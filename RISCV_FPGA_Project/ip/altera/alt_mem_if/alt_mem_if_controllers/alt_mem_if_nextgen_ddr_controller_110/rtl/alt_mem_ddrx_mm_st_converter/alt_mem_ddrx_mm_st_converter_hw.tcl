# (C) 2001-2013 Altera Corporation. All rights reserved.
# Your use of Altera Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Altera Program License Subscription 
# Agreement, Altera MegaCore Function License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Altera and sold by 
# Altera or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# TCL File Generated by Component Editor 11.0
# Thu Oct 07 16:58:41 EDT 2010
# DO NOT MODIFY

# +-----------------------------------
# Required header to put the alt_mem_if TCL packages on the TCL path
set alt_mem_if_tcl_libs_dir "$env(QUARTUS_ROOTDIR)/../ip/altera/alt_mem_if/alt_mem_if_tcl_packages"
if {[lsearch -exact $auto_path $alt_mem_if_tcl_libs_dir] == -1} {
	lappend auto_path $alt_mem_if_tcl_libs_dir
}
# +-----------------------------------

# +-----------------------------------
# | request TCL package from ACDS 12.0
# | 
package require -exact qsys 12.0

# Require alt_mem_if TCL packages
package require alt_mem_if::util::messaging
package require alt_mem_if::util::profiling
package require alt_mem_if::util::hwtcl_utils
package require alt_mem_if::gen::uniphy_interfaces

# Function Imports
namespace import ::alt_mem_if::util::messaging::*

# | 
# +-----------------------------------

# +-----------------------------------
# | module alt_mem_ddrx_mm_st_converter
# | 
set_module_property DESCRIPTION "Altera Nextgen Memory Controller MM-ST Adapter"
set_module_property NAME alt_mem_ddrx_mm_st_converter
set_module_property VERSION 13.1
::alt_mem_if::util::hwtcl_utils::set_module_internal_mode
set_module_property OPAQUE_ADDRESS_MAP true
set_module_property GROUP [::alt_mem_if::util::hwtcl_utils::memory_controller_components_group_name]
set_module_property AUTHOR "Altera Corporation"
set_module_property DISPLAY_NAME "Altera Nextgen Memory Controller MM-ST Adapter"
set_module_property INSTANTIATE_IN_SYSTEM_MODULE true
set_module_property EDITABLE true
set_module_property ANALYZE_HDL TRUE
# | 
# +-----------------------------------


# +-----------------------------------
# | Fileset Callbacks
# | 
add_fileset sim_vhdl SIM_VHDL generate_vhdl_sim
set_fileset_property sim_vhdl TOP_LEVEL alt_mem_ddrx_mm_st_converter

add_fileset sim_verilog SIM_VERILOG generate_verilog_sim
set_fileset_property sim_verilog TOP_LEVEL alt_mem_ddrx_mm_st_converter

add_fileset synth QUARTUS_SYNTH generate_synth
set_fileset_property synth TOP_LEVEL alt_mem_ddrx_mm_st_converter

proc generate_verilog_fileset {} {

	# Input list of source files
	set source_files_list [list \
		alt_mem_ddrx_mm_st_converter.v \
	]

	# Return all files
	return $source_files_list
}
	

proc generate_vhdl_sim {name} {
	_dprint 1 "Preparing to generate Verilog simulation fileset for $name"

	set non_encryp_simulators [::alt_mem_if::util::hwtcl_utils::get_simulator_attributes 1]

	foreach file_name [generate_verilog_fileset] {
		_dprint 1 "Preparing to add $file_name"
		add_fileset_file $file_name [::alt_mem_if::util::hwtcl_utils::get_file_type $file_name 1 0] PATH $file_name $non_encryp_simulators
		add_fileset_file [file join mentor $file_name] [::alt_mem_if::util::hwtcl_utils::get_file_type $file_name 1 1] PATH [file join ".." ".." mentor rtl "alt_mem_ddrx_mm_st_converter" $file_name] {MENTOR_SPECIFIC}
	}
}
	
proc generate_verilog_sim {name} {
	_dprint 1 "Preparing to generate Verilog simulation fileset for $name"

	foreach file_name [generate_verilog_fileset] {
		_dprint 1 "Preparing to add $file_name"
		add_fileset_file $file_name [::alt_mem_if::util::hwtcl_utils::get_file_type $file_name] PATH $file_name
	}
}

proc generate_synth {name} {
	_dprint 1 "Preparing to generate synthesis fileset for $name"

	foreach file_name [generate_verilog_fileset] {
		_dprint 1 "Preparing to add $file_name"
		add_fileset_file $file_name [::alt_mem_if::util::hwtcl_utils::get_file_type $file_name] PATH $file_name
	}
}

# | 
# +-----------------------------------



# +-----------------------------------
# | parameters
# | 
add_parameter AVL_SIZE_WIDTH INTEGER 3
set_parameter_property AVL_SIZE_WIDTH UNITS None
set_parameter_property AVL_SIZE_WIDTH ALLOWED_RANGES 0:1024
set_parameter_property AVL_SIZE_WIDTH HDL_PARAMETER true

add_parameter AVL_ADDR_WIDTH INTEGER 25
set_parameter_property AVL_ADDR_WIDTH UNITS None
set_parameter_property AVL_ADDR_WIDTH ALLOWED_RANGES 0:1024
set_parameter_property AVL_ADDR_WIDTH HDL_PARAMETER true

add_parameter AVL_DATA_WIDTH INTEGER 32
set_parameter_property AVL_DATA_WIDTH UNITS None
set_parameter_property AVL_DATA_WIDTH ALLOWED_RANGES 0:2048
set_parameter_property AVL_DATA_WIDTH HDL_PARAMETER true

add_parameter LOCAL_ID_WIDTH INTEGER 8
set_parameter_property LOCAL_ID_WIDTH UNITS None
set_parameter_property LOCAL_ID_WIDTH ALLOWED_RANGES 0:1024
set_parameter_property LOCAL_ID_WIDTH HDL_PARAMETER true

add_parameter CFG_DWIDTH_RATIO INTEGER 4
set_parameter_property CFG_DWIDTH_RATIO UNITS None
set_parameter_property CFG_DWIDTH_RATIO ALLOWED_RANGES 0:1024
set_parameter_property CFG_DWIDTH_RATIO HDL_PARAMETER true

add_parameter MAX_PENDING_READ_TRANSACTION INTEGER 16
set_parameter_property MAX_PENDING_READ_TRANSACTION UNITS None
set_parameter_property MAX_PENDING_READ_TRANSACTION ALLOWED_RANGES 0:1024

add_parameter AVL_SYMBOL_WIDTH INTEGER 8
set_parameter_property AVL_SYMBOL_WIDTH UNITS None
set_parameter_property AVL_SYMBOL_WIDTH ALLOWED_RANGES 0:1024

add_parameter AVL_NUM_SYMBOLS INTEGER 1
set_parameter_property AVL_NUM_SYMBOLS UNITS None
set_parameter_property AVL_NUM_SYMBOLS DERIVED true

add_parameter AVL_BYTE_ENABLE BOOLEAN false
set_parameter_property AVL_BYTE_ENABLE UNITS None

add_parameter CTL_AUTOPCH_EN BOOLEAN false
set_parameter_property CTL_AUTOPCH_EN UNITS None

add_parameter MULTICAST_EN BOOLEAN false
set_parameter_property MULTICAST_EN UNITS None

add_parameter ENABLE_CTRL_AVALON_INTERFACE BOOLEAN false
set_parameter_property ENABLE_CTRL_AVALON_INTERFACE UNITS None

add_parameter CTL_ECC_ENABLED BOOLEAN false
set_parameter_property CTL_ECC_ENABLED UNITS None

# | 
# +-----------------------------------

# +-----------------------------------
# | Elaboration/validation callbacks
# | 
if {[string compare -nocase [::alt_mem_if::util::hwtcl_utils::combined_callbacks] "false"] == 0} {
	set_module_property Validation_Callback ip_validate
	set_module_property elaboration_Callback ip_elaborate
} else {
	set_module_property elaboration_Callback combined_callback
}

proc combined_callback {} {
	ip_validate
	ip_elaborate
}

proc ip_validate {} {
	_dprint 1 "Running IP Validation"
	
	set num_symbols [expr {[get_parameter_value AVL_DATA_WIDTH] / [get_parameter_value AVL_SYMBOL_WIDTH]}]
	set_parameter_value AVL_NUM_SYMBOLS $num_symbols
	
	if {$num_symbols * [get_parameter_value AVL_SYMBOL_WIDTH] != [get_parameter_value AVL_DATA_WIDTH]} {
		_eprint "Symbol size is not a multiple of the data width"
	}
	
	# Currently the RTL only supports a symbol width of 8. Enforce that here
	if {[get_parameter_value AVL_SYMBOL_WIDTH] != 8} {
		_error "Only symbol width of 8 is currently suppoted"
	}
}


proc ip_elaborate {} {
	_dprint 1 "Running IP Elaboration"


	# +-----------------------------------
	# | connection point afi_clk
	# | 
	add_interface afi_clk clock end
	set_interface_property afi_clk clockRate 0
	
	set_interface_property afi_clk ENABLED true
	
	add_interface_port afi_clk ctl_clk clk Input 1
	# | 
	# +-----------------------------------
	
	# +-----------------------------------
	# | connection point afi_reset_n
	# | 
	add_interface afi_reset reset end
	set_interface_property afi_reset synchronousEdges NONE
	
	set_interface_property afi_reset ENABLED true
	
	add_interface_port afi_reset ctl_reset_n reset_n Input 1
	# | 
	# +-----------------------------------
	
	# +-----------------------------------
	# | connection point afi_half_clk
	# | 
	add_interface afi_half_clk clock end
	set_interface_property afi_half_clk clockRate 0
	
	set_interface_property afi_half_clk ENABLED true
	
	add_interface_port afi_half_clk ctl_half_clk clk Input 1
	# | 
	# +-----------------------------------
	
	# +-----------------------------------
	# | connection point afi_half_reset_n
	# | 
	add_interface afi_half_reset reset end
	set_interface_property afi_half_reset synchronousEdges NONE
	
	set_interface_property afi_half_reset ENABLED true
	
	add_interface_port afi_half_reset ctl_half_clk_reset_n reset_n Input 1
	# | 
	# +-----------------------------------

	# +-----------------------------------
	# | connection point avl
	# | 
	if {[string compare -nocase [get_parameter_value ENABLE_CTRL_AVALON_INTERFACE] "true"] == 0} {
		add_interface avl avalon end
		set_interface_property avl ENABLED true
		set_interface_property avl addressUnits WORDS
		set_interface_property avl associatedClock afi_clk
		set_interface_property avl associatedReset afi_reset
		set_interface_property avl bitsPerSymbol [get_parameter_value AVL_SYMBOL_WIDTH]
		set_interface_property avl addressAlignment DYNAMIC
		# Specify that the Avalon-MM interface is a memory device for use
		# with NIOS. The value must be "1"
		set_interface_property avl isMemoryDevice 1
	
		set_interface_property avl maximumPendingReadTransactions [get_parameter_value MAX_PENDING_READ_TRANSACTION]

		# allow the address and burstcount to be passed straight through the Merlin translators
		# rather than re-derived unnecessarily. This in fact matches the Avalon spec where it is
		# assumed that the address must only be valid at the beginning of the burst
		set_interface_property avl constantBurstBehavior false
	
	} else {
		add_interface avl conduit end
	}

	add_interface_port avl avl_ready waitrequest_n Output 1
	add_interface_port avl avl_burstbegin beginbursttransfer Input 1
	add_interface_port avl avl_addr address Input [get_parameter_value AVL_ADDR_WIDTH]
	add_interface_port avl avl_rdata_valid readdatavalid Output 1
	add_interface_port avl avl_rdata readdata Output [get_parameter_value AVL_DATA_WIDTH]
	add_interface_port avl avl_wdata writedata Input [get_parameter_value AVL_DATA_WIDTH]
	add_interface_port avl avl_be byteenable Input [get_parameter_value AVL_NUM_SYMBOLS]
	set_port_property avl_be VHDL_TYPE STD_LOGIC_VECTOR
	add_interface_port avl avl_read_req read Input 1
	add_interface_port avl avl_write_req write Input 1
	add_interface_port avl avl_size burstcount Input [get_parameter_value AVL_SIZE_WIDTH]

	if {[string compare -nocase [get_parameter_value AVL_BYTE_ENABLE] "true"] == 0} {
		set_port_property avl_be termination false
	} else {
		set_port_property avl_be termination true
		# assign all pins logical 1
		set_port_property avl_be termination_value "[get_parameter_value AVL_NUM_SYMBOLS]\'b[string repeat 1 [get_parameter_value AVL_NUM_SYMBOLS]]"
	}
	# | 
	# +-----------------------------------
	
	
	# +-----------------------------------
	# | connection point multicast
	# | 
	add_interface avl_multicast_write conduit end
	set_interface_property avl_multicast_write ENABLED true
	add_interface_port avl_multicast_write local_multicast local_multicast Input 1
	# Set termination on the interface as appropriate
	if {[string compare -nocase [get_parameter_value MULTICAST_EN] "true"] == 0} {
		::alt_mem_if::util::hwtcl_utils::set_interface_termination avl_multicast_write 1
	} else {
		::alt_mem_if::util::hwtcl_utils::set_interface_termination avl_multicast_write 0
	}
	
	
	# | 
	# +-----------------------------------
	
	# +-----------------------------------
	# | connection point autopch
	# | 
	add_interface autoprecharge_req conduit end
	set_interface_property autoprecharge_req ENABLED true
	add_interface_port autoprecharge_req local_autopch_req local_autopch_req Input 1
	# Set termination on the interface as appropriate
	if {[string compare -nocase [get_parameter_value CTL_AUTOPCH_EN] "true"] == 0} {
		::alt_mem_if::util::hwtcl_utils::set_interface_termination autoprecharge_req 1
	} else {
		::alt_mem_if::util::hwtcl_utils::set_interface_termination autoprecharge_req 0
	}


	# | 
	# +-----------------------------------
	
	# +-----------------------------------
	# | connection point priority
	# | 
	add_interface priority conduit end
	set_interface_property priority ENABLED true
	add_interface_port priority local_priority local_priority Input 1
	set_port_property local_priority termination true
	set_port_property local_priority termination_value 0
	# | 
	# +-----------------------------------
	
	# +-----------------------------------
	# | connection point rdata_error
	# | 
        if {[string compare -nocase [get_parameter_value CTL_ECC_ENABLED] "true"] == 0} {
                add_interface avl_rdata_error conduit end
                set_interface_property avl_rdata_error ENABLED true
                add_interface_port avl_rdata_error local_rdata_error local_rdata_error Output 4
        }

	# | 
	# +-----------------------------------
	
	# +-----------------------------------
	# | connection point nextgen
	# | 
	::alt_mem_if::gen::uniphy_interfaces::create_nextgen_st_interface 0
	# | 
	# +-----------------------------------
}
