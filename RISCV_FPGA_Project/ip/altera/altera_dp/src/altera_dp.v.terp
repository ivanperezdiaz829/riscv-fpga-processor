// (C) 2001-2013 Altera Corporation. All rights reserved.
// Your use of Altera Corporation's design tools, logic functions and other 
// software and tools, and its AMPP partner logic functions, and any output 
// files any of the foregoing (including device programming or simulation 
// files), and any associated documentation or information are expressly subject 
// to the terms and conditions of the Altera Program License Subscription 
// Agreement, Altera MegaCore Function License Agreement, or other applicable 
// license agreement, including, without limitation, that your use is for the 
// sole purpose of programming logic devices manufactured by Altera and sold by 
// Altera or its authorized distributors.  Please refer to the applicable 
// agreement for further details.



// *********************************************************************
//
//
// DisplayPort IP Core
// 
// Description
// 
// Top level module for DisplayPort IP
// This module instantiates the Bitec DP core and the Custom PHY IP
// It should be delivered as clear text to allow users who need to customize 
// their XCVR implementation (for example to pack unrelated RX/TX simplex
// protocols)
//
// *********************************************************************


// synthesis translate_off
`timescale 1ps / 1ps
// synthesis translate_on
`default_nettype none

// top-level module name is autogenerated by Qsys to enable different
// parameterizations of the PHY IP 
module ${output_name} #(
	parameter device_family = "Stratix V",
	parameter EXTERNAL_TRANSCIEVERS = 1,	// Not supported
	parameter SIMULATION_LOOPBACK = 0,		// Not supported
	parameter RST_CNTR = 16,				// nominal 16/20  or 6 for fast simulation of reset seq

	parameter TX_SUPPORT_DP = 1,
	parameter TX_MAX_LINK_RATE = 10,
	parameter TX_MAX_LANE_COUNT = 4,
	parameter TX_SUPPORT_ANALOG_RECONFIG = 0,
	parameter TX_POLINV = 0,
	parameter TX_SCRAMBLER_SEED = 16'hffff,
	parameter TX_SCRAMBLER_ENABLE = 1,
	parameter TX_SUPPORT_SS = 1,
	parameter TX_PIXELS_PER_CLOCK = 1,						// replaces RX_ODD_EVEN_PIXEL
	parameter TX_SYMBOLS_PER_CLOCK = 2,
	parameter TX_SUPPORT_18BPP = 1,
	parameter TX_SUPPORT_24BPP = 1,
	parameter TX_SUPPORT_30BPP = 1,
	parameter TX_SUPPORT_36BPP = 1,
	parameter TX_SUPPORT_48BPP = 1,
	parameter TX_SUPPORT_YCBCR422_16BPP = 1,
	parameter TX_SUPPORT_YCBCR422_20BPP = 1,
	parameter TX_SUPPORT_YCBCR422_24BPP = 1,
	parameter TX_SUPPORT_YCBCR422_32BPP = 1,
	parameter TX_ENHANCED_FRAME = 1,
	parameter TX_SUPPORT_HDCP = 0,
	parameter TX_VIDEO_BPS = 16,							// Bitec renamed to TX_VIDEO_BPC
	parameter TX_IMPORT_MSA = 0,
	parameter TX_INTERLACED_VID = 0,
	parameter TX_SUPPORT_AUTOMATED_TEST = 0,
	parameter TX_AUX_DEBUG = 0,
	parameter TX_SUPPORT_AUDIO = 1,
	parameter TX_AUDIO_CHANS = 2,

	parameter RX_SUPPORT_DP = 1,
	parameter RX_MAX_LINK_RATE = 10,
	parameter RX_MAX_LANE_COUNT = 4,
	parameter RX_POLINV = 0,
	parameter RX_SCRAMBLER_SEED = 16'hffff,
	parameter RX_SCRAMBLER_ENABLE = 1,
	parameter RX_SUPPORT_SS = 1,
	parameter RX_PIXELS_PER_CLOCK = 1,						// replaces RX_ODD_EVEN_PIXEL
	parameter RX_SYMBOLS_PER_CLOCK = 2,
	parameter RX_IMAGE_OUT_FORMAT = 0,
	parameter RX_SUPPORT_AUTOMATED_TEST = 0,
	parameter RX_SUPPORT_18BPP = 1,
	parameter RX_SUPPORT_24BPP = 1,
	parameter RX_SUPPORT_30BPP = 1,
	parameter RX_SUPPORT_36BPP = 1,
	parameter RX_SUPPORT_48BPP = 1,
	parameter RX_SUPPORT_YCBCR422_16BPP = 1,
	parameter RX_SUPPORT_YCBCR422_20BPP = 1,
	parameter RX_SUPPORT_YCBCR422_24BPP = 1,
	parameter RX_SUPPORT_YCBCR422_32BPP = 1,
	parameter RX_ENHANCED_FRAME = 1,
	parameter RX_SUPPORT_HDCP = 0,
	parameter RX_VIDEO_BPS = 16,							// Bitec renamed to RX_VIDEO_BPC
	parameter RX_AUX_DEBUG = 0,
	parameter RX_IEEE_OUI = 1,
	parameter RX_AUX_GPU = 0,
	parameter RX_EXTERNAL_EDID = 1,
	parameter RX_EXPORT_MSA = 0,
	parameter RX_SUPPORT_AUDIO = 1,
	parameter RX_AUDIO_CHANS = 2,
	parameter RX_SUPPORT_MST = 0,
	parameter RX_MAX_NUM_OF_STREAMS = 1
)(
	//************************************************************************
	// Main clock domain
	//
	// Clock is clk, reset is reset
	//************************************************************************
	input  wire reset, 
	input  wire clk, 

	// Management interfaces
	
	// TX Avalon-MM slave (tx_mgmt)
	input  wire [8:0]	tx_mgmt_address,
	input  wire			tx_mgmt_chipselect,
	input  wire			tx_mgmt_read,
	input  wire			tx_mgmt_write,
	input  wire [31:0]	tx_mgmt_writedata,
	output wire [31:0]	tx_mgmt_readdata,
	output wire			tx_mgmt_waitrequest,
	output wire			tx_mgmt_irq,

	// RX Avalon-MM slave (rx_mgmt)
	input  wire [8:0]	rx_mgmt_address,
	input  wire			rx_mgmt_chipselect,
	input  wire			rx_mgmt_read,
	input  wire			rx_mgmt_write,
	input  wire [31:0]	rx_mgmt_writedata,
	output wire [31:0]	rx_mgmt_readdata,
	output wire			rx_mgmt_waitrequest,
	output wire			rx_mgmt_irq,

	//************************************************************************
	// XCVR Mgmt clock domain
	//
	// Clock is xcvr_mgmt_clk, reset is reset
	//************************************************************************
	input  wire			xcvr_mgmt_clk,	// 100 MHz
	input  wire [1:0]	xcvr_refclk,	// 162 MHz, 270 MHz

	output wire [TX_MAX_LANE_COUNT-1:0]	tx_serial_data, 
	input  wire [RX_MAX_LANE_COUNT-1:0]	rx_serial_data, 

	// TX XCVR reconfig interface (tx_reconfig)
	output wire [1:0]	tx_link_rate,
	output wire			tx_reconfig_req, 
	input  wire			tx_reconfig_ack, 
	input  wire			tx_reconfig_busy, 

	// TX Analog reconfig interface (tx_analog_reconfig)
	output wire [(TX_MAX_LANE_COUNT*2)-1:0]		tx_vod, 
	output wire [(TX_MAX_LANE_COUNT*2)-1:0]		tx_emp, 
	output wire									tx_analog_reconfig_req, 
	input  wire									tx_analog_reconfig_ack, 
	input  wire									tx_analog_reconfig_busy, 

	// RX XCVR reconfig interface (rx_reconfig)
	output wire [1:0]	rx_link_rate,
	output wire			rx_reconfig_req, 
	input  wire			rx_reconfig_ack, 
	input  wire			rx_reconfig_busy, 

	// XCVR reconfig IP interface (xcvr_reconfig)
	input  wire [(((RX_SUPPORT_DP==1)*RX_MAX_LANE_COUNT*70) + ((TX_SUPPORT_DP==1)*TX_MAX_LANE_COUNT*2*70))-1:0] reconfig_to_xcvr,
	output wire [(((RX_SUPPORT_DP==1)*RX_MAX_LANE_COUNT*46) + ((TX_SUPPORT_DP==1)*TX_MAX_LANE_COUNT*2*46))-1:0] reconfig_from_xcvr,

	//************************************************************************
        // RX FIFO overflow signals 
        //
        //************************************************************************

	output wire rx_vid_overflow,
	output wire rx1_vid_overflow,
	output wire rx2_vid_overflow,
	output wire rx3_vid_overflow,
	
	//************************************************************************
	// Video clock domain
	//
	// TX Clock is tx_vid_clk, reset is reset
	// RX Clock is rx_vid_clk, reset is reset
	//************************************************************************
	input wire tx_vid_clk,		// DP Source Pixel clock frequency

	// TX Video input (tx_video_in)
	input wire [(TX_VIDEO_BPS*3*TX_PIXELS_PER_CLOCK)-1:0] tx_vid_data,
	input wire [TX_PIXELS_PER_CLOCK-1:0] tx_vid_v_sync,
	input wire [TX_PIXELS_PER_CLOCK-1:0] tx_vid_h_sync,
	input wire [TX_PIXELS_PER_CLOCK-1:0] tx_vid_f,
	input wire [TX_PIXELS_PER_CLOCK-1:0] tx_vid_de,

	// RX video inputs have 4 duplicate interfaces for beta MST
	// support of 4 streams

	input wire rx_vid_clk,		// DP Sink Pixel clock frequency

	// RX Video output (rx_video_out)
	output wire [RX_PIXELS_PER_CLOCK-1:0] rx_vid_valid,
	output wire rx_vid_sol,
	output wire rx_vid_eol,
	output wire rx_vid_sof,
	output wire rx_vid_eof,
	output wire rx_vid_locked,
	output wire [(RX_VIDEO_BPS*3*RX_PIXELS_PER_CLOCK)-1:0] rx_vid_data,

	// (optional) RX Video output AV-ST (rx_video_out_st)
	input  wire rx_vid_st_ready,
	output wire rx_vid_st_valid,
	output wire [(RX_VIDEO_BPS*3*RX_PIXELS_PER_CLOCK)-1:0] rx_vid_st_data,
	output wire rx_vid_st_sop,
	output wire rx_vid_st_eop,
	input  wire rx_vid_st_reset,

	input wire rx1_vid_clk,		// DP Sink Pixel clock frequency

	// RX Video output (rx_video_out)
	output wire [RX_PIXELS_PER_CLOCK-1:0] rx1_vid_valid,
	output wire rx1_vid_sol,
	output wire rx1_vid_eol,
	output wire rx1_vid_sof,
	output wire rx1_vid_eof,
	output wire rx1_vid_locked,
	output wire [(RX_VIDEO_BPS*3*RX_PIXELS_PER_CLOCK)-1:0] rx1_vid_data,

	// (optional) RX Video output AV-ST (rx_video_out_st)
	input  wire rx1_vid_st_ready,
	output wire rx1_vid_st_valid,
	output wire [(RX_VIDEO_BPS*3*RX_PIXELS_PER_CLOCK)-1:0] rx1_vid_st_data,
	output wire rx1_vid_st_sop,
	output wire rx1_vid_st_eop,
	input  wire rx1_vid_st_reset,

	input wire rx2_vid_clk,		// DP Sink Pixel clock frequency

	// RX Video output (rx_video_out)
	output wire [RX_PIXELS_PER_CLOCK-1:0] rx2_vid_valid,
	output wire rx2_vid_sol,
	output wire rx2_vid_eol,
	output wire rx2_vid_sof,
	output wire rx2_vid_eof,
	output wire rx2_vid_locked,
	output wire [(RX_VIDEO_BPS*3*RX_PIXELS_PER_CLOCK)-1:0] rx2_vid_data,

	// (optional) RX Video output AV-ST (rx_video_out_st)
	input  wire rx2_vid_st_ready,
	output wire rx2_vid_st_valid,
	output wire [(RX_VIDEO_BPS*3*RX_PIXELS_PER_CLOCK)-1:0] rx2_vid_st_data,
	output wire rx2_vid_st_sop,
	output wire rx2_vid_st_eop,
	input  wire rx2_vid_st_reset,

	input wire rx3_vid_clk,		// DP Sink Pixel clock frequency

	// RX Video output (rx_video_out)
	output wire [RX_PIXELS_PER_CLOCK-1:0] rx3_vid_valid,
	output wire rx3_vid_sol,
	output wire rx3_vid_eol,
	output wire rx3_vid_sof,
	output wire rx3_vid_eof,
	output wire rx3_vid_locked,
	output wire [(RX_VIDEO_BPS*3*RX_PIXELS_PER_CLOCK)-1:0] rx3_vid_data,

	// (optional) RX Video output AV-ST (rx_video_out_st)
	input  wire rx3_vid_st_ready,
	output wire rx3_vid_st_valid,
	output wire [(RX_VIDEO_BPS*3*RX_PIXELS_PER_CLOCK)-1:0] rx3_vid_st_data,
	output wire rx3_vid_st_sop,
	output wire rx3_vid_st_eop,
	input  wire rx3_vid_st_reset,

	//************************************************************************
	// AUX clock domain
	//
	// Clock is aux_clk, reset is aux_reset
	//************************************************************************
	input wire aux_reset,
	input wire aux_clk,		// 16 MHz

	// TX AUX channel physical signals (tx_aux)
	input  wire tx_aux_in,
	output wire tx_aux_out, 
	output wire tx_aux_oe,
	input  wire tx_hpd,

	// TX AUX Debug (AV-ST) sinks are designed to interface to Nios 32-bit bus via DC FIFO (tx_aux_debug)
	output wire [31:0] tx_aux_debug_data,
	output wire tx_aux_debug_valid,
	output wire tx_aux_debug_sop, 
	output wire tx_aux_debug_eop, 
	output wire tx_aux_debug_err,
	output wire tx_aux_debug_cha,

	// RX AUX channel physical signals (rx_aux)
	input  wire rx_aux_in,
	output wire rx_aux_out, 
	output wire rx_aux_oe,
	output wire rx_hpd,
	input  wire rx_cable_detect,
	input  wire rx_pwr_detect,

	// RX AUX Debug (AV-ST) sinks are designed to interface to Nios 32-bit bus via DC FIFO (rx_aux_debug)
	output wire [31:0]  rx_aux_debug_data,
	output wire rx_aux_debug_valid,
	output wire rx_aux_debug_sop, 
	output wire rx_aux_debug_eop, 
	output wire rx_aux_debug_err,
	output wire rx_aux_debug_cha,

	// RX EDID ROM interface (AV-MM) rx_edid
	output wire [7:0] rx_edid_address,
	output wire rx_edid_read,
	output wire rx_edid_write,
	output wire [7:0] rx_edid_writedata,
	input  wire [7:0] rx_edid_readdata,
	input  wire rx_edid_waitrequest,

	//************************************************************************
	// Debug domain (RX link status data)
	//
	// Clock and reset are a mixture, should be used for debug not design
	//************************************************************************
	output wire [4:0] rx_lane_count,

	// Top level RX post scrambler signals & recovered clock for each
	// stream
	output wire [4*8*RX_SYMBOLS_PER_CLOCK-1:0] rx_stream_data,
	output wire [4*1*RX_SYMBOLS_PER_CLOCK-1:0]  rx_stream_ctrl,
	output wire rx_stream_valid,
	output wire rx_stream_clk,

	output wire [4*8*RX_SYMBOLS_PER_CLOCK-1:0] rx1_stream_data,
	output wire [4*1*RX_SYMBOLS_PER_CLOCK-1:0]  rx1_stream_ctrl,
	output wire rx1_stream_valid,
	output wire rx1_stream_clk,

	output wire [4*8*RX_SYMBOLS_PER_CLOCK-1:0] rx2_stream_data,
	output wire [4*1*RX_SYMBOLS_PER_CLOCK-1:0]  rx2_stream_ctrl,
	output wire rx2_stream_valid,
	output wire rx2_stream_clk,

	output wire [4*8*RX_SYMBOLS_PER_CLOCK-1:0] rx3_stream_data,
	output wire [4*1*RX_SYMBOLS_PER_CLOCK-1:0]  rx3_stream_ctrl,
	output wire rx3_stream_valid,
	output wire rx3_stream_clk,

	//************************************************************************
	// Secondary data domain 
	//
	// Clock is mainly TX/RX XCVR recovered clock, but some domains have 
	// their own clock. Reset is reset
	//************************************************************************
	output wire tx_xcvr_clkout,		// 81 MHz or 135 MHz
	output wire rx_xcvr_clkout,		// 81 MHz or 135 MHz

	// MSA Domain per stream
	input  wire [191:0] tx_msa,
	output wire [216:0] rx_msa,
	output wire [216:0] rx1_msa,
	output wire [216:0] rx2_msa,
	output wire [216:0] rx3_msa,

	// SS Domain

	// TX SS Data (AV-ST) (tx_ss)
	input  wire [127:0] tx_ss_data,
	input  wire tx_ss_valid,
	output wire tx_ss_ready,
	input  wire tx_ss_sop,
	input  wire tx_ss_eop,

	// RX SS Data (AV-ST) (rx_ss) one per stream
	output wire [159:0] rx_ss_data,
	output wire rx_ss_valid,
	output wire rx_ss_sop,
	output wire rx_ss_eop,

	output wire [159:0] rx1_ss_data,
	output wire rx1_ss_valid,
	output wire rx1_ss_sop,
	output wire rx1_ss_eop,
	
	output wire [159:0] rx2_ss_data,
	output wire rx2_ss_valid,
	output wire rx2_ss_sop,
	output wire rx2_ss_eop,

	output wire [159:0] rx3_ss_data,
	output wire rx3_ss_valid,
	output wire rx3_ss_sop,
	output wire rx3_ss_eop,

	// Audio Domain
	// TX Audio data (tx_audio)
	input wire tx_audio_clk,		// 44 KHz
	input wire [TX_AUDIO_CHANS*32-1:0] tx_audio_lpcm_data,
	input wire tx_audio_valid,
	input wire tx_audio_mute,

	// RX Audio data (rx_audio) per stream
	output wire [RX_AUDIO_CHANS*32-1:0] rx_audio_lpcm_data,
	output wire rx_audio_valid,
	output wire rx_audio_mute,
	output wire [39:0] rx_audio_infoframe,

	output wire [RX_AUDIO_CHANS*32-1:0] rx1_audio_lpcm_data,
	output wire rx1_audio_valid,
	output wire rx1_audio_mute,
	output wire [39:0] rx1_audio_infoframe,

	output wire [RX_AUDIO_CHANS*32-1:0] rx2_audio_lpcm_data,
	output wire rx2_audio_valid,
	output wire rx2_audio_mute,
	output wire [39:0] rx2_audio_infoframe,

	output wire [RX_AUDIO_CHANS*32-1:0] rx3_audio_lpcm_data,
	output wire rx3_audio_valid,
	output wire rx3_audio_mute,
	output wire [39:0] rx3_audio_infoframe,

	// HDCP domain
	// TX HDCP (tx_hdcp) using main clock clk
	input  wire [55:0] tx_hdcp_akeys_dat,
	output wire [6:0]  tx_hdcp_akeys_sel,
	input  wire [39:0] tx_hdcp_akeys_ksv,

	// RX HDCP (rx_hdcp) using AUX clock aux_clk
	input  wire [55:0] rx_hdcp_bkeys_dat,
	output wire [6:0]  rx_hdcp_bkeys_sel,
	input  wire [39:0] rx_hdcp_bkeys_ksv
);
	// Wires connecting DP to PHY IP
	// XCVR data interface can now be 2 symbols or 4 symbols (20-bit
	// or 40-bit wide)
	wire [(1 + TX_MAX_LANE_COUNT + TX_MAX_LANE_COUNT*10*TX_SYMBOLS_PER_CLOCK)-1:0] conduit_to_gxb_tx;
	wire [(TX_MAX_LANE_COUNT + 1)-1:0] conduit_from_gxb_tx;

	// XCVR data interface can now be 2 symbols or 4 symbols (20-bit
	// or 40-bit wide)
	wire [(RX_MAX_LANE_COUNT + RX_MAX_LANE_COUNT + RX_MAX_LANE_COUNT + 1 + RX_MAX_LANE_COUNT + RX_MAX_LANE_COUNT) -1:0] conduit_to_gxb_rx;
	wire [(RX_MAX_LANE_COUNT + RX_MAX_LANE_COUNT + RX_MAX_LANE_COUNT + 10*RX_SYMBOLS_PER_CLOCK*RX_MAX_LANE_COUNT)-1:0] conduit_from_gxb_rx;

	// emp_lane3..emp_lane0, vod_lane3..vod_lane0, tx_link_rate,
	// reconfig_link_rate_req, reconfig_analog_req
	wire [(2*TX_MAX_LANE_COUNT + 2*TX_MAX_LANE_COUNT + 2 + 2)-1:0] conduit_to_tx_reconfig;
	wire [0:0] conduit_from_tx_reconfig;

	// rx_link_rate, reconfig_link_rate_req
	wire [(2 + 1)-1:0] conduit_to_rx_reconfig;
	wire [0:0] conduit_from_rx_reconfig;

	// Wires connecting to the TX PHY IP to DP
	wire [TX_MAX_LANE_COUNT-1:0]		pll_powerdown; 
	wire [TX_MAX_LANE_COUNT-1:0]		tx_analogreset;
	wire [TX_MAX_LANE_COUNT-1:0]		tx_digitalreset;
	wire [TX_MAX_LANE_COUNT-1:0]		btc_tx_digitalreset;
	wire [TX_MAX_LANE_COUNT-1:0]		pll_locked;
	wire [TX_MAX_LANE_COUNT-1:0]		tx_clkout;
	wire [TX_MAX_LANE_COUNT-1:0]		tx_cal_busy;
	wire [(TX_MAX_LANE_COUNT*10*TX_SYMBOLS_PER_CLOCK)-1:0]	tx_parallel_data;

	// Wires connecting to the RX PHY IP to DP
	wire [RX_MAX_LANE_COUNT-1:0]		rx_analogreset;
	wire [RX_MAX_LANE_COUNT-1:0]		btc_rx_analogreset;
	wire [RX_MAX_LANE_COUNT-1:0]		rx_digitalreset;
	wire [RX_MAX_LANE_COUNT-1:0]		btc_rx_digitalreset;
	wire [RX_MAX_LANE_COUNT-1:0]		rx_set_locktoref;
	wire [RX_MAX_LANE_COUNT-1:0]		rx_set_locktodata;
	wire [RX_MAX_LANE_COUNT-1:0]		rx_is_lockedtoref;
	wire [RX_MAX_LANE_COUNT-1:0]		rx_is_lockedtodata;
	wire [RX_MAX_LANE_COUNT-1:0]		rx_clkout;
	wire [RX_MAX_LANE_COUNT-1:0]		rx_bitslip;
	wire [RX_MAX_LANE_COUNT-1:0]		rx_cal_busy;
	wire [(RX_MAX_LANE_COUNT*10*RX_SYMBOLS_PER_CLOCK)-1:0]	rx_parallel_data;

	// Wires connecting to the TX Reconfig mgmt logic to DP
	wire								btc_tx_analog_reconfig_req;
	wire								btc_tx_reconfig_req;
	wire [1:0]							btc_tx_link_rate;
	wire [(TX_MAX_LANE_COUNT*2)-1:0]	btc_tx_vod;
	wire [(TX_MAX_LANE_COUNT*2)-1:0]	btc_tx_emp; 

	// Wires connecting to the RX Reconfig mgmt logic to DP
	wire								btc_rx_reconfig_req;
	wire [1:0]							btc_rx_link_rate;

	bitec_dp #(
		// Pass paramters
		.EXTERNAL_TRANSCIEVERS(EXTERNAL_TRANSCIEVERS),
		.TX_MAX_LINK_RATE(TX_MAX_LINK_RATE),
		.TX_MAX_LANE_COUNT(TX_MAX_LANE_COUNT),
		.TX_SCRAMBLER_SEED(TX_SCRAMBLER_SEED),
		.TX_SCRAMBLER_ENABLE(TX_SCRAMBLER_ENABLE),
		.TX_SUPPORT_SS(TX_SUPPORT_SS),
		.TX_PIXELS_PER_CLOCK(TX_PIXELS_PER_CLOCK),			// replaces TX_ODD_EVEN_PIXEL
		.TX_SYMBOLS_PER_CLOCK(TX_SYMBOLS_PER_CLOCK),

		.TX_SUPPORT_18BPP(TX_SUPPORT_18BPP),
		.TX_SUPPORT_24BPP(TX_SUPPORT_24BPP),
		.TX_SUPPORT_30BPP(TX_SUPPORT_30BPP),
		.TX_SUPPORT_36BPP(TX_SUPPORT_36BPP),
		.TX_SUPPORT_48BPP(TX_SUPPORT_48BPP),
		.TX_SUPPORT_YCBCR422_16BPP(TX_SUPPORT_YCBCR422_16BPP),
		.TX_SUPPORT_YCBCR422_20BPP(TX_SUPPORT_YCBCR422_20BPP),
		.TX_SUPPORT_YCBCR422_24BPP(TX_SUPPORT_YCBCR422_24BPP),
		.TX_SUPPORT_YCBCR422_32BPP(TX_SUPPORT_YCBCR422_32BPP),
		.TX_ENHANCED_FRAME(TX_ENHANCED_FRAME),
		.TX_SUPPORT_DP(TX_SUPPORT_DP),
		.TX_SUPPORT_HDCP(TX_SUPPORT_HDCP),
		.TX_VIDEO_BPC(TX_VIDEO_BPS),						// renamed in 40-bit code
		.TX_IMPORT_MSA(TX_IMPORT_MSA),
		.TX_INTERLACED_VID(TX_INTERLACED_VID),
		.TX_SUPPORT_AUTOMATED_TEST(TX_SUPPORT_AUTOMATED_TEST),
		.TX_AUX_DEBUG(TX_AUX_DEBUG),

		.RX_MAX_LINK_RATE(RX_MAX_LINK_RATE),
		.RX_MAX_LANE_COUNT(RX_MAX_LANE_COUNT),
		.RX_SCRAMBLER_SEED(RX_SCRAMBLER_SEED),
		.RX_SCRAMBLER_ENABLE(RX_SCRAMBLER_ENABLE),
		.RX_SUPPORT_SS(RX_SUPPORT_SS),
		.RX_PIXELS_PER_CLOCK(RX_PIXELS_PER_CLOCK),			// replaces RX_ODD_EVEN_PIXEL
		.RX_SYMBOLS_PER_CLOCK(RX_SYMBOLS_PER_CLOCK),
		.RX_IMAGE_OUT_FORMAT(RX_IMAGE_OUT_FORMAT),
		.RX_SUPPORT_AUTOMATED_TEST(RX_SUPPORT_AUTOMATED_TEST),

		.RX_SUPPORT_18BPP(RX_SUPPORT_18BPP),
		.RX_SUPPORT_24BPP(RX_SUPPORT_24BPP),
		.RX_SUPPORT_30BPP(RX_SUPPORT_30BPP),
		.RX_SUPPORT_36BPP(RX_SUPPORT_36BPP),
		.RX_SUPPORT_48BPP(RX_SUPPORT_48BPP),
		.RX_SUPPORT_YCBCR422_16BPP(RX_SUPPORT_YCBCR422_16BPP),
		.RX_SUPPORT_YCBCR422_20BPP(RX_SUPPORT_YCBCR422_20BPP),
		.RX_SUPPORT_YCBCR422_24BPP(RX_SUPPORT_YCBCR422_24BPP),
		.RX_SUPPORT_YCBCR422_32BPP(RX_SUPPORT_YCBCR422_32BPP),
		.RX_ENHANCED_FRAME(RX_ENHANCED_FRAME),
		.RX_SUPPORT_DP(RX_SUPPORT_DP),
		.RX_SUPPORT_HDCP(RX_SUPPORT_HDCP),
		.RX_VIDEO_BPC(RX_VIDEO_BPS),						// renamed in 40-bit code

		.RX_AUX_DEBUG(RX_AUX_DEBUG),
		.RX_IEEE_OUI(RX_IEEE_OUI),
		.RX_AUX_GPU(RX_AUX_GPU),
		.RX_EXTERNAL_EDID(RX_EXTERNAL_EDID),
		.RX_EXPORT_MSA(RX_EXPORT_MSA),

		.SIMULATION_LOOPBACK(SIMULATION_LOOPBACK),

		.TX_SUPPORT_AUDIO(TX_SUPPORT_AUDIO),
		.TX_AUDIO_CHANS(TX_AUDIO_CHANS),

		.RX_SUPPORT_AUDIO(RX_SUPPORT_AUDIO),
		.RX_AUDIO_CHANS(RX_AUDIO_CHANS),

		.RX_SUPPORT_MST(RX_SUPPORT_MST),
		.RX_MAX_NUM_OF_STREAMS(RX_MAX_NUM_OF_STREAMS)
	) bitec_dp_inst (
	// Common signals
		.reset_av (reset), 
		.clk_av (clk), 

		.clk_16 (aux_clk),
		.reset_16 (aux_reset),

		.clk_cal (xcvr_mgmt_clk),

		.conduit_to_gxb_tx (conduit_to_gxb_tx),
		.conduit_from_gxb_tx (conduit_from_gxb_tx),
		
		.conduit_to_gxb_rx (conduit_to_gxb_rx),
		.conduit_from_gxb_rx (conduit_from_gxb_rx),

		// Bitec now spliting the reconfig conduits
		.conduit_to_tx_reconfig (conduit_to_tx_reconfig),
		.conduit_from_tx_reconfig (conduit_from_tx_reconfig),
		.conduit_to_rx_reconfig (conduit_to_rx_reconfig),
		.conduit_from_rx_reconfig (conduit_from_rx_reconfig),

		// Input video interface
		.tx0_vid_vsync (tx_vid_v_sync),
		.tx0_vid_hsync (tx_vid_h_sync),
		.tx0_vid_data (tx_vid_data),
		.tx0_vid_de (tx_vid_de),   
		.tx0_vid_f (tx_vid_f),
		.tx0_vid_clk (tx_vid_clk),

		// TX AUX channel physical signals
		.tx_aux_in (tx_aux_in),
		.tx_aux_out (tx_aux_out), 
		.tx_aux_oe (tx_aux_oe),
		.tx_hpd (tx_hpd),

		// RX AUX channel physical signals
		.rx_aux_in (rx_aux_in),
		.rx_aux_out (rx_aux_out), 
		.rx_aux_oe (rx_aux_oe),
		.rx_hpd (rx_hpd),
		.rx_cable_detect(rx_cable_detect),
		.rx_pwr_detect(rx_pwr_detect),

		// TX Avalon Slave
		.av_tx_control_address (tx_mgmt_address),
		.av_tx_control_chipselect (tx_mgmt_chipselect),
		.av_tx_control_read (tx_mgmt_read),
		.av_tx_control_write (tx_mgmt_write),
		.av_tx_control_writedata (tx_mgmt_writedata),
		.av_tx_control_readdata (tx_mgmt_readdata),
		.av_tx_control_waitrequest (tx_mgmt_waitrequest),
		.av_tx_control_irq (tx_mgmt_irq),
		
		// RX Avalon slave
		.av_rx_control_chipselect (rx_mgmt_chipselect),
		.av_rx_control_read (rx_mgmt_read),
		.av_rx_control_write (rx_mgmt_write),
		.av_rx_control_address (rx_mgmt_address),
		.av_rx_control_writedata (rx_mgmt_writedata),
		.av_rx_control_readdata (rx_mgmt_readdata),
		.av_rx_control_waitrequest (rx_mgmt_waitrequest),
		.av_rx_control_irq (rx_mgmt_irq),

		// RX AUX debug stream
		.aux_rx_debug_st_data (rx_aux_debug_data),
		.aux_rx_debug_st_valid (rx_aux_debug_valid),
		.aux_rx_debug_st_sop (rx_aux_debug_sop),
		.aux_rx_debug_st_eop (rx_aux_debug_eop), 
		.aux_rx_debug_st_err (rx_aux_debug_err),
		.aux_rx_debug_st_cha (rx_aux_debug_cha),
		.aux_rx_debug_st_emp (),						// Unnecessary since 11.1

		// TX AUX debug stream
		.aux_tx_debug_st_data (tx_aux_debug_data),
		.aux_tx_debug_st_valid (tx_aux_debug_valid),
		.aux_tx_debug_st_sop (tx_aux_debug_sop),
		.aux_tx_debug_st_eop (tx_aux_debug_eop), 
		.aux_tx_debug_st_err (tx_aux_debug_err),
		.aux_tx_debug_st_cha (tx_aux_debug_cha),
		.aux_tx_debug_st_emp (),						// Unnecessary since 11.1


		// RX Status signals
		.rx_lane_count (rx_lane_count),
		
		// TX Secondary Stream data
		.tx_ss_clk (tx_xcvr_clkout),
		.tx0_ss_data (tx_ss_data),
		.tx0_ss_valid (tx_ss_valid),
		.tx0_ss_ready (tx_ss_ready),
		.tx0_ss_sop (tx_ss_sop),
		.tx0_ss_eop (tx_ss_eop),

		// RX external EDID
		.rx_edid_addr (rx_edid_address),
		.rx_edid_readdata (rx_edid_readdata),
		.rx_edid_writedata (rx_edid_writedata),
		.rx_edid_ren (rx_edid_read),
		.rx_edid_wen (rx_edid_write),
		.rx_edid_waitrequest (rx_edid_waitrequest),

		// TX MSA data
		.tx0_msa (tx_msa),

		// TX and RX HDCP keys
		.hdcp_bkeys_dat (rx_hdcp_bkeys_dat),
		.hdcp_bkeys_sel (rx_hdcp_bkeys_sel),
		.hdcp_bkeys_ksv (rx_hdcp_bkeys_ksv),

		.hdcp_akeys_dat (tx_hdcp_akeys_dat),
		.hdcp_akeys_sel (tx_hdcp_akeys_sel),
		.hdcp_akeys_ksv (tx_hdcp_akeys_ksv),

		// TX Audio data
		.tx0_audio_clk (tx_audio_clk),
		.tx0_audio_lpcm_data (tx_audio_lpcm_data),
		.tx0_audio_valid (tx_audio_valid), 
		.tx0_audio_mute (tx_audio_mute),

		// ---- RX Stream specific signals -----
  
		// Output Video Interface
		.rx0_st_ready(rx_vid_st_ready),
		.rx0_st_valid(rx_vid_st_valid), 
		.rx0_st_data(rx_vid_st_data),
		.rx0_st_sop(rx_vid_st_sop),
		.rx0_st_eop(rx_vid_st_eop),
		.rx0_st_clk(rx_vid_clk),
		.rx0_st_reset(rx_vid_st_reset),			
		.rx1_st_ready(rx1_vid_st_ready),
		.rx1_st_valid(rx1_vid_st_valid), 
		.rx1_st_data(rx1_vid_st_data),
		.rx1_st_sop(rx1_vid_st_sop),
		.rx1_st_eop(rx1_vid_st_eop),
		.rx1_st_clk(rx1_vid_clk),
		.rx1_st_reset(rx1_vid_st_reset),			
		.rx2_st_ready(rx2_vid_st_ready),
		.rx2_st_valid(rx2_vid_st_valid), 
		.rx2_st_data(rx2_vid_st_data),
		.rx2_st_sop(rx2_vid_st_sop),
		.rx2_st_eop(rx2_vid_st_eop),
		.rx2_st_clk(rx2_vid_clk),
		.rx2_st_reset(rx2_vid_st_reset),
		.rx3_st_ready(rx3_vid_st_ready),
		.rx3_st_valid(rx3_vid_st_valid), 
		.rx3_st_data(rx3_vid_st_data),
		.rx3_st_sop(rx3_vid_st_sop),
		.rx3_st_eop(rx3_vid_st_eop),
		.rx3_st_clk(rx3_vid_clk),
		.rx3_st_reset(rx3_vid_st_reset),			

		.rx0_im_valid(rx_vid_valid),
		.rx0_im_sol(rx_vid_sol),
		.rx0_im_eol(rx_vid_eol),
		.rx0_im_sof(rx_vid_sof),
		.rx0_im_eof(rx_vid_eof),
		.rx0_im_locked(rx_vid_locked),
		.rx0_im_overflow(rx_vid_overflow),
		.rx0_im_clk(rx_vid_clk),
		.rx0_im_data(rx_vid_data),
		.rx1_im_valid(rx1_vid_valid),
		.rx1_im_sol(rx1_vid_sol),
		.rx1_im_eol(rx1_vid_eol),
		.rx1_im_sof(rx1_vid_sof),
		.rx1_im_eof(rx1_vid_eof),
		.rx1_im_locked(rx1_vid_locked),
		.rx1_im_overflow(rx1_vid_overflow),
		.rx1_im_clk(rx1_vid_clk),
		.rx1_im_data(rx1_vid_data),
		.rx2_im_valid(rx2_vid_valid),
		.rx2_im_sol(rx2_vid_sol),
		.rx2_im_eol(rx2_vid_eol),
		.rx2_im_sof(rx2_vid_sof),
		.rx2_im_eof(rx2_vid_eof),
		.rx2_im_locked(rx2_vid_locked),
		.rx2_im_overflow(rx2_vid_overflow),
		.rx2_im_clk(rx2_vid_clk),
		.rx2_im_data(rx2_vid_data),
		.rx3_im_valid(rx3_vid_valid),
		.rx3_im_sol(rx3_vid_sol),
		.rx3_im_eol(rx3_vid_eol),
		.rx3_im_sof(rx3_vid_sof),
		.rx3_im_eof(rx3_vid_eof),
		.rx3_im_locked(rx3_vid_locked),
		.rx3_im_overflow(rx3_vid_overflow),
		.rx3_im_clk(rx3_vid_clk),
		.rx3_im_data(rx3_vid_data),

		// Post scrambler signals
		.rx0_stream_data(rx_stream_data),
		.rx0_stream_ctrl(rx_stream_ctrl),
		.rx0_stream_valid(rx_stream_valid),
		.rx0_stream_clk(rx_stream_clk),
		.rx1_stream_data(rx1_stream_data),
		.rx1_stream_ctrl(rx1_stream_ctrl),
		.rx1_stream_valid(rx1_stream_valid),
		.rx1_stream_clk(rx1_stream_clk),
		.rx2_stream_data(rx2_stream_data),
		.rx2_stream_ctrl(rx2_stream_ctrl),
		.rx2_stream_valid(rx2_stream_valid),
		.rx2_stream_clk(rx2_stream_clk),
		.rx3_stream_data(rx3_stream_data),
		.rx3_stream_ctrl(rx3_stream_ctrl),
		.rx3_stream_valid(rx3_stream_valid),
		.rx3_stream_clk(rx3_stream_clk),

		// Secondary Stream data
		.rx_ss_clk(rx_xcvr_clkout),
		.rx0_ss_data(rx_ss_data),
		.rx0_ss_valid(rx_ss_valid),
		.rx0_ss_sop(rx_ss_sop),
		.rx0_ss_eop(rx_ss_eop),
		.rx1_ss_data(rx1_ss_data),
		.rx1_ss_valid(rx1_ss_valid),
		.rx1_ss_sop(rx1_ss_sop),
		.rx1_ss_eop(rx1_ss_eop),
		.rx2_ss_data(rx2_ss_data),
		.rx2_ss_valid(rx2_ss_valid),
		.rx2_ss_sop(rx2_ss_sop),
		.rx2_ss_eop(rx2_ss_eop),
		.rx3_ss_data(rx3_ss_data),
		.rx3_ss_valid(rx3_ss_valid),
		.rx3_ss_sop(rx3_ss_sop),
		.rx3_ss_eop(rx3_ss_eop),

		// MSA data
		.rx0_msa(rx_msa), 
		.rx1_msa(rx1_msa), 
		.rx2_msa(rx2_msa), 
		.rx3_msa(rx3_msa), 

		// Audio data
		.rx0_audio_clk(),										// ignore, same as rx_ss_clk
		.rx0_audio_lpcm_data(rx_audio_lpcm_data),
		.rx0_audio_valid(rx_audio_valid), 
		.rx0_audio_mute(rx_audio_mute),
		.rx0_audio_infoframe(rx_audio_infoframe),
		.rx1_audio_clk(),										// ignore, same as rx_ss_clk
		.rx1_audio_lpcm_data(rx1_audio_lpcm_data),
		.rx1_audio_valid(rx1_audio_valid), 
		.rx1_audio_mute(rx1_audio_mute),
		.rx1_audio_infoframe(rx1_audio_infoframe),
		.rx2_audio_clk(),										// ignore, same as rx_ss_clk
		.rx2_audio_lpcm_data(rx2_audio_lpcm_data),
		.rx2_audio_valid(rx2_audio_valid), 
		.rx2_audio_mute(rx2_audio_mute),
		.rx2_audio_infoframe(rx2_audio_infoframe),
		.rx3_audio_clk(),										// ignore, same as rx_ss_clk
		.rx3_audio_lpcm_data(rx3_audio_lpcm_data),
		.rx3_audio_valid(rx3_audio_valid), 
		.rx3_audio_mute(rx3_audio_mute),
		.rx3_audio_infoframe(rx3_audio_infoframe)
	);

	// Generate the RX PHY
	genvar i;
	generate begin
		// Don't generate the RX PHY IP if TX only
		if (RX_SUPPORT_DP) begin
			for(i = 0; i < RX_MAX_LANE_COUNT; i = i + 1) begin : RX_PHY_GEN
				// PHY name auto-generated by HWTCL to match
				// parameterization used in add_hdl_instance
				${rx_phy_name} phy_rx (
					.rx_analogreset(rx_analogreset[i]),
					.rx_digitalreset(rx_digitalreset[i]),
					.rx_cdr_refclk(xcvr_refclk),  
					.rx_serial_data(rx_serial_data[i]), 
					.rx_set_locktoref(rx_set_locktoref[i]),
					.rx_set_locktodata(rx_set_locktodata[i]),
					.rx_is_lockedtoref(rx_is_lockedtoref[i]),
					.rx_is_lockedtodata(rx_is_lockedtodata[i]),
					.rx_std_coreclkin(rx_clkout[i]),
					.rx_std_clkout(rx_clkout[i]),
					.rx_std_bitslip(rx_bitslip[i]),
					.rx_std_polinv((RX_POLINV==1)),
					.rx_cal_busy(rx_cal_busy[i]),
					.reconfig_to_xcvr(reconfig_to_xcvr[70*i +: 70]),
					.reconfig_from_xcvr(reconfig_from_xcvr[46*i +: 46]),
					.rx_parallel_data(rx_parallel_data[10*RX_SYMBOLS_PER_CLOCK*i +: 10*RX_SYMBOLS_PER_CLOCK]),
					.unused_rx_parallel_data()					// Just ignore unused signals  
				);
			end // for
		end //if
		else begin
			// Stub out the unconnected PHY outputs
			assign rx_is_lockedtoref	= {RX_MAX_LANE_COUNT{1'b0}};
			assign rx_is_lockedtodata	= {RX_MAX_LANE_COUNT{1'b0}};
			assign rx_clkout			= {RX_MAX_LANE_COUNT{1'b0}};
			assign rx_cal_busy			= {RX_MAX_LANE_COUNT{1'b0}};
			assign rx_parallel_data		= {RX_MAX_LANE_COUNT*10*RX_SYMBOLS_PER_CLOCK{1'b0}};
		end // if
	end // generate
	endgenerate

	// Use a local parameter to calculate the reconfig base
	// index to make this easier to understand
	localparam RECONFIG_TO_XCVR_RX_OFFSET	= ((RX_SUPPORT_DP==1)*RX_MAX_LANE_COUNT*70);
	localparam RECONFIG_FROM_XCVR_RX_OFFSET = ((RX_SUPPORT_DP==1)*RX_MAX_LANE_COUNT*46);
			
	// Generate the TX PHY
	generate begin
		// Don't generate the TX PHY IP if RX only
		if (TX_SUPPORT_DP) begin

			for(i = 0; i < TX_MAX_LANE_COUNT; i = i + 1) begin : TX_PHY_GEN
				// PHY name auto-generated by HWTCL to match
				// parameterization used in add_hdl_instance
				${tx_phy_name} phy_tx (
					.pll_powerdown(pll_powerdown[i]),
					.tx_analogreset(tx_analogreset[i]),
					.tx_digitalreset(tx_digitalreset[i]),
					.tx_pll_refclk(xcvr_refclk),  
					.tx_serial_data(tx_serial_data[i]), 
					.pll_locked(pll_locked[i]),
					.tx_std_coreclkin(tx_clkout[0]),		// Bitec core syncs all TX lanes to clock 0
					.tx_std_clkout(tx_clkout[i]),
					.tx_std_polinv((TX_POLINV==1)),
					.tx_cal_busy(tx_cal_busy[i]),
					.reconfig_to_xcvr({reconfig_to_xcvr[(RECONFIG_TO_XCVR_RX_OFFSET + (TX_MAX_LANE_COUNT*70) + (70*i)) +: 70], reconfig_to_xcvr[(RECONFIG_TO_XCVR_RX_OFFSET + (70*i)) +: 70]}),
					.reconfig_from_xcvr({reconfig_from_xcvr[(RECONFIG_FROM_XCVR_RX_OFFSET + (TX_MAX_LANE_COUNT*46) + (46*i)) +: 46], reconfig_from_xcvr[(RECONFIG_FROM_XCVR_RX_OFFSET + (46*i)) +: 46]}),
					.tx_parallel_data(tx_parallel_data[10*TX_SYMBOLS_PER_CLOCK*i +: 10*TX_SYMBOLS_PER_CLOCK]),
					.unused_tx_parallel_data()					// Just ignore unused signals  
				);
			end // for
		end //if 
		else begin
			// Stub out the unconnected PHY outputs
			assign tx_serial_data		= {TX_MAX_LANE_COUNT{1'b0}};
			assign pll_locked			= {TX_MAX_LANE_COUNT{1'b0}};
			assign tx_clkout			= {TX_MAX_LANE_COUNT{1'b0}};
			assign tx_cal_busy			= {TX_MAX_LANE_COUNT{1'b0}};
		end // if
	end // generate
	endgenerate

	//***************************************************************************
	// Adaptation logic to connect the Bitec DP core to the XCVR PHY datapaths
	//***************************************************************************

	// TX: PHY <- DP
	// Dual-Symbol Mode				4-lane	                   2-lane                   1-lane
	// pll_powerdown		conduit_to_gxb_tx[84]		conduit_to_gxb_tx[42]     conduit_to_gxb_tx[21]
	// tx_digitalreset		conduit_to_gxb_tx[83:80]	conduit_to_gxb_tx[41:40]  conduit_to_gxb_tx[20]
	// tx_parallel_data     conduit_to_gxb_tx[79:0]		conduit_to_gxb_tx[39:0]   conduit_to_gxb_tx[19:0]

	// Quad-Symbol Mode				4-lane		                 2-lane                   1-lane
	// pll_powerdown		conduit_to_gxb_tx[164]		conduit_to_gxb_tx[82]     conduit_to_gxb_tx[41]
	// tx_digitalreset		conduit_to_gxb_tx[163:160]	conduit_to_gxb_tx[81:80]  conduit_to_gxb_tx[40]
	// tx_parallel_data     conduit_to_gxb_tx[159:0]	conduit_to_gxb_tx[79:0]   conduit_to_gxb_tx[39:0]

	wire btc_pll_powerdown;		// temp wire used to expand single-signal to lane width

	assign {btc_pll_powerdown, btc_tx_digitalreset, tx_parallel_data} = conduit_to_gxb_tx;
	assign pll_powerdown	= {TX_MAX_LANE_COUNT{btc_pll_powerdown}};

	// Reset the TX PLL and channel when doing a reconfiguration
	assign tx_analogreset	= {TX_MAX_LANE_COUNT{btc_pll_powerdown | tx_reconfig_busy}};
	assign tx_digitalreset	= btc_tx_digitalreset | {TX_MAX_LANE_COUNT{tx_reconfig_busy}};

	// TX: PHY -> DP                  4-lane                   2-lane                   1-lane
	// tx_clkout                conduit_from_gxb_tx[4:1]  conduit_from_gxb_tx[2:1]  conduit_from_gxb_tx[1]
	// pll_locked               conduit_from_gxb_tx[0]    conduit_from_gxb_tx[0]    conduit_from_gxb_tx[0]

	wire btc_pll_locked;					// temp wire to combine all PLL lock signals
	assign btc_pll_locked = & pll_locked;	// Wait for all TX PLLs to lock
	assign conduit_from_gxb_tx	= {tx_clkout, btc_pll_locked};

	// RX: PHY <- DP                  4-lane                   2-lane                   1-lane
	// rx_bitslip               conduit_to_gxb_rx[20:17]  conduit_to_gxb_rx[10:9]   conduit_to_gxb_rx[5]
	// rx_set_locktodata		conduit_to_gxb_rx[16:13]  conduit_to_gxb_rx[8:7]    conduit_to_gxb_rx[4]
	// rx_set_locktoref			conduit_to_gxb_rx[12:9]   conduit_to_gxb_rx[6:5]    conduit_to_gxb_rx[3]
	// gxb_powerdown			conduit_to_gxb_rx[8]      conduit_to_gxb_rx[4]      conduit_to_gxb_rx[2]
	// rx_analogreset			conduit_to_gxb_rx[7:4]    conduit_to_gxb_rx[3:2]    conduit_to_gxb_rx[1]
	// rx_digitalreset			conduit_to_gxb_rx[3:0]    conduit_to_gxb_rx[1:0]    conduit_to_gxb_rx[0]

	wire btc_gxb_powerdown;		// Temp wire for unnecessary gxb_powerdown signal

	assign {rx_bitslip, rx_set_locktodata, rx_set_locktoref, btc_gxb_powerdown, btc_rx_analogreset, btc_rx_digitalreset} = conduit_to_gxb_rx;

	// Reset the RX PLL and channel when doing a reconfiguration
	assign rx_analogreset	= btc_rx_analogreset | {RX_MAX_LANE_COUNT{rx_reconfig_busy}};
	assign rx_digitalreset	= btc_rx_digitalreset | {RX_MAX_LANE_COUNT{rx_reconfig_busy}};

	// RX: PHY -> DP
	// Dual-Symbol Mode				4-lane		                 2-lane                   1-lane
	// rx_clkout			conduit_from_gxb_rx[91:88]	 conduit_from_gxb_rx[45:44] conduit_from_gxb_rx[22]
	// rx_is_lockedtodata   conduit_from_gxb_rx[87:84]	 conduit_from_gxb_rx[43:42] conduit_from_gxb_rx[21]
	// rx_is_lockedtoref    conduit_from_gxb_rx[83:80]	 conduit_from_gxb_rx[41:40] conduit_from_gxb_rx[20]
	// rx_parallel_data     conduit_from_gxb_rx[79:0]	 conduit_from_gxb_rx[39:0]  conduit_from_gxb_rx[19:0]

	// Quad-Symbol Mode				4-lane		                 2-lane                   1-lane
	// rx_clkout            conduit_from_gxb_rx[171:168] conduit_from_gxb_rx[85:84] conduit_from_gxb_rx[42]
	// rx_is_lockedtodata   conduit_from_gxb_rx[167:164] conduit_from_gxb_rx[83:82] conduit_from_gxb_rx[41]
	// rx_is_lockedtoref    conduit_from_gxb_rx[163:160] conduit_from_gxb_rx[81:80] conduit_from_gxb_rx[40]
	// rx_parallel_data     conduit_from_gxb_rx[159:0]	 conduit_from_gxb_rx[79:0]	conduit_from_gxb_rx[39:0]

	assign conduit_from_gxb_rx = {rx_clkout, rx_is_lockedtodata, rx_is_lockedtoref, rx_parallel_data};

	//***************************************************************************
	// Adaptation logic to connect the Bitec DP core to the XCVR
	// reconfig management logic
	//***************************************************************************

	// TX: Reconfig <- DP
	assign {btc_tx_emp, btc_tx_vod, btc_tx_link_rate, btc_tx_reconfig_req, btc_tx_analog_reconfig_req} = conduit_to_tx_reconfig;

	// TX: Reconfig -> DP
	assign conduit_from_tx_reconfig = | tx_cal_busy;

	// RX: Reconfig <- DP
	assign {btc_rx_link_rate, btc_rx_reconfig_req} = conduit_to_rx_reconfig;

	// RX: Reconfig -> DP
	assign conduit_from_rx_reconfig = | rx_cal_busy;

	//*************************************************************
	// Reconfig Mgmt interfaces
	//*************************************************************

	// Don't make any reconfiguration requests while any reconfig
	// operations are busy
	wire reconfig_busy;
	assign reconfig_busy = (|rx_cal_busy) || (tx_cal_busy) || 
							rx_reconfig_busy || tx_reconfig_busy || tx_analog_reconfig_busy;

	//*************************************************************
	// RX Reconfig Mgmt
	//*************************************************************

	wire rx_reconfig_ready;

	generate 
	begin
		// Check if this interface should be supported
		if (RX_SUPPORT_DP) 
		begin
			// Instantiate a reconfig controller
			// Trigger on reset or link rate change
			// Wait for reconfigs to end
			altera_dp_reconfig_ctrl # (
				.WIDTH(2)
			) rx_reconfig (
				.clk(xcvr_mgmt_clk),
				.reset(reset),
				.trigger(!rx_reconfig_ready || (btc_rx_link_rate != rx_link_rate)),
				.din(btc_rx_link_rate),
				.dout(rx_link_rate),
				.ready(!reconfig_busy),
				.ack(rx_reconfig_ack),
				.busy(rx_reconfig_busy),
				.req(rx_reconfig_req),
				.done(rx_reconfig_ready)
			);

		end // if
		else begin
			// Stub out the unconnected outputs
			assign rx_reconfig_req		= 1'b0;
			assign rx_reconfig_ready	= 1'b1;
			assign rx_link_rate			= 2'b0;
		end // if
	end // generate
	endgenerate

	//*************************************************************
	// TX Reconfig Mgmt
	//*************************************************************

	wire tx_reconfig_ready;

	generate 
	begin
		// Check if this interface should be supported
		if (TX_SUPPORT_DP) 
		begin
			// Instantiate a reconfig controller
			// Trigger on reset or link rate change
			// Wait for reconfigs to end and RX to be reconfiged
			altera_dp_reconfig_ctrl # (
				.WIDTH(2)
			) tx_reconfig (
				.clk(xcvr_mgmt_clk),
				.reset(reset),
				.trigger(!tx_reconfig_ready || (btc_tx_link_rate != tx_link_rate)),
				.din(btc_tx_link_rate),
				.dout(tx_link_rate),
				.ready(!reconfig_busy && rx_reconfig_ready),
				.ack(tx_reconfig_ack),
				.busy(tx_reconfig_busy),
				.req(tx_reconfig_req),
				.done(tx_reconfig_ready)
			);

		end // if
		else begin
			// Stub out the unconnected outputs
			assign tx_reconfig_req		= 1'b0;
			assign tx_reconfig_ready	= 1'b1;
			assign tx_link_rate			= 2'b0;
		end // if
	end // generate
	endgenerate

	//*************************************************************
	// TX Analog Reconfig Mgmt
	//*************************************************************

	wire tx_analog_reconfig_ready;

	generate 
	begin
		// Check if this interface should be supported
		if (TX_SUPPORT_DP && TX_SUPPORT_ANALOG_RECONFIG) 
		begin
			// Instantiate a reconfig controller
			// Trigger on reset or do_analog_reconfig
			// Wait for reconfigs to end and RX & TX to be reconfiged
			altera_dp_reconfig_ctrl # (
				.WIDTH(4*TX_MAX_LANE_COUNT)
			) tx_reconfig (
				.clk(xcvr_mgmt_clk),
				.reset(reset),
				.trigger(!tx_analog_reconfig_ready || btc_tx_analog_reconfig_req),
				.din({btc_tx_emp, btc_tx_vod}),
				.dout({tx_emp, tx_vod}),
				.ready(!reconfig_busy && rx_reconfig_ready && tx_reconfig_ready),
				.ack(tx_analog_reconfig_ack),
				.busy(tx_analog_reconfig_busy),
				.req(tx_analog_reconfig_req),
				.done(tx_analog_reconfig_ready)
			);

		end // if
		else begin
			// Stub out the unconnected outputs
			assign tx_analog_reconfig_req	= 1'b0;
			assign tx_analog_reconfig_ready	= 1'b1;
			assign tx_vod = {TX_MAX_LANE_COUNT*2{1'b0}};
			assign tx_emp = {TX_MAX_LANE_COUNT*2{1'b0}};
		end // if
	end // generate
	endgenerate

endmodule

`default_nettype wire
