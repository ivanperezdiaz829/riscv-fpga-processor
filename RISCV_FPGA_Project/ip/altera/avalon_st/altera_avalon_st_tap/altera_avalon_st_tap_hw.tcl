# (C) 2001-2013 Altera Corporation. All rights reserved.
# Your use of Altera Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Altera Program License Subscription 
# Agreement, Altera MegaCore Function License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Altera and sold by 
# Altera or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# TCL File Generated by Component Editor 11.0
# Mon Jul 25 14:34:07 BST 2011
# DO NOT MODIFY


# +-----------------------------------
# | request TCL package from ACDS 11.0
# | 
package require -exact sopc 11.0
# | 
# +-----------------------------------

# +-----------------------------------
# | 
set_module_property NAME                         altera_avalon_st_tap
set_module_property VERSION                      13.1
set_module_property AUTHOR                       "Altera Corporation"
set_module_property INTERNAL                     true
set_module_property OPAQUE_ADDRESS_MAP           true
set_module_property DISPLAY_NAME                 "Avalon-ST Tap"
set_module_property INSTANTIATE_IN_SYSTEM_MODULE true
set_module_property GROUP                        "Verification/Debug & Performance/Trace"
set_module_property EDITABLE                     true
set_module_property ANALYZE_HDL                  false
set_module_property ELABORATION_CALLBACK         elaborate
set_module_property VALIDATION_CALLBACK          validate

set_module_assignment debug.isTransparent 1
# | 
# +-----------------------------------

# +-----------------------------------
# | files
# | 

# | 
# +-----------------------------------

# +-----------------------------------
# | parameters
# | 

proc proc_add_parameter {NAME TYPE DEFAULT IS_HDL VISIBLE AFFECTS_GENERATION GROUP DISP_NAME DESCRIPTION  args} {
    add_parameter           $NAME $TYPE $DEFAULT $DESCRIPTION
    if {$args != ""} then {
        set_parameter_property  $NAME "ALLOWED_RANGES" $args
    }
    set_parameter_property  $NAME "VISIBLE"            $VISIBLE
    set_parameter_property  $NAME "HDL_PARAMETER"      $IS_HDL
    set_parameter_property  $NAME "GROUP"              $GROUP
    set_parameter_property  $NAME "DISPLAY_NAME"       $DISP_NAME
    set_parameter_property  $NAME "AFFECTS_GENERATION" $AFFECTS_GENERATION
}

#                    name                      type   def_value   is_hdl   VISIBLE  Affects     group     display name             Tooltip hint                    args_range
#                                                                                   generation
proc_add_parameter  MON_SYM_WIDTH             INTEGER       8      false    true      true         ""       "Symbol Width"     ""
proc_add_parameter  MON_DATA_WIDTH            INTEGER      32      false    true      true         ""       "Data Width"       ""
proc_add_parameter  MON_CHANNEL_WIDTH         INTEGER       0      false    true      true         ""       "Channel Width"    ""
proc_add_parameter  MON_ERR_WIDTH             INTEGER       0      false    true      true         ""       "Error Width"    ""
proc_add_parameter  MON_USES_READY            boolean       true   false    true      true         ""       "uses ready"    ""
proc_add_parameter  MON_USES_PACKETS          boolean       true   false    true      true         ""       "uses packets"    ""
proc_add_parameter  MON_EMPTY_WIDTH           INTEGER       2      false    true      true         ""       "Empty Width"    "NOTE: empty is conditional on using packet signals"
# empty width could be derived but leaving it enabled

proc_add_parameter  MON_READY_LATENCY         integer       0       false    true     true         ""       "Ready latency of the monitored interface ...  this only affects the timing of ready for th RL0 tap port!"    ""
proc_add_parameter  MON_MAX_CHANNEL           integer       0       false    true     true         ""       "Max channel"    ""

proc_add_parameter  MONITORED_INTERFACE_NAME  STRING       ""       false    true     false        ""       "Monitored interface name" "The name of the interface that this tap is monitoring."
# | 
# +-----------------------------------



# +-----------------------------------
# | connection point clk
# | 
add_interface          clk clock     end
set_interface_property clk clockRate 0
set_interface_property clk ENABLED   true

add_interface_port clk clk clk Input 1
# | 
# +-----------------------------------


# +-----------------------------------
# | connection point reset
# | 
add_interface          reset reset end
set_interface_property reset associatedClock  clk
set_interface_property reset synchronousEdges DEASSERT
set_interface_property reset ENABLED          true

add_interface_port reset arst_n reset_n Input 1
# | 
# +-----------------------------------


# +-----------------------------------
# | connection point snk
# | 
add_interface          snk avalon_streaming           end
set_interface_property snk associatedClock            clk
set_interface_property snk associatedReset            reset
set_interface_property snk errorDescriptor            ""
set_interface_property snk firstSymbolInHighOrderBits true
set_interface_property snk ENABLED true

set_interface_assignment snk debug.controlledBy src
set_interface_assignment snk debug.visible true
set_interface_assignment snk merlin.flow.src src

add_interface_port snk sink_valid valid Input 1
add_interface_port snk sink_data  data  Input MON_DATA_WIDTH

# | 
# +-----------------------------------


# +-----------------------------------
# | connection point src
# | 
add_interface          src avalon_streaming           start
set_interface_property src associatedClock            clk
set_interface_property src associatedReset            reset
set_interface_property src errorDescriptor            ""
set_interface_property src firstSymbolInHighOrderBits true
set_interface_property src ENABLED                    true

add_interface_port src source_valid valid Output 1
add_interface_port src source_data  data  Output MON_DATA_WIDTH

# | 
# +-----------------------------------


# +-----------------------------------
# | connection point tap_out
# | 
add_interface          tap_out conduit end
set_interface_property tap_out ENABLED true

set_interface_assignment tap_out debug.monitoredInterfaces src
set_interface_assignment tap_out debug.visible true
set_interface_property   tap_out associatedClock  clk

add_interface_port tap_out tap_valid valid         Output 1
add_interface_port tap_out tap_data  data          Output MON_DATA_WIDTH
# | 
# +-----------------------------------



proc validate { } {
    set use_packets [get_parameter_value MON_USES_PACKETS]

	if {$use_packets} {
		set_parameter_property  MON_EMPTY_WIDTH ENABLED true	
	} else {
		set_parameter_property  MON_EMPTY_WIDTH ENABLED false		
	}
}


proc elaborate {} {
    set_interface_property snk dataBitsPerSymbol [get_parameter_value  MON_SYM_WIDTH ]
    set_interface_property src dataBitsPerSymbol [get_parameter_value  MON_SYM_WIDTH ]

    set_interface_property snk maxChannel      [get_parameter_value   MON_MAX_CHANNEL   ]
    set_interface_property src maxChannel      [get_parameter_value   MON_MAX_CHANNEL   ]
    set_interface_property snk readyLatency    [get_parameter_value   MON_READY_LATENCY ]
    set_interface_property src readyLatency    [get_parameter_value   MON_READY_LATENCY ]  

    set_interface_assignment tap_out debug.ultimatelyMonitoredInterfaces [ get_parameter_value MONITORED_INTERFACE_NAME ]
    
    set_port_property  tap_valid       DRIVEN_BY  sink_valid
    set_port_property  source_valid    DRIVEN_BY  sink_valid
    
    set_port_property  tap_data        DRIVEN_BY  sink_data
    set_port_property  source_data     DRIVEN_BY  sink_data                                               


    
    set use_ready   [get_parameter_value MON_USES_READY]    
    set use_packets [get_parameter_value MON_USES_PACKETS]
    set ch_width    [get_parameter_value MON_CHANNEL_WIDTH]
    set mty_width   [get_parameter_value MON_EMPTY_WIDTH]   
    set err_width   [get_parameter_value MON_ERR_WIDTH]


    if {$use_ready} {   
        add_interface_port src     source_ready ready Input 1
        add_interface_port snk     sink_ready   ready Output 1
        add_interface_port tap_out tap_ready    ready Output 1

        set_port_property  tap_ready       DRIVEN_BY  source_ready
        set_port_property  sink_ready      DRIVEN_BY  source_ready
    }

    
    if {$use_packets} { 
        add_interface_port snk     sink_sop   startofpacket Input  1    
        add_interface_port src     source_sop startofpacket Output 1
        add_interface_port tap_out tap_sop    startofpacket Output 1

        add_interface_port snk     sink_eop   endofpacket   Input  1
        add_interface_port src     source_eop endofpacket   Output 1        
        add_interface_port tap_out tap_eop    endofpacket   Output 1     

        set_port_property source_sop DRIVEN_BY  sink_sop
        set_port_property tap_sop    DRIVEN_BY  sink_sop    
        
        set_port_property source_eop DRIVEN_BY  sink_eop
        set_port_property tap_eop    DRIVEN_BY  sink_eop

        # NOTE: empty is conditional con packet signals
        if {$mty_width} {
            add_interface_port snk     sink_empty   empty  Input  $mty_width
            add_interface_port src     source_empty empty  Output $mty_width
            add_interface_port tap_out tap_empty    empty  Output $mty_width 
        
            set_port_property  source_empty DRIVEN_BY   sink_empty
            set_port_property  tap_empty    DRIVEN_BY   sink_empty      
        }        
    }

    
    if {$ch_width} {    
        add_interface_port snk     sink_ch   channel  Input  $ch_width
        add_interface_port src     source_ch channel  Output $ch_width
        add_interface_port tap_out tap_ch    channel  Output $ch_width

        set_port_property  source_ch  DRIVEN_BY sink_ch
        set_port_property  tap_ch     DRIVEN_BY sink_ch         
    }



    if {$err_width} {
        add_interface_port snk     sink_err   error  Input  $err_width
        add_interface_port src     source_err error  Output $err_width
        add_interface_port tap_out tap_err    error  Output $err_width
        
        set_port_property source_err DRIVEN_BY  sink_err
        set_port_property tap_err    DRIVEN_BY  sink_err                
    }
    

    
    
}
