# (C) 2001-2013 Altera Corporation. All rights reserved.
# Your use of Altera Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Altera Program License Subscription 
# Agreement, Altera MegaCore Function License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Altera and sold by 
# Altera or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# (C) 2001-2009 Altera Corporation. All rights reserved.
# Your use of Altera Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Altera Program License Subscription 
# Agreement, Altera MegaCore Function License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Altera and sold by 
# Altera or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# Create kernel of the MATLAB simulation

#package require ::quartus::flow
#package require ::quartus::project
#package require ::quartus::iptclgen

#Parameters
set out_dir                        [lindex $argv 0]
set component_name                 [lindex $argv 1]
set version                        [lindex $argv 2]

set coefficient_reload             [lindex $argv 3]
set num_coeff                      [lindex $argv 4]
set DATA_WIDTH_c                   [lindex $argv 5]
set filter_type                    [lindex $argv 6]
set interpN                        [lindex $argv 7]
set decimN                         [lindex $argv 8]
# Get OutWidth for real width of one data, instead of output wire width
set OUT_WIDTH_c                    [lindex $argv 9]
set COEF_ARRAY_c                   [lindex $argv 10]
set OUT_MSB_REMOVED_BITS_c         [lindex $argv 11]
set OUT_MSB_REMOVE_TYPE_c          [lindex $argv 12]
set OUT_LSB_REMOVED_BITS_c         [lindex $argv 13]
set OUT_LSB_REMOVE_TYPE_c          [lindex $argv 14]
set data_type                      [lindex $argv 15]
set NUM_OF_CHANNELS_c              [lindex $argv 16]
set PhysChanIn                     [lindex $argv 17]
set coeff_bit_width                [lindex $argv 18]
set coefficientWriteable           [lindex $argv 19]
set pfc_exists                     [lindex $argv 20]
set symmetry_type                  [lindex $argv 21]
set bankcount                      [lindex $argv 22]
set ChansPerPhyIn   [expr int([expr ceil([expr {$NUM_OF_CHANNELS_c / $PhysChanIn}])])]
set COEF_ARRAY_LIST [split "$COEF_ARRAY_c" ","]

if { [llength $COEF_ARRAY_LIST] != [expr $bankcount * $num_coeff] } {
	error "Incorrect coefficient count."
}

#Split coefficients into banks with ";"
set coef_sets ""
for {set bank 0} {$bank < $bankcount} {incr bank} {
  for {set cnt 0} {$cnt < $num_coeff} {incr cnt} {
    append coef_sets [lindex $COEF_ARRAY_LIST [expr $bank * $num_coeff + $cnt]]
    if {$cnt != [expr $num_coeff - 1]} { append coef_sets "," }
  }
  if {$bank != [expr $bankcount - 1]} { append coef_sets ";" }
}

# Temp
set MCV_selected false
set Aion_selected false
set pfc_exists true

set file_name "${out_dir}${component_name}_mlab.m"

if { [ catch { set out_file [ open $file_name w ] } err ] } {
    send_message "error" "$err"
    return
}

	puts $out_file "%"
	puts $out_file "%THIS IS A WIZARD GENERATED FILE. DO NOT EDIT THIS FILE!"
	puts $out_file "%"
	puts $out_file "%---------------------------------------------------------------------------------------------------------"
	puts $out_file "%This is a filter with fixed coefficients."
	puts $out_file "%This Model Only Support Single Channel Input Data."
	puts $out_file "%Please input:"
	puts $out_file "%data vector: 		stimulation(1:n)"
	puts $out_file ""
	
if {$coefficient_reload == "true" && $coefficientWriteable == "true"} {
	puts $out_file "%coefficient matrix:	coef_matrix(n * interpolation_factor,m). n is the input data length, m is the coefficients length."
	puts $out_file "%                       coef_matrix(1,:) coressponds to coefficient at time unit 1."
	puts $out_file "%                       coef_matrix(2,:) coressponds to coefficient at time unit 2."
	puts $out_file "%"
	puts $out_file "%                       coef_matrix(n,:) coressponds to coefficient at time unit n."
}

	puts $out_file "%    This Model Only Support FIR_WIDTH to 51 Bits"
	puts $out_file ""

	puts $out_file "%FILTER PARAMETER"
	puts $out_file "%Input Data Type :	$data_type"
	puts $out_file "%Input Data Width: $DATA_WIDTH_c"

if {$filter_type == "Interpolation"} {
	puts $out_file "%Interpolation Factor: $interpN"
	puts $out_file ""
} elseif {$filter_type == "Decimation"} {
	puts $out_file "%Decimation Factor: $decimN"
	puts $out_file ""
} elseif {$filter_type == "Fractional Rate"} {
	puts $out_file "%Interpolation Factor: $interpN"
	puts $out_file "%Decimation Factor: $decimN"
} else {
	puts $out_file "%Interpolation Factor: 1"
	puts $out_file "%Decimation Factor: 1"
}	


##if lose msb > 0,
##if out_msb_rad==0
#%MSB Truncated Bits:
##if out_msb_rad ==1           
#%MSB Satuated Bits :
##if lose lsb > 0
##if out_lsb_rad==0           
#%LSB Truncated bits:
##if out_lsb_rad==1
#%LSB Rounded bits  :

	puts $out_file "%FIR Width (Full Calculation Width Before Output Width Adjust) :$OUT_WIDTH_c"
	puts $out_file "%-----------------------------------------------------------------------------------------------------------"
	puts $out_file "%MegaWizard Scaled Coefficient Values"
	puts $out_file ""
	
if {$coefficient_reload == "true" && $coefficientWriteable == "true"} {
	if {$bankcount > 1} {
		puts $out_file " function  output = ${component_name}_mlab(stimulation, bank, coef_matrix_in, output)"
	} else {
		puts $out_file " function  output = ${component_name}_mlab(stimulation, coef_matrix_in, output)"
	}
} else {
  if {$bankcount > 1} {
    puts $out_file " function  output = ${component_name}_mlab(stimulation, bank, output)"
  } else {
    puts $out_file " function  output = ${component_name}_mlab(stimulation, output)"
  }
	puts $out_file " coef_matrix_in= \[$coef_sets\];"
}

 # for {set cnt 0} {$cnt < [llength $COEF_ARRAY_c]} {incr cnt } {
 #puts $out_file [set $COEF_ARRAY_c($cnt)]
 #}


if {$filter_type == "Interpolation"} {
	puts $out_file " INTER_FACTOR = $interpN;"
	puts $out_file " DECI_FACTOR  = 1;"
} elseif {$filter_type == "Decimation"} {
	puts $out_file " INTER_FACTOR  = 1;"
	puts $out_file " DECI_FACTOR  =  $decimN;"
} elseif {$filter_type == "Fractional Rate"} {
	puts $out_file " INTER_FACTOR  = $interpN;"
	puts $out_file " DECI_FACTOR  =  $decimN;"
} else {
	puts $out_file " INTER_FACTOR  = 1;"
	puts $out_file " DECI_FACTOR  =  1;"
}	

	puts $out_file " MSB_RM  = $OUT_MSB_REMOVED_BITS_c;"

if {$OUT_MSB_REMOVE_TYPE_c == "Truncate"} {
	puts $out_file " MSB_TYPE  = 0;"
} elseif { $OUT_MSB_REMOVE_TYPE_c == "Saturate" } {
	puts $out_file " MSB_TYPE  = 1;"
} else {
	puts $out_file " MSB_TYPE = 0;"
}

	puts $out_file " LSB_RM  = $OUT_LSB_REMOVED_BITS_c;"

if { $OUT_LSB_REMOVE_TYPE_c == "Truncate" } {
	puts $out_file " LSB_TYPE  = 0;"
} elseif {$OUT_LSB_REMOVE_TYPE_c == "Round"} {
	puts $out_file " LSB_TYPE  = 1;"
} else {
	puts $out_file " LSB_TYPE  = 0;"
}

####################### SPR 225858: output_bitwidth_mismatch ###########################       
	puts $out_file " FIR_WIDTH  = $OUT_WIDTH_c + MSB_RM + LSB_RM;"
	puts $out_file " OUT_WIDTH  = $OUT_WIDTH_c ;  %$OUT_WIDTH_c"
 #######################################################################################
	puts $out_file " DATA_WIDTH = $DATA_WIDTH_c;"
	puts $out_file " BANKCOUNT = $bankcount;"
if {($data_type == "Signed Binary") || ($data_type == "Signed Fractional Binary") } {
##in the old model, "sbf" mode is mapped onto data_type=2;
	puts $out_file " data_type = 1;"
} else {
	puts $out_file " data_type = 2;"
}

###### Begin Template ######

  puts $out_file {
  
 % check size of inputs. 
 [DX,DY] = size(stimulation);
 [CX,CY] = size(coef_matrix_in); 
 if (CY ~= DY * INTER_FACTOR) 
    fprintf('WARNING : coef_matrix size and input data size is not match\n'); 
 end 

 %fill coef_matrix to length of data with the latest coef set 
 if (CY < DY * INTER_FACTOR) 
   %for i= CX +1:DY * INTER_FACTOR 
   for i= 1:DY * INTER_FACTOR 
     if (BANKCOUNT > 1)
       coef_matrix(i,:) = coef_matrix_in(bank(i)+1,:); 
     else
       coef_matrix(i,:) = coef_matrix_in(1,:); 
     end
   end 
 end
	  
 % check if input is integer 
       	int_sti=round(stimulation); 
	    T = (int_sti ~= stimulation); 
	    if (max(T)~=0) 
	        fprintf('WARNING : Integer Input Expected: Rounding Fractional Input to Nearest Integer...\n'); 
	    end 
	     
	    %Input overflow check 
	    switch  data_type 
	    case 1 
	        %set max/min for signed 
	        maxdat = 2^(DATA_WIDTH-1)-1; 
	        mindat = -maxdat-1; 
	    case 2 
	        %set max/min for unsigned 
	        maxdat = 2^DATA_WIDTH-1; 
	        mindat = 0; 
	    end 

	    if(data_type == 2)
	    	if(abs(coef_matrix) == coef_matrix)
	    		FIR_WIDTH = FIR_WIDTH +1;
	    	end
	    end

	    %Saturating Input Value 
	    a=find(int_sti>maxdat); 
	    b=find(int_sti<mindat); 
	    if (~isempty(a)|~isempty(b)) 
	 	    fprintf('WARNING : Input Amplitude Exceeds MAXIMUM/MINIMUM allowable values - saturating input values...\n'); 
	            lena = length (a); 
	            lenb = length (b); 
	            for i =1:lena 
	        	    fprintf('%d > %d \n', int_sti(a(i)), maxdat); 
			        int_sti(a(i)) = maxdat; 
		        end 
		    for i =1:lenb 
			    fprintf('%d < %d \n', int_sti(b(i)), mindat); 
			    int_sti(b(i)) = mindat; 
		    end 
	    end 
         
	    % Add interpolation 
   	    inter_sti = zeros(1, INTER_FACTOR * length(int_sti)); 
	    inter_sti(1:INTER_FACTOR:INTER_FACTOR * length(int_sti)) = int_sti; 
 
         
        for i = 1 : DY *INTER_FACTOR 
    	    coef_current = coef_matrix(i,:); 
            output_temp(i) = simp_adaptive (inter_sti, coef_current, i); 
        end 
	% Truncate output 
	len1 = length(output_temp); 
	 
	    switch  LSB_TYPE 
	    case 0 
	        %truncate 
            out_dec = bi_trunc_lsb(output_temp,LSB_RM,FIR_WIDTH); 
	    case 1 
	        %round 
            out_dec = bi_round(output_temp,LSB_RM, FIR_WIDTH); 
	    end 
         
 	    switch  MSB_TYPE 
	    case 0 
	        %truncate 
            out_dec = bi_trunc_msb(out_dec,MSB_RM,FIR_WIDTH-LSB_RM); 
	    case 1 
	        %round 
            out_dec = bi_satu(out_dec,MSB_RM, FIR_WIDTH-LSB_RM); 
	    end 
 	    
    	% choose decimation output in phase=DECI_FACTOR-1  
     	if(DECI_FACTOR == 1) 
     		output = out_dec; 
     	else }

if {($filter_type == "Decimation") && ($MCV_selected || $Aion_selected)} {
	puts $out_file "     		output = out_dec;%(DECI_FACTOR:DECI_FACTOR:len1);"
} else {
	puts $out_file "        output = out_dec(1:DECI_FACTOR:len1);"
}


# Temp => line 292
##the new flow makes use of ROUND_UP which is different to the MATLAB round function          
#if($new_flow)           
#        data = round ((data_in + 0.5) / 2^LSB_RM);
#else
#	data = round (data_in / 2^LSB_RM);       
#end

  puts $out_file {
	 	end  
 	       
  	function[output, outindex] = simp_adaptive (int_sti, coef_current, data_index, output) 
	%Simulation is the whole input sequence 
	%coef_current is the current coefficient set 
	%data_index gives the last data to use 
	%outputs are the sum of input and coef multiplication 
	%outindex is the next data_index 
    
	sti_current = zeros(length(coef_current),1); 
	 
	data_length = length(int_sti); 
	 
	%Check data index 
	if (data_index > data_length) 
		fprintf('ERROR: DATA INDEX IS LARGER THAN DATA LENGTH!!!\n'); 
		return; 
	end 
	for i = 1: length(coef_current) 
	   if ((data_index -i+1)>0 & (data_index - i+1)<=data_length) 
	      sti_current(i,1) = int_sti(data_index - i+1); 
	   end 
	end 
	 
	outindex= data_index+1; 
	output = coef_current * sti_current; 
	% end of function simp_adaptive 
 
	function output = bi_round(data_in,LSB_RM,ORI_WIDTH, output) 
	% LSB_RM is the bit to lose in LSB 
	% ORI_WIDTH is the original data width

	data = round (data_in / 2^LSB_RM);

	output = bi_satu(data,0,ORI_WIDTH - LSB_RM); 
	%end of function bi_trunc_lsb 
	 
	function output = bi_trunc_lsb(data_in,LSB_RM,ORI_WIDTH, output) 
	% LSB_RM is the bit to lose in LSB 
	% ORI_WIDTH is the original data width 
	%2's complement system 
	output = bitshift(2^ORI_WIDTH*(data_in<0) + data_in, -LSB_RM) - 2^(ORI_WIDTH-LSB_RM) *(data_in<0); 
	% end of function bi_round 
	 
	function output = bi_trunc_msb(data_in,MSB_RM,ORI_WIDTH, output) 
	% MSB_RM is the bit to lose in LSB 
	% ORI_WIDTH is the original data width 
	%2's complement system 
	data = 2^ORI_WIDTH * (data_in < 0)+ data_in; 
	erase_num = 2^(ORI_WIDTH - MSB_RM) - 1; 
	data = bitand(data, erase_num); 
	output = data - 2^(ORI_WIDTH - MSB_RM)*(bitget(data,ORI_WIDTH - MSB_RM)); 
	%end of bi_trunc_msb 
	 
	function output = bi_satu(data_in,MSB_RM,ORI_WIDTH, output) 
	% MSB_RM is the bit to lose in LSB 
	% ORI_WIDTH is the original data width 
	%2's complement system 
	maxdat = 2^(ORI_WIDTH - MSB_RM - 1)-1; 
	mindat = 2^(ORI_WIDTH - MSB_RM - 1)*(-1); 
	data_in(find(data_in > maxdat)) = maxdat; 
	data_in(find(data_in < mindat)) = mindat; 
	output = data_in; 
	%end of bi_satu  

}

###### End of Template ######


close $out_file


#####################################################################################################

# Create MATLAB model

set file_name "${out_dir}${component_name}_model.m"

if { [ catch { set out_file [ open $file_name w ] } err ] } {
    send_message "error" "$err"
    return
}

puts $out_file {

% ================================================================================
% Legal Notice: Copyright (C) 1991-2006 Altera Corporation
% Any megafunction design, and related net list (encrypted or decrypted),
% support information, device programming or simulation file, and any other
% associated documentation or information provided by Altera or a partner
% under Altera's Megafunction Partnership Program may be used only to
% program PLD devices (but not masked PLD devices) from Altera.  Any other
% use of such megafunction design, net list, support information, device
% programming or simulation file, or any other related documentation or
% information is prohibited for any other purpose, including, but not
% limited to modification, reverse engineering, de-compiling, or use with
% any other silicon devices, unless such use is explicitly licensed under
% a separate agreement with Altera or a megafunction partner.  Title to
% the intellectual property, including patents, copyrights, trademarks,
% trade secrets, or maskworks, embodied in any such megafunction design,
% net list, support information, device programming or simulation file, or
% any other related documentation or information provided by Altera or a
% megafunction partner, remains with Altera, the megafunction partner, or
% their respective licensors.  No other licenses, including any licenses
% needed under any third party's intellectual property, are provided herein.
% ================================================================================
}
	puts $out_file "% Generated on: [clock format [clock seconds] -format "%m/%d/%Y %H:%M:%S"]"
	puts $out_file "% Generated by: FIR Compiler II $version"
	puts $out_file "%---------------------------------------------------------------------------------------------------------"
	puts $out_file "%"
	puts $out_file "%	THIS IS A WIZARD GENERATED FILE. DO NOT EDIT THIS FILE!"
	puts $out_file "%"
	puts $out_file "%---------------------------------------------------------------------------------------------------------"
	puts $out_file ""
	
	puts $out_file "clear;"
	puts $out_file ""

	puts $out_file "sx = 1;"
	puts $out_file "num_ch = $NUM_OF_CHANNELS_c;"
	
if { $filter_type == "Decimation" } {
	puts $out_file "poly_type = 'decimation';"
	puts $out_file "dec_fact = $decimN;"
	puts $out_file "int_fact = 1;"	
} elseif { $filter_type == "Interpolation" } {
	puts $out_file "poly_type = 'interpolation';"
	puts $out_file "int_fact = $interpN;"
	puts $out_file "dec_fact = 1;"
	puts $out_file "decimation_selected = false;"	
} elseif { $filter_type == "Fractional Rate" } {
	puts $out_file "poly_type = 'fractional';"
	puts $out_file "int_fact = $interpN;"
	puts $out_file "dec_fact = $decimN;"
	puts $out_file "decimation_selected = true;"
} else {
	puts $out_file "poly_type = 'single_rate';"
	puts $out_file "dec_fact = 1;"
	puts $out_file "int_fact = 1;"
}

	puts $out_file "bankcount = $bankcount;"
	puts $out_file "pfc_exists = $pfc_exists;"

if {$coefficient_reload == "true" && $coefficientWriteable == "true"} {

  if {$MCV_selected == "true" } {
	puts $out_file "  coef_in_file = fopen ('${component_name}_coef_reload.txt', 'r');"
	puts $out_file "  h = fscanf(coef_in_file, '%d' );"
	puts $out_file "  h = h';"
	puts $out_file "  fclose(coef_in_file);"

  } elseif {$Aion_selected} {
	puts $out_file "  coef_in_file = fopen ('${component_name}_coef_int.txt', 'r');"
	puts $out_file "  h = fscanf(coef_in_file, '%d' );"
	puts $out_file "  h = h';"
	puts $out_file "  fclose(coef_in_file);"

  } else {
	puts $out_file "  coef_in_file = fopen ('${component_name}_coef_reload.txt', 'r');"
	puts $out_file "  h_in = fscanf(coef_in_file, '%d' );"
	puts $out_file "  h_in = h_in';"
	puts $out_file "  fclose(coef_in_file);"
	puts $out_file ""
	puts $out_file "  ntaps = length(h_in)/bankcount;"
	puts $out_file "  h =zeros(bankcount,ntaps);"
	puts $out_file "  for b=0:bankcount-1"
	puts $out_file "    h(b+1,:) = h_in((b)*ntaps+1:(b)*ntaps+ntaps);"
	puts $out_file "  end"
  }
}

	puts $out_file "for j = 1:sx"
	puts $out_file "    %"
	puts $out_file "    %open and read data from file"
	puts $out_file "    %"
	puts $out_file "    file_name = \['${component_name}_input.txt'\];"
	puts $out_file "    infile = fopen (file_name, 'r');"
	puts $out_file ""
	
#if($is_reg_test)                
#    % parse NUMSYMBOLS identifier
#    % numwords = fgets(infile); %not in the file any more
#end                

## After Line 442  output_channel=zeros(num_ch, length(data)/(poly_fact*num_ch));

###### Begin Template ######

puts $out_file {

    % read in data from the file
    if (bankcount >1)
      input = fscanf(infile, '%d %d',[2 inf])';
      bank = input(:,2);
    else 
      input = fscanf(infile, '%d');
    end
    
    fclose(infile);

    data = input(:,1);

    % array to store output, one row of data for each channel
    if (strcmp(poly_type,'single_rate'))
      if (floor(length(data)/num_ch)*num_ch~=length(data))
        data=data(1:floor(length(data)/num_ch)*num_ch);
      end  
      output_channel=zeros(num_ch, length(data)/num_ch);
    elseif (strcmp(poly_type,'interpolation') || strcmp(poly_type,'fractional'))
      output_channel=zeros(num_ch, length(data)*int_fact/dec_fact/num_ch);
    elseif (strcmp(poly_type,'decimation'))
      if (pfc_exists == false)
            if (floor(length(data)/dec_fact)*dec_fact~=length(data))
                data=data(1:floor(length(data)/dec_fact)*dec_fact);
            end
            data = reshape(data,dec_fact,length(data)/dec_fact);
        else
            if (floor(length(data)/num_ch)*num_ch~=length(data))
                data=data(1:floor(length(data)/num_ch)*num_ch);
            end
        end
    end  

    for i = 1: num_ch

      % parse data for this channeldata(1:num_ch:end)'
      if (strcmp(poly_type,'decimation') && pfc_exists == false)
        data_channel = data(:,i:num_ch:(end-num_ch+i));
        data_channel = data_channel(:)';
      else
        data_channel = data(i:num_ch:end)';
        if (bankcount>1)
          bank_channel = bank(i:num_ch:end)';
          bank_int=zeros(length(bank_channel)*int_fact,1);
          for m=1:length(bank_channel)
            for n=1:int_fact
              bank_int((m-1)*int_fact+n) = bank_channel(m);
            end
          end
          bank_channel=bank_int;
        end
      end
        
     % run this output through the model }                  

###### End of Template ######

if {$coefficient_reload == "true" && $coefficientWriteable == "true"} {
	puts $out_file "      if(bankcount>1)"
	puts $out_file "        output = ${component_name}_mlab(data_channel, bank_channel, h);"
	puts $out_file "      else"
	puts $out_file "        output = ${component_name}_mlab(data_channel, h);"
	puts $out_file "      end"	
} else {
	puts $out_file "      if(bankcount>1)"
	puts $out_file "        output = ${component_name}_mlab(data_channel, bank_channel);"
	puts $out_file "      else"
	puts $out_file "        output = ${component_name}_mlab(data_channel);"
	puts $out_file "      end"
}

	puts $out_file ""
	puts $out_file "      %store this in array"
	puts $out_file "      output_channel(i, :) = output;"
	puts $out_file ""
	
	puts $out_file "    end"
	puts $out_file ""
	
	puts $out_file "    % reshape the output_channel so that the is channelwise"
	puts $out_file ""
	    
	puts $out_file "    if (strcmp(poly_type,'single_rate'))"
	puts $out_file "      reshaped_output=reshape(output_channel, length(data), 1);"
	puts $out_file "        elseif ( strcmp(poly_type,'interpolation') || strcmp(poly_type,'fractional') )"
	puts $out_file "      if (pfc_exists == false)"
	puts $out_file "        reshaped_output_temp=reshape(output_channel, int_fact/dec_fact, length(data));"
	puts $out_file "        reshaped_output =\[\];"
	puts $out_file "        for i = 1:length(data_channel)"
	puts $out_file "           reshaped_output = \[reshaped_output reshaped_output_temp(:,i:length(data_channel):length(data))\];"
	puts $out_file "        end"
	puts $out_file "        reshaped_output=reshape(reshaped_output,length(data)*int_fact/dec_fact,1);"
	puts $out_file "      else"
	puts $out_file "        reshaped_output=reshape(output_channel, length(data) * int_fact/dec_fact, 1);"
	puts $out_file "      end"
	puts $out_file "    elseif (strcmp(poly_type,'decimation'))"
	puts $out_file ""
	
if {($filter_type == "Decimation") && ($MCV_selected || $Aion_selected)} {
	puts $out_file "        output_length=length(output_channel(1,:));"
	puts $out_file "        reshaped_output_full=\[\];"
	puts $out_file "        for i = 1: (output_length/dec_fact)"
	puts $out_file "            reshaped_output_full=\[reshaped_output_full; output_channel(:,(dec_fact*(i-1)+1):dec_fact*i)\];"
	puts $out_file "        end"
	puts $out_file "        output_channel=output_channel(:,\[dec_fact:dec_fact:output_length\]);"
}

	puts $out_file "        reshaped_output=reshape(output_channel, length(output_channel(:)), 1);"
	puts $out_file "    end"
	puts $out_file ""
	      
	puts $out_file "    % Write data out to file"
	puts $out_file "    file_name = \['${component_name}_model_output'\];"
	puts $out_file ""
	
	puts $out_file "    outfile1 = fopen(\[file_name, '.txt'\],'w');"

if { $OUT_WIDTH_c > 32 } {

	set num_of_hex_digit [expr int($OUT_WIDTH_c/4)]

 #set ($num_of_hex_digit = $math.toInteger($math.div($OUT_WIDTH_c, 4)))

  if { [expr $num_of_hex_digit*4] < $OUT_WIDTH_c } {
    set num_of_hex_digit [expr $num_of_hex_digit + 1]
  }

	puts $out_file "    for i=1:length(reshaped_output)"
	puts $out_file "        if reshaped_output(i)>=0"
	puts $out_file "         fprintf(outfile1, '%s\\n',dec2hex(reshaped_output(i),$num_of_hex_digit));"
	puts $out_file "        else"
	puts $out_file "         fprintf(outfile1, '%s\\n',dec2hex(2^(${num_of_hex_digit}*4)+reshaped_output(i),$num_of_hex_digit));"
	puts $out_file "        end"
	puts $out_file "    end"
	puts $out_file "    fclose(outfile1);"
	puts $out_file ""
	
  if {($filter_type == "Decimation") && ($MCV_selected || $Aion_selected)} {
	puts $out_file "    outfile2=  fopen(\[file_name, '_full.txt'\],'w');"
	puts $out_file "    for i=1:length(reshaped_output_full)"
	puts $out_file "      for j=1:dec_fact"
	puts $out_file "        if reshaped_output_full(i,j)>=0"
	puts $out_file "         fprintf(outfile2, '%s ',dec2hex(reshaped_output_full(i,j),$num_of_hex_digit));"
	puts $out_file "        else"
	puts $out_file "         fprintf(outfile2, '%s ',dec2hex(2^(${num_of_hex_digit}*4)+reshaped_output_full(i,j),$num_of_hex_digit));"
	puts $out_file "        end"
	puts $out_file "      end"
	puts $out_file "      fprintf(outfile2, '\\n');"
	puts $out_file "    end"
	puts $out_file "    fclose(outfile2);"
  }

} else {

	puts $out_file "    fprintf(outfile1, '%ld\\n', reshaped_output);"
	puts $out_file "    fclose(outfile1);"
  
  if {($filter_type == "Decimation") && ($MCV_selected || $Aion_selected)} {
  
	puts $out_file "    outfile2=  fopen(\[file_name, '_full.txt'\],'w');"
	
	#fprintf(outfile2, '#set($cnt= 0)#foreach($i in [1..$POLY_FACTOR_c])#if($cnt > 0) #end%d#set($cnt= $cnt + 1)#end\n',reshaped_output_full');
	
	set out_element ""
	for {set cnt 0} {$cnt < $decimN} {incr cnt } {
  lappend out_element "%d"
  }
		
	puts $out_file "    fprintf(outfile2, '$out_element \\n',reshaped_output_full');"
	puts $out_file "    fclose(outfile2);"
  }
}
	puts $out_file "end"

close $out_file

#####################################################################################################

# Generate coefficient file

set file_name "${out_dir}${component_name}_coef_int.txt"

if { [ catch { set out_file [ open $file_name w ] } err ] } {
    send_message "error" "$err"
    return
}

if {$symmetry_type == "sym" || $symmetry_type == "asym"} {
	set num_eff_coeff [expr int([expr ceil ( [ expr double($num_coeff) / 2 ] )])]
} else {
	set num_eff_coeff $num_coeff
}

for {set bank 0} {$bank < $bankcount} {incr bank} {
  for {set cnt 0} {$cnt < $num_eff_coeff} {incr cnt} {
    lappend EFF_COEF_ARRAY_LIST [lindex $COEF_ARRAY_LIST [expr $num_coeff*$bank+$cnt]]
  }
}

for {set cnt 0} {$cnt < [llength $EFF_COEF_ARRAY_LIST]} {incr cnt } {
  puts $out_file [lindex $EFF_COEF_ARRAY_LIST $cnt]
}

close $out_file

#####################################################################################################

# Generate coefficient reloading file if coefficient reloading option is enabled

if {$coefficient_reload == "true" && $coefficientWriteable == "true"} {

  set file_name "${out_dir}${component_name}_coef_reload.txt"
  set file_name_rtl "${out_dir}${component_name}_coef_reload_rtl.txt"
  
  if { [ catch { set out_file [ open $file_name w ] } err ] } {
      send_message "error" "$err"
      return
  }

  if { [ catch { set out_file_rtl [ open $file_name_rtl w ] } err ] } {
      send_message "error" "$err"
      return
  }

  set min_limit [expr 0 - [expr pow (2,[expr $coeff_bit_width-1])]]
  set max_limit [expr [expr pow (2,[expr $coeff_bit_width-1])] - 1]

  set rand_coeff_cnt [expr int([expr ceil ( [ expr double($num_coeff) / 2 ] )])]
  set last_part_coeff_cnt [expr $num_coeff - $rand_coeff_cnt]
  set rand_coeff_full_set ""
  set rand_coeff_full_set_rtl ""

  for {set bank 0} {$bank < $bankcount} {incr bank } {

    set rand_coeff_set ""
    set rand_coeff_set_rtl ""
    
    if { $symmetry_type == "sym" } {
      # Generate random number in the range [min,max]
      for {set cnt 0} {$cnt < $rand_coeff_cnt} {incr cnt } {
        lappend rand_coeff_set [expr {int(rand()*($max_limit-$min_limit+1)+$min_limit)}]
      }
      set rand_coeff_set_rtl $rand_coeff_set
    
      # Fill in the remaining coefficients for sym type 
      for {set cnt $last_part_coeff_cnt} {$cnt > 0} {incr cnt -1} {
        lappend rand_coeff_set [lindex $rand_coeff_set [expr $cnt-1] ]
      }
    
    } elseif { $symmetry_type == "asym" } {
      # Generate random number in the range [min,max]
      for {set cnt 0} {$cnt < $rand_coeff_cnt} {incr cnt } {
        lappend rand_coeff_set [expr {int(rand()*($max_limit-$min_limit+1)+$min_limit)}]
      }	
    
      # Set middle coefficient to 0 if odd length
      if { [expr $num_coeff % 2] == 1 } {
        set rand_coeff_set [lreplace $rand_coeff_set [expr $rand_coeff_cnt - 1] [expr $rand_coeff_cnt - 1] 0]
      }
      
      set rand_coeff_set_rtl $rand_coeff_set
      
      # Fill in the remaining coefficients for asym type
      for {set cnt $last_part_coeff_cnt} {$cnt > 0} {incr cnt -1} {
        lappend rand_coeff_set [expr [lindex $rand_coeff_set [expr $cnt-1] ] * -1 ]
      }	
    
    } else {
    
      for {set cnt 0} {$cnt < $num_coeff} {incr cnt } {
        # Generate random number in the range [min,max]
        lappend rand_coeff_set [expr {int(rand()*($max_limit-$min_limit+1)+$min_limit)}]
      }
      set rand_coeff_set_rtl $rand_coeff_set 
    
    }
    set rand_coeff_full_set [concat $rand_coeff_full_set $rand_coeff_set]
    set rand_coeff_full_set_rtl [concat $rand_coeff_full_set_rtl $rand_coeff_set_rtl]
  }

  # Write coefficient set into output file
  for {set cnt 0} {$cnt < [expr $bankcount * $num_coeff]} {incr cnt } {
    puts $out_file [lindex $rand_coeff_full_set $cnt]
  }
  
  # Write rtl coefficient set into output file
  for {set cnt 0} {$cnt < [llength $rand_coeff_full_set_rtl]} {incr cnt } {
    puts $out_file_rtl [lindex $rand_coeff_full_set_rtl $cnt]
  }
    
  close $out_file
  close $out_file_rtl
}