// *****************************************************************************
//
// Copyright 2007-2013 Mentor Graphics Corporation
// All Rights Reserved.
//
// THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION WHICH IS THE PROPERTY OF
// MENTOR GRAPHICS CORPORATION OR ITS LICENSORS AND IS SUBJECT TO LICENSE TERMS.
//
// *****************************************************************************
// SystemVerilog           Version: 20130911_Questa_10.2c
// *****************************************************************************

// Title: axi_top
//

package mgc_axi_pkg;
import QUESTA_MVC::*;

`ifdef MODEL_TECH
// *****************************************************************************
//
// Copyright 2007-2013 Mentor Graphics Corporation
// All Rights Reserved.
//
// THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION WHICH IS THE PROPERTY OF
// MENTOR GRAPHICS CORPORATION OR ITS LICENSORS AND IS SUBJECT TO LICENSE TERMS.
//
// *****************************************************************************
// SystemVerilog           Version: 20130911_Questa_10.2c
// *****************************************************************************

// Title: axi_types
//

// enum: axi_size_e
//
//------------------------------------------------------------------------------
//  Word size encoding 
//------------------------------------------------------------------------------
typedef enum bit [2:0]
{
    AXI_BYTES_1   = 3'h0,
    AXI_BYTES_2   = 3'h1,
    AXI_BYTES_4   = 3'h2,
    AXI_BYTES_8   = 3'h3,
    AXI_BYTES_16  = 3'h4,
    AXI_BYTES_32  = 3'h5,
    AXI_BYTES_64  = 3'h6,
    AXI_BYTES_128 = 3'h7
} axi_size_e;


// enum: axi_prot_e
//
//------------------------------------------------------------------------------
//  Protection type 
//------------------------------------------------------------------------------
typedef enum bit [2:0]
{
    AXI_NORM_SEC_DATA    = 3'h0,
    AXI_PRIV_SEC_DATA    = 3'h1,
    AXI_NORM_NONSEC_DATA = 3'h2,
    AXI_PRIV_NONSEC_DATA = 3'h3,
    AXI_NORM_SEC_INST    = 3'h4,
    AXI_PRIV_SEC_INST    = 3'h5,
    AXI_NORM_NONSEC_INST = 3'h6,
    AXI_PRIV_NONSEC_INST = 3'h7
} axi_prot_e;


// enum: axi_cache_e
//
//------------------------------------------------------------------------------
//  Cache type
//------------------------------------------------------------------------------
typedef enum bit [3:0]
{
    AXI_NONCACHE_NONBUF             = 4'h0,
    AXI_BUF_ONLY                    = 4'h1,
    AXI_CACHE_NOALLOC               = 4'h2,
    AXI_CACHE_BUF_NOALLOC           = 4'h3,
    AXI_CACHE_RSVD0                 = 4'h4,
    AXI_CACHE_RSVD1                 = 4'h5,
    AXI_CACHE_WTHROUGH_ALLOC_R_ONLY = 4'h6,
    AXI_CACHE_WBACK_ALLOC_R_ONLY    = 4'h7,
    AXI_CACHE_RSVD2                 = 4'h8,
    AXI_CACHE_RSVD3                 = 4'h9,
    AXI_CACHE_WTHROUGH_ALLOC_W_ONLY = 4'ha,
    AXI_CACHE_WBACK_ALLOC_W_ONLY    = 4'hb,
    AXI_CACHE_RSVD4                 = 4'hc,
    AXI_CACHE_RSVD5                 = 4'hd,
    AXI_CACHE_WTHROUGH_ALLOC_RW     = 4'he,
    AXI_CACHE_WBACK_ALLOC_RW        = 4'hf
} axi_cache_e;


// enum: axi_burst_e
//
//------------------------------------------------------------------------------
//  Burst type - determines address calculation
//------------------------------------------------------------------------------
typedef enum bit [1:0]
{
    AXI_FIXED      = 2'h0,
    AXI_INCR       = 2'h1,
    AXI_WRAP       = 2'h2,
    AXI_BURST_RSVD = 2'h3
} axi_burst_e;


// enum: axi_response_e
//
//------------------------------------------------------------------------------
//  Response type 
//------------------------------------------------------------------------------
typedef enum bit [1:0]
{
    AXI_OKAY   = 2'h0,
    AXI_EXOKAY = 2'h1,
    AXI_SLVERR = 2'h2,
    AXI_DECERR = 2'h3
} axi_response_e;


// enum: axi_lock_e
//
//------------------------------------------------------------------------------
//  Lock type for atomic accesses
//------------------------------------------------------------------------------
typedef enum bit [1:0]
{
    AXI_NORMAL    = 2'h0,
    AXI_EXCLUSIVE = 2'h1,
    AXI_LOCKED    = 2'h2,
    AXI_LOCK_RSVD = 2'h3
} axi_lock_e;


// enum: axi_abstraction_level_e
//
//------------------------------------------------------------------------------
//  Abstraction level control
//------------------------------------------------------------------------------
typedef enum bit [2:0]
{
    AXI_PV       = 3'h0,
    AXI_PVT      = 3'h1,
    AXI_CC_BURST = 3'h2,
    AXI_CC_PHASE = 3'h3,
    AXI_CA       = 3'h4
} axi_abstraction_level_e;


// enum: axi_rw_e
//
typedef enum bit [0:0]
{
    AXI_TRANS_READ  = 1'h0,
    AXI_TRANS_WRITE = 1'h1
} axi_rw_e;


// enum: axi_error_e
//
typedef enum bit [3:0]
{
    AXI_AWBURST_RSVD        = 4'h0,
    AXI_ARBURST_RSVD        = 4'h1,
    AXI_AWSIZE_GT_BUS_WIDTH = 4'h2,
    AXI_ARSIZE_GT_BUS_WIDTH = 4'h3,
    AXI_AWLOCK_RSVD         = 4'h4,
    AXI_ARLOCK_RSVD         = 4'h5,
    AXI_AWLEN_LAST_MISMATCH = 4'h6,
    AXI_AWID_WID_MISMATCH   = 4'h7,
    AXI_WSTRB_ILLEGAL       = 4'h8,
    AXI_AWCACHE_RSVD        = 4'h9,
    AXI_ARCACHE_RSVD        = 4'ha
} axi_error_e;


// enum: axi_assertion_type_e
//
//------------------------------------------------------------------------------
//  Type defining the error messages which can be produced by the <mgc_axi> MVC.
// 
// Individual error messages can be disabled using the <IF::config_enable_error> array of configuration bits.
// 
//------------------------------------------------------------------------------
//    AXI_ARESETn_SIGNAL_Z -  AXI reset signal (ARESETn) has a value Z
//    AXI_ARESETn_SIGNAL_X -  AXI reset signal (ARESETn) has a value X
//    AXI_ACLK_SIGNAL_Z -  
//    AXI_ADDR_FOR_READ_BURST_ACROSS_4K_BOUNDARY -  This read transaction has crossed a 4KB boundary (SPEC3(A3.4.1))
//    AXI_ADDR_FOR_WRITE_BURST_ACROSS_4K_BOUNDARY -  This write transaction has crossed a 4KB boundary (SPEC3(A3.4.1))
//    AXI_ARADDR_CHANGED_BEFORE_ARREADY -  The value of <IF::ARADDR> has changed from its initial value between the time <IF::ARVALID> was asserted, and before <IF::ARREADY> was asserted (SPEC3(A3.2.1))
//    AXI_ARADDR_UNKN -  <IF::ARADDR> has an X value/<IF::ARADDR> has an Z value (SPEC3(A2.5))
//    AXI_ARBURST_CHANGED_BEFORE_ARREADY -  The value of <IF::ARBURST> has changed from its initial value between the time <IF::ARVALID> was asserted, and before <IF::ARREADY> was asserted (SPEC3(A3.2.1))
//    AXI_ARBURST_UNKN -  <IF::ARBURST> has an X value/<IF::ARBURST> has an Z value (SPEC3(A2.5))
//    AXI_ARCACHE_CHANGED_BEFORE_ARREADY -  The value of <IF::ARCACHE> has changed from its initial value between the time <IF::ARVALID> was asserted, and before <IF::ARREADY> was asserted (SPEC3(A3.2.1))
//    AXI_ARCACHE_UNKN -  <IF::ARCACHE> has an X value/<IF::ARCACHE> has an Z value (SPEC3(A2.5))
//    AXI_ARID_CHANGED_BEFORE_ARREADY -  The value of <IF::ARID> has changed from its initial value between the time <IF::ARVALID> was asserted, and before <IF::ARREADY> was asserted (SPEC3(A3.2.1))
//    AXI_ARID_UNKN -  <IF::ARID> has an X value/<IF::ARID> has an Z value (SPEC3(A2.5))
//    AXI_ARLEN_CHANGED_BEFORE_ARREADY -  The value of <IF::ARLEN> has changed from its initial value between the time <IF::ARVALID> was asserted, and before <IF::ARREADY> was asserted (SPEC3(A3.2.1))
//    AXI_ARLEN_UNKN -  <IF::ARLEN> has an X value/<IF::ARLEN> has an Z value (SPEC3(A2.5))
//    AXI_ARLOCK_CHANGED_BEFORE_ARREADY -  The value of <IF::ARLOCK> has changed from its initial value between the time <IF::ARVALID> was asserted, and before <IF::ARREADY> was asserted (SPEC3(A3.2.1))
//    AXI_ARLOCK_UNKN -  <IF::ARLOCK> has an X value/<IF::ARLOCK> has an Z value (SPEC3(A2.5))
//    AXI_ARPROT_CHANGED_BEFORE_ARREADY -  The value of <IF::ARPROT> has changed from its initial value between the time <IF::ARVALID> was asserted, and before <IF::ARREADY> was asserted (SPEC3(A3.2.1))
//    AXI_ARPROT_UNKN -  <IF::ARPROT> has an X value/<IF::ARPROT> has an Z value (SPEC3(A2.5))
//    AXI_ARREADY_UNKN -  <IF::ARREADY> has an X value/<IF::ARREADY> has a Z value (SPEC3(A2.5))
//    AXI_ARSIZE_CHANGED_BEFORE_ARREADY -  The value of <IF::ARSIZE> has changed from its initial value between the time <IF::ARVALID> was asserted, and before <IF::ARREADY> was asserted (SPEC3(A3.2.1))
//    AXI_ARSIZE_UNKN -  <IF::ARSIZE> has an X value/<IF::ARSIZE> has an Z value (SPEC3(A2.5))
//    AXI_ARUSER_CHANGED_BEFORE_ARREADY -  The value of <IF::ARUSER> has changed from its initial value between the time <IF::ARVALID> was asserted, and before <IF::ARREADY> was asserted (SPEC3(A3.2.1))
//    AXI_ARUSER_UNKN -  <IF::ARUSER> has an X value/<IF::ARUSER> has an Z value (SPEC3(A2.5))
//    AXI_ARVALID_DEASSERTED_BEFORE_ARREADY -  <IF::ARVALID> has been de-asserted before <IF::ARREADY> was asserted (SPEC3(A3.2.1))
//    AXI_ARVALID_HIGH_ON_FIRST_CLOCK_AFTER_RESET -  A master interface must begin driving <IF::ARVALID> high only at a rising clock edge after <IF::ARESETn> is HIGH (SPEC3(A3.1.2))
//    AXI_ARVALID_UNKN -  <IF::ARVALID> has an X value/<IF::ARVALID> has an Z value (SPEC3(A2.5))
//    AXI_AWADDR_CHANGED_BEFORE_AWREADY -  The value of <IF::AWADDR> has changed from its initial value between the time <IF::AWVALID> was asserted, and before <IF::AWREADY> was asserted (SPEC3(A3.2.1))
//    AXI_AWADDR_UNKN -  <IF::AWADDR> has an X value/<IF::AWADDR> has an Z value (SPEC3(A2.2))
//    AXI_AWBURST_CHANGED_BEFORE_AWREADY -  The value of <IF::AWBURST> has changed from its initial value between the time <IF::AWVALID> was asserted, and before <IF::AWREADY> was asserted (SPEC3(A3.2.1))
//    AXI_AWBURST_UNKN -  <IF::AWBURST> has an X value/<IF::AWBURST> has an Z value (SPEC3(A2.2))
//    AXI_AWCACHE_CHANGED_BEFORE_AWREADY -  The value of <IF::AWCACHE> has changed from its initial value between the time <IF::AWVALID> was asserted, and before <IF::AWREADY> was asserted (SPEC3(A3.2.1))                       
//    AXI_AWCACHE_UNKN -  <IF::AWCACHE> has an X value/AWCACHE has an Z value (SPEC3(A2.2))
//    AXI_AWID_CHANGED_BEFORE_AWREADY -  The value of <IF::AWID> has changed from its initial value between the time <IF::AWVALID> was asserted, and before <IF::AWREADY> was asserted (SPEC3(A3.2.1))
//    AXI_AWID_UNKN -  <IF::AWID> has an X value/<IF::AWID> has an Z value (SPEC3(A2.2))
//    AXI_AWLEN_CHANGED_BEFORE_AWREADY -  The value of <IF::AWLEN> has changed from its initial value between the time <IF::AWVALID> was asserted, and before <IF::AWREADY> was asserted (SPEC3(A3.2.1))
//    AXI_AWLEN_UNKN -  <IF::AWLEN> has an X value/<IF::AWLEN> has an Z value (SPEC3(A2.2))                                                                                                                                        
//    AXI_AWLOCK_CHANGED_BEFORE_AWREADY -  The value of <IF::AWLOCK> has changed from its initial value between the time <IF::AWVALID> was asserted, and before <IF::AWREADY> was asserted (SPEC3(A3.2.1))                            
//    AXI_AWLOCK_UNKN -  <IF::AWLOCK> has an X value/<IF::AWLOCK> has an Z value (SPEC3(A2.2))
//    AXI_AWPROT_CHANGED_BEFORE_AWREADY -  The value of <IF::AWPROT> has changed from its initial value between the time <IF::AWVALID> was asserted, and before <IF::AWREADY> was asserted (SPEC3(A3.2.1))                          
//    AXI_AWPROT_UNKN -  <IF::AWPROT> has an X value/<IF::AWPROT> has an Z value (SPEC3(A2.2))                                                                                                                                        
//    AXI_AWREADY_UNKN -  <IF::AWREADY> has an X value/<IF::AWREADY> has an Z value (SPEC3(A2.2))                                                                                                                                        
//    AXI_AWSIZE_CHANGED_BEFORE_AWREADY -  The value of <IF::AWSIZE> has changed from its initial value between the time <IF::AWVALID> was asserted, and before <IF::AWREADY> was asserted (SPEC3(A3.2.1))                                       
//    AXI_AWSIZE_UNKN -  <IF::AWSIZE> has an X value/<IF::AWSIZE> has an Z value (SPEC3(A2.2))                                                                                                                                                 
//    AXI_AWUSER_CHANGED_BEFORE_AWREADY -  The value of <IF::AWUSER> has changed from its initial value between the time <IF::AWVALID> was asserted, and before <IF::AWREADY> was asserted (SPEC3(A3.2.1))                                           
//    AXI_AWUSER_UNKN -  <IF::AWUSER> has an X value/<IF::AWUSER> has an Z value (SPEC3(A3.1))                                                                                                                                                    
//    AXI_AWVALID_DEASSERTED_BEFORE_AWREADY -  <IF::AWVALID> has been de-asserted before <IF::AWREADY> was asserted (SPEC3(A3.2.2))                                                                                                                  
//    AXI_AWVALID_HIGH_ON_FIRST_CLOCK_AFTER_RESET -  A master interface must begin driving <IF::AWVALID> high only at a rising clock edge after <IF::ARESETn> is HIGH (SPEC3(A3.1.2))                                                               
//    AXI_AWVALID_UNKN -  <IF::AWVALID> has an X value/<IF::AWVALID> has an Z value (SPEC3(A2.2))                                                                                                                                                 
//    AXI_BID_CHANGED_BEFORE_BREADY -  The value of <IF::BID> has changed from its initial value between the time <IF::BVALID> was asserted, and before <IF::BREADY> was asserted (SPEC3(A3.2.1))                                                 
//    AXI_BID_UNKN -  <IF::BID> has an X value/<IF::BID> has a Z value (SPEC3(A2.4))                                                                                                                                                       
//    AXI_BREADY_UNKN -  <IF::BREADY> has an X value/<IF::BREADY> has an Z value (SPEC3(A2.4))                                                                                                                                                 
//    AXI_BRESP_CHANGED_BEFORE_BREADY -  The value of <IF::BRESP> has changed from its initial value between the time <IF::BVALID> was asserted, and before <IF::BREADY> was asserted (SPEC3(A3.2.1))                                            
//    AXI_BRESP_UNKN -  <IF::BRESP> has an X value/<IF::BRESP> has a Z value (SPEC3(A2.4))                                                                                                                                                   
//    AXI_BUSER_CHANGED_BEFORE_BREADY -  The value of <IF::BUSER> has changed from its initial value between the time <IF::BVALID> was asserted, and before <IF::BREADY> was asserted (SPEC3(A3.2.1))                                       
//    AXI_BUSER_UNKN -  <IF::BUSER> has an X value/<IF::BUSER> has a Z value (SPEC3(A2.4))                                                                                                                                                       
//    AXI_BVALID_DEASSERTED_BEFORE_BREADY -  <IF::BVALID> has been de-asserted before <IF::BREADY> was asserted (SPEC3(A3.2.1))                                                                                                                       
//    AXI_BVALID_HIGH_ON_FIRST_CLOCK_AFTER_RESET -  A slave interface must begin driving  <IF::BVALID> high only at a rising clock edge after ARESETn is HIGH (SPEC3(A3.1.2))                                                                        
//    AXI_BVALID_UNKN -  <IF::BVALID> has an X value/<IF::BVALID> has a Z value (SPEC3(A2.4))                                                                                                                                                   
//    AXI_EXCLUSIVE_READ_ACCESS_MODIFIABLE -  The modifiable bit (bit 1 of the cache parameter) should not be set for an exclusive read access (SPEC3(A7.2.4))                                                                                 
//    AXI_EXCLUSIVE_READ_BYTES_TRANSFER_EXCEEDS_128 -  Number of bytes in an exclusive read transaction must be less than or equal to 128 (SPEC3(A7.2.4))                                                                                         
//    AXI_EXCLUSIVE_WRITE_BYTES_TRANSFER_EXCEEDS_128 -  Number of bytes in an exclusive write transaction must be less than or equal to 128 (SPEC3(A7.2.4))                                                                                
//    AXI_EXCLUSIVE_READ_BYTES_TRANSFER_NOT_POWER_OF_2 -  Number of bytes of an exclusive read transaction is not a power of 2 (SPEC3(A7.2.4))                                                                                           
//    AXI_EXCLUSIVE_WRITE_BYTES_TRANSFER_NOT_POWER_OF_2 -  Number of bytes of an exclusive write transaction is not a power of 2 (SPEC3(A7.2.4))                                                                                               
//    AXI_EXCLUSIVE_WR_ADDRESS_NOT_SAME_AS_RD -  Exclusive write does not match the address of the previous exclusive read to this id (SPEC3(A7.2.4))                                                                                        
//    AXI_EXCLUSIVE_WR_BURST_NOT_SAME_AS_RD -  Exclusive write does not match the burst setting of the previous exclusive read to this id (SPEC3(A7.2.4))                                                                                      
//    AXI_EXCLUSIVE_WR_CACHE_NOT_SAME_AS_RD -  Exclusive write does not match the cache setting of the previous exclusive read to this id (see the ARM AXI compliance-checker AXI_RECM_EXCL_MATCH assertion code) (SPEC3(A7.2.4))            
//    AXI_EXCLUSIVE_WRITE_ACCESS_MODIFIABLE -  The modifiable bit (bit 1 of the cache parameter) should not be set for an exclusive write access (SPEC3(A7.2.4))                                                               
//    AXI_EXCLUSIVE_WR_LENGTH_NOT_SAME_AS_RD -  Exclusive write does not match the length of the previous exclusive read to this id (SPEC3(A7.2.4))                                                                           
//    AXI_EXCLUSIVE_WR_PROT_NOT_SAME_AS_RD -  Exclusive write does not match the prot setting of the previous exclusive read to this id (SPEC3(A7.2.4))                                                                       
//    AXI_EXCLUSIVE_WR_SIZE_NOT_SAME_AS_RD -  Exclusive write does not match the size of the previous exclusive read to this id (SPEC3(A7.2.4))                                                                               
//    AXI_EXOKAY_RESPONSE_NORMAL_READ -  Slave has responded <AXI_EXOKAY> to a non exclusive read transfer                                                                                                                
//    AXI_EXOKAY_RESPONSE_NORMAL_WRITE -  Slave has responded <AXI_EXOKAY> to a non exclusive write transfer                                                                                                               
//    AXI_EX_RD_RESP_MISMATCHED_WITH_EXPECTED_RESP -  Expected response to this exclusive read did not matched with the actual response (SPEC3(A7.2.3))                                                                            
//    AXI_EX_WR_RESP_MISMATCHED_WITH_EXPECTED_RESP -  Expected response to this exclusive write did not matched with the actual response (SPEC3(A7.2.3))                                                                           
//    AXI_EX_RD_EXOKAY_RESP_SLAVE_WITHOUT_EXCLUSIVE_ACCESS -  Response for an exclusive read to a slave which does not support exclusive access should be <AXI_OKAY>, but it returned <AXI_EXOKAY> (SPEC3(A7.2.3))
//    AXI_EX_WRITE_BEFORE_EX_READ_RESPONSE -  Exclusive write has occurred, with no previous exclusive read (SPEC3(A7.2.2))                                                                                                        
//    AXI_EX_WRITE_EXOKAY_RESP_SLAVE_WITHOUT_EXCLUSIVE_ACCESS -  Response for an exclusive write to a slave which does not support exclusive access should be <AXI_OKAY>, but it returned <AXI_EXOKAY> (SPEC3(A7.2.3))              
//    AXI_ILLEGAL_LENGTH_WRAPPING_READ_BURST -  In the last read address phase burst_length has an illegal value for a burst of type AXI_WRAP (SPEC3(A3.4.1))                                                         
//    AXI_ILLEGAL_LENGTH_WRAPPING_WRITE_BURST -  In the last write address phase burst_length has an illegal value for a burst of type AXI_WRAP (SPEC3(A3.4.1))                                                        
//    AXI_ILLEGAL_RESPONSE_EXCLUSIVE_READ -  Response for an exclusive read should be either <AXI_OKAY> or <AXI_EXOKAY> (SPEC3(A7.2.3))                                                                                    
//    AXI_ILLEGAL_RESPONSE_EXCLUSIVE_WRITE -  Response for an exclusive write should be either <AXI_OKAY> or <AXI_EXOKAY> (SPEC3(A7.2.3))                                                                                   
//    AXI_PARAM_READ_DATA_BUS_WIDTH -  The value of <IF::AXI_RDATA_WIDTH> must be one of 8,16,32,64,128,256,512,1024 (SPEC3(A1.3.1))                                                                                            
//    AXI_PARAM_WRITE_DATA_BUS_WIDTH -  The value of <IF::AXI_WDATA_WIDTH> must be one of 8,16,32,64,128,256,512,1024 (SPEC3(A1.3.1))                                                                                        
//    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_12 -  The RA bit of the cache parameter should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                                                              
//    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_13 -  The RA bit of the cache parameter should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                                                             
//    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_4 -  The RA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                                                                
//    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_5 -  The RA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                                                                  
//    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_8 -  The RA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                                                                     
//    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_9 -  The RA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                                                                     
//    AXI_READ_BURST_LENGTH_VIOLATION -  The burst_length implied by the number of beats actually read does not match the burst_length defined by the <I_F_master_read_addr_channel_phase> (SPEC3(A3.4.1))                             
//    AXI_READ_BURST_SIZE_VIOLATION -  In this read transaction, size has been set greater than the defined data bus width (SPEC3(A3.4.1))                                                                                                   
//    AXI_READ_DATA_BEFORE_ADDRESS -  An unexpected read response has occurred (there are no outstanding read transactions with this id) (SPEC3(A3.3.1))                                                                           
//    AXI_READ_DATA_CHANGED_BEFORE_RREADY -  The value of <IF::RDATA> has changed from its initial value between the time <IF::RVALID> was asserted, and before <IF::RREADY> was asserted (SPEC3(A3.2.1))                              
//    AXI_READ_DATA_UNKN -  <IF::RDATA> has an X value/<IF::RDATA> has a Z value (SPEC3(A2.6))                                                                                                                                     
//    AXI_RESERVED_ARLOCK_ENCODING -  The reserved encoding of 2'b11 should not be used for ARLOCK (SPEC3(A7.4))                                                                                                                   
//    AXI_READ_RESP_CHANGED_BEFORE_RREADY -  The value of <IF::RRESP> has changed from its initial value between the time <IF::RVALID> was asserted, and before <IF::RREADY> was asserted (SPEC3(A3.2.1))                        
//    AXI_RESERVED_ARBURST_ENCODING -  The reserved encoding of 2'b11 should not be used for <IF::ARBURST> (SPEC3(A3.4.1))                                                                                              
//    AXI_RESERVED_AWBURST_ENCODING -  The reserved encoding of 2'b11 should not be used for <IF::AWBURST> (SPEC3(A3.4.1))                                                                                                  
//    AXI_RID_CHANGED_BEFORE_RREADY -  The value of <IF::RID> has changed from its initial value between the time <IF::RVALID> was asserted, and before <IF::RREADY> was asserted (SPEC3(A3.2.1))                              
//    AXI_RID_UNKN -  <IF::RID> has an X value/<IF::RID> has a Z value (SPEC3(A2.6))                                                                                                                                    
//    AXI_RLAST_CHANGED_BEFORE_RREADY -  The value of <IF::RLAST> has changed from its initial value between the time <IF::RVALID> was asserted, and before <IF::RREADY> was asserted (SPEC3(A3.2.1))                     
//    AXI_RLAST_UNKN -  <IF::RLAST> has an X value/<IF::RLAST> has a Z value (SPEC3(A2.6))                                                                                                                                 
//    AXI_RREADY_UNKN -  <IF::RREADY> has an X value/<IF::RREADY> has a Z value (SPEC3(A2.6))                                                                                                                                   
//    AXI_RRESP_UNKN -  <IF::RRESP> has an X value/<IF::RRESP> has a Z value (SPEC3(A2.6))                                                                                                                                  
//    AXI_RUSER_CHANGED_BEFORE_RREADY -  The value of <IF::RUSER> has changed from its initial value between the time <IF::RVALID> was asserted, and before <IF::RREADY> was asserted (SPEC3(A3.2.1))                          
//    AXI_RUSER_UNKN -  <IF::RUSER> has an X value/<IF::RUSER> has a Z value (SPEC3(A2.6))                                                                                                              
//    AXI_RVALID_DEASSERTED_BEFORE_RREADY -  <IF::RVALID> has been de-asserted before <IF::RREADY> was asserted (SPEC3(A3.2.1))                                                                         
//    AXI_RVALID_HIGH_ON_FIRST_CLOCK_AFTER_RESET -  A slave interface must begin driving  <IF::RVALID> high only at a rising clock edge after ARESETn is HIGH (SPEC3(A3.1.2))                                  
//    AXI_RVALID_UNKN -  <IF::RVALID> has an X value/<IF::RVALID> has a Z value (SPEC3(A2.6))                                                                                                        
//    AXI_UNALIGNED_ADDRESS_FOR_EXCLUSIVE_READ -  Exclusive read accesses must have address aligned to the total number of bytes in the transaction (SPEC3(A7.2.4))                                     
//    AXI_UNALIGNED_ADDRESS_FOR_EXCLUSIVE_WRITE -  Exclusive write accesses must have address aligned to the total number of bytes in the transaction (SPEC3(A7.2.4))                                     
//    AXI_UNALIGNED_ADDR_FOR_WRAPPING_READ_BURST -  Wrapping bursts must have address aligned to the start of the read transfer (SPEC3(A3.4.1))                                                                                                                                    
//    AXI_UNALIGNED_ADDR_FOR_WRAPPING_WRITE_BURST -  Wrapping bursts must have address aligned to the start of the write transfet (SPEC3(A3.4.1))                                                                                                                                    
//    AXI_WDATA_CHANGED_BEFORE_WREADY_ON_INVALID_LANE -  On a lane whose strobe is 0, the value of <IF::WDATA> has changed from its initial value between the time <IF::WVALID> was asserted, and before <IF::WREADY> was asserted (SPEC3(A3.2.1))                               
//    AXI_WDATA_CHANGED_BEFORE_WREADY_ON_VALID_LANE -  On a lane whose strobe is 1, the value of <IF::WDATA> has changed from its initial value between the time <IF::WVALID> was asserted, and before <IF::WREADY> was asserted (SPEC3(A3.2.1))                                   
//    AXI_WLAST_CHANGED_BEFORE_WREADY -  The value of <IF::WLAST> has changed from its initial value between the time <IF::WVALID> was asserted, and before <IF::WREADY> was asserted (SPEC3(A3.2.1))                                
//    AXI_WID_CHANGED_BEFORE_WREADY -  The value of <IF::WID> has changed from its initial value between the time <IF::WVALID> was asserted, and before <IF::WREADY> was asserted (SPEC3(A3.2.1))                                
//    AXI_WLAST_UNKN -  <IF::WLAST> has an X value/<IF::WLAST> has an Z value (SPEC3(A2.3))                                                                                        
//    AXI_WID_UNKN -  <IF::WID> has an X value/<IF::WID> has an Z value (SPEC3(A2.3))                                                                                                     
//    AXI_WREADY_UNKN -  <IF::WREADY> has an X value/<IF::WREADY> has a Z value (SPEC3(A2.3))                                                                                       
//    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_12 -  The WA bit of the cache parameter should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                     
//    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_13 -  The WA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                   
//    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_4 -  The WA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                              
//    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_5 -  The WA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                         
//    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_8 -  The WA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                           
//    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_9 -  The WA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                            
//    AXI_WRITE_BURST_SIZE_VIOLATION -  In this write transaction, size has been set greater than the defined data buswidth (SPEC3(A3.4.1))                                         
//    AXI_WRITE_DATA_BEFORE_ADDRESS -  A write data beat has occurred before the corresponding address phase                                                                      
//    AXI_WRITE_DATA_UNKN_ON_INVALID_LANE -  On a lane whose strobe is 0, <IF::WDATA> has an X value/<IF::WDATA> has a Z value (SPEC3(A2.3))                                           
//    AXI_WRITE_DATA_UNKN_ON_VALID_LANE -  On a lane whose strobe is 1, <IF::WDATA> has an X value/<IF::WDATA> has a Z value (SPEC3(A2.3))                                          
//    AXI_RESERVED_AWLOCK_ENCODING -  The reserved encoding of 2'b11 should not be used for AWLOCK (SPEC3(A7.4))                                                                                                                                
//    AXI_WRITE_STROBE_ON_INVALID_BYTE_LANES -  Write strobe(s) incorrect for the address/size of a fixed transfer (SPEC3(A2.3))                                                                                                                  
//    AXI_WSTRB_CHANGED_BEFORE_WREADY -  The value of <IF::WSTRB> has changed from its initial value between the time <IF::WVALID> was asserted, and before <IF::WREADY> was asserted (SPEC3(A3.2.1))                                         
//    AXI_WSTRB_UNKN -  <IF::WSTRB> has an X value/<IF::WSTRB> has an Z value (SPEC3(A2.3))                                                                                                                                                      
//    AXI_WUSER_CHANGED_BEFORE_WREADY -  The value of <IF::WUSER> has changed from its initial value between the time <IF::WVALID> was asserted, and before <IF::WREADY> was asserted (SPEC3(A3.2.1))                                        
//    AXI_WUSER_UNKN -  <IF::WUSER> has an X value/<IF::WUSER> has an Z value (SPEC3(A2.3))                                                                                                                              
//    AXI_WVALID_DEASSERTED_BEFORE_WREADY -  <IF::WVALID> has been de-asserted before <IF::WREADY> was asserted (SPEC3(A3.2.1))                                                                                               
//    AXI_WVALID_HIGH_ON_FIRST_CLOCK_AFTER_RESET -  A master interface must begin driving <IF::WVALID> high only at a rising clock edge after <IF::ARESETn> is HIGH (SPEC3(A3.1.2))                                             
//    AXI_WVALID_UNKN -  <IF::WVALID> has an X value/<IF::WVALID> has an Z value (SPEC3(A2.3))                                                                                                             
//    AXI_ADDR_ACROSS_4K_WITHIN_LOCKED_WRITE_TRANSACTION -  Transactions within a locked write sequence should be within the same 4K address boundary (SPEC3(A7.3))                                           
//    AXI_ADDR_ACROSS_4K_WITHIN_LOCKED_READ_TRANSACTION -  Transactions within a locked read sequence should be within the same 4K address boundary (SPEC3(A7.3))                                            
//    AXI_AWID_CHANGED_WITHIN_LOCKED_TRANSACTION -  Master should not change the awid within the locked transaction (SPEC3(A7.3))                                               
//    AXI_ARID_CHANGED_WITHIN_LOCKED_TRANSACTION -  Master should not change the arid within the locked transaction (SPEC3(A7.3))                                              
//    AXI_AWPROT_CHANGED_WITHIN_LOCKED_TRANSACTION -  Master should not change the awprot within the locked transaction (SPEC3(A7.3))                                                   
//    AXI_ARPROT_CHANGED_WITHIN_LOCKED_TRANSACTION -  Master should not change the arprot within the locked transaction (SPEC3(A7.3))                                                 
//    AXI_AWCACHE_CHANGED_WITHIN_LOCKED_TRANSACTION -  Master should not change the awcache within the locked transaction (SPEC3(A7.3))                                                    
//    AXI_ARCACHE_CHANGED_WITHIN_LOCKED_TRANSACTION -  Master should not change the arcache within the locked transaction (SPEC3(A7.3))                                                      
//    AXI_NUMBER_OF_LOCKED_SEQUENCES_EXCEEDS_2 -  Number of accesses within a locked sequence should not be more than 2 (SPEC3(A7.3))                                                                                                     
//    AXI_LOCKED_WRITE_BEFORE_COMPLETION_OF_PREVIOUS_WRITE_TRANSACTIONS -  A locked write sequence should not commence before completion of all previously issued write addresses (SPEC3(A7.3))                                                 
//    AXI_LOCKED_WRITE_BEFORE_COMPLETION_OF_PREVIOUS_READ_TRANSACTIONS -  A locked write sequence should not commence before completion of all previously issued read addresses (SPEC3(A7.3))                                              
//    AXI_LOCKED_READ_BEFORE_COMPLETION_OF_PREVIOUS_WRITE_TRANSACTIONS -  A locked read sequence should not commence before completion of all previously issued write addresses (SPEC3(A7.3))                                                    
//    AXI_LOCKED_READ_BEFORE_COMPLETION_OF_PREVIOUS_READ_TRANSACTIONS -  A locked read sequence should not commence before completion of all previously issued read addresses (SPEC3(A7.3))                                                        
//    AXI_NEW_BURST_BEFORE_COMPLETION_OF_UNLOCK_TRANSACTION -  The unlocking transaction should be completed before further any transactions are initiated (SPEC3(A7.3))                                                           
//    AXI_UNLOCKED_WRITE_WHILE_OUTSTANDING_LOCKED_WRITES -  Unlocking write transaction started while outstanding locked write transaction has not completed (SPEC3(A7.3))                                                  
//    AXI_UNLOCKED_WRITE_WHILE_OUTSTANDING_LOCKED_READS -  Unlocking write transaction started while outstanding locked read transaction has not completed (SPEC3(A7.3))                                                 
//    AXI_UNLOCKED_READ_WHILE_OUTSTANDING_LOCKED_WRITES -  Unlocking read transaction started while outstanding locked write transaction has not completed (SPEC3(A7.3))                                                             
//    AXI_UNLOCKED_READ_WHILE_OUTSTANDING_LOCKED_READS -  Unlocking read transaction started while outstanding locked read transaction has not completed (SPEC3(A7.3))                                                     
//    AXI_UNLOCKING_TRANSACTION_WITH_AN_EXCLUSIVE_ACCESS -  Unlocking transaction can not be an exclusive access transaction (SPEC3(A7.3))                                                                                                                                                            
//    AXI_FIRST_DATA_ITEM_OF_TRANSACTION_WRITE_ORDER_VIOLATION -  The order in which a slave receives the first data item of each transaction must be the same as the order in which it receives the addresses for the transaction (SPEC3(A5.3.3))                                                      
//    AXI_AWLEN_MISMATCHED_WITH_COMPLETED_WRITE_DATA_BURST -  AWLEN value of write address control does not match with corresponding outstanding write data burts length (SPEC3(A3.4.1))                                                       
//    AXI_WRITE_LENGTH_MISMATCHED_ACTUAL_LENGTH_OF_WRITE_DATA_BURST_EXCEEDS_AWLEN -  The actual length of write data burst exceeds with the length specified by AWLEN (SPEC3(A3.4.1))                                              
//    AXI_AWLEN_MISMATCHED_ACTUAL_LENGTH_OF_WRITE_DATA_BURST_EXCEEDS_AWLEN -  Actual length of data burst has exceeded the burst length specified by AWLEN (SPEC3(A3.4.1))                                                               
//    AXI_WLAST_ASSERTED_DURING_DATA_PHASE_OTHER_THAN_LAST -  AWLEN value of write address control does not match with corresponding outstanding write data burts length (SPEC3(A3.4.1))                                                 
//    AXI_WRITE_INTERLEAVE_DEPTH_VIOLATION -  Write data bursts should not be interleaved beyond the write interleaving depth (SPEC3(A5.3.3))                                   
//    AXI_WRITE_RESPONSE_WITHOUT_ADDR -  Write response should not be sent before the corresponding address has completed (SPEC3(A3.3.1))                                 
//    AXI_WRITE_RESPONSE_WITHOUT_DATA -  Write response should not be sent before the corresponding write data burst completed (SPEC3(A3.3.1))                           
//    AXI_AWVALID_HIGH_DURING_RESET -  AWVALID asserted during the reset state (SPEC3(A3.1.2))                                                                                                                     
//    AXI_WVALID_HIGH_DURING_RESET -  WVALID asserted during the reset state (SPEC3(A3.1.2))                                                                                                                       
//    AXI_BVALID_HIGH_DURING_RESET -  BVALID asserted during the reset state (SPEC3(A3.1.2))                                                                                                                        
//    AXI_ARVALID_HIGH_DURING_RESET -  ARVALID asserted during the reset state (SPEC3(A3.1.2))                                                                                                                          
//    AXI_RVALID_HIGH_DURING_RESET -  RVALID asserted during the reset state (SPEC3(A3.1.2))                                                                                                                         
//    AXI_RLAST_VIOLATION -  RLAST signal should be asserted along with the final transfer of the read data burst (SPEC3(A3.4.1))                                                                                    
//    AXI_EX_WRITE_AFTER_EX_READ_FAILURE -  It is recommended that an exclusive write access should not be performed after the corresponding exclusive read failure. (SPEC3(A7.2.2))                                
//    AXI_TIMEOUT_WAITING_FOR_WRITE_DATA -  Timed-out waiting for a data phase in write data burst. SPEC3(A2.3)                                                           
//    AXI_TIMEOUT_WAITING_FOR_WRITE_RESPONSE -  Timed-out waiting for a write response. SPEC3(A2.4)                                                                      
//    AXI_TIMEOUT_WAITING_FOR_READ_RESPONSE -  Timed-out waiting for a read response. SPEC3(A2.6)                                                                            
//    AXI_TIMEOUT_WAITING_FOR_WRITE_ADDR_AFTER_DATA -  Timed-out waiting for a write address phase to be coming after data SPEC3(A2.2)                                       
//    AXI_DEC_ERR_RESP_FOR_READ -  No slave at the address for this read transfer (signaled by <AXI_DECERR>)                                                                     
//    AXI_DEC_ERR_RESP_FOR_WRITE -  No slave at the address for this write transfer (signaled by <AXI_DECERR>)                                                                     
//    AXI_SLV_ERR_RESP_FOR_READ -  Slave has detected an error for this read transfer (signaled by <AXI_SLVERR>)                                                                  
//    AXI_SLV_ERR_RESP_FOR_WRITE -  Slave has detected an error for this write transfer (signaled by <AXI_SLVERR>)                                                                   
//    AXI_MINIMUM_SLAVE_ADDRESS_SPACE_VIOLATION -  The minimum address space occupied by a single slave device is 4 kilobytes (SPEC3(A10.3.2))                                       
//    AXI_ADDRESS_WIDTH_EXCEEDS_64 -  AXI supports up to 64-bit addressing (SPEC3(A10.3.1))                                                                                                                  
//    AXI_READ_BURST_MAXIMUM_LENGTH_VIOLATION -  16 read data beats were seen without RLAST (SPEC3(A3.4.1))                                                                                                   
//    AXI_WRITE_BURST_MAXIMUM_LENGTH_VIOLATION -  16 write data beats were seen without WLAST (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1 )                                     
//    AXI_WRITE_STROBES_LENGTH_VIOLATION -  The size of the write_strobes array in a write transfer should match the value given by AWLEN                                                                                               
//    AXI_EX_RD_WHEN_EX_NOT_ENABLED -  An exclusive read should not be issued when exclusive transactions are not enabled                                                                                                                   
//    AXI_EX_WR_WHEN_EX_NOT_ENABLED -  An exclusive write should not be issued when exclusive transactions are not enabled                                                                                                     
//    AXI_WRITE_TRANSFER_EXCEEDS_ADDRESS_SPACE -  This write transfer runs off the edge of the address space defined by AXI_ADDRESS_WIDTH (SPEC3(A10.3.1))                                                                           
//    AXI_READ_TRANSFER_EXCEEDS_ADDRESS_SPACE -  This read transfer runs off the edge of the address space defined by AXI_ADDRESS_WIDTH (SPEC3(A10.3.1))                                                                                 
//    AXI_EXCL_RD_WHILE_EXCL_WR_IN_PROGRESS_SAME_ID -  Master starts an exclusive read burst while exclusive write burst with same ID tag is in progress (SPEC3(A7.2.4))                                                                 
//    AXI_EXCL_WR_WHILE_EXCL_RD_IN_PROGRESS_SAME_ID -  Master starts an exclusive write burst while exclusive read burst with same ID tag is in progress (SPEC3(A7.2.4))                                                                
//    AXI_ILLEGAL_LENGTH_READ_BURST -  Read address phase burst_length has an illegal value (SPEC3(A3.4.1))                                                                                                                      
//    AXI_ILLEGAL_LENGTH_WRITE_BURST -  Write address phase burst_length has an illegal value (SPEC3(A3.4.1))                                                                                                                        
//    AXI_ARREADY_NOT_ASSERTED_AFTER_ARVALID -  Once ARVALID has been asserted, ARREADY> should be asserted within config_max_latency_ARVALID_assertion_to_ARREADY clock periods                                                     
//    AXI_BREADY_NOT_ASSERTED_AFTER_BVALID -  Once BVALID has been asserted, BREADY> should be asserted within config_max_latency_BVALID_assertion_to_BREADY clock periods                                                             
//    AXI_AWREADY_NOT_ASSERTED_AFTER_AWVALID -  Once AWVALID has been asserted, AWREADY> should be asserted within config_max_latency_AWVALID_assertion_to_AWREADY clock periods                                                              
//    AXI_RREADY_NOT_ASSERTED_AFTER_RVALID -  Once RVALID has been asserted, RREADY> should be asserted within config_max_latency_RVALID_assertion_to_RREADY clock periods                                                                
//    AXI_WREADY_NOT_ASSERTED_AFTER_WVALID -  Once WVALID has been asserted, WREADY> should be asserted within config_max_latency_WVALID_assertion_to_WREADY clock periods                                                           
//    AXI_DEC_ERR_ILLEGAL_FOR_MAPPED_SLAVE_ADDR -  Slave receives a burst to a mapped address but responds with DECERR (signalled by AXI_DECERR) (SPEC3(A3.4.4))                                                                           
//    AXI_PARAM_READ_REORDERING_DEPTH_EQUALS_ZERO -  The user-supplied config_read_data_reordering_depth should be greater than zero (SPEC3(A5.3.1))                                                                                        
//    AXI_PARAM_READ_REORDERING_DEPTH_EXCEEDS_MAX_ID -  The user-supplied config_read_data_reordering_depth exceeds the maximum possible value, as defined by the AXI_ID_WIDTH parameter (SPEC3(A5.3.1))                              
//    AXI_READ_REORDERING_VIOLATION -  The arrival of a read response has exceeded the read reordering depth (SPEC3(A5.3.1))                             
typedef enum bit [7:0]
{
    AXI_ARESETn_SIGNAL_Z                                                        = 8'h00,
    AXI_ARESETn_SIGNAL_X                                                        = 8'h01,
    AXI_ACLK_SIGNAL_Z                                                           = 8'h02,
    AXI_ACLK_SIGNAL_X                                                           = 8'h03,
    AXI_ADDR_FOR_READ_BURST_ACROSS_4K_BOUNDARY                                  = 8'h04,
    AXI_ADDR_FOR_WRITE_BURST_ACROSS_4K_BOUNDARY                                 = 8'h05,
    AXI_ARADDR_CHANGED_BEFORE_ARREADY                                           = 8'h06,
    AXI_ARADDR_UNKN                                                             = 8'h07,
    AXI_ARBURST_CHANGED_BEFORE_ARREADY                                          = 8'h08,
    AXI_ARBURST_UNKN                                                            = 8'h09,
    AXI_ARCACHE_CHANGED_BEFORE_ARREADY                                          = 8'h0a,
    AXI_ARCACHE_UNKN                                                            = 8'h0b,
    AXI_ARID_CHANGED_BEFORE_ARREADY                                             = 8'h0c,
    AXI_ARID_UNKN                                                               = 8'h0d,
    AXI_ARLEN_CHANGED_BEFORE_ARREADY                                            = 8'h0e,
    AXI_ARLEN_UNKN                                                              = 8'h0f,
    AXI_ARLOCK_CHANGED_BEFORE_ARREADY                                           = 8'h10,
    AXI_ARLOCK_UNKN                                                             = 8'h11,
    AXI_ARPROT_CHANGED_BEFORE_ARREADY                                           = 8'h12,
    AXI_ARPROT_UNKN                                                             = 8'h13,
    AXI_ARREADY_UNKN                                                            = 8'h14,
    AXI_ARSIZE_CHANGED_BEFORE_ARREADY                                           = 8'h15,
    AXI_ARSIZE_UNKN                                                             = 8'h16,
    AXI_ARUSER_CHANGED_BEFORE_ARREADY                                           = 8'h17,
    AXI_ARUSER_UNKN                                                             = 8'h18,
    AXI_ARVALID_DEASSERTED_BEFORE_ARREADY                                       = 8'h19,
    AXI_ARVALID_HIGH_ON_FIRST_CLOCK_AFTER_RESET                                 = 8'h1a,
    AXI_ARVALID_UNKN                                                            = 8'h1b,
    AXI_AWADDR_CHANGED_BEFORE_AWREADY                                           = 8'h1c,
    AXI_AWADDR_UNKN                                                             = 8'h1d,
    AXI_AWBURST_CHANGED_BEFORE_AWREADY                                          = 8'h1e,
    AXI_AWBURST_UNKN                                                            = 8'h1f,
    AXI_AWCACHE_CHANGED_BEFORE_AWREADY                                          = 8'h20,
    AXI_AWCACHE_UNKN                                                            = 8'h21,
    AXI_AWID_CHANGED_BEFORE_AWREADY                                             = 8'h22,
    AXI_AWID_UNKN                                                               = 8'h23,
    AXI_AWLEN_CHANGED_BEFORE_AWREADY                                            = 8'h24,
    AXI_AWLEN_UNKN                                                              = 8'h25,
    AXI_AWLOCK_CHANGED_BEFORE_AWREADY                                           = 8'h26,
    AXI_AWLOCK_UNKN                                                             = 8'h27,
    AXI_AWPROT_CHANGED_BEFORE_AWREADY                                           = 8'h28,
    AXI_AWPROT_UNKN                                                             = 8'h29,
    AXI_AWREADY_UNKN                                                            = 8'h2a,
    AXI_AWSIZE_CHANGED_BEFORE_AWREADY                                           = 8'h2b,
    AXI_AWSIZE_UNKN                                                             = 8'h2c,
    AXI_AWUSER_CHANGED_BEFORE_AWREADY                                           = 8'h2d,
    AXI_AWUSER_UNKN                                                             = 8'h2e,
    AXI_AWVALID_DEASSERTED_BEFORE_AWREADY                                       = 8'h2f,
    AXI_AWVALID_HIGH_ON_FIRST_CLOCK_AFTER_RESET                                 = 8'h30,
    AXI_AWVALID_UNKN                                                            = 8'h31,
    AXI_BID_CHANGED_BEFORE_BREADY                                               = 8'h32,
    AXI_BID_UNKN                                                                = 8'h33,
    AXI_BREADY_UNKN                                                             = 8'h34,
    AXI_BRESP_CHANGED_BEFORE_BREADY                                             = 8'h35,
    AXI_BRESP_UNKN                                                              = 8'h36,
    AXI_BUSER_CHANGED_BEFORE_BREADY                                             = 8'h37,
    AXI_BUSER_UNKN                                                              = 8'h38,
    AXI_BVALID_DEASSERTED_BEFORE_BREADY                                         = 8'h39,
    AXI_BVALID_HIGH_ON_FIRST_CLOCK_AFTER_RESET                                  = 8'h3a,
    AXI_BVALID_UNKN                                                             = 8'h3b,
    AXI_EXCLUSIVE_READ_ACCESS_MODIFIABLE                                        = 8'h3c,
    AXI_EXCLUSIVE_READ_BYTES_TRANSFER_EXCEEDS_128                               = 8'h3d,
    AXI_EXCLUSIVE_WRITE_BYTES_TRANSFER_EXCEEDS_128                              = 8'h3e,
    AXI_EXCLUSIVE_READ_BYTES_TRANSFER_NOT_POWER_OF_2                            = 8'h3f,
    AXI_EXCLUSIVE_WRITE_BYTES_TRANSFER_NOT_POWER_OF_2                           = 8'h40,
    AXI_EXCLUSIVE_WR_ADDRESS_NOT_SAME_AS_RD                                     = 8'h41,
    AXI_EXCLUSIVE_WR_BURST_NOT_SAME_AS_RD                                       = 8'h42,
    AXI_EXCLUSIVE_WR_CACHE_NOT_SAME_AS_RD                                       = 8'h43,
    AXI_EXCLUSIVE_WRITE_ACCESS_MODIFIABLE                                       = 8'h44,
    AXI_EXCLUSIVE_WR_LENGTH_NOT_SAME_AS_RD                                      = 8'h45,
    AXI_EXCLUSIVE_WR_PROT_NOT_SAME_AS_RD                                        = 8'h46,
    AXI_EXCLUSIVE_WR_SIZE_NOT_SAME_AS_RD                                        = 8'h47,
    AXI_EXOKAY_RESPONSE_NORMAL_READ                                             = 8'h48,
    AXI_EXOKAY_RESPONSE_NORMAL_WRITE                                            = 8'h49,
    AXI_EX_RD_RESP_MISMATCHED_WITH_EXPECTED_RESP                                = 8'h4a,
    AXI_EX_WR_RESP_MISMATCHED_WITH_EXPECTED_RESP                                = 8'h4b,
    AXI_EX_RD_EXOKAY_RESP_SLAVE_WITHOUT_EXCLUSIVE_ACCESS                        = 8'h4c,
    AXI_EX_WRITE_BEFORE_EX_READ_RESPONSE                                        = 8'h4d,
    AXI_EX_WRITE_EXOKAY_RESP_SLAVE_WITHOUT_EXCLUSIVE_ACCESS                     = 8'h4e,
    AXI_ILLEGAL_LENGTH_WRAPPING_READ_BURST                                      = 8'h4f,
    AXI_ILLEGAL_LENGTH_WRAPPING_WRITE_BURST                                     = 8'h50,
    AXI_ILLEGAL_RESPONSE_EXCLUSIVE_READ                                         = 8'h51,
    AXI_ILLEGAL_RESPONSE_EXCLUSIVE_WRITE                                        = 8'h52,
    AXI_PARAM_READ_DATA_BUS_WIDTH                                               = 8'h53,
    AXI_PARAM_WRITE_DATA_BUS_WIDTH                                              = 8'h54,
    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_12                                    = 8'h55,
    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_13                                    = 8'h56,
    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_4                                     = 8'h57,
    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_5                                     = 8'h58,
    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_8                                     = 8'h59,
    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_9                                     = 8'h5a,
    AXI_READ_BURST_LENGTH_VIOLATION                                             = 8'h5b,
    AXI_READ_BURST_SIZE_VIOLATION                                               = 8'h5c,
    AXI_READ_DATA_BEFORE_ADDRESS                                                = 8'h5d,
    AXI_READ_DATA_CHANGED_BEFORE_RREADY                                         = 8'h5e,
    AXI_READ_DATA_UNKN                                                          = 8'h5f,
    AXI_RESERVED_ARLOCK_ENCODING                                                = 8'h60,
    AXI_READ_RESP_CHANGED_BEFORE_RREADY                                         = 8'h61,
    AXI_RESERVED_ARBURST_ENCODING                                               = 8'h62,
    AXI_RESERVED_AWBURST_ENCODING                                               = 8'h63,
    AXI_RID_CHANGED_BEFORE_RREADY                                               = 8'h64,
    AXI_RID_UNKN                                                                = 8'h65,
    AXI_RLAST_CHANGED_BEFORE_RREADY                                             = 8'h66,
    AXI_RLAST_UNKN                                                              = 8'h67,
    AXI_RREADY_UNKN                                                             = 8'h68,
    AXI_RRESP_UNKN                                                              = 8'h69,
    AXI_RUSER_CHANGED_BEFORE_RREADY                                             = 8'h6a,
    AXI_RUSER_UNKN                                                              = 8'h6b,
    AXI_RVALID_DEASSERTED_BEFORE_RREADY                                         = 8'h6c,
    AXI_RVALID_HIGH_ON_FIRST_CLOCK_AFTER_RESET                                  = 8'h6d,
    AXI_RVALID_UNKN                                                             = 8'h6e,
    AXI_UNALIGNED_ADDRESS_FOR_EXCLUSIVE_READ                                    = 8'h6f,
    AXI_UNALIGNED_ADDRESS_FOR_EXCLUSIVE_WRITE                                   = 8'h70,
    AXI_UNALIGNED_ADDR_FOR_WRAPPING_READ_BURST                                  = 8'h71,
    AXI_UNALIGNED_ADDR_FOR_WRAPPING_WRITE_BURST                                 = 8'h72,
    AXI_WDATA_CHANGED_BEFORE_WREADY_ON_INVALID_LANE                             = 8'h73,
    AXI_WDATA_CHANGED_BEFORE_WREADY_ON_VALID_LANE                               = 8'h74,
    AXI_WLAST_CHANGED_BEFORE_WREADY                                             = 8'h75,
    AXI_WID_CHANGED_BEFORE_WREADY                                               = 8'h76,
    AXI_WLAST_UNKN                                                              = 8'h77,
    AXI_WID_UNKN                                                                = 8'h78,
    AXI_WREADY_UNKN                                                             = 8'h79,
    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_12                                   = 8'h7a,
    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_13                                   = 8'h7b,
    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_4                                    = 8'h7c,
    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_5                                    = 8'h7d,
    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_8                                    = 8'h7e,
    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_9                                    = 8'h7f,
    AXI_WRITE_BURST_SIZE_VIOLATION                                              = 8'h80,
    AXI_WRITE_DATA_BEFORE_ADDRESS                                               = 8'h81,
    AXI_WRITE_DATA_UNKN_ON_INVALID_LANE                                         = 8'h82,
    AXI_WRITE_DATA_UNKN_ON_VALID_LANE                                           = 8'h83,
    AXI_RESERVED_AWLOCK_ENCODING                                                = 8'h84,
    AXI_WRITE_STROBE_ON_INVALID_BYTE_LANES                                      = 8'h85,
    AXI_WSTRB_CHANGED_BEFORE_WREADY                                             = 8'h86,
    AXI_WSTRB_UNKN                                                              = 8'h87,
    AXI_WUSER_CHANGED_BEFORE_WREADY                                             = 8'h88,
    AXI_WUSER_UNKN                                                              = 8'h89,
    AXI_WVALID_DEASSERTED_BEFORE_WREADY                                         = 8'h8a,
    AXI_WVALID_HIGH_ON_FIRST_CLOCK_AFTER_RESET                                  = 8'h8b,
    AXI_WVALID_UNKN                                                             = 8'h8c,
    AXI_ADDR_ACROSS_4K_WITHIN_LOCKED_WRITE_TRANSACTION                          = 8'h8d,
    AXI_ADDR_ACROSS_4K_WITHIN_LOCKED_READ_TRANSACTION                           = 8'h8e,
    AXI_AWID_CHANGED_WITHIN_LOCKED_TRANSACTION                                  = 8'h8f,
    AXI_ARID_CHANGED_WITHIN_LOCKED_TRANSACTION                                  = 8'h90,
    AXI_AWPROT_CHANGED_WITHIN_LOCKED_TRANSACTION                                = 8'h91,
    AXI_ARPROT_CHANGED_WITHIN_LOCKED_TRANSACTION                                = 8'h92,
    AXI_AWCACHE_CHANGED_WITHIN_LOCKED_TRANSACTION                               = 8'h93,
    AXI_ARCACHE_CHANGED_WITHIN_LOCKED_TRANSACTION                               = 8'h94,
    AXI_NUMBER_OF_LOCKED_SEQUENCES_EXCEEDS_2                                    = 8'h95,
    AXI_LOCKED_WRITE_BEFORE_COMPLETION_OF_PREVIOUS_WRITE_TRANSACTIONS           = 8'h96,
    AXI_LOCKED_WRITE_BEFORE_COMPLETION_OF_PREVIOUS_READ_TRANSACTIONS            = 8'h97,
    AXI_LOCKED_READ_BEFORE_COMPLETION_OF_PREVIOUS_WRITE_TRANSACTIONS            = 8'h98,
    AXI_LOCKED_READ_BEFORE_COMPLETION_OF_PREVIOUS_READ_TRANSACTIONS             = 8'h99,
    AXI_NEW_BURST_BEFORE_COMPLETION_OF_UNLOCK_TRANSACTION                       = 8'h9a,
    AXI_UNLOCKED_WRITE_WHILE_OUTSTANDING_LOCKED_WRITES                          = 8'h9b,
    AXI_UNLOCKED_WRITE_WHILE_OUTSTANDING_LOCKED_READS                           = 8'h9c,
    AXI_UNLOCKED_READ_WHILE_OUTSTANDING_LOCKED_WRITES                           = 8'h9d,
    AXI_UNLOCKED_READ_WHILE_OUTSTANDING_LOCKED_READS                            = 8'h9e,
    AXI_UNLOCKING_TRANSACTION_WITH_AN_EXCLUSIVE_ACCESS                          = 8'h9f,
    AXI_FIRST_DATA_ITEM_OF_TRANSACTION_WRITE_ORDER_VIOLATION                    = 8'ha0,
    AXI_AWLEN_MISMATCHED_WITH_COMPLETED_WRITE_DATA_BURST                        = 8'ha1,
    AXI_WRITE_LENGTH_MISMATCHED_ACTUAL_LENGTH_OF_WRITE_DATA_BURST_EXCEEDS_AWLEN = 8'ha2,
    AXI_AWLEN_MISMATCHED_ACTUAL_LENGTH_OF_WRITE_DATA_BURST_EXCEEDS_AWLEN        = 8'ha3,
    AXI_WLAST_ASSERTED_DURING_DATA_PHASE_OTHER_THAN_LAST                        = 8'ha4,
    AXI_WRITE_INTERLEAVE_DEPTH_VIOLATION                                        = 8'ha5,
    AXI_WRITE_RESPONSE_WITHOUT_ADDR                                             = 8'ha6,
    AXI_WRITE_RESPONSE_WITHOUT_DATA                                             = 8'ha7,
    AXI_AWVALID_HIGH_DURING_RESET                                               = 8'ha8,
    AXI_WVALID_HIGH_DURING_RESET                                                = 8'ha9,
    AXI_BVALID_HIGH_DURING_RESET                                                = 8'haa,
    AXI_ARVALID_HIGH_DURING_RESET                                               = 8'hab,
    AXI_RVALID_HIGH_DURING_RESET                                                = 8'hac,
    AXI_RLAST_VIOLATION                                                         = 8'had,
    AXI_EX_WRITE_AFTER_EX_READ_FAILURE                                          = 8'hae,
    AXI_TIMEOUT_WAITING_FOR_WRITE_DATA                                          = 8'haf,
    AXI_TIMEOUT_WAITING_FOR_WRITE_RESPONSE                                      = 8'hb0,
    AXI_TIMEOUT_WAITING_FOR_READ_RESPONSE                                       = 8'hb1,
    AXI_TIMEOUT_WAITING_FOR_WRITE_ADDR_AFTER_DATA                               = 8'hb2,
    AXI_DEC_ERR_RESP_FOR_READ                                                   = 8'hb3,
    AXI_DEC_ERR_RESP_FOR_WRITE                                                  = 8'hb4,
    AXI_SLV_ERR_RESP_FOR_READ                                                   = 8'hb5,
    AXI_SLV_ERR_RESP_FOR_WRITE                                                  = 8'hb6,
    AXI_MINIMUM_SLAVE_ADDRESS_SPACE_VIOLATION                                   = 8'hb7,
    AXI_ADDRESS_WIDTH_EXCEEDS_64                                                = 8'hb8,
    AXI_READ_BURST_MAXIMUM_LENGTH_VIOLATION                                     = 8'hb9,
    AXI_WRITE_BURST_MAXIMUM_LENGTH_VIOLATION                                    = 8'hba,
    AXI_WRITE_STROBES_LENGTH_VIOLATION                                          = 8'hbb,
    AXI_EX_RD_WHEN_EX_NOT_ENABLED                                               = 8'hbc,
    AXI_EX_WR_WHEN_EX_NOT_ENABLED                                               = 8'hbd,
    AXI_WRITE_TRANSFER_EXCEEDS_ADDRESS_SPACE                                    = 8'hbe,
    AXI_READ_TRANSFER_EXCEEDS_ADDRESS_SPACE                                     = 8'hbf,
    AXI_EXCL_RD_WHILE_EXCL_WR_IN_PROGRESS_SAME_ID                               = 8'hc0,
    AXI_EXCL_WR_WHILE_EXCL_RD_IN_PROGRESS_SAME_ID                               = 8'hc1,
    AXI_ILLEGAL_LENGTH_READ_BURST                                               = 8'hc2,
    AXI_ILLEGAL_LENGTH_WRITE_BURST                                              = 8'hc3,
    AXI_ARREADY_NOT_ASSERTED_AFTER_ARVALID                                      = 8'hc4,
    AXI_BREADY_NOT_ASSERTED_AFTER_BVALID                                        = 8'hc5,
    AXI_AWREADY_NOT_ASSERTED_AFTER_AWVALID                                      = 8'hc6,
    AXI_RREADY_NOT_ASSERTED_AFTER_RVALID                                        = 8'hc7,
    AXI_WREADY_NOT_ASSERTED_AFTER_WVALID                                        = 8'hc8,
    AXI_DEC_ERR_ILLEGAL_FOR_MAPPED_SLAVE_ADDR                                   = 8'hc9,
    AXI_PARAM_READ_REORDERING_DEPTH_EQUALS_ZERO                                 = 8'hca,
    AXI_PARAM_READ_REORDERING_DEPTH_EXCEEDS_MAX_ID                              = 8'hcb,
    AXI_READ_REORDERING_VIOLATION                                               = 8'hcc
} axi_assertion_type_e;


typedef bit [1023:0] axi_max_bits_t;

// enum: axi_config_e
//
// An enum which fields corresponding to each configuration parameter of the VIP
//    AXI_CONFIG_SETUP_TIME - 
//         
//             Number of time units for the setup time to the active clock edge of ACLK.
//           
//    AXI_CONFIG_HOLD_TIME - 
//         
//             Number of time units for the hold time to the active clock edge of ACLK.
//           
//    AXI_CONFIG_MAX_TRANSACTION_TIME_FACTOR - 
//          This timeout "config_max_transaction_time_factor" is the timeout that sets the maximum timeout within which any read/write transaction is 
//                expected to occur (and in turn all individual phases as well) of the AXI interface. 
//                This timeout should be set as the maximum duration of read/write. 
//                In short it indicates the maximum duration of a read/write transaction (From start of transaction to end of it).
//                Its default value is 100000 clock cycles
//             
//    AXI_CONFIG_TIMEOUT_MAX_DATA_TRANSFER - 
//          This timeout "config_timeout_max_data_transfer" is actually a configuration which tells about the maximum number of write data beats that the AXI interface
//               can generate as part of write data burst of write transfer. 
//               It is actually not a timeout value and is the maximum number of beats of Write data that are expected. 
//    AXI_CONFIG_BURST_TIMEOUT_FACTOR - 
//         This timeout "config_burst_timeout_factor" represents the maximum delay between the individual phases of the AXI transactions.
//              For example between read address phase and read data phase, write address and Write data phases. 
//              If this delay exceeds between the phases then transaction will be  timed out.
//              Its default value is 10000 clock cycles
//             
//    AXI_CONFIG_MAX_LATENCY_AWVALID_ASSERTION_TO_AWREADY - 
//          A configuration parameter defining the timeout (in clock periods) from the assertion of <AWVALID> to the assertion of <AWREADY> (default 10000).
//         
//         The error message <AXI_AWREADY_NOT_ASSERTED_AFTER_AWVALID> will be issued if this period elapses from the assertion of <AWVALID>.
//         
//    AXI_CONFIG_MAX_LATENCY_ARVALID_ASSERTION_TO_ARREADY - 
//          A configuration parameter defining the timeout (in clock periods) from the assertion of <ARVALID> to the assertion of <ARREADY> (default 10000).
//         
//         The error message <AXI_ARREADY_NOT_ASSERTED_AFTER_ARVALID> will be issued if this period elapses from the assertion of <ARVALID>.
//         
//    AXI_CONFIG_MAX_LATENCY_RVALID_ASSERTION_TO_RREADY - 
//          A configuration parameter defining the timeout (in clock periods) from the assertion of <RVALID> to the assertion of <RREADY> (default 10000).
//         
//         The error message <AXI_RREADY_NOT_ASSERTED_AFTER_RVALID> will be issued if this period elapses from the assertion of <RVALID>.
//         
//    AXI_CONFIG_MAX_LATENCY_BVALID_ASSERTION_TO_BREADY - 
//          A configuration parameter defining the timeout (in clock periods) from the assertion of <BVALID> to the assertion of <BREADY> (default 10000).
//         
//         The error message <AXI_BREADY_NOT_ASSERTED_AFTER_BVALID> will be issued if this period elapses from the assertion of <BVALID>.
//         
//    AXI_CONFIG_MAX_LATENCY_WVALID_ASSERTION_TO_WREADY - 
//          A configuration parameter defining the timeout (in clock periods) from the assertion of <WVALID> to the assertion of <WREADY> (default 10000).
//         
//         The error message <AXI_WREADY_NOT_ASSERTED_AFTER_WVALID> will be issued if this period elapses from the assertion of <WVALID>.
//         
//    AXI_CONFIG_WRITE_CTRL_TO_DATA_MINTIME -  Number of clocks from the start of control to the start of data in a write. This configuration parameter has been deprecated and maintained for backward compatibility. Instead use write_address_to_data_delay variable to control delay between write address phase and write data phase.
//    AXI_CONFIG_MASTER_WRITE_DELAY -  To configure the write sequence item delays to be inserted.
//    AXI_CONFIG_ENABLE_ALL_ASSERTIONS - 
//         
//           Configuration parameter controlling whether the error messages(Assertions) issued from the QVIP are Enabled or Disabled.  
//           By default, it is enabled.
//         
//    AXI_CONFIG_ENABLE_ASSERTION - 
//         
//           An array of configuration parameters controlling whether specific error messages(Assertion) (of type <axi_assertion_type_e>)
//           can be issued by the QVIP. By default, all errors are enabled. To suppress a particular error, set the corresponding bit to 0.
//           e.g. config.m_bfm.set_config_enable_error_index1(AXI_RESET_SIGNAL_Z, 0);
//         
//    AXI_CONFIG_SLAVE_START_ADDR - 
//         
//            A configuration parameter indicating start address for slave.
//           
//    AXI_CONFIG_SLAVE_END_ADDR - 
//         
//            A configuration parameter indicating end address for slave.
//           
//    AXI_CONFIG_READ_DATA_REORDERING_DEPTH - 
//         
//            A configuration parameter defining the read reordering depth of the slave end of the interface (SPEC3(A5.3.1)).
//         
//            Responses from the first <config_read_data_reordering_depth> outstanding read transactions, each with address <ARID> values different from any
//            earlier outstanding read transaction(as seen by the slave) are expected, interleaved at random. A violation causes a <AXI_READ_REORDERING_VIOLATION> error.
//         
//            The default value of <config_read_data_reordering_depth> is (1 << AXI_ID_WIDTH), so that the slave is expected to process all transactions in any order (up to uniqueness of <ARID>).
//         
//            For a given <AXI_ID_WIDTH> parameter value, the maximum possible value of <config_read_data_reordering_depth> is 2**AXI_ID_WIDTH. The <AXI_PARAM_READ_REORDERING_DEPTH_EXCEEDS_MAX_ID>
//            error report will be issued if <config_read_data_reordering_depth> exceeds this value.
//         
//            If the user-supplied value is 0, the <AXI4_PARAM_READ_REORDERING_DEPTH_EQUALS_ZERO> error will be issued, and the value will be set to 1.
//           
//    AXI_CONFIG_MASTER_ERROR_POSITION - 
//         
//             To confgure the type of Master Error.
//           
//    AXI_CONFIG_SUPPORT_EXCLUSIVE_ACCESS - 
//         
//             This configures the support for exclusive slave.
//             If set, it enables the exclusive support in slave.
//             If cleared, it disables the exclusive support and every exclusive read/write will return OKAY response and 
//             exclusive write will update the memory.  
//           

typedef enum bit [7:0]
{
    AXI_CONFIG_SETUP_TIME                    = 8'd0,
    AXI_CONFIG_HOLD_TIME                     = 8'd1,
    AXI_CONFIG_MAX_TRANSACTION_TIME_FACTOR   = 8'd2,
    AXI_CONFIG_TIMEOUT_MAX_DATA_TRANSFER     = 8'd3,
    AXI_CONFIG_BURST_TIMEOUT_FACTOR          = 8'd4,
    AXI_CONFIG_MAX_LATENCY_AWVALID_ASSERTION_TO_AWREADY = 8'd5,
    AXI_CONFIG_MAX_LATENCY_ARVALID_ASSERTION_TO_ARREADY = 8'd6,
    AXI_CONFIG_MAX_LATENCY_RVALID_ASSERTION_TO_RREADY = 8'd7,
    AXI_CONFIG_MAX_LATENCY_BVALID_ASSERTION_TO_BREADY = 8'd8,
    AXI_CONFIG_MAX_LATENCY_WVALID_ASSERTION_TO_WREADY = 8'd9,
    AXI_CONFIG_WRITE_CTRL_TO_DATA_MINTIME    = 8'd10,
    AXI_CONFIG_MASTER_WRITE_DELAY            = 8'd11,
    AXI_CONFIG_ENABLE_ALL_ASSERTIONS         = 8'd12,
    AXI_CONFIG_ENABLE_ASSERTION              = 8'd13,
    AXI_CONFIG_SLAVE_START_ADDR              = 8'd14,
    AXI_CONFIG_SLAVE_END_ADDR                = 8'd15,
    AXI_CONFIG_READ_DATA_REORDERING_DEPTH    = 8'd16,
    AXI_CONFIG_MASTER_ERROR_POSITION         = 8'd17,
    AXI_CONFIG_SUPPORT_EXCLUSIVE_ACCESS      = 8'd18,
    AXI_CONFIG_MAX_OUTSTANDING_WR            = 8'd19,
    AXI_CONFIG_MAX_OUTSTANDING_RD            = 8'd20
} axi_config_e;

// enum: axi_vhd_if_e
//
// For VHDL use only
typedef enum int
{
    AXI_VHD_SET_CONFIG                         = 32'd0,
    AXI_VHD_GET_CONFIG                         = 32'd1,
    AXI_VHD_CREATE_WRITE_TRANSACTION           = 32'd2,
    AXI_VHD_CREATE_READ_TRANSACTION            = 32'd3,
    AXI_VHD_SET_ADDR                           = 32'd4,
    AXI_VHD_GET_ADDR                           = 32'd5,
    AXI_VHD_SET_SIZE                           = 32'd6,
    AXI_VHD_GET_SIZE                           = 32'd7,
    AXI_VHD_SET_BURST                          = 32'd8,
    AXI_VHD_GET_BURST                          = 32'd9,
    AXI_VHD_SET_LOCK                           = 32'd10,
    AXI_VHD_GET_LOCK                           = 32'd11,
    AXI_VHD_SET_CACHE                          = 32'd12,
    AXI_VHD_GET_CACHE                          = 32'd13,
    AXI_VHD_SET_PROT                           = 32'd14,
    AXI_VHD_GET_PROT                           = 32'd15,
    AXI_VHD_SET_ID                             = 32'd16,
    AXI_VHD_GET_ID                             = 32'd17,
    AXI_VHD_SET_BURST_LENGTH                   = 32'd18,
    AXI_VHD_GET_BURST_LENGTH                   = 32'd19,
    AXI_VHD_SET_DATA_WORDS                     = 32'd20,
    AXI_VHD_GET_DATA_WORDS                     = 32'd21,
    AXI_VHD_SET_WRITE_STROBES                  = 32'd22,
    AXI_VHD_GET_WRITE_STROBES                  = 32'd23,
    AXI_VHD_SET_RESP                           = 32'd24,
    AXI_VHD_GET_RESP                           = 32'd25,
    AXI_VHD_SET_ADDR_USER                      = 32'd26,
    AXI_VHD_GET_ADDR_USER                      = 32'd27,
    AXI_VHD_SET_READ_OR_WRITE                  = 32'd28,
    AXI_VHD_GET_READ_OR_WRITE                  = 32'd29,
    AXI_VHD_SET_ADDRESS_VALID_DELAY            = 32'd30,
    AXI_VHD_GET_ADDRESS_VALID_DELAY            = 32'd31,
    AXI_VHD_SET_DATA_VALID_DELAY               = 32'd32,
    AXI_VHD_GET_DATA_VALID_DELAY               = 32'd33,
    AXI_VHD_SET_WRITE_RESPONSE_VALID_DELAY     = 32'd34,
    AXI_VHD_GET_WRITE_RESPONSE_VALID_DELAY     = 32'd35,
    AXI_VHD_SET_ADDRESS_READY_DELAY            = 32'd36,
    AXI_VHD_GET_ADDRESS_READY_DELAY            = 32'd37,
    AXI_VHD_SET_DATA_READY_DELAY               = 32'd38,
    AXI_VHD_GET_DATA_READY_DELAY               = 32'd39,
    AXI_VHD_SET_WRITE_RESPONSE_READY_DELAY     = 32'd40,
    AXI_VHD_GET_WRITE_RESPONSE_READY_DELAY     = 32'd41,
    AXI_VHD_SET_GEN_WRITE_STROBES              = 32'd42,
    AXI_VHD_GET_GEN_WRITE_STROBES              = 32'd43,
    AXI_VHD_SET_OPERATION_MODE                 = 32'd44,
    AXI_VHD_GET_OPERATION_MODE                 = 32'd45,
    AXI_VHD_SET_DELAY_MODE                     = 32'd46,
    AXI_VHD_GET_DELAY_MODE                     = 32'd47,
    AXI_VHD_SET_WRITE_DATA_MODE                = 32'd48,
    AXI_VHD_GET_WRITE_DATA_MODE                = 32'd49,
    AXI_VHD_SET_DATA_BEAT_DONE                 = 32'd50,
    AXI_VHD_GET_DATA_BEAT_DONE                 = 32'd51,
    AXI_VHD_SET_TRANSACTION_DONE               = 32'd52,
    AXI_VHD_GET_TRANSACTION_DONE               = 32'd53,
    AXI_VHD_EXECUTE_TRANSACTION                = 32'd54,
    AXI_VHD_GET_RW_TRANSACTION                 = 32'd55,
    AXI_VHD_EXECUTE_READ_DATA_BURST            = 32'd56,
    AXI_VHD_GET_READ_DATA_BURST                = 32'd57,
    AXI_VHD_EXECUTE_WRITE_DATA_BURST           = 32'd58,
    AXI_VHD_GET_WRITE_DATA_BURST               = 32'd59,
    AXI_VHD_EXECUTE_READ_ADDR_PHASE            = 32'd60,
    AXI_VHD_GET_READ_ADDR_PHASE                = 32'd61,
    AXI_VHD_EXECUTE_READ_DATA_PHASE            = 32'd62,
    AXI_VHD_GET_READ_DATA_PHASE                = 32'd63,
    AXI_VHD_EXECUTE_WRITE_ADDR_PHASE           = 32'd64,
    AXI_VHD_GET_WRITE_ADDR_PHASE               = 32'd65,
    AXI_VHD_EXECUTE_WRITE_DATA_PHASE           = 32'd66,
    AXI_VHD_GET_WRITE_DATA_PHASE               = 32'd67,
    AXI_VHD_EXECUTE_WRITE_RESPONSE_PHASE       = 32'd68,
    AXI_VHD_GET_WRITE_RESPONSE_PHASE           = 32'd69,
    AXI_VHD_CREATE_MONITOR_TRANSACTION         = 32'd70,
    AXI_VHD_CREATE_SLAVE_TRANSACTION           = 32'd71,
    AXI_VHD_PUSH_TRANSACTION_ID                = 32'd72,
    AXI_VHD_POP_TRANSACTION_ID                 = 32'd73,
    AXI_VHD_GET_WRITE_ADDR_DATA                = 32'd74,
    AXI_VHD_GET_READ_ADDR                      = 32'd75,
    AXI_VHD_SET_READ_DATA                      = 32'd76,
    AXI_VHD_PRINT                              = 32'd77,
    AXI_VHD_DESTRUCT_TRANSACTION               = 32'd78,
    AXI_VHD_WAIT_ON                            = 32'd79
} axi_vhd_if_e;


typedef enum bit [7:0]
{
    AXI_CLOCK_POSEDGE = 8'd0,
    AXI_CLOCK_NEGEDGE = 8'd1,
    AXI_CLOCK_ANYEDGE = 8'd2,
    AXI_CLOCK_0_TO_1  = 8'd3,
    AXI_CLOCK_1_TO_0  = 8'd4,
    AXI_RESET_POSEDGE = 8'd5,
    AXI_RESET_NEGEDGE = 8'd6,
    AXI_RESET_ANYEDGE = 8'd7,
    AXI_RESET_0_TO_1  = 8'd8,
    AXI_RESET_1_TO_0  = 8'd9
} axi_wait_e;

`ifndef MAX_AXI_ADDRESS_WIDTH
  `define MAX_AXI_ADDRESS_WIDTH 64
`endif

`ifndef MAX_AXI_RDATA_WIDTH
  `define MAX_AXI_RDATA_WIDTH 1024
`endif

`ifndef MAX_AXI_WDATA_WIDTH
  `define MAX_AXI_WDATA_WIDTH 1024
`endif

`ifndef MAX_AXI_ID_WIDTH
  `define MAX_AXI_ID_WIDTH 18
`endif

// enum: axi_operation_mode_e
//
typedef enum int
{
    AXI_TRANSACTION_NON_BLOCKING = 32'd0,
    AXI_TRANSACTION_BLOCKING     = 32'd1
} axi_operation_mode_e;

// enum: axi_delay_mode_e
//
typedef enum int
{
    AXI_VALID2READY = 32'd0,
    AXI_TRANS2READY = 32'd1
} axi_delay_mode_e;

// enum: axi_write_data_mode_e
//
typedef enum int
{
    AXI_DATA_AFTER_ADDRESS = 32'd0,
    AXI_DATA_WITH_ADDRESS  = 32'd1
} axi_write_data_mode_e;

// Global Transaction Class
class axi_transaction;
    // Protocol 
    bit [((`MAX_AXI_ADDRESS_WIDTH) - 1):0]  addr;
    axi_size_e size;
    axi_burst_e burst;
    axi_lock_e lock;
    axi_cache_e cache;
    axi_prot_e prot;
    bit [((`MAX_AXI_ID_WIDTH) - 1):0]  id;
    bit [3:0] burst_length;
    bit [((((`MAX_AXI_RDATA_WIDTH > `MAX_AXI_WDATA_WIDTH) ? `MAX_AXI_RDATA_WIDTH : `MAX_AXI_WDATA_WIDTH)) - 1):0] data_words [];
    bit [(((`MAX_AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [];
    axi_response_e resp[];
    bit [7:0] addr_user;
    axi_rw_e read_or_write;
    int address_valid_delay;
    int data_valid_delay[];
    int write_response_valid_delay;
    int address_ready_delay;
    int data_ready_delay[];
    int write_response_ready_delay;

    // Housekeeping
    bit gen_write_strobes = 1'b1;
    axi_operation_mode_e  operation_mode  = AXI_TRANSACTION_BLOCKING;
    axi_delay_mode_e      delay_mode      = AXI_VALID2READY;
    axi_write_data_mode_e write_data_mode = AXI_DATA_AFTER_ADDRESS;
    bit data_beat_done[];
    bit transaction_done;

    // This varaible is for printing component name and should not be visible/documented
    string driver_name;

    function void set_addr( input bit [((`MAX_AXI_ADDRESS_WIDTH) - 1):0]  laddr );
      addr = laddr;
    endfunction

    function bit [((`MAX_AXI_ADDRESS_WIDTH) - 1):0]   get_addr();
      return addr;
    endfunction

    function void set_size( input axi_size_e lsize );
      size = lsize;
    endfunction

    function axi_size_e get_size();
      return size;
    endfunction

    function void set_burst( input axi_burst_e lburst );
      burst = lburst;
    endfunction

    function axi_burst_e get_burst();
      return burst;
    endfunction

    function void set_lock( input axi_lock_e llock );
      lock = llock;
    endfunction

    function axi_lock_e get_lock();
      return lock;
    endfunction

    function void set_cache( input axi_cache_e lcache );
      cache = lcache;
    endfunction

    function axi_cache_e get_cache();
      return cache;
    endfunction

    function void set_prot( input axi_prot_e lprot );
      prot = lprot;
    endfunction

    function axi_prot_e get_prot();
      return prot;
    endfunction

    function void set_id( input bit [((`MAX_AXI_ID_WIDTH) - 1):0]  lid );
      id = lid;
    endfunction

    function bit [((`MAX_AXI_ID_WIDTH) - 1):0]   get_id();
      return id;
    endfunction

    function void set_burst_length( input bit [3:0] lburst_length );
      burst_length = lburst_length;
      data_words           = new[(lburst_length + 1)];
      write_strobes        = new[(lburst_length + 1)];
      resp                 = new[(lburst_length + 1)];
      data_valid_delay     = new[(lburst_length + 1)];
      data_ready_delay     = new[(lburst_length + 1)];
      data_beat_done       = new[(lburst_length + 1)];
    endfunction

    function bit [3:0]  get_burst_length();
      return burst_length;
    endfunction

    function void set_data_words( input bit [((((`MAX_AXI_RDATA_WIDTH > `MAX_AXI_WDATA_WIDTH) ? `MAX_AXI_RDATA_WIDTH : `MAX_AXI_WDATA_WIDTH)) - 1):0] ldata_words, input int index = 0 );
      data_words[index] = ldata_words;
    endfunction

    function bit [((((`MAX_AXI_RDATA_WIDTH > `MAX_AXI_WDATA_WIDTH) ? `MAX_AXI_RDATA_WIDTH : `MAX_AXI_WDATA_WIDTH)) - 1):0]  get_data_words( input int index = 0 );
      return data_words[index];
    endfunction

    function void set_write_strobes( input bit [(((`MAX_AXI_WDATA_WIDTH / 8)) - 1):0] lwrite_strobes, input int index = 0 );
      write_strobes[index] = lwrite_strobes;
    endfunction

    function bit [(((`MAX_AXI_WDATA_WIDTH / 8)) - 1):0]  get_write_strobes( input int index = 0 );
      return write_strobes[index];
    endfunction

    function void set_resp( input axi_response_e lresp, input int index = 0 );
      resp[index] = lresp;
    endfunction

    function axi_response_e get_resp( input int index = 0 );
      return resp[index];
    endfunction

    function void set_addr_user( input bit [7:0] laddr_user );
      addr_user = laddr_user;
    endfunction

    function bit [7:0]  get_addr_user();
      return addr_user;
    endfunction

    function void set_read_or_write( input axi_rw_e lread_or_write );
      read_or_write = lread_or_write;
    endfunction

    function axi_rw_e get_read_or_write();
      return read_or_write;
    endfunction

    function void set_address_valid_delay( input int laddress_valid_delay );
      address_valid_delay = laddress_valid_delay;
    endfunction

    function int get_address_valid_delay();
      return address_valid_delay;
    endfunction

    function void set_data_valid_delay( input int ldata_valid_delay, input int index = 0 );
      data_valid_delay[index] = ldata_valid_delay;
    endfunction

    function int get_data_valid_delay( input int index = 0 );
      return data_valid_delay[index];
    endfunction

    function void set_write_response_valid_delay( input int lwrite_response_valid_delay );
      write_response_valid_delay = lwrite_response_valid_delay;
    endfunction

    function int get_write_response_valid_delay();
      return write_response_valid_delay;
    endfunction

    function void set_address_ready_delay( input int laddress_ready_delay );
      address_ready_delay = laddress_ready_delay;
    endfunction

    function int get_address_ready_delay();
      return address_ready_delay;
    endfunction

    function void set_data_ready_delay( input int ldata_ready_delay, input int index = 0 );
      data_ready_delay[index] = ldata_ready_delay;
    endfunction

    function int get_data_ready_delay( input int index = 0 );
      return data_ready_delay[index];
    endfunction

    function void set_write_response_ready_delay( input int lwrite_response_ready_delay );
      write_response_ready_delay = lwrite_response_ready_delay;
    endfunction

    function int get_write_response_ready_delay();
      return write_response_ready_delay;
    endfunction

    function void set_gen_write_strobes( input bit lgen_write_strobes);
      gen_write_strobes = lgen_write_strobes;
    endfunction

    function bit get_gen_write_strobes();
      return gen_write_strobes;
    endfunction

    function void set_operation_mode( input axi_operation_mode_e loperation_mode );
      operation_mode = loperation_mode;
    endfunction

    function axi_operation_mode_e get_operation_mode();
      return operation_mode;
    endfunction

    function void set_delay_mode( input axi_delay_mode_e ldelay_mode );
      delay_mode = ldelay_mode;
    endfunction

    function axi_delay_mode_e get_delay_mode();
      return delay_mode;
    endfunction

    function void set_write_data_mode( input axi_write_data_mode_e lwrite_data_mode );
      write_data_mode = lwrite_data_mode;
    endfunction

    function axi_write_data_mode_e get_write_data_mode();
      return write_data_mode;
    endfunction

    function void set_data_beat_done( input int ldata_beat_done, input int index = 0 );
      data_beat_done[index] = ldata_beat_done;
    endfunction

    function int get_data_beat_done( input int index = 0 );
      return data_beat_done[index];
    endfunction

    function void set_transaction_done( input int ltransaction_done );
      transaction_done = ltransaction_done;
    endfunction

    function int get_transaction_done();
      return transaction_done;
    endfunction

    // Function: do_print
    //
    // Prints axi_transaction transaction attributes
    function void print (bit print_delays = 1'b0);
      $display("------------------------------------------------------------------------");
      $display("%0t: %s axi_transaction", $time, driver_name);
      $display("------------------------------------------------------------------------");
      $display("addr : 'h%h", addr);
      $display("size : %s", size.name());
      $display("burst : %s", burst.name());
      $display("lock : %s", lock.name());
      $display("cache : %s", cache.name());
      $display("prot : %s", prot.name());
      $display("id : 'h%h", id);
      $display("burst_length : 'h%h", burst_length);
      foreach( data_words[i0_1] )
        $display("data_words[%0d] : 'h%h", i0_1, data_words[i0_1]);
      foreach( write_strobes[i0_1] )
        $display("write_strobes[%0d] : 'h%h", i0_1, write_strobes[i0_1]);
      foreach( resp[i0_1] )
        $display("resp[%0d] : %s", i0_1, resp[i0_1].name());
      $display("addr_user : 'h%h", addr_user);
      $display("read_or_write : %s", read_or_write.name());
      $display("gen_write_strobes : 'b%b", gen_write_strobes );
      $display("operation_mode   : %s", operation_mode.name() );
      $display("delay_mode       : %s", delay_mode.name() );
      $display("write_data_mode  : %s", write_data_mode.name() );
      foreach( data_beat_done[i0_1] )
        $display("data_beat_done[%0d] : 'b%b", i0_1, data_beat_done[i0_1] );
      $display("transaction_done : 'b%b", transaction_done );
      if ( print_delays == 1'b1 )
      begin
        $display("address_valid_delay : %0d", address_valid_delay);
        foreach( data_valid_delay[i0_1] )
          $display("data_valid_delay[%0d] : %0d", i0_1, data_valid_delay[i0_1]);
        $display("write_response_valid_delay : %0d", write_response_valid_delay);
        $display("address_ready_delay : %0d", address_ready_delay);
        foreach( data_ready_delay[i0_1] )
          $display("data_ready_delay[%0d] : %0d", i0_1, data_ready_delay[i0_1]);
        $display("write_response_ready_delay : %0d", write_response_ready_delay);
      end
    endfunction
endclass

`else
// *****************************************************************************
//
// Copyright 2007-2013 Mentor Graphics Corporation
// All Rights Reserved.
//
// THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION WHICH IS THE PROPERTY OF
// MENTOR GRAPHICS CORPORATION OR ITS LICENSORS AND IS SUBJECT TO LICENSE TERMS.
//
// *****************************************************************************
// SystemVerilog           Version: 20130911_Questa_10.2c
// *****************************************************************************

// Title: axi_types
//

// enum: axi_size_e
//
//------------------------------------------------------------------------------
//  Word size encoding 
//------------------------------------------------------------------------------
typedef enum bit [2:0]
{
    AXI_BYTES_1   = 3'h0,
    AXI_BYTES_2   = 3'h1,
    AXI_BYTES_4   = 3'h2,
    AXI_BYTES_8   = 3'h3,
    AXI_BYTES_16  = 3'h4,
    AXI_BYTES_32  = 3'h5,
    AXI_BYTES_64  = 3'h6,
    AXI_BYTES_128 = 3'h7
} axi_size_e;


// enum: axi_prot_e
//
//------------------------------------------------------------------------------
//  Protection type 
//------------------------------------------------------------------------------
typedef enum bit [2:0]
{
    AXI_NORM_SEC_DATA    = 3'h0,
    AXI_PRIV_SEC_DATA    = 3'h1,
    AXI_NORM_NONSEC_DATA = 3'h2,
    AXI_PRIV_NONSEC_DATA = 3'h3,
    AXI_NORM_SEC_INST    = 3'h4,
    AXI_PRIV_SEC_INST    = 3'h5,
    AXI_NORM_NONSEC_INST = 3'h6,
    AXI_PRIV_NONSEC_INST = 3'h7
} axi_prot_e;


// enum: axi_cache_e
//
//------------------------------------------------------------------------------
//  Cache type
//------------------------------------------------------------------------------
typedef enum bit [3:0]
{
    AXI_NONCACHE_NONBUF             = 4'h0,
    AXI_BUF_ONLY                    = 4'h1,
    AXI_CACHE_NOALLOC               = 4'h2,
    AXI_CACHE_BUF_NOALLOC           = 4'h3,
    AXI_CACHE_RSVD0                 = 4'h4,
    AXI_CACHE_RSVD1                 = 4'h5,
    AXI_CACHE_WTHROUGH_ALLOC_R_ONLY = 4'h6,
    AXI_CACHE_WBACK_ALLOC_R_ONLY    = 4'h7,
    AXI_CACHE_RSVD2                 = 4'h8,
    AXI_CACHE_RSVD3                 = 4'h9,
    AXI_CACHE_WTHROUGH_ALLOC_W_ONLY = 4'ha,
    AXI_CACHE_WBACK_ALLOC_W_ONLY    = 4'hb,
    AXI_CACHE_RSVD4                 = 4'hc,
    AXI_CACHE_RSVD5                 = 4'hd,
    AXI_CACHE_WTHROUGH_ALLOC_RW     = 4'he,
    AXI_CACHE_WBACK_ALLOC_RW        = 4'hf
} axi_cache_e;


// enum: axi_burst_e
//
//------------------------------------------------------------------------------
//  Burst type - determines address calculation
//------------------------------------------------------------------------------
typedef enum bit [1:0]
{
    AXI_FIXED      = 2'h0,
    AXI_INCR       = 2'h1,
    AXI_WRAP       = 2'h2,
    AXI_BURST_RSVD = 2'h3
} axi_burst_e;


// enum: axi_response_e
//
//------------------------------------------------------------------------------
//  Response type 
//------------------------------------------------------------------------------
typedef enum bit [1:0]
{
    AXI_OKAY   = 2'h0,
    AXI_EXOKAY = 2'h1,
    AXI_SLVERR = 2'h2,
    AXI_DECERR = 2'h3
} axi_response_e;


// enum: axi_lock_e
//
//------------------------------------------------------------------------------
//  Lock type for atomic accesses
//------------------------------------------------------------------------------
typedef enum bit [1:0]
{
    AXI_NORMAL    = 2'h0,
    AXI_EXCLUSIVE = 2'h1,
    AXI_LOCKED    = 2'h2,
    AXI_LOCK_RSVD = 2'h3
} axi_lock_e;


// enum: axi_abstraction_level_e
//
//------------------------------------------------------------------------------
//  Abstraction level control
//------------------------------------------------------------------------------
typedef enum bit [2:0]
{
    AXI_PV       = 3'h0,
    AXI_PVT      = 3'h1,
    AXI_CC_BURST = 3'h2,
    AXI_CC_PHASE = 3'h3,
    AXI_CA       = 3'h4
} axi_abstraction_level_e;


// enum: axi_rw_e
//
typedef enum bit [0:0]
{
    AXI_TRANS_READ  = 1'h0,
    AXI_TRANS_WRITE = 1'h1
} axi_rw_e;


// enum: axi_error_e
//
typedef enum bit [3:0]
{
    AXI_AWBURST_RSVD        = 4'h0,
    AXI_ARBURST_RSVD        = 4'h1,
    AXI_AWSIZE_GT_BUS_WIDTH = 4'h2,
    AXI_ARSIZE_GT_BUS_WIDTH = 4'h3,
    AXI_AWLOCK_RSVD         = 4'h4,
    AXI_ARLOCK_RSVD         = 4'h5,
    AXI_AWLEN_LAST_MISMATCH = 4'h6,
    AXI_AWID_WID_MISMATCH   = 4'h7,
    AXI_WSTRB_ILLEGAL       = 4'h8,
    AXI_AWCACHE_RSVD        = 4'h9,
    AXI_ARCACHE_RSVD        = 4'ha
} axi_error_e;


// enum: axi_assertion_type_e
//
//------------------------------------------------------------------------------
//  Type defining the error messages which can be produced by the <mgc_axi> MVC.
// 
// Individual error messages can be disabled using the <IF::config_enable_error> array of configuration bits.
// 
//------------------------------------------------------------------------------
//    AXI_ARESETn_SIGNAL_Z -  AXI reset signal (ARESETn) has a value Z
//    AXI_ARESETn_SIGNAL_X -  AXI reset signal (ARESETn) has a value X
//    AXI_ACLK_SIGNAL_Z -  
//    AXI_ADDR_FOR_READ_BURST_ACROSS_4K_BOUNDARY -  This read transaction has crossed a 4KB boundary (SPEC3(A3.4.1))
//    AXI_ADDR_FOR_WRITE_BURST_ACROSS_4K_BOUNDARY -  This write transaction has crossed a 4KB boundary (SPEC3(A3.4.1))
//    AXI_ARADDR_CHANGED_BEFORE_ARREADY -  The value of <IF::ARADDR> has changed from its initial value between the time <IF::ARVALID> was asserted, and before <IF::ARREADY> was asserted (SPEC3(A3.2.1))
//    AXI_ARADDR_UNKN -  <IF::ARADDR> has an X value/<IF::ARADDR> has an Z value (SPEC3(A2.5))
//    AXI_ARBURST_CHANGED_BEFORE_ARREADY -  The value of <IF::ARBURST> has changed from its initial value between the time <IF::ARVALID> was asserted, and before <IF::ARREADY> was asserted (SPEC3(A3.2.1))
//    AXI_ARBURST_UNKN -  <IF::ARBURST> has an X value/<IF::ARBURST> has an Z value (SPEC3(A2.5))
//    AXI_ARCACHE_CHANGED_BEFORE_ARREADY -  The value of <IF::ARCACHE> has changed from its initial value between the time <IF::ARVALID> was asserted, and before <IF::ARREADY> was asserted (SPEC3(A3.2.1))
//    AXI_ARCACHE_UNKN -  <IF::ARCACHE> has an X value/<IF::ARCACHE> has an Z value (SPEC3(A2.5))
//    AXI_ARID_CHANGED_BEFORE_ARREADY -  The value of <IF::ARID> has changed from its initial value between the time <IF::ARVALID> was asserted, and before <IF::ARREADY> was asserted (SPEC3(A3.2.1))
//    AXI_ARID_UNKN -  <IF::ARID> has an X value/<IF::ARID> has an Z value (SPEC3(A2.5))
//    AXI_ARLEN_CHANGED_BEFORE_ARREADY -  The value of <IF::ARLEN> has changed from its initial value between the time <IF::ARVALID> was asserted, and before <IF::ARREADY> was asserted (SPEC3(A3.2.1))
//    AXI_ARLEN_UNKN -  <IF::ARLEN> has an X value/<IF::ARLEN> has an Z value (SPEC3(A2.5))
//    AXI_ARLOCK_CHANGED_BEFORE_ARREADY -  The value of <IF::ARLOCK> has changed from its initial value between the time <IF::ARVALID> was asserted, and before <IF::ARREADY> was asserted (SPEC3(A3.2.1))
//    AXI_ARLOCK_UNKN -  <IF::ARLOCK> has an X value/<IF::ARLOCK> has an Z value (SPEC3(A2.5))
//    AXI_ARPROT_CHANGED_BEFORE_ARREADY -  The value of <IF::ARPROT> has changed from its initial value between the time <IF::ARVALID> was asserted, and before <IF::ARREADY> was asserted (SPEC3(A3.2.1))
//    AXI_ARPROT_UNKN -  <IF::ARPROT> has an X value/<IF::ARPROT> has an Z value (SPEC3(A2.5))
//    AXI_ARREADY_UNKN -  <IF::ARREADY> has an X value/<IF::ARREADY> has a Z value (SPEC3(A2.5))
//    AXI_ARSIZE_CHANGED_BEFORE_ARREADY -  The value of <IF::ARSIZE> has changed from its initial value between the time <IF::ARVALID> was asserted, and before <IF::ARREADY> was asserted (SPEC3(A3.2.1))
//    AXI_ARSIZE_UNKN -  <IF::ARSIZE> has an X value/<IF::ARSIZE> has an Z value (SPEC3(A2.5))
//    AXI_ARUSER_CHANGED_BEFORE_ARREADY -  The value of <IF::ARUSER> has changed from its initial value between the time <IF::ARVALID> was asserted, and before <IF::ARREADY> was asserted (SPEC3(A3.2.1))
//    AXI_ARUSER_UNKN -  <IF::ARUSER> has an X value/<IF::ARUSER> has an Z value (SPEC3(A2.5))
//    AXI_ARVALID_DEASSERTED_BEFORE_ARREADY -  <IF::ARVALID> has been de-asserted before <IF::ARREADY> was asserted (SPEC3(A3.2.1))
//    AXI_ARVALID_HIGH_ON_FIRST_CLOCK_AFTER_RESET -  A master interface must begin driving <IF::ARVALID> high only at a rising clock edge after <IF::ARESETn> is HIGH (SPEC3(A3.1.2))
//    AXI_ARVALID_UNKN -  <IF::ARVALID> has an X value/<IF::ARVALID> has an Z value (SPEC3(A2.5))
//    AXI_AWADDR_CHANGED_BEFORE_AWREADY -  The value of <IF::AWADDR> has changed from its initial value between the time <IF::AWVALID> was asserted, and before <IF::AWREADY> was asserted (SPEC3(A3.2.1))
//    AXI_AWADDR_UNKN -  <IF::AWADDR> has an X value/<IF::AWADDR> has an Z value (SPEC3(A2.2))
//    AXI_AWBURST_CHANGED_BEFORE_AWREADY -  The value of <IF::AWBURST> has changed from its initial value between the time <IF::AWVALID> was asserted, and before <IF::AWREADY> was asserted (SPEC3(A3.2.1))
//    AXI_AWBURST_UNKN -  <IF::AWBURST> has an X value/<IF::AWBURST> has an Z value (SPEC3(A2.2))
//    AXI_AWCACHE_CHANGED_BEFORE_AWREADY -  The value of <IF::AWCACHE> has changed from its initial value between the time <IF::AWVALID> was asserted, and before <IF::AWREADY> was asserted (SPEC3(A3.2.1))                       
//    AXI_AWCACHE_UNKN -  <IF::AWCACHE> has an X value/AWCACHE has an Z value (SPEC3(A2.2))
//    AXI_AWID_CHANGED_BEFORE_AWREADY -  The value of <IF::AWID> has changed from its initial value between the time <IF::AWVALID> was asserted, and before <IF::AWREADY> was asserted (SPEC3(A3.2.1))
//    AXI_AWID_UNKN -  <IF::AWID> has an X value/<IF::AWID> has an Z value (SPEC3(A2.2))
//    AXI_AWLEN_CHANGED_BEFORE_AWREADY -  The value of <IF::AWLEN> has changed from its initial value between the time <IF::AWVALID> was asserted, and before <IF::AWREADY> was asserted (SPEC3(A3.2.1))
//    AXI_AWLEN_UNKN -  <IF::AWLEN> has an X value/<IF::AWLEN> has an Z value (SPEC3(A2.2))                                                                                                                                        
//    AXI_AWLOCK_CHANGED_BEFORE_AWREADY -  The value of <IF::AWLOCK> has changed from its initial value between the time <IF::AWVALID> was asserted, and before <IF::AWREADY> was asserted (SPEC3(A3.2.1))                            
//    AXI_AWLOCK_UNKN -  <IF::AWLOCK> has an X value/<IF::AWLOCK> has an Z value (SPEC3(A2.2))
//    AXI_AWPROT_CHANGED_BEFORE_AWREADY -  The value of <IF::AWPROT> has changed from its initial value between the time <IF::AWVALID> was asserted, and before <IF::AWREADY> was asserted (SPEC3(A3.2.1))                          
//    AXI_AWPROT_UNKN -  <IF::AWPROT> has an X value/<IF::AWPROT> has an Z value (SPEC3(A2.2))                                                                                                                                        
//    AXI_AWREADY_UNKN -  <IF::AWREADY> has an X value/<IF::AWREADY> has an Z value (SPEC3(A2.2))                                                                                                                                        
//    AXI_AWSIZE_CHANGED_BEFORE_AWREADY -  The value of <IF::AWSIZE> has changed from its initial value between the time <IF::AWVALID> was asserted, and before <IF::AWREADY> was asserted (SPEC3(A3.2.1))                                       
//    AXI_AWSIZE_UNKN -  <IF::AWSIZE> has an X value/<IF::AWSIZE> has an Z value (SPEC3(A2.2))                                                                                                                                                 
//    AXI_AWUSER_CHANGED_BEFORE_AWREADY -  The value of <IF::AWUSER> has changed from its initial value between the time <IF::AWVALID> was asserted, and before <IF::AWREADY> was asserted (SPEC3(A3.2.1))                                           
//    AXI_AWUSER_UNKN -  <IF::AWUSER> has an X value/<IF::AWUSER> has an Z value (SPEC3(A3.1))                                                                                                                                                    
//    AXI_AWVALID_DEASSERTED_BEFORE_AWREADY -  <IF::AWVALID> has been de-asserted before <IF::AWREADY> was asserted (SPEC3(A3.2.2))                                                                                                                  
//    AXI_AWVALID_HIGH_ON_FIRST_CLOCK_AFTER_RESET -  A master interface must begin driving <IF::AWVALID> high only at a rising clock edge after <IF::ARESETn> is HIGH (SPEC3(A3.1.2))                                                               
//    AXI_AWVALID_UNKN -  <IF::AWVALID> has an X value/<IF::AWVALID> has an Z value (SPEC3(A2.2))                                                                                                                                                 
//    AXI_BID_CHANGED_BEFORE_BREADY -  The value of <IF::BID> has changed from its initial value between the time <IF::BVALID> was asserted, and before <IF::BREADY> was asserted (SPEC3(A3.2.1))                                                 
//    AXI_BID_UNKN -  <IF::BID> has an X value/<IF::BID> has a Z value (SPEC3(A2.4))                                                                                                                                                       
//    AXI_BREADY_UNKN -  <IF::BREADY> has an X value/<IF::BREADY> has an Z value (SPEC3(A2.4))                                                                                                                                                 
//    AXI_BRESP_CHANGED_BEFORE_BREADY -  The value of <IF::BRESP> has changed from its initial value between the time <IF::BVALID> was asserted, and before <IF::BREADY> was asserted (SPEC3(A3.2.1))                                            
//    AXI_BRESP_UNKN -  <IF::BRESP> has an X value/<IF::BRESP> has a Z value (SPEC3(A2.4))                                                                                                                                                   
//    AXI_BUSER_CHANGED_BEFORE_BREADY -  The value of <IF::BUSER> has changed from its initial value between the time <IF::BVALID> was asserted, and before <IF::BREADY> was asserted (SPEC3(A3.2.1))                                       
//    AXI_BUSER_UNKN -  <IF::BUSER> has an X value/<IF::BUSER> has a Z value (SPEC3(A2.4))                                                                                                                                                       
//    AXI_BVALID_DEASSERTED_BEFORE_BREADY -  <IF::BVALID> has been de-asserted before <IF::BREADY> was asserted (SPEC3(A3.2.1))                                                                                                                       
//    AXI_BVALID_HIGH_ON_FIRST_CLOCK_AFTER_RESET -  A slave interface must begin driving  <IF::BVALID> high only at a rising clock edge after ARESETn is HIGH (SPEC3(A3.1.2))                                                                        
//    AXI_BVALID_UNKN -  <IF::BVALID> has an X value/<IF::BVALID> has a Z value (SPEC3(A2.4))                                                                                                                                                   
//    AXI_EXCLUSIVE_READ_ACCESS_MODIFIABLE -  The modifiable bit (bit 1 of the cache parameter) should not be set for an exclusive read access (SPEC3(A7.2.4))                                                                                 
//    AXI_EXCLUSIVE_READ_BYTES_TRANSFER_EXCEEDS_128 -  Number of bytes in an exclusive read transaction must be less than or equal to 128 (SPEC3(A7.2.4))                                                                                         
//    AXI_EXCLUSIVE_WRITE_BYTES_TRANSFER_EXCEEDS_128 -  Number of bytes in an exclusive write transaction must be less than or equal to 128 (SPEC3(A7.2.4))                                                                                
//    AXI_EXCLUSIVE_READ_BYTES_TRANSFER_NOT_POWER_OF_2 -  Number of bytes of an exclusive read transaction is not a power of 2 (SPEC3(A7.2.4))                                                                                           
//    AXI_EXCLUSIVE_WRITE_BYTES_TRANSFER_NOT_POWER_OF_2 -  Number of bytes of an exclusive write transaction is not a power of 2 (SPEC3(A7.2.4))                                                                                               
//    AXI_EXCLUSIVE_WR_ADDRESS_NOT_SAME_AS_RD -  Exclusive write does not match the address of the previous exclusive read to this id (SPEC3(A7.2.4))                                                                                        
//    AXI_EXCLUSIVE_WR_BURST_NOT_SAME_AS_RD -  Exclusive write does not match the burst setting of the previous exclusive read to this id (SPEC3(A7.2.4))                                                                                      
//    AXI_EXCLUSIVE_WR_CACHE_NOT_SAME_AS_RD -  Exclusive write does not match the cache setting of the previous exclusive read to this id (see the ARM AXI compliance-checker AXI_RECM_EXCL_MATCH assertion code) (SPEC3(A7.2.4))            
//    AXI_EXCLUSIVE_WRITE_ACCESS_MODIFIABLE -  The modifiable bit (bit 1 of the cache parameter) should not be set for an exclusive write access (SPEC3(A7.2.4))                                                               
//    AXI_EXCLUSIVE_WR_LENGTH_NOT_SAME_AS_RD -  Exclusive write does not match the length of the previous exclusive read to this id (SPEC3(A7.2.4))                                                                           
//    AXI_EXCLUSIVE_WR_PROT_NOT_SAME_AS_RD -  Exclusive write does not match the prot setting of the previous exclusive read to this id (SPEC3(A7.2.4))                                                                       
//    AXI_EXCLUSIVE_WR_SIZE_NOT_SAME_AS_RD -  Exclusive write does not match the size of the previous exclusive read to this id (SPEC3(A7.2.4))                                                                               
//    AXI_EXOKAY_RESPONSE_NORMAL_READ -  Slave has responded <AXI_EXOKAY> to a non exclusive read transfer                                                                                                                
//    AXI_EXOKAY_RESPONSE_NORMAL_WRITE -  Slave has responded <AXI_EXOKAY> to a non exclusive write transfer                                                                                                               
//    AXI_EX_RD_RESP_MISMATCHED_WITH_EXPECTED_RESP -  Expected response to this exclusive read did not matched with the actual response (SPEC3(A7.2.3))                                                                            
//    AXI_EX_WR_RESP_MISMATCHED_WITH_EXPECTED_RESP -  Expected response to this exclusive write did not matched with the actual response (SPEC3(A7.2.3))                                                                           
//    AXI_EX_RD_EXOKAY_RESP_SLAVE_WITHOUT_EXCLUSIVE_ACCESS -  Response for an exclusive read to a slave which does not support exclusive access should be <AXI_OKAY>, but it returned <AXI_EXOKAY> (SPEC3(A7.2.3))
//    AXI_EX_WRITE_BEFORE_EX_READ_RESPONSE -  Exclusive write has occurred, with no previous exclusive read (SPEC3(A7.2.2))                                                                                                        
//    AXI_EX_WRITE_EXOKAY_RESP_SLAVE_WITHOUT_EXCLUSIVE_ACCESS -  Response for an exclusive write to a slave which does not support exclusive access should be <AXI_OKAY>, but it returned <AXI_EXOKAY> (SPEC3(A7.2.3))              
//    AXI_ILLEGAL_LENGTH_WRAPPING_READ_BURST -  In the last read address phase burst_length has an illegal value for a burst of type AXI_WRAP (SPEC3(A3.4.1))                                                         
//    AXI_ILLEGAL_LENGTH_WRAPPING_WRITE_BURST -  In the last write address phase burst_length has an illegal value for a burst of type AXI_WRAP (SPEC3(A3.4.1))                                                        
//    AXI_ILLEGAL_RESPONSE_EXCLUSIVE_READ -  Response for an exclusive read should be either <AXI_OKAY> or <AXI_EXOKAY> (SPEC3(A7.2.3))                                                                                    
//    AXI_ILLEGAL_RESPONSE_EXCLUSIVE_WRITE -  Response for an exclusive write should be either <AXI_OKAY> or <AXI_EXOKAY> (SPEC3(A7.2.3))                                                                                   
//    AXI_PARAM_READ_DATA_BUS_WIDTH -  The value of <IF::AXI_RDATA_WIDTH> must be one of 8,16,32,64,128,256,512,1024 (SPEC3(A1.3.1))                                                                                            
//    AXI_PARAM_WRITE_DATA_BUS_WIDTH -  The value of <IF::AXI_WDATA_WIDTH> must be one of 8,16,32,64,128,256,512,1024 (SPEC3(A1.3.1))                                                                                        
//    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_12 -  The RA bit of the cache parameter should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                                                              
//    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_13 -  The RA bit of the cache parameter should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                                                             
//    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_4 -  The RA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                                                                
//    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_5 -  The RA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                                                                  
//    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_8 -  The RA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                                                                     
//    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_9 -  The RA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                                                                     
//    AXI_READ_BURST_LENGTH_VIOLATION -  The burst_length implied by the number of beats actually read does not match the burst_length defined by the <I_F_master_read_addr_channel_phase> (SPEC3(A3.4.1))                             
//    AXI_READ_BURST_SIZE_VIOLATION -  In this read transaction, size has been set greater than the defined data bus width (SPEC3(A3.4.1))                                                                                                   
//    AXI_READ_DATA_BEFORE_ADDRESS -  An unexpected read response has occurred (there are no outstanding read transactions with this id) (SPEC3(A3.3.1))                                                                           
//    AXI_READ_DATA_CHANGED_BEFORE_RREADY -  The value of <IF::RDATA> has changed from its initial value between the time <IF::RVALID> was asserted, and before <IF::RREADY> was asserted (SPEC3(A3.2.1))                              
//    AXI_READ_DATA_UNKN -  <IF::RDATA> has an X value/<IF::RDATA> has a Z value (SPEC3(A2.6))                                                                                                                                     
//    AXI_RESERVED_ARLOCK_ENCODING -  The reserved encoding of 2'b11 should not be used for ARLOCK (SPEC3(A7.4))                                                                                                                   
//    AXI_READ_RESP_CHANGED_BEFORE_RREADY -  The value of <IF::RRESP> has changed from its initial value between the time <IF::RVALID> was asserted, and before <IF::RREADY> was asserted (SPEC3(A3.2.1))                        
//    AXI_RESERVED_ARBURST_ENCODING -  The reserved encoding of 2'b11 should not be used for <IF::ARBURST> (SPEC3(A3.4.1))                                                                                              
//    AXI_RESERVED_AWBURST_ENCODING -  The reserved encoding of 2'b11 should not be used for <IF::AWBURST> (SPEC3(A3.4.1))                                                                                                  
//    AXI_RID_CHANGED_BEFORE_RREADY -  The value of <IF::RID> has changed from its initial value between the time <IF::RVALID> was asserted, and before <IF::RREADY> was asserted (SPEC3(A3.2.1))                              
//    AXI_RID_UNKN -  <IF::RID> has an X value/<IF::RID> has a Z value (SPEC3(A2.6))                                                                                                                                    
//    AXI_RLAST_CHANGED_BEFORE_RREADY -  The value of <IF::RLAST> has changed from its initial value between the time <IF::RVALID> was asserted, and before <IF::RREADY> was asserted (SPEC3(A3.2.1))                     
//    AXI_RLAST_UNKN -  <IF::RLAST> has an X value/<IF::RLAST> has a Z value (SPEC3(A2.6))                                                                                                                                 
//    AXI_RREADY_UNKN -  <IF::RREADY> has an X value/<IF::RREADY> has a Z value (SPEC3(A2.6))                                                                                                                                   
//    AXI_RRESP_UNKN -  <IF::RRESP> has an X value/<IF::RRESP> has a Z value (SPEC3(A2.6))                                                                                                                                  
//    AXI_RUSER_CHANGED_BEFORE_RREADY -  The value of <IF::RUSER> has changed from its initial value between the time <IF::RVALID> was asserted, and before <IF::RREADY> was asserted (SPEC3(A3.2.1))                          
//    AXI_RUSER_UNKN -  <IF::RUSER> has an X value/<IF::RUSER> has a Z value (SPEC3(A2.6))                                                                                                              
//    AXI_RVALID_DEASSERTED_BEFORE_RREADY -  <IF::RVALID> has been de-asserted before <IF::RREADY> was asserted (SPEC3(A3.2.1))                                                                         
//    AXI_RVALID_HIGH_ON_FIRST_CLOCK_AFTER_RESET -  A slave interface must begin driving  <IF::RVALID> high only at a rising clock edge after ARESETn is HIGH (SPEC3(A3.1.2))                                  
//    AXI_RVALID_UNKN -  <IF::RVALID> has an X value/<IF::RVALID> has a Z value (SPEC3(A2.6))                                                                                                        
//    AXI_UNALIGNED_ADDRESS_FOR_EXCLUSIVE_READ -  Exclusive read accesses must have address aligned to the total number of bytes in the transaction (SPEC3(A7.2.4))                                     
//    AXI_UNALIGNED_ADDRESS_FOR_EXCLUSIVE_WRITE -  Exclusive write accesses must have address aligned to the total number of bytes in the transaction (SPEC3(A7.2.4))                                     
//    AXI_UNALIGNED_ADDR_FOR_WRAPPING_READ_BURST -  Wrapping bursts must have address aligned to the start of the read transfer (SPEC3(A3.4.1))                                                                                                                                    
//    AXI_UNALIGNED_ADDR_FOR_WRAPPING_WRITE_BURST -  Wrapping bursts must have address aligned to the start of the write transfet (SPEC3(A3.4.1))                                                                                                                                    
//    AXI_WDATA_CHANGED_BEFORE_WREADY_ON_INVALID_LANE -  On a lane whose strobe is 0, the value of <IF::WDATA> has changed from its initial value between the time <IF::WVALID> was asserted, and before <IF::WREADY> was asserted (SPEC3(A3.2.1))                               
//    AXI_WDATA_CHANGED_BEFORE_WREADY_ON_VALID_LANE -  On a lane whose strobe is 1, the value of <IF::WDATA> has changed from its initial value between the time <IF::WVALID> was asserted, and before <IF::WREADY> was asserted (SPEC3(A3.2.1))                                   
//    AXI_WLAST_CHANGED_BEFORE_WREADY -  The value of <IF::WLAST> has changed from its initial value between the time <IF::WVALID> was asserted, and before <IF::WREADY> was asserted (SPEC3(A3.2.1))                                
//    AXI_WID_CHANGED_BEFORE_WREADY -  The value of <IF::WID> has changed from its initial value between the time <IF::WVALID> was asserted, and before <IF::WREADY> was asserted (SPEC3(A3.2.1))                                
//    AXI_WLAST_UNKN -  <IF::WLAST> has an X value/<IF::WLAST> has an Z value (SPEC3(A2.3))                                                                                        
//    AXI_WID_UNKN -  <IF::WID> has an X value/<IF::WID> has an Z value (SPEC3(A2.3))                                                                                                     
//    AXI_WREADY_UNKN -  <IF::WREADY> has an X value/<IF::WREADY> has a Z value (SPEC3(A2.3))                                                                                       
//    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_12 -  The WA bit of the cache parameter should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                     
//    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_13 -  The WA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                   
//    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_4 -  The WA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                              
//    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_5 -  The WA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                         
//    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_8 -  The WA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                           
//    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_9 -  The WA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (SPEC3(A4.4))                                            
//    AXI_WRITE_BURST_SIZE_VIOLATION -  In this write transaction, size has been set greater than the defined data buswidth (SPEC3(A3.4.1))                                         
//    AXI_WRITE_DATA_BEFORE_ADDRESS -  A write data beat has occurred before the corresponding address phase                                                                      
//    AXI_WRITE_DATA_UNKN_ON_INVALID_LANE -  On a lane whose strobe is 0, <IF::WDATA> has an X value/<IF::WDATA> has a Z value (SPEC3(A2.3))                                           
//    AXI_WRITE_DATA_UNKN_ON_VALID_LANE -  On a lane whose strobe is 1, <IF::WDATA> has an X value/<IF::WDATA> has a Z value (SPEC3(A2.3))                                          
//    AXI_RESERVED_AWLOCK_ENCODING -  The reserved encoding of 2'b11 should not be used for AWLOCK (SPEC3(A7.4))                                                                                                                                
//    AXI_WRITE_STROBE_ON_INVALID_BYTE_LANES -  Write strobe(s) incorrect for the address/size of a fixed transfer (SPEC3(A2.3))                                                                                                                  
//    AXI_WSTRB_CHANGED_BEFORE_WREADY -  The value of <IF::WSTRB> has changed from its initial value between the time <IF::WVALID> was asserted, and before <IF::WREADY> was asserted (SPEC3(A3.2.1))                                         
//    AXI_WSTRB_UNKN -  <IF::WSTRB> has an X value/<IF::WSTRB> has an Z value (SPEC3(A2.3))                                                                                                                                                      
//    AXI_WUSER_CHANGED_BEFORE_WREADY -  The value of <IF::WUSER> has changed from its initial value between the time <IF::WVALID> was asserted, and before <IF::WREADY> was asserted (SPEC3(A3.2.1))                                        
//    AXI_WUSER_UNKN -  <IF::WUSER> has an X value/<IF::WUSER> has an Z value (SPEC3(A2.3))                                                                                                                              
//    AXI_WVALID_DEASSERTED_BEFORE_WREADY -  <IF::WVALID> has been de-asserted before <IF::WREADY> was asserted (SPEC3(A3.2.1))                                                                                               
//    AXI_WVALID_HIGH_ON_FIRST_CLOCK_AFTER_RESET -  A master interface must begin driving <IF::WVALID> high only at a rising clock edge after <IF::ARESETn> is HIGH (SPEC3(A3.1.2))                                             
//    AXI_WVALID_UNKN -  <IF::WVALID> has an X value/<IF::WVALID> has an Z value (SPEC3(A2.3))                                                                                                             
//    AXI_ADDR_ACROSS_4K_WITHIN_LOCKED_WRITE_TRANSACTION -  Transactions within a locked write sequence should be within the same 4K address boundary (SPEC3(A7.3))                                           
//    AXI_ADDR_ACROSS_4K_WITHIN_LOCKED_READ_TRANSACTION -  Transactions within a locked read sequence should be within the same 4K address boundary (SPEC3(A7.3))                                            
//    AXI_AWID_CHANGED_WITHIN_LOCKED_TRANSACTION -  Master should not change the awid within the locked transaction (SPEC3(A7.3))                                               
//    AXI_ARID_CHANGED_WITHIN_LOCKED_TRANSACTION -  Master should not change the arid within the locked transaction (SPEC3(A7.3))                                              
//    AXI_AWPROT_CHANGED_WITHIN_LOCKED_TRANSACTION -  Master should not change the awprot within the locked transaction (SPEC3(A7.3))                                                   
//    AXI_ARPROT_CHANGED_WITHIN_LOCKED_TRANSACTION -  Master should not change the arprot within the locked transaction (SPEC3(A7.3))                                                 
//    AXI_AWCACHE_CHANGED_WITHIN_LOCKED_TRANSACTION -  Master should not change the awcache within the locked transaction (SPEC3(A7.3))                                                    
//    AXI_ARCACHE_CHANGED_WITHIN_LOCKED_TRANSACTION -  Master should not change the arcache within the locked transaction (SPEC3(A7.3))                                                      
//    AXI_NUMBER_OF_LOCKED_SEQUENCES_EXCEEDS_2 -  Number of accesses within a locked sequence should not be more than 2 (SPEC3(A7.3))                                                                                                     
//    AXI_LOCKED_WRITE_BEFORE_COMPLETION_OF_PREVIOUS_WRITE_TRANSACTIONS -  A locked write sequence should not commence before completion of all previously issued write addresses (SPEC3(A7.3))                                                 
//    AXI_LOCKED_WRITE_BEFORE_COMPLETION_OF_PREVIOUS_READ_TRANSACTIONS -  A locked write sequence should not commence before completion of all previously issued read addresses (SPEC3(A7.3))                                              
//    AXI_LOCKED_READ_BEFORE_COMPLETION_OF_PREVIOUS_WRITE_TRANSACTIONS -  A locked read sequence should not commence before completion of all previously issued write addresses (SPEC3(A7.3))                                                    
//    AXI_LOCKED_READ_BEFORE_COMPLETION_OF_PREVIOUS_READ_TRANSACTIONS -  A locked read sequence should not commence before completion of all previously issued read addresses (SPEC3(A7.3))                                                        
//    AXI_NEW_BURST_BEFORE_COMPLETION_OF_UNLOCK_TRANSACTION -  The unlocking transaction should be completed before further any transactions are initiated (SPEC3(A7.3))                                                           
//    AXI_UNLOCKED_WRITE_WHILE_OUTSTANDING_LOCKED_WRITES -  Unlocking write transaction started while outstanding locked write transaction has not completed (SPEC3(A7.3))                                                  
//    AXI_UNLOCKED_WRITE_WHILE_OUTSTANDING_LOCKED_READS -  Unlocking write transaction started while outstanding locked read transaction has not completed (SPEC3(A7.3))                                                 
//    AXI_UNLOCKED_READ_WHILE_OUTSTANDING_LOCKED_WRITES -  Unlocking read transaction started while outstanding locked write transaction has not completed (SPEC3(A7.3))                                                             
//    AXI_UNLOCKED_READ_WHILE_OUTSTANDING_LOCKED_READS -  Unlocking read transaction started while outstanding locked read transaction has not completed (SPEC3(A7.3))                                                     
//    AXI_UNLOCKING_TRANSACTION_WITH_AN_EXCLUSIVE_ACCESS -  Unlocking transaction can not be an exclusive access transaction (SPEC3(A7.3))                                                                                                                                                            
//    AXI_FIRST_DATA_ITEM_OF_TRANSACTION_WRITE_ORDER_VIOLATION -  The order in which a slave receives the first data item of each transaction must be the same as the order in which it receives the addresses for the transaction (SPEC3(A5.3.3))                                                      
//    AXI_AWLEN_MISMATCHED_WITH_COMPLETED_WRITE_DATA_BURST -  AWLEN value of write address control does not match with corresponding outstanding write data burts length (SPEC3(A3.4.1))                                                       
//    AXI_WRITE_LENGTH_MISMATCHED_ACTUAL_LENGTH_OF_WRITE_DATA_BURST_EXCEEDS_AWLEN -  The actual length of write data burst exceeds with the length specified by AWLEN (SPEC3(A3.4.1))                                              
//    AXI_AWLEN_MISMATCHED_ACTUAL_LENGTH_OF_WRITE_DATA_BURST_EXCEEDS_AWLEN -  Actual length of data burst has exceeded the burst length specified by AWLEN (SPEC3(A3.4.1))                                                               
//    AXI_WLAST_ASSERTED_DURING_DATA_PHASE_OTHER_THAN_LAST -  AWLEN value of write address control does not match with corresponding outstanding write data burts length (SPEC3(A3.4.1))                                                 
//    AXI_WRITE_INTERLEAVE_DEPTH_VIOLATION -  Write data bursts should not be interleaved beyond the write interleaving depth (SPEC3(A5.3.3))                                   
//    AXI_WRITE_RESPONSE_WITHOUT_ADDR -  Write response should not be sent before the corresponding address has completed (SPEC3(A3.3.1))                                 
//    AXI_WRITE_RESPONSE_WITHOUT_DATA -  Write response should not be sent before the corresponding write data burst completed (SPEC3(A3.3.1))                           
//    AXI_AWVALID_HIGH_DURING_RESET -  AWVALID asserted during the reset state (SPEC3(A3.1.2))                                                                                                                     
//    AXI_WVALID_HIGH_DURING_RESET -  WVALID asserted during the reset state (SPEC3(A3.1.2))                                                                                                                       
//    AXI_BVALID_HIGH_DURING_RESET -  BVALID asserted during the reset state (SPEC3(A3.1.2))                                                                                                                        
//    AXI_ARVALID_HIGH_DURING_RESET -  ARVALID asserted during the reset state (SPEC3(A3.1.2))                                                                                                                          
//    AXI_RVALID_HIGH_DURING_RESET -  RVALID asserted during the reset state (SPEC3(A3.1.2))                                                                                                                         
//    AXI_RLAST_VIOLATION -  RLAST signal should be asserted along with the final transfer of the read data burst (SPEC3(A3.4.1))                                                                                    
//    AXI_EX_WRITE_AFTER_EX_READ_FAILURE -  It is recommended that an exclusive write access should not be performed after the corresponding exclusive read failure. (SPEC3(A7.2.2))                                
//    AXI_TIMEOUT_WAITING_FOR_WRITE_DATA -  Timed-out waiting for a data phase in write data burst. SPEC3(A2.3)                                                           
//    AXI_TIMEOUT_WAITING_FOR_WRITE_RESPONSE -  Timed-out waiting for a write response. SPEC3(A2.4)                                                                      
//    AXI_TIMEOUT_WAITING_FOR_READ_RESPONSE -  Timed-out waiting for a read response. SPEC3(A2.6)                                                                            
//    AXI_TIMEOUT_WAITING_FOR_WRITE_ADDR_AFTER_DATA -  Timed-out waiting for a write address phase to be coming after data SPEC3(A2.2)                                       
//    AXI_DEC_ERR_RESP_FOR_READ -  No slave at the address for this read transfer (signaled by <AXI_DECERR>)                                                                     
//    AXI_DEC_ERR_RESP_FOR_WRITE -  No slave at the address for this write transfer (signaled by <AXI_DECERR>)                                                                     
//    AXI_SLV_ERR_RESP_FOR_READ -  Slave has detected an error for this read transfer (signaled by <AXI_SLVERR>)                                                                  
//    AXI_SLV_ERR_RESP_FOR_WRITE -  Slave has detected an error for this write transfer (signaled by <AXI_SLVERR>)                                                                   
//    AXI_MINIMUM_SLAVE_ADDRESS_SPACE_VIOLATION -  The minimum address space occupied by a single slave device is 4 kilobytes (SPEC3(A10.3.2))                                       
//    AXI_ADDRESS_WIDTH_EXCEEDS_64 -  AXI supports up to 64-bit addressing (SPEC3(A10.3.1))                                                                                                                  
//    AXI_READ_BURST_MAXIMUM_LENGTH_VIOLATION -  16 read data beats were seen without RLAST (SPEC3(A3.4.1))                                                                                                   
//    AXI_WRITE_BURST_MAXIMUM_LENGTH_VIOLATION -  16 write data beats were seen without WLAST (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1 )                                     
//    AXI_WRITE_STROBES_LENGTH_VIOLATION -  The size of the write_strobes array in a write transfer should match the value given by AWLEN                                                                                               
//    AXI_EX_RD_WHEN_EX_NOT_ENABLED -  An exclusive read should not be issued when exclusive transactions are not enabled                                                                                                                   
//    AXI_EX_WR_WHEN_EX_NOT_ENABLED -  An exclusive write should not be issued when exclusive transactions are not enabled                                                                                                     
//    AXI_WRITE_TRANSFER_EXCEEDS_ADDRESS_SPACE -  This write transfer runs off the edge of the address space defined by AXI_ADDRESS_WIDTH (SPEC3(A10.3.1))                                                                           
//    AXI_READ_TRANSFER_EXCEEDS_ADDRESS_SPACE -  This read transfer runs off the edge of the address space defined by AXI_ADDRESS_WIDTH (SPEC3(A10.3.1))                                                                                 
//    AXI_EXCL_RD_WHILE_EXCL_WR_IN_PROGRESS_SAME_ID -  Master starts an exclusive read burst while exclusive write burst with same ID tag is in progress (SPEC3(A7.2.4))                                                                 
//    AXI_EXCL_WR_WHILE_EXCL_RD_IN_PROGRESS_SAME_ID -  Master starts an exclusive write burst while exclusive read burst with same ID tag is in progress (SPEC3(A7.2.4))                                                                
//    AXI_ILLEGAL_LENGTH_READ_BURST -  Read address phase burst_length has an illegal value (SPEC3(A3.4.1))                                                                                                                      
//    AXI_ILLEGAL_LENGTH_WRITE_BURST -  Write address phase burst_length has an illegal value (SPEC3(A3.4.1))                                                                                                                        
//    AXI_ARREADY_NOT_ASSERTED_AFTER_ARVALID -  Once ARVALID has been asserted, ARREADY> should be asserted within config_max_latency_ARVALID_assertion_to_ARREADY clock periods                                                     
//    AXI_BREADY_NOT_ASSERTED_AFTER_BVALID -  Once BVALID has been asserted, BREADY> should be asserted within config_max_latency_BVALID_assertion_to_BREADY clock periods                                                             
//    AXI_AWREADY_NOT_ASSERTED_AFTER_AWVALID -  Once AWVALID has been asserted, AWREADY> should be asserted within config_max_latency_AWVALID_assertion_to_AWREADY clock periods                                                              
//    AXI_RREADY_NOT_ASSERTED_AFTER_RVALID -  Once RVALID has been asserted, RREADY> should be asserted within config_max_latency_RVALID_assertion_to_RREADY clock periods                                                                
//    AXI_WREADY_NOT_ASSERTED_AFTER_WVALID -  Once WVALID has been asserted, WREADY> should be asserted within config_max_latency_WVALID_assertion_to_WREADY clock periods                                                           
//    AXI_DEC_ERR_ILLEGAL_FOR_MAPPED_SLAVE_ADDR -  Slave receives a burst to a mapped address but responds with DECERR (signalled by AXI_DECERR) (SPEC3(A3.4.4))                                                                           
//    AXI_PARAM_READ_REORDERING_DEPTH_EQUALS_ZERO -  The user-supplied config_read_data_reordering_depth should be greater than zero (SPEC3(A5.3.1))                                                                                        
//    AXI_PARAM_READ_REORDERING_DEPTH_EXCEEDS_MAX_ID -  The user-supplied config_read_data_reordering_depth exceeds the maximum possible value, as defined by the AXI_ID_WIDTH parameter (SPEC3(A5.3.1))                              
//    AXI_READ_REORDERING_VIOLATION -  The arrival of a read response has exceeded the read reordering depth (SPEC3(A5.3.1))                             
typedef enum bit [7:0]
{
    AXI_ARESETn_SIGNAL_Z                                                        = 8'h00,
    AXI_ARESETn_SIGNAL_X                                                        = 8'h01,
    AXI_ACLK_SIGNAL_Z                                                           = 8'h02,
    AXI_ACLK_SIGNAL_X                                                           = 8'h03,
    AXI_ADDR_FOR_READ_BURST_ACROSS_4K_BOUNDARY                                  = 8'h04,
    AXI_ADDR_FOR_WRITE_BURST_ACROSS_4K_BOUNDARY                                 = 8'h05,
    AXI_ARADDR_CHANGED_BEFORE_ARREADY                                           = 8'h06,
    AXI_ARADDR_UNKN                                                             = 8'h07,
    AXI_ARBURST_CHANGED_BEFORE_ARREADY                                          = 8'h08,
    AXI_ARBURST_UNKN                                                            = 8'h09,
    AXI_ARCACHE_CHANGED_BEFORE_ARREADY                                          = 8'h0a,
    AXI_ARCACHE_UNKN                                                            = 8'h0b,
    AXI_ARID_CHANGED_BEFORE_ARREADY                                             = 8'h0c,
    AXI_ARID_UNKN                                                               = 8'h0d,
    AXI_ARLEN_CHANGED_BEFORE_ARREADY                                            = 8'h0e,
    AXI_ARLEN_UNKN                                                              = 8'h0f,
    AXI_ARLOCK_CHANGED_BEFORE_ARREADY                                           = 8'h10,
    AXI_ARLOCK_UNKN                                                             = 8'h11,
    AXI_ARPROT_CHANGED_BEFORE_ARREADY                                           = 8'h12,
    AXI_ARPROT_UNKN                                                             = 8'h13,
    AXI_ARREADY_UNKN                                                            = 8'h14,
    AXI_ARSIZE_CHANGED_BEFORE_ARREADY                                           = 8'h15,
    AXI_ARSIZE_UNKN                                                             = 8'h16,
    AXI_ARUSER_CHANGED_BEFORE_ARREADY                                           = 8'h17,
    AXI_ARUSER_UNKN                                                             = 8'h18,
    AXI_ARVALID_DEASSERTED_BEFORE_ARREADY                                       = 8'h19,
    AXI_ARVALID_HIGH_ON_FIRST_CLOCK_AFTER_RESET                                 = 8'h1a,
    AXI_ARVALID_UNKN                                                            = 8'h1b,
    AXI_AWADDR_CHANGED_BEFORE_AWREADY                                           = 8'h1c,
    AXI_AWADDR_UNKN                                                             = 8'h1d,
    AXI_AWBURST_CHANGED_BEFORE_AWREADY                                          = 8'h1e,
    AXI_AWBURST_UNKN                                                            = 8'h1f,
    AXI_AWCACHE_CHANGED_BEFORE_AWREADY                                          = 8'h20,
    AXI_AWCACHE_UNKN                                                            = 8'h21,
    AXI_AWID_CHANGED_BEFORE_AWREADY                                             = 8'h22,
    AXI_AWID_UNKN                                                               = 8'h23,
    AXI_AWLEN_CHANGED_BEFORE_AWREADY                                            = 8'h24,
    AXI_AWLEN_UNKN                                                              = 8'h25,
    AXI_AWLOCK_CHANGED_BEFORE_AWREADY                                           = 8'h26,
    AXI_AWLOCK_UNKN                                                             = 8'h27,
    AXI_AWPROT_CHANGED_BEFORE_AWREADY                                           = 8'h28,
    AXI_AWPROT_UNKN                                                             = 8'h29,
    AXI_AWREADY_UNKN                                                            = 8'h2a,
    AXI_AWSIZE_CHANGED_BEFORE_AWREADY                                           = 8'h2b,
    AXI_AWSIZE_UNKN                                                             = 8'h2c,
    AXI_AWUSER_CHANGED_BEFORE_AWREADY                                           = 8'h2d,
    AXI_AWUSER_UNKN                                                             = 8'h2e,
    AXI_AWVALID_DEASSERTED_BEFORE_AWREADY                                       = 8'h2f,
    AXI_AWVALID_HIGH_ON_FIRST_CLOCK_AFTER_RESET                                 = 8'h30,
    AXI_AWVALID_UNKN                                                            = 8'h31,
    AXI_BID_CHANGED_BEFORE_BREADY                                               = 8'h32,
    AXI_BID_UNKN                                                                = 8'h33,
    AXI_BREADY_UNKN                                                             = 8'h34,
    AXI_BRESP_CHANGED_BEFORE_BREADY                                             = 8'h35,
    AXI_BRESP_UNKN                                                              = 8'h36,
    AXI_BUSER_CHANGED_BEFORE_BREADY                                             = 8'h37,
    AXI_BUSER_UNKN                                                              = 8'h38,
    AXI_BVALID_DEASSERTED_BEFORE_BREADY                                         = 8'h39,
    AXI_BVALID_HIGH_ON_FIRST_CLOCK_AFTER_RESET                                  = 8'h3a,
    AXI_BVALID_UNKN                                                             = 8'h3b,
    AXI_EXCLUSIVE_READ_ACCESS_MODIFIABLE                                        = 8'h3c,
    AXI_EXCLUSIVE_READ_BYTES_TRANSFER_EXCEEDS_128                               = 8'h3d,
    AXI_EXCLUSIVE_WRITE_BYTES_TRANSFER_EXCEEDS_128                              = 8'h3e,
    AXI_EXCLUSIVE_READ_BYTES_TRANSFER_NOT_POWER_OF_2                            = 8'h3f,
    AXI_EXCLUSIVE_WRITE_BYTES_TRANSFER_NOT_POWER_OF_2                           = 8'h40,
    AXI_EXCLUSIVE_WR_ADDRESS_NOT_SAME_AS_RD                                     = 8'h41,
    AXI_EXCLUSIVE_WR_BURST_NOT_SAME_AS_RD                                       = 8'h42,
    AXI_EXCLUSIVE_WR_CACHE_NOT_SAME_AS_RD                                       = 8'h43,
    AXI_EXCLUSIVE_WRITE_ACCESS_MODIFIABLE                                       = 8'h44,
    AXI_EXCLUSIVE_WR_LENGTH_NOT_SAME_AS_RD                                      = 8'h45,
    AXI_EXCLUSIVE_WR_PROT_NOT_SAME_AS_RD                                        = 8'h46,
    AXI_EXCLUSIVE_WR_SIZE_NOT_SAME_AS_RD                                        = 8'h47,
    AXI_EXOKAY_RESPONSE_NORMAL_READ                                             = 8'h48,
    AXI_EXOKAY_RESPONSE_NORMAL_WRITE                                            = 8'h49,
    AXI_EX_RD_RESP_MISMATCHED_WITH_EXPECTED_RESP                                = 8'h4a,
    AXI_EX_WR_RESP_MISMATCHED_WITH_EXPECTED_RESP                                = 8'h4b,
    AXI_EX_RD_EXOKAY_RESP_SLAVE_WITHOUT_EXCLUSIVE_ACCESS                        = 8'h4c,
    AXI_EX_WRITE_BEFORE_EX_READ_RESPONSE                                        = 8'h4d,
    AXI_EX_WRITE_EXOKAY_RESP_SLAVE_WITHOUT_EXCLUSIVE_ACCESS                     = 8'h4e,
    AXI_ILLEGAL_LENGTH_WRAPPING_READ_BURST                                      = 8'h4f,
    AXI_ILLEGAL_LENGTH_WRAPPING_WRITE_BURST                                     = 8'h50,
    AXI_ILLEGAL_RESPONSE_EXCLUSIVE_READ                                         = 8'h51,
    AXI_ILLEGAL_RESPONSE_EXCLUSIVE_WRITE                                        = 8'h52,
    AXI_PARAM_READ_DATA_BUS_WIDTH                                               = 8'h53,
    AXI_PARAM_WRITE_DATA_BUS_WIDTH                                              = 8'h54,
    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_12                                    = 8'h55,
    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_13                                    = 8'h56,
    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_4                                     = 8'h57,
    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_5                                     = 8'h58,
    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_8                                     = 8'h59,
    AXI_READ_ALLOCATE_WHEN_NON_MODIFIABLE_9                                     = 8'h5a,
    AXI_READ_BURST_LENGTH_VIOLATION                                             = 8'h5b,
    AXI_READ_BURST_SIZE_VIOLATION                                               = 8'h5c,
    AXI_READ_DATA_BEFORE_ADDRESS                                                = 8'h5d,
    AXI_READ_DATA_CHANGED_BEFORE_RREADY                                         = 8'h5e,
    AXI_READ_DATA_UNKN                                                          = 8'h5f,
    AXI_RESERVED_ARLOCK_ENCODING                                                = 8'h60,
    AXI_READ_RESP_CHANGED_BEFORE_RREADY                                         = 8'h61,
    AXI_RESERVED_ARBURST_ENCODING                                               = 8'h62,
    AXI_RESERVED_AWBURST_ENCODING                                               = 8'h63,
    AXI_RID_CHANGED_BEFORE_RREADY                                               = 8'h64,
    AXI_RID_UNKN                                                                = 8'h65,
    AXI_RLAST_CHANGED_BEFORE_RREADY                                             = 8'h66,
    AXI_RLAST_UNKN                                                              = 8'h67,
    AXI_RREADY_UNKN                                                             = 8'h68,
    AXI_RRESP_UNKN                                                              = 8'h69,
    AXI_RUSER_CHANGED_BEFORE_RREADY                                             = 8'h6a,
    AXI_RUSER_UNKN                                                              = 8'h6b,
    AXI_RVALID_DEASSERTED_BEFORE_RREADY                                         = 8'h6c,
    AXI_RVALID_HIGH_ON_FIRST_CLOCK_AFTER_RESET                                  = 8'h6d,
    AXI_RVALID_UNKN                                                             = 8'h6e,
    AXI_UNALIGNED_ADDRESS_FOR_EXCLUSIVE_READ                                    = 8'h6f,
    AXI_UNALIGNED_ADDRESS_FOR_EXCLUSIVE_WRITE                                   = 8'h70,
    AXI_UNALIGNED_ADDR_FOR_WRAPPING_READ_BURST                                  = 8'h71,
    AXI_UNALIGNED_ADDR_FOR_WRAPPING_WRITE_BURST                                 = 8'h72,
    AXI_WDATA_CHANGED_BEFORE_WREADY_ON_INVALID_LANE                             = 8'h73,
    AXI_WDATA_CHANGED_BEFORE_WREADY_ON_VALID_LANE                               = 8'h74,
    AXI_WLAST_CHANGED_BEFORE_WREADY                                             = 8'h75,
    AXI_WID_CHANGED_BEFORE_WREADY                                               = 8'h76,
    AXI_WLAST_UNKN                                                              = 8'h77,
    AXI_WID_UNKN                                                                = 8'h78,
    AXI_WREADY_UNKN                                                             = 8'h79,
    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_12                                   = 8'h7a,
    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_13                                   = 8'h7b,
    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_4                                    = 8'h7c,
    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_5                                    = 8'h7d,
    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_8                                    = 8'h7e,
    AXI_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_9                                    = 8'h7f,
    AXI_WRITE_BURST_SIZE_VIOLATION                                              = 8'h80,
    AXI_WRITE_DATA_BEFORE_ADDRESS                                               = 8'h81,
    AXI_WRITE_DATA_UNKN_ON_INVALID_LANE                                         = 8'h82,
    AXI_WRITE_DATA_UNKN_ON_VALID_LANE                                           = 8'h83,
    AXI_RESERVED_AWLOCK_ENCODING                                                = 8'h84,
    AXI_WRITE_STROBE_ON_INVALID_BYTE_LANES                                      = 8'h85,
    AXI_WSTRB_CHANGED_BEFORE_WREADY                                             = 8'h86,
    AXI_WSTRB_UNKN                                                              = 8'h87,
    AXI_WUSER_CHANGED_BEFORE_WREADY                                             = 8'h88,
    AXI_WUSER_UNKN                                                              = 8'h89,
    AXI_WVALID_DEASSERTED_BEFORE_WREADY                                         = 8'h8a,
    AXI_WVALID_HIGH_ON_FIRST_CLOCK_AFTER_RESET                                  = 8'h8b,
    AXI_WVALID_UNKN                                                             = 8'h8c,
    AXI_ADDR_ACROSS_4K_WITHIN_LOCKED_WRITE_TRANSACTION                          = 8'h8d,
    AXI_ADDR_ACROSS_4K_WITHIN_LOCKED_READ_TRANSACTION                           = 8'h8e,
    AXI_AWID_CHANGED_WITHIN_LOCKED_TRANSACTION                                  = 8'h8f,
    AXI_ARID_CHANGED_WITHIN_LOCKED_TRANSACTION                                  = 8'h90,
    AXI_AWPROT_CHANGED_WITHIN_LOCKED_TRANSACTION                                = 8'h91,
    AXI_ARPROT_CHANGED_WITHIN_LOCKED_TRANSACTION                                = 8'h92,
    AXI_AWCACHE_CHANGED_WITHIN_LOCKED_TRANSACTION                               = 8'h93,
    AXI_ARCACHE_CHANGED_WITHIN_LOCKED_TRANSACTION                               = 8'h94,
    AXI_NUMBER_OF_LOCKED_SEQUENCES_EXCEEDS_2                                    = 8'h95,
    AXI_LOCKED_WRITE_BEFORE_COMPLETION_OF_PREVIOUS_WRITE_TRANSACTIONS           = 8'h96,
    AXI_LOCKED_WRITE_BEFORE_COMPLETION_OF_PREVIOUS_READ_TRANSACTIONS            = 8'h97,
    AXI_LOCKED_READ_BEFORE_COMPLETION_OF_PREVIOUS_WRITE_TRANSACTIONS            = 8'h98,
    AXI_LOCKED_READ_BEFORE_COMPLETION_OF_PREVIOUS_READ_TRANSACTIONS             = 8'h99,
    AXI_NEW_BURST_BEFORE_COMPLETION_OF_UNLOCK_TRANSACTION                       = 8'h9a,
    AXI_UNLOCKED_WRITE_WHILE_OUTSTANDING_LOCKED_WRITES                          = 8'h9b,
    AXI_UNLOCKED_WRITE_WHILE_OUTSTANDING_LOCKED_READS                           = 8'h9c,
    AXI_UNLOCKED_READ_WHILE_OUTSTANDING_LOCKED_WRITES                           = 8'h9d,
    AXI_UNLOCKED_READ_WHILE_OUTSTANDING_LOCKED_READS                            = 8'h9e,
    AXI_UNLOCKING_TRANSACTION_WITH_AN_EXCLUSIVE_ACCESS                          = 8'h9f,
    AXI_FIRST_DATA_ITEM_OF_TRANSACTION_WRITE_ORDER_VIOLATION                    = 8'ha0,
    AXI_AWLEN_MISMATCHED_WITH_COMPLETED_WRITE_DATA_BURST                        = 8'ha1,
    AXI_WRITE_LENGTH_MISMATCHED_ACTUAL_LENGTH_OF_WRITE_DATA_BURST_EXCEEDS_AWLEN = 8'ha2,
    AXI_AWLEN_MISMATCHED_ACTUAL_LENGTH_OF_WRITE_DATA_BURST_EXCEEDS_AWLEN        = 8'ha3,
    AXI_WLAST_ASSERTED_DURING_DATA_PHASE_OTHER_THAN_LAST                        = 8'ha4,
    AXI_WRITE_INTERLEAVE_DEPTH_VIOLATION                                        = 8'ha5,
    AXI_WRITE_RESPONSE_WITHOUT_ADDR                                             = 8'ha6,
    AXI_WRITE_RESPONSE_WITHOUT_DATA                                             = 8'ha7,
    AXI_AWVALID_HIGH_DURING_RESET                                               = 8'ha8,
    AXI_WVALID_HIGH_DURING_RESET                                                = 8'ha9,
    AXI_BVALID_HIGH_DURING_RESET                                                = 8'haa,
    AXI_ARVALID_HIGH_DURING_RESET                                               = 8'hab,
    AXI_RVALID_HIGH_DURING_RESET                                                = 8'hac,
    AXI_RLAST_VIOLATION                                                         = 8'had,
    AXI_EX_WRITE_AFTER_EX_READ_FAILURE                                          = 8'hae,
    AXI_TIMEOUT_WAITING_FOR_WRITE_DATA                                          = 8'haf,
    AXI_TIMEOUT_WAITING_FOR_WRITE_RESPONSE                                      = 8'hb0,
    AXI_TIMEOUT_WAITING_FOR_READ_RESPONSE                                       = 8'hb1,
    AXI_TIMEOUT_WAITING_FOR_WRITE_ADDR_AFTER_DATA                               = 8'hb2,
    AXI_DEC_ERR_RESP_FOR_READ                                                   = 8'hb3,
    AXI_DEC_ERR_RESP_FOR_WRITE                                                  = 8'hb4,
    AXI_SLV_ERR_RESP_FOR_READ                                                   = 8'hb5,
    AXI_SLV_ERR_RESP_FOR_WRITE                                                  = 8'hb6,
    AXI_MINIMUM_SLAVE_ADDRESS_SPACE_VIOLATION                                   = 8'hb7,
    AXI_ADDRESS_WIDTH_EXCEEDS_64                                                = 8'hb8,
    AXI_READ_BURST_MAXIMUM_LENGTH_VIOLATION                                     = 8'hb9,
    AXI_WRITE_BURST_MAXIMUM_LENGTH_VIOLATION                                    = 8'hba,
    AXI_WRITE_STROBES_LENGTH_VIOLATION                                          = 8'hbb,
    AXI_EX_RD_WHEN_EX_NOT_ENABLED                                               = 8'hbc,
    AXI_EX_WR_WHEN_EX_NOT_ENABLED                                               = 8'hbd,
    AXI_WRITE_TRANSFER_EXCEEDS_ADDRESS_SPACE                                    = 8'hbe,
    AXI_READ_TRANSFER_EXCEEDS_ADDRESS_SPACE                                     = 8'hbf,
    AXI_EXCL_RD_WHILE_EXCL_WR_IN_PROGRESS_SAME_ID                               = 8'hc0,
    AXI_EXCL_WR_WHILE_EXCL_RD_IN_PROGRESS_SAME_ID                               = 8'hc1,
    AXI_ILLEGAL_LENGTH_READ_BURST                                               = 8'hc2,
    AXI_ILLEGAL_LENGTH_WRITE_BURST                                              = 8'hc3,
    AXI_ARREADY_NOT_ASSERTED_AFTER_ARVALID                                      = 8'hc4,
    AXI_BREADY_NOT_ASSERTED_AFTER_BVALID                                        = 8'hc5,
    AXI_AWREADY_NOT_ASSERTED_AFTER_AWVALID                                      = 8'hc6,
    AXI_RREADY_NOT_ASSERTED_AFTER_RVALID                                        = 8'hc7,
    AXI_WREADY_NOT_ASSERTED_AFTER_WVALID                                        = 8'hc8,
    AXI_DEC_ERR_ILLEGAL_FOR_MAPPED_SLAVE_ADDR                                   = 8'hc9,
    AXI_PARAM_READ_REORDERING_DEPTH_EQUALS_ZERO                                 = 8'hca,
    AXI_PARAM_READ_REORDERING_DEPTH_EXCEEDS_MAX_ID                              = 8'hcb,
    AXI_READ_REORDERING_VIOLATION                                               = 8'hcc
} axi_assertion_type_e;

//------------------------------------------------------------------------------
//
// CLASS: axi_interface_class
//     Abstract class which defines the API to the <axi> interface
//
//------------------------------------------------------------------------------
virtual class axi_interface_class #(int AXI_ADDRESS_WIDTH = 64, int AXI_RDATA_WIDTH = 1024, int AXI_WDATA_WIDTH = 1024, int AXI_ID_WIDTH = 18);

    //------------------------------------------------------------------------------
    // Tasks to wait for a number of specified edges on a wire
    //------------------------------------------------------------------------------

    //------------------------------------------------------------------------------
    // Function:- wait_for_ACLK
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ACLK>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ACLK( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARESETn
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARESETn>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARESETn( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWVALID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWVALID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWVALID( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWADDR
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWADDR>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWADDR( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWADDR_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWLEN
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWLEN>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWLEN( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWLEN_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWSIZE
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWSIZE>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWSIZE( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWSIZE_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWBURST
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWBURST>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWBURST( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWBURST_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWLOCK
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWLOCK>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWLOCK( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWLOCK_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWLOCK>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWLOCK_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWCACHE
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWCACHE>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWCACHE( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWCACHE_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWPROT
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWPROT>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWPROT( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWPROT_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWID( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWID_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWREADY
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWREADY>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWREADY( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWUSER
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWUSER>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWUSER( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWUSER_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARVALID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARVALID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARVALID( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARADDR
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARADDR>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARADDR( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARADDR_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARLEN
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARLEN>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARLEN( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARLEN_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARSIZE
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARSIZE>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARSIZE( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARSIZE_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARBURST
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARBURST>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARBURST( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARBURST_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARLOCK
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARLOCK>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARLOCK( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARLOCK_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARLOCK>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARLOCK_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARCACHE
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARCACHE>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARCACHE( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARCACHE_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARPROT
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARPROT>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARPROT( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARPROT_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARID( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARID_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARREADY
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARREADY>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARREADY( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARUSER
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARUSER>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARUSER( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARUSER_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RVALID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RVALID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RVALID( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RLAST
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RLAST>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RLAST( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RDATA
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RDATA>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RDATA( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RDATA_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RRESP
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RRESP>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RRESP( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RRESP_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RID( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RID_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RREADY
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RREADY>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RREADY( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RUSER
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RUSER>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RUSER( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RUSER_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_WVALID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WVALID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_WVALID( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_WLAST
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WLAST>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_WLAST( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_WDATA
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WDATA>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_WDATA( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_WDATA_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_WDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_WSTRB
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WSTRB>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_WSTRB( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_WSTRB_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WSTRB>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_WSTRB_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_WID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_WID( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_WID_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_WID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_WREADY
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WREADY>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_WREADY( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_WUSER
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WUSER>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_WUSER( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_WUSER_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_WUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_BVALID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::BVALID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_BVALID( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_BRESP
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::BRESP>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_BRESP( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_BRESP_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::BRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_BRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_BID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::BID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_BID( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_BID_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::BID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_BID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_BREADY
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::BREADY>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_BREADY( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_BUSER
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::BUSER>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_BUSER( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_BUSER_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::BUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_BUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Tasks/functions to set/get wires
    //------------------------------------------------------------------------------

    //------------------------------------------------------------------------------
    // Function:- set_ACLK
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ACLK>.
    //
    // Parameters:
    //     ACLK_param - The value to set onto wire <axi::ACLK>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ACLK( logic ACLK_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ACLK
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ACLK>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ACLK>.
    //
    pure virtual function automatic logic get_ACLK(  );


    //------------------------------------------------------------------------------
    // Function:- set_ARESETn
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARESETn>.
    //
    // Parameters:
    //     ARESETn_param - The value to set onto wire <axi::ARESETn>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARESETn( logic ARESETn_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARESETn
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARESETn>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARESETn>.
    //
    pure virtual function automatic logic get_ARESETn(  );


    //------------------------------------------------------------------------------
    // Function:- set_AWVALID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWVALID>.
    //
    // Parameters:
    //     AWVALID_param - The value to set onto wire <axi::AWVALID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWVALID( logic AWVALID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWVALID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWVALID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWVALID>.
    //
    pure virtual function automatic logic get_AWVALID(  );


    //------------------------------------------------------------------------------
    // Function:- set_AWADDR
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWADDR>.
    //
    // Parameters:
    //     AWADDR_param - The value to set onto wire <axi::AWADDR>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWADDR( logic [((AXI_ADDRESS_WIDTH) - 1):0]  AWADDR_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_AWADDR_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::AWADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWADDR_param - The value to set onto wire <axi::AWADDR>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWADDR_index1( int _this_dot_1, logic  AWADDR_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWADDR
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWADDR>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWADDR>.
    //
    pure virtual function automatic logic [((AXI_ADDRESS_WIDTH) - 1):0]   get_AWADDR(  );

    //------------------------------------------------------------------------------
    // Function:- get_AWADDR_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::AWADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::AWADDR>.
    //
    pure virtual function automatic logic   get_AWADDR_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_AWLEN
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWLEN>.
    //
    // Parameters:
    //     AWLEN_param - The value to set onto wire <axi::AWLEN>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWLEN( logic [3:0] AWLEN_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_AWLEN_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::AWLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWLEN_param - The value to set onto wire <axi::AWLEN>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWLEN_index1( int _this_dot_1, logic  AWLEN_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWLEN
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWLEN>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWLEN>.
    //
    pure virtual function automatic logic [3:0]  get_AWLEN(  );

    //------------------------------------------------------------------------------
    // Function:- get_AWLEN_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::AWLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::AWLEN>.
    //
    pure virtual function automatic logic   get_AWLEN_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_AWSIZE
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWSIZE>.
    //
    // Parameters:
    //     AWSIZE_param - The value to set onto wire <axi::AWSIZE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWSIZE( logic [2:0] AWSIZE_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_AWSIZE_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::AWSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWSIZE_param - The value to set onto wire <axi::AWSIZE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWSIZE_index1( int _this_dot_1, logic  AWSIZE_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWSIZE
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWSIZE>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWSIZE>.
    //
    pure virtual function automatic logic [2:0]  get_AWSIZE(  );

    //------------------------------------------------------------------------------
    // Function:- get_AWSIZE_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::AWSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::AWSIZE>.
    //
    pure virtual function automatic logic   get_AWSIZE_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_AWBURST
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWBURST>.
    //
    // Parameters:
    //     AWBURST_param - The value to set onto wire <axi::AWBURST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWBURST( logic [1:0] AWBURST_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_AWBURST_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::AWBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWBURST_param - The value to set onto wire <axi::AWBURST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWBURST_index1( int _this_dot_1, logic  AWBURST_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWBURST
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWBURST>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWBURST>.
    //
    pure virtual function automatic logic [1:0]  get_AWBURST(  );

    //------------------------------------------------------------------------------
    // Function:- get_AWBURST_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::AWBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::AWBURST>.
    //
    pure virtual function automatic logic   get_AWBURST_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_AWLOCK
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWLOCK>.
    //
    // Parameters:
    //     AWLOCK_param - The value to set onto wire <axi::AWLOCK>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWLOCK( logic [1:0] AWLOCK_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_AWLOCK_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::AWLOCK>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWLOCK_param - The value to set onto wire <axi::AWLOCK>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWLOCK_index1( int _this_dot_1, logic  AWLOCK_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWLOCK
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWLOCK>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWLOCK>.
    //
    pure virtual function automatic logic [1:0]  get_AWLOCK(  );

    //------------------------------------------------------------------------------
    // Function:- get_AWLOCK_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::AWLOCK>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::AWLOCK>.
    //
    pure virtual function automatic logic   get_AWLOCK_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_AWCACHE
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWCACHE>.
    //
    // Parameters:
    //     AWCACHE_param - The value to set onto wire <axi::AWCACHE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWCACHE( logic [3:0] AWCACHE_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_AWCACHE_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::AWCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWCACHE_param - The value to set onto wire <axi::AWCACHE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWCACHE_index1( int _this_dot_1, logic  AWCACHE_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWCACHE
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWCACHE>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWCACHE>.
    //
    pure virtual function automatic logic [3:0]  get_AWCACHE(  );

    //------------------------------------------------------------------------------
    // Function:- get_AWCACHE_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::AWCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::AWCACHE>.
    //
    pure virtual function automatic logic   get_AWCACHE_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_AWPROT
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWPROT>.
    //
    // Parameters:
    //     AWPROT_param - The value to set onto wire <axi::AWPROT>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWPROT( logic [2:0] AWPROT_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_AWPROT_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::AWPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWPROT_param - The value to set onto wire <axi::AWPROT>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWPROT_index1( int _this_dot_1, logic  AWPROT_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWPROT
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWPROT>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWPROT>.
    //
    pure virtual function automatic logic [2:0]  get_AWPROT(  );

    //------------------------------------------------------------------------------
    // Function:- get_AWPROT_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::AWPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::AWPROT>.
    //
    pure virtual function automatic logic   get_AWPROT_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_AWID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWID>.
    //
    // Parameters:
    //     AWID_param - The value to set onto wire <axi::AWID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWID( logic [((AXI_ID_WIDTH) - 1):0]  AWID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_AWID_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::AWID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWID_param - The value to set onto wire <axi::AWID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWID_index1( int _this_dot_1, logic  AWID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWID>.
    //
    pure virtual function automatic logic [((AXI_ID_WIDTH) - 1):0]   get_AWID(  );

    //------------------------------------------------------------------------------
    // Function:- get_AWID_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::AWID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::AWID>.
    //
    pure virtual function automatic logic   get_AWID_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_AWREADY
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWREADY>.
    //
    // Parameters:
    //     AWREADY_param - The value to set onto wire <axi::AWREADY>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWREADY( logic AWREADY_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWREADY
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWREADY>.
    //
    pure virtual function automatic logic get_AWREADY(  );


    //------------------------------------------------------------------------------
    // Function:- set_AWUSER
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWUSER>.
    //
    // Parameters:
    //     AWUSER_param - The value to set onto wire <axi::AWUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWUSER( logic [7:0] AWUSER_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_AWUSER_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::AWUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWUSER_param - The value to set onto wire <axi::AWUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWUSER_index1( int _this_dot_1, logic  AWUSER_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWUSER
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWUSER>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWUSER>.
    //
    pure virtual function automatic logic [7:0]  get_AWUSER(  );

    //------------------------------------------------------------------------------
    // Function:- get_AWUSER_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::AWUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::AWUSER>.
    //
    pure virtual function automatic logic   get_AWUSER_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_ARVALID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARVALID>.
    //
    // Parameters:
    //     ARVALID_param - The value to set onto wire <axi::ARVALID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARVALID( logic ARVALID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARVALID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARVALID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARVALID>.
    //
    pure virtual function automatic logic get_ARVALID(  );


    //------------------------------------------------------------------------------
    // Function:- set_ARADDR
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARADDR>.
    //
    // Parameters:
    //     ARADDR_param - The value to set onto wire <axi::ARADDR>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARADDR( logic [((AXI_ADDRESS_WIDTH) - 1):0]  ARADDR_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_ARADDR_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::ARADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARADDR_param - The value to set onto wire <axi::ARADDR>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARADDR_index1( int _this_dot_1, logic  ARADDR_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARADDR
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARADDR>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARADDR>.
    //
    pure virtual function automatic logic [((AXI_ADDRESS_WIDTH) - 1):0]   get_ARADDR(  );

    //------------------------------------------------------------------------------
    // Function:- get_ARADDR_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::ARADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::ARADDR>.
    //
    pure virtual function automatic logic   get_ARADDR_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_ARLEN
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARLEN>.
    //
    // Parameters:
    //     ARLEN_param - The value to set onto wire <axi::ARLEN>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARLEN( logic [3:0] ARLEN_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_ARLEN_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::ARLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARLEN_param - The value to set onto wire <axi::ARLEN>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARLEN_index1( int _this_dot_1, logic  ARLEN_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARLEN
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARLEN>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARLEN>.
    //
    pure virtual function automatic logic [3:0]  get_ARLEN(  );

    //------------------------------------------------------------------------------
    // Function:- get_ARLEN_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::ARLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::ARLEN>.
    //
    pure virtual function automatic logic   get_ARLEN_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_ARSIZE
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARSIZE>.
    //
    // Parameters:
    //     ARSIZE_param - The value to set onto wire <axi::ARSIZE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARSIZE( logic [2:0] ARSIZE_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_ARSIZE_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::ARSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARSIZE_param - The value to set onto wire <axi::ARSIZE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARSIZE_index1( int _this_dot_1, logic  ARSIZE_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARSIZE
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARSIZE>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARSIZE>.
    //
    pure virtual function automatic logic [2:0]  get_ARSIZE(  );

    //------------------------------------------------------------------------------
    // Function:- get_ARSIZE_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::ARSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::ARSIZE>.
    //
    pure virtual function automatic logic   get_ARSIZE_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_ARBURST
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARBURST>.
    //
    // Parameters:
    //     ARBURST_param - The value to set onto wire <axi::ARBURST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARBURST( logic [1:0] ARBURST_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_ARBURST_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::ARBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARBURST_param - The value to set onto wire <axi::ARBURST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARBURST_index1( int _this_dot_1, logic  ARBURST_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARBURST
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARBURST>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARBURST>.
    //
    pure virtual function automatic logic [1:0]  get_ARBURST(  );

    //------------------------------------------------------------------------------
    // Function:- get_ARBURST_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::ARBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::ARBURST>.
    //
    pure virtual function automatic logic   get_ARBURST_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_ARLOCK
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARLOCK>.
    //
    // Parameters:
    //     ARLOCK_param - The value to set onto wire <axi::ARLOCK>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARLOCK( logic [1:0] ARLOCK_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_ARLOCK_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::ARLOCK>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARLOCK_param - The value to set onto wire <axi::ARLOCK>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARLOCK_index1( int _this_dot_1, logic  ARLOCK_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARLOCK
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARLOCK>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARLOCK>.
    //
    pure virtual function automatic logic [1:0]  get_ARLOCK(  );

    //------------------------------------------------------------------------------
    // Function:- get_ARLOCK_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::ARLOCK>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::ARLOCK>.
    //
    pure virtual function automatic logic   get_ARLOCK_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_ARCACHE
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARCACHE>.
    //
    // Parameters:
    //     ARCACHE_param - The value to set onto wire <axi::ARCACHE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARCACHE( logic [3:0] ARCACHE_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_ARCACHE_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::ARCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARCACHE_param - The value to set onto wire <axi::ARCACHE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARCACHE_index1( int _this_dot_1, logic  ARCACHE_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARCACHE
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARCACHE>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARCACHE>.
    //
    pure virtual function automatic logic [3:0]  get_ARCACHE(  );

    //------------------------------------------------------------------------------
    // Function:- get_ARCACHE_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::ARCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::ARCACHE>.
    //
    pure virtual function automatic logic   get_ARCACHE_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_ARPROT
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARPROT>.
    //
    // Parameters:
    //     ARPROT_param - The value to set onto wire <axi::ARPROT>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARPROT( logic [2:0] ARPROT_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_ARPROT_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::ARPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARPROT_param - The value to set onto wire <axi::ARPROT>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARPROT_index1( int _this_dot_1, logic  ARPROT_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARPROT
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARPROT>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARPROT>.
    //
    pure virtual function automatic logic [2:0]  get_ARPROT(  );

    //------------------------------------------------------------------------------
    // Function:- get_ARPROT_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::ARPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::ARPROT>.
    //
    pure virtual function automatic logic   get_ARPROT_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_ARID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARID>.
    //
    // Parameters:
    //     ARID_param - The value to set onto wire <axi::ARID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARID( logic [((AXI_ID_WIDTH) - 1):0]  ARID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_ARID_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::ARID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARID_param - The value to set onto wire <axi::ARID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARID_index1( int _this_dot_1, logic  ARID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARID>.
    //
    pure virtual function automatic logic [((AXI_ID_WIDTH) - 1):0]   get_ARID(  );

    //------------------------------------------------------------------------------
    // Function:- get_ARID_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::ARID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::ARID>.
    //
    pure virtual function automatic logic   get_ARID_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_ARREADY
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARREADY>.
    //
    // Parameters:
    //     ARREADY_param - The value to set onto wire <axi::ARREADY>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARREADY( logic ARREADY_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARREADY
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARREADY>.
    //
    pure virtual function automatic logic get_ARREADY(  );


    //------------------------------------------------------------------------------
    // Function:- set_ARUSER
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARUSER>.
    //
    // Parameters:
    //     ARUSER_param - The value to set onto wire <axi::ARUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARUSER( logic [7:0] ARUSER_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_ARUSER_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::ARUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARUSER_param - The value to set onto wire <axi::ARUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARUSER_index1( int _this_dot_1, logic  ARUSER_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARUSER
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARUSER>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARUSER>.
    //
    pure virtual function automatic logic [7:0]  get_ARUSER(  );

    //------------------------------------------------------------------------------
    // Function:- get_ARUSER_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::ARUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::ARUSER>.
    //
    pure virtual function automatic logic   get_ARUSER_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_RVALID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::RVALID>.
    //
    // Parameters:
    //     RVALID_param - The value to set onto wire <axi::RVALID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RVALID( logic RVALID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_RVALID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::RVALID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::RVALID>.
    //
    pure virtual function automatic logic get_RVALID(  );


    //------------------------------------------------------------------------------
    // Function:- set_RLAST
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::RLAST>.
    //
    // Parameters:
    //     RLAST_param - The value to set onto wire <axi::RLAST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RLAST( logic RLAST_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_RLAST
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::RLAST>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::RLAST>.
    //
    pure virtual function automatic logic get_RLAST(  );


    //------------------------------------------------------------------------------
    // Function:- set_RDATA
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::RDATA>.
    //
    // Parameters:
    //     RDATA_param - The value to set onto wire <axi::RDATA>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RDATA( logic [((AXI_RDATA_WIDTH) - 1):0]  RDATA_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_RDATA_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::RDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     RDATA_param - The value to set onto wire <axi::RDATA>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RDATA_index1( int _this_dot_1, logic  RDATA_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_RDATA
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::RDATA>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::RDATA>.
    //
    pure virtual function automatic logic [((AXI_RDATA_WIDTH) - 1):0]   get_RDATA(  );

    //------------------------------------------------------------------------------
    // Function:- get_RDATA_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::RDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::RDATA>.
    //
    pure virtual function automatic logic   get_RDATA_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_RRESP
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::RRESP>.
    //
    // Parameters:
    //     RRESP_param - The value to set onto wire <axi::RRESP>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RRESP( logic [1:0] RRESP_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_RRESP_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::RRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     RRESP_param - The value to set onto wire <axi::RRESP>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RRESP_index1( int _this_dot_1, logic  RRESP_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_RRESP
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::RRESP>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::RRESP>.
    //
    pure virtual function automatic logic [1:0]  get_RRESP(  );

    //------------------------------------------------------------------------------
    // Function:- get_RRESP_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::RRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::RRESP>.
    //
    pure virtual function automatic logic   get_RRESP_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_RID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::RID>.
    //
    // Parameters:
    //     RID_param - The value to set onto wire <axi::RID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RID( logic [((AXI_ID_WIDTH) - 1):0]  RID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_RID_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::RID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     RID_param - The value to set onto wire <axi::RID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RID_index1( int _this_dot_1, logic  RID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_RID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::RID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::RID>.
    //
    pure virtual function automatic logic [((AXI_ID_WIDTH) - 1):0]   get_RID(  );

    //------------------------------------------------------------------------------
    // Function:- get_RID_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::RID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::RID>.
    //
    pure virtual function automatic logic   get_RID_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_RREADY
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::RREADY>.
    //
    // Parameters:
    //     RREADY_param - The value to set onto wire <axi::RREADY>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RREADY( logic RREADY_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_RREADY
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::RREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::RREADY>.
    //
    pure virtual function automatic logic get_RREADY(  );


    //------------------------------------------------------------------------------
    // Function:- set_RUSER
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::RUSER>.
    //
    // Parameters:
    //     RUSER_param - The value to set onto wire <axi::RUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RUSER( logic [7:0] RUSER_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_RUSER_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::RUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     RUSER_param - The value to set onto wire <axi::RUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RUSER_index1( int _this_dot_1, logic  RUSER_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_RUSER
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::RUSER>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::RUSER>.
    //
    pure virtual function automatic logic [7:0]  get_RUSER(  );

    //------------------------------------------------------------------------------
    // Function:- get_RUSER_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::RUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::RUSER>.
    //
    pure virtual function automatic logic   get_RUSER_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_WVALID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::WVALID>.
    //
    // Parameters:
    //     WVALID_param - The value to set onto wire <axi::WVALID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_WVALID( logic WVALID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_WVALID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::WVALID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::WVALID>.
    //
    pure virtual function automatic logic get_WVALID(  );


    //------------------------------------------------------------------------------
    // Function:- set_WLAST
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::WLAST>.
    //
    // Parameters:
    //     WLAST_param - The value to set onto wire <axi::WLAST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_WLAST( logic WLAST_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_WLAST
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::WLAST>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::WLAST>.
    //
    pure virtual function automatic logic get_WLAST(  );


    //------------------------------------------------------------------------------
    // Function:- set_WDATA
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::WDATA>.
    //
    // Parameters:
    //     WDATA_param - The value to set onto wire <axi::WDATA>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_WDATA( logic [((AXI_WDATA_WIDTH) - 1):0]  WDATA_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_WDATA_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::WDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     WDATA_param - The value to set onto wire <axi::WDATA>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_WDATA_index1( int _this_dot_1, logic  WDATA_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_WDATA
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::WDATA>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::WDATA>.
    //
    pure virtual function automatic logic [((AXI_WDATA_WIDTH) - 1):0]   get_WDATA(  );

    //------------------------------------------------------------------------------
    // Function:- get_WDATA_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::WDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::WDATA>.
    //
    pure virtual function automatic logic   get_WDATA_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_WSTRB
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::WSTRB>.
    //
    // Parameters:
    //     WSTRB_param - The value to set onto wire <axi::WSTRB>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_WSTRB( logic [(((AXI_WDATA_WIDTH / 8)) - 1):0]  WSTRB_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_WSTRB_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::WSTRB>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     WSTRB_param - The value to set onto wire <axi::WSTRB>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_WSTRB_index1( int _this_dot_1, logic  WSTRB_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_WSTRB
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::WSTRB>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::WSTRB>.
    //
    pure virtual function automatic logic [(((AXI_WDATA_WIDTH / 8)) - 1):0]   get_WSTRB(  );

    //------------------------------------------------------------------------------
    // Function:- get_WSTRB_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::WSTRB>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::WSTRB>.
    //
    pure virtual function automatic logic   get_WSTRB_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_WID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::WID>.
    //
    // Parameters:
    //     WID_param - The value to set onto wire <axi::WID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_WID( logic [((AXI_ID_WIDTH) - 1):0]  WID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_WID_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::WID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     WID_param - The value to set onto wire <axi::WID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_WID_index1( int _this_dot_1, logic  WID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_WID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::WID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::WID>.
    //
    pure virtual function automatic logic [((AXI_ID_WIDTH) - 1):0]   get_WID(  );

    //------------------------------------------------------------------------------
    // Function:- get_WID_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::WID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::WID>.
    //
    pure virtual function automatic logic   get_WID_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_WREADY
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::WREADY>.
    //
    // Parameters:
    //     WREADY_param - The value to set onto wire <axi::WREADY>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_WREADY( logic WREADY_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_WREADY
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::WREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::WREADY>.
    //
    pure virtual function automatic logic get_WREADY(  );


    //------------------------------------------------------------------------------
    // Function:- set_WUSER
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::WUSER>.
    //
    // Parameters:
    //     WUSER_param - The value to set onto wire <axi::WUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_WUSER( logic [7:0] WUSER_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_WUSER_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::WUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     WUSER_param - The value to set onto wire <axi::WUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_WUSER_index1( int _this_dot_1, logic  WUSER_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_WUSER
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::WUSER>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::WUSER>.
    //
    pure virtual function automatic logic [7:0]  get_WUSER(  );

    //------------------------------------------------------------------------------
    // Function:- get_WUSER_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::WUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::WUSER>.
    //
    pure virtual function automatic logic   get_WUSER_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_BVALID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::BVALID>.
    //
    // Parameters:
    //     BVALID_param - The value to set onto wire <axi::BVALID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_BVALID( logic BVALID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_BVALID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::BVALID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::BVALID>.
    //
    pure virtual function automatic logic get_BVALID(  );


    //------------------------------------------------------------------------------
    // Function:- set_BRESP
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::BRESP>.
    //
    // Parameters:
    //     BRESP_param - The value to set onto wire <axi::BRESP>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_BRESP( logic [1:0] BRESP_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_BRESP_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::BRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     BRESP_param - The value to set onto wire <axi::BRESP>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_BRESP_index1( int _this_dot_1, logic  BRESP_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_BRESP
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::BRESP>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::BRESP>.
    //
    pure virtual function automatic logic [1:0]  get_BRESP(  );

    //------------------------------------------------------------------------------
    // Function:- get_BRESP_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::BRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::BRESP>.
    //
    pure virtual function automatic logic   get_BRESP_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_BID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::BID>.
    //
    // Parameters:
    //     BID_param - The value to set onto wire <axi::BID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_BID( logic [((AXI_ID_WIDTH) - 1):0]  BID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_BID_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::BID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     BID_param - The value to set onto wire <axi::BID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_BID_index1( int _this_dot_1, logic  BID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_BID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::BID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::BID>.
    //
    pure virtual function automatic logic [((AXI_ID_WIDTH) - 1):0]   get_BID(  );

    //------------------------------------------------------------------------------
    // Function:- get_BID_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::BID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::BID>.
    //
    pure virtual function automatic logic   get_BID_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_BREADY
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::BREADY>.
    //
    // Parameters:
    //     BREADY_param - The value to set onto wire <axi::BREADY>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_BREADY( logic BREADY_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_BREADY
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::BREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::BREADY>.
    //
    pure virtual function automatic logic get_BREADY(  );


    //------------------------------------------------------------------------------
    // Function:- set_BUSER
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::BUSER>.
    //
    // Parameters:
    //     BUSER_param - The value to set onto wire <axi::BUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_BUSER( logic [7:0] BUSER_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_BUSER_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::BUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     BUSER_param - The value to set onto wire <axi::BUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_BUSER_index1( int _this_dot_1, logic  BUSER_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_BUSER
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::BUSER>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::BUSER>.
    //
    pure virtual function automatic logic [7:0]  get_BUSER(  );

    //------------------------------------------------------------------------------
    // Function:- get_BUSER_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::BUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::BUSER>.
    //
    pure virtual function automatic logic   get_BUSER_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Tasks to wait for a change to a global variable with read access
    //------------------------------------------------------------------------------

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_clk_init_value
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_clk_init_value>.
    //
    pure virtual task automatic wait_for_config_clk_init_value(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_clk_phase_shift
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_clk_phase_shift>.
    //
    pure virtual task automatic wait_for_config_clk_phase_shift(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_clk_1st_time
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_clk_1st_time>.
    //
    pure virtual task automatic wait_for_config_clk_1st_time(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_clk_2nd_time
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_clk_2nd_time>.
    //
    pure virtual task automatic wait_for_config_clk_2nd_time(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_setup_time
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_setup_time>.
    //
    pure virtual task automatic wait_for_config_setup_time(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_hold_time
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_hold_time>.
    //
    pure virtual task automatic wait_for_config_hold_time(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_transaction_time_factor
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_max_transaction_time_factor>.
    //
    pure virtual task automatic wait_for_config_max_transaction_time_factor(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_timeout_max_data_transfer
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_timeout_max_data_transfer>.
    //
    pure virtual task automatic wait_for_config_timeout_max_data_transfer(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_burst_timeout_factor
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_burst_timeout_factor>.
    //
    pure virtual task automatic wait_for_config_burst_timeout_factor(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_latency_AWVALID_assertion_to_AWREADY
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_max_latency_AWVALID_assertion_to_AWREADY>.
    //
    pure virtual task automatic wait_for_config_max_latency_AWVALID_assertion_to_AWREADY(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_latency_ARVALID_assertion_to_ARREADY
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_max_latency_ARVALID_assertion_to_ARREADY>.
    //
    pure virtual task automatic wait_for_config_max_latency_ARVALID_assertion_to_ARREADY(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_latency_RVALID_assertion_to_RREADY
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_max_latency_RVALID_assertion_to_RREADY>.
    //
    pure virtual task automatic wait_for_config_max_latency_RVALID_assertion_to_RREADY(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_latency_BVALID_assertion_to_BREADY
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_max_latency_BVALID_assertion_to_BREADY>.
    //
    pure virtual task automatic wait_for_config_max_latency_BVALID_assertion_to_BREADY(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_latency_WVALID_assertion_to_WREADY
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_max_latency_WVALID_assertion_to_WREADY>.
    //
    pure virtual task automatic wait_for_config_max_latency_WVALID_assertion_to_WREADY(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_write_ctrl_first_ratio
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_write_ctrl_first_ratio>.
    //
    pure virtual task automatic wait_for_config_write_ctrl_first_ratio(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_write_data_first_ratio
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_write_data_first_ratio>.
    //
    pure virtual task automatic wait_for_config_write_data_first_ratio(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_write_ctrl_to_data_mintime
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_write_ctrl_to_data_mintime>.
    //
    pure virtual task automatic wait_for_config_write_ctrl_to_data_mintime(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_write_data_to_ctrl_mintime
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_write_data_to_ctrl_mintime>.
    //
    pure virtual task automatic wait_for_config_write_data_to_ctrl_mintime(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_master_write_delay
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_master_write_delay>.
    //
    pure virtual task automatic wait_for_config_master_write_delay(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_reset_low_clocks
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_reset_low_clocks>.
    //
    pure virtual task automatic wait_for_config_reset_low_clocks(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_reset_hold_time
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_reset_hold_time>.
    //
    pure virtual task automatic wait_for_config_reset_hold_time(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_protect_ready
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_protect_ready>.
    //
    pure virtual task automatic wait_for_config_protect_ready(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_user_sideband
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_user_sideband>.
    //
    pure virtual task automatic wait_for_config_enable_user_sideband(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_extended_length_enable
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_extended_length_enable>.
    //
    pure virtual task automatic wait_for_config_extended_length_enable(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_burst_reserved_value
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_burst_reserved_value>.
    //
    pure virtual task automatic wait_for_config_enable_burst_reserved_value(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_lock_reserved_value
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_lock_reserved_value>.
    //
    pure virtual task automatic wait_for_config_enable_lock_reserved_value(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_cache_reserved_value
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_cache_reserved_value>.
    //
    pure virtual task automatic wait_for_config_enable_cache_reserved_value(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_all_assertions
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_all_assertions>.
    //
    pure virtual task automatic wait_for_config_enable_all_assertions(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_assertion
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_assertion>.
    //
    pure virtual task automatic wait_for_config_enable_assertion(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_assertion_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_assertion>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_config_enable_assertion_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_error
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_error>.
    //
    pure virtual task automatic wait_for_config_enable_error(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_error_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_error>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_config_enable_error_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_errors
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_errors>.
    //
    pure virtual task automatic wait_for_config_enable_errors(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_all_assertion_errors
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_all_assertion_errors>.
    //
    pure virtual task automatic wait_for_config_enable_all_assertion_errors(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_abstraction_level
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_abstraction_level>.
    //
    pure virtual task automatic wait_for_config_abstraction_level(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_start_addr
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_slave_start_addr>.
    //
    pure virtual task automatic wait_for_config_slave_start_addr(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_start_addr_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_slave_start_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_config_slave_start_addr_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_end_addr
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_slave_end_addr>.
    //
    pure virtual task automatic wait_for_config_slave_end_addr(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_end_addr_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_slave_end_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_config_slave_end_addr_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_slave_addr_range_in_bfm
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_slave_addr_range_in_bfm>.
    //
    pure virtual task automatic wait_for_config_enable_slave_addr_range_in_bfm(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_read_data_reordering_depth
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_read_data_reordering_depth>.
    //
    pure virtual task automatic wait_for_config_read_data_reordering_depth(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_read_data_reordering_depth_in_bfm
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_read_data_reordering_depth_in_bfm>.
    //
    pure virtual task automatic wait_for_config_enable_read_data_reordering_depth_in_bfm(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_awid_wid_mismatch
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_awid_wid_mismatch>.
    //
    pure virtual task automatic wait_for_config_awid_wid_mismatch(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_length_last_mismatch_error
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_length_last_mismatch_error>.
    //
    pure virtual task automatic wait_for_config_length_last_mismatch_error(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_master_error_position
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_master_error_position>.
    //
    pure virtual task automatic wait_for_config_master_error_position(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_dummy_var
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::dummy_var>.
    //
    pure virtual task automatic wait_for_dummy_var(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_wlast_length
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_wlast_length>.
    //
    pure virtual task automatic wait_for_config_wlast_length(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_wid_for_awid_not_matching
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_wid_for_awid_not_matching>.
    //
    pure virtual task automatic wait_for_config_wid_for_awid_not_matching(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_wid_for_awid_not_matching_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_wid_for_awid_not_matching>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_config_wid_for_awid_not_matching_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_support_exclusive_access
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_support_exclusive_access>.
    //
    pure virtual task automatic wait_for_config_support_exclusive_access(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_write_data_interleaving_depth
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_write_data_interleaving_depth>.
    //
    pure virtual task automatic wait_for_config_write_data_interleaving_depth(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_status_master_error
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::status_master_error>.
    //
    pure virtual task automatic wait_for_status_master_error(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_status_master_error_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::status_master_error>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_status_master_error_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_status_num_reads_waiting_for_resp
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::status_num_reads_waiting_for_resp>.
    //
    pure virtual task automatic wait_for_status_num_reads_waiting_for_resp(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_status_num_writes_waiting_for_response
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::status_num_writes_waiting_for_response>.
    //
    pure virtual task automatic wait_for_status_num_writes_waiting_for_response(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_check_total_num_wdata_outstanding
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::check_total_num_wdata_outstanding>.
    //
    pure virtual task automatic wait_for_check_total_num_wdata_outstanding(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_total_num_wdata_outstanding
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::total_num_wdata_outstanding>.
    //
    pure virtual task automatic wait_for_total_num_wdata_outstanding(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_check_max_num_wdata_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::check_max_num_wdata_outstanding_per_id>.
    //
    pure virtual task automatic wait_for_check_max_num_wdata_outstanding_per_id(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_max_num_wdata_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::max_num_wdata_outstanding_per_id>.
    //
    pure virtual task automatic wait_for_max_num_wdata_outstanding_per_id(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_check_max_num_waddr_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::check_max_num_waddr_outstanding_per_id>.
    //
    pure virtual task automatic wait_for_check_max_num_waddr_outstanding_per_id(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_max_num_waddr_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::max_num_waddr_outstanding_per_id>.
    //
    pure virtual task automatic wait_for_max_num_waddr_outstanding_per_id(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_check_total_num_waddr_outstanding
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::check_total_num_waddr_outstanding>.
    //
    pure virtual task automatic wait_for_check_total_num_waddr_outstanding(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_total_num_waddr_outstanding
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::total_num_waddr_outstanding>.
    //
    pure virtual task automatic wait_for_total_num_waddr_outstanding(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_status_outstanding_num_for_waddr
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::status_outstanding_num_for_waddr>.
    //
    pure virtual task automatic wait_for_status_outstanding_num_for_waddr(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_start_finding_outstanding_waddr
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::start_finding_outstanding_waddr>.
    //
    pure virtual task automatic wait_for_start_finding_outstanding_waddr(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_status_outstanding_num_for_wdata
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::status_outstanding_num_for_wdata>.
    //
    pure virtual task automatic wait_for_status_outstanding_num_for_wdata(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_start_finding_outstanding_wdata
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::start_finding_outstanding_wdata>.
    //
    pure virtual task automatic wait_for_start_finding_outstanding_wdata(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_find_waddr_outstanding_for_wid
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::find_waddr_outstanding_for_wid>.
    //
    pure virtual task automatic wait_for_find_waddr_outstanding_for_wid(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_find_waddr_outstanding_for_wid_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::find_waddr_outstanding_for_wid>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_find_waddr_outstanding_for_wid_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_find_wdata_outstanding_for_wid
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::find_wdata_outstanding_for_wid>.
    //
    pure virtual task automatic wait_for_find_wdata_outstanding_for_wid(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_find_wdata_outstanding_for_wid_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::find_wdata_outstanding_for_wid>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_find_wdata_outstanding_for_wid_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_change_in_wdata_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::change_in_wdata_outstanding_per_id>.
    //
    pure virtual task automatic wait_for_change_in_wdata_outstanding_per_id(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_start_finding_change_in_wdata
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::start_finding_change_in_wdata>.
    //
    pure virtual task automatic wait_for_start_finding_change_in_wdata(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_find_change_in_wdata_outstanding_for_wid
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::find_change_in_wdata_outstanding_for_wid>.
    //
    pure virtual task automatic wait_for_find_change_in_wdata_outstanding_for_wid(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_find_change_in_wdata_outstanding_for_wid_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::find_change_in_wdata_outstanding_for_wid>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_find_change_in_wdata_outstanding_for_wid_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_outstanding_wr
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_max_outstanding_wr>.
    //
    pure virtual task automatic wait_for_config_max_outstanding_wr(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_outstanding_rd
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_max_outstanding_rd>.
    //
    pure virtual task automatic wait_for_config_max_outstanding_rd(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_error_on_deleted_valid_cycles
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_error_on_deleted_valid_cycles>.
    //
    pure virtual task automatic wait_for_config_error_on_deleted_valid_cycles(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable>.
    //
    pure virtual task automatic wait_for_config_stats_enable(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_AXI_read_occupancy
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_AXI_read_occupancy>.
    //
    pure virtual task automatic wait_for_config_stats_enable_AXI_read_occupancy(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_AXI_write_occupancy
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_AXI_write_occupancy>.
    //
    pure virtual task automatic wait_for_config_stats_enable_AXI_write_occupancy(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_data_occupancy
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_read_data_occupancy>.
    //
    pure virtual task automatic wait_for_config_stats_enable_read_data_occupancy(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_data_occupancy
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_write_data_occupancy>.
    //
    pure virtual task automatic wait_for_config_stats_enable_write_data_occupancy(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_latency
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_read_latency>.
    //
    pure virtual task automatic wait_for_config_stats_enable_read_latency(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_latency
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_write_latency>.
    //
    pure virtual task automatic wait_for_config_stats_enable_write_latency(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_address_waits
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_read_address_waits>.
    //
    pure virtual task automatic wait_for_config_stats_enable_read_address_waits(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_data_waits
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_read_data_waits>.
    //
    pure virtual task automatic wait_for_config_stats_enable_read_data_waits(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_address_waits
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_write_address_waits>.
    //
    pure virtual task automatic wait_for_config_stats_enable_write_address_waits(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_data_waits
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_write_data_waits>.
    //
    pure virtual task automatic wait_for_config_stats_enable_write_data_waits(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_response_waits
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_write_response_waits>.
    //
    pure virtual task automatic wait_for_config_stats_enable_write_response_waits(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_bandwidth
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_read_bandwidth>.
    //
    pure virtual task automatic wait_for_config_stats_enable_read_bandwidth(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_bandwidth
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_write_bandwidth>.
    //
    pure virtual task automatic wait_for_config_stats_enable_write_bandwidth(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_AXI_read_occupancy_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_AXI_read_occupancy_step>.
    //
    pure virtual task automatic wait_for_config_stats_AXI_read_occupancy_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_AXI_read_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_AXI_read_occupancy_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_AXI_read_occupancy_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_active
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_active>.
    //
    pure virtual task automatic wait_for_stats_AXI_read_active(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_occupancy_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_occupancy_sw>.
    //
    pure virtual task automatic wait_for_stats_AXI_read_occupancy_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_occupancy_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_occupancy_sw_updated>.
    //
    pure virtual task automatic wait_for_stats_AXI_read_occupancy_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_idle_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_idle_sw>.
    //
    pure virtual task automatic wait_for_stats_AXI_read_idle_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_occupancy_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_occupancy_min>.
    //
    pure virtual task automatic wait_for_stats_AXI_read_occupancy_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_idle_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_idle_min>.
    //
    pure virtual task automatic wait_for_stats_AXI_read_idle_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_occupancy_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_occupancy_max>.
    //
    pure virtual task automatic wait_for_stats_AXI_read_occupancy_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_idle_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_idle_max>.
    //
    pure virtual task automatic wait_for_stats_AXI_read_idle_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_occupancy_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_occupancy_mean>.
    //
    pure virtual task automatic wait_for_stats_AXI_read_occupancy_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_idle_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_idle_mean>.
    //
    pure virtual task automatic wait_for_stats_AXI_read_idle_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_AXI_write_occupancy_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_AXI_write_occupancy_step>.
    //
    pure virtual task automatic wait_for_config_stats_AXI_write_occupancy_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_AXI_write_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_AXI_write_occupancy_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_AXI_write_occupancy_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_active
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_active>.
    //
    pure virtual task automatic wait_for_stats_AXI_write_active(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_occupancy_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_occupancy_sw>.
    //
    pure virtual task automatic wait_for_stats_AXI_write_occupancy_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_occupancy_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_occupancy_sw_updated>.
    //
    pure virtual task automatic wait_for_stats_AXI_write_occupancy_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_idle_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_idle_sw>.
    //
    pure virtual task automatic wait_for_stats_AXI_write_idle_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_occupancy_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_occupancy_min>.
    //
    pure virtual task automatic wait_for_stats_AXI_write_occupancy_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_idle_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_idle_min>.
    //
    pure virtual task automatic wait_for_stats_AXI_write_idle_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_occupancy_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_occupancy_max>.
    //
    pure virtual task automatic wait_for_stats_AXI_write_occupancy_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_idle_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_idle_max>.
    //
    pure virtual task automatic wait_for_stats_AXI_write_idle_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_occupancy_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_occupancy_mean>.
    //
    pure virtual task automatic wait_for_stats_AXI_write_occupancy_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_idle_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_idle_mean>.
    //
    pure virtual task automatic wait_for_stats_AXI_write_idle_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_read_data_occupancy_step>.
    //
    pure virtual task automatic wait_for_config_stats_read_data_occupancy_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_read_data_occupancy_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_read_data_occupancy_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_occupancy_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_occupancy_sw>.
    //
    pure virtual task automatic wait_for_stats_read_data_occupancy_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_occupancy_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_occupancy_sw_updated>.
    //
    pure virtual task automatic wait_for_stats_read_data_occupancy_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_idle_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_idle_sw>.
    //
    pure virtual task automatic wait_for_stats_read_data_idle_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_occupancy_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_occupancy_min>.
    //
    pure virtual task automatic wait_for_stats_read_data_occupancy_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_idle_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_idle_min>.
    //
    pure virtual task automatic wait_for_stats_read_data_idle_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_occupancy_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_occupancy_max>.
    //
    pure virtual task automatic wait_for_stats_read_data_occupancy_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_idle_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_idle_max>.
    //
    pure virtual task automatic wait_for_stats_read_data_idle_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_occupancy_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_occupancy_mean>.
    //
    pure virtual task automatic wait_for_stats_read_data_occupancy_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_idle_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_idle_mean>.
    //
    pure virtual task automatic wait_for_stats_read_data_idle_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_data_occupancy_step>.
    //
    pure virtual task automatic wait_for_config_stats_write_data_occupancy_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_data_occupancy_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_write_data_occupancy_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_occupancy_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_occupancy_sw>.
    //
    pure virtual task automatic wait_for_stats_write_data_occupancy_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_occupancy_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_occupancy_sw_updated>.
    //
    pure virtual task automatic wait_for_stats_write_data_occupancy_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_idle_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_idle_sw>.
    //
    pure virtual task automatic wait_for_stats_write_data_idle_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_occupancy_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_occupancy_min>.
    //
    pure virtual task automatic wait_for_stats_write_data_occupancy_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_idle_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_idle_min>.
    //
    pure virtual task automatic wait_for_stats_write_data_idle_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_occupancy_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_occupancy_max>.
    //
    pure virtual task automatic wait_for_stats_write_data_occupancy_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_idle_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_idle_max>.
    //
    pure virtual task automatic wait_for_stats_write_data_idle_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_occupancy_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_occupancy_mean>.
    //
    pure virtual task automatic wait_for_stats_write_data_occupancy_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_idle_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_idle_mean>.
    //
    pure virtual task automatic wait_for_stats_write_data_idle_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_bandwidth_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_read_bandwidth_step>.
    //
    pure virtual task automatic wait_for_config_stats_read_bandwidth_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_read_bandwidth_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_read_bandwidth_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_bandwidth_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_bandwidth_sw>.
    //
    pure virtual task automatic wait_for_stats_read_bandwidth_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_bandwidth_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_bandwidth_sw_updated>.
    //
    pure virtual task automatic wait_for_stats_read_bandwidth_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_bandwidth_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_bandwidth_min>.
    //
    pure virtual task automatic wait_for_stats_read_bandwidth_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_bandwidth_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_bandwidth_max>.
    //
    pure virtual task automatic wait_for_stats_read_bandwidth_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_bandwidth_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_bandwidth_mean>.
    //
    pure virtual task automatic wait_for_stats_read_bandwidth_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_bandwidth_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_bandwidth_step>.
    //
    pure virtual task automatic wait_for_config_stats_write_bandwidth_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_bandwidth_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_write_bandwidth_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_bandwidth_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_bandwidth_sw>.
    //
    pure virtual task automatic wait_for_stats_write_bandwidth_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_bandwidth_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_bandwidth_sw_updated>.
    //
    pure virtual task automatic wait_for_stats_write_bandwidth_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_bandwidth_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_bandwidth_min>.
    //
    pure virtual task automatic wait_for_stats_write_bandwidth_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_bandwidth_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_bandwidth_max>.
    //
    pure virtual task automatic wait_for_stats_write_bandwidth_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_bandwidth_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_bandwidth_mean>.
    //
    pure virtual task automatic wait_for_stats_write_bandwidth_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_latency_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_read_latency_step>.
    //
    pure virtual task automatic wait_for_config_stats_read_latency_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_latency_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_read_latency_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_read_latency_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_latency_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_latency_sw_updated>.
    //
    pure virtual task automatic wait_for_stats_read_latency_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_data_latency_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_data_latency_inst>.
    //
    pure virtual task automatic wait_for_stats_read_address_data_latency_inst(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_data_latency_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_data_latency_sw>.
    //
    pure virtual task automatic wait_for_stats_read_address_data_latency_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_data_latency_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_data_latency_min>.
    //
    pure virtual task automatic wait_for_stats_read_address_data_latency_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_data_latency_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_data_latency_max>.
    //
    pure virtual task automatic wait_for_stats_read_address_data_latency_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_data_latency_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_data_latency_mean>.
    //
    pure virtual task automatic wait_for_stats_read_address_data_latency_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_address_latency_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_address_latency_inst>.
    //
    pure virtual task automatic wait_for_stats_read_address_address_latency_inst(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_address_latency_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_address_latency_sw>.
    //
    pure virtual task automatic wait_for_stats_read_address_address_latency_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_address_latency_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_address_latency_min>.
    //
    pure virtual task automatic wait_for_stats_read_address_address_latency_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_address_latency_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_address_latency_max>.
    //
    pure virtual task automatic wait_for_stats_read_address_address_latency_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_address_latency_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_address_latency_mean>.
    //
    pure virtual task automatic wait_for_stats_read_address_address_latency_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_latency_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_latency_step>.
    //
    pure virtual task automatic wait_for_config_stats_write_latency_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_latency_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_latency_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_write_latency_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_latency_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_latency_sw_updated>.
    //
    pure virtual task automatic wait_for_stats_write_latency_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_data_latency_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_data_latency_inst>.
    //
    pure virtual task automatic wait_for_stats_write_address_data_latency_inst(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_data_latency_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_data_latency_sw>.
    //
    pure virtual task automatic wait_for_stats_write_address_data_latency_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_data_latency_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_data_latency_min>.
    //
    pure virtual task automatic wait_for_stats_write_address_data_latency_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_data_latency_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_data_latency_max>.
    //
    pure virtual task automatic wait_for_stats_write_address_data_latency_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_data_latency_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_data_latency_mean>.
    //
    pure virtual task automatic wait_for_stats_write_address_data_latency_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_response_latency_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_response_latency_inst>.
    //
    pure virtual task automatic wait_for_stats_write_data_response_latency_inst(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_response_latency_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_response_latency_sw>.
    //
    pure virtual task automatic wait_for_stats_write_data_response_latency_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_response_latency_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_response_latency_min>.
    //
    pure virtual task automatic wait_for_stats_write_data_response_latency_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_response_latency_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_response_latency_max>.
    //
    pure virtual task automatic wait_for_stats_write_data_response_latency_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_response_latency_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_response_latency_mean>.
    //
    pure virtual task automatic wait_for_stats_write_data_response_latency_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_address_latency_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_address_latency_inst>.
    //
    pure virtual task automatic wait_for_stats_write_address_address_latency_inst(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_address_latency_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_address_latency_sw>.
    //
    pure virtual task automatic wait_for_stats_write_address_address_latency_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_address_latency_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_address_latency_min>.
    //
    pure virtual task automatic wait_for_stats_write_address_address_latency_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_address_latency_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_address_latency_max>.
    //
    pure virtual task automatic wait_for_stats_write_address_address_latency_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_address_latency_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_address_latency_mean>.
    //
    pure virtual task automatic wait_for_stats_write_address_address_latency_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_address_waits_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_read_address_waits_step>.
    //
    pure virtual task automatic wait_for_config_stats_read_address_waits_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_read_address_waits_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_read_address_waits_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_waits_inst>.
    //
    pure virtual task automatic wait_for_stats_read_address_waits_inst(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_waits_sw>.
    //
    pure virtual task automatic wait_for_stats_read_address_waits_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_waits_sw_updated>.
    //
    pure virtual task automatic wait_for_stats_read_address_waits_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_waits_min>.
    //
    pure virtual task automatic wait_for_stats_read_address_waits_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_waits_max>.
    //
    pure virtual task automatic wait_for_stats_read_address_waits_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_waits_mean>.
    //
    pure virtual task automatic wait_for_stats_read_address_waits_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_data_waits_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_read_data_waits_step>.
    //
    pure virtual task automatic wait_for_config_stats_read_data_waits_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_read_data_waits_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_read_data_waits_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_waits_inst>.
    //
    pure virtual task automatic wait_for_stats_read_data_waits_inst(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_waits_sw>.
    //
    pure virtual task automatic wait_for_stats_read_data_waits_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_waits_sw_updated>.
    //
    pure virtual task automatic wait_for_stats_read_data_waits_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_waits_min>.
    //
    pure virtual task automatic wait_for_stats_read_data_waits_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_waits_max>.
    //
    pure virtual task automatic wait_for_stats_read_data_waits_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_waits_mean>.
    //
    pure virtual task automatic wait_for_stats_read_data_waits_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_address_waits_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_address_waits_step>.
    //
    pure virtual task automatic wait_for_config_stats_write_address_waits_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_address_waits_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_write_address_waits_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_waits_inst>.
    //
    pure virtual task automatic wait_for_stats_write_address_waits_inst(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_waits_sw>.
    //
    pure virtual task automatic wait_for_stats_write_address_waits_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_waits_sw_updated>.
    //
    pure virtual task automatic wait_for_stats_write_address_waits_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_waits_min>.
    //
    pure virtual task automatic wait_for_stats_write_address_waits_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_waits_max>.
    //
    pure virtual task automatic wait_for_stats_write_address_waits_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_waits_mean>.
    //
    pure virtual task automatic wait_for_stats_write_address_waits_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_data_waits_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_data_waits_step>.
    //
    pure virtual task automatic wait_for_config_stats_write_data_waits_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_data_waits_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_write_data_waits_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_waits_inst>.
    //
    pure virtual task automatic wait_for_stats_write_data_waits_inst(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_waits_sw>.
    //
    pure virtual task automatic wait_for_stats_write_data_waits_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_waits_sw_updated>.
    //
    pure virtual task automatic wait_for_stats_write_data_waits_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_waits_min>.
    //
    pure virtual task automatic wait_for_stats_write_data_waits_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_waits_max>.
    //
    pure virtual task automatic wait_for_stats_write_data_waits_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_waits_mean>.
    //
    pure virtual task automatic wait_for_stats_write_data_waits_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_response_waits_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_response_waits_step>.
    //
    pure virtual task automatic wait_for_config_stats_write_response_waits_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_response_waits_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_response_waits_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_write_response_waits_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_response_waits_inst>.
    //
    pure virtual task automatic wait_for_stats_write_response_waits_inst(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_response_waits_sw>.
    //
    pure virtual task automatic wait_for_stats_write_response_waits_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_response_waits_sw_updated>.
    //
    pure virtual task automatic wait_for_stats_write_response_waits_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_response_waits_min>.
    //
    pure virtual task automatic wait_for_stats_write_response_waits_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_response_waits_max>.
    //
    pure virtual task automatic wait_for_stats_write_response_waits_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_response_waits_mean>.
    //
    pure virtual task automatic wait_for_stats_write_response_waits_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_rw_transaction_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_rw_transaction_last_duration>.
    //
    pure virtual task automatic wait_for_stats_rw_transaction_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_last_duration>.
    //
    pure virtual task automatic wait_for_stats_AXI_read_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_last_duration>.
    //
    pure virtual task automatic wait_for_stats_AXI_write_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_addr_channel_phase_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_addr_channel_phase_last_duration>.
    //
    pure virtual task automatic wait_for_stats_read_addr_channel_phase_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_burst_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_burst_last_duration>.
    //
    pure virtual task automatic wait_for_stats_read_data_burst_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_channel_phase_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_channel_phase_last_duration>.
    //
    pure virtual task automatic wait_for_stats_read_channel_phase_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_addr_channel_phase_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_addr_channel_phase_last_duration>.
    //
    pure virtual task automatic wait_for_stats_write_addr_channel_phase_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_burst_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_burst_last_duration>.
    //
    pure virtual task automatic wait_for_stats_write_data_burst_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_channel_phase_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_channel_phase_last_duration>.
    //
    pure virtual task automatic wait_for_stats_write_channel_phase_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_resp_channel_phase_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_resp_channel_phase_last_duration>.
    //
    pure virtual task automatic wait_for_stats_write_resp_channel_phase_last_duration(  );

    //------------------------------------------------------------------------------
    // Functions to set global variables with write access
    //------------------------------------------------------------------------------

    //------------------------------------------------------------------------------
    // Function:- set_config_clk_init_value
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_clk_init_value>.
    //
    // Parameters:
    //     config_clk_init_value_param - The value to assign to variable <axi::config_clk_init_value>.
    //
    pure virtual function automatic void set_config_clk_init_value( bit config_clk_init_value_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_clk_phase_shift
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_clk_phase_shift>.
    //
    // Parameters:
    //     config_clk_phase_shift_param - The value to assign to variable <axi::config_clk_phase_shift>.
    //
    pure virtual function automatic void set_config_clk_phase_shift( int config_clk_phase_shift_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_clk_1st_time
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_clk_1st_time>.
    //
    // Parameters:
    //     config_clk_1st_time_param - The value to assign to variable <axi::config_clk_1st_time>.
    //
    pure virtual function automatic void set_config_clk_1st_time( int config_clk_1st_time_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_clk_2nd_time
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_clk_2nd_time>.
    //
    // Parameters:
    //     config_clk_2nd_time_param - The value to assign to variable <axi::config_clk_2nd_time>.
    //
    pure virtual function automatic void set_config_clk_2nd_time( int config_clk_2nd_time_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_setup_time
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_setup_time>.
    //
    // Parameters:
    //     config_setup_time_param - The value to assign to variable <axi::config_setup_time>.
    //
    pure virtual function automatic void set_config_setup_time( int config_setup_time_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_hold_time
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_hold_time>.
    //
    // Parameters:
    //     config_hold_time_param - The value to assign to variable <axi::config_hold_time>.
    //
    pure virtual function automatic void set_config_hold_time( int config_hold_time_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_max_transaction_time_factor
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_max_transaction_time_factor>.
    //
    // Parameters:
    //     config_max_transaction_time_factor_param - The value to assign to variable <axi::config_max_transaction_time_factor>.
    //
    pure virtual function automatic void set_config_max_transaction_time_factor( int unsigned config_max_transaction_time_factor_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_timeout_max_data_transfer
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_timeout_max_data_transfer>.
    //
    // Parameters:
    //     config_timeout_max_data_transfer_param - The value to assign to variable <axi::config_timeout_max_data_transfer>.
    //
    pure virtual function automatic void set_config_timeout_max_data_transfer( int config_timeout_max_data_transfer_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_burst_timeout_factor
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_burst_timeout_factor>.
    //
    // Parameters:
    //     config_burst_timeout_factor_param - The value to assign to variable <axi::config_burst_timeout_factor>.
    //
    pure virtual function automatic void set_config_burst_timeout_factor( int unsigned config_burst_timeout_factor_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_max_latency_AWVALID_assertion_to_AWREADY
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_max_latency_AWVALID_assertion_to_AWREADY>.
    //
    // Parameters:
    //     config_max_latency_AWVALID_assertion_to_AWREADY_param - The value to assign to variable <axi::config_max_latency_AWVALID_assertion_to_AWREADY>.
    //
    pure virtual function automatic void set_config_max_latency_AWVALID_assertion_to_AWREADY( int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_max_latency_ARVALID_assertion_to_ARREADY
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_max_latency_ARVALID_assertion_to_ARREADY>.
    //
    // Parameters:
    //     config_max_latency_ARVALID_assertion_to_ARREADY_param - The value to assign to variable <axi::config_max_latency_ARVALID_assertion_to_ARREADY>.
    //
    pure virtual function automatic void set_config_max_latency_ARVALID_assertion_to_ARREADY( int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_max_latency_RVALID_assertion_to_RREADY
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_max_latency_RVALID_assertion_to_RREADY>.
    //
    // Parameters:
    //     config_max_latency_RVALID_assertion_to_RREADY_param - The value to assign to variable <axi::config_max_latency_RVALID_assertion_to_RREADY>.
    //
    pure virtual function automatic void set_config_max_latency_RVALID_assertion_to_RREADY( int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_max_latency_BVALID_assertion_to_BREADY
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_max_latency_BVALID_assertion_to_BREADY>.
    //
    // Parameters:
    //     config_max_latency_BVALID_assertion_to_BREADY_param - The value to assign to variable <axi::config_max_latency_BVALID_assertion_to_BREADY>.
    //
    pure virtual function automatic void set_config_max_latency_BVALID_assertion_to_BREADY( int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_max_latency_WVALID_assertion_to_WREADY
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_max_latency_WVALID_assertion_to_WREADY>.
    //
    // Parameters:
    //     config_max_latency_WVALID_assertion_to_WREADY_param - The value to assign to variable <axi::config_max_latency_WVALID_assertion_to_WREADY>.
    //
    pure virtual function automatic void set_config_max_latency_WVALID_assertion_to_WREADY( int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_write_ctrl_first_ratio
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_write_ctrl_first_ratio>.
    //
    // Parameters:
    //     config_write_ctrl_first_ratio_param - The value to assign to variable <axi::config_write_ctrl_first_ratio>.
    //
    pure virtual function automatic void set_config_write_ctrl_first_ratio( int config_write_ctrl_first_ratio_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_write_data_first_ratio
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_write_data_first_ratio>.
    //
    // Parameters:
    //     config_write_data_first_ratio_param - The value to assign to variable <axi::config_write_data_first_ratio>.
    //
    pure virtual function automatic void set_config_write_data_first_ratio( int config_write_data_first_ratio_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_write_ctrl_to_data_mintime
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_write_ctrl_to_data_mintime>.
    //
    // Parameters:
    //     config_write_ctrl_to_data_mintime_param - The value to assign to variable <axi::config_write_ctrl_to_data_mintime>.
    //
    pure virtual function automatic void set_config_write_ctrl_to_data_mintime( int unsigned config_write_ctrl_to_data_mintime_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_write_data_to_ctrl_mintime
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_write_data_to_ctrl_mintime>.
    //
    // Parameters:
    //     config_write_data_to_ctrl_mintime_param - The value to assign to variable <axi::config_write_data_to_ctrl_mintime>.
    //
    pure virtual function automatic void set_config_write_data_to_ctrl_mintime( int unsigned config_write_data_to_ctrl_mintime_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_master_write_delay
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_master_write_delay>.
    //
    // Parameters:
    //     config_master_write_delay_param - The value to assign to variable <axi::config_master_write_delay>.
    //
    pure virtual function automatic void set_config_master_write_delay( bit config_master_write_delay_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_reset_low_clocks
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_reset_low_clocks>.
    //
    // Parameters:
    //     config_reset_low_clocks_param - The value to assign to variable <axi::config_reset_low_clocks>.
    //
    pure virtual function automatic void set_config_reset_low_clocks( int config_reset_low_clocks_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_reset_hold_time
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_reset_hold_time>.
    //
    // Parameters:
    //     config_reset_hold_time_param - The value to assign to variable <axi::config_reset_hold_time>.
    //
    pure virtual function automatic void set_config_reset_hold_time( int config_reset_hold_time_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_protect_ready
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_protect_ready>.
    //
    // Parameters:
    //     config_protect_ready_param - The value to assign to variable <axi::config_protect_ready>.
    //
    pure virtual function automatic void set_config_protect_ready( bit config_protect_ready_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_user_sideband
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_user_sideband>.
    //
    // Parameters:
    //     config_enable_user_sideband_param - The value to assign to variable <axi::config_enable_user_sideband>.
    //
    pure virtual function automatic void set_config_enable_user_sideband( bit config_enable_user_sideband_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_extended_length_enable
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_extended_length_enable>.
    //
    // Parameters:
    //     config_extended_length_enable_param - The value to assign to variable <axi::config_extended_length_enable>.
    //
    pure virtual function automatic void set_config_extended_length_enable( bit config_extended_length_enable_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_burst_reserved_value
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_burst_reserved_value>.
    //
    // Parameters:
    //     config_enable_burst_reserved_value_param - The value to assign to variable <axi::config_enable_burst_reserved_value>.
    //
    pure virtual function automatic void set_config_enable_burst_reserved_value( bit config_enable_burst_reserved_value_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_lock_reserved_value
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_lock_reserved_value>.
    //
    // Parameters:
    //     config_enable_lock_reserved_value_param - The value to assign to variable <axi::config_enable_lock_reserved_value>.
    //
    pure virtual function automatic void set_config_enable_lock_reserved_value( bit config_enable_lock_reserved_value_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_cache_reserved_value
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_cache_reserved_value>.
    //
    // Parameters:
    //     config_enable_cache_reserved_value_param - The value to assign to variable <axi::config_enable_cache_reserved_value>.
    //
    pure virtual function automatic void set_config_enable_cache_reserved_value( bit config_enable_cache_reserved_value_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_all_assertions
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_all_assertions>.
    //
    // Parameters:
    //     config_enable_all_assertions_param - The value to assign to variable <axi::config_enable_all_assertions>.
    //
    pure virtual function automatic void set_config_enable_all_assertions( bit config_enable_all_assertions_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_assertion
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_assertion>.
    //
    // Parameters:
    //     config_enable_assertion_param - The value to assign to variable <axi::config_enable_assertion>.
    //
    pure virtual function automatic void set_config_enable_assertion( bit [255:0] config_enable_assertion_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_assertion_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi::config_enable_assertion>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_enable_assertion_param - The value to assign to variable <axi::config_enable_assertion>.
    //
    pure virtual function automatic void set_config_enable_assertion_index1( int _this_dot_1, bit  config_enable_assertion_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_error
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_error>.
    //
    // Parameters:
    //     config_enable_error_param - The value to assign to variable <axi::config_enable_error>.
    //
    pure virtual function automatic void set_config_enable_error( bit [255:0] config_enable_error_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_error_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi::config_enable_error>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_enable_error_param - The value to assign to variable <axi::config_enable_error>.
    //
    pure virtual function automatic void set_config_enable_error_index1( int _this_dot_1, bit  config_enable_error_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_errors
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_errors>.
    //
    // Parameters:
    //     config_enable_errors_param - The value to assign to variable <axi::config_enable_errors>.
    //
    pure virtual function automatic void set_config_enable_errors( bit config_enable_errors_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_all_assertion_errors
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_all_assertion_errors>.
    //
    // Parameters:
    //     config_enable_all_assertion_errors_param - The value to assign to variable <axi::config_enable_all_assertion_errors>.
    //
    pure virtual function automatic void set_config_enable_all_assertion_errors( bit config_enable_all_assertion_errors_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_abstraction_level
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_abstraction_level>.
    //
    // Parameters:
    //     config_abstraction_level_param - The value to assign to variable <axi::config_abstraction_level>.
    //
    pure virtual function automatic void set_config_abstraction_level( axi_abstraction_level_e config_abstraction_level_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_slave_start_addr
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_slave_start_addr>.
    //
    // Parameters:
    //     config_slave_start_addr_param - The value to assign to variable <axi::config_slave_start_addr>.
    //
    pure virtual function automatic void set_config_slave_start_addr( bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_slave_start_addr_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi::config_slave_start_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_slave_start_addr_param - The value to assign to variable <axi::config_slave_start_addr>.
    //
    pure virtual function automatic void set_config_slave_start_addr_index1( int _this_dot_1, bit  config_slave_start_addr_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_slave_end_addr
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_slave_end_addr>.
    //
    // Parameters:
    //     config_slave_end_addr_param - The value to assign to variable <axi::config_slave_end_addr>.
    //
    pure virtual function automatic void set_config_slave_end_addr( bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_slave_end_addr_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi::config_slave_end_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_slave_end_addr_param - The value to assign to variable <axi::config_slave_end_addr>.
    //
    pure virtual function automatic void set_config_slave_end_addr_index1( int _this_dot_1, bit  config_slave_end_addr_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_slave_addr_range_in_bfm
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_slave_addr_range_in_bfm>.
    //
    // Parameters:
    //     config_enable_slave_addr_range_in_bfm_param - The value to assign to variable <axi::config_enable_slave_addr_range_in_bfm>.
    //
    pure virtual function automatic void set_config_enable_slave_addr_range_in_bfm( bit config_enable_slave_addr_range_in_bfm_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_read_data_reordering_depth
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_read_data_reordering_depth>.
    //
    // Parameters:
    //     config_read_data_reordering_depth_param - The value to assign to variable <axi::config_read_data_reordering_depth>.
    //
    pure virtual function automatic void set_config_read_data_reordering_depth( int unsigned config_read_data_reordering_depth_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_read_data_reordering_depth_in_bfm
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_read_data_reordering_depth_in_bfm>.
    //
    // Parameters:
    //     config_enable_read_data_reordering_depth_in_bfm_param - The value to assign to variable <axi::config_enable_read_data_reordering_depth_in_bfm>.
    //
    pure virtual function automatic void set_config_enable_read_data_reordering_depth_in_bfm( bit config_enable_read_data_reordering_depth_in_bfm_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_awid_wid_mismatch
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_awid_wid_mismatch>.
    //
    // Parameters:
    //     config_awid_wid_mismatch_param - The value to assign to variable <axi::config_awid_wid_mismatch>.
    //
    pure virtual function automatic void set_config_awid_wid_mismatch( bit config_awid_wid_mismatch_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_length_last_mismatch_error
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_length_last_mismatch_error>.
    //
    // Parameters:
    //     config_length_last_mismatch_error_param - The value to assign to variable <axi::config_length_last_mismatch_error>.
    //
    pure virtual function automatic void set_config_length_last_mismatch_error( bit config_length_last_mismatch_error_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_master_error_position
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_master_error_position>.
    //
    // Parameters:
    //     config_master_error_position_param - The value to assign to variable <axi::config_master_error_position>.
    //
    pure virtual function automatic void set_config_master_error_position( axi_error_e config_master_error_position_param );

    //------------------------------------------------------------------------------
    // Function:- set_dummy_var
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::dummy_var>.
    //
    // Parameters:
    //     dummy_var_param - The value to assign to variable <axi::dummy_var>.
    //
    pure virtual function automatic void set_dummy_var( axi_assertion_type_e dummy_var_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_wlast_length
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_wlast_length>.
    //
    // Parameters:
    //     config_wlast_length_param - The value to assign to variable <axi::config_wlast_length>.
    //
    pure virtual function automatic void set_config_wlast_length( int config_wlast_length_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_wid_for_awid_not_matching
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_wid_for_awid_not_matching>.
    //
    // Parameters:
    //     config_wid_for_awid_not_matching_param - The value to assign to variable <axi::config_wid_for_awid_not_matching>.
    //
    pure virtual function automatic void set_config_wid_for_awid_not_matching( bit [((AXI_ID_WIDTH) - 1):0]  config_wid_for_awid_not_matching_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_wid_for_awid_not_matching_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi::config_wid_for_awid_not_matching>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_wid_for_awid_not_matching_param - The value to assign to variable <axi::config_wid_for_awid_not_matching>.
    //
    pure virtual function automatic void set_config_wid_for_awid_not_matching_index1( int _this_dot_1, bit  config_wid_for_awid_not_matching_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_support_exclusive_access
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_support_exclusive_access>.
    //
    // Parameters:
    //     config_support_exclusive_access_param - The value to assign to variable <axi::config_support_exclusive_access>.
    //
    pure virtual function automatic void set_config_support_exclusive_access( bit config_support_exclusive_access_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_write_data_interleaving_depth
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_write_data_interleaving_depth>.
    //
    // Parameters:
    //     config_write_data_interleaving_depth_param - The value to assign to variable <axi::config_write_data_interleaving_depth>.
    //
    pure virtual function automatic void set_config_write_data_interleaving_depth( int config_write_data_interleaving_depth_param );

    //------------------------------------------------------------------------------
    // Function:- set_status_master_error
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::status_master_error>.
    //
    // Parameters:
    //     status_master_error_param - The value to assign to variable <axi::status_master_error>.
    //
    pure virtual function automatic void set_status_master_error( bit [15:0] status_master_error_param );

    //------------------------------------------------------------------------------
    // Function:- set_status_master_error_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi::status_master_error>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     status_master_error_param - The value to assign to variable <axi::status_master_error>.
    //
    pure virtual function automatic void set_status_master_error_index1( int _this_dot_1, bit  status_master_error_param );

    //------------------------------------------------------------------------------
    // Function:- set_check_total_num_wdata_outstanding
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::check_total_num_wdata_outstanding>.
    //
    // Parameters:
    //     check_total_num_wdata_outstanding_param - The value to assign to variable <axi::check_total_num_wdata_outstanding>.
    //
    pure virtual function automatic void set_check_total_num_wdata_outstanding( bit check_total_num_wdata_outstanding_param );

    //------------------------------------------------------------------------------
    // Function:- set_total_num_wdata_outstanding
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::total_num_wdata_outstanding>.
    //
    // Parameters:
    //     total_num_wdata_outstanding_param - The value to assign to variable <axi::total_num_wdata_outstanding>.
    //
    pure virtual function automatic void set_total_num_wdata_outstanding( int total_num_wdata_outstanding_param );

    //------------------------------------------------------------------------------
    // Function:- set_check_max_num_wdata_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::check_max_num_wdata_outstanding_per_id>.
    //
    // Parameters:
    //     check_max_num_wdata_outstanding_per_id_param - The value to assign to variable <axi::check_max_num_wdata_outstanding_per_id>.
    //
    pure virtual function automatic void set_check_max_num_wdata_outstanding_per_id( bit check_max_num_wdata_outstanding_per_id_param );

    //------------------------------------------------------------------------------
    // Function:- set_max_num_wdata_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::max_num_wdata_outstanding_per_id>.
    //
    // Parameters:
    //     max_num_wdata_outstanding_per_id_param - The value to assign to variable <axi::max_num_wdata_outstanding_per_id>.
    //
    pure virtual function automatic void set_max_num_wdata_outstanding_per_id( int max_num_wdata_outstanding_per_id_param );

    //------------------------------------------------------------------------------
    // Function:- set_check_max_num_waddr_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::check_max_num_waddr_outstanding_per_id>.
    //
    // Parameters:
    //     check_max_num_waddr_outstanding_per_id_param - The value to assign to variable <axi::check_max_num_waddr_outstanding_per_id>.
    //
    pure virtual function automatic void set_check_max_num_waddr_outstanding_per_id( bit check_max_num_waddr_outstanding_per_id_param );

    //------------------------------------------------------------------------------
    // Function:- set_max_num_waddr_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::max_num_waddr_outstanding_per_id>.
    //
    // Parameters:
    //     max_num_waddr_outstanding_per_id_param - The value to assign to variable <axi::max_num_waddr_outstanding_per_id>.
    //
    pure virtual function automatic void set_max_num_waddr_outstanding_per_id( int max_num_waddr_outstanding_per_id_param );

    //------------------------------------------------------------------------------
    // Function:- set_check_total_num_waddr_outstanding
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::check_total_num_waddr_outstanding>.
    //
    // Parameters:
    //     check_total_num_waddr_outstanding_param - The value to assign to variable <axi::check_total_num_waddr_outstanding>.
    //
    pure virtual function automatic void set_check_total_num_waddr_outstanding( bit check_total_num_waddr_outstanding_param );

    //------------------------------------------------------------------------------
    // Function:- set_total_num_waddr_outstanding
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::total_num_waddr_outstanding>.
    //
    // Parameters:
    //     total_num_waddr_outstanding_param - The value to assign to variable <axi::total_num_waddr_outstanding>.
    //
    pure virtual function automatic void set_total_num_waddr_outstanding( int total_num_waddr_outstanding_param );

    //------------------------------------------------------------------------------
    // Function:- set_status_outstanding_num_for_waddr
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::status_outstanding_num_for_waddr>.
    //
    // Parameters:
    //     status_outstanding_num_for_waddr_param - The value to assign to variable <axi::status_outstanding_num_for_waddr>.
    //
    pure virtual function automatic void set_status_outstanding_num_for_waddr( int status_outstanding_num_for_waddr_param );

    //------------------------------------------------------------------------------
    // Function:- set_start_finding_outstanding_waddr
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::start_finding_outstanding_waddr>.
    //
    // Parameters:
    //     start_finding_outstanding_waddr_param - The value to assign to variable <axi::start_finding_outstanding_waddr>.
    //
    pure virtual function automatic void set_start_finding_outstanding_waddr( bit start_finding_outstanding_waddr_param );

    //------------------------------------------------------------------------------
    // Function:- set_status_outstanding_num_for_wdata
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::status_outstanding_num_for_wdata>.
    //
    // Parameters:
    //     status_outstanding_num_for_wdata_param - The value to assign to variable <axi::status_outstanding_num_for_wdata>.
    //
    pure virtual function automatic void set_status_outstanding_num_for_wdata( int status_outstanding_num_for_wdata_param );

    //------------------------------------------------------------------------------
    // Function:- set_start_finding_outstanding_wdata
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::start_finding_outstanding_wdata>.
    //
    // Parameters:
    //     start_finding_outstanding_wdata_param - The value to assign to variable <axi::start_finding_outstanding_wdata>.
    //
    pure virtual function automatic void set_start_finding_outstanding_wdata( bit start_finding_outstanding_wdata_param );

    //------------------------------------------------------------------------------
    // Function:- set_find_waddr_outstanding_for_wid
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::find_waddr_outstanding_for_wid>.
    //
    // Parameters:
    //     find_waddr_outstanding_for_wid_param - The value to assign to variable <axi::find_waddr_outstanding_for_wid>.
    //
    pure virtual function automatic void set_find_waddr_outstanding_for_wid( bit [((AXI_ID_WIDTH) - 1):0]  find_waddr_outstanding_for_wid_param );

    //------------------------------------------------------------------------------
    // Function:- set_find_waddr_outstanding_for_wid_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi::find_waddr_outstanding_for_wid>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     find_waddr_outstanding_for_wid_param - The value to assign to variable <axi::find_waddr_outstanding_for_wid>.
    //
    pure virtual function automatic void set_find_waddr_outstanding_for_wid_index1( int _this_dot_1, bit  find_waddr_outstanding_for_wid_param );

    //------------------------------------------------------------------------------
    // Function:- set_find_wdata_outstanding_for_wid
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::find_wdata_outstanding_for_wid>.
    //
    // Parameters:
    //     find_wdata_outstanding_for_wid_param - The value to assign to variable <axi::find_wdata_outstanding_for_wid>.
    //
    pure virtual function automatic void set_find_wdata_outstanding_for_wid( bit [((AXI_ID_WIDTH) - 1):0]  find_wdata_outstanding_for_wid_param );

    //------------------------------------------------------------------------------
    // Function:- set_find_wdata_outstanding_for_wid_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi::find_wdata_outstanding_for_wid>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     find_wdata_outstanding_for_wid_param - The value to assign to variable <axi::find_wdata_outstanding_for_wid>.
    //
    pure virtual function automatic void set_find_wdata_outstanding_for_wid_index1( int _this_dot_1, bit  find_wdata_outstanding_for_wid_param );

    //------------------------------------------------------------------------------
    // Function:- set_change_in_wdata_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::change_in_wdata_outstanding_per_id>.
    //
    // Parameters:
    //     change_in_wdata_outstanding_per_id_param - The value to assign to variable <axi::change_in_wdata_outstanding_per_id>.
    //
    pure virtual function automatic void set_change_in_wdata_outstanding_per_id( bit change_in_wdata_outstanding_per_id_param );

    //------------------------------------------------------------------------------
    // Function:- set_start_finding_change_in_wdata
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::start_finding_change_in_wdata>.
    //
    // Parameters:
    //     start_finding_change_in_wdata_param - The value to assign to variable <axi::start_finding_change_in_wdata>.
    //
    pure virtual function automatic void set_start_finding_change_in_wdata( bit start_finding_change_in_wdata_param );

    //------------------------------------------------------------------------------
    // Function:- set_find_change_in_wdata_outstanding_for_wid
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::find_change_in_wdata_outstanding_for_wid>.
    //
    // Parameters:
    //     find_change_in_wdata_outstanding_for_wid_param - The value to assign to variable <axi::find_change_in_wdata_outstanding_for_wid>.
    //
    pure virtual function automatic void set_find_change_in_wdata_outstanding_for_wid( bit [((AXI_ID_WIDTH) - 1):0]  find_change_in_wdata_outstanding_for_wid_param );

    //------------------------------------------------------------------------------
    // Function:- set_find_change_in_wdata_outstanding_for_wid_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi::find_change_in_wdata_outstanding_for_wid>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     find_change_in_wdata_outstanding_for_wid_param - The value to assign to variable <axi::find_change_in_wdata_outstanding_for_wid>.
    //
    pure virtual function automatic void set_find_change_in_wdata_outstanding_for_wid_index1( int _this_dot_1, bit  find_change_in_wdata_outstanding_for_wid_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_max_outstanding_wr
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_max_outstanding_wr>.
    //
    // Parameters:
    //     config_max_outstanding_wr_param - The value to assign to variable <axi::config_max_outstanding_wr>.
    //
    pure virtual function automatic void set_config_max_outstanding_wr( int config_max_outstanding_wr_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_max_outstanding_rd
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_max_outstanding_rd>.
    //
    // Parameters:
    //     config_max_outstanding_rd_param - The value to assign to variable <axi::config_max_outstanding_rd>.
    //
    pure virtual function automatic void set_config_max_outstanding_rd( int config_max_outstanding_rd_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_error_on_deleted_valid_cycles
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_error_on_deleted_valid_cycles>.
    //
    // Parameters:
    //     config_error_on_deleted_valid_cycles_param - The value to assign to variable <axi::config_error_on_deleted_valid_cycles>.
    //
    pure virtual function automatic void set_config_error_on_deleted_valid_cycles( bit config_error_on_deleted_valid_cycles_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable>.
    //
    // Parameters:
    //     config_stats_enable_param - The value to assign to variable <axi::config_stats_enable>.
    //
    pure virtual function automatic void set_config_stats_enable( bit config_stats_enable_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_AXI_read_occupancy
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_AXI_read_occupancy>.
    //
    // Parameters:
    //     config_stats_enable_AXI_read_occupancy_param - The value to assign to variable <axi::config_stats_enable_AXI_read_occupancy>.
    //
    pure virtual function automatic void set_config_stats_enable_AXI_read_occupancy( bit config_stats_enable_AXI_read_occupancy_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_AXI_write_occupancy
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_AXI_write_occupancy>.
    //
    // Parameters:
    //     config_stats_enable_AXI_write_occupancy_param - The value to assign to variable <axi::config_stats_enable_AXI_write_occupancy>.
    //
    pure virtual function automatic void set_config_stats_enable_AXI_write_occupancy( bit config_stats_enable_AXI_write_occupancy_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_data_occupancy
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_read_data_occupancy>.
    //
    // Parameters:
    //     config_stats_enable_read_data_occupancy_param - The value to assign to variable <axi::config_stats_enable_read_data_occupancy>.
    //
    pure virtual function automatic void set_config_stats_enable_read_data_occupancy( bit config_stats_enable_read_data_occupancy_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_data_occupancy
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_write_data_occupancy>.
    //
    // Parameters:
    //     config_stats_enable_write_data_occupancy_param - The value to assign to variable <axi::config_stats_enable_write_data_occupancy>.
    //
    pure virtual function automatic void set_config_stats_enable_write_data_occupancy( bit config_stats_enable_write_data_occupancy_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_latency
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_read_latency>.
    //
    // Parameters:
    //     config_stats_enable_read_latency_param - The value to assign to variable <axi::config_stats_enable_read_latency>.
    //
    pure virtual function automatic void set_config_stats_enable_read_latency( bit config_stats_enable_read_latency_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_latency
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_write_latency>.
    //
    // Parameters:
    //     config_stats_enable_write_latency_param - The value to assign to variable <axi::config_stats_enable_write_latency>.
    //
    pure virtual function automatic void set_config_stats_enable_write_latency( bit config_stats_enable_write_latency_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_address_waits
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_read_address_waits>.
    //
    // Parameters:
    //     config_stats_enable_read_address_waits_param - The value to assign to variable <axi::config_stats_enable_read_address_waits>.
    //
    pure virtual function automatic void set_config_stats_enable_read_address_waits( bit config_stats_enable_read_address_waits_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_data_waits
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_read_data_waits>.
    //
    // Parameters:
    //     config_stats_enable_read_data_waits_param - The value to assign to variable <axi::config_stats_enable_read_data_waits>.
    //
    pure virtual function automatic void set_config_stats_enable_read_data_waits( bit config_stats_enable_read_data_waits_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_address_waits
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_write_address_waits>.
    //
    // Parameters:
    //     config_stats_enable_write_address_waits_param - The value to assign to variable <axi::config_stats_enable_write_address_waits>.
    //
    pure virtual function automatic void set_config_stats_enable_write_address_waits( bit config_stats_enable_write_address_waits_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_data_waits
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_write_data_waits>.
    //
    // Parameters:
    //     config_stats_enable_write_data_waits_param - The value to assign to variable <axi::config_stats_enable_write_data_waits>.
    //
    pure virtual function automatic void set_config_stats_enable_write_data_waits( bit config_stats_enable_write_data_waits_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_response_waits
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_write_response_waits>.
    //
    // Parameters:
    //     config_stats_enable_write_response_waits_param - The value to assign to variable <axi::config_stats_enable_write_response_waits>.
    //
    pure virtual function automatic void set_config_stats_enable_write_response_waits( bit config_stats_enable_write_response_waits_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_bandwidth
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_read_bandwidth>.
    //
    // Parameters:
    //     config_stats_enable_read_bandwidth_param - The value to assign to variable <axi::config_stats_enable_read_bandwidth>.
    //
    pure virtual function automatic void set_config_stats_enable_read_bandwidth( bit config_stats_enable_read_bandwidth_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_bandwidth
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_write_bandwidth>.
    //
    // Parameters:
    //     config_stats_enable_write_bandwidth_param - The value to assign to variable <axi::config_stats_enable_write_bandwidth>.
    //
    pure virtual function automatic void set_config_stats_enable_write_bandwidth( bit config_stats_enable_write_bandwidth_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_AXI_read_occupancy_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_AXI_read_occupancy_step>.
    //
    // Parameters:
    //     config_stats_AXI_read_occupancy_step_param - The value to assign to variable <axi::config_stats_AXI_read_occupancy_step>.
    //
    pure virtual function automatic void set_config_stats_AXI_read_occupancy_step( int config_stats_AXI_read_occupancy_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_AXI_read_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_AXI_read_occupancy_multiple>.
    //
    // Parameters:
    //     config_stats_AXI_read_occupancy_multiple_param - The value to assign to variable <axi::config_stats_AXI_read_occupancy_multiple>.
    //
    pure virtual function automatic void set_config_stats_AXI_read_occupancy_multiple( int config_stats_AXI_read_occupancy_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_AXI_write_occupancy_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_AXI_write_occupancy_step>.
    //
    // Parameters:
    //     config_stats_AXI_write_occupancy_step_param - The value to assign to variable <axi::config_stats_AXI_write_occupancy_step>.
    //
    pure virtual function automatic void set_config_stats_AXI_write_occupancy_step( int config_stats_AXI_write_occupancy_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_AXI_write_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_AXI_write_occupancy_multiple>.
    //
    // Parameters:
    //     config_stats_AXI_write_occupancy_multiple_param - The value to assign to variable <axi::config_stats_AXI_write_occupancy_multiple>.
    //
    pure virtual function automatic void set_config_stats_AXI_write_occupancy_multiple( int config_stats_AXI_write_occupancy_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_read_data_occupancy_step>.
    //
    // Parameters:
    //     config_stats_read_data_occupancy_step_param - The value to assign to variable <axi::config_stats_read_data_occupancy_step>.
    //
    pure virtual function automatic void set_config_stats_read_data_occupancy_step( int config_stats_read_data_occupancy_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_read_data_occupancy_multiple>.
    //
    // Parameters:
    //     config_stats_read_data_occupancy_multiple_param - The value to assign to variable <axi::config_stats_read_data_occupancy_multiple>.
    //
    pure virtual function automatic void set_config_stats_read_data_occupancy_multiple( int config_stats_read_data_occupancy_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_data_occupancy_step>.
    //
    // Parameters:
    //     config_stats_write_data_occupancy_step_param - The value to assign to variable <axi::config_stats_write_data_occupancy_step>.
    //
    pure virtual function automatic void set_config_stats_write_data_occupancy_step( int config_stats_write_data_occupancy_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_data_occupancy_multiple>.
    //
    // Parameters:
    //     config_stats_write_data_occupancy_multiple_param - The value to assign to variable <axi::config_stats_write_data_occupancy_multiple>.
    //
    pure virtual function automatic void set_config_stats_write_data_occupancy_multiple( int config_stats_write_data_occupancy_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_bandwidth_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_read_bandwidth_step>.
    //
    // Parameters:
    //     config_stats_read_bandwidth_step_param - The value to assign to variable <axi::config_stats_read_bandwidth_step>.
    //
    pure virtual function automatic void set_config_stats_read_bandwidth_step( int config_stats_read_bandwidth_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_read_bandwidth_multiple>.
    //
    // Parameters:
    //     config_stats_read_bandwidth_multiple_param - The value to assign to variable <axi::config_stats_read_bandwidth_multiple>.
    //
    pure virtual function automatic void set_config_stats_read_bandwidth_multiple( int config_stats_read_bandwidth_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_bandwidth_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_bandwidth_step>.
    //
    // Parameters:
    //     config_stats_write_bandwidth_step_param - The value to assign to variable <axi::config_stats_write_bandwidth_step>.
    //
    pure virtual function automatic void set_config_stats_write_bandwidth_step( int config_stats_write_bandwidth_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_bandwidth_multiple>.
    //
    // Parameters:
    //     config_stats_write_bandwidth_multiple_param - The value to assign to variable <axi::config_stats_write_bandwidth_multiple>.
    //
    pure virtual function automatic void set_config_stats_write_bandwidth_multiple( int config_stats_write_bandwidth_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_latency_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_read_latency_step>.
    //
    // Parameters:
    //     config_stats_read_latency_step_param - The value to assign to variable <axi::config_stats_read_latency_step>.
    //
    pure virtual function automatic void set_config_stats_read_latency_step( int config_stats_read_latency_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_latency_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_read_latency_multiple>.
    //
    // Parameters:
    //     config_stats_read_latency_multiple_param - The value to assign to variable <axi::config_stats_read_latency_multiple>.
    //
    pure virtual function automatic void set_config_stats_read_latency_multiple( int config_stats_read_latency_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_latency_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_latency_step>.
    //
    // Parameters:
    //     config_stats_write_latency_step_param - The value to assign to variable <axi::config_stats_write_latency_step>.
    //
    pure virtual function automatic void set_config_stats_write_latency_step( int config_stats_write_latency_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_latency_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_latency_multiple>.
    //
    // Parameters:
    //     config_stats_write_latency_multiple_param - The value to assign to variable <axi::config_stats_write_latency_multiple>.
    //
    pure virtual function automatic void set_config_stats_write_latency_multiple( int config_stats_write_latency_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_address_waits_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_read_address_waits_step>.
    //
    // Parameters:
    //     config_stats_read_address_waits_step_param - The value to assign to variable <axi::config_stats_read_address_waits_step>.
    //
    pure virtual function automatic void set_config_stats_read_address_waits_step( int config_stats_read_address_waits_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_read_address_waits_multiple>.
    //
    // Parameters:
    //     config_stats_read_address_waits_multiple_param - The value to assign to variable <axi::config_stats_read_address_waits_multiple>.
    //
    pure virtual function automatic void set_config_stats_read_address_waits_multiple( int config_stats_read_address_waits_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_data_waits_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_read_data_waits_step>.
    //
    // Parameters:
    //     config_stats_read_data_waits_step_param - The value to assign to variable <axi::config_stats_read_data_waits_step>.
    //
    pure virtual function automatic void set_config_stats_read_data_waits_step( int config_stats_read_data_waits_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_read_data_waits_multiple>.
    //
    // Parameters:
    //     config_stats_read_data_waits_multiple_param - The value to assign to variable <axi::config_stats_read_data_waits_multiple>.
    //
    pure virtual function automatic void set_config_stats_read_data_waits_multiple( int config_stats_read_data_waits_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_address_waits_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_address_waits_step>.
    //
    // Parameters:
    //     config_stats_write_address_waits_step_param - The value to assign to variable <axi::config_stats_write_address_waits_step>.
    //
    pure virtual function automatic void set_config_stats_write_address_waits_step( int config_stats_write_address_waits_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_address_waits_multiple>.
    //
    // Parameters:
    //     config_stats_write_address_waits_multiple_param - The value to assign to variable <axi::config_stats_write_address_waits_multiple>.
    //
    pure virtual function automatic void set_config_stats_write_address_waits_multiple( int config_stats_write_address_waits_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_data_waits_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_data_waits_step>.
    //
    // Parameters:
    //     config_stats_write_data_waits_step_param - The value to assign to variable <axi::config_stats_write_data_waits_step>.
    //
    pure virtual function automatic void set_config_stats_write_data_waits_step( int config_stats_write_data_waits_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_data_waits_multiple>.
    //
    // Parameters:
    //     config_stats_write_data_waits_multiple_param - The value to assign to variable <axi::config_stats_write_data_waits_multiple>.
    //
    pure virtual function automatic void set_config_stats_write_data_waits_multiple( int config_stats_write_data_waits_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_response_waits_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_response_waits_step>.
    //
    // Parameters:
    //     config_stats_write_response_waits_step_param - The value to assign to variable <axi::config_stats_write_response_waits_step>.
    //
    pure virtual function automatic void set_config_stats_write_response_waits_step( int config_stats_write_response_waits_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_response_waits_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_response_waits_multiple>.
    //
    // Parameters:
    //     config_stats_write_response_waits_multiple_param - The value to assign to variable <axi::config_stats_write_response_waits_multiple>.
    //
    pure virtual function automatic void set_config_stats_write_response_waits_multiple( int config_stats_write_response_waits_multiple_param );

    //------------------------------------------------------------------------------
    // Functions to get global variables with read access
    //------------------------------------------------------------------------------

    //------------------------------------------------------------------------------
    // Function:- get_config_clk_init_value
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_clk_init_value>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_clk_init_value>.
    //
    pure virtual function automatic bit get_config_clk_init_value(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_clk_phase_shift
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_clk_phase_shift>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_clk_phase_shift>.
    //
    pure virtual function automatic int get_config_clk_phase_shift(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_clk_1st_time
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_clk_1st_time>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_clk_1st_time>.
    //
    pure virtual function automatic int get_config_clk_1st_time(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_clk_2nd_time
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_clk_2nd_time>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_clk_2nd_time>.
    //
    pure virtual function automatic int get_config_clk_2nd_time(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_setup_time
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_setup_time>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_setup_time>.
    //
    pure virtual function automatic int get_config_setup_time(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_hold_time
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_hold_time>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_hold_time>.
    //
    pure virtual function automatic int get_config_hold_time(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_max_transaction_time_factor
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_max_transaction_time_factor>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_max_transaction_time_factor>.
    //
    pure virtual function automatic int unsigned get_config_max_transaction_time_factor(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_timeout_max_data_transfer
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_timeout_max_data_transfer>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_timeout_max_data_transfer>.
    //
    pure virtual function automatic int get_config_timeout_max_data_transfer(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_burst_timeout_factor
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_burst_timeout_factor>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_burst_timeout_factor>.
    //
    pure virtual function automatic int unsigned get_config_burst_timeout_factor(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_max_latency_AWVALID_assertion_to_AWREADY
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_max_latency_AWVALID_assertion_to_AWREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_max_latency_AWVALID_assertion_to_AWREADY>.
    //
    pure virtual function automatic int unsigned get_config_max_latency_AWVALID_assertion_to_AWREADY(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_max_latency_ARVALID_assertion_to_ARREADY
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_max_latency_ARVALID_assertion_to_ARREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_max_latency_ARVALID_assertion_to_ARREADY>.
    //
    pure virtual function automatic int unsigned get_config_max_latency_ARVALID_assertion_to_ARREADY(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_max_latency_RVALID_assertion_to_RREADY
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_max_latency_RVALID_assertion_to_RREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_max_latency_RVALID_assertion_to_RREADY>.
    //
    pure virtual function automatic int unsigned get_config_max_latency_RVALID_assertion_to_RREADY(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_max_latency_BVALID_assertion_to_BREADY
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_max_latency_BVALID_assertion_to_BREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_max_latency_BVALID_assertion_to_BREADY>.
    //
    pure virtual function automatic int unsigned get_config_max_latency_BVALID_assertion_to_BREADY(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_max_latency_WVALID_assertion_to_WREADY
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_max_latency_WVALID_assertion_to_WREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_max_latency_WVALID_assertion_to_WREADY>.
    //
    pure virtual function automatic int unsigned get_config_max_latency_WVALID_assertion_to_WREADY(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_write_ctrl_first_ratio
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_write_ctrl_first_ratio>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_write_ctrl_first_ratio>.
    //
    pure virtual function automatic int get_config_write_ctrl_first_ratio(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_write_data_first_ratio
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_write_data_first_ratio>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_write_data_first_ratio>.
    //
    pure virtual function automatic int get_config_write_data_first_ratio(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_write_ctrl_to_data_mintime
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_write_ctrl_to_data_mintime>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_write_ctrl_to_data_mintime>.
    //
    pure virtual function automatic int unsigned get_config_write_ctrl_to_data_mintime(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_write_data_to_ctrl_mintime
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_write_data_to_ctrl_mintime>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_write_data_to_ctrl_mintime>.
    //
    pure virtual function automatic int unsigned get_config_write_data_to_ctrl_mintime(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_master_write_delay
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_master_write_delay>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_master_write_delay>.
    //
    pure virtual function automatic bit get_config_master_write_delay(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_reset_low_clocks
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_reset_low_clocks>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_reset_low_clocks>.
    //
    pure virtual function automatic int get_config_reset_low_clocks(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_reset_hold_time
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_reset_hold_time>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_reset_hold_time>.
    //
    pure virtual function automatic int get_config_reset_hold_time(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_protect_ready
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_protect_ready>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_protect_ready>.
    //
    pure virtual function automatic bit get_config_protect_ready(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_user_sideband
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_user_sideband>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_user_sideband>.
    //
    pure virtual function automatic bit get_config_enable_user_sideband(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_extended_length_enable
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_extended_length_enable>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_extended_length_enable>.
    //
    pure virtual function automatic bit get_config_extended_length_enable(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_burst_reserved_value
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_burst_reserved_value>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_burst_reserved_value>.
    //
    pure virtual function automatic bit get_config_enable_burst_reserved_value(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_lock_reserved_value
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_lock_reserved_value>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_lock_reserved_value>.
    //
    pure virtual function automatic bit get_config_enable_lock_reserved_value(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_cache_reserved_value
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_cache_reserved_value>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_cache_reserved_value>.
    //
    pure virtual function automatic bit get_config_enable_cache_reserved_value(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_all_assertions
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_all_assertions>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_all_assertions>.
    //
    pure virtual function automatic bit get_config_enable_all_assertions(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_assertion
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_assertion>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_assertion>.
    //
    pure virtual function automatic bit [255:0]  get_config_enable_assertion(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_assertion_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi::config_enable_assertion>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_assertion>.
    //
    pure virtual function automatic bit   get_config_enable_assertion_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_error
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_error>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_error>.
    //
    pure virtual function automatic bit [255:0]  get_config_enable_error(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_error_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi::config_enable_error>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_error>.
    //
    pure virtual function automatic bit   get_config_enable_error_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_errors
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_errors>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_errors>.
    //
    pure virtual function automatic bit get_config_enable_errors(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_all_assertion_errors
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_all_assertion_errors>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_all_assertion_errors>.
    //
    pure virtual function automatic bit get_config_enable_all_assertion_errors(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_abstraction_level
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_abstraction_level>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_abstraction_level>.
    //
    pure virtual function automatic axi_abstraction_level_e get_config_abstraction_level(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_slave_start_addr
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_slave_start_addr>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_slave_start_addr>.
    //
    pure virtual function automatic bit [((AXI_ADDRESS_WIDTH) - 1):0]   get_config_slave_start_addr(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_slave_start_addr_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi::config_slave_start_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi::config_slave_start_addr>.
    //
    pure virtual function automatic bit   get_config_slave_start_addr_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_config_slave_end_addr
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_slave_end_addr>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_slave_end_addr>.
    //
    pure virtual function automatic bit [((AXI_ADDRESS_WIDTH) - 1):0]   get_config_slave_end_addr(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_slave_end_addr_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi::config_slave_end_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi::config_slave_end_addr>.
    //
    pure virtual function automatic bit   get_config_slave_end_addr_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_slave_addr_range_in_bfm
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_slave_addr_range_in_bfm>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_slave_addr_range_in_bfm>.
    //
    pure virtual function automatic bit get_config_enable_slave_addr_range_in_bfm(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_read_data_reordering_depth
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_read_data_reordering_depth>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_read_data_reordering_depth>.
    //
    pure virtual function automatic int unsigned get_config_read_data_reordering_depth(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_read_data_reordering_depth_in_bfm
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_read_data_reordering_depth_in_bfm>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_read_data_reordering_depth_in_bfm>.
    //
    pure virtual function automatic bit get_config_enable_read_data_reordering_depth_in_bfm(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_awid_wid_mismatch
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_awid_wid_mismatch>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_awid_wid_mismatch>.
    //
    pure virtual function automatic bit get_config_awid_wid_mismatch(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_length_last_mismatch_error
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_length_last_mismatch_error>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_length_last_mismatch_error>.
    //
    pure virtual function automatic bit get_config_length_last_mismatch_error(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_master_error_position
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_master_error_position>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_master_error_position>.
    //
    pure virtual function automatic axi_error_e get_config_master_error_position(  );

    //------------------------------------------------------------------------------
    // Function:- get_dummy_var
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::dummy_var>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::dummy_var>.
    //
    pure virtual function automatic axi_assertion_type_e get_dummy_var(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_wlast_length
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_wlast_length>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_wlast_length>.
    //
    pure virtual function automatic int get_config_wlast_length(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_wid_for_awid_not_matching
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_wid_for_awid_not_matching>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_wid_for_awid_not_matching>.
    //
    pure virtual function automatic bit [((AXI_ID_WIDTH) - 1):0]   get_config_wid_for_awid_not_matching(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_wid_for_awid_not_matching_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi::config_wid_for_awid_not_matching>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi::config_wid_for_awid_not_matching>.
    //
    pure virtual function automatic bit   get_config_wid_for_awid_not_matching_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_config_support_exclusive_access
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_support_exclusive_access>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_support_exclusive_access>.
    //
    pure virtual function automatic bit get_config_support_exclusive_access(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_write_data_interleaving_depth
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_write_data_interleaving_depth>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_write_data_interleaving_depth>.
    //
    pure virtual function automatic int get_config_write_data_interleaving_depth(  );

    //------------------------------------------------------------------------------
    // Function:- get_status_master_error
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::status_master_error>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::status_master_error>.
    //
    pure virtual function automatic bit [15:0]  get_status_master_error(  );

    //------------------------------------------------------------------------------
    // Function:- get_status_master_error_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi::status_master_error>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi::status_master_error>.
    //
    pure virtual function automatic bit   get_status_master_error_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_status_num_reads_waiting_for_resp
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::status_num_reads_waiting_for_resp>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::status_num_reads_waiting_for_resp>.
    //
    pure virtual function automatic int get_status_num_reads_waiting_for_resp(  );

    //------------------------------------------------------------------------------
    // Function:- get_status_num_writes_waiting_for_response
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::status_num_writes_waiting_for_response>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::status_num_writes_waiting_for_response>.
    //
    pure virtual function automatic int get_status_num_writes_waiting_for_response(  );

    //------------------------------------------------------------------------------
    // Function:- get_check_total_num_wdata_outstanding
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::check_total_num_wdata_outstanding>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::check_total_num_wdata_outstanding>.
    //
    pure virtual function automatic bit get_check_total_num_wdata_outstanding(  );

    //------------------------------------------------------------------------------
    // Function:- get_total_num_wdata_outstanding
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::total_num_wdata_outstanding>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::total_num_wdata_outstanding>.
    //
    pure virtual function automatic int get_total_num_wdata_outstanding(  );

    //------------------------------------------------------------------------------
    // Function:- get_check_max_num_wdata_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::check_max_num_wdata_outstanding_per_id>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::check_max_num_wdata_outstanding_per_id>.
    //
    pure virtual function automatic bit get_check_max_num_wdata_outstanding_per_id(  );

    //------------------------------------------------------------------------------
    // Function:- get_max_num_wdata_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::max_num_wdata_outstanding_per_id>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::max_num_wdata_outstanding_per_id>.
    //
    pure virtual function automatic int get_max_num_wdata_outstanding_per_id(  );

    //------------------------------------------------------------------------------
    // Function:- get_check_max_num_waddr_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::check_max_num_waddr_outstanding_per_id>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::check_max_num_waddr_outstanding_per_id>.
    //
    pure virtual function automatic bit get_check_max_num_waddr_outstanding_per_id(  );

    //------------------------------------------------------------------------------
    // Function:- get_max_num_waddr_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::max_num_waddr_outstanding_per_id>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::max_num_waddr_outstanding_per_id>.
    //
    pure virtual function automatic int get_max_num_waddr_outstanding_per_id(  );

    //------------------------------------------------------------------------------
    // Function:- get_check_total_num_waddr_outstanding
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::check_total_num_waddr_outstanding>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::check_total_num_waddr_outstanding>.
    //
    pure virtual function automatic bit get_check_total_num_waddr_outstanding(  );

    //------------------------------------------------------------------------------
    // Function:- get_total_num_waddr_outstanding
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::total_num_waddr_outstanding>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::total_num_waddr_outstanding>.
    //
    pure virtual function automatic int get_total_num_waddr_outstanding(  );

    //------------------------------------------------------------------------------
    // Function:- get_status_outstanding_num_for_waddr
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::status_outstanding_num_for_waddr>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::status_outstanding_num_for_waddr>.
    //
    pure virtual function automatic int get_status_outstanding_num_for_waddr(  );

    //------------------------------------------------------------------------------
    // Function:- get_start_finding_outstanding_waddr
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::start_finding_outstanding_waddr>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::start_finding_outstanding_waddr>.
    //
    pure virtual function automatic bit get_start_finding_outstanding_waddr(  );

    //------------------------------------------------------------------------------
    // Function:- get_status_outstanding_num_for_wdata
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::status_outstanding_num_for_wdata>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::status_outstanding_num_for_wdata>.
    //
    pure virtual function automatic int get_status_outstanding_num_for_wdata(  );

    //------------------------------------------------------------------------------
    // Function:- get_start_finding_outstanding_wdata
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::start_finding_outstanding_wdata>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::start_finding_outstanding_wdata>.
    //
    pure virtual function automatic bit get_start_finding_outstanding_wdata(  );

    //------------------------------------------------------------------------------
    // Function:- get_find_waddr_outstanding_for_wid
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::find_waddr_outstanding_for_wid>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::find_waddr_outstanding_for_wid>.
    //
    pure virtual function automatic bit [((AXI_ID_WIDTH) - 1):0]   get_find_waddr_outstanding_for_wid(  );

    //------------------------------------------------------------------------------
    // Function:- get_find_waddr_outstanding_for_wid_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi::find_waddr_outstanding_for_wid>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi::find_waddr_outstanding_for_wid>.
    //
    pure virtual function automatic bit   get_find_waddr_outstanding_for_wid_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_find_wdata_outstanding_for_wid
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::find_wdata_outstanding_for_wid>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::find_wdata_outstanding_for_wid>.
    //
    pure virtual function automatic bit [((AXI_ID_WIDTH) - 1):0]   get_find_wdata_outstanding_for_wid(  );

    //------------------------------------------------------------------------------
    // Function:- get_find_wdata_outstanding_for_wid_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi::find_wdata_outstanding_for_wid>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi::find_wdata_outstanding_for_wid>.
    //
    pure virtual function automatic bit   get_find_wdata_outstanding_for_wid_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_change_in_wdata_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::change_in_wdata_outstanding_per_id>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::change_in_wdata_outstanding_per_id>.
    //
    pure virtual function automatic bit get_change_in_wdata_outstanding_per_id(  );

    //------------------------------------------------------------------------------
    // Function:- get_start_finding_change_in_wdata
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::start_finding_change_in_wdata>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::start_finding_change_in_wdata>.
    //
    pure virtual function automatic bit get_start_finding_change_in_wdata(  );

    //------------------------------------------------------------------------------
    // Function:- get_find_change_in_wdata_outstanding_for_wid
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::find_change_in_wdata_outstanding_for_wid>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::find_change_in_wdata_outstanding_for_wid>.
    //
    pure virtual function automatic bit [((AXI_ID_WIDTH) - 1):0]   get_find_change_in_wdata_outstanding_for_wid(  );

    //------------------------------------------------------------------------------
    // Function:- get_find_change_in_wdata_outstanding_for_wid_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi::find_change_in_wdata_outstanding_for_wid>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi::find_change_in_wdata_outstanding_for_wid>.
    //
    pure virtual function automatic bit   get_find_change_in_wdata_outstanding_for_wid_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_config_max_outstanding_wr
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_max_outstanding_wr>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_max_outstanding_wr>.
    //
    pure virtual function automatic int get_config_max_outstanding_wr(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_max_outstanding_rd
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_max_outstanding_rd>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_max_outstanding_rd>.
    //
    pure virtual function automatic int get_config_max_outstanding_rd(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_error_on_deleted_valid_cycles
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_error_on_deleted_valid_cycles>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_error_on_deleted_valid_cycles>.
    //
    pure virtual function automatic bit get_config_error_on_deleted_valid_cycles(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable>.
    //
    pure virtual function automatic bit get_config_stats_enable(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_AXI_read_occupancy
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_AXI_read_occupancy>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_AXI_read_occupancy>.
    //
    pure virtual function automatic bit get_config_stats_enable_AXI_read_occupancy(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_AXI_write_occupancy
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_AXI_write_occupancy>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_AXI_write_occupancy>.
    //
    pure virtual function automatic bit get_config_stats_enable_AXI_write_occupancy(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_data_occupancy
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_read_data_occupancy>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_read_data_occupancy>.
    //
    pure virtual function automatic bit get_config_stats_enable_read_data_occupancy(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_data_occupancy
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_write_data_occupancy>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_write_data_occupancy>.
    //
    pure virtual function automatic bit get_config_stats_enable_write_data_occupancy(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_latency
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_read_latency>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_read_latency>.
    //
    pure virtual function automatic bit get_config_stats_enable_read_latency(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_latency
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_write_latency>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_write_latency>.
    //
    pure virtual function automatic bit get_config_stats_enable_write_latency(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_address_waits
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_read_address_waits>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_read_address_waits>.
    //
    pure virtual function automatic bit get_config_stats_enable_read_address_waits(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_data_waits
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_read_data_waits>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_read_data_waits>.
    //
    pure virtual function automatic bit get_config_stats_enable_read_data_waits(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_address_waits
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_write_address_waits>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_write_address_waits>.
    //
    pure virtual function automatic bit get_config_stats_enable_write_address_waits(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_data_waits
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_write_data_waits>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_write_data_waits>.
    //
    pure virtual function automatic bit get_config_stats_enable_write_data_waits(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_response_waits
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_write_response_waits>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_write_response_waits>.
    //
    pure virtual function automatic bit get_config_stats_enable_write_response_waits(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_bandwidth
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_read_bandwidth>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_read_bandwidth>.
    //
    pure virtual function automatic bit get_config_stats_enable_read_bandwidth(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_bandwidth
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_write_bandwidth>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_write_bandwidth>.
    //
    pure virtual function automatic bit get_config_stats_enable_write_bandwidth(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_AXI_read_occupancy_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_AXI_read_occupancy_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_AXI_read_occupancy_step>.
    //
    pure virtual function automatic int get_config_stats_AXI_read_occupancy_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_AXI_read_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_AXI_read_occupancy_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_AXI_read_occupancy_multiple>.
    //
    pure virtual function automatic int get_config_stats_AXI_read_occupancy_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_active
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_active>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_active>.
    //
    pure virtual function automatic bit get_stats_AXI_read_active(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_occupancy_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_occupancy_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_occupancy_sw>.
    //
    pure virtual function automatic int get_stats_AXI_read_occupancy_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_occupancy_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_occupancy_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_occupancy_sw_updated>.
    //
    pure virtual function automatic int get_stats_AXI_read_occupancy_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_idle_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_idle_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_idle_sw>.
    //
    pure virtual function automatic int get_stats_AXI_read_idle_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_occupancy_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_occupancy_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_occupancy_min>.
    //
    pure virtual function automatic int get_stats_AXI_read_occupancy_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_idle_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_idle_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_idle_min>.
    //
    pure virtual function automatic int get_stats_AXI_read_idle_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_occupancy_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_occupancy_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_occupancy_max>.
    //
    pure virtual function automatic int get_stats_AXI_read_occupancy_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_idle_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_idle_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_idle_max>.
    //
    pure virtual function automatic int get_stats_AXI_read_idle_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_occupancy_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_occupancy_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_occupancy_mean>.
    //
    pure virtual function automatic int get_stats_AXI_read_occupancy_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_idle_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_idle_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_idle_mean>.
    //
    pure virtual function automatic int get_stats_AXI_read_idle_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_AXI_write_occupancy_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_AXI_write_occupancy_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_AXI_write_occupancy_step>.
    //
    pure virtual function automatic int get_config_stats_AXI_write_occupancy_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_AXI_write_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_AXI_write_occupancy_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_AXI_write_occupancy_multiple>.
    //
    pure virtual function automatic int get_config_stats_AXI_write_occupancy_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_active
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_active>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_active>.
    //
    pure virtual function automatic bit get_stats_AXI_write_active(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_occupancy_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_occupancy_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_occupancy_sw>.
    //
    pure virtual function automatic int get_stats_AXI_write_occupancy_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_occupancy_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_occupancy_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_occupancy_sw_updated>.
    //
    pure virtual function automatic int get_stats_AXI_write_occupancy_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_idle_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_idle_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_idle_sw>.
    //
    pure virtual function automatic int get_stats_AXI_write_idle_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_occupancy_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_occupancy_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_occupancy_min>.
    //
    pure virtual function automatic int get_stats_AXI_write_occupancy_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_idle_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_idle_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_idle_min>.
    //
    pure virtual function automatic int get_stats_AXI_write_idle_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_occupancy_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_occupancy_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_occupancy_max>.
    //
    pure virtual function automatic int get_stats_AXI_write_occupancy_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_idle_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_idle_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_idle_max>.
    //
    pure virtual function automatic int get_stats_AXI_write_idle_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_occupancy_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_occupancy_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_occupancy_mean>.
    //
    pure virtual function automatic int get_stats_AXI_write_occupancy_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_idle_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_idle_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_idle_mean>.
    //
    pure virtual function automatic int get_stats_AXI_write_idle_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_read_data_occupancy_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_read_data_occupancy_step>.
    //
    pure virtual function automatic int get_config_stats_read_data_occupancy_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_read_data_occupancy_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_read_data_occupancy_multiple>.
    //
    pure virtual function automatic int get_config_stats_read_data_occupancy_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_occupancy_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_occupancy_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_occupancy_sw>.
    //
    pure virtual function automatic int get_stats_read_data_occupancy_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_occupancy_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_occupancy_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_occupancy_sw_updated>.
    //
    pure virtual function automatic int get_stats_read_data_occupancy_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_idle_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_idle_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_idle_sw>.
    //
    pure virtual function automatic int get_stats_read_data_idle_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_occupancy_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_occupancy_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_occupancy_min>.
    //
    pure virtual function automatic int get_stats_read_data_occupancy_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_idle_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_idle_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_idle_min>.
    //
    pure virtual function automatic int get_stats_read_data_idle_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_occupancy_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_occupancy_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_occupancy_max>.
    //
    pure virtual function automatic int get_stats_read_data_occupancy_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_idle_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_idle_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_idle_max>.
    //
    pure virtual function automatic int get_stats_read_data_idle_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_occupancy_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_occupancy_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_occupancy_mean>.
    //
    pure virtual function automatic int get_stats_read_data_occupancy_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_idle_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_idle_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_idle_mean>.
    //
    pure virtual function automatic int get_stats_read_data_idle_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_data_occupancy_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_data_occupancy_step>.
    //
    pure virtual function automatic int get_config_stats_write_data_occupancy_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_data_occupancy_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_data_occupancy_multiple>.
    //
    pure virtual function automatic int get_config_stats_write_data_occupancy_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_occupancy_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_occupancy_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_occupancy_sw>.
    //
    pure virtual function automatic int get_stats_write_data_occupancy_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_occupancy_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_occupancy_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_occupancy_sw_updated>.
    //
    pure virtual function automatic int get_stats_write_data_occupancy_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_idle_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_idle_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_idle_sw>.
    //
    pure virtual function automatic int get_stats_write_data_idle_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_occupancy_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_occupancy_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_occupancy_min>.
    //
    pure virtual function automatic int get_stats_write_data_occupancy_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_idle_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_idle_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_idle_min>.
    //
    pure virtual function automatic int get_stats_write_data_idle_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_occupancy_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_occupancy_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_occupancy_max>.
    //
    pure virtual function automatic int get_stats_write_data_occupancy_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_idle_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_idle_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_idle_max>.
    //
    pure virtual function automatic int get_stats_write_data_idle_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_occupancy_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_occupancy_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_occupancy_mean>.
    //
    pure virtual function automatic int get_stats_write_data_occupancy_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_idle_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_idle_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_idle_mean>.
    //
    pure virtual function automatic int get_stats_write_data_idle_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_bandwidth_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_read_bandwidth_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_read_bandwidth_step>.
    //
    pure virtual function automatic int get_config_stats_read_bandwidth_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_read_bandwidth_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_read_bandwidth_multiple>.
    //
    pure virtual function automatic int get_config_stats_read_bandwidth_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_bandwidth_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_bandwidth_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_bandwidth_sw>.
    //
    pure virtual function automatic int get_stats_read_bandwidth_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_bandwidth_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_bandwidth_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_bandwidth_sw_updated>.
    //
    pure virtual function automatic int get_stats_read_bandwidth_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_bandwidth_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_bandwidth_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_bandwidth_min>.
    //
    pure virtual function automatic int get_stats_read_bandwidth_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_bandwidth_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_bandwidth_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_bandwidth_max>.
    //
    pure virtual function automatic int get_stats_read_bandwidth_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_bandwidth_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_bandwidth_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_bandwidth_mean>.
    //
    pure virtual function automatic int get_stats_read_bandwidth_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_bandwidth_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_bandwidth_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_bandwidth_step>.
    //
    pure virtual function automatic int get_config_stats_write_bandwidth_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_bandwidth_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_bandwidth_multiple>.
    //
    pure virtual function automatic int get_config_stats_write_bandwidth_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_bandwidth_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_bandwidth_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_bandwidth_sw>.
    //
    pure virtual function automatic int get_stats_write_bandwidth_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_bandwidth_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_bandwidth_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_bandwidth_sw_updated>.
    //
    pure virtual function automatic int get_stats_write_bandwidth_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_bandwidth_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_bandwidth_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_bandwidth_min>.
    //
    pure virtual function automatic int get_stats_write_bandwidth_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_bandwidth_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_bandwidth_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_bandwidth_max>.
    //
    pure virtual function automatic int get_stats_write_bandwidth_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_bandwidth_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_bandwidth_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_bandwidth_mean>.
    //
    pure virtual function automatic int get_stats_write_bandwidth_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_latency_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_read_latency_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_read_latency_step>.
    //
    pure virtual function automatic int get_config_stats_read_latency_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_latency_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_read_latency_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_read_latency_multiple>.
    //
    pure virtual function automatic int get_config_stats_read_latency_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_latency_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_latency_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_latency_sw_updated>.
    //
    pure virtual function automatic int get_stats_read_latency_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_data_latency_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_data_latency_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_data_latency_inst>.
    //
    pure virtual function automatic int get_stats_read_address_data_latency_inst(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_data_latency_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_data_latency_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_data_latency_sw>.
    //
    pure virtual function automatic int get_stats_read_address_data_latency_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_data_latency_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_data_latency_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_data_latency_min>.
    //
    pure virtual function automatic int get_stats_read_address_data_latency_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_data_latency_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_data_latency_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_data_latency_max>.
    //
    pure virtual function automatic int get_stats_read_address_data_latency_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_data_latency_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_data_latency_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_data_latency_mean>.
    //
    pure virtual function automatic int get_stats_read_address_data_latency_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_address_latency_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_address_latency_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_address_latency_inst>.
    //
    pure virtual function automatic int get_stats_read_address_address_latency_inst(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_address_latency_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_address_latency_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_address_latency_sw>.
    //
    pure virtual function automatic int get_stats_read_address_address_latency_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_address_latency_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_address_latency_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_address_latency_min>.
    //
    pure virtual function automatic int get_stats_read_address_address_latency_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_address_latency_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_address_latency_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_address_latency_max>.
    //
    pure virtual function automatic int get_stats_read_address_address_latency_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_address_latency_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_address_latency_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_address_latency_mean>.
    //
    pure virtual function automatic int get_stats_read_address_address_latency_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_latency_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_latency_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_latency_step>.
    //
    pure virtual function automatic int get_config_stats_write_latency_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_latency_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_latency_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_latency_multiple>.
    //
    pure virtual function automatic int get_config_stats_write_latency_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_latency_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_latency_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_latency_sw_updated>.
    //
    pure virtual function automatic int get_stats_write_latency_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_data_latency_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_data_latency_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_data_latency_inst>.
    //
    pure virtual function automatic int get_stats_write_address_data_latency_inst(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_data_latency_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_data_latency_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_data_latency_sw>.
    //
    pure virtual function automatic int get_stats_write_address_data_latency_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_data_latency_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_data_latency_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_data_latency_min>.
    //
    pure virtual function automatic int get_stats_write_address_data_latency_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_data_latency_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_data_latency_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_data_latency_max>.
    //
    pure virtual function automatic int get_stats_write_address_data_latency_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_data_latency_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_data_latency_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_data_latency_mean>.
    //
    pure virtual function automatic int get_stats_write_address_data_latency_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_response_latency_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_response_latency_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_response_latency_inst>.
    //
    pure virtual function automatic int get_stats_write_data_response_latency_inst(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_response_latency_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_response_latency_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_response_latency_sw>.
    //
    pure virtual function automatic int get_stats_write_data_response_latency_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_response_latency_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_response_latency_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_response_latency_min>.
    //
    pure virtual function automatic int get_stats_write_data_response_latency_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_response_latency_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_response_latency_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_response_latency_max>.
    //
    pure virtual function automatic int get_stats_write_data_response_latency_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_response_latency_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_response_latency_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_response_latency_mean>.
    //
    pure virtual function automatic int get_stats_write_data_response_latency_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_address_latency_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_address_latency_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_address_latency_inst>.
    //
    pure virtual function automatic int get_stats_write_address_address_latency_inst(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_address_latency_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_address_latency_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_address_latency_sw>.
    //
    pure virtual function automatic int get_stats_write_address_address_latency_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_address_latency_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_address_latency_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_address_latency_min>.
    //
    pure virtual function automatic int get_stats_write_address_address_latency_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_address_latency_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_address_latency_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_address_latency_max>.
    //
    pure virtual function automatic int get_stats_write_address_address_latency_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_address_latency_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_address_latency_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_address_latency_mean>.
    //
    pure virtual function automatic int get_stats_write_address_address_latency_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_address_waits_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_read_address_waits_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_read_address_waits_step>.
    //
    pure virtual function automatic int get_config_stats_read_address_waits_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_read_address_waits_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_read_address_waits_multiple>.
    //
    pure virtual function automatic int get_config_stats_read_address_waits_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_waits_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_waits_inst>.
    //
    pure virtual function automatic int get_stats_read_address_waits_inst(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_waits_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_waits_sw>.
    //
    pure virtual function automatic int get_stats_read_address_waits_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_waits_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_waits_sw_updated>.
    //
    pure virtual function automatic int get_stats_read_address_waits_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_waits_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_waits_min>.
    //
    pure virtual function automatic int get_stats_read_address_waits_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_waits_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_waits_max>.
    //
    pure virtual function automatic int get_stats_read_address_waits_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_waits_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_waits_mean>.
    //
    pure virtual function automatic int get_stats_read_address_waits_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_data_waits_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_read_data_waits_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_read_data_waits_step>.
    //
    pure virtual function automatic int get_config_stats_read_data_waits_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_read_data_waits_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_read_data_waits_multiple>.
    //
    pure virtual function automatic int get_config_stats_read_data_waits_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_waits_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_waits_inst>.
    //
    pure virtual function automatic int get_stats_read_data_waits_inst(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_waits_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_waits_sw>.
    //
    pure virtual function automatic int get_stats_read_data_waits_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_waits_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_waits_sw_updated>.
    //
    pure virtual function automatic int get_stats_read_data_waits_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_waits_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_waits_min>.
    //
    pure virtual function automatic int get_stats_read_data_waits_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_waits_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_waits_max>.
    //
    pure virtual function automatic int get_stats_read_data_waits_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_waits_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_waits_mean>.
    //
    pure virtual function automatic int get_stats_read_data_waits_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_address_waits_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_address_waits_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_address_waits_step>.
    //
    pure virtual function automatic int get_config_stats_write_address_waits_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_address_waits_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_address_waits_multiple>.
    //
    pure virtual function automatic int get_config_stats_write_address_waits_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_waits_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_waits_inst>.
    //
    pure virtual function automatic int get_stats_write_address_waits_inst(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_waits_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_waits_sw>.
    //
    pure virtual function automatic int get_stats_write_address_waits_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_waits_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_waits_sw_updated>.
    //
    pure virtual function automatic int get_stats_write_address_waits_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_waits_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_waits_min>.
    //
    pure virtual function automatic int get_stats_write_address_waits_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_waits_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_waits_max>.
    //
    pure virtual function automatic int get_stats_write_address_waits_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_waits_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_waits_mean>.
    //
    pure virtual function automatic int get_stats_write_address_waits_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_data_waits_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_data_waits_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_data_waits_step>.
    //
    pure virtual function automatic int get_config_stats_write_data_waits_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_data_waits_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_data_waits_multiple>.
    //
    pure virtual function automatic int get_config_stats_write_data_waits_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_waits_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_waits_inst>.
    //
    pure virtual function automatic int get_stats_write_data_waits_inst(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_waits_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_waits_sw>.
    //
    pure virtual function automatic int get_stats_write_data_waits_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_waits_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_waits_sw_updated>.
    //
    pure virtual function automatic int get_stats_write_data_waits_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_waits_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_waits_min>.
    //
    pure virtual function automatic int get_stats_write_data_waits_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_waits_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_waits_max>.
    //
    pure virtual function automatic int get_stats_write_data_waits_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_waits_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_waits_mean>.
    //
    pure virtual function automatic int get_stats_write_data_waits_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_response_waits_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_response_waits_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_response_waits_step>.
    //
    pure virtual function automatic int get_config_stats_write_response_waits_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_response_waits_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_response_waits_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_response_waits_multiple>.
    //
    pure virtual function automatic int get_config_stats_write_response_waits_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_response_waits_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_response_waits_inst>.
    //
    pure virtual function automatic int get_stats_write_response_waits_inst(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_response_waits_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_response_waits_sw>.
    //
    pure virtual function automatic int get_stats_write_response_waits_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_response_waits_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_response_waits_sw_updated>.
    //
    pure virtual function automatic int get_stats_write_response_waits_sw_updated(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_response_waits_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_response_waits_min>.
    //
    pure virtual function automatic int get_stats_write_response_waits_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_response_waits_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_response_waits_max>.
    //
    pure virtual function automatic int get_stats_write_response_waits_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_response_waits_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_response_waits_mean>.
    //
    pure virtual function automatic int get_stats_write_response_waits_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_rw_transaction_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_rw_transaction_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_rw_transaction_last_duration>.
    //
    pure virtual function automatic int get_stats_rw_transaction_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_last_duration>.
    //
    pure virtual function automatic int get_stats_AXI_read_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_last_duration>.
    //
    pure virtual function automatic int get_stats_AXI_write_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_addr_channel_phase_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_addr_channel_phase_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_addr_channel_phase_last_duration>.
    //
    pure virtual function automatic int get_stats_read_addr_channel_phase_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_burst_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_burst_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_burst_last_duration>.
    //
    pure virtual function automatic int get_stats_read_data_burst_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_channel_phase_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_channel_phase_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_channel_phase_last_duration>.
    //
    pure virtual function automatic int get_stats_read_channel_phase_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_addr_channel_phase_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_addr_channel_phase_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_addr_channel_phase_last_duration>.
    //
    pure virtual function automatic int get_stats_write_addr_channel_phase_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_burst_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_burst_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_burst_last_duration>.
    //
    pure virtual function automatic int get_stats_write_data_burst_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_channel_phase_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_channel_phase_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_channel_phase_last_duration>.
    //
    pure virtual function automatic int get_stats_write_channel_phase_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_resp_channel_phase_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_resp_channel_phase_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_resp_channel_phase_last_duration>.
    //
    pure virtual function automatic int get_stats_write_resp_channel_phase_last_duration(  );

    //------------------------------------------------------------------------------
    // Function to get last database handle
    //------------------------------------------------------------------------------

    pure virtual function longint get_last_handle();

    //------------------------------------------------------------------------------
    // Function to get last start time
    //------------------------------------------------------------------------------

    pure virtual function longint get_last_start_time();

    //------------------------------------------------------------------------------
    // Function to get last end time
    //------------------------------------------------------------------------------

    pure virtual function longint get_last_end_time();


    //------------------------------------------------------------------------------
    // Functions to set/get generic interface configuration
    //------------------------------------------------------------------------------

    pure virtual function void set_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0,
        input int arg10 = 0
    );

    pure virtual function int get_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0
    );

    //------------------------------------------------------------------------------
    // Functions to get the hierarchic name of this interface
    //------------------------------------------------------------------------------
    pure virtual function string get_full_name();

    //------------------------------------------------------------------------------
    // Functions to set/get the abstraction levels of interface ends
    //------------------------------------------------------------------------------
    //------------------------------------------------------------------------------
    // Function: axi_set_master_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to set whether the <master> end of the interface is WLM or TLM connected.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels,
    //     how they affect the behaviour of the QVIP, and guidelines for setting them.
    //
    // Parameters:
    //    wire_level - Set to 1 to be WLM connected.
    //    TLM_level -  Set to 1 to be TLM connected.
    //------------------------------------------------------------------------------
    pure virtual function void axi_set_master_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
    //------------------------------------------------------------------------------
    // Function: axi_get_master_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to return the Abstraction level setting for the master end.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels
    //     and how they affect the behaviour of the MVC.
    //
    // Parameters:
    //
    //    wire_level - Value = 1 if this end is WLM connected.
    //    TLM_level -  Value = 1 if this end is TLM connected.
    //------------------------------------------------------------------------------
    pure virtual function void axi_get_master_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    //------------------------------------------------------------------------------
    // Function: axi_set_slave_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to set whether the <slave> end of the interface is WLM or TLM connected.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels,
    //     how they affect the behaviour of the QVIP, and guidelines for setting them.
    //
    // Parameters:
    //    wire_level - Set to 1 to be WLM connected.
    //    TLM_level -  Set to 1 to be TLM connected.
    //------------------------------------------------------------------------------
    pure virtual function void axi_set_slave_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
    //------------------------------------------------------------------------------
    // Function: axi_get_slave_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to return the Abstraction level setting for the slave end.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels
    //     and how they affect the behaviour of the MVC.
    //
    // Parameters:
    //
    //    wire_level - Value = 1 if this end is WLM connected.
    //    TLM_level -  Value = 1 if this end is TLM connected.
    //------------------------------------------------------------------------------
    pure virtual function void axi_get_slave_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    //------------------------------------------------------------------------------
    // Function: axi_set_clock_source_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to set whether the <clock_source> end of the interface is WLM or TLM connected.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels,
    //     how they affect the behaviour of the QVIP, and guidelines for setting them.
    //
    // Parameters:
    //    wire_level - Set to 1 to be WLM connected.
    //    TLM_level -  Set to 1 to be TLM connected.
    //------------------------------------------------------------------------------
    pure virtual function void axi_set_clock_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
    //------------------------------------------------------------------------------
    // Function: axi_get_clock_source_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to return the Abstraction level setting for the clock_source end.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels
    //     and how they affect the behaviour of the MVC.
    //
    // Parameters:
    //
    //    wire_level - Value = 1 if this end is WLM connected.
    //    TLM_level -  Value = 1 if this end is TLM connected.
    //------------------------------------------------------------------------------
    pure virtual function void axi_get_clock_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    //------------------------------------------------------------------------------
    // Function: axi_set_reset_source_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to set whether the <reset_source> end of the interface is WLM or TLM connected.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels,
    //     how they affect the behaviour of the QVIP, and guidelines for setting them.
    //
    // Parameters:
    //    wire_level - Set to 1 to be WLM connected.
    //    TLM_level -  Set to 1 to be TLM connected.
    //------------------------------------------------------------------------------
    pure virtual function void axi_set_reset_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
    //------------------------------------------------------------------------------
    // Function: axi_get_reset_source_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to return the Abstraction level setting for the reset_source end.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels
    //     and how they affect the behaviour of the MVC.
    //
    // Parameters:
    //
    //    wire_level - Value = 1 if this end is WLM connected.
    //    TLM_level -  Value = 1 if this end is TLM connected.
    //------------------------------------------------------------------------------
    pure virtual function void axi_get_reset_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );

    //------------------------------------------------------------------------------
    // Interface end access functions
    //------------------------------------------------------------------------------

    //------------------------------------------------------------------------------
    // Function: get_axi_master_end
    //------------------------------------------------------------------------------
    //
    // Returns:
    //     A handle to the master end of this instance of the <axi> interface.
    //
    pure virtual function longint get_axi_master_end();
    //------------------------------------------------------------------------------
    // Function: get_axi_slave_end
    //------------------------------------------------------------------------------
    //
    // Returns:
    //     A handle to the slave end of this instance of the <axi> interface.
    //
    pure virtual function longint get_axi_slave_end();
    //------------------------------------------------------------------------------
    // Function:- get_axi_clock_source_end
    //------------------------------------------------------------------------------
    //
    // Returns:
    //     A handle to the clock_source end of this instance of the <axi> interface.
    //
    pure virtual function longint get_axi_clock_source_end();
    //------------------------------------------------------------------------------
    // Function:- get_axi_reset_source_end
    //------------------------------------------------------------------------------
    //
    // Returns:
    //     A handle to the reset_source end of this instance of the <axi> interface.
    //
    pure virtual function longint get_axi_reset_source_end();
    //------------------------------------------------------------------------------
    // Function: get_axi__monitor_end
    //------------------------------------------------------------------------------
    //
    // Returns:
    //     A handle to the _monitor end of this instance of the <axi> interface.
    //
    pure virtual function longint get_axi__monitor_end();

    //------------------------------------------------------------------------------
    // Transaction interface
    //------------------------------------------------------------------------------
    pure virtual task automatic dvc_activate_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi_size_e size,
        ref axi_burst_e burst,
        ref axi_lock_e lock,
        ref axi_cache_e cache,
        ref axi_prot_e prot,
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [3:0] burst_length,
        ref bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref axi_response_e resp[],
        ref bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        ref bit [7:0] resp_user,
        ref axi_rw_e read_or_write,
        ref int address_to_data_latency,
        ref int data_to_response_latency,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        ref int address_valid_delay,
        ref int data_valid_delay[],
        ref int write_response_valid_delay,
        ref int address_ready_delay,
        ref int data_ready_delay[],
        ref int write_response_ready_delay,
        ref bit write_data_with_address,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        ref bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref axi_response_e resp[],
        output bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output axi_rw_e read_or_write,
        output int address_to_data_latency,
        output int data_to_response_latency,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        output int address_valid_delay,
        ref int data_valid_delay[],
        output int write_response_valid_delay,
        output int address_ready_delay,
        ref int data_ready_delay[],
        output int write_response_ready_delay,
        output bit write_data_with_address,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_activate_AXI_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi_size_e size,
        ref axi_burst_e burst,
        ref axi_lock_e lock,
        ref axi_cache_e cache,
        ref axi_prot_e prot,
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        ref bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        ref int address_to_data_latency,
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int address_valid_delay,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_AXI_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        output bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        output int address_to_data_latency,
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output int address_valid_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_activate_AXI_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi_size_e size,
        ref axi_burst_e burst,
        ref axi_lock_e lock,
        ref axi_cache_e cache,
        ref axi_prot_e prot,
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [3:0] burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref axi_response_e resp,
        ref bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        ref bit [7:0] resp_user,
        ref int address_to_data_latency,
        ref int data_to_response_latency,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref longint wr_resp_start_time,
        ref longint wr_resp_end_time,
        ref int address_valid_delay,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_AXI_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output axi_response_e resp,
        output bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output int address_to_data_latency,
        output int data_to_response_latency,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output longint wr_resp_start_time,
        output longint wr_resp_end_time,
        output int address_valid_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_activate_data_resp
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref axi_response_e resp,
        ref bit [7:0] data_user [],
        ref bit [7:0] resp_user,
        ref longint data_start,
        ref longint data_end,
        ref longint response_start,
        ref int write_data_beats_delay[],
        ref longint data_beat_start_time[],
        ref longint data_beat_end_time[],
        ref longint response_end_time,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_data_resp
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output axi_response_e resp,
        ref bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output longint data_start,
        output longint data_end,
        output longint response_start,
        ref int write_data_beats_delay[],
        ref longint data_beat_start_time[],
        ref longint data_beat_end_time[],
        output longint response_end_time,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref int write_data_beats_delay[],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref int write_data_beats_delay[],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int data_ready_delay,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int data_ready_delay,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] resp_user,
        input int write_response_ready_delay,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] resp_user,
        output int write_response_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  strb,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  strb,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] resp_user,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] resp_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
    //------------------------------------------------------------------------------
    // Functions to register reports for the interface and interface-ends.
    //------------------------------------------------------------------------------
    //------------------------------------------------------------------------------
    // Tasks for registering reports
    //------------------------------------------------------------------------------
    pure virtual function void register_interface_reporter( input questa_mvc_reporter _rep = null );
    //------------------------------------------------------------------------------
    // Function: register_master_reporter
    //------------------------------------------------------------------------------
    //     Function used to register a reporter for the <master> end of the <axi> interface.
    //     See <Customizing Error-Reporting> for a description of creating, customising and using reporters.
    //
    // Parameters:
    //    rep - The reporter to be used for the master end.
    //------------------------------------------------------------------------------
    pure virtual function void register_master_reporter
    (
        input questa_mvc_reporter rep = null
    );
    //------------------------------------------------------------------------------
    // Function: register_slave_reporter
    //------------------------------------------------------------------------------
    //     Function used to register a reporter for the <slave> end of the <axi> interface.
    //     See <Customizing Error-Reporting> for a description of creating, customising and using reporters.
    //
    // Parameters:
    //    rep - The reporter to be used for the slave end.
    //------------------------------------------------------------------------------
    pure virtual function void register_slave_reporter
    (
        input questa_mvc_reporter rep = null
    );
    //------------------------------------------------------------------------------
    // Function:- register_clock_source_reporter
    //------------------------------------------------------------------------------
    //     Function used to register a reporter for the <clock_source> end of the <axi> interface.
    //     See <Customizing Error-Reporting> for a description of creating, customising and using reporters.
    //
    // Parameters:
    //    rep - The reporter to be used for the clock_source end.
    //------------------------------------------------------------------------------
    pure virtual function void register_clock_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
    //------------------------------------------------------------------------------
    // Function:- register_reset_source_reporter
    //------------------------------------------------------------------------------
    //     Function used to register a reporter for the <reset_source> end of the <axi> interface.
    //     See <Customizing Error-Reporting> for a description of creating, customising and using reporters.
    //
    // Parameters:
    //    rep - The reporter to be used for the reset_source end.
    //------------------------------------------------------------------------------
    pure virtual function void register_reset_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
endclass


typedef bit [1023:0] axi_max_bits_t;

// enum: axi_config_e
//
// An enum which fields corresponding to each configuration parameter of the VIP
//    AXI_CONFIG_SETUP_TIME - 
//         
//             Number of time units for the setup time to the active clock edge of ACLK.
//           
//    AXI_CONFIG_HOLD_TIME - 
//         
//             Number of time units for the hold time to the active clock edge of ACLK.
//           
//    AXI_CONFIG_MAX_TRANSACTION_TIME_FACTOR - 
//          This timeout "config_max_transaction_time_factor" is the timeout that sets the maximum timeout within which any read/write transaction is 
//                expected to occur (and in turn all individual phases as well) of the AXI interface. 
//                This timeout should be set as the maximum duration of read/write. 
//                In short it indicates the maximum duration of a read/write transaction (From start of transaction to end of it).
//                Its default value is 100000 clock cycles
//             
//    AXI_CONFIG_TIMEOUT_MAX_DATA_TRANSFER - 
//          This timeout "config_timeout_max_data_transfer" is actually a configuration which tells about the maximum number of write data beats that the AXI interface
//               can generate as part of write data burst of write transfer. 
//               It is actually not a timeout value and is the maximum number of beats of Write data that are expected. 
//    AXI_CONFIG_BURST_TIMEOUT_FACTOR - 
//         This timeout "config_burst_timeout_factor" represents the maximum delay between the individual phases of the AXI transactions.
//              For example between read address phase and read data phase, write address and Write data phases. 
//              If this delay exceeds between the phases then transaction will be  timed out.
//              Its default value is 10000 clock cycles
//             
//    AXI_CONFIG_MAX_LATENCY_AWVALID_ASSERTION_TO_AWREADY - 
//          A configuration parameter defining the timeout (in clock periods) from the assertion of <AWVALID> to the assertion of <AWREADY> (default 10000).
//         
//         The error message <AXI_AWREADY_NOT_ASSERTED_AFTER_AWVALID> will be issued if this period elapses from the assertion of <AWVALID>.
//         
//    AXI_CONFIG_MAX_LATENCY_ARVALID_ASSERTION_TO_ARREADY - 
//          A configuration parameter defining the timeout (in clock periods) from the assertion of <ARVALID> to the assertion of <ARREADY> (default 10000).
//         
//         The error message <AXI_ARREADY_NOT_ASSERTED_AFTER_ARVALID> will be issued if this period elapses from the assertion of <ARVALID>.
//         
//    AXI_CONFIG_MAX_LATENCY_RVALID_ASSERTION_TO_RREADY - 
//          A configuration parameter defining the timeout (in clock periods) from the assertion of <RVALID> to the assertion of <RREADY> (default 10000).
//         
//         The error message <AXI_RREADY_NOT_ASSERTED_AFTER_RVALID> will be issued if this period elapses from the assertion of <RVALID>.
//         
//    AXI_CONFIG_MAX_LATENCY_BVALID_ASSERTION_TO_BREADY - 
//          A configuration parameter defining the timeout (in clock periods) from the assertion of <BVALID> to the assertion of <BREADY> (default 10000).
//         
//         The error message <AXI_BREADY_NOT_ASSERTED_AFTER_BVALID> will be issued if this period elapses from the assertion of <BVALID>.
//         
//    AXI_CONFIG_MAX_LATENCY_WVALID_ASSERTION_TO_WREADY - 
//          A configuration parameter defining the timeout (in clock periods) from the assertion of <WVALID> to the assertion of <WREADY> (default 10000).
//         
//         The error message <AXI_WREADY_NOT_ASSERTED_AFTER_WVALID> will be issued if this period elapses from the assertion of <WVALID>.
//         
//    AXI_CONFIG_WRITE_CTRL_TO_DATA_MINTIME -  Number of clocks from the start of control to the start of data in a write. This configuration parameter has been deprecated and maintained for backward compatibility. Instead use write_address_to_data_delay variable to control delay between write address phase and write data phase.
//    AXI_CONFIG_MASTER_WRITE_DELAY -  To configure the write sequence item delays to be inserted.
//    AXI_CONFIG_ENABLE_ALL_ASSERTIONS - 
//         
//           Configuration parameter controlling whether the error messages(Assertions) issued from the QVIP are Enabled or Disabled.  
//           By default, it is enabled.
//         
//    AXI_CONFIG_ENABLE_ASSERTION - 
//         
//           An array of configuration parameters controlling whether specific error messages(Assertion) (of type <axi_assertion_type_e>)
//           can be issued by the QVIP. By default, all errors are enabled. To suppress a particular error, set the corresponding bit to 0.
//           e.g. config.m_bfm.set_config_enable_error_index1(AXI_RESET_SIGNAL_Z, 0);
//         
//    AXI_CONFIG_SLAVE_START_ADDR - 
//         
//            A configuration parameter indicating start address for slave.
//           
//    AXI_CONFIG_SLAVE_END_ADDR - 
//         
//            A configuration parameter indicating end address for slave.
//           
//    AXI_CONFIG_READ_DATA_REORDERING_DEPTH - 
//         
//            A configuration parameter defining the read reordering depth of the slave end of the interface (SPEC3(A5.3.1)).
//         
//            Responses from the first <config_read_data_reordering_depth> outstanding read transactions, each with address <ARID> values different from any
//            earlier outstanding read transaction(as seen by the slave) are expected, interleaved at random. A violation causes a <AXI_READ_REORDERING_VIOLATION> error.
//         
//            The default value of <config_read_data_reordering_depth> is (1 << AXI_ID_WIDTH), so that the slave is expected to process all transactions in any order (up to uniqueness of <ARID>).
//         
//            For a given <AXI_ID_WIDTH> parameter value, the maximum possible value of <config_read_data_reordering_depth> is 2**AXI_ID_WIDTH. The <AXI_PARAM_READ_REORDERING_DEPTH_EXCEEDS_MAX_ID>
//            error report will be issued if <config_read_data_reordering_depth> exceeds this value.
//         
//            If the user-supplied value is 0, the <AXI4_PARAM_READ_REORDERING_DEPTH_EQUALS_ZERO> error will be issued, and the value will be set to 1.
//           
//    AXI_CONFIG_MASTER_ERROR_POSITION - 
//         
//             To confgure the type of Master Error.
//           
//    AXI_CONFIG_SUPPORT_EXCLUSIVE_ACCESS - 
//         
//             This configures the support for exclusive slave.
//             If set, it enables the exclusive support in slave.
//             If cleared, it disables the exclusive support and every exclusive read/write will return OKAY response and 
//             exclusive write will update the memory.  
//           

typedef enum bit [7:0]
{
    AXI_CONFIG_SETUP_TIME                    = 8'd0,
    AXI_CONFIG_HOLD_TIME                     = 8'd1,
    AXI_CONFIG_MAX_TRANSACTION_TIME_FACTOR   = 8'd2,
    AXI_CONFIG_TIMEOUT_MAX_DATA_TRANSFER     = 8'd3,
    AXI_CONFIG_BURST_TIMEOUT_FACTOR          = 8'd4,
    AXI_CONFIG_MAX_LATENCY_AWVALID_ASSERTION_TO_AWREADY = 8'd5,
    AXI_CONFIG_MAX_LATENCY_ARVALID_ASSERTION_TO_ARREADY = 8'd6,
    AXI_CONFIG_MAX_LATENCY_RVALID_ASSERTION_TO_RREADY = 8'd7,
    AXI_CONFIG_MAX_LATENCY_BVALID_ASSERTION_TO_BREADY = 8'd8,
    AXI_CONFIG_MAX_LATENCY_WVALID_ASSERTION_TO_WREADY = 8'd9,
    AXI_CONFIG_WRITE_CTRL_TO_DATA_MINTIME    = 8'd10,
    AXI_CONFIG_MASTER_WRITE_DELAY            = 8'd11,
    AXI_CONFIG_ENABLE_ALL_ASSERTIONS         = 8'd12,
    AXI_CONFIG_ENABLE_ASSERTION              = 8'd13,
    AXI_CONFIG_SLAVE_START_ADDR              = 8'd14,
    AXI_CONFIG_SLAVE_END_ADDR                = 8'd15,
    AXI_CONFIG_READ_DATA_REORDERING_DEPTH    = 8'd16,
    AXI_CONFIG_MASTER_ERROR_POSITION         = 8'd17,
    AXI_CONFIG_SUPPORT_EXCLUSIVE_ACCESS      = 8'd18,
    AXI_CONFIG_MAX_OUTSTANDING_WR            = 8'd19,
    AXI_CONFIG_MAX_OUTSTANDING_RD            = 8'd20
} axi_config_e;

// enum: axi_vhd_if_e
//
// For VHDL use only
typedef enum int
{
    AXI_VHD_SET_CONFIG                         = 32'd0,
    AXI_VHD_GET_CONFIG                         = 32'd1,
    AXI_VHD_CREATE_WRITE_TRANSACTION           = 32'd2,
    AXI_VHD_CREATE_READ_TRANSACTION            = 32'd3,
    AXI_VHD_SET_ADDR                           = 32'd4,
    AXI_VHD_GET_ADDR                           = 32'd5,
    AXI_VHD_SET_SIZE                           = 32'd6,
    AXI_VHD_GET_SIZE                           = 32'd7,
    AXI_VHD_SET_BURST                          = 32'd8,
    AXI_VHD_GET_BURST                          = 32'd9,
    AXI_VHD_SET_LOCK                           = 32'd10,
    AXI_VHD_GET_LOCK                           = 32'd11,
    AXI_VHD_SET_CACHE                          = 32'd12,
    AXI_VHD_GET_CACHE                          = 32'd13,
    AXI_VHD_SET_PROT                           = 32'd14,
    AXI_VHD_GET_PROT                           = 32'd15,
    AXI_VHD_SET_ID                             = 32'd16,
    AXI_VHD_GET_ID                             = 32'd17,
    AXI_VHD_SET_BURST_LENGTH                   = 32'd18,
    AXI_VHD_GET_BURST_LENGTH                   = 32'd19,
    AXI_VHD_SET_DATA_WORDS                     = 32'd20,
    AXI_VHD_GET_DATA_WORDS                     = 32'd21,
    AXI_VHD_SET_WRITE_STROBES                  = 32'd22,
    AXI_VHD_GET_WRITE_STROBES                  = 32'd23,
    AXI_VHD_SET_RESP                           = 32'd24,
    AXI_VHD_GET_RESP                           = 32'd25,
    AXI_VHD_SET_ADDR_USER                      = 32'd26,
    AXI_VHD_GET_ADDR_USER                      = 32'd27,
    AXI_VHD_SET_READ_OR_WRITE                  = 32'd28,
    AXI_VHD_GET_READ_OR_WRITE                  = 32'd29,
    AXI_VHD_SET_ADDRESS_VALID_DELAY            = 32'd30,
    AXI_VHD_GET_ADDRESS_VALID_DELAY            = 32'd31,
    AXI_VHD_SET_DATA_VALID_DELAY               = 32'd32,
    AXI_VHD_GET_DATA_VALID_DELAY               = 32'd33,
    AXI_VHD_SET_WRITE_RESPONSE_VALID_DELAY     = 32'd34,
    AXI_VHD_GET_WRITE_RESPONSE_VALID_DELAY     = 32'd35,
    AXI_VHD_SET_ADDRESS_READY_DELAY            = 32'd36,
    AXI_VHD_GET_ADDRESS_READY_DELAY            = 32'd37,
    AXI_VHD_SET_DATA_READY_DELAY               = 32'd38,
    AXI_VHD_GET_DATA_READY_DELAY               = 32'd39,
    AXI_VHD_SET_WRITE_RESPONSE_READY_DELAY     = 32'd40,
    AXI_VHD_GET_WRITE_RESPONSE_READY_DELAY     = 32'd41,
    AXI_VHD_SET_GEN_WRITE_STROBES              = 32'd42,
    AXI_VHD_GET_GEN_WRITE_STROBES              = 32'd43,
    AXI_VHD_SET_OPERATION_MODE                 = 32'd44,
    AXI_VHD_GET_OPERATION_MODE                 = 32'd45,
    AXI_VHD_SET_DELAY_MODE                     = 32'd46,
    AXI_VHD_GET_DELAY_MODE                     = 32'd47,
    AXI_VHD_SET_WRITE_DATA_MODE                = 32'd48,
    AXI_VHD_GET_WRITE_DATA_MODE                = 32'd49,
    AXI_VHD_SET_DATA_BEAT_DONE                 = 32'd50,
    AXI_VHD_GET_DATA_BEAT_DONE                 = 32'd51,
    AXI_VHD_SET_TRANSACTION_DONE               = 32'd52,
    AXI_VHD_GET_TRANSACTION_DONE               = 32'd53,
    AXI_VHD_EXECUTE_TRANSACTION                = 32'd54,
    AXI_VHD_GET_RW_TRANSACTION                 = 32'd55,
    AXI_VHD_EXECUTE_READ_DATA_BURST            = 32'd56,
    AXI_VHD_GET_READ_DATA_BURST                = 32'd57,
    AXI_VHD_EXECUTE_WRITE_DATA_BURST           = 32'd58,
    AXI_VHD_GET_WRITE_DATA_BURST               = 32'd59,
    AXI_VHD_EXECUTE_READ_ADDR_PHASE            = 32'd60,
    AXI_VHD_GET_READ_ADDR_PHASE                = 32'd61,
    AXI_VHD_EXECUTE_READ_DATA_PHASE            = 32'd62,
    AXI_VHD_GET_READ_DATA_PHASE                = 32'd63,
    AXI_VHD_EXECUTE_WRITE_ADDR_PHASE           = 32'd64,
    AXI_VHD_GET_WRITE_ADDR_PHASE               = 32'd65,
    AXI_VHD_EXECUTE_WRITE_DATA_PHASE           = 32'd66,
    AXI_VHD_GET_WRITE_DATA_PHASE               = 32'd67,
    AXI_VHD_EXECUTE_WRITE_RESPONSE_PHASE       = 32'd68,
    AXI_VHD_GET_WRITE_RESPONSE_PHASE           = 32'd69,
    AXI_VHD_CREATE_MONITOR_TRANSACTION         = 32'd70,
    AXI_VHD_CREATE_SLAVE_TRANSACTION           = 32'd71,
    AXI_VHD_PUSH_TRANSACTION_ID                = 32'd72,
    AXI_VHD_POP_TRANSACTION_ID                 = 32'd73,
    AXI_VHD_GET_WRITE_ADDR_DATA                = 32'd74,
    AXI_VHD_GET_READ_ADDR                      = 32'd75,
    AXI_VHD_SET_READ_DATA                      = 32'd76,
    AXI_VHD_PRINT                              = 32'd77,
    AXI_VHD_DESTRUCT_TRANSACTION               = 32'd78,
    AXI_VHD_WAIT_ON                            = 32'd79
} axi_vhd_if_e;


typedef enum bit [7:0]
{
    AXI_CLOCK_POSEDGE = 8'd0,
    AXI_CLOCK_NEGEDGE = 8'd1,
    AXI_CLOCK_ANYEDGE = 8'd2,
    AXI_CLOCK_0_TO_1  = 8'd3,
    AXI_CLOCK_1_TO_0  = 8'd4,
    AXI_RESET_POSEDGE = 8'd5,
    AXI_RESET_NEGEDGE = 8'd6,
    AXI_RESET_ANYEDGE = 8'd7,
    AXI_RESET_0_TO_1  = 8'd8,
    AXI_RESET_1_TO_0  = 8'd9
} axi_wait_e;

`ifndef MAX_AXI_ADDRESS_WIDTH
  `define MAX_AXI_ADDRESS_WIDTH 64
`endif

`ifndef MAX_AXI_RDATA_WIDTH
  `define MAX_AXI_RDATA_WIDTH 1024
`endif

`ifndef MAX_AXI_WDATA_WIDTH
  `define MAX_AXI_WDATA_WIDTH 1024
`endif

`ifndef MAX_AXI_ID_WIDTH
  `define MAX_AXI_ID_WIDTH 18
`endif

// enum: axi_operation_mode_e
//
typedef enum int
{
    AXI_TRANSACTION_NON_BLOCKING = 32'd0,
    AXI_TRANSACTION_BLOCKING     = 32'd1
} axi_operation_mode_e;

// enum: axi_delay_mode_e
//
typedef enum int
{
    AXI_VALID2READY = 32'd0,
    AXI_TRANS2READY = 32'd1
} axi_delay_mode_e;

// enum: axi_write_data_mode_e
//
typedef enum int
{
    AXI_DATA_AFTER_ADDRESS = 32'd0,
    AXI_DATA_WITH_ADDRESS  = 32'd1
} axi_write_data_mode_e;

// Global Transaction Class
class axi_transaction;
    // Protocol 
    bit [((`MAX_AXI_ADDRESS_WIDTH) - 1):0]  addr;
    axi_size_e size;
    axi_burst_e burst;
    axi_lock_e lock;
    axi_cache_e cache;
    axi_prot_e prot;
    bit [((`MAX_AXI_ID_WIDTH) - 1):0]  id;
    bit [3:0] burst_length;
    bit [((((`MAX_AXI_RDATA_WIDTH > `MAX_AXI_WDATA_WIDTH) ? `MAX_AXI_RDATA_WIDTH : `MAX_AXI_WDATA_WIDTH)) - 1):0] data_words [];
    bit [(((`MAX_AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [];
    axi_response_e resp[];
    bit [7:0] addr_user;
    axi_rw_e read_or_write;
    int address_valid_delay;
    int data_valid_delay[];
    int write_response_valid_delay;
    int address_ready_delay;
    int data_ready_delay[];
    int write_response_ready_delay;

    // Housekeeping
    bit gen_write_strobes = 1'b1;
    axi_operation_mode_e  operation_mode  = AXI_TRANSACTION_BLOCKING;
    axi_delay_mode_e      delay_mode      = AXI_VALID2READY;
    axi_write_data_mode_e write_data_mode = AXI_DATA_AFTER_ADDRESS;
    bit data_beat_done[];
    bit transaction_done;

    // This varaible is for printing component name and should not be visible/documented
    string driver_name;

    function void set_addr( input bit [((`MAX_AXI_ADDRESS_WIDTH) - 1):0]  laddr );
      addr = laddr;
    endfunction

    function bit [((`MAX_AXI_ADDRESS_WIDTH) - 1):0]   get_addr();
      return addr;
    endfunction

    function void set_size( input axi_size_e lsize );
      size = lsize;
    endfunction

    function axi_size_e get_size();
      return size;
    endfunction

    function void set_burst( input axi_burst_e lburst );
      burst = lburst;
    endfunction

    function axi_burst_e get_burst();
      return burst;
    endfunction

    function void set_lock( input axi_lock_e llock );
      lock = llock;
    endfunction

    function axi_lock_e get_lock();
      return lock;
    endfunction

    function void set_cache( input axi_cache_e lcache );
      cache = lcache;
    endfunction

    function axi_cache_e get_cache();
      return cache;
    endfunction

    function void set_prot( input axi_prot_e lprot );
      prot = lprot;
    endfunction

    function axi_prot_e get_prot();
      return prot;
    endfunction

    function void set_id( input bit [((`MAX_AXI_ID_WIDTH) - 1):0]  lid );
      id = lid;
    endfunction

    function bit [((`MAX_AXI_ID_WIDTH) - 1):0]   get_id();
      return id;
    endfunction

    function void set_burst_length( input bit [3:0] lburst_length );
      burst_length = lburst_length;
      data_words           = new[(lburst_length + 1)];
      write_strobes        = new[(lburst_length + 1)];
      resp                 = new[(lburst_length + 1)];
      data_valid_delay     = new[(lburst_length + 1)];
      data_ready_delay     = new[(lburst_length + 1)];
      data_beat_done       = new[(lburst_length + 1)];
    endfunction

    function bit [3:0]  get_burst_length();
      return burst_length;
    endfunction

    function void set_data_words( input bit [((((`MAX_AXI_RDATA_WIDTH > `MAX_AXI_WDATA_WIDTH) ? `MAX_AXI_RDATA_WIDTH : `MAX_AXI_WDATA_WIDTH)) - 1):0] ldata_words, input int index = 0 );
      data_words[index] = ldata_words;
    endfunction

    function bit [((((`MAX_AXI_RDATA_WIDTH > `MAX_AXI_WDATA_WIDTH) ? `MAX_AXI_RDATA_WIDTH : `MAX_AXI_WDATA_WIDTH)) - 1):0]  get_data_words( input int index = 0 );
      return data_words[index];
    endfunction

    function void set_write_strobes( input bit [(((`MAX_AXI_WDATA_WIDTH / 8)) - 1):0] lwrite_strobes, input int index = 0 );
      write_strobes[index] = lwrite_strobes;
    endfunction

    function bit [(((`MAX_AXI_WDATA_WIDTH / 8)) - 1):0]  get_write_strobes( input int index = 0 );
      return write_strobes[index];
    endfunction

    function void set_resp( input axi_response_e lresp, input int index = 0 );
      resp[index] = lresp;
    endfunction

    function axi_response_e get_resp( input int index = 0 );
      return resp[index];
    endfunction

    function void set_addr_user( input bit [7:0] laddr_user );
      addr_user = laddr_user;
    endfunction

    function bit [7:0]  get_addr_user();
      return addr_user;
    endfunction

    function void set_read_or_write( input axi_rw_e lread_or_write );
      read_or_write = lread_or_write;
    endfunction

    function axi_rw_e get_read_or_write();
      return read_or_write;
    endfunction

    function void set_address_valid_delay( input int laddress_valid_delay );
      address_valid_delay = laddress_valid_delay;
    endfunction

    function int get_address_valid_delay();
      return address_valid_delay;
    endfunction

    function void set_data_valid_delay( input int ldata_valid_delay, input int index = 0 );
      data_valid_delay[index] = ldata_valid_delay;
    endfunction

    function int get_data_valid_delay( input int index = 0 );
      return data_valid_delay[index];
    endfunction

    function void set_write_response_valid_delay( input int lwrite_response_valid_delay );
      write_response_valid_delay = lwrite_response_valid_delay;
    endfunction

    function int get_write_response_valid_delay();
      return write_response_valid_delay;
    endfunction

    function void set_address_ready_delay( input int laddress_ready_delay );
      address_ready_delay = laddress_ready_delay;
    endfunction

    function int get_address_ready_delay();
      return address_ready_delay;
    endfunction

    function void set_data_ready_delay( input int ldata_ready_delay, input int index = 0 );
      data_ready_delay[index] = ldata_ready_delay;
    endfunction

    function int get_data_ready_delay( input int index = 0 );
      return data_ready_delay[index];
    endfunction

    function void set_write_response_ready_delay( input int lwrite_response_ready_delay );
      write_response_ready_delay = lwrite_response_ready_delay;
    endfunction

    function int get_write_response_ready_delay();
      return write_response_ready_delay;
    endfunction

    function void set_gen_write_strobes( input bit lgen_write_strobes);
      gen_write_strobes = lgen_write_strobes;
    endfunction

    function bit get_gen_write_strobes();
      return gen_write_strobes;
    endfunction

    function void set_operation_mode( input axi_operation_mode_e loperation_mode );
      operation_mode = loperation_mode;
    endfunction

    function axi_operation_mode_e get_operation_mode();
      return operation_mode;
    endfunction

    function void set_delay_mode( input axi_delay_mode_e ldelay_mode );
      delay_mode = ldelay_mode;
    endfunction

    function axi_delay_mode_e get_delay_mode();
      return delay_mode;
    endfunction

    function void set_write_data_mode( input axi_write_data_mode_e lwrite_data_mode );
      write_data_mode = lwrite_data_mode;
    endfunction

    function axi_write_data_mode_e get_write_data_mode();
      return write_data_mode;
    endfunction

    function void set_data_beat_done( input int ldata_beat_done, input int index = 0 );
      data_beat_done[index] = ldata_beat_done;
    endfunction

    function int get_data_beat_done( input int index = 0 );
      return data_beat_done[index];
    endfunction

    function void set_transaction_done( input int ltransaction_done );
      transaction_done = ltransaction_done;
    endfunction

    function int get_transaction_done();
      return transaction_done;
    endfunction

    // Function: do_print
    //
    // Prints axi_transaction transaction attributes
    function void print (bit print_delays = 1'b0);
      $display("------------------------------------------------------------------------");
      $display("%0t: %s axi_transaction", $time, driver_name);
      $display("------------------------------------------------------------------------");
      $display("addr : 'h%h", addr);
      $display("size : %s", size.name());
      $display("burst : %s", burst.name());
      $display("lock : %s", lock.name());
      $display("cache : %s", cache.name());
      $display("prot : %s", prot.name());
      $display("id : 'h%h", id);
      $display("burst_length : 'h%h", burst_length);
      foreach( data_words[i0_1] )
        $display("data_words[%0d] : 'h%h", i0_1, data_words[i0_1]);
      foreach( write_strobes[i0_1] )
        $display("write_strobes[%0d] : 'h%h", i0_1, write_strobes[i0_1]);
      foreach( resp[i0_1] )
        $display("resp[%0d] : %s", i0_1, resp[i0_1].name());
      $display("addr_user : 'h%h", addr_user);
      $display("read_or_write : %s", read_or_write.name());
      $display("gen_write_strobes : 'b%b", gen_write_strobes );
      $display("operation_mode   : %s", operation_mode.name() );
      $display("delay_mode       : %s", delay_mode.name() );
      $display("write_data_mode  : %s", write_data_mode.name() );
      foreach( data_beat_done[i0_1] )
        $display("data_beat_done[%0d] : 'b%b", i0_1, data_beat_done[i0_1] );
      $display("transaction_done : 'b%b", transaction_done );
      if ( print_delays == 1'b1 )
      begin
        $display("address_valid_delay : %0d", address_valid_delay);
        foreach( data_valid_delay[i0_1] )
          $display("data_valid_delay[%0d] : %0d", i0_1, data_valid_delay[i0_1]);
        $display("write_response_valid_delay : %0d", write_response_valid_delay);
        $display("address_ready_delay : %0d", address_ready_delay);
        foreach( data_ready_delay[i0_1] )
          $display("data_ready_delay[%0d] : %0d", i0_1, data_ready_delay[i0_1]);
        $display("write_response_ready_delay : %0d", write_response_ready_delay);
      end
    endfunction
endclass

`endif // MODEL_TECH
endpackage

import mgc_axi_pkg::*;
`ifdef MODEL_TECH
// *****************************************************************************
//
// Copyright 2007-2013 Mentor Graphics Corporation
// All Rights Reserved.
//
// THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION WHICH IS THE PROPERTY OF
// MENTOR GRAPHICS CORPORATION OR ITS LICENSORS AND IS SUBJECT TO LICENSE TERMS.
//
// *****************************************************************************
// SystemVerilog           Version: 20130911_Questa_10.2c
// *****************************************************************************

// Title: axi
//

import QUESTA_MVC::questa_mvc_reporter;
import QUESTA_MVC::questa_mvc_item_comms_semantic;
import QUESTA_MVC::questa_mvc_edge;
import QUESTA_MVC::QUESTA_MVC_POSEDGE;
import QUESTA_MVC::QUESTA_MVC_NEGEDGE;
import QUESTA_MVC::QUESTA_MVC_ANYEDGE;
import QUESTA_MVC::QUESTA_MVC_0_TO_1_EDGE;
import QUESTA_MVC::QUESTA_MVC_1_TO_0_EDGE;

//------------------------------------------------------------------------------
//
// Interface:- axi
//
//------------------------------------------------------------------------------
//  This interface contains all the wires and BFM configuration variables.
// 
// For all Configuration variables set/get/wait functions are available in the
// interface.
// 
// For e.g.
// 
// bit config_master_write_delay:
// 
// >   function void set_config_master_write_delay( bit arg1 )
// >
// >   function bit get_config_master_write_delay()
// >
// >   task wait_for_config_master_write_delay()
// 
// bit [255:0] config_enable_assertion:
// 
// >     task wait_for_config_enable_assertion()
// >     
// >     task wait_for_config_enable_assertion_index1( input int _this_dot_1 )
// >     
// >     function void set_config_enable_assertion( bit [255:0] arg2 )
// >     
// >     function set_config_enable_assertion_index1( int _this_dot_1, bit  arg3 )
// >     
// >     function bit [255:0]  get_config_enable_assertion()
// >     
// >     function bit get_config_enable_assertion_index1( int _this_dot_1 ) 
// >
// 
//------------------------------------------------------------------------------
(* cy_so="libaxi_IN_SystemVerilog_MTI_full" *)
(* on_lib_load="axi_IN_SystemVerilog_load" *)
interface mgc_common_axi
    #(int AXI_ADDRESS_WIDTH = 64, int AXI_RDATA_WIDTH = 1024, int AXI_WDATA_WIDTH = 1024, int AXI_ID_WIDTH = 18)
    (input wire iACLK, input wire iARESETn);
    // Constant: AXI_ADDRESS_WIDTH
    //
    // The width of the AWADDR and ARADDR signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2).
    //

    // Constant: AXI_RDATA_WIDTH
    //
    // The width of the RDATA signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6).
    //

    // Constant: AXI_WDATA_WIDTH
    //
    // The width of the WDATA signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.3).
    //

    // Constant: AXI_ID_WIDTH
    //
    // The width of the AWID, ARID, WID, RID and BID signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2).
    //

    //------------------------------------------------------------------------------
    //
    // Wires for interface: axi
    //
    //------------------------------------------------------------------------------

    // Wire: ACLK
    //
    //------------------------------------------------------------------------------
    // 
    //       Global Clock Signal
    //     
    //------------------------------------------------------------------------------
    wire ACLK;

    // Wire: ARESETn
    //
    //------------------------------------------------------------------------------
    // 
    //       Global Reset Signal. This signal is Active Low.
    //     
    //------------------------------------------------------------------------------
    wire ARESETn;

    // Wire: AWVALID
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Address Valid. 
    // 
    //       The source of this signal is Master and this signal indicates 
    //       that valid write address and control information are available.
    //     
    //------------------------------------------------------------------------------
    wire AWVALID;

    // Wire: AWADDR
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Address Signal.
    // 
    //       The source of this signal is Master.
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_ADDRESS_WIDTH) - 1):0]  AWADDR;

    // Wire: AWLEN
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Burst Length Signal.
    // 
    //       The source of this signal is Master.
    //       The width of this signal is set to 10 by default. If the signal width of 4 is required, a wrapper can be made over the dut to do so.
    //     
    //------------------------------------------------------------------------------
    wire [3:0] AWLEN;

    // Wire: AWSIZE
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Burst Size Signal.
    // 
    //       The source of this signal is Master.
    //     
    //------------------------------------------------------------------------------
    wire [2:0] AWSIZE;

    // Wire: AWBURST
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Burst Type Signal.
    // 
    //       The source of this signal is Master.
    //     
    //------------------------------------------------------------------------------
    wire [1:0] AWBURST;

    // Wire: AWLOCK
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Lock Type Signal. 
    // 
    //       The source of this signal is Master and this signal provides the 
    //       atomic characteristics of the transfer.
    //     
    //------------------------------------------------------------------------------
    wire [1:0] AWLOCK;

    // Wire: AWCACHE
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Cache type Signal. 
    // 
    //       The source of this signal is Master and this signal indicates the 
    //       bufferable, cacheable, write-through, write-back, and allocate 
    //       attributes of the transaction.
    //     
    //------------------------------------------------------------------------------
    wire [3:0] AWCACHE;

    // Wire: AWPROT
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Protection Type Signal. 
    // 
    //       The source of this signal is Master and this signal indicates the 
    //       normal, privileged, or secure protection level of the transaction 
    //       and whether it is a data access or instruction access.
    //     
    //------------------------------------------------------------------------------
    wire [2:0] AWPROT;

    // Wire: AWID
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Address ID.
    // 
    //       The source of this signal is Master and this signal is the 
    //       identification tag for the write address group of signals.
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_ID_WIDTH) - 1):0]  AWID;

    // Wire: AWREADY
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Address Ready Signal.
    // 
    //       The source of this signal is Slave and this signal indicates that 
    //       the valid write address and control information are available.
    //     
    //------------------------------------------------------------------------------
    wire AWREADY;

    // Wire: AWUSER
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Address User Signal.
    //     
    //------------------------------------------------------------------------------
    wire [7:0] AWUSER;

    // Wire: ARVALID
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Address Valid. 
    // 
    //       The source of this signal is Master and this signal indicates that 
    //       valid write address and control information are available.
    //     
    //------------------------------------------------------------------------------
    wire ARVALID;

    // Wire: ARADDR
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Address Signal.
    // 
    //       The source of this signal is Master.
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_ADDRESS_WIDTH) - 1):0]  ARADDR;

    // Wire: ARLEN
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Burst Length Signal.
    // 
    //       The source of this signal is Master.
    //       The width of this signal is set to 10 by default. If the signal width of 4 is required, a wrapper can be made over the dut to do so.
    //     
    //------------------------------------------------------------------------------
    wire [3:0] ARLEN;

    // Wire: ARSIZE
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Burst Size Signal.
    // 
    //       The source of this signal is Master.
    //     
    //------------------------------------------------------------------------------
    wire [2:0] ARSIZE;

    // Wire: ARBURST
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Burst Type Signal.
    // 
    //       The source of this signal is Master.
    //     
    //------------------------------------------------------------------------------
    wire [1:0] ARBURST;

    // Wire: ARLOCK
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Lock Type Signal. 
    // 
    //       The source of this signal is Master and this signal provides the 
    //       atomic characteristics of the transfer.
    //     
    //------------------------------------------------------------------------------
    wire [1:0] ARLOCK;

    // Wire: ARCACHE
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Cache type Signal. 
    // 
    //       The source of this signal is Master and this signal indicates the 
    //       bufferable, cacheable, write-through, write-back, and allocate 
    //       attributes of the transaction.
    //     
    //------------------------------------------------------------------------------
    wire [3:0] ARCACHE;

    // Wire: ARPROT
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Protection Type Signal. 
    // 
    //       The source of this signal is Master and this signal indicates the 
    //       normal, privileged, or secure protection level of the transaction 
    //       and whether it is a data access or instruction access.
    //     
    //------------------------------------------------------------------------------
    wire [2:0] ARPROT;

    // Wire: ARID
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Address ID.
    // 
    //       The source of this signal is Master and this signal is the 
    //       identification tag for the write address group of signals.
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_ID_WIDTH) - 1):0]  ARID;

    // Wire: ARREADY
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Address Ready Signal.
    // 
    //       The source of this signal is Slave and this signal indicates that 
    //       the valid write address and control information are available.
    //     
    //------------------------------------------------------------------------------
    wire ARREADY;

    // Wire: ARUSER
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Address User Signal.
    //     
    //------------------------------------------------------------------------------
    wire [7:0] ARUSER;

    // Wire: RVALID
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Valid Signal.
    // 
    //       The source of this signal is Slave and this signal indicates that 
    //       the read data is available and read transfer can complete.
    //     
    //------------------------------------------------------------------------------
    wire RVALID;

    // Wire: RLAST
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Last Signal.
    // 
    //       The source of this signal is Slave and this signal indicates 
    //       the last transfer in the read burst.
    //     
    //------------------------------------------------------------------------------
    wire RLAST;

    // Wire: RDATA
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Data Signal.
    // 
    //       The source of this signal is Slave and the read data bus can be 
    //       8, 16, 24, 32, 64, 128, 256, 512 or 1024 bits wide. 
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_RDATA_WIDTH) - 1):0]  RDATA;

    // Wire: RRESP
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Response Signal.
    // 
    //       The source of this signal is Slave and it indicates the status of read transfer.
    //       The allowable responses are OKAY, EXOKAY, SLVERR and DECERR. 
    //     
    //------------------------------------------------------------------------------
    wire [1:0] RRESP;

    // Wire: RID
    //
    //------------------------------------------------------------------------------
    // 
    //       Read ID Tag Signal.
    // 
    //       The source of this signal is Slave and it is the ID tag of the read data 
    //       group of signals.
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_ID_WIDTH) - 1):0]  RID;

    // Wire: RREADY
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Ready Signal.
    // 
    //       The source of this signal is Master and it indicates that the Master can
    //       accept the read data and response information.
    //     
    //------------------------------------------------------------------------------
    wire RREADY;

    // Wire: RUSER
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Data User Signal.
    //     
    //------------------------------------------------------------------------------
    wire [7:0] RUSER;

    // Wire: WVALID
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Valid Signal.
    // 
    //       The source of this signal is Master and this signal indicates that 
    //       the read data is available and read transfer can complete.
    //     
    //------------------------------------------------------------------------------
    wire WVALID;

    // Wire: WLAST
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Last Signal.
    // 
    //       The source of this signal is Master and this signal indicates 
    //       the last transfer in the read burst.
    //     
    //------------------------------------------------------------------------------
    wire WLAST;

    // Wire: WDATA
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Data Signal.
    // 
    //       The source of this signal is Master and the read data bus can be 
    //       8, 16, 24, 32, 64, 128, 256, 512 or 1024 bits wide. 
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_WDATA_WIDTH) - 1):0]  WDATA;

    // Wire: WSTRB
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Strobes Signal.
    // 
    //       The source of this signal is Master and this signal indicates which 
    //       byte lanes to update in the memory.
    //     
    //------------------------------------------------------------------------------
    wire [(((AXI_WDATA_WIDTH / 8)) - 1):0]  WSTRB;

    // Wire: WID
    //
    //------------------------------------------------------------------------------
    // 
    //       Write ID Tag Signal.
    // 
    //       The source of this signal is Master and it is the ID tag of the write 
    //       data transfer.
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_ID_WIDTH) - 1):0]  WID;

    // Wire: WREADY
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Ready Signal.
    // 
    //       The source of this signal is Slave and it indicates that the Slave can
    //       accept the write data.
    //     
    //------------------------------------------------------------------------------
    wire WREADY;

    // Wire: WUSER
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Data User Signal.
    //     
    //------------------------------------------------------------------------------
    wire [7:0] WUSER;

    // Wire: BVALID
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Response Valid Signal.
    // 
    //       The source of this signal is Slave and it indicates that a valid write
    //       response is available.
    //     
    //------------------------------------------------------------------------------
    wire BVALID;

    // Wire: BRESP
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Response Signal.
    // 
    //       The source of this signal is Slave and it indicates the status of the 
    //       write transaction. The allowable responses are OKAY, EXOKAY, SLVERR 
    //       and DECERR.
    //     
    //------------------------------------------------------------------------------
    wire [1:0] BRESP;

    // Wire: BID
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Response ID Signal.
    // 
    //       The source of this signal is Slave and it indicates the identifciation 
    //       tag of a write response.
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_ID_WIDTH) - 1):0]  BID;

    // Wire: BREADY
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Response Ready Signal.
    // 
    //       The source of this signal is Master and it indicates that the master 
    //       can accept the response information.
    //     
    //------------------------------------------------------------------------------
    wire BREADY;

    // Wire: BUSER
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Response User Signal.
    //     
    //------------------------------------------------------------------------------
    wire [7:0] BUSER;

    // Propagate global signals onto interface wires
    assign ACLK = iACLK;
    assign ARESETn = iARESETn;

    //------------------------------------------------------------------------------
    // Global Variables - config
    //------------------------------------------------------------------------------

    // Variable:- config_clk_init_value
    //
    // 
    //     Initial value of the clock signal generated by the AXI MVC built-in clock generator.
    //   
    //
    bit config_clk_init_value;

    // Variable:- config_clk_phase_shift
    //
    // 
    //     Number of time units to hold the initial value of the clock signal generated by the AXI
    //     MVC built-in clock generator. 
    //   
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    int config_clk_phase_shift;

    // Variable:- config_clk_1st_time
    //
    // 
    //     Number of time units for the first phase of the clock signal generated by the AXI MVC
    //     built-in clock generator.
    //   
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    int config_clk_1st_time;

    // Variable:- config_clk_2nd_time
    //
    // 
    //     Number of time units for the second phase of the clock signal generated by the AXI MVC
    //     built-in clock generator.
    //   
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    int config_clk_2nd_time;

    // Variable:- config_setup_time
    //
    // 
    //     Number of time units for the setup time to the active clock edge of ACLK.
    //   
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    int config_setup_time;

    // Variable:- config_hold_time
    //
    // 
    //     Number of time units for the hold time to the active clock edge of ACLK.
    //   
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    int config_hold_time;

    // Variable:- config_max_transaction_time_factor
    //
    //  This timeout "config_max_transaction_time_factor" is the timeout that sets the maximum timeout within which any read/write transaction is 
    //        expected to occur (and in turn all individual phases as well) of the AXI interface. 
    //        This timeout should be set as the maximum duration of read/write. 
    //        In short it indicates the maximum duration of a read/write transaction (From start of transaction to end of it).
    //        Its default value is 100000 clock cycles
    //     
    //
    int unsigned config_max_transaction_time_factor;

    // Variable:- config_timeout_max_data_transfer
    //
    //  This timeout "config_timeout_max_data_transfer" is actually a configuration which tells about the maximum number of write data beats that the AXI interface
    //       can generate as part of write data burst of write transfer. 
    //       It is actually not a timeout value and is the maximum number of beats of Write data that are expected. 
    //
    int config_timeout_max_data_transfer;

    // Variable:- config_burst_timeout_factor
    //
    // This timeout "config_burst_timeout_factor" represents the maximum delay between the individual phases of the AXI transactions.
    //      For example between read address phase and read data phase, write address and Write data phases. 
    //      If this delay exceeds between the phases then transaction will be  timed out.
    //      Its default value is 10000 clock cycles
    //     
    //
    int unsigned config_burst_timeout_factor;

    // Variable:- config_max_latency_AWVALID_assertion_to_AWREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <AWVALID> to the assertion of <AWREADY> (default 10000).
    // 
    // The error message <AXI_AWREADY_NOT_ASSERTED_AFTER_AWVALID> will be issued if this period elapses from the assertion of <AWVALID>.
    // 
    //
    int unsigned config_max_latency_AWVALID_assertion_to_AWREADY;

    // Variable:- config_max_latency_ARVALID_assertion_to_ARREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <ARVALID> to the assertion of <ARREADY> (default 10000).
    // 
    // The error message <AXI_ARREADY_NOT_ASSERTED_AFTER_ARVALID> will be issued if this period elapses from the assertion of <ARVALID>.
    // 
    //
    int unsigned config_max_latency_ARVALID_assertion_to_ARREADY;

    // Variable:- config_max_latency_RVALID_assertion_to_RREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <RVALID> to the assertion of <RREADY> (default 10000).
    // 
    // The error message <AXI_RREADY_NOT_ASSERTED_AFTER_RVALID> will be issued if this period elapses from the assertion of <RVALID>.
    // 
    //
    int unsigned config_max_latency_RVALID_assertion_to_RREADY;

    // Variable:- config_max_latency_BVALID_assertion_to_BREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <BVALID> to the assertion of <BREADY> (default 10000).
    // 
    // The error message <AXI_BREADY_NOT_ASSERTED_AFTER_BVALID> will be issued if this period elapses from the assertion of <BVALID>.
    // 
    //
    int unsigned config_max_latency_BVALID_assertion_to_BREADY;

    // Variable:- config_max_latency_WVALID_assertion_to_WREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <WVALID> to the assertion of <WREADY> (default 10000).
    // 
    // The error message <AXI_WREADY_NOT_ASSERTED_AFTER_WVALID> will be issued if this period elapses from the assertion of <WVALID>.
    // 
    //
    int unsigned config_max_latency_WVALID_assertion_to_WREADY;

    // Variable:- config_write_ctrl_first_ratio
    //
    // Data starts at same time as or after control phase.  Response follows data.
    //
    int config_write_ctrl_first_ratio;

    // Variable:- config_write_data_first_ratio
    //
    // control phase starts at same time as or after data phase.  Response follows data.
    //
    int config_write_data_first_ratio;

    // Variable:- config_write_ctrl_to_data_mintime
    //
    // Number of clocks from the start of control to the start of data in a write. This configuration parameter has been deprecated and maintained for backward compatibility. Instead use write_address_to_data_delay variable to control delay between write address phase and write data phase.
    //
    int unsigned config_write_ctrl_to_data_mintime;

    // Variable:- config_write_data_to_ctrl_mintime
    //
    // Number of clocks from the start of data to the start of control in a write
    //
    int unsigned config_write_data_to_ctrl_mintime;

    // Variable:- config_master_write_delay
    //
    // To configure the write sequence item delays to be inserted.
    //
    bit config_master_write_delay;

    // Variable:- config_reset_low_clocks
    //
    // 
    //     Number of clock cycles to hold the reset signal generated by the AXI MVC built-in reset
    //     generator at the start of an OVM test.
    //   
    //
    int config_reset_low_clocks;

    // Variable:- config_reset_hold_time
    //
    // 
    //     Number of time units to delay changing the reset signal generated by the AXI MVC
    //     built-in reset generator after a clock edge.
    //   
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    int config_reset_hold_time;

    // Variable:- config_protect_ready
    //
    // 
    //     Boolean to set ready stripes as protected (so don't recognize) 
    //   
    //
    bit config_protect_ready;

    // Variable:- config_enable_user_sideband
    //
    // 
    //     To enable the user sideband.
    //   
    //
    bit config_enable_user_sideband;

    // Variable:- config_extended_length_enable
    //
    // 
    //     To enable the extended burst length feature.
    //   
    //
    bit config_extended_length_enable;

    // Variable:- config_enable_burst_reserved_value
    //
    //  A configuration parameter to control the generation (within the QVIP) and coverage collection of the <axi_burst_e> reserved value AXI_BURST_RSVD
    //   when it is allowed as a legal value for the 'burst' parameter of <axi_master_AXI_write>/<axi_master_AXI_read>.
    // 
    //   1'b0 - randomized generation by the master and coverage collection by <axi_functional_coverage> is not performed for the <axi_burst_e> reserved value AXI_BURST_RSVD (default).
    //   1'b1 - randomized generation by the master and coverage collection by <axi_functional_coverage> is performed for the <axi_burst_e> reserved value AXI_BURST_RSVD.
    //   
    //
    bit config_enable_burst_reserved_value;

    // Variable:- config_enable_lock_reserved_value
    //
    //  A configuration parameter to control the coverage collection of the <axi_lock_e> reserved value AXI_LOCK_RSVD when it is allowed as a legal value for the 'lock'
    //   parameter of <axi_master_AXI_write>/<axi_master_AXI_read>.
    // 
    //   1'b0 - randomized generation by the master and coverage collection by <axi_functional_coverage> is not performed for the <axi_lock_e> reserved value AXI_LOCK_RSVD (default).
    //   1'b1 - randomized generation by the master and coverage collection by <axi_functional_coverage> is performed for the <axi_lock_e> reserved value AXI_LOCK_RSVD.
    //   
    //
    bit config_enable_lock_reserved_value;

    // Variable:- config_enable_cache_reserved_value
    //
    //  A configuration parameter to control the coverage collection of the <axi_cache_e> reserved values AXI_CACHE_RSVD0, AXI_CACHE_RSVD1
    //   AXI_CACHE_RSVD2 AXI_CACHE_RSVD3, AXI_CACHE_RSVD4, AXI_CACHE_RSVD5 when they are allowed as legal values for the 'cache'
    //   parameter of <axi_master_AXI_write>/<axi_master_AXI_read>.
    // 
    //   1'b0 - randomized generation by the master and coverage collection by <axi_functional_coverage> is not performed for the <axi_cache_e> reserved values(default).
    //   1'b1 - randomized generation by the master and coverage collection by <axi_functional_coverage> is performed for the <axi_cache_e> reserved values(default).
    //   
    //
    bit config_enable_cache_reserved_value;

    // Variable:- config_enable_all_assertions
    //
    // 
    //   Configuration parameter controlling whether the error messages(Assertions) issued from the QVIP are Enabled or Disabled.  
    //   By default, it is enabled.
    // 
    //
    bit config_enable_all_assertions;

    // Variable:- config_enable_assertion
    //
    // 
    //   An array of configuration parameters controlling whether specific error messages(Assertion) (of type <axi_assertion_type_e>)
    //   can be issued by the QVIP. By default, all errors are enabled. To suppress a particular error, set the corresponding bit to 0.
    //   e.g. config.m_bfm.set_config_enable_error_index1(AXI_RESET_SIGNAL_Z, 0);
    // 
    //
    bit [255:0] config_enable_assertion;

    // Variable:- config_enable_error
    //
    //  
    //   This configuration parameter has been deprecated and maintained for backward compatibility
    // 
    //
    bit [255:0] config_enable_error;

    // Variable:- config_enable_errors
    //
    //  
    //   This configuration parameter has been deprecated and maintained for backward compatibility
    // 
    //
    bit config_enable_errors;

    // Variable:- config_enable_all_assertion_errors
    //
    //  This configuration parameter has been deprecated and maintained for backward compatibility
    // 
    //
    bit config_enable_all_assertion_errors;

    // Variable:- config_abstraction_level
    //
    // 
    //     To set the Abstraction Level. 
    //   
    //
    axi_abstraction_level_e config_abstraction_level;

    // Variable:- config_slave_start_addr
    //
    // 
    //    A configuration parameter indicating start address for slave.
    //   
    //
    bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr;

    // Variable:- config_slave_end_addr
    //
    // 
    //    A configuration parameter indicating end address for slave.
    //   
    //
    bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr;

    // Variable:- config_enable_slave_addr_range_in_bfm
    //
    // 
    //    A configuration parameter indicating whether slave start and end address provided in bfm is valid or not.
    //    If set to 1 then slave start and end address provided in bfm will be considered valid.
    //   
    //
    bit config_enable_slave_addr_range_in_bfm;

    // Variable:- config_read_data_reordering_depth
    //
    // 
    //    A configuration parameter defining the read reordering depth of the slave end of the interface (SPEC3(A5.3.1)).
    // 
    //    Responses from the first <config_read_data_reordering_depth> outstanding read transactions, each with address <ARID> values different from any
    //    earlier outstanding read transaction(as seen by the slave) are expected, interleaved at random. A violation causes a <AXI_READ_REORDERING_VIOLATION> error.
    // 
    //    The default value of <config_read_data_reordering_depth> is (1 << AXI_ID_WIDTH), so that the slave is expected to process all transactions in any order (up to uniqueness of <ARID>).
    // 
    //    For a given <AXI_ID_WIDTH> parameter value, the maximum possible value of <config_read_data_reordering_depth> is 2**AXI_ID_WIDTH. The <AXI_PARAM_READ_REORDERING_DEPTH_EXCEEDS_MAX_ID>
    //    error report will be issued if <config_read_data_reordering_depth> exceeds this value.
    // 
    //    If the user-supplied value is 0, the <AXI4_PARAM_READ_REORDERING_DEPTH_EQUALS_ZERO> error will be issued, and the value will be set to 1.
    //   
    //
    int unsigned config_read_data_reordering_depth;

    // Variable:- config_enable_read_data_reordering_depth_in_bfm
    //
    // 
    //    A configuration parameter indicating whether read data reordering depth provided in bfm is valid or not.
    //    If set to 1 then read data reordering depth in bfm will be considered valid.
    //   
    //
    bit config_enable_read_data_reordering_depth_in_bfm;

    // Variable:- config_awid_wid_mismatch
    //
    // 
    //     Configuration to set a AWID WID mismatch error.
    //   
    //
    bit config_awid_wid_mismatch;

    // Variable:- config_length_last_mismatch_error
    //
    // 
    //     Configuration to set a AWLEN last mismatch error.
    //   
    //
    bit config_length_last_mismatch_error;

    // Variable:- config_master_error_position
    //
    // 
    //     To confgure the type of Master Error.
    //   
    //
    axi_error_e config_master_error_position;

    // Variable:- dummy_var
    //
    // 
    //     To configure the assertion type.
    //   
    //
    axi_assertion_type_e dummy_var;

    // Variable:- config_wlast_length
    //
    // 
    //     This configures the length of data phase after which wlast should be asserted.
    //     This has effect only when m_length_last_mismatch_error is set to 1.
    //   
    //
    int config_wlast_length;

    // Variable:- config_wid_for_awid_not_matching
    //
    // 
    //     This configures the value of WID when m_awid_wid_mismatch is set to 1.
    //   
    //
    bit [((AXI_ID_WIDTH) - 1):0]  config_wid_for_awid_not_matching;

    // Variable:- config_support_exclusive_access
    //
    // 
    //     This configures the support for exclusive slave.
    //     If set, it enables the exclusive support in slave.
    //     If cleared, it disables the exclusive support and every exclusive read/write will return OKAY response and 
    //     exclusive write will update the memory.  
    //   
    //
    bit config_support_exclusive_access;

    // Variable:- config_write_data_interleaving_depth
    //
    // 
    //     This configures the maximum number of different write transaction addresses for which write data can be supplied
    //     to the slave.
    //   
    //
    int config_write_data_interleaving_depth;

    // Variable:- status_master_error
    //
    // 
    //     This shows the Status of Master Error.
    //   
    //
    bit [15:0] status_master_error;

    // Variable:- check_total_num_wdata_outstanding
    //
    // 
    //    This variable is set to true and then BFM updates <total_num_wdata_outstanding> and set this variable to false to
    //    notify that required variable has been updated.
    //   
    //
    bit check_total_num_wdata_outstanding;

    // Variable:- total_num_wdata_outstanding
    //
    // 
    //    This represents the total number of outstanding write data bursts. This could be received by setting
    //    <check_total_num_wdata_outstanding> to true and then waiting for same variable to become false.
    //   
    //
    int total_num_wdata_outstanding;

    // Variable:- check_max_num_wdata_outstanding_per_id
    //
    // 
    //    This variable is set to true and then BFM updates <max_num_wdata_outstanding_per_id> and set this variable to false to
    //    notify that required variable has been updated.
    //   
    //
    bit check_max_num_wdata_outstanding_per_id;

    // Variable:- max_num_wdata_outstanding_per_id
    //
    // 
    //    This represents the maximum number of outstanding write data bursts for any id. This could be received by setting
    //    <check_max_num_wdata_outstanding_per_id> to true and then waiting for same variable to become false.
    //   
    //
    int max_num_wdata_outstanding_per_id;

    // Variable:- check_max_num_waddr_outstanding_per_id
    //
    // 
    //    This variable is set to true and then BFM updates <max_num_waddr_outstanding_per_id> and set this variable to false to
    //    notify that required variable has been updated.
    //   
    //
    bit check_max_num_waddr_outstanding_per_id;

    // Variable:- max_num_waddr_outstanding_per_id
    //
    // 
    //    This represents the maximum number of outstanding write address bursts for any id. This could be received by setting
    //    <check_max_num_waddr_outstanding_per_id> to true and then waiting for same variable to become false.
    //   
    //
    int max_num_waddr_outstanding_per_id;

    // Variable:- check_total_num_waddr_outstanding
    //
    // 
    //    This variable is set to true and then BFM updates <total_num_waddr_outstanding> and set this variable to false to
    //    notify that required variable has been updated.
    //   
    //
    bit check_total_num_waddr_outstanding;

    // Variable:- total_num_waddr_outstanding
    //
    // 
    //    This represents the total number of outstanding write address bursts. This could be received by setting
    //    <check_total_num_waddr_outstanding> to true and then waiting for same variable to become false.
    //   
    //
    int total_num_waddr_outstanding;

    // Variable:- status_outstanding_num_for_waddr
    //
    // 
    //     This gives the number of write address phases outstanding with WID of <find_waddr_outstanding_for_wid>
    //     when start_finding_outstanding_waddr is set to 1.
    //   
    //
    int status_outstanding_num_for_waddr;

    // Variable:- start_finding_outstanding_waddr
    //
    //  If set to 1, this variable starts the updation of the variable status_outstanding_num_for_waddr 
    //      with the number of outstanding write address bursts of WID = find_waddr_outstanding_for_wid
    //    
    //
    bit start_finding_outstanding_waddr;

    // Variable:- status_outstanding_num_for_wdata
    //
    // 
    //     This gives the number of write data phases outstanding with WID of <find_wdata_outstanding_for_wid>
    //     when start_finding_outstanding_wdata is set to 1.
    //   
    //
    int status_outstanding_num_for_wdata;

    // Variable:- start_finding_outstanding_wdata
    //
    //  If set to 1, this variable starts the updation of the variable status_outstanding_num_for_wdata 
    //      with the number of outstanding write data bursts of WID = find_wdata_outstanding_for_wid
    //    
    //
    bit start_finding_outstanding_wdata;

    // Variable:- find_waddr_outstanding_for_wid
    //
    //  
    //     This variable is the input WID, for which the number of outstanding write addr phases is
    //     required. If start_finding_outstanding_waddr is set to 1, the variable status_outstanding_num_for_waddr
    //     is updated with the number of outstanding write addr phases with a WID of find_waddr_outstanding_for_wid
    //   
    //
    bit [((AXI_ID_WIDTH) - 1):0]  find_waddr_outstanding_for_wid;

    // Variable:- find_wdata_outstanding_for_wid
    //
    //  
    //     This variable is the input WID, for which the number of outstanding write data phases is
    //     required. If start_finding_outstanding_wdata is set to 1, the variable status_outstanding_num_for_wdata
    //     is updated with the number of outstanding write data phases with a WID of find_wdata_outstanding_for_wid
    //   
    //
    bit [((AXI_ID_WIDTH) - 1):0]  find_wdata_outstanding_for_wid;

    // Variable:- change_in_wdata_outstanding_per_id
    //
    // 
    //     This variable helps to wait for a change in number of outstanding write data phases per id.
    //   
    //
    bit change_in_wdata_outstanding_per_id;

    // Variable:- start_finding_change_in_wdata
    //
    //  This variable keeps a track of a change in the number of outstanding
    //      write data phases for WID find_change_in_wdata_outstanding_for_wid
    //    
    //
    bit start_finding_change_in_wdata;

    // Variable:- find_change_in_wdata_outstanding_for_wid
    //
    //  
    //     This variable is the input WID, for which the change in number of outstanding write data phases is
    //     required. If start_finding_change_in_wdata is set to 1, the variable start_finding_outstanding_wdata
    //     is cleared again when the number of outstanding write data phases with a WID of find_change_in_wdata_outstanding_for_wid
    //     modifies
    //   
    //
    bit [((AXI_ID_WIDTH) - 1):0]  find_change_in_wdata_outstanding_for_wid;

    // Variable:- config_max_outstanding_wr
    //
    int config_max_outstanding_wr;

    // Variable:- config_max_outstanding_rd
    //
    int config_max_outstanding_rd;

    // Variable:- config_error_on_deleted_valid_cycles
    //
    bit config_error_on_deleted_valid_cycles;

    // Variable:- config_stats_enable
    //
    //  A flag to globally enable/disable performance attributes calculation
    // 
    // Flag settings are:
    // - disabled = 1'b0 (default)
    // - enabled  = 1'b1
    // 
    //
    bit config_stats_enable;

    // Variable:- config_stats_enable_AXI_read_occupancy
    //
    //  A configuration flag to enable/disable the read channel occupancy statistics gathering.
    // 
    // The read channel occupancy is calculated as a percentage of time the read channel (or part of it) is occupied
    // and is measured from the first rising clock that an appropriate *VALID signal is asserted.
    // The read channel is deemed to be occupied if there is a read transaction active.
    // An active read transaction does not necessarily relate to activity on any of the read channel buses
    // as there may be gaps of time between the read transaction phases.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_AXI_read_occupancy;

    // Variable:- config_stats_enable_AXI_write_occupancy
    //
    //  A configuration flag to enable/disable the write channel occupancy statistics gathering.
    // 
    // The write channel occupancy is calculated as a percentage of time the write channel (or part of it) is occupied
    // and is measured from the first rising clock that an appropriate *VALID signal is asserted.
    // The write channel is deemed to be occupied if there is a write transaction active.
    // An active write transaction does not necessarily relate to activity on any of the write channel buses
    // as there may be gaps of time between the write transaction phases.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_AXI_write_occupancy;

    // Variable:- config_stats_enable_read_data_occupancy
    //
    //  A configuration flag to enable/disable the read data occupancy statistics gathering.
    // 
    // The read data occupancy is calculated as a percentage of time the read data channel (or part of it) is occupied
    // and is measured from the first rising clock that an appropriate *VALID signal is asserted.
    // The read data channel is deemed to be occupied if there is a read data phase active and is measured
    // at the phase level, giving a true indication of activity.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_read_data_occupancy;

    // Variable:- config_stats_enable_write_data_occupancy
    //
    //  A configuration flag to enable/disable the write data occupancy statistics gathering.
    // 
    // The write data occupancy is calculated as a percentage of time the write data channel (or part of it) is occupied
    // and is measured from the first rising clock that an appropriate *VALID signal is asserted.
    // The write data channel is deemed to be occupied if there is a write data phase active and is measured
    // at the phase level, giving a true indication of activity.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_write_data_occupancy;

    // Variable:- config_stats_enable_read_latency
    //
    //  A configuration flag to enable/disable the read latency statistics gathering.
    // 
    // The read latency is calculated as the number of clock cycles between the read channel phases.
    // It is measured from the clock edge when the first phase ends (*VALID and *READY are high)
    // to when the next phase starts (*VALID is high).
    // 
    // The latencies measured are:
    // -       read address (end) to read data (start). The calculation is updated at the end of the transaction.
    // -       read address (end) to the next read address (start). The calculation is updated when the latter of the two address phases occurs.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_read_latency;

    // Variable:- config_stats_enable_write_latency
    //
    //  A configuration flag to enable/disable the write latency statistics gathering.
    // 
    // The write latency is calculated as the number of clock cycles between the write channel phases.
    // It is measured from the clock edge when the first phase ends (*VALID and *READY are high)
    // to when the next phase starts (*VALID is high).
    // 
    // The latencies measured are:
    // -       write address (end) to write data (start) The calculation is updated at the end of the transaction.
    // -       write data (end) to write response (start). The calculation is updated at the end of the transaction.
    // -       write address (end) to the next write address (start). The calculation is updated when the latter of the two address phases occurs.
    // 
    // Note that the write address/write data latency calculation may result in negative value as the address and data can happen in either order, or in parallel.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_write_latency;

    // Variable:- config_stats_enable_read_address_waits
    //
    //  A configuration flag to enable/disable the read address wait states statistics gathering.
    // 
    // The read address wait is calculated as the length of time a particular address phase is active for, in clock cycles.
    // This is determined by the number of clock cycles between its *VALID and *READY handshake signals.
    // If an address phase lasts a single clock (*VALID and *READY are both high) then the wait is zero.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_read_address_waits;

    // Variable:- config_stats_enable_read_data_waits
    //
    //  A configuration flag to enable/disable the read data wait states statistics gathering.
    // 
    // The read data wait is calculated as the length of time a particular data phase is active for, in clock cycles.
    // This is determined by the number of clock cycles between its *VALID and *READY handshake signals.
    // If a data phase lasts a single clock (*VALID and *READY are both high) then the wait is zero.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_read_data_waits;

    // Variable:- config_stats_enable_write_address_waits
    //
    //  A configuration flag to enable/disable the write address wait states statistics gathering.
    // 
    // The write address wait is calculated as the length of time a particular address phase is active for, in clock cycles.
    // This is determined by the number of clock cycles between its *VALID and *READY handshake signals.
    // If an address phase lasts a single clock (*VALID and *READY are both high) then the wait is zero.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_write_address_waits;

    // Variable:- config_stats_enable_write_data_waits
    //
    //  A configuration flag to enable/disable the write data wait states statistics gathering.
    // 
    // The write data wait is calculated as the length of time a particular data phase is active for, in clock cycles.
    // This is determined by the number of clock cycles between its *VALID and *READY handshake signals.
    // If a data phase lasts a single clock (*VALID and *READY are both high) then the wait is zero.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_write_data_waits;

    // Variable:- config_stats_enable_write_response_waits
    //
    //  A configuration flag to enable/disable the write response wait states statistics gathering.
    // 
    // The write response wait is calculated as the length of time a particular response phase is active for, in clock cycles.
    // This is determined by the number of clock cycles between its *VALID and *READY handshake signals.
    // If a response phase lasts a single clock (*VALID and *READY are both high) then the wait is zero.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_write_response_waits;

    // Variable:- config_stats_enable_read_bandwidth
    //
    //  A configuration flag to enable/disable the read bandwidth statistics gathering.
    // 
    // The read bandwidth is calculated as the amount of data transferred within a sliding window,
    // taking into account the read transfer size parameter.
    // The contribution from any specific read transaction is measured at the end of the transaction.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_read_bandwidth;

    // Variable:- config_stats_enable_write_bandwidth
    //
    //  A configuration flag to enable/disable the write bandwidth statistics gathering.
    // 
    // The write bandwidth is calculated as the amount of data transferred within a sliding window,
    // taking into account the write transfer size parameter.
    // The contribution from any specific write transaction is measured at the end of the transaction.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_write_bandwidth;

    // Variable:- config_stats_AXI_read_occupancy_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_AXI_read_occupancy> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_AXI_read_occupancy_step;

    // Variable:- config_stats_AXI_read_occupancy_multiple
    //
    //  A configuration variable for setting the read occupancy multiple of the <config_stats_enable_AXI_read_occupancy> sliding window.
    // 
    // The read occupancy multiple is the number of <config_stats_AXI_read_occupancy_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_AXI_read_occupancy_multiple;

    // Variable:- config_stats_AXI_write_occupancy_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_AXI_write_occupancy> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_AXI_write_occupancy_step;

    // Variable:- config_stats_AXI_write_occupancy_multiple
    //
    //  A configuration variable for setting the write occupancy multiple of the <config_stats_enable_AXI_write_occupancy> sliding window.
    // 
    // The read occupancy multiple is the number of <config_stats_AXI_write_occupancy_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_AXI_write_occupancy_multiple;

    // Variable:- config_stats_read_data_occupancy_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_read_data_occupancy_step;

    // Variable:- config_stats_read_data_occupancy_multiple
    //
    //  A configuration variable for setting the read data occupancy multiple of the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    // The read data occupancy multiple is the number of <config_stats_read_data_occupancy_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_read_data_occupancy_multiple;

    // Variable:- config_stats_write_data_occupancy_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_write_data_occupancy_step;

    // Variable:- config_stats_write_data_occupancy_multiple
    //
    //  A configuration variable for setting the write data occupancy multiple of the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    // The write data occupancy multiple is the number of <config_stats_write_data_occupancy_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_write_data_occupancy_multiple;

    // Variable:- config_stats_read_bandwidth_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_read_bandwidth> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_read_bandwidth_step;

    // Variable:- config_stats_read_bandwidth_multiple
    //
    //  A configuration variable for setting the read bandwidth multiple of the <config_stats_enable_read_bandwidth> sliding window.
    // 
    // The read bandwidth multiple is the number of <config_stats_read_bandwidth_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_read_bandwidth_multiple;

    // Variable:- config_stats_write_bandwidth_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_write_bandwidth> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_write_bandwidth_step;

    // Variable:- config_stats_write_bandwidth_multiple
    //
    //  A configuration variable for setting the write bandwidth multiple of the <config_stats_enable_write_bandwidth> sliding window.
    // 
    // The write bandwidth multiple is the number of <config_stats_write_bandwidth_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_write_bandwidth_multiple;

    // Variable:- config_stats_read_latency_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_read_latency> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_read_latency_step;

    // Variable:- config_stats_read_latency_multiple
    //
    //  A configuration variable for setting the read latency multiple of the <config_stats_enable_read_latency> sliding window.
    // 
    // The read latency multiple is the number of <config_stats_read_latency_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_read_latency_multiple;

    // Variable:- config_stats_write_latency_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_write_latency> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_write_latency_step;

    // Variable:- config_stats_write_latency_multiple
    //
    //  A configuration variable for setting the write latency multiple of the <config_stats_enable_write_latency> sliding window.
    // 
    // The write latency multiple is the number of <config_stats_write_latency_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_write_latency_multiple;

    // Variable:- config_stats_read_address_waits_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_read_address_waits> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_read_address_waits_step;

    // Variable:- config_stats_read_address_waits_multiple
    //
    //  A configuration variable for setting the read address wait states multiple of the <config_stats_enable_read_address_waits> sliding window.
    // 
    // The read address wait states multiple is the number of <config_stats_read_address_waits_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_read_address_waits_multiple;

    // Variable:- config_stats_read_data_waits_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_read_data_waits> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_read_data_waits_step;

    // Variable:- config_stats_read_data_waits_multiple
    //
    //  A configuration variable for setting the read data wait states multiple of the <config_stats_enable_read_data_waits> sliding window.
    // 
    // The read data wait states multiple is the number of <config_stats_read_data_waits_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_read_data_waits_multiple;

    // Variable:- config_stats_write_address_waits_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_write_address_waits> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_write_address_waits_step;

    // Variable:- config_stats_write_address_waits_multiple
    //
    //  A configuration variable for setting the write address wait states multiple of the <config_stats_enable_write_address_waits> sliding window.
    // 
    // The write address wait states multiple is the number of <config_stats_write_address_waits_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_write_address_waits_multiple;

    // Variable:- config_stats_write_data_waits_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_write_data_waits> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_write_data_waits_step;

    // Variable:- config_stats_write_data_waits_multiple
    //
    //  A configuration variable for setting the write data wait states multiple of the <config_stats_enable_write_data_waits> sliding window.
    // 
    // The write data wait states multiple is the number of <config_stats_write_data_waits_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_write_data_waits_multiple;

    // Variable:- config_stats_write_response_waits_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_write_response_waits> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_write_response_waits_step;

    // Variable:- config_stats_write_response_waits_multiple
    //
    //  A configuration variable for setting the write response wait states multiple of the <config_stats_enable_write_response_waits> sliding window.
    // 
    // The write response wait states multiple is the number of <config_stats_write_response_waits_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_write_response_waits_multiple;

    //------------------------------------------------------------------------------
    // Global Variables - status
    //------------------------------------------------------------------------------

    // Variable:- status_num_reads_waiting_for_resp
    //
    // 
    //     This shows the number of outstanding read transactions
    //   
    //
    int status_num_reads_waiting_for_resp;

    // Variable:- status_num_writes_waiting_for_response
    //
    // 
    //     This shows the number of outstanding write transactions that have not received a response
    //   
    //
    int status_num_writes_waiting_for_response;

    // Variable:- stats_AXI_read_active
    //
    //  A flag for indicating that there is one or more active read transactions.
    // 
    //
    bit stats_AXI_read_active;

    // Variable:- stats_AXI_read_occupancy_sw
    //
    //  A variable for holding the calculation of the read occupancy <config_stats_enable_AXI_read_occupancy> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_AXI_read_occupancy_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_AXI_read_occupancy_sw;

    // Variable:- stats_AXI_read_occupancy_sw_updated
    //
    //  A variable for holding the number of times the <stats_AXI_read_occupancy_sw> and <stats_AXI_read_idle_sw> sliding window statistics
    // have been updated, plus their respective min, max and mean values.
    // The value is incremented after every <config_stats_AXI_read_occupancy_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest value of the following statistics.
    // - <stats_AXI_read_occupancy_sw>
    // - <stats_AXI_read_occupancy_min>
    // - <stats_AXI_read_occupancy_max>
    // - <stats_AXI_read_occupancy_mean>
    // - <stats_AXI_read_idle_sw>
    // - <stats_AXI_read_idle_min>
    // - <stats_AXI_read_idle_max>
    // - <stats_AXI_read_idle_mean>
    // 
    //
    int stats_AXI_read_occupancy_sw_updated;

    // Variable:- stats_AXI_read_idle_sw
    //
    //  A variable for holding the calculation of the read idle <config_stats_enable_AXI_read_occupancy> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_AXI_read_idle_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_AXI_read_idle_sw;

    // Variable:- stats_AXI_read_occupancy_min
    //
    //  A variable for holding the minimum read occupancy metric within the <config_stats_enable_AXI_read_occupancy> sliding window.
    // 
    //
    int stats_AXI_read_occupancy_min;

    // Variable:- stats_AXI_read_idle_min
    //
    //  A variable for holding the minimum read idle metric within the <config_stats_enable_AXI_read_occupancy> sliding window.
    // 
    //
    int stats_AXI_read_idle_min;

    // Variable:- stats_AXI_read_occupancy_max
    //
    //  A variable for holding the maximum read occupancy metric within the <config_stats_enable_AXI_read_occupancy> sliding window.
    // 
    //
    int stats_AXI_read_occupancy_max;

    // Variable:- stats_AXI_read_idle_max
    //
    //  A variable for holding the maximum read idle metric within <config_stats_enable_AXI_read_occupancy> the sliding window.
    // 
    //
    int stats_AXI_read_idle_max;

    // Variable:- stats_AXI_read_occupancy_mean
    //
    //  A variable for holding the mean read occupancy metric within the <config_stats_enable_AXI_read_occupancy> sliding window.
    // 
    //
    int stats_AXI_read_occupancy_mean;

    // Variable:- stats_AXI_read_idle_mean
    //
    //  A variable for holding the mean read idle metric within the <config_stats_enable_AXI_read_occupancy> sliding window.
    // 
    //
    int stats_AXI_read_idle_mean;

    // Variable:- stats_AXI_write_active
    //
    //  A flag for indicating that there is one or more active write transactions.
    // 
    //
    bit stats_AXI_write_active;

    // Variable:- stats_AXI_write_occupancy_sw
    //
    //  A variable for holding the calculation of the write occupancy sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_AXI_write_occupancy_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_AXI_write_occupancy_sw;

    // Variable:- stats_AXI_write_occupancy_sw_updated
    //
    //  A variable for holding the number of times the <stats_AXI_write_occupancy_sw> and <stats_AXI_write_idle_sw> sliding window statistics
    // have been updated, plus their respective min, max and mean values.
    // The value is incremented after every <config_stats_AXI_write_occupancy_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest values of the following statistics.
    // - <stats_AXI_write_occupancy_sw>
    // - <stats_AXI_write_occupancy_min>
    // - <stats_AXI_write_occupancy_max>
    // - <stats_AXI_write_occupancy_mean>
    // - <stats_AXI_write_idle_sw>
    // - <stats_AXI_write_idle_min>
    // - <stats_AXI_write_idle_max>
    // - <stats_AXI_write_idle_mean>
    // 
    //
    int stats_AXI_write_occupancy_sw_updated;

    // Variable:- stats_AXI_write_idle_sw
    //
    //  A variable for holding the calculation of the write idle sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_AXI_write_idle_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_AXI_write_idle_sw;

    // Variable:- stats_AXI_write_occupancy_min
    //
    //  A variable for holding the minimum write occupancy metric within the <config_stats_enable_AXI_write_occupancy> sliding window.
    // 
    //
    int stats_AXI_write_occupancy_min;

    // Variable:- stats_AXI_write_idle_min
    //
    //  A variable for holding the minimum write idle metric within the <config_stats_enable_AXI_write_occupancy> sliding window.
    // 
    //
    int stats_AXI_write_idle_min;

    // Variable:- stats_AXI_write_occupancy_max
    //
    //  A variable for holding the maximum write occupancy metric within the <config_stats_enable_AXI_write_occupancy> sliding window.
    // 
    //
    int stats_AXI_write_occupancy_max;

    // Variable:- stats_AXI_write_idle_max
    //
    //  A variable for holding the maximum write idle metric within <config_stats_enable_AXI_write_occupancy> the sliding window.
    // 
    //
    int stats_AXI_write_idle_max;

    // Variable:- stats_AXI_write_occupancy_mean
    //
    //  A variable for holding the mean write occupancy metric within the <config_stats_enable_AXI_write_occupancy> sliding window.
    // 
    //
    int stats_AXI_write_occupancy_mean;

    // Variable:- stats_AXI_write_idle_mean
    //
    //  A variable for holding the mean write idle metric within the <config_stats_enable_AXI_write_occupancy> sliding window.
    // 
    //
    int stats_AXI_write_idle_mean;

    // Variable:- stats_read_data_occupancy_sw
    //
    //  A variable for holding the calculation of the read data occupancy <config_stats_enable_read_data_occupancy> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <config_stats_enable_read_data_occupancy> statistic is calculated based on all of the segments.
    // 
    //
    int stats_read_data_occupancy_sw;

    // Variable:- stats_read_data_occupancy_sw_updated
    //
    //  A variable for holding the number of times the <stats_read_data_occupancy_sw> and <stats_read_data_idle_sw> sliding window statistics have been updated,
    //  plus their respective min, max and mean values.
    // The value is incremented after every <config_stats_read_data_occupancy_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest values of the following statistics
    // - <stats_read_data_occupancy_sw>
    // - <stats_read_data_occupancy_min>
    // - <stats_read_data_occupancy_max>
    // - <stats_read_data_occupancy_mean>
    // - <stats_read_data_idle_sw>
    // - <stats_read_data_idle_min>
    // - <stats_read_data_idle_max>
    // - <stats_read_data_idle_mean>
    // 
    //
    int stats_read_data_occupancy_sw_updated;

    // Variable:- stats_read_data_idle_sw
    //
    //  A variable for holding the calculation of the read data idle <config_stats_enable_read_data_occupancy> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_read_data_idle_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_read_data_idle_sw;

    // Variable:- stats_read_data_occupancy_min
    //
    //  A variable for holding the minimum read data occupancy metric within the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    //
    int stats_read_data_occupancy_min;

    // Variable:- stats_read_data_idle_min
    //
    //  A variable for holding the minimum read data idle metric within the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    //
    int stats_read_data_idle_min;

    // Variable:- stats_read_data_occupancy_max
    //
    //  A variable for holding the maximum read data metric within the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    //
    int stats_read_data_occupancy_max;

    // Variable:- stats_read_data_idle_max
    //
    //  A variable for holding the maximum read data idle metric within the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    //
    int stats_read_data_idle_max;

    // Variable:- stats_read_data_occupancy_mean
    //
    //  A variable for holding the mean read data occupancy metric within the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    //
    int stats_read_data_occupancy_mean;

    // Variable:- stats_read_data_idle_mean
    //
    //  A variable for holding the mean read data idle occupancy metric within the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    //
    int stats_read_data_idle_mean;

    // Variable:- stats_write_data_occupancy_sw
    //
    //  A variable for holding the calculation of the write data occupancy <config_stats_enable_write_data_occupancy> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_data_occupancy_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_data_occupancy_sw;

    // Variable:- stats_write_data_occupancy_sw_updated
    //
    //  A variable for holding the number of times the <stats_write_data_occupancy_sw> and <stats_write_data_idle_sw>sliding window statistics have been updated,
    //  plus their respective min, max and mean values.
    // The value is incremented after every <config_stats_write_data_occupancy_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest values of the following statistics.
    // - <stats_write_data_occupancy_sw>
    // - <stats_write_data_occupancy_min>
    // - <stats_write_data_occupancy_max>
    // - <stats_write_data_occupancy_min>
    // - <stats_write_data_idle_sw>
    // - <stats_write_data_idle_min>
    // - <stats_write_data_idle_max>
    // - <stats_write_data_idle_mean>
    // 
    //
    int stats_write_data_occupancy_sw_updated;

    // Variable:- stats_write_data_idle_sw
    //
    //  A variable for holding the calculation of the write data idle <config_stats_enable_write_data_occupancy> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_data_idle_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_data_idle_sw;

    // Variable:- stats_write_data_occupancy_min
    //
    //  A variable for holding the minimum write data occupancy metric within the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    //
    int stats_write_data_occupancy_min;

    // Variable:- stats_write_data_idle_min
    //
    //  A variable for holding the mean write data idle occupancy metric within the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    //
    int stats_write_data_idle_min;

    // Variable:- stats_write_data_occupancy_max
    //
    //  A variable for holding the maximum write data metric within the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    //
    int stats_write_data_occupancy_max;

    // Variable:- stats_write_data_idle_max
    //
    //  A variable for holding the maximum write data idle metric within the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    //
    int stats_write_data_idle_max;

    // Variable:- stats_write_data_occupancy_mean
    //
    //  A variable for holding the mean write data occupancy metric within the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    //
    int stats_write_data_occupancy_mean;

    // Variable:- stats_write_data_idle_mean
    //
    //  A variable for holding the mean write data idle occupancy metric within the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    //
    int stats_write_data_idle_mean;

    // Variable:- stats_read_bandwidth_sw
    //
    //  A variable for holding the calculation of the read bandwidth <config_stats_enable_read_bandwidth> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_read_bandwidth_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_read_bandwidth_sw;

    // Variable:- stats_read_bandwidth_sw_updated
    //
    //  A variable for holding the number of times the <stats_read_bandwidth_sw> sliding window statistic has been updated.
    // The value is incremented after every <config_stats_read_bandwidth_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest values of the following statistics.
    // - <stats_read_bandwidth_sw>
    // - <stats_read_bandwidth_min>
    // - <stats_read_bandwidth_max>
    // - <stats_read_bandwidth_mean>
    // 
    //
    int stats_read_bandwidth_sw_updated;

    // Variable:- stats_read_bandwidth_min
    //
    //  A variable for holding the minimum read bandwidth metric within the <config_stats_enable_read_bandwidth> sliding window.
    // 
    //
    int stats_read_bandwidth_min;

    // Variable:- stats_read_bandwidth_max
    //
    //  A variable for holding the maximum read bandwidth metric within the <config_stats_enable_read_bandwidth> sliding window.
    // 
    //
    int stats_read_bandwidth_max;

    // Variable:- stats_read_bandwidth_mean
    //
    //  A variable for holding the mean read bandwidth metric within the <config_stats_enable_read_bandwidth> sliding window.
    // 
    //
    int stats_read_bandwidth_mean;

    // Variable:- stats_write_bandwidth_sw
    //
    //  A variable for holding the calculation of the write bandwidth <config_stats_enable_write_bandwidth> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_bandwidth_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_bandwidth_sw;

    // Variable:- stats_write_bandwidth_sw_updated
    //
    //  A variable for holding the number of times the <stats_write_bandwidth_sw> sliding window statistic has been updated.
    // The value is incremented after every <config_stats_write_bandwidth_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest values of the following staistics
    // - <stats_write_bandwidth_sw>
    // - <stats_write_bandwidth_min>
    // - <stats_write_bandwidth_max>
    // - <stats_write_bandwidth_mean>
    // 
    //
    int stats_write_bandwidth_sw_updated;

    // Variable:- stats_write_bandwidth_min
    //
    //  A variable for holding the minimum write bandwidth metric within the <config_stats_enable_write_bandwidth> sliding window.
    // 
    //
    int stats_write_bandwidth_min;

    // Variable:- stats_write_bandwidth_max
    //
    //  A variable for holding the maximum write bandwidth metric within the <config_stats_enable_write_bandwidth> sliding window.
    // 
    //
    int stats_write_bandwidth_max;

    // Variable:- stats_write_bandwidth_mean
    //
    //  A variable for holding the mean write bandwidth metric within the <config_stats_enable_write_bandwidth> sliding window.
    // 
    //
    int stats_write_bandwidth_mean;

    // Variable:- stats_read_latency_sw_updated
    //
    //  A variable for holding the number of times the <stats_read_address_data_latency_sw> sliding window statistic has been updated.
    // The value is incremented after every <config_stats_read_latency_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest values of the following statistics.
    // - <stats_read_address_data_latency_sw>
    // - <stats_read_address_data_latency_min>
    // - <stats_read_address_data_latency_max>
    // - <stats_read_address_data_latency_mean>
    // 
    //
    int stats_read_latency_sw_updated;

    // Variable:- stats_read_address_data_latency_inst
    //
    //  A variable for holding the instantaneous read address to read data latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_data_latency_inst;

    // Variable:- stats_read_address_data_latency_sw
    //
    //  A variable for holding the calculation of the read address to read data latency <config_stats_enable_read_latency> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_read_address_data_latency_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_read_address_data_latency_sw;

    // Variable:- stats_read_address_data_latency_min
    //
    //  A variable for holding the minimum read address to read data latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_data_latency_min;

    // Variable:- stats_read_address_data_latency_max
    //
    //  A variable for holding the maximum read address to read data latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_data_latency_max;

    // Variable:- stats_read_address_data_latency_mean
    //
    //  A variable for holding the mean read address to read data latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_data_latency_mean;

    // Variable:- stats_read_address_address_latency_inst
    //
    //  A variable for holding the instantaneous read address to read address latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_address_latency_inst;

    // Variable:- stats_read_address_address_latency_sw
    //
    //  A variable for holding the calculation of the read address to read address latency <config_stats_enable_read_latency> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_read_address_address_latency_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_read_address_address_latency_sw;

    // Variable:- stats_read_address_address_latency_min
    //
    //  A variable for holding the minimum read address to read address latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_address_latency_min;

    // Variable:- stats_read_address_address_latency_max
    //
    //  A variable for holding the maximum read address to read address latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_address_latency_max;

    // Variable:- stats_read_address_address_latency_mean
    //
    //  A variable for holding the mean read address to read address latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_address_latency_mean;

    // Variable:- stats_write_latency_sw_updated
    //
    //  A variable for holding the number of times the <stats_write_address_data_latency_sw> sliding window statistic has been updated.
    // The value is incremented after every <config_stats_write_latency_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest value of the following statistics
    // - <stats_write_address_data_latency_sw>
    // - <stats_write_address_data_latency_min>
    // - <stats_write_address_data_latency_max>
    // - <stats_write_address_data_latency_mean>
    // 
    //
    int stats_write_latency_sw_updated;

    // Variable:- stats_write_address_data_latency_inst
    //
    //  A variable for holding the instantaneous write address to write data latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_data_latency_inst;

    // Variable:- stats_write_address_data_latency_sw
    //
    //  A variable for holding the calculation of the write address to write data latency <config_stats_enable_write_latency> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_address_data_latency_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_address_data_latency_sw;

    // Variable:- stats_write_address_data_latency_min
    //
    //  A variable for holding the minimum write address to write data latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_data_latency_min;

    // Variable:- stats_write_address_data_latency_max
    //
    //  A variable for holding the maximum write address to write data latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_data_latency_max;

    // Variable:- stats_write_address_data_latency_mean
    //
    //  A variable for holding the mean write address to write data latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_data_latency_mean;

    // Variable:- stats_write_data_response_latency_inst
    //
    //  A variable for holding the instantaneous write data to write response latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_data_response_latency_inst;

    // Variable:- stats_write_data_response_latency_sw
    //
    //  A variable for holding the calculation of the write data to write response latency <config_stats_enable_write_latency> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_data_response_latency_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_data_response_latency_sw;

    // Variable:- stats_write_data_response_latency_min
    //
    //  A variable for holding the minimum write data to write response latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_data_response_latency_min;

    // Variable:- stats_write_data_response_latency_max
    //
    //  A variable for holding the maximum write data to write response latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_data_response_latency_max;

    // Variable:- stats_write_data_response_latency_mean
    //
    //  A variable for holding the mean write data to write response latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_data_response_latency_mean;

    // Variable:- stats_write_address_address_latency_inst
    //
    //  A variable for holding the instantaneous write address to write address latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_address_latency_inst;

    // Variable:- stats_write_address_address_latency_sw
    //
    //  A variable for holding the calculation of the write address to write address latency <config_stats_enable_write_latency> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_address_address_latency_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_address_address_latency_sw;

    // Variable:- stats_write_address_address_latency_min
    //
    //  A variable for holding the minimum write address to write address latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_address_latency_min;

    // Variable:- stats_write_address_address_latency_max
    //
    //  A variable for holding the maximum write address to write address latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_address_latency_max;

    // Variable:- stats_write_address_address_latency_mean
    //
    //  A variable for holding the mean write address to write address latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_address_latency_mean;

    // Variable:- stats_read_address_waits_inst
    //
    //  A variable for holding the instantaneous read address wait states metric within the <config_stats_enable_read_address_waits> sliding window.
    // 
    //
    int stats_read_address_waits_inst;

    // Variable:- stats_read_address_waits_sw
    //
    //  A variable for holding the calculation of the read address wait states <config_stats_enable_read_address_waits> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_read_address_waits_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_read_address_waits_sw;

    // Variable:- stats_read_address_waits_sw_updated
    //
    //  A variable for holding the number of times the <stats_read_address_waits_sw> sliding window statistic has been updated.
    // It is incremented after every <config_stats_read_address_waits_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest value of the following statistics
    // - <stats_read_address_waits_sw>
    // - <stats_read_address_waits_min>
    // - <stats_read_address_waits_max>
    // - <stats_read_address_waits_mean>
    // 
    //
    int stats_read_address_waits_sw_updated;

    // Variable:- stats_read_address_waits_min
    //
    //  A variable for holding the minimum read address wait states metric within the <config_stats_enable_read_address_waits> sliding window.
    // 
    //
    int stats_read_address_waits_min;

    // Variable:- stats_read_address_waits_max
    //
    //  A variable for holding the maximum read address wait states metric within the <config_stats_enable_read_address_waits> sliding window.
    // 
    //
    int stats_read_address_waits_max;

    // Variable:- stats_read_address_waits_mean
    //
    //  A variable for holding the mean read address wait states metric within the <config_stats_enable_read_address_waits> sliding window.
    // 
    //
    int stats_read_address_waits_mean;

    // Variable:- stats_read_data_waits_inst
    //
    //  A variable for holding the instantaneous read data wait states metric within the <config_stats_enable_read_data_waits> sliding window.
    // 
    //
    int stats_read_data_waits_inst;

    // Variable:- stats_read_data_waits_sw
    //
    //  A variable for holding the calculation of the read data wait states <config_stats_enable_read_data_waits> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_read_data_waits_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_read_data_waits_sw;

    // Variable:- stats_read_data_waits_sw_updated
    //
    //  A variable for holding the number of times the <stats_read_data_waits_sw> sliding window statistic has been updated.
    // It is incremented after every <config_stats_read_data_waits_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest value of the following statistics
    // - <stats_read_data_waits_sw>
    // - <stats_read_data_waits_min>
    // - <stats_read_data_waits_max>
    // - <stats_read_data_waits_mean>
    // 
    //
    int stats_read_data_waits_sw_updated;

    // Variable:- stats_read_data_waits_min
    //
    //  A variable for holding the minimum read data wait states metric within the <config_stats_enable_read_data_waits> sliding window.
    // 
    //
    int stats_read_data_waits_min;

    // Variable:- stats_read_data_waits_max
    //
    //  A variable for holding the maximum read data wait states metric within the <config_stats_enable_read_data_waits> sliding window.
    // 
    //
    int stats_read_data_waits_max;

    // Variable:- stats_read_data_waits_mean
    //
    //  A variable for holding the mean read data wait states metric within the <config_stats_enable_read_data_waits> sliding window.
    // 
    //
    int stats_read_data_waits_mean;

    // Variable:- stats_write_address_waits_inst
    //
    //  A variable for holding the instantaneous write address wait states metric within the <config_stats_enable_write_address_waits> sliding window.
    // 
    //
    int stats_write_address_waits_inst;

    // Variable:- stats_write_address_waits_sw
    //
    //  A variable for holding the calculation of the write address wait states <config_stats_enable_write_address_waits> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_address_waits_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_address_waits_sw;

    // Variable:- stats_write_address_waits_sw_updated
    //
    //  A variable for holding the number of times the <stats_write_address_waits_sw> sliding window statistic has been updated.
    // It is incremented after every <config_stats_write_address_waits_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest value of the following statistics
    // - <stats_write_address_waits_sw>
    // - <stats_write_address_waits_min>
    // - <stats_write_address_waits_max>
    // - <stats_write_address_waits_mean>
    // 
    //
    int stats_write_address_waits_sw_updated;

    // Variable:- stats_write_address_waits_min
    //
    //  A variable for holding the minimum write address wait states metric within the <config_stats_enable_write_address_waits> sliding window.
    // 
    //
    int stats_write_address_waits_min;

    // Variable:- stats_write_address_waits_max
    //
    //  A variable for holding the maximum write address wait states metric within the <config_stats_enable_write_address_waits> sliding window.
    // 
    //
    int stats_write_address_waits_max;

    // Variable:- stats_write_address_waits_mean
    //
    //  A variable for holding the mean write address wait states metric within the <config_stats_enable_write_address_waits> sliding window.
    // 
    //
    int stats_write_address_waits_mean;

    // Variable:- stats_write_data_waits_inst
    //
    //  A variable for holding the instantaneous write data wait states metric within the <config_stats_enable_write_data_waits> sliding window.
    // 
    //
    int stats_write_data_waits_inst;

    // Variable:- stats_write_data_waits_sw
    //
    //  A variable for holding the calculation of the write data wait states <config_stats_enable_write_data_waits> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_data_waits_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_data_waits_sw;

    // Variable:- stats_write_data_waits_sw_updated
    //
    //  A variable for holding the number of times the <stats_write_data_waits_sw> sliding window statistic has been updated.
    // It is incremented after every <config_stats_write_data_waits_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest value of the following statistics.
    // - <stats_write_data_waits_sw>
    // - <stats_write_data_waits_min>
    // - <stats_write_data_waits_max>
    // - <stats_write_data_waits_mean>
    // 
    //
    int stats_write_data_waits_sw_updated;

    // Variable:- stats_write_data_waits_min
    //
    //  A variable for holding the minimum write data wait states metric within the <config_stats_enable_write_data_waits> sliding window.
    // 
    //
    int stats_write_data_waits_min;

    // Variable:- stats_write_data_waits_max
    //
    //  A variable for holding the maximum write data wait states metric within the <config_stats_enable_write_data_waits> sliding window.
    // 
    //
    int stats_write_data_waits_max;

    // Variable:- stats_write_data_waits_mean
    //
    //  A variable for holding the mean write data wait states metric within the <config_stats_enable_write_data_waits> sliding window.
    // 
    //
    int stats_write_data_waits_mean;

    // Variable:- stats_write_response_waits_inst
    //
    //  A variable for holding the instantaneous write response wait states metric within the <config_stats_enable_write_response_waits> sliding window.
    // 
    //
    int stats_write_response_waits_inst;

    // Variable:- stats_write_response_waits_sw
    //
    //  A variable for holding the calculation of the write response wait states <config_stats_enable_write_response_waits> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_response_waits_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_response_waits_sw;

    // Variable:- stats_write_response_waits_sw_updated
    //
    //  A variable for holding the number of times the <stats_write_response_waits_sw> sliding window statistic has been updated.
    // It is incremented after every <config_stats_write_response_waits_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest value of the following statistics.
    // - <stats_write_response_waits_sw>
    // - <stats_write_response_waits_min>
    // - <stats_write_response_waits_max>
    // - <stats_write_response_waits_mean>
    // 
    //
    int stats_write_response_waits_sw_updated;

    // Variable:- stats_write_response_waits_min
    //
    //  A variable for holding the minimum write response wait states metric within the <config_stats_enable_write_response_waits> sliding window.
    // 
    //
    int stats_write_response_waits_min;

    // Variable:- stats_write_response_waits_max
    //
    //  A variable for holding the maximum write response wait states metric within the <config_stats_enable_write_response_waits> sliding window.
    // 
    //
    int stats_write_response_waits_max;

    // Variable:- stats_write_response_waits_mean
    //
    //  A variable for holding the mean write response wait states metric within the <config_stats_enable_write_response_waits> sliding window.
    // 
    //
    int stats_write_response_waits_mean;

    // Variable:- stats_rw_transaction_last_duration
    //
    //  A variable for holding the duration of the last read or write transaction.
    // 
    //
    int stats_rw_transaction_last_duration;

    // Variable:- stats_AXI_read_last_duration
    //
    //  A variable for holding the duration of the last read transaction.
    // 
    //
    int stats_AXI_read_last_duration;

    // Variable:- stats_AXI_write_last_duration
    //
    //  A variable for holding the duration of the last write transaction.
    // 
    //
    int stats_AXI_write_last_duration;

    // Variable:- stats_read_addr_channel_phase_last_duration
    //
    //  A variable for holding the duration of the last read address phase.
    // 
    //
    int stats_read_addr_channel_phase_last_duration;

    // Variable:- stats_read_data_burst_last_duration
    //
    //  A variable for holding the duration of the last read data burst.
    // 
    //
    int stats_read_data_burst_last_duration;

    // Variable:- stats_read_channel_phase_last_duration
    //
    //  A variable for holding the duration of the last read channel phase.
    // 
    //
    int stats_read_channel_phase_last_duration;

    // Variable:- stats_write_addr_channel_phase_last_duration
    //
    //  A variable for holding the duration of the last write address channel phase.
    // 
    //
    int stats_write_addr_channel_phase_last_duration;

    // Variable:- stats_write_data_burst_last_duration
    //
    //  A variable for holding the duration of the last write data burst.
    // 
    //
    int stats_write_data_burst_last_duration;

    // Variable:- stats_write_channel_phase_last_duration
    //
    //  A variable for holding the duration of the last write channel phase.
    // 
    //
    int stats_write_channel_phase_last_duration;

    // Variable:- stats_write_resp_channel_phase_last_duration
    //
    //  A variable for holding the duration of the last write response channel phase.
    // 
    //
    int stats_write_resp_channel_phase_last_duration;

    //------------------------------------------------------------------------------
    // Interface ends and access functions
    //------------------------------------------------------------------------------

    longint axi_master_end;

    //------------------------------------------------------------------------------
    // Function: get_axi_master_end
    //------------------------------------------------------------------------------
    //
    // Returns:
    //     A handle to the master end of this instance of the <axi> interface.
    //
    function longint get_axi_master_end();
        return axi_master_end;
    endfunction

    longint axi_slave_end;

    //------------------------------------------------------------------------------
    // Function: get_axi_slave_end
    //------------------------------------------------------------------------------
    //
    // Returns:
    //     A handle to the slave end of this instance of the <axi> interface.
    //
    function longint get_axi_slave_end();
        return axi_slave_end;
    endfunction

    longint axi_clock_source_end;

    //------------------------------------------------------------------------------
    // Function:- get_axi_clock_source_end
    //------------------------------------------------------------------------------
    //
    // Returns:
    //     A handle to the clock_source end of this instance of the <axi> interface.
    //
    function longint get_axi_clock_source_end();
        return axi_clock_source_end;
    endfunction

    longint axi_reset_source_end;

    //------------------------------------------------------------------------------
    // Function:- get_axi_reset_source_end
    //------------------------------------------------------------------------------
    //
    // Returns:
    //     A handle to the reset_source end of this instance of the <axi> interface.
    //
    function longint get_axi_reset_source_end();
        return axi_reset_source_end;
    endfunction

    longint axi__monitor_end;

    //------------------------------------------------------------------------------
    // Function: get_axi__monitor_end
    //------------------------------------------------------------------------------
    //
    // Returns:
    //     A handle to the _monitor end of this instance of the <axi> interface.
    //
    function longint get_axi__monitor_end();
        return axi__monitor_end;
    endfunction


    //------------------------------------------------------------------------------
    // Assertions
    //------------------------------------------------------------------------------
    // Documentation for assertions has been moved to <axi_assertions.svh>.

    // Declare user visible wires variables, for non-continuous assignments.
    logic m_ACLK = 'z;
    logic m_ARESETn = 'z;
    logic m_AWVALID = 'z;
    logic [((AXI_ADDRESS_WIDTH) - 1):0]  m_AWADDR = 'z;
    logic [3:0] m_AWLEN = 'z;
    logic [2:0] m_AWSIZE = 'z;
    logic [1:0] m_AWBURST = 'z;
    logic [1:0] m_AWLOCK = 'z;
    logic [3:0] m_AWCACHE = 'z;
    logic [2:0] m_AWPROT = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  m_AWID = 'z;
    logic m_AWREADY = 'z;
    logic [7:0] m_AWUSER = 'z;
    logic m_ARVALID = 'z;
    logic [((AXI_ADDRESS_WIDTH) - 1):0]  m_ARADDR = 'z;
    logic [3:0] m_ARLEN = 'z;
    logic [2:0] m_ARSIZE = 'z;
    logic [1:0] m_ARBURST = 'z;
    logic [1:0] m_ARLOCK = 'z;
    logic [3:0] m_ARCACHE = 'z;
    logic [2:0] m_ARPROT = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  m_ARID = 'z;
    logic m_ARREADY = 'z;
    logic [7:0] m_ARUSER = 'z;
    logic m_RVALID = 'z;
    logic m_RLAST = 'z;
    logic [((AXI_RDATA_WIDTH) - 1):0]  m_RDATA = 'z;
    logic [1:0] m_RRESP = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  m_RID = 'z;
    logic m_RREADY = 'z;
    logic [7:0] m_RUSER = 'z;
    logic m_WVALID = 'z;
    logic m_WLAST = 'z;
    logic [((AXI_WDATA_WIDTH) - 1):0]  m_WDATA = 'z;
    logic [(((AXI_WDATA_WIDTH / 8)) - 1):0]  m_WSTRB = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  m_WID = 'z;
    logic m_WREADY = 'z;
    logic [7:0] m_WUSER = 'z;
    logic m_BVALID = 'z;
    logic [1:0] m_BRESP = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  m_BID = 'z;
    logic m_BREADY = 'z;
    logic [7:0] m_BUSER = 'z;

    import "DPI-C" context function longint axi_initialise_SystemVerilog
    (
        int usage_code,
        output longint master_end,
        output longint slave_end,
        output longint clock_source_end,
        output longint reset_source_end,
        output longint _monitor_end,
        input int AXI_ADDRESS_WIDTH,
        input int AXI_RDATA_WIDTH,
        input int AXI_WDATA_WIDTH,
        input int AXI_ID_WIDTH
    );

    // Handle to the linkage
    (* elab_init *) longint _interface_ref =
                                axi_initialise_SystemVerilog
                                (
                                    18102076,
                                    axi_master_end,
                                    axi_slave_end,
                                    axi_clock_source_end,
                                    axi_reset_source_end,
                                    axi__monitor_end,
                                    AXI_ADDRESS_WIDTH,
                                    AXI_RDATA_WIDTH,
                                    AXI_WDATA_WIDTH,
                                    AXI_ID_WIDTH
                                ); // DPI call to create transactor (called at elaboration time as initialiser)

    // Forces a sweep through the wire change checkers at time 0 to get around process kick-off order unknowns
    bit _check_t0_values;
    always_comb _check_t0_values = 1;


    //------------------------------------------------------------------------------
    // Generic Interface Configuration Support
    //------------------------------------------------------------------------------

    import "DPI-C" context axi_set_interface = function void axi_set_interface
    (
        input int what,
        input int arg1,
        input int arg2,
        input int arg3,
        input int arg4,
        input int arg5,
        input int arg6,
        input int arg7,
        input int arg8,
        input int arg9,
        input int arg10
    );
    import "DPI-C" context axi_get_interface = function int axi_get_interface
    (
        input int what,
        input int arg1,
        input int arg2,
        input int arg3,
        input int arg4,
        input int arg5,
        input int arg6,
        input int arg7,
        input int arg8,
        input int arg9
    );
    //------------------------------------------------------------------------------
    // Functions to get the hierarchic name of this interface
    //------------------------------------------------------------------------------
    import "DPI-C" context axi_get_full_name = function string axi_get_full_name();

    //------------------------------------------------------------------------------
    // Abstraction level Support
    //------------------------------------------------------------------------------

    import "DPI-C" context axi_set_master_end_abstraction_level = function void axi_set_master_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi_get_master_end_abstraction_level = function void axi_get_master_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    import "DPI-C" context axi_set_slave_end_abstraction_level = function void axi_set_slave_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi_get_slave_end_abstraction_level = function void axi_get_slave_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    import "DPI-C" context axi_set_clock_source_end_abstraction_level = function void axi_set_clock_source_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi_get_clock_source_end_abstraction_level = function void axi_get_clock_source_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    import "DPI-C" context axi_set_reset_source_end_abstraction_level = function void axi_set_reset_source_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi_get_reset_source_end_abstraction_level = function void axi_get_reset_source_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );

    //------------------------------------------------------------------------------
    // Wire Level Interface Support
    //------------------------------------------------------------------------------
    logic internal_ACLK = 'z;
    logic internal_ARESETn = 'z;
    logic internal_AWVALID = 'z;
    logic [((AXI_ADDRESS_WIDTH) - 1):0]  internal_AWADDR = 'z;
    logic [3:0] internal_AWLEN = 'z;
    logic [2:0] internal_AWSIZE = 'z;
    logic [1:0] internal_AWBURST = 'z;
    logic [1:0] internal_AWLOCK = 'z;
    logic [3:0] internal_AWCACHE = 'z;
    logic [2:0] internal_AWPROT = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  internal_AWID = 'z;
    logic internal_AWREADY = 'z;
    logic [7:0] internal_AWUSER = 'z;
    logic internal_ARVALID = 'z;
    logic [((AXI_ADDRESS_WIDTH) - 1):0]  internal_ARADDR = 'z;
    logic [3:0] internal_ARLEN = 'z;
    logic [2:0] internal_ARSIZE = 'z;
    logic [1:0] internal_ARBURST = 'z;
    logic [1:0] internal_ARLOCK = 'z;
    logic [3:0] internal_ARCACHE = 'z;
    logic [2:0] internal_ARPROT = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  internal_ARID = 'z;
    logic internal_ARREADY = 'z;
    logic [7:0] internal_ARUSER = 'z;
    logic internal_RVALID = 'z;
    logic internal_RLAST = 'z;
    logic [((AXI_RDATA_WIDTH) - 1):0]  internal_RDATA = 'z;
    logic [1:0] internal_RRESP = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  internal_RID = 'z;
    logic internal_RREADY = 'z;
    logic [7:0] internal_RUSER = 'z;
    logic internal_WVALID = 'z;
    logic internal_WLAST = 'z;
    logic [((AXI_WDATA_WIDTH) - 1):0]  internal_WDATA = 'z;
    logic [(((AXI_WDATA_WIDTH / 8)) - 1):0]  internal_WSTRB = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  internal_WID = 'z;
    logic internal_WREADY = 'z;
    logic [7:0] internal_WUSER = 'z;
    logic internal_BVALID = 'z;
    logic [1:0] internal_BRESP = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  internal_BID = 'z;
    logic internal_BREADY = 'z;
    logic [7:0] internal_BUSER = 'z;

    import "DPI-C" context function void axi_set_ACLK_from_SystemVerilog
    (
        input bit ACLK_param
    );
    import "DPI-C" context function void axi_get_ACLK_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ACLK_from_CY;
    export "DPI-C" function axi_initialise_ACLK_from_CY;

    import "DPI-C" context function void axi_set_ARESETn_from_SystemVerilog
    (
        input logic ARESETn_param
    );
    import "DPI-C" context function void axi_get_ARESETn_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARESETn_from_CY;
    export "DPI-C" function axi_initialise_ARESETn_from_CY;

    import "DPI-C" context function void axi_set_AWVALID_from_SystemVerilog
    (
        input logic AWVALID_param
    );
    import "DPI-C" context function void axi_get_AWVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWVALID_from_CY;
    export "DPI-C" function axi_initialise_AWVALID_from_CY;

    import "DPI-C" context function void axi_set_AWADDR_from_SystemVerilog
    (
        input logic [((AXI_ADDRESS_WIDTH) - 1):0]  AWADDR_param
    );
    import "DPI-C" context function void axi_get_AWADDR_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWADDR_from_CY;
    export "DPI-C" function axi_initialise_AWADDR_from_CY;

    import "DPI-C" context function void axi_set_AWLEN_from_SystemVerilog
    (
        input logic [3:0] AWLEN_param
    );
    import "DPI-C" context function void axi_get_AWLEN_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWLEN_from_CY;
    export "DPI-C" function axi_initialise_AWLEN_from_CY;

    import "DPI-C" context function void axi_set_AWSIZE_from_SystemVerilog
    (
        input logic [2:0] AWSIZE_param
    );
    import "DPI-C" context function void axi_get_AWSIZE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWSIZE_from_CY;
    export "DPI-C" function axi_initialise_AWSIZE_from_CY;

    import "DPI-C" context function void axi_set_AWBURST_from_SystemVerilog
    (
        input logic [1:0] AWBURST_param
    );
    import "DPI-C" context function void axi_get_AWBURST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWBURST_from_CY;
    export "DPI-C" function axi_initialise_AWBURST_from_CY;

    import "DPI-C" context function void axi_set_AWLOCK_from_SystemVerilog
    (
        input logic [1:0] AWLOCK_param
    );
    import "DPI-C" context function void axi_get_AWLOCK_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWLOCK_from_CY;
    export "DPI-C" function axi_initialise_AWLOCK_from_CY;

    import "DPI-C" context function void axi_set_AWCACHE_from_SystemVerilog
    (
        input logic [3:0] AWCACHE_param
    );
    import "DPI-C" context function void axi_get_AWCACHE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWCACHE_from_CY;
    export "DPI-C" function axi_initialise_AWCACHE_from_CY;

    import "DPI-C" context function void axi_set_AWPROT_from_SystemVerilog
    (
        input logic [2:0] AWPROT_param
    );
    import "DPI-C" context function void axi_get_AWPROT_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWPROT_from_CY;
    export "DPI-C" function axi_initialise_AWPROT_from_CY;

    import "DPI-C" context function void axi_set_AWID_from_SystemVerilog
    (
        input logic [((AXI_ID_WIDTH) - 1):0]  AWID_param
    );
    import "DPI-C" context function void axi_get_AWID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWID_from_CY;
    export "DPI-C" function axi_initialise_AWID_from_CY;

    import "DPI-C" context function void axi_set_AWREADY_from_SystemVerilog
    (
        input logic AWREADY_param
    );
    import "DPI-C" context function void axi_get_AWREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWREADY_from_CY;
    export "DPI-C" function axi_initialise_AWREADY_from_CY;

    import "DPI-C" context function void axi_set_AWUSER_from_SystemVerilog
    (
        input logic [7:0] AWUSER_param
    );
    import "DPI-C" context function void axi_get_AWUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWUSER_from_CY;
    export "DPI-C" function axi_initialise_AWUSER_from_CY;

    import "DPI-C" context function void axi_set_ARVALID_from_SystemVerilog
    (
        input logic ARVALID_param
    );
    import "DPI-C" context function void axi_get_ARVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARVALID_from_CY;
    export "DPI-C" function axi_initialise_ARVALID_from_CY;

    import "DPI-C" context function void axi_set_ARADDR_from_SystemVerilog
    (
        input logic [((AXI_ADDRESS_WIDTH) - 1):0]  ARADDR_param
    );
    import "DPI-C" context function void axi_get_ARADDR_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARADDR_from_CY;
    export "DPI-C" function axi_initialise_ARADDR_from_CY;

    import "DPI-C" context function void axi_set_ARLEN_from_SystemVerilog
    (
        input logic [3:0] ARLEN_param
    );
    import "DPI-C" context function void axi_get_ARLEN_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARLEN_from_CY;
    export "DPI-C" function axi_initialise_ARLEN_from_CY;

    import "DPI-C" context function void axi_set_ARSIZE_from_SystemVerilog
    (
        input logic [2:0] ARSIZE_param
    );
    import "DPI-C" context function void axi_get_ARSIZE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARSIZE_from_CY;
    export "DPI-C" function axi_initialise_ARSIZE_from_CY;

    import "DPI-C" context function void axi_set_ARBURST_from_SystemVerilog
    (
        input logic [1:0] ARBURST_param
    );
    import "DPI-C" context function void axi_get_ARBURST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARBURST_from_CY;
    export "DPI-C" function axi_initialise_ARBURST_from_CY;

    import "DPI-C" context function void axi_set_ARLOCK_from_SystemVerilog
    (
        input logic [1:0] ARLOCK_param
    );
    import "DPI-C" context function void axi_get_ARLOCK_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARLOCK_from_CY;
    export "DPI-C" function axi_initialise_ARLOCK_from_CY;

    import "DPI-C" context function void axi_set_ARCACHE_from_SystemVerilog
    (
        input logic [3:0] ARCACHE_param
    );
    import "DPI-C" context function void axi_get_ARCACHE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARCACHE_from_CY;
    export "DPI-C" function axi_initialise_ARCACHE_from_CY;

    import "DPI-C" context function void axi_set_ARPROT_from_SystemVerilog
    (
        input logic [2:0] ARPROT_param
    );
    import "DPI-C" context function void axi_get_ARPROT_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARPROT_from_CY;
    export "DPI-C" function axi_initialise_ARPROT_from_CY;

    import "DPI-C" context function void axi_set_ARID_from_SystemVerilog
    (
        input logic [((AXI_ID_WIDTH) - 1):0]  ARID_param
    );
    import "DPI-C" context function void axi_get_ARID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARID_from_CY;
    export "DPI-C" function axi_initialise_ARID_from_CY;

    import "DPI-C" context function void axi_set_ARREADY_from_SystemVerilog
    (
        input logic ARREADY_param
    );
    import "DPI-C" context function void axi_get_ARREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARREADY_from_CY;
    export "DPI-C" function axi_initialise_ARREADY_from_CY;

    import "DPI-C" context function void axi_set_ARUSER_from_SystemVerilog
    (
        input logic [7:0] ARUSER_param
    );
    import "DPI-C" context function void axi_get_ARUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARUSER_from_CY;
    export "DPI-C" function axi_initialise_ARUSER_from_CY;

    import "DPI-C" context function void axi_set_RVALID_from_SystemVerilog
    (
        input logic RVALID_param
    );
    import "DPI-C" context function void axi_get_RVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_RVALID_from_CY;
    export "DPI-C" function axi_initialise_RVALID_from_CY;

    import "DPI-C" context function void axi_set_RLAST_from_SystemVerilog
    (
        input logic RLAST_param
    );
    import "DPI-C" context function void axi_get_RLAST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_RLAST_from_CY;
    export "DPI-C" function axi_initialise_RLAST_from_CY;

    import "DPI-C" context function void axi_set_RDATA_from_SystemVerilog
    (
        input logic [((AXI_RDATA_WIDTH) - 1):0]  RDATA_param
    );
    import "DPI-C" context function void axi_get_RDATA_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_RDATA_from_CY;
    export "DPI-C" function axi_initialise_RDATA_from_CY;

    import "DPI-C" context function void axi_set_RRESP_from_SystemVerilog
    (
        input logic [1:0] RRESP_param
    );
    import "DPI-C" context function void axi_get_RRESP_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_RRESP_from_CY;
    export "DPI-C" function axi_initialise_RRESP_from_CY;

    import "DPI-C" context function void axi_set_RID_from_SystemVerilog
    (
        input logic [((AXI_ID_WIDTH) - 1):0]  RID_param
    );
    import "DPI-C" context function void axi_get_RID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_RID_from_CY;
    export "DPI-C" function axi_initialise_RID_from_CY;

    import "DPI-C" context function void axi_set_RREADY_from_SystemVerilog
    (
        input logic RREADY_param
    );
    import "DPI-C" context function void axi_get_RREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_RREADY_from_CY;
    export "DPI-C" function axi_initialise_RREADY_from_CY;

    import "DPI-C" context function void axi_set_RUSER_from_SystemVerilog
    (
        input logic [7:0] RUSER_param
    );
    import "DPI-C" context function void axi_get_RUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_RUSER_from_CY;
    export "DPI-C" function axi_initialise_RUSER_from_CY;

    import "DPI-C" context function void axi_set_WVALID_from_SystemVerilog
    (
        input logic WVALID_param
    );
    import "DPI-C" context function void axi_get_WVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_WVALID_from_CY;
    export "DPI-C" function axi_initialise_WVALID_from_CY;

    import "DPI-C" context function void axi_set_WLAST_from_SystemVerilog
    (
        input logic WLAST_param
    );
    import "DPI-C" context function void axi_get_WLAST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_WLAST_from_CY;
    export "DPI-C" function axi_initialise_WLAST_from_CY;

    import "DPI-C" context function void axi_set_WDATA_from_SystemVerilog
    (
        input logic [((AXI_WDATA_WIDTH) - 1):0]  WDATA_param
    );
    import "DPI-C" context function void axi_get_WDATA_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_WDATA_from_CY;
    export "DPI-C" function axi_initialise_WDATA_from_CY;

    import "DPI-C" context function void axi_set_WSTRB_from_SystemVerilog
    (
        input logic [(((AXI_WDATA_WIDTH / 8)) - 1):0]  WSTRB_param
    );
    import "DPI-C" context function void axi_get_WSTRB_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_WSTRB_from_CY;
    export "DPI-C" function axi_initialise_WSTRB_from_CY;

    import "DPI-C" context function void axi_set_WID_from_SystemVerilog
    (
        input logic [((AXI_ID_WIDTH) - 1):0]  WID_param
    );
    import "DPI-C" context function void axi_get_WID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_WID_from_CY;
    export "DPI-C" function axi_initialise_WID_from_CY;

    import "DPI-C" context function void axi_set_WREADY_from_SystemVerilog
    (
        input logic WREADY_param
    );
    import "DPI-C" context function void axi_get_WREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_WREADY_from_CY;
    export "DPI-C" function axi_initialise_WREADY_from_CY;

    import "DPI-C" context function void axi_set_WUSER_from_SystemVerilog
    (
        input logic [7:0] WUSER_param
    );
    import "DPI-C" context function void axi_get_WUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_WUSER_from_CY;
    export "DPI-C" function axi_initialise_WUSER_from_CY;

    import "DPI-C" context function void axi_set_BVALID_from_SystemVerilog
    (
        input logic BVALID_param
    );
    import "DPI-C" context function void axi_get_BVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_BVALID_from_CY;
    export "DPI-C" function axi_initialise_BVALID_from_CY;

    import "DPI-C" context function void axi_set_BRESP_from_SystemVerilog
    (
        input logic [1:0] BRESP_param
    );
    import "DPI-C" context function void axi_get_BRESP_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_BRESP_from_CY;
    export "DPI-C" function axi_initialise_BRESP_from_CY;

    import "DPI-C" context function void axi_set_BID_from_SystemVerilog
    (
        input logic [((AXI_ID_WIDTH) - 1):0]  BID_param
    );
    import "DPI-C" context function void axi_get_BID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_BID_from_CY;
    export "DPI-C" function axi_initialise_BID_from_CY;

    import "DPI-C" context function void axi_set_BREADY_from_SystemVerilog
    (
        input logic BREADY_param
    );
    import "DPI-C" context function void axi_get_BREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_BREADY_from_CY;
    export "DPI-C" function axi_initialise_BREADY_from_CY;

    import "DPI-C" context function void axi_set_BUSER_from_SystemVerilog
    (
        input logic [7:0] BUSER_param
    );
    import "DPI-C" context function void axi_get_BUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_BUSER_from_CY;
    export "DPI-C" function axi_initialise_BUSER_from_CY;

    import "DPI-C" context function void axi_set_config_clk_init_value_from_SystemVerilog
    (
        input bit config_clk_init_value_param
    );
    import "DPI-C" context function void axi_get_config_clk_init_value_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_clk_init_value_from_CY;

    import "DPI-C" context function void axi_set_config_clk_phase_shift_from_SystemVerilog
    (
        input int config_clk_phase_shift_param
    );
    import "DPI-C" context function void axi_get_config_clk_phase_shift_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_clk_phase_shift_from_CY;

    import "DPI-C" context function void axi_set_config_clk_1st_time_from_SystemVerilog
    (
        input int config_clk_1st_time_param
    );
    import "DPI-C" context function void axi_get_config_clk_1st_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_clk_1st_time_from_CY;

    import "DPI-C" context function void axi_set_config_clk_2nd_time_from_SystemVerilog
    (
        input int config_clk_2nd_time_param
    );
    import "DPI-C" context function void axi_get_config_clk_2nd_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_clk_2nd_time_from_CY;

    import "DPI-C" context function void axi_set_config_setup_time_from_SystemVerilog
    (
        input int config_setup_time_param
    );
    import "DPI-C" context function void axi_get_config_setup_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_setup_time_from_CY;

    import "DPI-C" context function void axi_set_config_hold_time_from_SystemVerilog
    (
        input int config_hold_time_param
    );
    import "DPI-C" context function void axi_get_config_hold_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_hold_time_from_CY;

    import "DPI-C" context function void axi_set_config_max_transaction_time_factor_from_SystemVerilog
    (
        input int unsigned config_max_transaction_time_factor_param
    );
    import "DPI-C" context function void axi_get_config_max_transaction_time_factor_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_transaction_time_factor_from_CY;

    import "DPI-C" context function void axi_set_config_timeout_max_data_transfer_from_SystemVerilog
    (
        input int config_timeout_max_data_transfer_param
    );
    import "DPI-C" context function void axi_get_config_timeout_max_data_transfer_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_timeout_max_data_transfer_from_CY;

    import "DPI-C" context function void axi_set_config_burst_timeout_factor_from_SystemVerilog
    (
        input int unsigned config_burst_timeout_factor_param
    );
    import "DPI-C" context function void axi_get_config_burst_timeout_factor_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_burst_timeout_factor_from_CY;

    import "DPI-C" context function void axi_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param
    );
    import "DPI-C" context function void axi_get_config_max_latency_AWVALID_assertion_to_AWREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_CY;

    import "DPI-C" context function void axi_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param
    );
    import "DPI-C" context function void axi_get_config_max_latency_ARVALID_assertion_to_ARREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_CY;

    import "DPI-C" context function void axi_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_RVALID_assertion_to_RREADY_param
    );
    import "DPI-C" context function void axi_get_config_max_latency_RVALID_assertion_to_RREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_latency_RVALID_assertion_to_RREADY_from_CY;

    import "DPI-C" context function void axi_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_BVALID_assertion_to_BREADY_param
    );
    import "DPI-C" context function void axi_get_config_max_latency_BVALID_assertion_to_BREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_latency_BVALID_assertion_to_BREADY_from_CY;

    import "DPI-C" context function void axi_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_WVALID_assertion_to_WREADY_param
    );
    import "DPI-C" context function void axi_get_config_max_latency_WVALID_assertion_to_WREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_latency_WVALID_assertion_to_WREADY_from_CY;

    import "DPI-C" context function void axi_set_config_write_ctrl_first_ratio_from_SystemVerilog
    (
        input int config_write_ctrl_first_ratio_param
    );
    import "DPI-C" context function void axi_get_config_write_ctrl_first_ratio_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_write_ctrl_first_ratio_from_CY;

    import "DPI-C" context function void axi_set_config_write_data_first_ratio_from_SystemVerilog
    (
        input int config_write_data_first_ratio_param
    );
    import "DPI-C" context function void axi_get_config_write_data_first_ratio_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_write_data_first_ratio_from_CY;

    import "DPI-C" context function void axi_set_config_write_ctrl_to_data_mintime_from_SystemVerilog
    (
        input int unsigned config_write_ctrl_to_data_mintime_param
    );
    import "DPI-C" context function void axi_get_config_write_ctrl_to_data_mintime_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_write_ctrl_to_data_mintime_from_CY;

    import "DPI-C" context function void axi_set_config_write_data_to_ctrl_mintime_from_SystemVerilog
    (
        input int unsigned config_write_data_to_ctrl_mintime_param
    );
    import "DPI-C" context function void axi_get_config_write_data_to_ctrl_mintime_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_write_data_to_ctrl_mintime_from_CY;

    import "DPI-C" context function void axi_set_config_master_write_delay_from_SystemVerilog
    (
        input bit config_master_write_delay_param
    );
    import "DPI-C" context function void axi_get_config_master_write_delay_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_master_write_delay_from_CY;

    import "DPI-C" context function void axi_set_config_reset_low_clocks_from_SystemVerilog
    (
        input int config_reset_low_clocks_param
    );
    import "DPI-C" context function void axi_get_config_reset_low_clocks_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_reset_low_clocks_from_CY;

    import "DPI-C" context function void axi_set_config_reset_hold_time_from_SystemVerilog
    (
        input int config_reset_hold_time_param
    );
    import "DPI-C" context function void axi_get_config_reset_hold_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_reset_hold_time_from_CY;

    import "DPI-C" context function void axi_set_config_protect_ready_from_SystemVerilog
    (
        input bit config_protect_ready_param
    );
    import "DPI-C" context function void axi_get_config_protect_ready_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_protect_ready_from_CY;

    import "DPI-C" context function void axi_set_config_enable_user_sideband_from_SystemVerilog
    (
        input bit config_enable_user_sideband_param
    );
    import "DPI-C" context function void axi_get_config_enable_user_sideband_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_user_sideband_from_CY;

    import "DPI-C" context function void axi_set_config_extended_length_enable_from_SystemVerilog
    (
        input bit config_extended_length_enable_param
    );
    import "DPI-C" context function void axi_get_config_extended_length_enable_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_extended_length_enable_from_CY;

    import "DPI-C" context function void axi_set_config_enable_burst_reserved_value_from_SystemVerilog
    (
        input bit config_enable_burst_reserved_value_param
    );
    import "DPI-C" context function void axi_get_config_enable_burst_reserved_value_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_burst_reserved_value_from_CY;

    import "DPI-C" context function void axi_set_config_enable_lock_reserved_value_from_SystemVerilog
    (
        input bit config_enable_lock_reserved_value_param
    );
    import "DPI-C" context function void axi_get_config_enable_lock_reserved_value_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_lock_reserved_value_from_CY;

    import "DPI-C" context function void axi_set_config_enable_cache_reserved_value_from_SystemVerilog
    (
        input bit config_enable_cache_reserved_value_param
    );
    import "DPI-C" context function void axi_get_config_enable_cache_reserved_value_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_cache_reserved_value_from_CY;

    import "DPI-C" context function void axi_set_config_enable_all_assertions_from_SystemVerilog
    (
        input bit config_enable_all_assertions_param
    );
    import "DPI-C" context function void axi_get_config_enable_all_assertions_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_all_assertions_from_CY;

    import "DPI-C" context function void axi_set_config_enable_assertion_from_SystemVerilog
    (
        input bit [255:0] config_enable_assertion_param
    );
    import "DPI-C" context function void axi_get_config_enable_assertion_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_assertion_from_CY;

    import "DPI-C" context function void axi_set_config_enable_error_from_SystemVerilog
    (
        input bit [255:0] config_enable_error_param
    );
    import "DPI-C" context function void axi_get_config_enable_error_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_error_from_CY;

    import "DPI-C" context function void axi_set_config_enable_errors_from_SystemVerilog
    (
        input bit config_enable_errors_param
    );
    import "DPI-C" context function void axi_get_config_enable_errors_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_errors_from_CY;

    import "DPI-C" context function void axi_set_config_enable_all_assertion_errors_from_SystemVerilog
    (
        input bit config_enable_all_assertion_errors_param
    );
    import "DPI-C" context function void axi_get_config_enable_all_assertion_errors_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_all_assertion_errors_from_CY;

    import "DPI-C" context function void axi_set_config_abstraction_level_from_SystemVerilog
    (
        input axi_abstraction_level_e config_abstraction_level_param
    );
    import "DPI-C" context function void axi_get_config_abstraction_level_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_abstraction_level_from_CY;

    import "DPI-C" context function void axi_set_config_slave_start_addr_from_SystemVerilog
    (
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param
    );
    import "DPI-C" context function void axi_get_config_slave_start_addr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_slave_start_addr_from_CY;

    import "DPI-C" context function void axi_set_config_slave_end_addr_from_SystemVerilog
    (
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param
    );
    import "DPI-C" context function void axi_get_config_slave_end_addr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_slave_end_addr_from_CY;

    import "DPI-C" context function void axi_set_config_enable_slave_addr_range_in_bfm_from_SystemVerilog
    (
        input bit config_enable_slave_addr_range_in_bfm_param
    );
    import "DPI-C" context function void axi_get_config_enable_slave_addr_range_in_bfm_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_slave_addr_range_in_bfm_from_CY;

    import "DPI-C" context function void axi_set_config_read_data_reordering_depth_from_SystemVerilog
    (
        input int unsigned config_read_data_reordering_depth_param
    );
    import "DPI-C" context function void axi_get_config_read_data_reordering_depth_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_read_data_reordering_depth_from_CY;

    import "DPI-C" context function void axi_set_config_enable_read_data_reordering_depth_in_bfm_from_SystemVerilog
    (
        input bit config_enable_read_data_reordering_depth_in_bfm_param
    );
    import "DPI-C" context function void axi_get_config_enable_read_data_reordering_depth_in_bfm_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_read_data_reordering_depth_in_bfm_from_CY;

    import "DPI-C" context function void axi_set_config_awid_wid_mismatch_from_SystemVerilog
    (
        input bit config_awid_wid_mismatch_param
    );
    import "DPI-C" context function void axi_get_config_awid_wid_mismatch_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_awid_wid_mismatch_from_CY;

    import "DPI-C" context function void axi_set_config_length_last_mismatch_error_from_SystemVerilog
    (
        input bit config_length_last_mismatch_error_param
    );
    import "DPI-C" context function void axi_get_config_length_last_mismatch_error_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_length_last_mismatch_error_from_CY;

    import "DPI-C" context function void axi_set_config_master_error_position_from_SystemVerilog
    (
        input axi_error_e config_master_error_position_param
    );
    import "DPI-C" context function void axi_get_config_master_error_position_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_master_error_position_from_CY;

    import "DPI-C" context function void axi_set_dummy_var_from_SystemVerilog
    (
        input axi_assertion_type_e dummy_var_param
    );
    import "DPI-C" context function void axi_get_dummy_var_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_dummy_var_from_CY;

    import "DPI-C" context function void axi_set_config_wlast_length_from_SystemVerilog
    (
        input int config_wlast_length_param
    );
    import "DPI-C" context function void axi_get_config_wlast_length_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_wlast_length_from_CY;

    import "DPI-C" context function void axi_set_config_wid_for_awid_not_matching_from_SystemVerilog
    (
        input bit [((AXI_ID_WIDTH) - 1):0]  config_wid_for_awid_not_matching_param
    );
    import "DPI-C" context function void axi_get_config_wid_for_awid_not_matching_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_wid_for_awid_not_matching_from_CY;

    import "DPI-C" context function void axi_set_config_support_exclusive_access_from_SystemVerilog
    (
        input bit config_support_exclusive_access_param
    );
    import "DPI-C" context function void axi_get_config_support_exclusive_access_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_support_exclusive_access_from_CY;

    import "DPI-C" context function void axi_set_config_write_data_interleaving_depth_from_SystemVerilog
    (
        input int config_write_data_interleaving_depth_param
    );
    import "DPI-C" context function void axi_get_config_write_data_interleaving_depth_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_write_data_interleaving_depth_from_CY;

    import "DPI-C" context function void axi_set_status_master_error_from_SystemVerilog
    (
        input bit [15:0] status_master_error_param
    );
    import "DPI-C" context function void axi_get_status_master_error_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_status_master_error_from_CY;

    import "DPI-C" context function void axi_get_status_num_reads_waiting_for_resp_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_status_num_reads_waiting_for_resp_from_CY;

    import "DPI-C" context function void axi_get_status_num_writes_waiting_for_response_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_status_num_writes_waiting_for_response_from_CY;

    import "DPI-C" context function void axi_set_check_total_num_wdata_outstanding_from_SystemVerilog
    (
        input bit check_total_num_wdata_outstanding_param
    );
    import "DPI-C" context function void axi_get_check_total_num_wdata_outstanding_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_check_total_num_wdata_outstanding_from_CY;

    import "DPI-C" context function void axi_set_total_num_wdata_outstanding_from_SystemVerilog
    (
        input int total_num_wdata_outstanding_param
    );
    import "DPI-C" context function void axi_get_total_num_wdata_outstanding_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_total_num_wdata_outstanding_from_CY;

    import "DPI-C" context function void axi_set_check_max_num_wdata_outstanding_per_id_from_SystemVerilog
    (
        input bit check_max_num_wdata_outstanding_per_id_param
    );
    import "DPI-C" context function void axi_get_check_max_num_wdata_outstanding_per_id_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_check_max_num_wdata_outstanding_per_id_from_CY;

    import "DPI-C" context function void axi_set_max_num_wdata_outstanding_per_id_from_SystemVerilog
    (
        input int max_num_wdata_outstanding_per_id_param
    );
    import "DPI-C" context function void axi_get_max_num_wdata_outstanding_per_id_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_max_num_wdata_outstanding_per_id_from_CY;

    import "DPI-C" context function void axi_set_check_max_num_waddr_outstanding_per_id_from_SystemVerilog
    (
        input bit check_max_num_waddr_outstanding_per_id_param
    );
    import "DPI-C" context function void axi_get_check_max_num_waddr_outstanding_per_id_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_check_max_num_waddr_outstanding_per_id_from_CY;

    import "DPI-C" context function void axi_set_max_num_waddr_outstanding_per_id_from_SystemVerilog
    (
        input int max_num_waddr_outstanding_per_id_param
    );
    import "DPI-C" context function void axi_get_max_num_waddr_outstanding_per_id_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_max_num_waddr_outstanding_per_id_from_CY;

    import "DPI-C" context function void axi_set_check_total_num_waddr_outstanding_from_SystemVerilog
    (
        input bit check_total_num_waddr_outstanding_param
    );
    import "DPI-C" context function void axi_get_check_total_num_waddr_outstanding_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_check_total_num_waddr_outstanding_from_CY;

    import "DPI-C" context function void axi_set_total_num_waddr_outstanding_from_SystemVerilog
    (
        input int total_num_waddr_outstanding_param
    );
    import "DPI-C" context function void axi_get_total_num_waddr_outstanding_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_total_num_waddr_outstanding_from_CY;

    import "DPI-C" context function void axi_set_status_outstanding_num_for_waddr_from_SystemVerilog
    (
        input int status_outstanding_num_for_waddr_param
    );
    import "DPI-C" context function void axi_get_status_outstanding_num_for_waddr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_status_outstanding_num_for_waddr_from_CY;

    import "DPI-C" context function void axi_set_start_finding_outstanding_waddr_from_SystemVerilog
    (
        input bit start_finding_outstanding_waddr_param
    );
    import "DPI-C" context function void axi_get_start_finding_outstanding_waddr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_start_finding_outstanding_waddr_from_CY;

    import "DPI-C" context function void axi_set_status_outstanding_num_for_wdata_from_SystemVerilog
    (
        input int status_outstanding_num_for_wdata_param
    );
    import "DPI-C" context function void axi_get_status_outstanding_num_for_wdata_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_status_outstanding_num_for_wdata_from_CY;

    import "DPI-C" context function void axi_set_start_finding_outstanding_wdata_from_SystemVerilog
    (
        input bit start_finding_outstanding_wdata_param
    );
    import "DPI-C" context function void axi_get_start_finding_outstanding_wdata_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_start_finding_outstanding_wdata_from_CY;

    import "DPI-C" context function void axi_set_find_waddr_outstanding_for_wid_from_SystemVerilog
    (
        input bit [((AXI_ID_WIDTH) - 1):0]  find_waddr_outstanding_for_wid_param
    );
    import "DPI-C" context function void axi_get_find_waddr_outstanding_for_wid_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_find_waddr_outstanding_for_wid_from_CY;

    import "DPI-C" context function void axi_set_find_wdata_outstanding_for_wid_from_SystemVerilog
    (
        input bit [((AXI_ID_WIDTH) - 1):0]  find_wdata_outstanding_for_wid_param
    );
    import "DPI-C" context function void axi_get_find_wdata_outstanding_for_wid_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_find_wdata_outstanding_for_wid_from_CY;

    import "DPI-C" context function void axi_set_change_in_wdata_outstanding_per_id_from_SystemVerilog
    (
        input bit change_in_wdata_outstanding_per_id_param
    );
    import "DPI-C" context function void axi_get_change_in_wdata_outstanding_per_id_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_change_in_wdata_outstanding_per_id_from_CY;

    import "DPI-C" context function void axi_set_start_finding_change_in_wdata_from_SystemVerilog
    (
        input bit start_finding_change_in_wdata_param
    );
    import "DPI-C" context function void axi_get_start_finding_change_in_wdata_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_start_finding_change_in_wdata_from_CY;

    import "DPI-C" context function void axi_set_find_change_in_wdata_outstanding_for_wid_from_SystemVerilog
    (
        input bit [((AXI_ID_WIDTH) - 1):0]  find_change_in_wdata_outstanding_for_wid_param
    );
    import "DPI-C" context function void axi_get_find_change_in_wdata_outstanding_for_wid_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_find_change_in_wdata_outstanding_for_wid_from_CY;

    import "DPI-C" context function void axi_set_config_max_outstanding_wr_from_SystemVerilog
    (
        input int config_max_outstanding_wr_param
    );
    import "DPI-C" context function void axi_get_config_max_outstanding_wr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_outstanding_wr_from_CY;

    import "DPI-C" context function void axi_set_config_max_outstanding_rd_from_SystemVerilog
    (
        input int config_max_outstanding_rd_param
    );
    import "DPI-C" context function void axi_get_config_max_outstanding_rd_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_outstanding_rd_from_CY;

    import "DPI-C" context function void axi_set_config_error_on_deleted_valid_cycles_from_SystemVerilog
    (
        input bit config_error_on_deleted_valid_cycles_param
    );
    import "DPI-C" context function void axi_get_config_error_on_deleted_valid_cycles_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_error_on_deleted_valid_cycles_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_from_SystemVerilog
    (
        input bit config_stats_enable_param
    );
    import "DPI-C" context function void axi_get_config_stats_enable_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_AXI_read_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_AXI_read_occupancy_param
    );
    import "DPI-C" context function void axi_get_config_stats_enable_AXI_read_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_AXI_read_occupancy_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_AXI_write_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_AXI_write_occupancy_param
    );
    import "DPI-C" context function void axi_get_config_stats_enable_AXI_write_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_AXI_write_occupancy_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_read_data_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_read_data_occupancy_param
    );
    import "DPI-C" context function void axi_get_config_stats_enable_read_data_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_read_data_occupancy_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_write_data_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_write_data_occupancy_param
    );
    import "DPI-C" context function void axi_get_config_stats_enable_write_data_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_write_data_occupancy_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_read_latency_from_SystemVerilog
    (
        input bit config_stats_enable_read_latency_param
    );
    import "DPI-C" context function void axi_get_config_stats_enable_read_latency_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_read_latency_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_write_latency_from_SystemVerilog
    (
        input bit config_stats_enable_write_latency_param
    );
    import "DPI-C" context function void axi_get_config_stats_enable_write_latency_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_write_latency_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_read_address_waits_from_SystemVerilog
    (
        input bit config_stats_enable_read_address_waits_param
    );
    import "DPI-C" context function void axi_get_config_stats_enable_read_address_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_read_address_waits_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_read_data_waits_from_SystemVerilog
    (
        input bit config_stats_enable_read_data_waits_param
    );
    import "DPI-C" context function void axi_get_config_stats_enable_read_data_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_read_data_waits_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_write_address_waits_from_SystemVerilog
    (
        input bit config_stats_enable_write_address_waits_param
    );
    import "DPI-C" context function void axi_get_config_stats_enable_write_address_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_write_address_waits_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_write_data_waits_from_SystemVerilog
    (
        input bit config_stats_enable_write_data_waits_param
    );
    import "DPI-C" context function void axi_get_config_stats_enable_write_data_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_write_data_waits_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_write_response_waits_from_SystemVerilog
    (
        input bit config_stats_enable_write_response_waits_param
    );
    import "DPI-C" context function void axi_get_config_stats_enable_write_response_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_write_response_waits_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_read_bandwidth_from_SystemVerilog
    (
        input bit config_stats_enable_read_bandwidth_param
    );
    import "DPI-C" context function void axi_get_config_stats_enable_read_bandwidth_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_read_bandwidth_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_write_bandwidth_from_SystemVerilog
    (
        input bit config_stats_enable_write_bandwidth_param
    );
    import "DPI-C" context function void axi_get_config_stats_enable_write_bandwidth_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_write_bandwidth_from_CY;

    import "DPI-C" context function void axi_set_config_stats_AXI_read_occupancy_step_from_SystemVerilog
    (
        input int config_stats_AXI_read_occupancy_step_param
    );
    import "DPI-C" context function void axi_get_config_stats_AXI_read_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_AXI_read_occupancy_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_AXI_read_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_AXI_read_occupancy_multiple_param
    );
    import "DPI-C" context function void axi_get_config_stats_AXI_read_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_AXI_read_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_active_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_active_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_occupancy_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_occupancy_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_occupancy_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_idle_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_occupancy_min_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_idle_min_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_occupancy_max_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_idle_max_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_occupancy_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_idle_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_AXI_write_occupancy_step_from_SystemVerilog
    (
        input int config_stats_AXI_write_occupancy_step_param
    );
    import "DPI-C" context function void axi_get_config_stats_AXI_write_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_AXI_write_occupancy_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_AXI_write_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_AXI_write_occupancy_multiple_param
    );
    import "DPI-C" context function void axi_get_config_stats_AXI_write_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_AXI_write_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_active_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_active_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_occupancy_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_occupancy_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_occupancy_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_idle_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_occupancy_min_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_idle_min_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_occupancy_max_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_idle_max_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_occupancy_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_idle_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_data_occupancy_step_from_SystemVerilog
    (
        input int config_stats_read_data_occupancy_step_param
    );
    import "DPI-C" context function void axi_get_config_stats_read_data_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_data_occupancy_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_read_data_occupancy_multiple_param
    );
    import "DPI-C" context function void axi_get_config_stats_read_data_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_data_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_occupancy_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_occupancy_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_occupancy_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_idle_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_occupancy_min_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_idle_min_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_occupancy_max_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_idle_max_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_occupancy_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_idle_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_data_occupancy_step_from_SystemVerilog
    (
        input int config_stats_write_data_occupancy_step_param
    );
    import "DPI-C" context function void axi_get_config_stats_write_data_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_data_occupancy_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_write_data_occupancy_multiple_param
    );
    import "DPI-C" context function void axi_get_config_stats_write_data_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_data_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_occupancy_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_occupancy_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_occupancy_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_idle_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_occupancy_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_idle_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_occupancy_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_idle_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_occupancy_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_idle_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_bandwidth_step_from_SystemVerilog
    (
        input int config_stats_read_bandwidth_step_param
    );
    import "DPI-C" context function void axi_get_config_stats_read_bandwidth_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_bandwidth_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_bandwidth_multiple_from_SystemVerilog
    (
        input int config_stats_read_bandwidth_multiple_param
    );
    import "DPI-C" context function void axi_get_config_stats_read_bandwidth_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_bandwidth_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_read_bandwidth_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_bandwidth_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_read_bandwidth_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_bandwidth_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_read_bandwidth_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_bandwidth_min_from_CY;

    import "DPI-C" context function void axi_get_stats_read_bandwidth_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_bandwidth_max_from_CY;

    import "DPI-C" context function void axi_get_stats_read_bandwidth_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_bandwidth_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_bandwidth_step_from_SystemVerilog
    (
        input int config_stats_write_bandwidth_step_param
    );
    import "DPI-C" context function void axi_get_config_stats_write_bandwidth_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_bandwidth_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_bandwidth_multiple_from_SystemVerilog
    (
        input int config_stats_write_bandwidth_multiple_param
    );
    import "DPI-C" context function void axi_get_config_stats_write_bandwidth_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_bandwidth_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_write_bandwidth_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_bandwidth_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_bandwidth_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_bandwidth_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_write_bandwidth_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_bandwidth_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_bandwidth_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_bandwidth_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_bandwidth_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_bandwidth_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_latency_step_from_SystemVerilog
    (
        input int config_stats_read_latency_step_param
    );
    import "DPI-C" context function void axi_get_config_stats_read_latency_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_latency_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_latency_multiple_from_SystemVerilog
    (
        input int config_stats_read_latency_multiple_param
    );
    import "DPI-C" context function void axi_get_config_stats_read_latency_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_latency_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_read_latency_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_latency_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_data_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_data_latency_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_data_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_data_latency_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_data_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_data_latency_min_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_data_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_data_latency_max_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_data_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_data_latency_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_address_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_address_latency_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_address_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_address_latency_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_address_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_address_latency_min_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_address_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_address_latency_max_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_address_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_address_latency_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_latency_step_from_SystemVerilog
    (
        input int config_stats_write_latency_step_param
    );
    import "DPI-C" context function void axi_get_config_stats_write_latency_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_latency_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_latency_multiple_from_SystemVerilog
    (
        input int config_stats_write_latency_multiple_param
    );
    import "DPI-C" context function void axi_get_config_stats_write_latency_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_latency_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_write_latency_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_latency_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_data_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_data_latency_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_data_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_data_latency_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_data_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_data_latency_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_data_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_data_latency_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_data_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_data_latency_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_response_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_response_latency_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_response_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_response_latency_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_response_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_response_latency_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_response_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_response_latency_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_response_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_response_latency_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_address_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_address_latency_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_address_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_address_latency_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_address_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_address_latency_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_address_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_address_latency_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_address_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_address_latency_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_address_waits_step_from_SystemVerilog
    (
        input int config_stats_read_address_waits_step_param
    );
    import "DPI-C" context function void axi_get_config_stats_read_address_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_address_waits_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_address_waits_multiple_from_SystemVerilog
    (
        input int config_stats_read_address_waits_multiple_param
    );
    import "DPI-C" context function void axi_get_config_stats_read_address_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_address_waits_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_waits_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_waits_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_waits_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_waits_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_waits_min_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_waits_max_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_waits_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_data_waits_step_from_SystemVerilog
    (
        input int config_stats_read_data_waits_step_param
    );
    import "DPI-C" context function void axi_get_config_stats_read_data_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_data_waits_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_data_waits_multiple_from_SystemVerilog
    (
        input int config_stats_read_data_waits_multiple_param
    );
    import "DPI-C" context function void axi_get_config_stats_read_data_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_data_waits_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_waits_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_waits_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_waits_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_waits_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_waits_min_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_waits_max_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_waits_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_address_waits_step_from_SystemVerilog
    (
        input int config_stats_write_address_waits_step_param
    );
    import "DPI-C" context function void axi_get_config_stats_write_address_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_address_waits_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_address_waits_multiple_from_SystemVerilog
    (
        input int config_stats_write_address_waits_multiple_param
    );
    import "DPI-C" context function void axi_get_config_stats_write_address_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_address_waits_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_waits_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_waits_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_waits_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_waits_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_waits_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_waits_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_waits_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_data_waits_step_from_SystemVerilog
    (
        input int config_stats_write_data_waits_step_param
    );
    import "DPI-C" context function void axi_get_config_stats_write_data_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_data_waits_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_data_waits_multiple_from_SystemVerilog
    (
        input int config_stats_write_data_waits_multiple_param
    );
    import "DPI-C" context function void axi_get_config_stats_write_data_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_data_waits_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_waits_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_waits_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_waits_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_waits_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_waits_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_waits_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_waits_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_response_waits_step_from_SystemVerilog
    (
        input int config_stats_write_response_waits_step_param
    );
    import "DPI-C" context function void axi_get_config_stats_write_response_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_response_waits_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_response_waits_multiple_from_SystemVerilog
    (
        input int config_stats_write_response_waits_multiple_param
    );
    import "DPI-C" context function void axi_get_config_stats_write_response_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_response_waits_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_write_response_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_response_waits_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_write_response_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_response_waits_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_response_waits_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_response_waits_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_write_response_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_response_waits_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_response_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_response_waits_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_response_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_response_waits_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_rw_transaction_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_rw_transaction_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_read_addr_channel_phase_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_addr_channel_phase_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_burst_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_burst_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_read_channel_phase_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_channel_phase_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_write_addr_channel_phase_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_addr_channel_phase_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_burst_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_burst_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_write_channel_phase_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_channel_phase_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_write_resp_channel_phase_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_resp_channel_phase_last_duration_from_CY;

    function void axi_set_ACLK_from_CY( bit ACLK_param );
        internal_ACLK = ACLK_param;
    endfunction

    function void axi_initialise_ACLK_from_CY();
        internal_ACLK = 'z;
        m_ACLK = 'z;
    endfunction

    function void axi_set_ARESETn_from_CY( logic ARESETn_param );
        internal_ARESETn = ARESETn_param;
    endfunction

    function void axi_initialise_ARESETn_from_CY();
        internal_ARESETn = 'z;
        m_ARESETn = 'z;
    endfunction

    function void axi_set_AWVALID_from_CY( logic AWVALID_param );
        internal_AWVALID = AWVALID_param;
    endfunction

    function void axi_initialise_AWVALID_from_CY();
        internal_AWVALID = 'z;
        m_AWVALID = 'z;
    endfunction

    function void axi_set_AWADDR_from_CY( logic [((AXI_ADDRESS_WIDTH) - 1):0]  AWADDR_param );
        internal_AWADDR = AWADDR_param;
    endfunction

    function void axi_initialise_AWADDR_from_CY();
        internal_AWADDR = 'z;
        m_AWADDR = 'z;
    endfunction

    function void axi_set_AWLEN_from_CY( logic [3:0] AWLEN_param );
        internal_AWLEN = AWLEN_param;
    endfunction

    function void axi_initialise_AWLEN_from_CY();
        internal_AWLEN = 'z;
        m_AWLEN = 'z;
    endfunction

    function void axi_set_AWSIZE_from_CY( logic [2:0] AWSIZE_param );
        internal_AWSIZE = AWSIZE_param;
    endfunction

    function void axi_initialise_AWSIZE_from_CY();
        internal_AWSIZE = 'z;
        m_AWSIZE = 'z;
    endfunction

    function void axi_set_AWBURST_from_CY( logic [1:0] AWBURST_param );
        internal_AWBURST = AWBURST_param;
    endfunction

    function void axi_initialise_AWBURST_from_CY();
        internal_AWBURST = 'z;
        m_AWBURST = 'z;
    endfunction

    function void axi_set_AWLOCK_from_CY( logic [1:0] AWLOCK_param );
        internal_AWLOCK = AWLOCK_param;
    endfunction

    function void axi_initialise_AWLOCK_from_CY();
        internal_AWLOCK = 'z;
        m_AWLOCK = 'z;
    endfunction

    function void axi_set_AWCACHE_from_CY( logic [3:0] AWCACHE_param );
        internal_AWCACHE = AWCACHE_param;
    endfunction

    function void axi_initialise_AWCACHE_from_CY();
        internal_AWCACHE = 'z;
        m_AWCACHE = 'z;
    endfunction

    function void axi_set_AWPROT_from_CY( logic [2:0] AWPROT_param );
        internal_AWPROT = AWPROT_param;
    endfunction

    function void axi_initialise_AWPROT_from_CY();
        internal_AWPROT = 'z;
        m_AWPROT = 'z;
    endfunction

    function void axi_set_AWID_from_CY( logic [((AXI_ID_WIDTH) - 1):0]  AWID_param );
        internal_AWID = AWID_param;
    endfunction

    function void axi_initialise_AWID_from_CY();
        internal_AWID = 'z;
        m_AWID = 'z;
    endfunction

    function void axi_set_AWREADY_from_CY( logic AWREADY_param );
        internal_AWREADY = AWREADY_param;
    endfunction

    function void axi_initialise_AWREADY_from_CY();
        internal_AWREADY = 'z;
        m_AWREADY = 'z;
    endfunction

    function void axi_set_AWUSER_from_CY( logic [7:0] AWUSER_param );
        internal_AWUSER = AWUSER_param;
    endfunction

    function void axi_initialise_AWUSER_from_CY();
        internal_AWUSER = 'z;
        m_AWUSER = 'z;
    endfunction

    function void axi_set_ARVALID_from_CY( logic ARVALID_param );
        internal_ARVALID = ARVALID_param;
    endfunction

    function void axi_initialise_ARVALID_from_CY();
        internal_ARVALID = 'z;
        m_ARVALID = 'z;
    endfunction

    function void axi_set_ARADDR_from_CY( logic [((AXI_ADDRESS_WIDTH) - 1):0]  ARADDR_param );
        internal_ARADDR = ARADDR_param;
    endfunction

    function void axi_initialise_ARADDR_from_CY();
        internal_ARADDR = 'z;
        m_ARADDR = 'z;
    endfunction

    function void axi_set_ARLEN_from_CY( logic [3:0] ARLEN_param );
        internal_ARLEN = ARLEN_param;
    endfunction

    function void axi_initialise_ARLEN_from_CY();
        internal_ARLEN = 'z;
        m_ARLEN = 'z;
    endfunction

    function void axi_set_ARSIZE_from_CY( logic [2:0] ARSIZE_param );
        internal_ARSIZE = ARSIZE_param;
    endfunction

    function void axi_initialise_ARSIZE_from_CY();
        internal_ARSIZE = 'z;
        m_ARSIZE = 'z;
    endfunction

    function void axi_set_ARBURST_from_CY( logic [1:0] ARBURST_param );
        internal_ARBURST = ARBURST_param;
    endfunction

    function void axi_initialise_ARBURST_from_CY();
        internal_ARBURST = 'z;
        m_ARBURST = 'z;
    endfunction

    function void axi_set_ARLOCK_from_CY( logic [1:0] ARLOCK_param );
        internal_ARLOCK = ARLOCK_param;
    endfunction

    function void axi_initialise_ARLOCK_from_CY();
        internal_ARLOCK = 'z;
        m_ARLOCK = 'z;
    endfunction

    function void axi_set_ARCACHE_from_CY( logic [3:0] ARCACHE_param );
        internal_ARCACHE = ARCACHE_param;
    endfunction

    function void axi_initialise_ARCACHE_from_CY();
        internal_ARCACHE = 'z;
        m_ARCACHE = 'z;
    endfunction

    function void axi_set_ARPROT_from_CY( logic [2:0] ARPROT_param );
        internal_ARPROT = ARPROT_param;
    endfunction

    function void axi_initialise_ARPROT_from_CY();
        internal_ARPROT = 'z;
        m_ARPROT = 'z;
    endfunction

    function void axi_set_ARID_from_CY( logic [((AXI_ID_WIDTH) - 1):0]  ARID_param );
        internal_ARID = ARID_param;
    endfunction

    function void axi_initialise_ARID_from_CY();
        internal_ARID = 'z;
        m_ARID = 'z;
    endfunction

    function void axi_set_ARREADY_from_CY( logic ARREADY_param );
        internal_ARREADY = ARREADY_param;
    endfunction

    function void axi_initialise_ARREADY_from_CY();
        internal_ARREADY = 'z;
        m_ARREADY = 'z;
    endfunction

    function void axi_set_ARUSER_from_CY( logic [7:0] ARUSER_param );
        internal_ARUSER = ARUSER_param;
    endfunction

    function void axi_initialise_ARUSER_from_CY();
        internal_ARUSER = 'z;
        m_ARUSER = 'z;
    endfunction

    function void axi_set_RVALID_from_CY( logic RVALID_param );
        internal_RVALID = RVALID_param;
    endfunction

    function void axi_initialise_RVALID_from_CY();
        internal_RVALID = 'z;
        m_RVALID = 'z;
    endfunction

    function void axi_set_RLAST_from_CY( logic RLAST_param );
        internal_RLAST = RLAST_param;
    endfunction

    function void axi_initialise_RLAST_from_CY();
        internal_RLAST = 'z;
        m_RLAST = 'z;
    endfunction

    function void axi_set_RDATA_from_CY( logic [((AXI_RDATA_WIDTH) - 1):0]  RDATA_param );
        internal_RDATA = RDATA_param;
    endfunction

    function void axi_initialise_RDATA_from_CY();
        internal_RDATA = 'z;
        m_RDATA = 'z;
    endfunction

    function void axi_set_RRESP_from_CY( logic [1:0] RRESP_param );
        internal_RRESP = RRESP_param;
    endfunction

    function void axi_initialise_RRESP_from_CY();
        internal_RRESP = 'z;
        m_RRESP = 'z;
    endfunction

    function void axi_set_RID_from_CY( logic [((AXI_ID_WIDTH) - 1):0]  RID_param );
        internal_RID = RID_param;
    endfunction

    function void axi_initialise_RID_from_CY();
        internal_RID = 'z;
        m_RID = 'z;
    endfunction

    function void axi_set_RREADY_from_CY( logic RREADY_param );
        internal_RREADY = RREADY_param;
    endfunction

    function void axi_initialise_RREADY_from_CY();
        internal_RREADY = 'z;
        m_RREADY = 'z;
    endfunction

    function void axi_set_RUSER_from_CY( logic [7:0] RUSER_param );
        internal_RUSER = RUSER_param;
    endfunction

    function void axi_initialise_RUSER_from_CY();
        internal_RUSER = 'z;
        m_RUSER = 'z;
    endfunction

    function void axi_set_WVALID_from_CY( logic WVALID_param );
        internal_WVALID = WVALID_param;
    endfunction

    function void axi_initialise_WVALID_from_CY();
        internal_WVALID = 'z;
        m_WVALID = 'z;
    endfunction

    function void axi_set_WLAST_from_CY( logic WLAST_param );
        internal_WLAST = WLAST_param;
    endfunction

    function void axi_initialise_WLAST_from_CY();
        internal_WLAST = 'z;
        m_WLAST = 'z;
    endfunction

    function void axi_set_WDATA_from_CY( logic [((AXI_WDATA_WIDTH) - 1):0]  WDATA_param );
        internal_WDATA = WDATA_param;
    endfunction

    function void axi_initialise_WDATA_from_CY();
        internal_WDATA = 'z;
        m_WDATA = 'z;
    endfunction

    function void axi_set_WSTRB_from_CY( logic [(((AXI_WDATA_WIDTH / 8)) - 1):0]  WSTRB_param );
        internal_WSTRB = WSTRB_param;
    endfunction

    function void axi_initialise_WSTRB_from_CY();
        internal_WSTRB = 'z;
        m_WSTRB = 'z;
    endfunction

    function void axi_set_WID_from_CY( logic [((AXI_ID_WIDTH) - 1):0]  WID_param );
        internal_WID = WID_param;
    endfunction

    function void axi_initialise_WID_from_CY();
        internal_WID = 'z;
        m_WID = 'z;
    endfunction

    function void axi_set_WREADY_from_CY( logic WREADY_param );
        internal_WREADY = WREADY_param;
    endfunction

    function void axi_initialise_WREADY_from_CY();
        internal_WREADY = 'z;
        m_WREADY = 'z;
    endfunction

    function void axi_set_WUSER_from_CY( logic [7:0] WUSER_param );
        internal_WUSER = WUSER_param;
    endfunction

    function void axi_initialise_WUSER_from_CY();
        internal_WUSER = 'z;
        m_WUSER = 'z;
    endfunction

    function void axi_set_BVALID_from_CY( logic BVALID_param );
        internal_BVALID = BVALID_param;
    endfunction

    function void axi_initialise_BVALID_from_CY();
        internal_BVALID = 'z;
        m_BVALID = 'z;
    endfunction

    function void axi_set_BRESP_from_CY( logic [1:0] BRESP_param );
        internal_BRESP = BRESP_param;
    endfunction

    function void axi_initialise_BRESP_from_CY();
        internal_BRESP = 'z;
        m_BRESP = 'z;
    endfunction

    function void axi_set_BID_from_CY( logic [((AXI_ID_WIDTH) - 1):0]  BID_param );
        internal_BID = BID_param;
    endfunction

    function void axi_initialise_BID_from_CY();
        internal_BID = 'z;
        m_BID = 'z;
    endfunction

    function void axi_set_BREADY_from_CY( logic BREADY_param );
        internal_BREADY = BREADY_param;
    endfunction

    function void axi_initialise_BREADY_from_CY();
        internal_BREADY = 'z;
        m_BREADY = 'z;
    endfunction

    function void axi_set_BUSER_from_CY( logic [7:0] BUSER_param );
        internal_BUSER = BUSER_param;
    endfunction

    function void axi_initialise_BUSER_from_CY();
        internal_BUSER = 'z;
        m_BUSER = 'z;
    endfunction

    function void axi_set_config_clk_init_value_from_CY( bit config_clk_init_value_param );
        config_clk_init_value = config_clk_init_value_param;
    endfunction

    function void axi_set_config_clk_phase_shift_from_CY( int config_clk_phase_shift_param );
        config_clk_phase_shift = config_clk_phase_shift_param;
    endfunction

    function void axi_set_config_clk_1st_time_from_CY( int config_clk_1st_time_param );
        config_clk_1st_time = config_clk_1st_time_param;
    endfunction

    function void axi_set_config_clk_2nd_time_from_CY( int config_clk_2nd_time_param );
        config_clk_2nd_time = config_clk_2nd_time_param;
    endfunction

    function void axi_set_config_setup_time_from_CY( int config_setup_time_param );
        config_setup_time = config_setup_time_param;
    endfunction

    function void axi_set_config_hold_time_from_CY( int config_hold_time_param );
        config_hold_time = config_hold_time_param;
    endfunction

    function void axi_set_config_max_transaction_time_factor_from_CY( int unsigned config_max_transaction_time_factor_param );
        config_max_transaction_time_factor = config_max_transaction_time_factor_param;
    endfunction

    function void axi_set_config_timeout_max_data_transfer_from_CY( int config_timeout_max_data_transfer_param );
        config_timeout_max_data_transfer = config_timeout_max_data_transfer_param;
    endfunction

    function void axi_set_config_burst_timeout_factor_from_CY( int unsigned config_burst_timeout_factor_param );
        config_burst_timeout_factor = config_burst_timeout_factor_param;
    endfunction

    function void axi_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_CY( int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
        config_max_latency_AWVALID_assertion_to_AWREADY = config_max_latency_AWVALID_assertion_to_AWREADY_param;
    endfunction

    function void axi_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_CY( int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
        config_max_latency_ARVALID_assertion_to_ARREADY = config_max_latency_ARVALID_assertion_to_ARREADY_param;
    endfunction

    function void axi_set_config_max_latency_RVALID_assertion_to_RREADY_from_CY( int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
        config_max_latency_RVALID_assertion_to_RREADY = config_max_latency_RVALID_assertion_to_RREADY_param;
    endfunction

    function void axi_set_config_max_latency_BVALID_assertion_to_BREADY_from_CY( int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
        config_max_latency_BVALID_assertion_to_BREADY = config_max_latency_BVALID_assertion_to_BREADY_param;
    endfunction

    function void axi_set_config_max_latency_WVALID_assertion_to_WREADY_from_CY( int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
        config_max_latency_WVALID_assertion_to_WREADY = config_max_latency_WVALID_assertion_to_WREADY_param;
    endfunction

    function void axi_set_config_write_ctrl_first_ratio_from_CY( int config_write_ctrl_first_ratio_param );
        config_write_ctrl_first_ratio = config_write_ctrl_first_ratio_param;
    endfunction

    function void axi_set_config_write_data_first_ratio_from_CY( int config_write_data_first_ratio_param );
        config_write_data_first_ratio = config_write_data_first_ratio_param;
    endfunction

    function void axi_set_config_write_ctrl_to_data_mintime_from_CY( int unsigned config_write_ctrl_to_data_mintime_param );
        config_write_ctrl_to_data_mintime = config_write_ctrl_to_data_mintime_param;
    endfunction

    function void axi_set_config_write_data_to_ctrl_mintime_from_CY( int unsigned config_write_data_to_ctrl_mintime_param );
        config_write_data_to_ctrl_mintime = config_write_data_to_ctrl_mintime_param;
    endfunction

    function void axi_set_config_master_write_delay_from_CY( bit config_master_write_delay_param );
        config_master_write_delay = config_master_write_delay_param;
    endfunction

    function void axi_set_config_reset_low_clocks_from_CY( int config_reset_low_clocks_param );
        config_reset_low_clocks = config_reset_low_clocks_param;
    endfunction

    function void axi_set_config_reset_hold_time_from_CY( int config_reset_hold_time_param );
        config_reset_hold_time = config_reset_hold_time_param;
    endfunction

    function void axi_set_config_protect_ready_from_CY( bit config_protect_ready_param );
        config_protect_ready = config_protect_ready_param;
    endfunction

    function void axi_set_config_enable_user_sideband_from_CY( bit config_enable_user_sideband_param );
        config_enable_user_sideband = config_enable_user_sideband_param;
    endfunction

    function void axi_set_config_extended_length_enable_from_CY( bit config_extended_length_enable_param );
        config_extended_length_enable = config_extended_length_enable_param;
    endfunction

    function void axi_set_config_enable_burst_reserved_value_from_CY( bit config_enable_burst_reserved_value_param );
        config_enable_burst_reserved_value = config_enable_burst_reserved_value_param;
    endfunction

    function void axi_set_config_enable_lock_reserved_value_from_CY( bit config_enable_lock_reserved_value_param );
        config_enable_lock_reserved_value = config_enable_lock_reserved_value_param;
    endfunction

    function void axi_set_config_enable_cache_reserved_value_from_CY( bit config_enable_cache_reserved_value_param );
        config_enable_cache_reserved_value = config_enable_cache_reserved_value_param;
    endfunction

    function void axi_set_config_enable_all_assertions_from_CY( bit config_enable_all_assertions_param );
        config_enable_all_assertions = config_enable_all_assertions_param;
    endfunction

    function void axi_set_config_enable_assertion_from_CY( bit [255:0] config_enable_assertion_param );
        config_enable_assertion = config_enable_assertion_param;
    endfunction

    function void axi_set_config_enable_error_from_CY( bit [255:0] config_enable_error_param );
        config_enable_error = config_enable_error_param;
    endfunction

    function void axi_set_config_enable_errors_from_CY( bit config_enable_errors_param );
        config_enable_errors = config_enable_errors_param;
    endfunction

    function void axi_set_config_enable_all_assertion_errors_from_CY( bit config_enable_all_assertion_errors_param );
        config_enable_all_assertion_errors = config_enable_all_assertion_errors_param;
    endfunction

    function void axi_set_config_abstraction_level_from_CY( axi_abstraction_level_e config_abstraction_level_param );
        config_abstraction_level = config_abstraction_level_param;
    endfunction

    function void axi_set_config_slave_start_addr_from_CY( bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param );
        config_slave_start_addr = config_slave_start_addr_param;
    endfunction

    function void axi_set_config_slave_end_addr_from_CY( bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param );
        config_slave_end_addr = config_slave_end_addr_param;
    endfunction

    function void axi_set_config_enable_slave_addr_range_in_bfm_from_CY( bit config_enable_slave_addr_range_in_bfm_param );
        config_enable_slave_addr_range_in_bfm = config_enable_slave_addr_range_in_bfm_param;
    endfunction

    function void axi_set_config_read_data_reordering_depth_from_CY( int unsigned config_read_data_reordering_depth_param );
        config_read_data_reordering_depth = config_read_data_reordering_depth_param;
    endfunction

    function void axi_set_config_enable_read_data_reordering_depth_in_bfm_from_CY( bit config_enable_read_data_reordering_depth_in_bfm_param );
        config_enable_read_data_reordering_depth_in_bfm = config_enable_read_data_reordering_depth_in_bfm_param;
    endfunction

    function void axi_set_config_awid_wid_mismatch_from_CY( bit config_awid_wid_mismatch_param );
        config_awid_wid_mismatch = config_awid_wid_mismatch_param;
    endfunction

    function void axi_set_config_length_last_mismatch_error_from_CY( bit config_length_last_mismatch_error_param );
        config_length_last_mismatch_error = config_length_last_mismatch_error_param;
    endfunction

    function void axi_set_config_master_error_position_from_CY( axi_error_e config_master_error_position_param );
        config_master_error_position = config_master_error_position_param;
    endfunction

    function void axi_set_dummy_var_from_CY( axi_assertion_type_e dummy_var_param );
        dummy_var = dummy_var_param;
    endfunction

    function void axi_set_config_wlast_length_from_CY( int config_wlast_length_param );
        config_wlast_length = config_wlast_length_param;
    endfunction

    function void axi_set_config_wid_for_awid_not_matching_from_CY( bit [((AXI_ID_WIDTH) - 1):0]  config_wid_for_awid_not_matching_param );
        config_wid_for_awid_not_matching = config_wid_for_awid_not_matching_param;
    endfunction

    function void axi_set_config_support_exclusive_access_from_CY( bit config_support_exclusive_access_param );
        config_support_exclusive_access = config_support_exclusive_access_param;
    endfunction

    function void axi_set_config_write_data_interleaving_depth_from_CY( int config_write_data_interleaving_depth_param );
        config_write_data_interleaving_depth = config_write_data_interleaving_depth_param;
    endfunction

    function void axi_set_status_master_error_from_CY( bit [15:0] status_master_error_param );
        status_master_error = status_master_error_param;
    endfunction

    function void axi_set_status_num_reads_waiting_for_resp_from_CY( int status_num_reads_waiting_for_resp_param );
        status_num_reads_waiting_for_resp = status_num_reads_waiting_for_resp_param;
    endfunction

    function void axi_set_status_num_writes_waiting_for_response_from_CY( int status_num_writes_waiting_for_response_param );
        status_num_writes_waiting_for_response = status_num_writes_waiting_for_response_param;
    endfunction

    function void axi_set_check_total_num_wdata_outstanding_from_CY( bit check_total_num_wdata_outstanding_param );
        check_total_num_wdata_outstanding = check_total_num_wdata_outstanding_param;
    endfunction

    function void axi_set_total_num_wdata_outstanding_from_CY( int total_num_wdata_outstanding_param );
        total_num_wdata_outstanding = total_num_wdata_outstanding_param;
    endfunction

    function void axi_set_check_max_num_wdata_outstanding_per_id_from_CY( bit check_max_num_wdata_outstanding_per_id_param );
        check_max_num_wdata_outstanding_per_id = check_max_num_wdata_outstanding_per_id_param;
    endfunction

    function void axi_set_max_num_wdata_outstanding_per_id_from_CY( int max_num_wdata_outstanding_per_id_param );
        max_num_wdata_outstanding_per_id = max_num_wdata_outstanding_per_id_param;
    endfunction

    function void axi_set_check_max_num_waddr_outstanding_per_id_from_CY( bit check_max_num_waddr_outstanding_per_id_param );
        check_max_num_waddr_outstanding_per_id = check_max_num_waddr_outstanding_per_id_param;
    endfunction

    function void axi_set_max_num_waddr_outstanding_per_id_from_CY( int max_num_waddr_outstanding_per_id_param );
        max_num_waddr_outstanding_per_id = max_num_waddr_outstanding_per_id_param;
    endfunction

    function void axi_set_check_total_num_waddr_outstanding_from_CY( bit check_total_num_waddr_outstanding_param );
        check_total_num_waddr_outstanding = check_total_num_waddr_outstanding_param;
    endfunction

    function void axi_set_total_num_waddr_outstanding_from_CY( int total_num_waddr_outstanding_param );
        total_num_waddr_outstanding = total_num_waddr_outstanding_param;
    endfunction

    function void axi_set_status_outstanding_num_for_waddr_from_CY( int status_outstanding_num_for_waddr_param );
        status_outstanding_num_for_waddr = status_outstanding_num_for_waddr_param;
    endfunction

    function void axi_set_start_finding_outstanding_waddr_from_CY( bit start_finding_outstanding_waddr_param );
        start_finding_outstanding_waddr = start_finding_outstanding_waddr_param;
    endfunction

    function void axi_set_status_outstanding_num_for_wdata_from_CY( int status_outstanding_num_for_wdata_param );
        status_outstanding_num_for_wdata = status_outstanding_num_for_wdata_param;
    endfunction

    function void axi_set_start_finding_outstanding_wdata_from_CY( bit start_finding_outstanding_wdata_param );
        start_finding_outstanding_wdata = start_finding_outstanding_wdata_param;
    endfunction

    function void axi_set_find_waddr_outstanding_for_wid_from_CY( bit [((AXI_ID_WIDTH) - 1):0]  find_waddr_outstanding_for_wid_param );
        find_waddr_outstanding_for_wid = find_waddr_outstanding_for_wid_param;
    endfunction

    function void axi_set_find_wdata_outstanding_for_wid_from_CY( bit [((AXI_ID_WIDTH) - 1):0]  find_wdata_outstanding_for_wid_param );
        find_wdata_outstanding_for_wid = find_wdata_outstanding_for_wid_param;
    endfunction

    function void axi_set_change_in_wdata_outstanding_per_id_from_CY( bit change_in_wdata_outstanding_per_id_param );
        change_in_wdata_outstanding_per_id = change_in_wdata_outstanding_per_id_param;
    endfunction

    function void axi_set_start_finding_change_in_wdata_from_CY( bit start_finding_change_in_wdata_param );
        start_finding_change_in_wdata = start_finding_change_in_wdata_param;
    endfunction

    function void axi_set_find_change_in_wdata_outstanding_for_wid_from_CY( bit [((AXI_ID_WIDTH) - 1):0]  find_change_in_wdata_outstanding_for_wid_param );
        find_change_in_wdata_outstanding_for_wid = find_change_in_wdata_outstanding_for_wid_param;
    endfunction

    function void axi_set_config_max_outstanding_wr_from_CY( int config_max_outstanding_wr_param );
        config_max_outstanding_wr = config_max_outstanding_wr_param;
    endfunction

    function void axi_set_config_max_outstanding_rd_from_CY( int config_max_outstanding_rd_param );
        config_max_outstanding_rd = config_max_outstanding_rd_param;
    endfunction

    function void axi_set_config_error_on_deleted_valid_cycles_from_CY( bit config_error_on_deleted_valid_cycles_param );
        config_error_on_deleted_valid_cycles = config_error_on_deleted_valid_cycles_param;
    endfunction

    function void axi_set_config_stats_enable_from_CY( bit config_stats_enable_param );
        config_stats_enable = config_stats_enable_param;
    endfunction

    function void axi_set_config_stats_enable_AXI_read_occupancy_from_CY( bit config_stats_enable_AXI_read_occupancy_param );
        config_stats_enable_AXI_read_occupancy = config_stats_enable_AXI_read_occupancy_param;
    endfunction

    function void axi_set_config_stats_enable_AXI_write_occupancy_from_CY( bit config_stats_enable_AXI_write_occupancy_param );
        config_stats_enable_AXI_write_occupancy = config_stats_enable_AXI_write_occupancy_param;
    endfunction

    function void axi_set_config_stats_enable_read_data_occupancy_from_CY( bit config_stats_enable_read_data_occupancy_param );
        config_stats_enable_read_data_occupancy = config_stats_enable_read_data_occupancy_param;
    endfunction

    function void axi_set_config_stats_enable_write_data_occupancy_from_CY( bit config_stats_enable_write_data_occupancy_param );
        config_stats_enable_write_data_occupancy = config_stats_enable_write_data_occupancy_param;
    endfunction

    function void axi_set_config_stats_enable_read_latency_from_CY( bit config_stats_enable_read_latency_param );
        config_stats_enable_read_latency = config_stats_enable_read_latency_param;
    endfunction

    function void axi_set_config_stats_enable_write_latency_from_CY( bit config_stats_enable_write_latency_param );
        config_stats_enable_write_latency = config_stats_enable_write_latency_param;
    endfunction

    function void axi_set_config_stats_enable_read_address_waits_from_CY( bit config_stats_enable_read_address_waits_param );
        config_stats_enable_read_address_waits = config_stats_enable_read_address_waits_param;
    endfunction

    function void axi_set_config_stats_enable_read_data_waits_from_CY( bit config_stats_enable_read_data_waits_param );
        config_stats_enable_read_data_waits = config_stats_enable_read_data_waits_param;
    endfunction

    function void axi_set_config_stats_enable_write_address_waits_from_CY( bit config_stats_enable_write_address_waits_param );
        config_stats_enable_write_address_waits = config_stats_enable_write_address_waits_param;
    endfunction

    function void axi_set_config_stats_enable_write_data_waits_from_CY( bit config_stats_enable_write_data_waits_param );
        config_stats_enable_write_data_waits = config_stats_enable_write_data_waits_param;
    endfunction

    function void axi_set_config_stats_enable_write_response_waits_from_CY( bit config_stats_enable_write_response_waits_param );
        config_stats_enable_write_response_waits = config_stats_enable_write_response_waits_param;
    endfunction

    function void axi_set_config_stats_enable_read_bandwidth_from_CY( bit config_stats_enable_read_bandwidth_param );
        config_stats_enable_read_bandwidth = config_stats_enable_read_bandwidth_param;
    endfunction

    function void axi_set_config_stats_enable_write_bandwidth_from_CY( bit config_stats_enable_write_bandwidth_param );
        config_stats_enable_write_bandwidth = config_stats_enable_write_bandwidth_param;
    endfunction

    function void axi_set_config_stats_AXI_read_occupancy_step_from_CY( int config_stats_AXI_read_occupancy_step_param );
        config_stats_AXI_read_occupancy_step = config_stats_AXI_read_occupancy_step_param;
    endfunction

    function void axi_set_config_stats_AXI_read_occupancy_multiple_from_CY( int config_stats_AXI_read_occupancy_multiple_param );
        config_stats_AXI_read_occupancy_multiple = config_stats_AXI_read_occupancy_multiple_param;
    endfunction

    function void axi_set_stats_AXI_read_active_from_CY( bit stats_AXI_read_active_param );
        stats_AXI_read_active = stats_AXI_read_active_param;
    endfunction

    function void axi_set_stats_AXI_read_occupancy_sw_from_CY( int stats_AXI_read_occupancy_sw_param );
        stats_AXI_read_occupancy_sw = stats_AXI_read_occupancy_sw_param;
    endfunction

    function void axi_set_stats_AXI_read_occupancy_sw_updated_from_CY( int stats_AXI_read_occupancy_sw_updated_param );
        stats_AXI_read_occupancy_sw_updated = stats_AXI_read_occupancy_sw_updated_param;
    endfunction

    function void axi_set_stats_AXI_read_idle_sw_from_CY( int stats_AXI_read_idle_sw_param );
        stats_AXI_read_idle_sw = stats_AXI_read_idle_sw_param;
    endfunction

    function void axi_set_stats_AXI_read_occupancy_min_from_CY( int stats_AXI_read_occupancy_min_param );
        stats_AXI_read_occupancy_min = stats_AXI_read_occupancy_min_param;
    endfunction

    function void axi_set_stats_AXI_read_idle_min_from_CY( int stats_AXI_read_idle_min_param );
        stats_AXI_read_idle_min = stats_AXI_read_idle_min_param;
    endfunction

    function void axi_set_stats_AXI_read_occupancy_max_from_CY( int stats_AXI_read_occupancy_max_param );
        stats_AXI_read_occupancy_max = stats_AXI_read_occupancy_max_param;
    endfunction

    function void axi_set_stats_AXI_read_idle_max_from_CY( int stats_AXI_read_idle_max_param );
        stats_AXI_read_idle_max = stats_AXI_read_idle_max_param;
    endfunction

    function void axi_set_stats_AXI_read_occupancy_mean_from_CY( int stats_AXI_read_occupancy_mean_param );
        stats_AXI_read_occupancy_mean = stats_AXI_read_occupancy_mean_param;
    endfunction

    function void axi_set_stats_AXI_read_idle_mean_from_CY( int stats_AXI_read_idle_mean_param );
        stats_AXI_read_idle_mean = stats_AXI_read_idle_mean_param;
    endfunction

    function void axi_set_config_stats_AXI_write_occupancy_step_from_CY( int config_stats_AXI_write_occupancy_step_param );
        config_stats_AXI_write_occupancy_step = config_stats_AXI_write_occupancy_step_param;
    endfunction

    function void axi_set_config_stats_AXI_write_occupancy_multiple_from_CY( int config_stats_AXI_write_occupancy_multiple_param );
        config_stats_AXI_write_occupancy_multiple = config_stats_AXI_write_occupancy_multiple_param;
    endfunction

    function void axi_set_stats_AXI_write_active_from_CY( bit stats_AXI_write_active_param );
        stats_AXI_write_active = stats_AXI_write_active_param;
    endfunction

    function void axi_set_stats_AXI_write_occupancy_sw_from_CY( int stats_AXI_write_occupancy_sw_param );
        stats_AXI_write_occupancy_sw = stats_AXI_write_occupancy_sw_param;
    endfunction

    function void axi_set_stats_AXI_write_occupancy_sw_updated_from_CY( int stats_AXI_write_occupancy_sw_updated_param );
        stats_AXI_write_occupancy_sw_updated = stats_AXI_write_occupancy_sw_updated_param;
    endfunction

    function void axi_set_stats_AXI_write_idle_sw_from_CY( int stats_AXI_write_idle_sw_param );
        stats_AXI_write_idle_sw = stats_AXI_write_idle_sw_param;
    endfunction

    function void axi_set_stats_AXI_write_occupancy_min_from_CY( int stats_AXI_write_occupancy_min_param );
        stats_AXI_write_occupancy_min = stats_AXI_write_occupancy_min_param;
    endfunction

    function void axi_set_stats_AXI_write_idle_min_from_CY( int stats_AXI_write_idle_min_param );
        stats_AXI_write_idle_min = stats_AXI_write_idle_min_param;
    endfunction

    function void axi_set_stats_AXI_write_occupancy_max_from_CY( int stats_AXI_write_occupancy_max_param );
        stats_AXI_write_occupancy_max = stats_AXI_write_occupancy_max_param;
    endfunction

    function void axi_set_stats_AXI_write_idle_max_from_CY( int stats_AXI_write_idle_max_param );
        stats_AXI_write_idle_max = stats_AXI_write_idle_max_param;
    endfunction

    function void axi_set_stats_AXI_write_occupancy_mean_from_CY( int stats_AXI_write_occupancy_mean_param );
        stats_AXI_write_occupancy_mean = stats_AXI_write_occupancy_mean_param;
    endfunction

    function void axi_set_stats_AXI_write_idle_mean_from_CY( int stats_AXI_write_idle_mean_param );
        stats_AXI_write_idle_mean = stats_AXI_write_idle_mean_param;
    endfunction

    function void axi_set_config_stats_read_data_occupancy_step_from_CY( int config_stats_read_data_occupancy_step_param );
        config_stats_read_data_occupancy_step = config_stats_read_data_occupancy_step_param;
    endfunction

    function void axi_set_config_stats_read_data_occupancy_multiple_from_CY( int config_stats_read_data_occupancy_multiple_param );
        config_stats_read_data_occupancy_multiple = config_stats_read_data_occupancy_multiple_param;
    endfunction

    function void axi_set_stats_read_data_occupancy_sw_from_CY( int stats_read_data_occupancy_sw_param );
        stats_read_data_occupancy_sw = stats_read_data_occupancy_sw_param;
    endfunction

    function void axi_set_stats_read_data_occupancy_sw_updated_from_CY( int stats_read_data_occupancy_sw_updated_param );
        stats_read_data_occupancy_sw_updated = stats_read_data_occupancy_sw_updated_param;
    endfunction

    function void axi_set_stats_read_data_idle_sw_from_CY( int stats_read_data_idle_sw_param );
        stats_read_data_idle_sw = stats_read_data_idle_sw_param;
    endfunction

    function void axi_set_stats_read_data_occupancy_min_from_CY( int stats_read_data_occupancy_min_param );
        stats_read_data_occupancy_min = stats_read_data_occupancy_min_param;
    endfunction

    function void axi_set_stats_read_data_idle_min_from_CY( int stats_read_data_idle_min_param );
        stats_read_data_idle_min = stats_read_data_idle_min_param;
    endfunction

    function void axi_set_stats_read_data_occupancy_max_from_CY( int stats_read_data_occupancy_max_param );
        stats_read_data_occupancy_max = stats_read_data_occupancy_max_param;
    endfunction

    function void axi_set_stats_read_data_idle_max_from_CY( int stats_read_data_idle_max_param );
        stats_read_data_idle_max = stats_read_data_idle_max_param;
    endfunction

    function void axi_set_stats_read_data_occupancy_mean_from_CY( int stats_read_data_occupancy_mean_param );
        stats_read_data_occupancy_mean = stats_read_data_occupancy_mean_param;
    endfunction

    function void axi_set_stats_read_data_idle_mean_from_CY( int stats_read_data_idle_mean_param );
        stats_read_data_idle_mean = stats_read_data_idle_mean_param;
    endfunction

    function void axi_set_config_stats_write_data_occupancy_step_from_CY( int config_stats_write_data_occupancy_step_param );
        config_stats_write_data_occupancy_step = config_stats_write_data_occupancy_step_param;
    endfunction

    function void axi_set_config_stats_write_data_occupancy_multiple_from_CY( int config_stats_write_data_occupancy_multiple_param );
        config_stats_write_data_occupancy_multiple = config_stats_write_data_occupancy_multiple_param;
    endfunction

    function void axi_set_stats_write_data_occupancy_sw_from_CY( int stats_write_data_occupancy_sw_param );
        stats_write_data_occupancy_sw = stats_write_data_occupancy_sw_param;
    endfunction

    function void axi_set_stats_write_data_occupancy_sw_updated_from_CY( int stats_write_data_occupancy_sw_updated_param );
        stats_write_data_occupancy_sw_updated = stats_write_data_occupancy_sw_updated_param;
    endfunction

    function void axi_set_stats_write_data_idle_sw_from_CY( int stats_write_data_idle_sw_param );
        stats_write_data_idle_sw = stats_write_data_idle_sw_param;
    endfunction

    function void axi_set_stats_write_data_occupancy_min_from_CY( int stats_write_data_occupancy_min_param );
        stats_write_data_occupancy_min = stats_write_data_occupancy_min_param;
    endfunction

    function void axi_set_stats_write_data_idle_min_from_CY( int stats_write_data_idle_min_param );
        stats_write_data_idle_min = stats_write_data_idle_min_param;
    endfunction

    function void axi_set_stats_write_data_occupancy_max_from_CY( int stats_write_data_occupancy_max_param );
        stats_write_data_occupancy_max = stats_write_data_occupancy_max_param;
    endfunction

    function void axi_set_stats_write_data_idle_max_from_CY( int stats_write_data_idle_max_param );
        stats_write_data_idle_max = stats_write_data_idle_max_param;
    endfunction

    function void axi_set_stats_write_data_occupancy_mean_from_CY( int stats_write_data_occupancy_mean_param );
        stats_write_data_occupancy_mean = stats_write_data_occupancy_mean_param;
    endfunction

    function void axi_set_stats_write_data_idle_mean_from_CY( int stats_write_data_idle_mean_param );
        stats_write_data_idle_mean = stats_write_data_idle_mean_param;
    endfunction

    function void axi_set_config_stats_read_bandwidth_step_from_CY( int config_stats_read_bandwidth_step_param );
        config_stats_read_bandwidth_step = config_stats_read_bandwidth_step_param;
    endfunction

    function void axi_set_config_stats_read_bandwidth_multiple_from_CY( int config_stats_read_bandwidth_multiple_param );
        config_stats_read_bandwidth_multiple = config_stats_read_bandwidth_multiple_param;
    endfunction

    function void axi_set_stats_read_bandwidth_sw_from_CY( int stats_read_bandwidth_sw_param );
        stats_read_bandwidth_sw = stats_read_bandwidth_sw_param;
    endfunction

    function void axi_set_stats_read_bandwidth_sw_updated_from_CY( int stats_read_bandwidth_sw_updated_param );
        stats_read_bandwidth_sw_updated = stats_read_bandwidth_sw_updated_param;
    endfunction

    function void axi_set_stats_read_bandwidth_min_from_CY( int stats_read_bandwidth_min_param );
        stats_read_bandwidth_min = stats_read_bandwidth_min_param;
    endfunction

    function void axi_set_stats_read_bandwidth_max_from_CY( int stats_read_bandwidth_max_param );
        stats_read_bandwidth_max = stats_read_bandwidth_max_param;
    endfunction

    function void axi_set_stats_read_bandwidth_mean_from_CY( int stats_read_bandwidth_mean_param );
        stats_read_bandwidth_mean = stats_read_bandwidth_mean_param;
    endfunction

    function void axi_set_config_stats_write_bandwidth_step_from_CY( int config_stats_write_bandwidth_step_param );
        config_stats_write_bandwidth_step = config_stats_write_bandwidth_step_param;
    endfunction

    function void axi_set_config_stats_write_bandwidth_multiple_from_CY( int config_stats_write_bandwidth_multiple_param );
        config_stats_write_bandwidth_multiple = config_stats_write_bandwidth_multiple_param;
    endfunction

    function void axi_set_stats_write_bandwidth_sw_from_CY( int stats_write_bandwidth_sw_param );
        stats_write_bandwidth_sw = stats_write_bandwidth_sw_param;
    endfunction

    function void axi_set_stats_write_bandwidth_sw_updated_from_CY( int stats_write_bandwidth_sw_updated_param );
        stats_write_bandwidth_sw_updated = stats_write_bandwidth_sw_updated_param;
    endfunction

    function void axi_set_stats_write_bandwidth_min_from_CY( int stats_write_bandwidth_min_param );
        stats_write_bandwidth_min = stats_write_bandwidth_min_param;
    endfunction

    function void axi_set_stats_write_bandwidth_max_from_CY( int stats_write_bandwidth_max_param );
        stats_write_bandwidth_max = stats_write_bandwidth_max_param;
    endfunction

    function void axi_set_stats_write_bandwidth_mean_from_CY( int stats_write_bandwidth_mean_param );
        stats_write_bandwidth_mean = stats_write_bandwidth_mean_param;
    endfunction

    function void axi_set_config_stats_read_latency_step_from_CY( int config_stats_read_latency_step_param );
        config_stats_read_latency_step = config_stats_read_latency_step_param;
    endfunction

    function void axi_set_config_stats_read_latency_multiple_from_CY( int config_stats_read_latency_multiple_param );
        config_stats_read_latency_multiple = config_stats_read_latency_multiple_param;
    endfunction

    function void axi_set_stats_read_latency_sw_updated_from_CY( int stats_read_latency_sw_updated_param );
        stats_read_latency_sw_updated = stats_read_latency_sw_updated_param;
    endfunction

    function void axi_set_stats_read_address_data_latency_inst_from_CY( int stats_read_address_data_latency_inst_param );
        stats_read_address_data_latency_inst = stats_read_address_data_latency_inst_param;
    endfunction

    function void axi_set_stats_read_address_data_latency_sw_from_CY( int stats_read_address_data_latency_sw_param );
        stats_read_address_data_latency_sw = stats_read_address_data_latency_sw_param;
    endfunction

    function void axi_set_stats_read_address_data_latency_min_from_CY( int stats_read_address_data_latency_min_param );
        stats_read_address_data_latency_min = stats_read_address_data_latency_min_param;
    endfunction

    function void axi_set_stats_read_address_data_latency_max_from_CY( int stats_read_address_data_latency_max_param );
        stats_read_address_data_latency_max = stats_read_address_data_latency_max_param;
    endfunction

    function void axi_set_stats_read_address_data_latency_mean_from_CY( int stats_read_address_data_latency_mean_param );
        stats_read_address_data_latency_mean = stats_read_address_data_latency_mean_param;
    endfunction

    function void axi_set_stats_read_address_address_latency_inst_from_CY( int stats_read_address_address_latency_inst_param );
        stats_read_address_address_latency_inst = stats_read_address_address_latency_inst_param;
    endfunction

    function void axi_set_stats_read_address_address_latency_sw_from_CY( int stats_read_address_address_latency_sw_param );
        stats_read_address_address_latency_sw = stats_read_address_address_latency_sw_param;
    endfunction

    function void axi_set_stats_read_address_address_latency_min_from_CY( int stats_read_address_address_latency_min_param );
        stats_read_address_address_latency_min = stats_read_address_address_latency_min_param;
    endfunction

    function void axi_set_stats_read_address_address_latency_max_from_CY( int stats_read_address_address_latency_max_param );
        stats_read_address_address_latency_max = stats_read_address_address_latency_max_param;
    endfunction

    function void axi_set_stats_read_address_address_latency_mean_from_CY( int stats_read_address_address_latency_mean_param );
        stats_read_address_address_latency_mean = stats_read_address_address_latency_mean_param;
    endfunction

    function void axi_set_config_stats_write_latency_step_from_CY( int config_stats_write_latency_step_param );
        config_stats_write_latency_step = config_stats_write_latency_step_param;
    endfunction

    function void axi_set_config_stats_write_latency_multiple_from_CY( int config_stats_write_latency_multiple_param );
        config_stats_write_latency_multiple = config_stats_write_latency_multiple_param;
    endfunction

    function void axi_set_stats_write_latency_sw_updated_from_CY( int stats_write_latency_sw_updated_param );
        stats_write_latency_sw_updated = stats_write_latency_sw_updated_param;
    endfunction

    function void axi_set_stats_write_address_data_latency_inst_from_CY( int stats_write_address_data_latency_inst_param );
        stats_write_address_data_latency_inst = stats_write_address_data_latency_inst_param;
    endfunction

    function void axi_set_stats_write_address_data_latency_sw_from_CY( int stats_write_address_data_latency_sw_param );
        stats_write_address_data_latency_sw = stats_write_address_data_latency_sw_param;
    endfunction

    function void axi_set_stats_write_address_data_latency_min_from_CY( int stats_write_address_data_latency_min_param );
        stats_write_address_data_latency_min = stats_write_address_data_latency_min_param;
    endfunction

    function void axi_set_stats_write_address_data_latency_max_from_CY( int stats_write_address_data_latency_max_param );
        stats_write_address_data_latency_max = stats_write_address_data_latency_max_param;
    endfunction

    function void axi_set_stats_write_address_data_latency_mean_from_CY( int stats_write_address_data_latency_mean_param );
        stats_write_address_data_latency_mean = stats_write_address_data_latency_mean_param;
    endfunction

    function void axi_set_stats_write_data_response_latency_inst_from_CY( int stats_write_data_response_latency_inst_param );
        stats_write_data_response_latency_inst = stats_write_data_response_latency_inst_param;
    endfunction

    function void axi_set_stats_write_data_response_latency_sw_from_CY( int stats_write_data_response_latency_sw_param );
        stats_write_data_response_latency_sw = stats_write_data_response_latency_sw_param;
    endfunction

    function void axi_set_stats_write_data_response_latency_min_from_CY( int stats_write_data_response_latency_min_param );
        stats_write_data_response_latency_min = stats_write_data_response_latency_min_param;
    endfunction

    function void axi_set_stats_write_data_response_latency_max_from_CY( int stats_write_data_response_latency_max_param );
        stats_write_data_response_latency_max = stats_write_data_response_latency_max_param;
    endfunction

    function void axi_set_stats_write_data_response_latency_mean_from_CY( int stats_write_data_response_latency_mean_param );
        stats_write_data_response_latency_mean = stats_write_data_response_latency_mean_param;
    endfunction

    function void axi_set_stats_write_address_address_latency_inst_from_CY( int stats_write_address_address_latency_inst_param );
        stats_write_address_address_latency_inst = stats_write_address_address_latency_inst_param;
    endfunction

    function void axi_set_stats_write_address_address_latency_sw_from_CY( int stats_write_address_address_latency_sw_param );
        stats_write_address_address_latency_sw = stats_write_address_address_latency_sw_param;
    endfunction

    function void axi_set_stats_write_address_address_latency_min_from_CY( int stats_write_address_address_latency_min_param );
        stats_write_address_address_latency_min = stats_write_address_address_latency_min_param;
    endfunction

    function void axi_set_stats_write_address_address_latency_max_from_CY( int stats_write_address_address_latency_max_param );
        stats_write_address_address_latency_max = stats_write_address_address_latency_max_param;
    endfunction

    function void axi_set_stats_write_address_address_latency_mean_from_CY( int stats_write_address_address_latency_mean_param );
        stats_write_address_address_latency_mean = stats_write_address_address_latency_mean_param;
    endfunction

    function void axi_set_config_stats_read_address_waits_step_from_CY( int config_stats_read_address_waits_step_param );
        config_stats_read_address_waits_step = config_stats_read_address_waits_step_param;
    endfunction

    function void axi_set_config_stats_read_address_waits_multiple_from_CY( int config_stats_read_address_waits_multiple_param );
        config_stats_read_address_waits_multiple = config_stats_read_address_waits_multiple_param;
    endfunction

    function void axi_set_stats_read_address_waits_inst_from_CY( int stats_read_address_waits_inst_param );
        stats_read_address_waits_inst = stats_read_address_waits_inst_param;
    endfunction

    function void axi_set_stats_read_address_waits_sw_from_CY( int stats_read_address_waits_sw_param );
        stats_read_address_waits_sw = stats_read_address_waits_sw_param;
    endfunction

    function void axi_set_stats_read_address_waits_sw_updated_from_CY( int stats_read_address_waits_sw_updated_param );
        stats_read_address_waits_sw_updated = stats_read_address_waits_sw_updated_param;
    endfunction

    function void axi_set_stats_read_address_waits_min_from_CY( int stats_read_address_waits_min_param );
        stats_read_address_waits_min = stats_read_address_waits_min_param;
    endfunction

    function void axi_set_stats_read_address_waits_max_from_CY( int stats_read_address_waits_max_param );
        stats_read_address_waits_max = stats_read_address_waits_max_param;
    endfunction

    function void axi_set_stats_read_address_waits_mean_from_CY( int stats_read_address_waits_mean_param );
        stats_read_address_waits_mean = stats_read_address_waits_mean_param;
    endfunction

    function void axi_set_config_stats_read_data_waits_step_from_CY( int config_stats_read_data_waits_step_param );
        config_stats_read_data_waits_step = config_stats_read_data_waits_step_param;
    endfunction

    function void axi_set_config_stats_read_data_waits_multiple_from_CY( int config_stats_read_data_waits_multiple_param );
        config_stats_read_data_waits_multiple = config_stats_read_data_waits_multiple_param;
    endfunction

    function void axi_set_stats_read_data_waits_inst_from_CY( int stats_read_data_waits_inst_param );
        stats_read_data_waits_inst = stats_read_data_waits_inst_param;
    endfunction

    function void axi_set_stats_read_data_waits_sw_from_CY( int stats_read_data_waits_sw_param );
        stats_read_data_waits_sw = stats_read_data_waits_sw_param;
    endfunction

    function void axi_set_stats_read_data_waits_sw_updated_from_CY( int stats_read_data_waits_sw_updated_param );
        stats_read_data_waits_sw_updated = stats_read_data_waits_sw_updated_param;
    endfunction

    function void axi_set_stats_read_data_waits_min_from_CY( int stats_read_data_waits_min_param );
        stats_read_data_waits_min = stats_read_data_waits_min_param;
    endfunction

    function void axi_set_stats_read_data_waits_max_from_CY( int stats_read_data_waits_max_param );
        stats_read_data_waits_max = stats_read_data_waits_max_param;
    endfunction

    function void axi_set_stats_read_data_waits_mean_from_CY( int stats_read_data_waits_mean_param );
        stats_read_data_waits_mean = stats_read_data_waits_mean_param;
    endfunction

    function void axi_set_config_stats_write_address_waits_step_from_CY( int config_stats_write_address_waits_step_param );
        config_stats_write_address_waits_step = config_stats_write_address_waits_step_param;
    endfunction

    function void axi_set_config_stats_write_address_waits_multiple_from_CY( int config_stats_write_address_waits_multiple_param );
        config_stats_write_address_waits_multiple = config_stats_write_address_waits_multiple_param;
    endfunction

    function void axi_set_stats_write_address_waits_inst_from_CY( int stats_write_address_waits_inst_param );
        stats_write_address_waits_inst = stats_write_address_waits_inst_param;
    endfunction

    function void axi_set_stats_write_address_waits_sw_from_CY( int stats_write_address_waits_sw_param );
        stats_write_address_waits_sw = stats_write_address_waits_sw_param;
    endfunction

    function void axi_set_stats_write_address_waits_sw_updated_from_CY( int stats_write_address_waits_sw_updated_param );
        stats_write_address_waits_sw_updated = stats_write_address_waits_sw_updated_param;
    endfunction

    function void axi_set_stats_write_address_waits_min_from_CY( int stats_write_address_waits_min_param );
        stats_write_address_waits_min = stats_write_address_waits_min_param;
    endfunction

    function void axi_set_stats_write_address_waits_max_from_CY( int stats_write_address_waits_max_param );
        stats_write_address_waits_max = stats_write_address_waits_max_param;
    endfunction

    function void axi_set_stats_write_address_waits_mean_from_CY( int stats_write_address_waits_mean_param );
        stats_write_address_waits_mean = stats_write_address_waits_mean_param;
    endfunction

    function void axi_set_config_stats_write_data_waits_step_from_CY( int config_stats_write_data_waits_step_param );
        config_stats_write_data_waits_step = config_stats_write_data_waits_step_param;
    endfunction

    function void axi_set_config_stats_write_data_waits_multiple_from_CY( int config_stats_write_data_waits_multiple_param );
        config_stats_write_data_waits_multiple = config_stats_write_data_waits_multiple_param;
    endfunction

    function void axi_set_stats_write_data_waits_inst_from_CY( int stats_write_data_waits_inst_param );
        stats_write_data_waits_inst = stats_write_data_waits_inst_param;
    endfunction

    function void axi_set_stats_write_data_waits_sw_from_CY( int stats_write_data_waits_sw_param );
        stats_write_data_waits_sw = stats_write_data_waits_sw_param;
    endfunction

    function void axi_set_stats_write_data_waits_sw_updated_from_CY( int stats_write_data_waits_sw_updated_param );
        stats_write_data_waits_sw_updated = stats_write_data_waits_sw_updated_param;
    endfunction

    function void axi_set_stats_write_data_waits_min_from_CY( int stats_write_data_waits_min_param );
        stats_write_data_waits_min = stats_write_data_waits_min_param;
    endfunction

    function void axi_set_stats_write_data_waits_max_from_CY( int stats_write_data_waits_max_param );
        stats_write_data_waits_max = stats_write_data_waits_max_param;
    endfunction

    function void axi_set_stats_write_data_waits_mean_from_CY( int stats_write_data_waits_mean_param );
        stats_write_data_waits_mean = stats_write_data_waits_mean_param;
    endfunction

    function void axi_set_config_stats_write_response_waits_step_from_CY( int config_stats_write_response_waits_step_param );
        config_stats_write_response_waits_step = config_stats_write_response_waits_step_param;
    endfunction

    function void axi_set_config_stats_write_response_waits_multiple_from_CY( int config_stats_write_response_waits_multiple_param );
        config_stats_write_response_waits_multiple = config_stats_write_response_waits_multiple_param;
    endfunction

    function void axi_set_stats_write_response_waits_inst_from_CY( int stats_write_response_waits_inst_param );
        stats_write_response_waits_inst = stats_write_response_waits_inst_param;
    endfunction

    function void axi_set_stats_write_response_waits_sw_from_CY( int stats_write_response_waits_sw_param );
        stats_write_response_waits_sw = stats_write_response_waits_sw_param;
    endfunction

    function void axi_set_stats_write_response_waits_sw_updated_from_CY( int stats_write_response_waits_sw_updated_param );
        stats_write_response_waits_sw_updated = stats_write_response_waits_sw_updated_param;
    endfunction

    function void axi_set_stats_write_response_waits_min_from_CY( int stats_write_response_waits_min_param );
        stats_write_response_waits_min = stats_write_response_waits_min_param;
    endfunction

    function void axi_set_stats_write_response_waits_max_from_CY( int stats_write_response_waits_max_param );
        stats_write_response_waits_max = stats_write_response_waits_max_param;
    endfunction

    function void axi_set_stats_write_response_waits_mean_from_CY( int stats_write_response_waits_mean_param );
        stats_write_response_waits_mean = stats_write_response_waits_mean_param;
    endfunction

    function void axi_set_stats_rw_transaction_last_duration_from_CY( int stats_rw_transaction_last_duration_param );
        stats_rw_transaction_last_duration = stats_rw_transaction_last_duration_param;
    endfunction

    function void axi_set_stats_AXI_read_last_duration_from_CY( int stats_AXI_read_last_duration_param );
        stats_AXI_read_last_duration = stats_AXI_read_last_duration_param;
    endfunction

    function void axi_set_stats_AXI_write_last_duration_from_CY( int stats_AXI_write_last_duration_param );
        stats_AXI_write_last_duration = stats_AXI_write_last_duration_param;
    endfunction

    function void axi_set_stats_read_addr_channel_phase_last_duration_from_CY( int stats_read_addr_channel_phase_last_duration_param );
        stats_read_addr_channel_phase_last_duration = stats_read_addr_channel_phase_last_duration_param;
    endfunction

    function void axi_set_stats_read_data_burst_last_duration_from_CY( int stats_read_data_burst_last_duration_param );
        stats_read_data_burst_last_duration = stats_read_data_burst_last_duration_param;
    endfunction

    function void axi_set_stats_read_channel_phase_last_duration_from_CY( int stats_read_channel_phase_last_duration_param );
        stats_read_channel_phase_last_duration = stats_read_channel_phase_last_duration_param;
    endfunction

    function void axi_set_stats_write_addr_channel_phase_last_duration_from_CY( int stats_write_addr_channel_phase_last_duration_param );
        stats_write_addr_channel_phase_last_duration = stats_write_addr_channel_phase_last_duration_param;
    endfunction

    function void axi_set_stats_write_data_burst_last_duration_from_CY( int stats_write_data_burst_last_duration_param );
        stats_write_data_burst_last_duration = stats_write_data_burst_last_duration_param;
    endfunction

    function void axi_set_stats_write_channel_phase_last_duration_from_CY( int stats_write_channel_phase_last_duration_param );
        stats_write_channel_phase_last_duration = stats_write_channel_phase_last_duration_param;
    endfunction

    function void axi_set_stats_write_resp_channel_phase_last_duration_from_CY( int stats_write_resp_channel_phase_last_duration_param );
        stats_write_resp_channel_phase_last_duration = stats_write_resp_channel_phase_last_duration_param;
    endfunction

    //------------------------------------------------------------------------------
    // TLM Interface Support
    //------------------------------------------------------------------------------

    import "DPI-C" context axi_rw_transaction_ActivatesActivatingActivate_SystemVerilog =
    task axi_rw_transaction_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi_size_e size,
        inout axi_burst_e burst,
        inout axi_lock_e lock,
        inout axi_cache_e cache,
        inout axi_prot_e prot,
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [3:0] burst_length,
        input bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] data_words [],
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        input axi_response_e resp[],
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout bit [7:0] addr_user,
        input bit [7:0] data_user [],
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout bit [7:0] resp_user,
        inout axi_rw_e read_or_write,
        inout int address_to_data_latency,
        inout int data_to_response_latency,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        input int write_data_beats_delay[],
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int address_valid_delay,
        input int data_valid_delay[],
        inout int data_valid_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_response_valid_delay,
        inout int address_ready_delay,
        input int data_ready_delay[],
        inout int data_ready_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_response_ready_delay,
        inout bit write_data_with_address,
        input int _unit_id
    );
    import "DPI-C" context axi_rw_transaction_ActivatesActivatingActivate_open_SystemVerilog =
    task axi_rw_transaction_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi_size_e size,
        inout axi_burst_e burst,
        inout axi_lock_e lock,
        inout axi_cache_e cache,
        inout axi_prot_e prot,
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [3:0] burst_length,
        inout bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] data_words [],
        inout bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout axi_response_e resp[],
        inout bit [7:0] addr_user,
        inout bit [7:0] data_user [],
        inout bit [7:0] resp_user,
        inout axi_rw_e read_or_write,
        inout int address_to_data_latency,
        inout int data_to_response_latency,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int write_data_beats_delay[],
        inout int address_valid_delay,
        inout int data_valid_delay[],
        inout int write_response_valid_delay,
        inout int address_ready_delay,
        inout int data_ready_delay[],
        inout int write_response_ready_delay,
        inout bit write_data_with_address,
        input int _unit_id
    );
    import "DPI-C" context axi_rw_transaction_START_ActivatesActivatingActivate_SystemVerilog =
    function int axi_rw_transaction_START_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        inout bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi_size_e size,
        inout axi_burst_e burst,
        inout axi_lock_e lock,
        inout axi_cache_e cache,
        inout axi_prot_e prot,
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [3:0] burst_length,
        input bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] data_words [],
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        input axi_response_e resp[],
        inout bit [7:0] addr_user,
        input bit [7:0] data_user [],
        inout bit [7:0] resp_user,
        inout axi_rw_e read_or_write,
        inout int address_to_data_latency,
        inout int data_to_response_latency,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        input int write_data_beats_delay[],
        inout int address_valid_delay,
        input int data_valid_delay[],
        inout int write_response_valid_delay,
        inout int address_ready_delay,
        input int data_ready_delay[],
        inout int write_response_ready_delay,
        inout bit write_data_with_address,
        input int _unit_id
    );
    import "DPI-C" context axi_rw_transaction_END_ActivatesActivatingActivate_SystemVerilog =
    function int axi_rw_transaction_END_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_valid_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_ready_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi_rw_transaction_END_ActivatesActivatingActivate_open_SystemVerilog =
    function int axi_rw_transaction_END_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi_size_e size,
        inout axi_burst_e burst,
        inout axi_lock_e lock,
        inout axi_cache_e cache,
        inout axi_prot_e prot,
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [3:0] burst_length,
        inout bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] data_words [],
        inout bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout axi_response_e resp[],
        inout bit [7:0] addr_user,
        inout bit [7:0] data_user [],
        inout bit [7:0] resp_user,
        inout axi_rw_e read_or_write,
        inout int address_to_data_latency,
        inout int data_to_response_latency,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int write_data_beats_delay[],
        inout int address_valid_delay,
        inout int data_valid_delay[],
        inout int write_response_valid_delay,
        inout int address_ready_delay,
        inout int data_ready_delay[],
        inout int write_response_ready_delay,
        inout bit write_data_with_address,
        input int _unit_id
    );
    import "DPI-C" context axi_rw_transaction_Initiate_Join_SystemVerilog =
    task axi_rw_transaction_Initiate_Join_SystemVerilog
    (
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_valid_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_ready_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi_rw_transaction_Initiate_Join_open_SystemVerilog =
    task axi_rw_transaction_Initiate_Join_open_SystemVerilog
    (
        input longint _as_end,
        output int _trans_id,
        inout bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi_size_e size,
        inout axi_burst_e burst,
        inout axi_lock_e lock,
        inout axi_cache_e cache,
        inout axi_prot_e prot,
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [3:0] burst_length,
        inout bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] data_words [],
        inout bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout axi_response_e resp[],
        inout bit [7:0] addr_user,
        inout bit [7:0] data_user [],
        inout bit [7:0] resp_user,
        inout axi_rw_e read_or_write,
        inout int address_to_data_latency,
        inout int data_to_response_latency,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int write_data_beats_delay[],
        inout int address_valid_delay,
        inout int data_valid_delay[],
        inout int write_response_valid_delay,
        inout int address_ready_delay,
        inout int data_ready_delay[],
        inout int write_response_ready_delay,
        inout bit write_data_with_address,
        input int _unit_id
    );
    import "DPI-C" context axi_rw_transaction_Complete_Join_SystemVerilog =
    task axi_rw_transaction_Complete_Join_SystemVerilog
    (
        input longint _as_end,
        input int _trans_id,
        inout bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi_size_e size,
        inout axi_burst_e burst,
        inout axi_lock_e lock,
        inout axi_cache_e cache,
        inout axi_prot_e prot,
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [3:0] burst_length,
        input bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] data_words [],
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        input axi_response_e resp[],
        inout bit [7:0] addr_user,
        input bit [7:0] data_user [],
        inout bit [7:0] resp_user,
        inout axi_rw_e read_or_write,
        inout int address_to_data_latency,
        inout int data_to_response_latency,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        input int write_data_beats_delay[],
        inout int address_valid_delay,
        input int data_valid_delay[],
        inout int write_response_valid_delay,
        inout int address_ready_delay,
        input int data_ready_delay[],
        inout int write_response_ready_delay,
        inout bit write_data_with_address,
        input int _unit_id
    );
    import "DPI-C" context axi_rw_transaction_ReceivedReceivingReceive_SystemVerilog =
    task axi_rw_transaction_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_valid_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_ready_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_rw_transaction_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_rw_transaction_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        inout bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] data_words [],
        inout bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout axi_response_e resp[],
        output bit [7:0] addr_user,
        inout bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output axi_rw_e read_or_write,
        output int address_to_data_latency,
        output int data_to_response_latency,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        inout int write_data_beats_delay[],
        output int address_valid_delay,
        inout int data_valid_delay[],
        output int write_response_valid_delay,
        output int address_ready_delay,
        inout int data_ready_delay[],
        output int write_response_ready_delay,
        output bit write_data_with_address,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_rw_transaction_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi_rw_transaction_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_rw_transaction_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi_rw_transaction_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_valid_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_ready_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi_rw_transaction_END_ReceivedReceivingReceive_open_SystemVerilog =
    function int axi_rw_transaction_END_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        inout bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] data_words [],
        inout bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout axi_response_e resp[],
        output bit [7:0] addr_user,
        inout bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output axi_rw_e read_or_write,
        output int address_to_data_latency,
        output int data_to_response_latency,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        inout int write_data_beats_delay[],
        output int address_valid_delay,
        inout int data_valid_delay[],
        output int write_response_valid_delay,
        output int address_ready_delay,
        inout int data_ready_delay[],
        output int write_response_ready_delay,
        output bit write_data_with_address,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_read_ActivatesActivatingActivate_SystemVerilog =
    task axi_AXI_read_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi_size_e size,
        inout axi_burst_e burst,
        inout axi_lock_e lock,
        inout axi_cache_e cache,
        inout axi_prot_e prot,
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [3:0] burst_length,
        input bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        input axi_response_e resp[],
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout bit [7:0] addr_user,
        input bit [7:0] data_user [],
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int address_to_data_latency,
        inout longint addr_start_time,
        inout longint addr_end_time,
        input longint data_start_time[],
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input longint data_end_time[],
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_read_ActivatesActivatingActivate_open_SystemVerilog =
    task axi_AXI_read_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi_size_e size,
        inout axi_burst_e burst,
        inout axi_lock_e lock,
        inout axi_cache_e cache,
        inout axi_prot_e prot,
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [3:0] burst_length,
        inout bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        inout axi_response_e resp[],
        inout bit [7:0] addr_user,
        inout bit [7:0] data_user [],
        inout int address_to_data_latency,
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout longint data_start_time[],
        inout longint data_end_time[],
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_read_START_ActivatesActivatingActivate_SystemVerilog =
    function int axi_AXI_read_START_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        inout bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi_size_e size,
        inout axi_burst_e burst,
        inout axi_lock_e lock,
        inout axi_cache_e cache,
        inout axi_prot_e prot,
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [3:0] burst_length,
        input bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        input axi_response_e resp[],
        inout bit [7:0] addr_user,
        input bit [7:0] data_user [],
        inout int address_to_data_latency,
        inout longint addr_start_time,
        inout longint addr_end_time,
        input longint data_start_time[],
        input longint data_end_time[],
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_read_END_ActivatesActivatingActivate_SystemVerilog =
    function int axi_AXI_read_END_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_read_END_ActivatesActivatingActivate_open_SystemVerilog =
    function int axi_AXI_read_END_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi_size_e size,
        inout axi_burst_e burst,
        inout axi_lock_e lock,
        inout axi_cache_e cache,
        inout axi_prot_e prot,
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [3:0] burst_length,
        inout bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        inout axi_response_e resp[],
        inout bit [7:0] addr_user,
        inout bit [7:0] data_user [],
        inout int address_to_data_latency,
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout longint data_start_time[],
        inout longint data_end_time[],
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_read_Initiate_Join_SystemVerilog =
    task axi_AXI_read_Initiate_Join_SystemVerilog
    (
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_read_Initiate_Join_open_SystemVerilog =
    task axi_AXI_read_Initiate_Join_open_SystemVerilog
    (
        input longint _as_end,
        output int _trans_id,
        inout bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi_size_e size,
        inout axi_burst_e burst,
        inout axi_lock_e lock,
        inout axi_cache_e cache,
        inout axi_prot_e prot,
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [3:0] burst_length,
        inout bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        inout axi_response_e resp[],
        inout bit [7:0] addr_user,
        inout bit [7:0] data_user [],
        inout int address_to_data_latency,
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout longint data_start_time[],
        inout longint data_end_time[],
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_read_Complete_Join_SystemVerilog =
    task axi_AXI_read_Complete_Join_SystemVerilog
    (
        input longint _as_end,
        input int _trans_id,
        inout bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi_size_e size,
        inout axi_burst_e burst,
        inout axi_lock_e lock,
        inout axi_cache_e cache,
        inout axi_prot_e prot,
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [3:0] burst_length,
        input bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        input axi_response_e resp[],
        inout bit [7:0] addr_user,
        input bit [7:0] data_user [],
        inout int address_to_data_latency,
        inout longint addr_start_time,
        inout longint addr_end_time,
        input longint data_start_time[],
        input longint data_end_time[],
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_read_ReceivedReceivingReceive_SystemVerilog =
    task axi_AXI_read_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_AXI_read_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_AXI_read_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        inout bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        inout axi_response_e resp[],
        output bit [7:0] addr_user,
        inout bit [7:0] data_user [],
        output int address_to_data_latency,
        output longint addr_start_time,
        output longint addr_end_time,
        inout longint data_start_time[],
        inout longint data_end_time[],
        output int address_valid_delay,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_AXI_read_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi_AXI_read_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_AXI_read_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi_AXI_read_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_read_END_ReceivedReceivingReceive_open_SystemVerilog =
    function int axi_AXI_read_END_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        inout bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        inout axi_response_e resp[],
        output bit [7:0] addr_user,
        inout bit [7:0] data_user [],
        output int address_to_data_latency,
        output longint addr_start_time,
        output longint addr_end_time,
        inout longint data_start_time[],
        inout longint data_end_time[],
        output int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_write_ActivatesActivatingActivate_SystemVerilog =
    task axi_AXI_write_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi_size_e size,
        inout axi_burst_e burst,
        inout axi_lock_e lock,
        inout axi_cache_e cache,
        inout axi_prot_e prot,
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [3:0] burst_length,
        input bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout axi_response_e resp,
        inout bit [7:0] addr_user,
        input bit [7:0] data_user [],
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout bit [7:0] resp_user,
        inout int address_to_data_latency,
        inout int data_to_response_latency,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        input int write_data_beats_delay[],
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout longint addr_start_time,
        inout longint addr_end_time,
        input longint data_start_time[],
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input longint data_end_time[],
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout longint wr_resp_start_time,
        inout longint wr_resp_end_time,
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_write_ActivatesActivatingActivate_open_SystemVerilog =
    task axi_AXI_write_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi_size_e size,
        inout axi_burst_e burst,
        inout axi_lock_e lock,
        inout axi_cache_e cache,
        inout axi_prot_e prot,
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [3:0] burst_length,
        inout bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        inout bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout axi_response_e resp,
        inout bit [7:0] addr_user,
        inout bit [7:0] data_user [],
        inout bit [7:0] resp_user,
        inout int address_to_data_latency,
        inout int data_to_response_latency,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int write_data_beats_delay[],
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout longint data_start_time[],
        inout longint data_end_time[],
        inout longint wr_resp_start_time,
        inout longint wr_resp_end_time,
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_write_START_ActivatesActivatingActivate_SystemVerilog =
    function int axi_AXI_write_START_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        inout bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi_size_e size,
        inout axi_burst_e burst,
        inout axi_lock_e lock,
        inout axi_cache_e cache,
        inout axi_prot_e prot,
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [3:0] burst_length,
        input bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout axi_response_e resp,
        inout bit [7:0] addr_user,
        input bit [7:0] data_user [],
        inout bit [7:0] resp_user,
        inout int address_to_data_latency,
        inout int data_to_response_latency,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        input int write_data_beats_delay[],
        inout longint addr_start_time,
        inout longint addr_end_time,
        input longint data_start_time[],
        input longint data_end_time[],
        inout longint wr_resp_start_time,
        inout longint wr_resp_end_time,
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_write_END_ActivatesActivatingActivate_SystemVerilog =
    function int axi_AXI_write_END_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_write_END_ActivatesActivatingActivate_open_SystemVerilog =
    function int axi_AXI_write_END_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi_size_e size,
        inout axi_burst_e burst,
        inout axi_lock_e lock,
        inout axi_cache_e cache,
        inout axi_prot_e prot,
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [3:0] burst_length,
        inout bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        inout bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout axi_response_e resp,
        inout bit [7:0] addr_user,
        inout bit [7:0] data_user [],
        inout bit [7:0] resp_user,
        inout int address_to_data_latency,
        inout int data_to_response_latency,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int write_data_beats_delay[],
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout longint data_start_time[],
        inout longint data_end_time[],
        inout longint wr_resp_start_time,
        inout longint wr_resp_end_time,
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_write_Initiate_Join_SystemVerilog =
    task axi_AXI_write_Initiate_Join_SystemVerilog
    (
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_write_Initiate_Join_open_SystemVerilog =
    task axi_AXI_write_Initiate_Join_open_SystemVerilog
    (
        input longint _as_end,
        output int _trans_id,
        inout bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi_size_e size,
        inout axi_burst_e burst,
        inout axi_lock_e lock,
        inout axi_cache_e cache,
        inout axi_prot_e prot,
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [3:0] burst_length,
        inout bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        inout bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout axi_response_e resp,
        inout bit [7:0] addr_user,
        inout bit [7:0] data_user [],
        inout bit [7:0] resp_user,
        inout int address_to_data_latency,
        inout int data_to_response_latency,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int write_data_beats_delay[],
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout longint data_start_time[],
        inout longint data_end_time[],
        inout longint wr_resp_start_time,
        inout longint wr_resp_end_time,
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_write_Complete_Join_SystemVerilog =
    task axi_AXI_write_Complete_Join_SystemVerilog
    (
        input longint _as_end,
        input int _trans_id,
        inout bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi_size_e size,
        inout axi_burst_e burst,
        inout axi_lock_e lock,
        inout axi_cache_e cache,
        inout axi_prot_e prot,
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [3:0] burst_length,
        input bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout axi_response_e resp,
        inout bit [7:0] addr_user,
        input bit [7:0] data_user [],
        inout bit [7:0] resp_user,
        inout int address_to_data_latency,
        inout int data_to_response_latency,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        input int write_data_beats_delay[],
        inout longint addr_start_time,
        inout longint addr_end_time,
        input longint data_start_time[],
        input longint data_end_time[],
        inout longint wr_resp_start_time,
        inout longint wr_resp_end_time,
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_write_ReceivedReceivingReceive_SystemVerilog =
    task axi_AXI_write_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_AXI_write_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_AXI_write_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        inout bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        inout bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output axi_response_e resp,
        output bit [7:0] addr_user,
        inout bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output int address_to_data_latency,
        output int data_to_response_latency,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        inout int write_data_beats_delay[],
        output longint addr_start_time,
        output longint addr_end_time,
        inout longint data_start_time[],
        inout longint data_end_time[],
        output longint wr_resp_start_time,
        output longint wr_resp_end_time,
        output int address_valid_delay,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_AXI_write_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi_AXI_write_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_AXI_write_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi_AXI_write_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_write_END_ReceivedReceivingReceive_open_SystemVerilog =
    function int axi_AXI_write_END_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        inout bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        inout bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output axi_response_e resp,
        output bit [7:0] addr_user,
        inout bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output int address_to_data_latency,
        output int data_to_response_latency,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        inout int write_data_beats_delay[],
        output longint addr_start_time,
        output longint addr_end_time,
        inout longint data_start_time[],
        inout longint data_end_time[],
        output longint wr_resp_start_time,
        output longint wr_resp_end_time,
        output int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_data_resp_ActivatesActivatingActivate_SystemVerilog =
    task axi_data_resp_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int burst_length,
        input bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout axi_response_e resp,
        input bit [7:0] data_user [],
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout bit [7:0] resp_user,
        inout longint data_start,
        inout longint data_end,
        inout longint response_start,
        input int write_data_beats_delay[],
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input longint data_beat_start_time[],
        inout int data_beat_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input longint data_beat_end_time[],
        inout int data_beat_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout longint response_end_time,
        input int _unit_id
    );
    import "DPI-C" context axi_data_resp_ActivatesActivatingActivate_open_SystemVerilog =
    task axi_data_resp_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int burst_length,
        inout bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        inout bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout axi_response_e resp,
        inout bit [7:0] data_user [],
        inout bit [7:0] resp_user,
        inout longint data_start,
        inout longint data_end,
        inout longint response_start,
        inout int write_data_beats_delay[],
        inout longint data_beat_start_time[],
        inout longint data_beat_end_time[],
        inout longint response_end_time,
        input int _unit_id
    );
    import "DPI-C" context axi_data_resp_START_ActivatesActivatingActivate_SystemVerilog =
    function int axi_data_resp_START_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        inout int burst_length,
        input bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout axi_response_e resp,
        input bit [7:0] data_user [],
        inout bit [7:0] resp_user,
        inout longint data_start,
        inout longint data_end,
        inout longint response_start,
        input int write_data_beats_delay[],
        input longint data_beat_start_time[],
        input longint data_beat_end_time[],
        inout longint response_end_time,
        input int _unit_id
    );
    import "DPI-C" context axi_data_resp_END_ActivatesActivatingActivate_SystemVerilog =
    function int axi_data_resp_END_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_beat_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_beat_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi_data_resp_END_ActivatesActivatingActivate_open_SystemVerilog =
    function int axi_data_resp_END_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int burst_length,
        inout bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        inout bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout axi_response_e resp,
        inout bit [7:0] data_user [],
        inout bit [7:0] resp_user,
        inout longint data_start,
        inout longint data_end,
        inout longint response_start,
        inout int write_data_beats_delay[],
        inout longint data_beat_start_time[],
        inout longint data_beat_end_time[],
        inout longint response_end_time,
        input int _unit_id
    );
    import "DPI-C" context axi_data_resp_Initiate_Join_SystemVerilog =
    task axi_data_resp_Initiate_Join_SystemVerilog
    (
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_beat_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_beat_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi_data_resp_Initiate_Join_open_SystemVerilog =
    task axi_data_resp_Initiate_Join_open_SystemVerilog
    (
        input longint _as_end,
        output int _trans_id,
        inout int burst_length,
        inout bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        inout bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout axi_response_e resp,
        inout bit [7:0] data_user [],
        inout bit [7:0] resp_user,
        inout longint data_start,
        inout longint data_end,
        inout longint response_start,
        inout int write_data_beats_delay[],
        inout longint data_beat_start_time[],
        inout longint data_beat_end_time[],
        inout longint response_end_time,
        input int _unit_id
    );
    import "DPI-C" context axi_data_resp_Complete_Join_SystemVerilog =
    task axi_data_resp_Complete_Join_SystemVerilog
    (
        input longint _as_end,
        input int _trans_id,
        inout int burst_length,
        input bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout axi_response_e resp,
        input bit [7:0] data_user [],
        inout bit [7:0] resp_user,
        inout longint data_start,
        inout longint data_end,
        inout longint response_start,
        input int write_data_beats_delay[],
        input longint data_beat_start_time[],
        input longint data_beat_end_time[],
        inout longint response_end_time,
        input int _unit_id
    );
    import "DPI-C" context axi_data_resp_ReceivedReceivingReceive_SystemVerilog =
    task axi_data_resp_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_beat_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_beat_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_data_resp_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_data_resp_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int burst_length,
        inout bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        inout bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output axi_response_e resp,
        inout bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output longint data_start,
        output longint data_end,
        output longint response_start,
        inout int write_data_beats_delay[],
        inout longint data_beat_start_time[],
        inout longint data_beat_end_time[],
        output longint response_end_time,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_data_resp_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi_data_resp_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_data_resp_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi_data_resp_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_beat_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_beat_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi_data_resp_END_ReceivedReceivingReceive_open_SystemVerilog =
    function int axi_data_resp_END_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int burst_length,
        inout bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        inout bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output axi_response_e resp,
        inout bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output longint data_start,
        output longint data_end,
        output longint response_start,
        inout int write_data_beats_delay[],
        inout longint data_beat_start_time[],
        inout longint data_beat_end_time[],
        output longint response_end_time,
        input int _unit_id
    );
    import "DPI-C" context axi_read_data_burst_SendSendingSent_SystemVerilog =
    task axi_read_data_burst_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [3:0] burst_length,
        input bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        input axi_response_e resp[],
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user [],
        input longint data_start_time[],
        input longint data_end_time[],
        input int _unit_id
    );
    import "DPI-C" context axi_read_data_burst_START_SendSendingSent_SystemVerilog =
    function int axi_read_data_burst_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [3:0] burst_length,
        input bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        input axi_response_e resp[],
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user [],
        input longint data_start_time[],
        input longint data_end_time[],
        input int _unit_id
    );
    import "DPI-C" context axi_read_data_burst_END_SendSendingSent_SystemVerilog =
    function int axi_read_data_burst_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi_read_data_burst_ReceivedReceivingReceive_SystemVerilog =
    task axi_read_data_burst_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_data_burst_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_read_data_burst_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [3:0] burst_length,
        inout bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        inout axi_response_e resp[],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] data_user [],
        inout longint data_start_time[],
        inout longint data_end_time[],
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_data_burst_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi_read_data_burst_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_data_burst_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi_read_data_burst_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi_read_data_burst_END_ReceivedReceivingReceive_open_SystemVerilog =
    function int axi_read_data_burst_END_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [3:0] burst_length,
        inout bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        inout axi_response_e resp[],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] data_user [],
        inout longint data_start_time[],
        inout longint data_end_time[],
        input int _unit_id
    );
    import "DPI-C" context axi_write_data_burst_SendSendingSent_SystemVerilog =
    task axi_write_data_burst_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int burst_length,
        input bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user [],
        input int write_data_beats_delay[],
        input longint data_start_time[],
        input longint data_end_time[],
        input int _unit_id
    );
    import "DPI-C" context axi_write_data_burst_START_SendSendingSent_SystemVerilog =
    function int axi_write_data_burst_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int burst_length,
        input bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user [],
        input int write_data_beats_delay[],
        input longint data_start_time[],
        input longint data_end_time[],
        input int _unit_id
    );
    import "DPI-C" context axi_write_data_burst_END_SendSendingSent_SystemVerilog =
    function int axi_write_data_burst_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi_write_data_burst_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_data_burst_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_data_burst_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_write_data_burst_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int burst_length,
        inout bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        inout bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] data_user [],
        inout int write_data_beats_delay[],
        inout longint data_start_time[],
        inout longint data_end_time[],
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_data_burst_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi_write_data_burst_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_data_burst_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi_write_data_burst_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi_write_data_burst_END_ReceivedReceivingReceive_open_SystemVerilog =
    function int axi_write_data_burst_END_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int burst_length,
        inout bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        inout bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] data_user [],
        inout int write_data_beats_delay[],
        inout longint data_start_time[],
        inout longint data_end_time[],
        input int _unit_id
    );
    import "DPI-C" context axi_read_addr_channel_phase_SendSendingSent_SystemVerilog =
    task axi_read_addr_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_read_addr_channel_phase_START_SendSendingSent_SystemVerilog =
    function int axi_read_addr_channel_phase_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_read_addr_channel_phase_END_SendSendingSent_SystemVerilog =
    function int axi_read_addr_channel_phase_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi_read_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi_read_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_addr_channel_phase_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi_read_addr_channel_phase_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_addr_channel_phase_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi_read_addr_channel_phase_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_read_channel_phase_SendSendingSent_SystemVerilog =
    task axi_read_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int data_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_read_channel_phase_START_SendSendingSent_SystemVerilog =
    function int axi_read_channel_phase_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int data_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_read_channel_phase_END_SendSendingSent_SystemVerilog =
    function int axi_read_channel_phase_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi_read_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi_read_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        output int data_ready_delay,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_channel_phase_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi_read_channel_phase_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_channel_phase_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi_read_channel_phase_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit last,
        output bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        output int data_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_write_addr_channel_phase_SendSendingSent_SystemVerilog =
    task axi_write_addr_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_write_addr_channel_phase_START_SendSendingSent_SystemVerilog =
    function int axi_write_addr_channel_phase_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_write_addr_channel_phase_END_SendSendingSent_SystemVerilog =
    function int axi_write_addr_channel_phase_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi_write_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_addr_channel_phase_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi_write_addr_channel_phase_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_addr_channel_phase_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi_write_addr_channel_phase_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_write_channel_phase_SendSendingSent_SystemVerilog =
    task axi_write_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int data_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_write_channel_phase_START_SendSendingSent_SystemVerilog =
    function int axi_write_channel_phase_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int data_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_write_channel_phase_END_SendSendingSent_SystemVerilog =
    function int axi_write_channel_phase_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi_write_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        output int data_ready_delay,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_channel_phase_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi_write_channel_phase_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_channel_phase_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi_write_channel_phase_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit last,
        output bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        output int data_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_write_resp_channel_phase_SendSendingSent_SystemVerilog =
    task axi_write_resp_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] resp_user,
        input int write_response_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_write_resp_channel_phase_START_SendSendingSent_SystemVerilog =
    function int axi_write_resp_channel_phase_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] resp_user,
        input int write_response_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_write_resp_channel_phase_END_SendSendingSent_SystemVerilog =
    function int axi_write_resp_channel_phase_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi_write_resp_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_resp_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] resp_user,
        output int write_response_ready_delay,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_resp_channel_phase_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi_write_resp_channel_phase_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_resp_channel_phase_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi_write_resp_channel_phase_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] resp_user,
        output int write_response_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_read_addr_channel_cycle_SendSendingSent_SystemVerilog =
    task axi_read_addr_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int _unit_id
    );
    import "DPI-C" context axi_read_addr_channel_cycle_START_SendSendingSent_SystemVerilog =
    function int axi_read_addr_channel_cycle_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int _unit_id
    );
    import "DPI-C" context axi_read_addr_channel_cycle_END_SendSendingSent_SystemVerilog =
    function int axi_read_addr_channel_cycle_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi_read_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi_read_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_addr_channel_cycle_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi_read_addr_channel_cycle_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_addr_channel_cycle_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi_read_addr_channel_cycle_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        input int _unit_id
    );
    import "DPI-C" context axi_read_addr_channel_ready_SendSendingSent_SystemVerilog =
    task axi_read_addr_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_read_addr_channel_ready_START_SendSendingSent_SystemVerilog =
    function int axi_read_addr_channel_ready_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_read_addr_channel_ready_END_SendSendingSent_SystemVerilog =
    function int axi_read_addr_channel_ready_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi_read_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi_read_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_addr_channel_ready_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi_read_addr_channel_ready_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_addr_channel_ready_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi_read_addr_channel_ready_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_read_channel_cycle_SendSendingSent_SystemVerilog =
    task axi_read_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int _unit_id
    );
    import "DPI-C" context axi_read_channel_cycle_START_SendSendingSent_SystemVerilog =
    function int axi_read_channel_cycle_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int _unit_id
    );
    import "DPI-C" context axi_read_channel_cycle_END_SendSendingSent_SystemVerilog =
    function int axi_read_channel_cycle_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi_read_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi_read_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_channel_cycle_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi_read_channel_cycle_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_channel_cycle_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi_read_channel_cycle_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit last,
        output bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        input int _unit_id
    );
    import "DPI-C" context axi_read_channel_ready_SendSendingSent_SystemVerilog =
    task axi_read_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_read_channel_ready_START_SendSendingSent_SystemVerilog =
    function int axi_read_channel_ready_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_read_channel_ready_END_SendSendingSent_SystemVerilog =
    function int axi_read_channel_ready_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi_read_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi_read_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_channel_ready_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi_read_channel_ready_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_channel_ready_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi_read_channel_ready_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_write_addr_channel_cycle_SendSendingSent_SystemVerilog =
    task axi_write_addr_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int _unit_id
    );
    import "DPI-C" context axi_write_addr_channel_cycle_START_SendSendingSent_SystemVerilog =
    function int axi_write_addr_channel_cycle_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int _unit_id
    );
    import "DPI-C" context axi_write_addr_channel_cycle_END_SendSendingSent_SystemVerilog =
    function int axi_write_addr_channel_cycle_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi_write_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_addr_channel_cycle_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi_write_addr_channel_cycle_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_addr_channel_cycle_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi_write_addr_channel_cycle_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        input int _unit_id
    );
    import "DPI-C" context axi_write_addr_channel_ready_SendSendingSent_SystemVerilog =
    task axi_write_addr_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_write_addr_channel_ready_START_SendSendingSent_SystemVerilog =
    function int axi_write_addr_channel_ready_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_write_addr_channel_ready_END_SendSendingSent_SystemVerilog =
    function int axi_write_addr_channel_ready_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi_write_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_addr_channel_ready_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi_write_addr_channel_ready_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_addr_channel_ready_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi_write_addr_channel_ready_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_write_channel_cycle_SendSendingSent_SystemVerilog =
    task axi_write_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  strb,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int _unit_id
    );
    import "DPI-C" context axi_write_channel_cycle_START_SendSendingSent_SystemVerilog =
    function int axi_write_channel_cycle_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  strb,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int _unit_id
    );
    import "DPI-C" context axi_write_channel_cycle_END_SendSendingSent_SystemVerilog =
    function int axi_write_channel_cycle_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi_write_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  strb,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_channel_cycle_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi_write_channel_cycle_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_channel_cycle_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi_write_channel_cycle_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit last,
        output bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  strb,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        input int _unit_id
    );
    import "DPI-C" context axi_write_channel_ready_SendSendingSent_SystemVerilog =
    task axi_write_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_write_channel_ready_START_SendSendingSent_SystemVerilog =
    function int axi_write_channel_ready_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_write_channel_ready_END_SendSendingSent_SystemVerilog =
    function int axi_write_channel_ready_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi_write_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_channel_ready_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi_write_channel_ready_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_channel_ready_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi_write_channel_ready_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_write_resp_channel_cycle_SendSendingSent_SystemVerilog =
    task axi_write_resp_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] resp_user,
        input int _unit_id
    );
    import "DPI-C" context axi_write_resp_channel_cycle_START_SendSendingSent_SystemVerilog =
    function int axi_write_resp_channel_cycle_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] resp_user,
        input int _unit_id
    );
    import "DPI-C" context axi_write_resp_channel_cycle_END_SendSendingSent_SystemVerilog =
    function int axi_write_resp_channel_cycle_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi_write_resp_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_resp_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] resp_user,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_resp_channel_cycle_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi_write_resp_channel_cycle_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_resp_channel_cycle_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi_write_resp_channel_cycle_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] resp_user,
        input int _unit_id
    );
    import "DPI-C" context axi_write_resp_channel_ready_SendSendingSent_SystemVerilog =
    task axi_write_resp_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_write_resp_channel_ready_START_SendSendingSent_SystemVerilog =
    function int axi_write_resp_channel_ready_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_write_resp_channel_ready_END_SendSendingSent_SystemVerilog =
    function int axi_write_resp_channel_ready_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi_write_resp_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_resp_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_resp_channel_ready_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi_write_resp_channel_ready_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_resp_channel_ready_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi_write_resp_channel_ready_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit ready,
        input int _unit_id
    );
    // Waiter task and control
    reg wait_for_control = 0;

    always @(posedge wait_for_control)
    begin
        disable wait_for;
        wait_for_control = 0;
    end

    export "DPI-C" axi_wait_for = task wait_for;

    task wait_for();
        begin
            wait(0 == 1);
        end
    endtask

    // handle control
    longint last_handle = 0;

    longint last_start_time = 0;

    longint last_end_time = 0;

    export "DPI-C" axi_set_last_handle_and_times = function set_last_handle_and_times;

    function void set_last_handle_and_times(longint _handle, longint _start, longint _end);
        last_handle = _handle;
        last_start_time = _start;
        last_end_time = _end;
    endfunction

    // Drive wires (from Cohesive) 
    assign ACLK = internal_ACLK;
    assign ARESETn = internal_ARESETn;
    assign AWVALID = internal_AWVALID;
    assign AWADDR = internal_AWADDR;
    assign AWLEN = internal_AWLEN;
    assign AWSIZE = internal_AWSIZE;
    assign AWBURST = internal_AWBURST;
    assign AWLOCK = internal_AWLOCK;
    assign AWCACHE = internal_AWCACHE;
    assign AWPROT = internal_AWPROT;
    assign AWID = internal_AWID;
    assign AWREADY = internal_AWREADY;
    assign AWUSER = internal_AWUSER;
    assign ARVALID = internal_ARVALID;
    assign ARADDR = internal_ARADDR;
    assign ARLEN = internal_ARLEN;
    assign ARSIZE = internal_ARSIZE;
    assign ARBURST = internal_ARBURST;
    assign ARLOCK = internal_ARLOCK;
    assign ARCACHE = internal_ARCACHE;
    assign ARPROT = internal_ARPROT;
    assign ARID = internal_ARID;
    assign ARREADY = internal_ARREADY;
    assign ARUSER = internal_ARUSER;
    assign RVALID = internal_RVALID;
    assign RLAST = internal_RLAST;
    assign RDATA = internal_RDATA;
    assign RRESP = internal_RRESP;
    assign RID = internal_RID;
    assign RREADY = internal_RREADY;
    assign RUSER = internal_RUSER;
    assign WVALID = internal_WVALID;
    assign WLAST = internal_WLAST;
    assign WDATA = internal_WDATA;
    assign WSTRB = internal_WSTRB;
    assign WID = internal_WID;
    assign WREADY = internal_WREADY;
    assign WUSER = internal_WUSER;
    assign BVALID = internal_BVALID;
    assign BRESP = internal_BRESP;
    assign BID = internal_BID;
    assign BREADY = internal_BREADY;
    assign BUSER = internal_BUSER;
    // Drive wires (from User) 
    assign ACLK = m_ACLK;
    assign ARESETn = m_ARESETn;
    assign AWVALID = m_AWVALID;
    assign AWADDR = m_AWADDR;
    assign AWLEN = m_AWLEN;
    assign AWSIZE = m_AWSIZE;
    assign AWBURST = m_AWBURST;
    assign AWLOCK = m_AWLOCK;
    assign AWCACHE = m_AWCACHE;
    assign AWPROT = m_AWPROT;
    assign AWID = m_AWID;
    assign AWREADY = m_AWREADY;
    assign AWUSER = m_AWUSER;
    assign ARVALID = m_ARVALID;
    assign ARADDR = m_ARADDR;
    assign ARLEN = m_ARLEN;
    assign ARSIZE = m_ARSIZE;
    assign ARBURST = m_ARBURST;
    assign ARLOCK = m_ARLOCK;
    assign ARCACHE = m_ARCACHE;
    assign ARPROT = m_ARPROT;
    assign ARID = m_ARID;
    assign ARREADY = m_ARREADY;
    assign ARUSER = m_ARUSER;
    assign RVALID = m_RVALID;
    assign RLAST = m_RLAST;
    assign RDATA = m_RDATA;
    assign RRESP = m_RRESP;
    assign RID = m_RID;
    assign RREADY = m_RREADY;
    assign RUSER = m_RUSER;
    assign WVALID = m_WVALID;
    assign WLAST = m_WLAST;
    assign WDATA = m_WDATA;
    assign WSTRB = m_WSTRB;
    assign WID = m_WID;
    assign WREADY = m_WREADY;
    assign WUSER = m_WUSER;
    assign BVALID = m_BVALID;
    assign BRESP = m_BRESP;
    assign BID = m_BID;
    assign BREADY = m_BREADY;
    assign BUSER = m_BUSER;

    reg ACLK_changed = 0;
    reg ARESETn_changed = 0;
    reg AWVALID_changed = 0;
    reg AWADDR_changed = 0;
    reg AWLEN_changed = 0;
    reg AWSIZE_changed = 0;
    reg AWBURST_changed = 0;
    reg AWLOCK_changed = 0;
    reg AWCACHE_changed = 0;
    reg AWPROT_changed = 0;
    reg AWID_changed = 0;
    reg AWREADY_changed = 0;
    reg AWUSER_changed = 0;
    reg ARVALID_changed = 0;
    reg ARADDR_changed = 0;
    reg ARLEN_changed = 0;
    reg ARSIZE_changed = 0;
    reg ARBURST_changed = 0;
    reg ARLOCK_changed = 0;
    reg ARCACHE_changed = 0;
    reg ARPROT_changed = 0;
    reg ARID_changed = 0;
    reg ARREADY_changed = 0;
    reg ARUSER_changed = 0;
    reg RVALID_changed = 0;
    reg RLAST_changed = 0;
    reg RDATA_changed = 0;
    reg RRESP_changed = 0;
    reg RID_changed = 0;
    reg RREADY_changed = 0;
    reg RUSER_changed = 0;
    reg WVALID_changed = 0;
    reg WLAST_changed = 0;
    reg WDATA_changed = 0;
    reg WSTRB_changed = 0;
    reg WID_changed = 0;
    reg WREADY_changed = 0;
    reg WUSER_changed = 0;
    reg BVALID_changed = 0;
    reg BRESP_changed = 0;
    reg BID_changed = 0;
    reg BREADY_changed = 0;
    reg BUSER_changed = 0;
    reg config_clk_init_value_changed = 0;
    reg config_clk_phase_shift_changed = 0;
    reg config_clk_1st_time_changed = 0;
    reg config_clk_2nd_time_changed = 0;
    reg config_setup_time_changed = 0;
    reg config_hold_time_changed = 0;
    reg config_max_transaction_time_factor_changed = 0;
    reg config_timeout_max_data_transfer_changed = 0;
    reg config_burst_timeout_factor_changed = 0;
    reg config_max_latency_AWVALID_assertion_to_AWREADY_changed = 0;
    reg config_max_latency_ARVALID_assertion_to_ARREADY_changed = 0;
    reg config_max_latency_RVALID_assertion_to_RREADY_changed = 0;
    reg config_max_latency_BVALID_assertion_to_BREADY_changed = 0;
    reg config_max_latency_WVALID_assertion_to_WREADY_changed = 0;
    reg config_write_ctrl_first_ratio_changed = 0;
    reg config_write_data_first_ratio_changed = 0;
    reg config_write_ctrl_to_data_mintime_changed = 0;
    reg config_write_data_to_ctrl_mintime_changed = 0;
    reg config_master_write_delay_changed = 0;
    reg config_reset_low_clocks_changed = 0;
    reg config_reset_hold_time_changed = 0;
    reg config_protect_ready_changed = 0;
    reg config_enable_user_sideband_changed = 0;
    reg config_extended_length_enable_changed = 0;
    reg config_enable_burst_reserved_value_changed = 0;
    reg config_enable_lock_reserved_value_changed = 0;
    reg config_enable_cache_reserved_value_changed = 0;
    reg config_enable_all_assertions_changed = 0;
    reg config_enable_assertion_changed = 0;
    reg config_enable_error_changed = 0;
    reg config_enable_errors_changed = 0;
    reg config_enable_all_assertion_errors_changed = 0;
    reg config_abstraction_level_changed = 0;
    reg config_slave_start_addr_changed = 0;
    reg config_slave_end_addr_changed = 0;
    reg config_enable_slave_addr_range_in_bfm_changed = 0;
    reg config_read_data_reordering_depth_changed = 0;
    reg config_enable_read_data_reordering_depth_in_bfm_changed = 0;
    reg config_awid_wid_mismatch_changed = 0;
    reg config_length_last_mismatch_error_changed = 0;
    reg config_master_error_position_changed = 0;
    reg dummy_var_changed = 0;
    reg config_wlast_length_changed = 0;
    reg config_wid_for_awid_not_matching_changed = 0;
    reg config_support_exclusive_access_changed = 0;
    reg config_write_data_interleaving_depth_changed = 0;
    reg status_master_error_changed = 0;
    reg status_num_reads_waiting_for_resp_changed = 0;
    reg status_num_writes_waiting_for_response_changed = 0;
    reg check_total_num_wdata_outstanding_changed = 0;
    reg total_num_wdata_outstanding_changed = 0;
    reg check_max_num_wdata_outstanding_per_id_changed = 0;
    reg max_num_wdata_outstanding_per_id_changed = 0;
    reg check_max_num_waddr_outstanding_per_id_changed = 0;
    reg max_num_waddr_outstanding_per_id_changed = 0;
    reg check_total_num_waddr_outstanding_changed = 0;
    reg total_num_waddr_outstanding_changed = 0;
    reg status_outstanding_num_for_waddr_changed = 0;
    reg start_finding_outstanding_waddr_changed = 0;
    reg status_outstanding_num_for_wdata_changed = 0;
    reg start_finding_outstanding_wdata_changed = 0;
    reg find_waddr_outstanding_for_wid_changed = 0;
    reg find_wdata_outstanding_for_wid_changed = 0;
    reg change_in_wdata_outstanding_per_id_changed = 0;
    reg start_finding_change_in_wdata_changed = 0;
    reg find_change_in_wdata_outstanding_for_wid_changed = 0;
    reg config_max_outstanding_wr_changed = 0;
    reg config_max_outstanding_rd_changed = 0;
    reg config_error_on_deleted_valid_cycles_changed = 0;
    reg config_stats_enable_changed = 0;
    reg config_stats_enable_AXI_read_occupancy_changed = 0;
    reg config_stats_enable_AXI_write_occupancy_changed = 0;
    reg config_stats_enable_read_data_occupancy_changed = 0;
    reg config_stats_enable_write_data_occupancy_changed = 0;
    reg config_stats_enable_read_latency_changed = 0;
    reg config_stats_enable_write_latency_changed = 0;
    reg config_stats_enable_read_address_waits_changed = 0;
    reg config_stats_enable_read_data_waits_changed = 0;
    reg config_stats_enable_write_address_waits_changed = 0;
    reg config_stats_enable_write_data_waits_changed = 0;
    reg config_stats_enable_write_response_waits_changed = 0;
    reg config_stats_enable_read_bandwidth_changed = 0;
    reg config_stats_enable_write_bandwidth_changed = 0;
    reg config_stats_AXI_read_occupancy_step_changed = 0;
    reg config_stats_AXI_read_occupancy_multiple_changed = 0;
    reg stats_AXI_read_active_changed = 0;
    reg stats_AXI_read_occupancy_sw_changed = 0;
    reg stats_AXI_read_occupancy_sw_updated_changed = 0;
    reg stats_AXI_read_idle_sw_changed = 0;
    reg stats_AXI_read_occupancy_min_changed = 0;
    reg stats_AXI_read_idle_min_changed = 0;
    reg stats_AXI_read_occupancy_max_changed = 0;
    reg stats_AXI_read_idle_max_changed = 0;
    reg stats_AXI_read_occupancy_mean_changed = 0;
    reg stats_AXI_read_idle_mean_changed = 0;
    reg config_stats_AXI_write_occupancy_step_changed = 0;
    reg config_stats_AXI_write_occupancy_multiple_changed = 0;
    reg stats_AXI_write_active_changed = 0;
    reg stats_AXI_write_occupancy_sw_changed = 0;
    reg stats_AXI_write_occupancy_sw_updated_changed = 0;
    reg stats_AXI_write_idle_sw_changed = 0;
    reg stats_AXI_write_occupancy_min_changed = 0;
    reg stats_AXI_write_idle_min_changed = 0;
    reg stats_AXI_write_occupancy_max_changed = 0;
    reg stats_AXI_write_idle_max_changed = 0;
    reg stats_AXI_write_occupancy_mean_changed = 0;
    reg stats_AXI_write_idle_mean_changed = 0;
    reg config_stats_read_data_occupancy_step_changed = 0;
    reg config_stats_read_data_occupancy_multiple_changed = 0;
    reg stats_read_data_occupancy_sw_changed = 0;
    reg stats_read_data_occupancy_sw_updated_changed = 0;
    reg stats_read_data_idle_sw_changed = 0;
    reg stats_read_data_occupancy_min_changed = 0;
    reg stats_read_data_idle_min_changed = 0;
    reg stats_read_data_occupancy_max_changed = 0;
    reg stats_read_data_idle_max_changed = 0;
    reg stats_read_data_occupancy_mean_changed = 0;
    reg stats_read_data_idle_mean_changed = 0;
    reg config_stats_write_data_occupancy_step_changed = 0;
    reg config_stats_write_data_occupancy_multiple_changed = 0;
    reg stats_write_data_occupancy_sw_changed = 0;
    reg stats_write_data_occupancy_sw_updated_changed = 0;
    reg stats_write_data_idle_sw_changed = 0;
    reg stats_write_data_occupancy_min_changed = 0;
    reg stats_write_data_idle_min_changed = 0;
    reg stats_write_data_occupancy_max_changed = 0;
    reg stats_write_data_idle_max_changed = 0;
    reg stats_write_data_occupancy_mean_changed = 0;
    reg stats_write_data_idle_mean_changed = 0;
    reg config_stats_read_bandwidth_step_changed = 0;
    reg config_stats_read_bandwidth_multiple_changed = 0;
    reg stats_read_bandwidth_sw_changed = 0;
    reg stats_read_bandwidth_sw_updated_changed = 0;
    reg stats_read_bandwidth_min_changed = 0;
    reg stats_read_bandwidth_max_changed = 0;
    reg stats_read_bandwidth_mean_changed = 0;
    reg config_stats_write_bandwidth_step_changed = 0;
    reg config_stats_write_bandwidth_multiple_changed = 0;
    reg stats_write_bandwidth_sw_changed = 0;
    reg stats_write_bandwidth_sw_updated_changed = 0;
    reg stats_write_bandwidth_min_changed = 0;
    reg stats_write_bandwidth_max_changed = 0;
    reg stats_write_bandwidth_mean_changed = 0;
    reg config_stats_read_latency_step_changed = 0;
    reg config_stats_read_latency_multiple_changed = 0;
    reg stats_read_latency_sw_updated_changed = 0;
    reg stats_read_address_data_latency_inst_changed = 0;
    reg stats_read_address_data_latency_sw_changed = 0;
    reg stats_read_address_data_latency_min_changed = 0;
    reg stats_read_address_data_latency_max_changed = 0;
    reg stats_read_address_data_latency_mean_changed = 0;
    reg stats_read_address_address_latency_inst_changed = 0;
    reg stats_read_address_address_latency_sw_changed = 0;
    reg stats_read_address_address_latency_min_changed = 0;
    reg stats_read_address_address_latency_max_changed = 0;
    reg stats_read_address_address_latency_mean_changed = 0;
    reg config_stats_write_latency_step_changed = 0;
    reg config_stats_write_latency_multiple_changed = 0;
    reg stats_write_latency_sw_updated_changed = 0;
    reg stats_write_address_data_latency_inst_changed = 0;
    reg stats_write_address_data_latency_sw_changed = 0;
    reg stats_write_address_data_latency_min_changed = 0;
    reg stats_write_address_data_latency_max_changed = 0;
    reg stats_write_address_data_latency_mean_changed = 0;
    reg stats_write_data_response_latency_inst_changed = 0;
    reg stats_write_data_response_latency_sw_changed = 0;
    reg stats_write_data_response_latency_min_changed = 0;
    reg stats_write_data_response_latency_max_changed = 0;
    reg stats_write_data_response_latency_mean_changed = 0;
    reg stats_write_address_address_latency_inst_changed = 0;
    reg stats_write_address_address_latency_sw_changed = 0;
    reg stats_write_address_address_latency_min_changed = 0;
    reg stats_write_address_address_latency_max_changed = 0;
    reg stats_write_address_address_latency_mean_changed = 0;
    reg config_stats_read_address_waits_step_changed = 0;
    reg config_stats_read_address_waits_multiple_changed = 0;
    reg stats_read_address_waits_inst_changed = 0;
    reg stats_read_address_waits_sw_changed = 0;
    reg stats_read_address_waits_sw_updated_changed = 0;
    reg stats_read_address_waits_min_changed = 0;
    reg stats_read_address_waits_max_changed = 0;
    reg stats_read_address_waits_mean_changed = 0;
    reg config_stats_read_data_waits_step_changed = 0;
    reg config_stats_read_data_waits_multiple_changed = 0;
    reg stats_read_data_waits_inst_changed = 0;
    reg stats_read_data_waits_sw_changed = 0;
    reg stats_read_data_waits_sw_updated_changed = 0;
    reg stats_read_data_waits_min_changed = 0;
    reg stats_read_data_waits_max_changed = 0;
    reg stats_read_data_waits_mean_changed = 0;
    reg config_stats_write_address_waits_step_changed = 0;
    reg config_stats_write_address_waits_multiple_changed = 0;
    reg stats_write_address_waits_inst_changed = 0;
    reg stats_write_address_waits_sw_changed = 0;
    reg stats_write_address_waits_sw_updated_changed = 0;
    reg stats_write_address_waits_min_changed = 0;
    reg stats_write_address_waits_max_changed = 0;
    reg stats_write_address_waits_mean_changed = 0;
    reg config_stats_write_data_waits_step_changed = 0;
    reg config_stats_write_data_waits_multiple_changed = 0;
    reg stats_write_data_waits_inst_changed = 0;
    reg stats_write_data_waits_sw_changed = 0;
    reg stats_write_data_waits_sw_updated_changed = 0;
    reg stats_write_data_waits_min_changed = 0;
    reg stats_write_data_waits_max_changed = 0;
    reg stats_write_data_waits_mean_changed = 0;
    reg config_stats_write_response_waits_step_changed = 0;
    reg config_stats_write_response_waits_multiple_changed = 0;
    reg stats_write_response_waits_inst_changed = 0;
    reg stats_write_response_waits_sw_changed = 0;
    reg stats_write_response_waits_sw_updated_changed = 0;
    reg stats_write_response_waits_min_changed = 0;
    reg stats_write_response_waits_max_changed = 0;
    reg stats_write_response_waits_mean_changed = 0;
    reg stats_rw_transaction_last_duration_changed = 0;
    reg stats_AXI_read_last_duration_changed = 0;
    reg stats_AXI_write_last_duration_changed = 0;
    reg stats_read_addr_channel_phase_last_duration_changed = 0;
    reg stats_read_data_burst_last_duration_changed = 0;
    reg stats_read_channel_phase_last_duration_changed = 0;
    reg stats_write_addr_channel_phase_last_duration_changed = 0;
    reg stats_write_data_burst_last_duration_changed = 0;
    reg stats_write_channel_phase_last_duration_changed = 0;
    reg stats_write_resp_channel_phase_last_duration_changed = 0;
    // Timeless transaction monitor
    reg timeless_trans_control= 0;

    // SV wire change monitors

    always @( ACLK or posedge _check_t0_values )
    begin
        axi_set_ACLK_from_SystemVerilog(ACLK); // DPI call to imported task
    end

    always @( ARESETn or posedge _check_t0_values )
    begin
        axi_set_ARESETn_from_SystemVerilog(ARESETn); // DPI call to imported task
    end

    always @( AWVALID or posedge _check_t0_values )
    begin
        axi_set_AWVALID_from_SystemVerilog(AWVALID); // DPI call to imported task
    end

    always @( AWADDR or posedge _check_t0_values )
    begin
        axi_set_AWADDR_from_SystemVerilog(AWADDR); // DPI call to imported task
    end

    always @( AWLEN or posedge _check_t0_values )
    begin
        axi_set_AWLEN_from_SystemVerilog(AWLEN); // DPI call to imported task
    end

    always @( AWSIZE or posedge _check_t0_values )
    begin
        axi_set_AWSIZE_from_SystemVerilog(AWSIZE); // DPI call to imported task
    end

    always @( AWBURST or posedge _check_t0_values )
    begin
        axi_set_AWBURST_from_SystemVerilog(AWBURST); // DPI call to imported task
    end

    always @( AWLOCK or posedge _check_t0_values )
    begin
        axi_set_AWLOCK_from_SystemVerilog(AWLOCK); // DPI call to imported task
    end

    always @( AWCACHE or posedge _check_t0_values )
    begin
        axi_set_AWCACHE_from_SystemVerilog(AWCACHE); // DPI call to imported task
    end

    always @( AWPROT or posedge _check_t0_values )
    begin
        axi_set_AWPROT_from_SystemVerilog(AWPROT); // DPI call to imported task
    end

    always @( AWID or posedge _check_t0_values )
    begin
        axi_set_AWID_from_SystemVerilog(AWID); // DPI call to imported task
    end

    always @( AWREADY or posedge _check_t0_values )
    begin
        axi_set_AWREADY_from_SystemVerilog(AWREADY); // DPI call to imported task
    end

    always @( AWUSER or posedge _check_t0_values )
    begin
        axi_set_AWUSER_from_SystemVerilog(AWUSER); // DPI call to imported task
    end

    always @( ARVALID or posedge _check_t0_values )
    begin
        axi_set_ARVALID_from_SystemVerilog(ARVALID); // DPI call to imported task
    end

    always @( ARADDR or posedge _check_t0_values )
    begin
        axi_set_ARADDR_from_SystemVerilog(ARADDR); // DPI call to imported task
    end

    always @( ARLEN or posedge _check_t0_values )
    begin
        axi_set_ARLEN_from_SystemVerilog(ARLEN); // DPI call to imported task
    end

    always @( ARSIZE or posedge _check_t0_values )
    begin
        axi_set_ARSIZE_from_SystemVerilog(ARSIZE); // DPI call to imported task
    end

    always @( ARBURST or posedge _check_t0_values )
    begin
        axi_set_ARBURST_from_SystemVerilog(ARBURST); // DPI call to imported task
    end

    always @( ARLOCK or posedge _check_t0_values )
    begin
        axi_set_ARLOCK_from_SystemVerilog(ARLOCK); // DPI call to imported task
    end

    always @( ARCACHE or posedge _check_t0_values )
    begin
        axi_set_ARCACHE_from_SystemVerilog(ARCACHE); // DPI call to imported task
    end

    always @( ARPROT or posedge _check_t0_values )
    begin
        axi_set_ARPROT_from_SystemVerilog(ARPROT); // DPI call to imported task
    end

    always @( ARID or posedge _check_t0_values )
    begin
        axi_set_ARID_from_SystemVerilog(ARID); // DPI call to imported task
    end

    always @( ARREADY or posedge _check_t0_values )
    begin
        axi_set_ARREADY_from_SystemVerilog(ARREADY); // DPI call to imported task
    end

    always @( ARUSER or posedge _check_t0_values )
    begin
        axi_set_ARUSER_from_SystemVerilog(ARUSER); // DPI call to imported task
    end

    always @( RVALID or posedge _check_t0_values )
    begin
        axi_set_RVALID_from_SystemVerilog(RVALID); // DPI call to imported task
    end

    always @( RLAST or posedge _check_t0_values )
    begin
        axi_set_RLAST_from_SystemVerilog(RLAST); // DPI call to imported task
    end

    always @( RDATA or posedge _check_t0_values )
    begin
        axi_set_RDATA_from_SystemVerilog(RDATA); // DPI call to imported task
    end

    always @( RRESP or posedge _check_t0_values )
    begin
        axi_set_RRESP_from_SystemVerilog(RRESP); // DPI call to imported task
    end

    always @( RID or posedge _check_t0_values )
    begin
        axi_set_RID_from_SystemVerilog(RID); // DPI call to imported task
    end

    always @( RREADY or posedge _check_t0_values )
    begin
        axi_set_RREADY_from_SystemVerilog(RREADY); // DPI call to imported task
    end

    always @( RUSER or posedge _check_t0_values )
    begin
        axi_set_RUSER_from_SystemVerilog(RUSER); // DPI call to imported task
    end

    always @( WVALID or posedge _check_t0_values )
    begin
        axi_set_WVALID_from_SystemVerilog(WVALID); // DPI call to imported task
    end

    always @( WLAST or posedge _check_t0_values )
    begin
        axi_set_WLAST_from_SystemVerilog(WLAST); // DPI call to imported task
    end

    always @( WDATA or posedge _check_t0_values )
    begin
        axi_set_WDATA_from_SystemVerilog(WDATA); // DPI call to imported task
    end

    always @( WSTRB or posedge _check_t0_values )
    begin
        axi_set_WSTRB_from_SystemVerilog(WSTRB); // DPI call to imported task
    end

    always @( WID or posedge _check_t0_values )
    begin
        axi_set_WID_from_SystemVerilog(WID); // DPI call to imported task
    end

    always @( WREADY or posedge _check_t0_values )
    begin
        axi_set_WREADY_from_SystemVerilog(WREADY); // DPI call to imported task
    end

    always @( WUSER or posedge _check_t0_values )
    begin
        axi_set_WUSER_from_SystemVerilog(WUSER); // DPI call to imported task
    end

    always @( BVALID or posedge _check_t0_values )
    begin
        axi_set_BVALID_from_SystemVerilog(BVALID); // DPI call to imported task
    end

    always @( BRESP or posedge _check_t0_values )
    begin
        axi_set_BRESP_from_SystemVerilog(BRESP); // DPI call to imported task
    end

    always @( BID or posedge _check_t0_values )
    begin
        axi_set_BID_from_SystemVerilog(BID); // DPI call to imported task
    end

    always @( BREADY or posedge _check_t0_values )
    begin
        axi_set_BREADY_from_SystemVerilog(BREADY); // DPI call to imported task
    end

    always @( BUSER or posedge _check_t0_values )
    begin
        axi_set_BUSER_from_SystemVerilog(BUSER); // DPI call to imported task
    end


    // CY wire and variable changed flag monitors

    always @(posedge ACLK_changed or posedge _check_t0_values )
    begin
        while (ACLK_changed == 1'b1)
        begin
            axi_get_ACLK_into_SystemVerilog(  ); // DPI call to imported task
            ACLK_changed = 1'b0;
            #0 if ( ACLK !== internal_ACLK )
            begin
                axi_set_ACLK_from_SystemVerilog( ACLK );
            end
        end
    end

    always @(posedge ARESETn_changed or posedge _check_t0_values )
    begin
        while (ARESETn_changed == 1'b1)
        begin
            axi_get_ARESETn_into_SystemVerilog(  ); // DPI call to imported task
            ARESETn_changed = 1'b0;
            #0 if ( ARESETn !== internal_ARESETn )
            begin
                axi_set_ARESETn_from_SystemVerilog( ARESETn );
            end
        end
    end

    always @(posedge AWVALID_changed or posedge _check_t0_values )
    begin
        while (AWVALID_changed == 1'b1)
        begin
            axi_get_AWVALID_into_SystemVerilog(  ); // DPI call to imported task
            AWVALID_changed = 1'b0;
            #0 if ( AWVALID !== internal_AWVALID )
            begin
                axi_set_AWVALID_from_SystemVerilog( AWVALID );
            end
        end
    end

    always @(posedge AWADDR_changed or posedge _check_t0_values )
    begin
        while (AWADDR_changed == 1'b1)
        begin
            axi_get_AWADDR_into_SystemVerilog(  ); // DPI call to imported task
            AWADDR_changed = 1'b0;
            #0 if ( AWADDR !== internal_AWADDR )
            begin
                axi_set_AWADDR_from_SystemVerilog( AWADDR );
            end
        end
    end

    always @(posedge AWLEN_changed or posedge _check_t0_values )
    begin
        while (AWLEN_changed == 1'b1)
        begin
            axi_get_AWLEN_into_SystemVerilog(  ); // DPI call to imported task
            AWLEN_changed = 1'b0;
            #0 if ( AWLEN !== internal_AWLEN )
            begin
                axi_set_AWLEN_from_SystemVerilog( AWLEN );
            end
        end
    end

    always @(posedge AWSIZE_changed or posedge _check_t0_values )
    begin
        while (AWSIZE_changed == 1'b1)
        begin
            axi_get_AWSIZE_into_SystemVerilog(  ); // DPI call to imported task
            AWSIZE_changed = 1'b0;
            #0 if ( AWSIZE !== internal_AWSIZE )
            begin
                axi_set_AWSIZE_from_SystemVerilog( AWSIZE );
            end
        end
    end

    always @(posedge AWBURST_changed or posedge _check_t0_values )
    begin
        while (AWBURST_changed == 1'b1)
        begin
            axi_get_AWBURST_into_SystemVerilog(  ); // DPI call to imported task
            AWBURST_changed = 1'b0;
            #0 if ( AWBURST !== internal_AWBURST )
            begin
                axi_set_AWBURST_from_SystemVerilog( AWBURST );
            end
        end
    end

    always @(posedge AWLOCK_changed or posedge _check_t0_values )
    begin
        while (AWLOCK_changed == 1'b1)
        begin
            axi_get_AWLOCK_into_SystemVerilog(  ); // DPI call to imported task
            AWLOCK_changed = 1'b0;
            #0 if ( AWLOCK !== internal_AWLOCK )
            begin
                axi_set_AWLOCK_from_SystemVerilog( AWLOCK );
            end
        end
    end

    always @(posedge AWCACHE_changed or posedge _check_t0_values )
    begin
        while (AWCACHE_changed == 1'b1)
        begin
            axi_get_AWCACHE_into_SystemVerilog(  ); // DPI call to imported task
            AWCACHE_changed = 1'b0;
            #0 if ( AWCACHE !== internal_AWCACHE )
            begin
                axi_set_AWCACHE_from_SystemVerilog( AWCACHE );
            end
        end
    end

    always @(posedge AWPROT_changed or posedge _check_t0_values )
    begin
        while (AWPROT_changed == 1'b1)
        begin
            axi_get_AWPROT_into_SystemVerilog(  ); // DPI call to imported task
            AWPROT_changed = 1'b0;
            #0 if ( AWPROT !== internal_AWPROT )
            begin
                axi_set_AWPROT_from_SystemVerilog( AWPROT );
            end
        end
    end

    always @(posedge AWID_changed or posedge _check_t0_values )
    begin
        while (AWID_changed == 1'b1)
        begin
            axi_get_AWID_into_SystemVerilog(  ); // DPI call to imported task
            AWID_changed = 1'b0;
            #0 if ( AWID !== internal_AWID )
            begin
                axi_set_AWID_from_SystemVerilog( AWID );
            end
        end
    end

    always @(posedge AWREADY_changed or posedge _check_t0_values )
    begin
        while (AWREADY_changed == 1'b1)
        begin
            axi_get_AWREADY_into_SystemVerilog(  ); // DPI call to imported task
            AWREADY_changed = 1'b0;
            #0 if ( AWREADY !== internal_AWREADY )
            begin
                axi_set_AWREADY_from_SystemVerilog( AWREADY );
            end
        end
    end

    always @(posedge AWUSER_changed or posedge _check_t0_values )
    begin
        while (AWUSER_changed == 1'b1)
        begin
            axi_get_AWUSER_into_SystemVerilog(  ); // DPI call to imported task
            AWUSER_changed = 1'b0;
            #0 if ( AWUSER !== internal_AWUSER )
            begin
                axi_set_AWUSER_from_SystemVerilog( AWUSER );
            end
        end
    end

    always @(posedge ARVALID_changed or posedge _check_t0_values )
    begin
        while (ARVALID_changed == 1'b1)
        begin
            axi_get_ARVALID_into_SystemVerilog(  ); // DPI call to imported task
            ARVALID_changed = 1'b0;
            #0 if ( ARVALID !== internal_ARVALID )
            begin
                axi_set_ARVALID_from_SystemVerilog( ARVALID );
            end
        end
    end

    always @(posedge ARADDR_changed or posedge _check_t0_values )
    begin
        while (ARADDR_changed == 1'b1)
        begin
            axi_get_ARADDR_into_SystemVerilog(  ); // DPI call to imported task
            ARADDR_changed = 1'b0;
            #0 if ( ARADDR !== internal_ARADDR )
            begin
                axi_set_ARADDR_from_SystemVerilog( ARADDR );
            end
        end
    end

    always @(posedge ARLEN_changed or posedge _check_t0_values )
    begin
        while (ARLEN_changed == 1'b1)
        begin
            axi_get_ARLEN_into_SystemVerilog(  ); // DPI call to imported task
            ARLEN_changed = 1'b0;
            #0 if ( ARLEN !== internal_ARLEN )
            begin
                axi_set_ARLEN_from_SystemVerilog( ARLEN );
            end
        end
    end

    always @(posedge ARSIZE_changed or posedge _check_t0_values )
    begin
        while (ARSIZE_changed == 1'b1)
        begin
            axi_get_ARSIZE_into_SystemVerilog(  ); // DPI call to imported task
            ARSIZE_changed = 1'b0;
            #0 if ( ARSIZE !== internal_ARSIZE )
            begin
                axi_set_ARSIZE_from_SystemVerilog( ARSIZE );
            end
        end
    end

    always @(posedge ARBURST_changed or posedge _check_t0_values )
    begin
        while (ARBURST_changed == 1'b1)
        begin
            axi_get_ARBURST_into_SystemVerilog(  ); // DPI call to imported task
            ARBURST_changed = 1'b0;
            #0 if ( ARBURST !== internal_ARBURST )
            begin
                axi_set_ARBURST_from_SystemVerilog( ARBURST );
            end
        end
    end

    always @(posedge ARLOCK_changed or posedge _check_t0_values )
    begin
        while (ARLOCK_changed == 1'b1)
        begin
            axi_get_ARLOCK_into_SystemVerilog(  ); // DPI call to imported task
            ARLOCK_changed = 1'b0;
            #0 if ( ARLOCK !== internal_ARLOCK )
            begin
                axi_set_ARLOCK_from_SystemVerilog( ARLOCK );
            end
        end
    end

    always @(posedge ARCACHE_changed or posedge _check_t0_values )
    begin
        while (ARCACHE_changed == 1'b1)
        begin
            axi_get_ARCACHE_into_SystemVerilog(  ); // DPI call to imported task
            ARCACHE_changed = 1'b0;
            #0 if ( ARCACHE !== internal_ARCACHE )
            begin
                axi_set_ARCACHE_from_SystemVerilog( ARCACHE );
            end
        end
    end

    always @(posedge ARPROT_changed or posedge _check_t0_values )
    begin
        while (ARPROT_changed == 1'b1)
        begin
            axi_get_ARPROT_into_SystemVerilog(  ); // DPI call to imported task
            ARPROT_changed = 1'b0;
            #0 if ( ARPROT !== internal_ARPROT )
            begin
                axi_set_ARPROT_from_SystemVerilog( ARPROT );
            end
        end
    end

    always @(posedge ARID_changed or posedge _check_t0_values )
    begin
        while (ARID_changed == 1'b1)
        begin
            axi_get_ARID_into_SystemVerilog(  ); // DPI call to imported task
            ARID_changed = 1'b0;
            #0 if ( ARID !== internal_ARID )
            begin
                axi_set_ARID_from_SystemVerilog( ARID );
            end
        end
    end

    always @(posedge ARREADY_changed or posedge _check_t0_values )
    begin
        while (ARREADY_changed == 1'b1)
        begin
            axi_get_ARREADY_into_SystemVerilog(  ); // DPI call to imported task
            ARREADY_changed = 1'b0;
            #0 if ( ARREADY !== internal_ARREADY )
            begin
                axi_set_ARREADY_from_SystemVerilog( ARREADY );
            end
        end
    end

    always @(posedge ARUSER_changed or posedge _check_t0_values )
    begin
        while (ARUSER_changed == 1'b1)
        begin
            axi_get_ARUSER_into_SystemVerilog(  ); // DPI call to imported task
            ARUSER_changed = 1'b0;
            #0 if ( ARUSER !== internal_ARUSER )
            begin
                axi_set_ARUSER_from_SystemVerilog( ARUSER );
            end
        end
    end

    always @(posedge RVALID_changed or posedge _check_t0_values )
    begin
        while (RVALID_changed == 1'b1)
        begin
            axi_get_RVALID_into_SystemVerilog(  ); // DPI call to imported task
            RVALID_changed = 1'b0;
            #0 if ( RVALID !== internal_RVALID )
            begin
                axi_set_RVALID_from_SystemVerilog( RVALID );
            end
        end
    end

    always @(posedge RLAST_changed or posedge _check_t0_values )
    begin
        while (RLAST_changed == 1'b1)
        begin
            axi_get_RLAST_into_SystemVerilog(  ); // DPI call to imported task
            RLAST_changed = 1'b0;
            #0 if ( RLAST !== internal_RLAST )
            begin
                axi_set_RLAST_from_SystemVerilog( RLAST );
            end
        end
    end

    always @(posedge RDATA_changed or posedge _check_t0_values )
    begin
        while (RDATA_changed == 1'b1)
        begin
            axi_get_RDATA_into_SystemVerilog(  ); // DPI call to imported task
            RDATA_changed = 1'b0;
            #0 if ( RDATA !== internal_RDATA )
            begin
                axi_set_RDATA_from_SystemVerilog( RDATA );
            end
        end
    end

    always @(posedge RRESP_changed or posedge _check_t0_values )
    begin
        while (RRESP_changed == 1'b1)
        begin
            axi_get_RRESP_into_SystemVerilog(  ); // DPI call to imported task
            RRESP_changed = 1'b0;
            #0 if ( RRESP !== internal_RRESP )
            begin
                axi_set_RRESP_from_SystemVerilog( RRESP );
            end
        end
    end

    always @(posedge RID_changed or posedge _check_t0_values )
    begin
        while (RID_changed == 1'b1)
        begin
            axi_get_RID_into_SystemVerilog(  ); // DPI call to imported task
            RID_changed = 1'b0;
            #0 if ( RID !== internal_RID )
            begin
                axi_set_RID_from_SystemVerilog( RID );
            end
        end
    end

    always @(posedge RREADY_changed or posedge _check_t0_values )
    begin
        while (RREADY_changed == 1'b1)
        begin
            axi_get_RREADY_into_SystemVerilog(  ); // DPI call to imported task
            RREADY_changed = 1'b0;
            #0 if ( RREADY !== internal_RREADY )
            begin
                axi_set_RREADY_from_SystemVerilog( RREADY );
            end
        end
    end

    always @(posedge RUSER_changed or posedge _check_t0_values )
    begin
        while (RUSER_changed == 1'b1)
        begin
            axi_get_RUSER_into_SystemVerilog(  ); // DPI call to imported task
            RUSER_changed = 1'b0;
            #0 if ( RUSER !== internal_RUSER )
            begin
                axi_set_RUSER_from_SystemVerilog( RUSER );
            end
        end
    end

    always @(posedge WVALID_changed or posedge _check_t0_values )
    begin
        while (WVALID_changed == 1'b1)
        begin
            axi_get_WVALID_into_SystemVerilog(  ); // DPI call to imported task
            WVALID_changed = 1'b0;
            #0 if ( WVALID !== internal_WVALID )
            begin
                axi_set_WVALID_from_SystemVerilog( WVALID );
            end
        end
    end

    always @(posedge WLAST_changed or posedge _check_t0_values )
    begin
        while (WLAST_changed == 1'b1)
        begin
            axi_get_WLAST_into_SystemVerilog(  ); // DPI call to imported task
            WLAST_changed = 1'b0;
            #0 if ( WLAST !== internal_WLAST )
            begin
                axi_set_WLAST_from_SystemVerilog( WLAST );
            end
        end
    end

    always @(posedge WDATA_changed or posedge _check_t0_values )
    begin
        while (WDATA_changed == 1'b1)
        begin
            axi_get_WDATA_into_SystemVerilog(  ); // DPI call to imported task
            WDATA_changed = 1'b0;
            #0 if ( WDATA !== internal_WDATA )
            begin
                axi_set_WDATA_from_SystemVerilog( WDATA );
            end
        end
    end

    always @(posedge WSTRB_changed or posedge _check_t0_values )
    begin
        while (WSTRB_changed == 1'b1)
        begin
            axi_get_WSTRB_into_SystemVerilog(  ); // DPI call to imported task
            WSTRB_changed = 1'b0;
            #0 if ( WSTRB !== internal_WSTRB )
            begin
                axi_set_WSTRB_from_SystemVerilog( WSTRB );
            end
        end
    end

    always @(posedge WID_changed or posedge _check_t0_values )
    begin
        while (WID_changed == 1'b1)
        begin
            axi_get_WID_into_SystemVerilog(  ); // DPI call to imported task
            WID_changed = 1'b0;
            #0 if ( WID !== internal_WID )
            begin
                axi_set_WID_from_SystemVerilog( WID );
            end
        end
    end

    always @(posedge WREADY_changed or posedge _check_t0_values )
    begin
        while (WREADY_changed == 1'b1)
        begin
            axi_get_WREADY_into_SystemVerilog(  ); // DPI call to imported task
            WREADY_changed = 1'b0;
            #0 if ( WREADY !== internal_WREADY )
            begin
                axi_set_WREADY_from_SystemVerilog( WREADY );
            end
        end
    end

    always @(posedge WUSER_changed or posedge _check_t0_values )
    begin
        while (WUSER_changed == 1'b1)
        begin
            axi_get_WUSER_into_SystemVerilog(  ); // DPI call to imported task
            WUSER_changed = 1'b0;
            #0 if ( WUSER !== internal_WUSER )
            begin
                axi_set_WUSER_from_SystemVerilog( WUSER );
            end
        end
    end

    always @(posedge BVALID_changed or posedge _check_t0_values )
    begin
        while (BVALID_changed == 1'b1)
        begin
            axi_get_BVALID_into_SystemVerilog(  ); // DPI call to imported task
            BVALID_changed = 1'b0;
            #0 if ( BVALID !== internal_BVALID )
            begin
                axi_set_BVALID_from_SystemVerilog( BVALID );
            end
        end
    end

    always @(posedge BRESP_changed or posedge _check_t0_values )
    begin
        while (BRESP_changed == 1'b1)
        begin
            axi_get_BRESP_into_SystemVerilog(  ); // DPI call to imported task
            BRESP_changed = 1'b0;
            #0 if ( BRESP !== internal_BRESP )
            begin
                axi_set_BRESP_from_SystemVerilog( BRESP );
            end
        end
    end

    always @(posedge BID_changed or posedge _check_t0_values )
    begin
        while (BID_changed == 1'b1)
        begin
            axi_get_BID_into_SystemVerilog(  ); // DPI call to imported task
            BID_changed = 1'b0;
            #0 if ( BID !== internal_BID )
            begin
                axi_set_BID_from_SystemVerilog( BID );
            end
        end
    end

    always @(posedge BREADY_changed or posedge _check_t0_values )
    begin
        while (BREADY_changed == 1'b1)
        begin
            axi_get_BREADY_into_SystemVerilog(  ); // DPI call to imported task
            BREADY_changed = 1'b0;
            #0 if ( BREADY !== internal_BREADY )
            begin
                axi_set_BREADY_from_SystemVerilog( BREADY );
            end
        end
    end

    always @(posedge BUSER_changed or posedge _check_t0_values )
    begin
        while (BUSER_changed == 1'b1)
        begin
            axi_get_BUSER_into_SystemVerilog(  ); // DPI call to imported task
            BUSER_changed = 1'b0;
            #0 if ( BUSER !== internal_BUSER )
            begin
                axi_set_BUSER_from_SystemVerilog( BUSER );
            end
        end
    end

    always @(posedge config_clk_init_value_changed or posedge _check_t0_values )
    begin
        if (config_clk_init_value_changed == 1'b1)
        begin
            axi_get_config_clk_init_value_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_init_value_changed = 1'b0;
        end
    end

    always @(posedge config_clk_phase_shift_changed or posedge _check_t0_values )
    begin
        if (config_clk_phase_shift_changed == 1'b1)
        begin
            axi_get_config_clk_phase_shift_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_phase_shift_changed = 1'b0;
        end
    end

    always @(posedge config_clk_1st_time_changed or posedge _check_t0_values )
    begin
        if (config_clk_1st_time_changed == 1'b1)
        begin
            axi_get_config_clk_1st_time_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_1st_time_changed = 1'b0;
        end
    end

    always @(posedge config_clk_2nd_time_changed or posedge _check_t0_values )
    begin
        if (config_clk_2nd_time_changed == 1'b1)
        begin
            axi_get_config_clk_2nd_time_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_2nd_time_changed = 1'b0;
        end
    end

    always @(posedge config_setup_time_changed or posedge _check_t0_values )
    begin
        if (config_setup_time_changed == 1'b1)
        begin
            axi_get_config_setup_time_into_SystemVerilog(  ); // DPI call to imported task
            config_setup_time_changed = 1'b0;
        end
    end

    always @(posedge config_hold_time_changed or posedge _check_t0_values )
    begin
        if (config_hold_time_changed == 1'b1)
        begin
            axi_get_config_hold_time_into_SystemVerilog(  ); // DPI call to imported task
            config_hold_time_changed = 1'b0;
        end
    end

    always @(posedge config_max_transaction_time_factor_changed or posedge _check_t0_values )
    begin
        if (config_max_transaction_time_factor_changed == 1'b1)
        begin
            axi_get_config_max_transaction_time_factor_into_SystemVerilog(  ); // DPI call to imported task
            config_max_transaction_time_factor_changed = 1'b0;
        end
    end

    always @(posedge config_timeout_max_data_transfer_changed or posedge _check_t0_values )
    begin
        if (config_timeout_max_data_transfer_changed == 1'b1)
        begin
            axi_get_config_timeout_max_data_transfer_into_SystemVerilog(  ); // DPI call to imported task
            config_timeout_max_data_transfer_changed = 1'b0;
        end
    end

    always @(posedge config_burst_timeout_factor_changed or posedge _check_t0_values )
    begin
        if (config_burst_timeout_factor_changed == 1'b1)
        begin
            axi_get_config_burst_timeout_factor_into_SystemVerilog(  ); // DPI call to imported task
            config_burst_timeout_factor_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_AWVALID_assertion_to_AWREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_AWVALID_assertion_to_AWREADY_changed == 1'b1)
        begin
            axi_get_config_max_latency_AWVALID_assertion_to_AWREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_AWVALID_assertion_to_AWREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_ARVALID_assertion_to_ARREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_ARVALID_assertion_to_ARREADY_changed == 1'b1)
        begin
            axi_get_config_max_latency_ARVALID_assertion_to_ARREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_ARVALID_assertion_to_ARREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_RVALID_assertion_to_RREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_RVALID_assertion_to_RREADY_changed == 1'b1)
        begin
            axi_get_config_max_latency_RVALID_assertion_to_RREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_RVALID_assertion_to_RREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_BVALID_assertion_to_BREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_BVALID_assertion_to_BREADY_changed == 1'b1)
        begin
            axi_get_config_max_latency_BVALID_assertion_to_BREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_BVALID_assertion_to_BREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_WVALID_assertion_to_WREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_WVALID_assertion_to_WREADY_changed == 1'b1)
        begin
            axi_get_config_max_latency_WVALID_assertion_to_WREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_WVALID_assertion_to_WREADY_changed = 1'b0;
        end
    end

    always @(posedge config_write_ctrl_first_ratio_changed or posedge _check_t0_values )
    begin
        if (config_write_ctrl_first_ratio_changed == 1'b1)
        begin
            axi_get_config_write_ctrl_first_ratio_into_SystemVerilog(  ); // DPI call to imported task
            config_write_ctrl_first_ratio_changed = 1'b0;
        end
    end

    always @(posedge config_write_data_first_ratio_changed or posedge _check_t0_values )
    begin
        if (config_write_data_first_ratio_changed == 1'b1)
        begin
            axi_get_config_write_data_first_ratio_into_SystemVerilog(  ); // DPI call to imported task
            config_write_data_first_ratio_changed = 1'b0;
        end
    end

    always @(posedge config_write_ctrl_to_data_mintime_changed or posedge _check_t0_values )
    begin
        if (config_write_ctrl_to_data_mintime_changed == 1'b1)
        begin
            axi_get_config_write_ctrl_to_data_mintime_into_SystemVerilog(  ); // DPI call to imported task
            config_write_ctrl_to_data_mintime_changed = 1'b0;
        end
    end

    always @(posedge config_write_data_to_ctrl_mintime_changed or posedge _check_t0_values )
    begin
        if (config_write_data_to_ctrl_mintime_changed == 1'b1)
        begin
            axi_get_config_write_data_to_ctrl_mintime_into_SystemVerilog(  ); // DPI call to imported task
            config_write_data_to_ctrl_mintime_changed = 1'b0;
        end
    end

    always @(posedge config_master_write_delay_changed or posedge _check_t0_values )
    begin
        if (config_master_write_delay_changed == 1'b1)
        begin
            axi_get_config_master_write_delay_into_SystemVerilog(  ); // DPI call to imported task
            config_master_write_delay_changed = 1'b0;
        end
    end

    always @(posedge config_reset_low_clocks_changed or posedge _check_t0_values )
    begin
        if (config_reset_low_clocks_changed == 1'b1)
        begin
            axi_get_config_reset_low_clocks_into_SystemVerilog(  ); // DPI call to imported task
            config_reset_low_clocks_changed = 1'b0;
        end
    end

    always @(posedge config_reset_hold_time_changed or posedge _check_t0_values )
    begin
        if (config_reset_hold_time_changed == 1'b1)
        begin
            axi_get_config_reset_hold_time_into_SystemVerilog(  ); // DPI call to imported task
            config_reset_hold_time_changed = 1'b0;
        end
    end

    always @(posedge config_protect_ready_changed or posedge _check_t0_values )
    begin
        if (config_protect_ready_changed == 1'b1)
        begin
            axi_get_config_protect_ready_into_SystemVerilog(  ); // DPI call to imported task
            config_protect_ready_changed = 1'b0;
        end
    end

    always @(posedge config_enable_user_sideband_changed or posedge _check_t0_values )
    begin
        if (config_enable_user_sideband_changed == 1'b1)
        begin
            axi_get_config_enable_user_sideband_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_user_sideband_changed = 1'b0;
        end
    end

    always @(posedge config_extended_length_enable_changed or posedge _check_t0_values )
    begin
        if (config_extended_length_enable_changed == 1'b1)
        begin
            axi_get_config_extended_length_enable_into_SystemVerilog(  ); // DPI call to imported task
            config_extended_length_enable_changed = 1'b0;
        end
    end

    always @(posedge config_enable_burst_reserved_value_changed or posedge _check_t0_values )
    begin
        if (config_enable_burst_reserved_value_changed == 1'b1)
        begin
            axi_get_config_enable_burst_reserved_value_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_burst_reserved_value_changed = 1'b0;
        end
    end

    always @(posedge config_enable_lock_reserved_value_changed or posedge _check_t0_values )
    begin
        if (config_enable_lock_reserved_value_changed == 1'b1)
        begin
            axi_get_config_enable_lock_reserved_value_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_lock_reserved_value_changed = 1'b0;
        end
    end

    always @(posedge config_enable_cache_reserved_value_changed or posedge _check_t0_values )
    begin
        if (config_enable_cache_reserved_value_changed == 1'b1)
        begin
            axi_get_config_enable_cache_reserved_value_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_cache_reserved_value_changed = 1'b0;
        end
    end

    always @(posedge config_enable_all_assertions_changed or posedge _check_t0_values )
    begin
        if (config_enable_all_assertions_changed == 1'b1)
        begin
            axi_get_config_enable_all_assertions_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_all_assertions_changed = 1'b0;
        end
    end

    always @(posedge config_enable_assertion_changed or posedge _check_t0_values )
    begin
        if (config_enable_assertion_changed == 1'b1)
        begin
            axi_get_config_enable_assertion_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_assertion_changed = 1'b0;
        end
    end

    always @(posedge config_enable_error_changed or posedge _check_t0_values )
    begin
        if (config_enable_error_changed == 1'b1)
        begin
            axi_get_config_enable_error_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_error_changed = 1'b0;
        end
    end

    always @(posedge config_enable_errors_changed or posedge _check_t0_values )
    begin
        if (config_enable_errors_changed == 1'b1)
        begin
            axi_get_config_enable_errors_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_errors_changed = 1'b0;
        end
    end

    always @(posedge config_enable_all_assertion_errors_changed or posedge _check_t0_values )
    begin
        if (config_enable_all_assertion_errors_changed == 1'b1)
        begin
            axi_get_config_enable_all_assertion_errors_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_all_assertion_errors_changed = 1'b0;
        end
    end

    always @(posedge config_abstraction_level_changed or posedge _check_t0_values )
    begin
        if (config_abstraction_level_changed == 1'b1)
        begin
            axi_get_config_abstraction_level_into_SystemVerilog(  ); // DPI call to imported task
            config_abstraction_level_changed = 1'b0;
        end
    end

    always @(posedge config_slave_start_addr_changed or posedge _check_t0_values )
    begin
        if (config_slave_start_addr_changed == 1'b1)
        begin
            axi_get_config_slave_start_addr_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_start_addr_changed = 1'b0;
        end
    end

    always @(posedge config_slave_end_addr_changed or posedge _check_t0_values )
    begin
        if (config_slave_end_addr_changed == 1'b1)
        begin
            axi_get_config_slave_end_addr_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_end_addr_changed = 1'b0;
        end
    end

    always @(posedge config_enable_slave_addr_range_in_bfm_changed or posedge _check_t0_values )
    begin
        if (config_enable_slave_addr_range_in_bfm_changed == 1'b1)
        begin
            axi_get_config_enable_slave_addr_range_in_bfm_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_slave_addr_range_in_bfm_changed = 1'b0;
        end
    end

    always @(posedge config_read_data_reordering_depth_changed or posedge _check_t0_values )
    begin
        if (config_read_data_reordering_depth_changed == 1'b1)
        begin
            axi_get_config_read_data_reordering_depth_into_SystemVerilog(  ); // DPI call to imported task
            config_read_data_reordering_depth_changed = 1'b0;
        end
    end

    always @(posedge config_enable_read_data_reordering_depth_in_bfm_changed or posedge _check_t0_values )
    begin
        if (config_enable_read_data_reordering_depth_in_bfm_changed == 1'b1)
        begin
            axi_get_config_enable_read_data_reordering_depth_in_bfm_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_read_data_reordering_depth_in_bfm_changed = 1'b0;
        end
    end

    always @(posedge config_awid_wid_mismatch_changed or posedge _check_t0_values )
    begin
        if (config_awid_wid_mismatch_changed == 1'b1)
        begin
            axi_get_config_awid_wid_mismatch_into_SystemVerilog(  ); // DPI call to imported task
            config_awid_wid_mismatch_changed = 1'b0;
        end
    end

    always @(posedge config_length_last_mismatch_error_changed or posedge _check_t0_values )
    begin
        if (config_length_last_mismatch_error_changed == 1'b1)
        begin
            axi_get_config_length_last_mismatch_error_into_SystemVerilog(  ); // DPI call to imported task
            config_length_last_mismatch_error_changed = 1'b0;
        end
    end

    always @(posedge config_master_error_position_changed or posedge _check_t0_values )
    begin
        if (config_master_error_position_changed == 1'b1)
        begin
            axi_get_config_master_error_position_into_SystemVerilog(  ); // DPI call to imported task
            config_master_error_position_changed = 1'b0;
        end
    end

    always @(posedge dummy_var_changed or posedge _check_t0_values )
    begin
        if (dummy_var_changed == 1'b1)
        begin
            axi_get_dummy_var_into_SystemVerilog(  ); // DPI call to imported task
            dummy_var_changed = 1'b0;
        end
    end

    always @(posedge config_wlast_length_changed or posedge _check_t0_values )
    begin
        if (config_wlast_length_changed == 1'b1)
        begin
            axi_get_config_wlast_length_into_SystemVerilog(  ); // DPI call to imported task
            config_wlast_length_changed = 1'b0;
        end
    end

    always @(posedge config_wid_for_awid_not_matching_changed or posedge _check_t0_values )
    begin
        if (config_wid_for_awid_not_matching_changed == 1'b1)
        begin
            axi_get_config_wid_for_awid_not_matching_into_SystemVerilog(  ); // DPI call to imported task
            config_wid_for_awid_not_matching_changed = 1'b0;
        end
    end

    always @(posedge config_support_exclusive_access_changed or posedge _check_t0_values )
    begin
        if (config_support_exclusive_access_changed == 1'b1)
        begin
            axi_get_config_support_exclusive_access_into_SystemVerilog(  ); // DPI call to imported task
            config_support_exclusive_access_changed = 1'b0;
        end
    end

    always @(posedge config_write_data_interleaving_depth_changed or posedge _check_t0_values )
    begin
        if (config_write_data_interleaving_depth_changed == 1'b1)
        begin
            axi_get_config_write_data_interleaving_depth_into_SystemVerilog(  ); // DPI call to imported task
            config_write_data_interleaving_depth_changed = 1'b0;
        end
    end

    always @(posedge status_master_error_changed or posedge _check_t0_values )
    begin
        if (status_master_error_changed == 1'b1)
        begin
            axi_get_status_master_error_into_SystemVerilog(  ); // DPI call to imported task
            status_master_error_changed = 1'b0;
        end
    end

    always @(posedge status_num_reads_waiting_for_resp_changed or posedge _check_t0_values )
    begin
        if (status_num_reads_waiting_for_resp_changed == 1'b1)
        begin
            axi_get_status_num_reads_waiting_for_resp_into_SystemVerilog(  ); // DPI call to imported task
            status_num_reads_waiting_for_resp_changed = 1'b0;
        end
    end

    always @(posedge status_num_writes_waiting_for_response_changed or posedge _check_t0_values )
    begin
        if (status_num_writes_waiting_for_response_changed == 1'b1)
        begin
            axi_get_status_num_writes_waiting_for_response_into_SystemVerilog(  ); // DPI call to imported task
            status_num_writes_waiting_for_response_changed = 1'b0;
        end
    end

    always @(posedge check_total_num_wdata_outstanding_changed or posedge _check_t0_values )
    begin
        if (check_total_num_wdata_outstanding_changed == 1'b1)
        begin
            axi_get_check_total_num_wdata_outstanding_into_SystemVerilog(  ); // DPI call to imported task
            check_total_num_wdata_outstanding_changed = 1'b0;
        end
    end

    always @(posedge total_num_wdata_outstanding_changed or posedge _check_t0_values )
    begin
        if (total_num_wdata_outstanding_changed == 1'b1)
        begin
            axi_get_total_num_wdata_outstanding_into_SystemVerilog(  ); // DPI call to imported task
            total_num_wdata_outstanding_changed = 1'b0;
        end
    end

    always @(posedge check_max_num_wdata_outstanding_per_id_changed or posedge _check_t0_values )
    begin
        if (check_max_num_wdata_outstanding_per_id_changed == 1'b1)
        begin
            axi_get_check_max_num_wdata_outstanding_per_id_into_SystemVerilog(  ); // DPI call to imported task
            check_max_num_wdata_outstanding_per_id_changed = 1'b0;
        end
    end

    always @(posedge max_num_wdata_outstanding_per_id_changed or posedge _check_t0_values )
    begin
        if (max_num_wdata_outstanding_per_id_changed == 1'b1)
        begin
            axi_get_max_num_wdata_outstanding_per_id_into_SystemVerilog(  ); // DPI call to imported task
            max_num_wdata_outstanding_per_id_changed = 1'b0;
        end
    end

    always @(posedge check_max_num_waddr_outstanding_per_id_changed or posedge _check_t0_values )
    begin
        if (check_max_num_waddr_outstanding_per_id_changed == 1'b1)
        begin
            axi_get_check_max_num_waddr_outstanding_per_id_into_SystemVerilog(  ); // DPI call to imported task
            check_max_num_waddr_outstanding_per_id_changed = 1'b0;
        end
    end

    always @(posedge max_num_waddr_outstanding_per_id_changed or posedge _check_t0_values )
    begin
        if (max_num_waddr_outstanding_per_id_changed == 1'b1)
        begin
            axi_get_max_num_waddr_outstanding_per_id_into_SystemVerilog(  ); // DPI call to imported task
            max_num_waddr_outstanding_per_id_changed = 1'b0;
        end
    end

    always @(posedge check_total_num_waddr_outstanding_changed or posedge _check_t0_values )
    begin
        if (check_total_num_waddr_outstanding_changed == 1'b1)
        begin
            axi_get_check_total_num_waddr_outstanding_into_SystemVerilog(  ); // DPI call to imported task
            check_total_num_waddr_outstanding_changed = 1'b0;
        end
    end

    always @(posedge total_num_waddr_outstanding_changed or posedge _check_t0_values )
    begin
        if (total_num_waddr_outstanding_changed == 1'b1)
        begin
            axi_get_total_num_waddr_outstanding_into_SystemVerilog(  ); // DPI call to imported task
            total_num_waddr_outstanding_changed = 1'b0;
        end
    end

    always @(posedge status_outstanding_num_for_waddr_changed or posedge _check_t0_values )
    begin
        if (status_outstanding_num_for_waddr_changed == 1'b1)
        begin
            axi_get_status_outstanding_num_for_waddr_into_SystemVerilog(  ); // DPI call to imported task
            status_outstanding_num_for_waddr_changed = 1'b0;
        end
    end

    always @(posedge start_finding_outstanding_waddr_changed or posedge _check_t0_values )
    begin
        if (start_finding_outstanding_waddr_changed == 1'b1)
        begin
            axi_get_start_finding_outstanding_waddr_into_SystemVerilog(  ); // DPI call to imported task
            start_finding_outstanding_waddr_changed = 1'b0;
        end
    end

    always @(posedge status_outstanding_num_for_wdata_changed or posedge _check_t0_values )
    begin
        if (status_outstanding_num_for_wdata_changed == 1'b1)
        begin
            axi_get_status_outstanding_num_for_wdata_into_SystemVerilog(  ); // DPI call to imported task
            status_outstanding_num_for_wdata_changed = 1'b0;
        end
    end

    always @(posedge start_finding_outstanding_wdata_changed or posedge _check_t0_values )
    begin
        if (start_finding_outstanding_wdata_changed == 1'b1)
        begin
            axi_get_start_finding_outstanding_wdata_into_SystemVerilog(  ); // DPI call to imported task
            start_finding_outstanding_wdata_changed = 1'b0;
        end
    end

    always @(posedge find_waddr_outstanding_for_wid_changed or posedge _check_t0_values )
    begin
        if (find_waddr_outstanding_for_wid_changed == 1'b1)
        begin
            axi_get_find_waddr_outstanding_for_wid_into_SystemVerilog(  ); // DPI call to imported task
            find_waddr_outstanding_for_wid_changed = 1'b0;
        end
    end

    always @(posedge find_wdata_outstanding_for_wid_changed or posedge _check_t0_values )
    begin
        if (find_wdata_outstanding_for_wid_changed == 1'b1)
        begin
            axi_get_find_wdata_outstanding_for_wid_into_SystemVerilog(  ); // DPI call to imported task
            find_wdata_outstanding_for_wid_changed = 1'b0;
        end
    end

    always @(posedge change_in_wdata_outstanding_per_id_changed or posedge _check_t0_values )
    begin
        if (change_in_wdata_outstanding_per_id_changed == 1'b1)
        begin
            axi_get_change_in_wdata_outstanding_per_id_into_SystemVerilog(  ); // DPI call to imported task
            change_in_wdata_outstanding_per_id_changed = 1'b0;
        end
    end

    always @(posedge start_finding_change_in_wdata_changed or posedge _check_t0_values )
    begin
        if (start_finding_change_in_wdata_changed == 1'b1)
        begin
            axi_get_start_finding_change_in_wdata_into_SystemVerilog(  ); // DPI call to imported task
            start_finding_change_in_wdata_changed = 1'b0;
        end
    end

    always @(posedge find_change_in_wdata_outstanding_for_wid_changed or posedge _check_t0_values )
    begin
        if (find_change_in_wdata_outstanding_for_wid_changed == 1'b1)
        begin
            axi_get_find_change_in_wdata_outstanding_for_wid_into_SystemVerilog(  ); // DPI call to imported task
            find_change_in_wdata_outstanding_for_wid_changed = 1'b0;
        end
    end

    always @(posedge config_max_outstanding_wr_changed or posedge _check_t0_values )
    begin
        if (config_max_outstanding_wr_changed == 1'b1)
        begin
            axi_get_config_max_outstanding_wr_into_SystemVerilog(  ); // DPI call to imported task
            config_max_outstanding_wr_changed = 1'b0;
        end
    end

    always @(posedge config_max_outstanding_rd_changed or posedge _check_t0_values )
    begin
        if (config_max_outstanding_rd_changed == 1'b1)
        begin
            axi_get_config_max_outstanding_rd_into_SystemVerilog(  ); // DPI call to imported task
            config_max_outstanding_rd_changed = 1'b0;
        end
    end

    always @(posedge config_error_on_deleted_valid_cycles_changed or posedge _check_t0_values )
    begin
        if (config_error_on_deleted_valid_cycles_changed == 1'b1)
        begin
            axi_get_config_error_on_deleted_valid_cycles_into_SystemVerilog(  ); // DPI call to imported task
            config_error_on_deleted_valid_cycles_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_changed == 1'b1)
        begin
            axi_get_config_stats_enable_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_AXI_read_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_AXI_read_occupancy_changed == 1'b1)
        begin
            axi_get_config_stats_enable_AXI_read_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_AXI_read_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_AXI_write_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_AXI_write_occupancy_changed == 1'b1)
        begin
            axi_get_config_stats_enable_AXI_write_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_AXI_write_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_data_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_data_occupancy_changed == 1'b1)
        begin
            axi_get_config_stats_enable_read_data_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_data_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_data_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_data_occupancy_changed == 1'b1)
        begin
            axi_get_config_stats_enable_write_data_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_data_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_latency_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_latency_changed == 1'b1)
        begin
            axi_get_config_stats_enable_read_latency_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_latency_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_latency_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_latency_changed == 1'b1)
        begin
            axi_get_config_stats_enable_write_latency_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_latency_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_address_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_address_waits_changed == 1'b1)
        begin
            axi_get_config_stats_enable_read_address_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_address_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_data_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_data_waits_changed == 1'b1)
        begin
            axi_get_config_stats_enable_read_data_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_data_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_address_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_address_waits_changed == 1'b1)
        begin
            axi_get_config_stats_enable_write_address_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_address_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_data_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_data_waits_changed == 1'b1)
        begin
            axi_get_config_stats_enable_write_data_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_data_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_response_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_response_waits_changed == 1'b1)
        begin
            axi_get_config_stats_enable_write_response_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_response_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_bandwidth_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_bandwidth_changed == 1'b1)
        begin
            axi_get_config_stats_enable_read_bandwidth_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_bandwidth_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_bandwidth_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_bandwidth_changed == 1'b1)
        begin
            axi_get_config_stats_enable_write_bandwidth_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_bandwidth_changed = 1'b0;
        end
    end

    always @(posedge config_stats_AXI_read_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_AXI_read_occupancy_step_changed == 1'b1)
        begin
            axi_get_config_stats_AXI_read_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_AXI_read_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_AXI_read_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_AXI_read_occupancy_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_AXI_read_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_AXI_read_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_active_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_active_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_active_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_active_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_occupancy_sw_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_occupancy_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_occupancy_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_occupancy_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_occupancy_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_idle_sw_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_occupancy_min_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_idle_min_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_occupancy_max_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_idle_max_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_occupancy_mean_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_idle_mean_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_AXI_write_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_AXI_write_occupancy_step_changed == 1'b1)
        begin
            axi_get_config_stats_AXI_write_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_AXI_write_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_AXI_write_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_AXI_write_occupancy_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_AXI_write_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_AXI_write_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_active_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_active_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_active_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_active_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_occupancy_sw_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_occupancy_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_occupancy_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_occupancy_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_occupancy_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_idle_sw_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_occupancy_min_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_idle_min_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_occupancy_max_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_idle_max_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_occupancy_mean_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_idle_mean_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_occupancy_step_changed == 1'b1)
        begin
            axi_get_config_stats_read_data_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_occupancy_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_read_data_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_sw_changed == 1'b1)
        begin
            axi_get_stats_read_data_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_read_data_occupancy_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_sw_changed == 1'b1)
        begin
            axi_get_stats_read_data_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_min_changed == 1'b1)
        begin
            axi_get_stats_read_data_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_min_changed == 1'b1)
        begin
            axi_get_stats_read_data_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_max_changed == 1'b1)
        begin
            axi_get_stats_read_data_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_max_changed == 1'b1)
        begin
            axi_get_stats_read_data_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_mean_changed == 1'b1)
        begin
            axi_get_stats_read_data_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_mean_changed == 1'b1)
        begin
            axi_get_stats_read_data_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_occupancy_step_changed == 1'b1)
        begin
            axi_get_config_stats_write_data_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_occupancy_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_write_data_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_sw_changed == 1'b1)
        begin
            axi_get_stats_write_data_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_write_data_occupancy_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_sw_changed == 1'b1)
        begin
            axi_get_stats_write_data_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_min_changed == 1'b1)
        begin
            axi_get_stats_write_data_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_min_changed == 1'b1)
        begin
            axi_get_stats_write_data_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_max_changed == 1'b1)
        begin
            axi_get_stats_write_data_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_max_changed == 1'b1)
        begin
            axi_get_stats_write_data_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_mean_changed == 1'b1)
        begin
            axi_get_stats_write_data_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_mean_changed == 1'b1)
        begin
            axi_get_stats_write_data_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_bandwidth_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_bandwidth_step_changed == 1'b1)
        begin
            axi_get_config_stats_read_bandwidth_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_bandwidth_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_bandwidth_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_bandwidth_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_read_bandwidth_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_bandwidth_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_sw_changed == 1'b1)
        begin
            axi_get_stats_read_bandwidth_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_read_bandwidth_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_min_changed == 1'b1)
        begin
            axi_get_stats_read_bandwidth_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_max_changed == 1'b1)
        begin
            axi_get_stats_read_bandwidth_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_mean_changed == 1'b1)
        begin
            axi_get_stats_read_bandwidth_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_bandwidth_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_bandwidth_step_changed == 1'b1)
        begin
            axi_get_config_stats_write_bandwidth_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_bandwidth_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_bandwidth_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_bandwidth_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_write_bandwidth_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_bandwidth_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_sw_changed == 1'b1)
        begin
            axi_get_stats_write_bandwidth_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_write_bandwidth_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_min_changed == 1'b1)
        begin
            axi_get_stats_write_bandwidth_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_max_changed == 1'b1)
        begin
            axi_get_stats_write_bandwidth_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_mean_changed == 1'b1)
        begin
            axi_get_stats_write_bandwidth_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_latency_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_latency_step_changed == 1'b1)
        begin
            axi_get_config_stats_read_latency_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_latency_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_latency_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_latency_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_read_latency_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_latency_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_latency_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_read_latency_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_read_latency_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_latency_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_inst_changed == 1'b1)
        begin
            axi_get_stats_read_address_data_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_sw_changed == 1'b1)
        begin
            axi_get_stats_read_address_data_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_min_changed == 1'b1)
        begin
            axi_get_stats_read_address_data_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_max_changed == 1'b1)
        begin
            axi_get_stats_read_address_data_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_mean_changed == 1'b1)
        begin
            axi_get_stats_read_address_data_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_inst_changed == 1'b1)
        begin
            axi_get_stats_read_address_address_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_sw_changed == 1'b1)
        begin
            axi_get_stats_read_address_address_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_min_changed == 1'b1)
        begin
            axi_get_stats_read_address_address_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_max_changed == 1'b1)
        begin
            axi_get_stats_read_address_address_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_mean_changed == 1'b1)
        begin
            axi_get_stats_read_address_address_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_latency_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_latency_step_changed == 1'b1)
        begin
            axi_get_config_stats_write_latency_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_latency_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_latency_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_latency_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_write_latency_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_latency_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_latency_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_write_latency_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_write_latency_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_latency_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_data_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_data_latency_inst_changed == 1'b1)
        begin
            axi_get_stats_write_address_data_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_data_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_data_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_data_latency_sw_changed == 1'b1)
        begin
            axi_get_stats_write_address_data_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_data_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_data_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_data_latency_min_changed == 1'b1)
        begin
            axi_get_stats_write_address_data_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_data_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_data_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_data_latency_max_changed == 1'b1)
        begin
            axi_get_stats_write_address_data_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_data_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_data_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_data_latency_mean_changed == 1'b1)
        begin
            axi_get_stats_write_address_data_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_data_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_response_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_response_latency_inst_changed == 1'b1)
        begin
            axi_get_stats_write_data_response_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_response_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_response_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_response_latency_sw_changed == 1'b1)
        begin
            axi_get_stats_write_data_response_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_response_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_response_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_response_latency_min_changed == 1'b1)
        begin
            axi_get_stats_write_data_response_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_response_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_response_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_response_latency_max_changed == 1'b1)
        begin
            axi_get_stats_write_data_response_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_response_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_response_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_response_latency_mean_changed == 1'b1)
        begin
            axi_get_stats_write_data_response_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_response_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_inst_changed == 1'b1)
        begin
            axi_get_stats_write_address_address_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_sw_changed == 1'b1)
        begin
            axi_get_stats_write_address_address_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_min_changed == 1'b1)
        begin
            axi_get_stats_write_address_address_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_max_changed == 1'b1)
        begin
            axi_get_stats_write_address_address_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_mean_changed == 1'b1)
        begin
            axi_get_stats_write_address_address_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_address_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_address_waits_step_changed == 1'b1)
        begin
            axi_get_config_stats_read_address_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_address_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_address_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_address_waits_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_read_address_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_address_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_inst_changed == 1'b1)
        begin
            axi_get_stats_read_address_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_sw_changed == 1'b1)
        begin
            axi_get_stats_read_address_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_read_address_waits_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_min_changed == 1'b1)
        begin
            axi_get_stats_read_address_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_max_changed == 1'b1)
        begin
            axi_get_stats_read_address_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_mean_changed == 1'b1)
        begin
            axi_get_stats_read_address_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_waits_step_changed == 1'b1)
        begin
            axi_get_config_stats_read_data_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_waits_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_read_data_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_inst_changed == 1'b1)
        begin
            axi_get_stats_read_data_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_sw_changed == 1'b1)
        begin
            axi_get_stats_read_data_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_read_data_waits_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_min_changed == 1'b1)
        begin
            axi_get_stats_read_data_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_max_changed == 1'b1)
        begin
            axi_get_stats_read_data_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_mean_changed == 1'b1)
        begin
            axi_get_stats_read_data_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_address_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_address_waits_step_changed == 1'b1)
        begin
            axi_get_config_stats_write_address_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_address_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_address_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_address_waits_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_write_address_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_address_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_inst_changed == 1'b1)
        begin
            axi_get_stats_write_address_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_sw_changed == 1'b1)
        begin
            axi_get_stats_write_address_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_write_address_waits_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_min_changed == 1'b1)
        begin
            axi_get_stats_write_address_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_max_changed == 1'b1)
        begin
            axi_get_stats_write_address_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_mean_changed == 1'b1)
        begin
            axi_get_stats_write_address_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_waits_step_changed == 1'b1)
        begin
            axi_get_config_stats_write_data_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_waits_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_write_data_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_inst_changed == 1'b1)
        begin
            axi_get_stats_write_data_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_sw_changed == 1'b1)
        begin
            axi_get_stats_write_data_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_write_data_waits_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_min_changed == 1'b1)
        begin
            axi_get_stats_write_data_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_max_changed == 1'b1)
        begin
            axi_get_stats_write_data_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_mean_changed == 1'b1)
        begin
            axi_get_stats_write_data_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_response_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_response_waits_step_changed == 1'b1)
        begin
            axi_get_config_stats_write_response_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_response_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_response_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_response_waits_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_write_response_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_response_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_inst_changed == 1'b1)
        begin
            axi_get_stats_write_response_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_sw_changed == 1'b1)
        begin
            axi_get_stats_write_response_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_write_response_waits_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_min_changed == 1'b1)
        begin
            axi_get_stats_write_response_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_max_changed == 1'b1)
        begin
            axi_get_stats_write_response_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_mean_changed == 1'b1)
        begin
            axi_get_stats_write_response_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_rw_transaction_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_rw_transaction_last_duration_changed == 1'b1)
        begin
            axi_get_stats_rw_transaction_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_rw_transaction_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_last_duration_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_last_duration_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_read_addr_channel_phase_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_read_addr_channel_phase_last_duration_changed == 1'b1)
        begin
            axi_get_stats_read_addr_channel_phase_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_addr_channel_phase_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_burst_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_burst_last_duration_changed == 1'b1)
        begin
            axi_get_stats_read_data_burst_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_burst_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_read_channel_phase_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_read_channel_phase_last_duration_changed == 1'b1)
        begin
            axi_get_stats_read_channel_phase_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_channel_phase_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_write_addr_channel_phase_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_write_addr_channel_phase_last_duration_changed == 1'b1)
        begin
            axi_get_stats_write_addr_channel_phase_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_addr_channel_phase_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_burst_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_burst_last_duration_changed == 1'b1)
        begin
            axi_get_stats_write_data_burst_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_burst_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_write_channel_phase_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_write_channel_phase_last_duration_changed == 1'b1)
        begin
            axi_get_stats_write_channel_phase_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_channel_phase_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_write_resp_channel_phase_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_write_resp_channel_phase_last_duration_changed == 1'b1)
        begin
            axi_get_stats_write_resp_channel_phase_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_resp_channel_phase_last_duration_changed = 1'b0;
        end
    end

// Timeless transaction interface support

    // assocative array of event indexed by unique_id(int)
    event assoc_timeless_comm_array[int];

    // these three functions are used by the timeless_trans_control event loop:
    // 1. initialise the loop
    import "DPI-C" context axi_start_next_timeless_trans = function void axi_start_next_timeless_trans();
    // 2. get next completed timeless transaction, returns null at the end
    import "DPI-C" context axi_get_next_timeless_trans = function int axi_get_next_timeless_trans();
    // 3. reset loop and empty the list
    import "DPI-C" context axi_end_next_timeless_trans = function void axi_end_next_timeless_trans();
    // could do above a little more efficiently by having each 'get' also remove the element so won't need an 'end'?

    // when timeless transaction monitor goes to 1 ..... trigger all the events associated with each transaction
    always @(posedge timeless_trans_control)
    begin
        int _trans_id ;
        // initialise C++ list
        axi_start_next_timeless_trans() ; 
        // loop round the list, triggering all associated events
        for ( _trans_id= axi_get_next_timeless_trans() ;
              _trans_id != 0 ;
              _trans_id= axi_get_next_timeless_trans() )
        begin
            if ( assoc_timeless_comm_array.exists( _trans_id ) )
            begin
                // trigger the event
                -> assoc_timeless_comm_array[_trans_id] ;
                // the _END_ deletes it from the array after checking existance ...
                // - that's two accesses to the array here and two in the END, there must be a more efficient way! (Could do it in C++)
            end
            else
            begin
                // survivable (?) error - a non-null handle returned which isn't in the array!
                $display("Transaction WARNING @ %t: %m - unknown unique_id received from Adaptor.",$time);
            end
        end
        // completed C++ list
        axi_end_next_timeless_trans() ; 
        timeless_trans_control= 0 ;
    end


    function longint get_last_handle();
        return last_handle;
    endfunction


    function longint get_last_start_time();
        return last_start_time;
    endfunction


    function longint get_last_end_time();
        return last_end_time;
    endfunction


    generate
    begin : questa_mvc_reporting
        bit report_available;

        // Function for getting a message from QUESTA_MVC. Returns 1 if a message was returned, 0 otherwise.
        import "DPI-C" questa_mvc_sv_get_report =  function bit get_report( input longint recipient,
                                     output string category,     output string objectName,
                                     output string instanceName, output string error_no,
                                     output string typ,          output string mess );
        questa_mvc_reporter endPoint[longint];
        initial report_available = 0;

        always @report_available
        begin
            longint recipient;
            string category;
            string objectName;
            string instanceName;
            string severity;
            string mess;
            string error_no;

            if ( endPoint.first( recipient ) )
              begin
                do
                  begin
                      while ( get_report( recipient, category, objectName, instanceName, error_no, severity, mess ) )
                        begin
                          endPoint[recipient].report_message( category, "axi", 0, objectName, instanceName, error_no, severity, mess );
                        end
                  end
                while (endPoint.next(recipient));
              end
            report_available = 0;
        end

        import "DPI-C" context questa_mvc_register_end_point = function void questa_mvc_register_end_point( input longint as_end, input string name );

        // A function for registering a reporter to capture any reports coming from as_end
        function automatic void register_end_point( input longint as_end, input questa_mvc_reporter rep = null );
            if ( rep != null )
              begin
                if ( ( rep.name == "" ) || ( rep.name == "NULL" ) )
                  begin
                    $display("Error: %m: Reporter passed to register_end_point has a reserved name. Neither an empty string nor the string 'NULL' can be used.");
                  end
                else
                  begin
                    questa_mvc_register_end_point( as_end, rep.name );
                    endPoint[as_end] = rep;
                  end
              end
            else
              begin
                questa_mvc_register_end_point( as_end, "NULL" );
                endPoint.delete( as_end );
              end
        endfunction

    end : questa_mvc_reporting
    endgenerate

    //------------------------------------------------------------------------------
    // Tasks for registering reports
    //------------------------------------------------------------------------------
    function void register_interface_reporter( input questa_mvc_reporter _rep = null );
        questa_mvc_reporting.register_end_point( _interface_ref, _rep );
    endfunction


    // Support the old API for registering an interface, for backwards compatability.
    // Note that this function is deprecated and may be removed in the future.
    function void interface_register_reporter( input questa_mvc_reporter _rep = null );
        questa_mvc_reporting.register_end_point( _interface_ref, _rep );
    endfunction

    //------------------------------------------------------------------------------
    // Function: register_master_reporter
    //------------------------------------------------------------------------------
    //     Function used to register a reporter for the <master> end of the <axi> interface.
    //     See <Customizing Error-Reporting> for a description of creating, customising and using reporters.
    //
    // Parameters:
    //    rep - The reporter to be used for the master end.
    //------------------------------------------------------------------------------
    function void register_master_reporter
    (
        input questa_mvc_reporter rep = null
    );
        questa_mvc_reporting.register_end_point( axi_master_end, rep );
    endfunction

    //------------------------------------------------------------------------------
    // Function: register_slave_reporter
    //------------------------------------------------------------------------------
    //     Function used to register a reporter for the <slave> end of the <axi> interface.
    //     See <Customizing Error-Reporting> for a description of creating, customising and using reporters.
    //
    // Parameters:
    //    rep - The reporter to be used for the slave end.
    //------------------------------------------------------------------------------
    function void register_slave_reporter
    (
        input questa_mvc_reporter rep = null
    );
        questa_mvc_reporting.register_end_point( axi_slave_end, rep );
    endfunction

    //------------------------------------------------------------------------------
    // Function:- register_clock_source_reporter
    //------------------------------------------------------------------------------
    //     Function used to register a reporter for the <clock_source> end of the <axi> interface.
    //     See <Customizing Error-Reporting> for a description of creating, customising and using reporters.
    //
    // Parameters:
    //    rep - The reporter to be used for the clock_source end.
    //------------------------------------------------------------------------------
    function void register_clock_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
        questa_mvc_reporting.register_end_point( axi_clock_source_end, rep );
    endfunction

    //------------------------------------------------------------------------------
    // Function:- register_reset_source_reporter
    //------------------------------------------------------------------------------
    //     Function used to register a reporter for the <reset_source> end of the <axi> interface.
    //     See <Customizing Error-Reporting> for a description of creating, customising and using reporters.
    //
    // Parameters:
    //    rep - The reporter to be used for the reset_source end.
    //------------------------------------------------------------------------------
    function void register_reset_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
        questa_mvc_reporting.register_end_point( axi_reset_source_end, rep );
    endfunction


    //------------------------------------------------------------------------------
    // Tasks to wait for a number of specified edges on a wire
    //------------------------------------------------------------------------------


    //------------------------------------------------------------------------------
    // Function:- wait_for_ACLK
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ACLK>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ACLK( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ACLK);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ACLK);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ACLK);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ACLK === 0 );
                    @( ACLK );
                end
                while ( ACLK !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ACLK === 1 );
                    @( ACLK );
                end
                while ( ACLK !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARESETn
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARESETn>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARESETn( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARESETn);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARESETn);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARESETn);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARESETn === 0 );
                    @( ARESETn );
                end
                while ( ARESETn !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARESETn === 1 );
                    @( ARESETn );
                end
                while ( ARESETn !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWVALID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWVALID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWVALID === 0 );
                    @( AWVALID );
                end
                while ( AWVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWVALID === 1 );
                    @( AWVALID );
                end
                while ( AWVALID !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWADDR
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWADDR>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWADDR( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWADDR);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWADDR);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWADDR);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWADDR === 0 );
                    @( AWADDR );
                end
                while ( AWADDR !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWADDR === 1 );
                    @( AWADDR );
                end
                while ( AWADDR !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWADDR_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWADDR[_this_dot_1] === 0 );
                    @( AWADDR[_this_dot_1] );
                end
                while ( AWADDR[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWADDR[_this_dot_1] === 1 );
                    @( AWADDR[_this_dot_1] );
                end
                while ( AWADDR[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWLEN
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWLEN>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWLEN( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWLEN);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWLEN);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWLEN);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWLEN === 0 );
                    @( AWLEN );
                end
                while ( AWLEN !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWLEN === 1 );
                    @( AWLEN );
                end
                while ( AWLEN !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWLEN_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWLEN[_this_dot_1] === 0 );
                    @( AWLEN[_this_dot_1] );
                end
                while ( AWLEN[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWLEN[_this_dot_1] === 1 );
                    @( AWLEN[_this_dot_1] );
                end
                while ( AWLEN[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWSIZE
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWSIZE>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWSIZE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWSIZE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWSIZE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWSIZE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWSIZE === 0 );
                    @( AWSIZE );
                end
                while ( AWSIZE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWSIZE === 1 );
                    @( AWSIZE );
                end
                while ( AWSIZE !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWSIZE_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWSIZE[_this_dot_1] === 0 );
                    @( AWSIZE[_this_dot_1] );
                end
                while ( AWSIZE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWSIZE[_this_dot_1] === 1 );
                    @( AWSIZE[_this_dot_1] );
                end
                while ( AWSIZE[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWBURST
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWBURST>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWBURST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWBURST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWBURST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWBURST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWBURST === 0 );
                    @( AWBURST );
                end
                while ( AWBURST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWBURST === 1 );
                    @( AWBURST );
                end
                while ( AWBURST !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWBURST_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWBURST[_this_dot_1] === 0 );
                    @( AWBURST[_this_dot_1] );
                end
                while ( AWBURST[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWBURST[_this_dot_1] === 1 );
                    @( AWBURST[_this_dot_1] );
                end
                while ( AWBURST[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWLOCK
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWLOCK>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWLOCK( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWLOCK);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWLOCK);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWLOCK);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWLOCK === 0 );
                    @( AWLOCK );
                end
                while ( AWLOCK !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWLOCK === 1 );
                    @( AWLOCK );
                end
                while ( AWLOCK !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWLOCK_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWLOCK>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWLOCK_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWLOCK[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWLOCK[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWLOCK[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWLOCK[_this_dot_1] === 0 );
                    @( AWLOCK[_this_dot_1] );
                end
                while ( AWLOCK[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWLOCK[_this_dot_1] === 1 );
                    @( AWLOCK[_this_dot_1] );
                end
                while ( AWLOCK[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWCACHE
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWCACHE>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWCACHE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWCACHE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWCACHE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWCACHE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWCACHE === 0 );
                    @( AWCACHE );
                end
                while ( AWCACHE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWCACHE === 1 );
                    @( AWCACHE );
                end
                while ( AWCACHE !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWCACHE_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWCACHE[_this_dot_1] === 0 );
                    @( AWCACHE[_this_dot_1] );
                end
                while ( AWCACHE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWCACHE[_this_dot_1] === 1 );
                    @( AWCACHE[_this_dot_1] );
                end
                while ( AWCACHE[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWPROT
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWPROT>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWPROT( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWPROT);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWPROT);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWPROT);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWPROT === 0 );
                    @( AWPROT );
                end
                while ( AWPROT !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWPROT === 1 );
                    @( AWPROT );
                end
                while ( AWPROT !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWPROT_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWPROT[_this_dot_1] === 0 );
                    @( AWPROT[_this_dot_1] );
                end
                while ( AWPROT[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWPROT[_this_dot_1] === 1 );
                    @( AWPROT[_this_dot_1] );
                end
                while ( AWPROT[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWID === 0 );
                    @( AWID );
                end
                while ( AWID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWID === 1 );
                    @( AWID );
                end
                while ( AWID !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWID_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWID[_this_dot_1] === 0 );
                    @( AWID[_this_dot_1] );
                end
                while ( AWID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWID[_this_dot_1] === 1 );
                    @( AWID[_this_dot_1] );
                end
                while ( AWID[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWREADY
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWREADY>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWREADY === 0 );
                    @( AWREADY );
                end
                while ( AWREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWREADY === 1 );
                    @( AWREADY );
                end
                while ( AWREADY !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWUSER
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWUSER>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWUSER === 0 );
                    @( AWUSER );
                end
                while ( AWUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWUSER === 1 );
                    @( AWUSER );
                end
                while ( AWUSER !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWUSER_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::AWUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWUSER[_this_dot_1] === 0 );
                    @( AWUSER[_this_dot_1] );
                end
                while ( AWUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWUSER[_this_dot_1] === 1 );
                    @( AWUSER[_this_dot_1] );
                end
                while ( AWUSER[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARVALID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARVALID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARVALID === 0 );
                    @( ARVALID );
                end
                while ( ARVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARVALID === 1 );
                    @( ARVALID );
                end
                while ( ARVALID !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARADDR
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARADDR>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARADDR( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARADDR);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARADDR);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARADDR);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARADDR === 0 );
                    @( ARADDR );
                end
                while ( ARADDR !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARADDR === 1 );
                    @( ARADDR );
                end
                while ( ARADDR !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARADDR_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARADDR[_this_dot_1] === 0 );
                    @( ARADDR[_this_dot_1] );
                end
                while ( ARADDR[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARADDR[_this_dot_1] === 1 );
                    @( ARADDR[_this_dot_1] );
                end
                while ( ARADDR[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARLEN
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARLEN>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARLEN( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARLEN);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARLEN);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARLEN);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARLEN === 0 );
                    @( ARLEN );
                end
                while ( ARLEN !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARLEN === 1 );
                    @( ARLEN );
                end
                while ( ARLEN !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARLEN_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARLEN[_this_dot_1] === 0 );
                    @( ARLEN[_this_dot_1] );
                end
                while ( ARLEN[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARLEN[_this_dot_1] === 1 );
                    @( ARLEN[_this_dot_1] );
                end
                while ( ARLEN[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARSIZE
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARSIZE>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARSIZE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARSIZE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARSIZE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARSIZE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARSIZE === 0 );
                    @( ARSIZE );
                end
                while ( ARSIZE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARSIZE === 1 );
                    @( ARSIZE );
                end
                while ( ARSIZE !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARSIZE_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARSIZE[_this_dot_1] === 0 );
                    @( ARSIZE[_this_dot_1] );
                end
                while ( ARSIZE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARSIZE[_this_dot_1] === 1 );
                    @( ARSIZE[_this_dot_1] );
                end
                while ( ARSIZE[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARBURST
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARBURST>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARBURST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARBURST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARBURST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARBURST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARBURST === 0 );
                    @( ARBURST );
                end
                while ( ARBURST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARBURST === 1 );
                    @( ARBURST );
                end
                while ( ARBURST !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARBURST_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARBURST[_this_dot_1] === 0 );
                    @( ARBURST[_this_dot_1] );
                end
                while ( ARBURST[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARBURST[_this_dot_1] === 1 );
                    @( ARBURST[_this_dot_1] );
                end
                while ( ARBURST[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARLOCK
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARLOCK>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARLOCK( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARLOCK);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARLOCK);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARLOCK);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARLOCK === 0 );
                    @( ARLOCK );
                end
                while ( ARLOCK !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARLOCK === 1 );
                    @( ARLOCK );
                end
                while ( ARLOCK !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARLOCK_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARLOCK>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARLOCK_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARLOCK[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARLOCK[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARLOCK[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARLOCK[_this_dot_1] === 0 );
                    @( ARLOCK[_this_dot_1] );
                end
                while ( ARLOCK[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARLOCK[_this_dot_1] === 1 );
                    @( ARLOCK[_this_dot_1] );
                end
                while ( ARLOCK[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARCACHE
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARCACHE>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARCACHE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARCACHE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARCACHE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARCACHE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARCACHE === 0 );
                    @( ARCACHE );
                end
                while ( ARCACHE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARCACHE === 1 );
                    @( ARCACHE );
                end
                while ( ARCACHE !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARCACHE_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARCACHE[_this_dot_1] === 0 );
                    @( ARCACHE[_this_dot_1] );
                end
                while ( ARCACHE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARCACHE[_this_dot_1] === 1 );
                    @( ARCACHE[_this_dot_1] );
                end
                while ( ARCACHE[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARPROT
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARPROT>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARPROT( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARPROT);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARPROT);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARPROT);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARPROT === 0 );
                    @( ARPROT );
                end
                while ( ARPROT !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARPROT === 1 );
                    @( ARPROT );
                end
                while ( ARPROT !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARPROT_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARPROT[_this_dot_1] === 0 );
                    @( ARPROT[_this_dot_1] );
                end
                while ( ARPROT[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARPROT[_this_dot_1] === 1 );
                    @( ARPROT[_this_dot_1] );
                end
                while ( ARPROT[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARID === 0 );
                    @( ARID );
                end
                while ( ARID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARID === 1 );
                    @( ARID );
                end
                while ( ARID !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARID_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARID[_this_dot_1] === 0 );
                    @( ARID[_this_dot_1] );
                end
                while ( ARID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARID[_this_dot_1] === 1 );
                    @( ARID[_this_dot_1] );
                end
                while ( ARID[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARREADY
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARREADY>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARREADY === 0 );
                    @( ARREADY );
                end
                while ( ARREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARREADY === 1 );
                    @( ARREADY );
                end
                while ( ARREADY !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARUSER
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARUSER>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARUSER === 0 );
                    @( ARUSER );
                end
                while ( ARUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARUSER === 1 );
                    @( ARUSER );
                end
                while ( ARUSER !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARUSER_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::ARUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARUSER[_this_dot_1] === 0 );
                    @( ARUSER[_this_dot_1] );
                end
                while ( ARUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARUSER[_this_dot_1] === 1 );
                    @( ARUSER[_this_dot_1] );
                end
                while ( ARUSER[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RVALID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RVALID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RVALID === 0 );
                    @( RVALID );
                end
                while ( RVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RVALID === 1 );
                    @( RVALID );
                end
                while ( RVALID !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RLAST
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RLAST>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RLAST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RLAST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RLAST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RLAST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RLAST === 0 );
                    @( RLAST );
                end
                while ( RLAST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RLAST === 1 );
                    @( RLAST );
                end
                while ( RLAST !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RDATA
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RDATA>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RDATA( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RDATA);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RDATA);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RDATA);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RDATA === 0 );
                    @( RDATA );
                end
                while ( RDATA !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RDATA === 1 );
                    @( RDATA );
                end
                while ( RDATA !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RDATA_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RDATA[_this_dot_1] === 0 );
                    @( RDATA[_this_dot_1] );
                end
                while ( RDATA[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RDATA[_this_dot_1] === 1 );
                    @( RDATA[_this_dot_1] );
                end
                while ( RDATA[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RRESP
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RRESP>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RRESP( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RRESP);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RRESP);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RRESP);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RRESP === 0 );
                    @( RRESP );
                end
                while ( RRESP !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RRESP === 1 );
                    @( RRESP );
                end
                while ( RRESP !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RRESP_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RRESP[_this_dot_1] === 0 );
                    @( RRESP[_this_dot_1] );
                end
                while ( RRESP[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RRESP[_this_dot_1] === 1 );
                    @( RRESP[_this_dot_1] );
                end
                while ( RRESP[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RID === 0 );
                    @( RID );
                end
                while ( RID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RID === 1 );
                    @( RID );
                end
                while ( RID !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RID_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RID[_this_dot_1] === 0 );
                    @( RID[_this_dot_1] );
                end
                while ( RID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RID[_this_dot_1] === 1 );
                    @( RID[_this_dot_1] );
                end
                while ( RID[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RREADY
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RREADY>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RREADY === 0 );
                    @( RREADY );
                end
                while ( RREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RREADY === 1 );
                    @( RREADY );
                end
                while ( RREADY !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RUSER
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RUSER>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RUSER === 0 );
                    @( RUSER );
                end
                while ( RUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RUSER === 1 );
                    @( RUSER );
                end
                while ( RUSER !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RUSER_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::RUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RUSER[_this_dot_1] === 0 );
                    @( RUSER[_this_dot_1] );
                end
                while ( RUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RUSER[_this_dot_1] === 1 );
                    @( RUSER[_this_dot_1] );
                end
                while ( RUSER[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_WVALID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WVALID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_WVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WVALID === 0 );
                    @( WVALID );
                end
                while ( WVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WVALID === 1 );
                    @( WVALID );
                end
                while ( WVALID !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_WLAST
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WLAST>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_WLAST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WLAST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WLAST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WLAST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WLAST === 0 );
                    @( WLAST );
                end
                while ( WLAST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WLAST === 1 );
                    @( WLAST );
                end
                while ( WLAST !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_WDATA
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WDATA>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_WDATA( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WDATA);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WDATA);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WDATA);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WDATA === 0 );
                    @( WDATA );
                end
                while ( WDATA !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WDATA === 1 );
                    @( WDATA );
                end
                while ( WDATA !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_WDATA_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_WDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WDATA[_this_dot_1] === 0 );
                    @( WDATA[_this_dot_1] );
                end
                while ( WDATA[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WDATA[_this_dot_1] === 1 );
                    @( WDATA[_this_dot_1] );
                end
                while ( WDATA[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_WSTRB
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WSTRB>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_WSTRB( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WSTRB);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WSTRB);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WSTRB);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WSTRB === 0 );
                    @( WSTRB );
                end
                while ( WSTRB !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WSTRB === 1 );
                    @( WSTRB );
                end
                while ( WSTRB !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_WSTRB_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WSTRB>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_WSTRB_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WSTRB[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WSTRB[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WSTRB[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WSTRB[_this_dot_1] === 0 );
                    @( WSTRB[_this_dot_1] );
                end
                while ( WSTRB[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WSTRB[_this_dot_1] === 1 );
                    @( WSTRB[_this_dot_1] );
                end
                while ( WSTRB[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_WID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_WID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WID === 0 );
                    @( WID );
                end
                while ( WID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WID === 1 );
                    @( WID );
                end
                while ( WID !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_WID_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_WID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WID[_this_dot_1] === 0 );
                    @( WID[_this_dot_1] );
                end
                while ( WID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WID[_this_dot_1] === 1 );
                    @( WID[_this_dot_1] );
                end
                while ( WID[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_WREADY
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WREADY>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_WREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WREADY === 0 );
                    @( WREADY );
                end
                while ( WREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WREADY === 1 );
                    @( WREADY );
                end
                while ( WREADY !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_WUSER
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WUSER>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_WUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WUSER === 0 );
                    @( WUSER );
                end
                while ( WUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WUSER === 1 );
                    @( WUSER );
                end
                while ( WUSER !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_WUSER_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::WUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_WUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WUSER[_this_dot_1] === 0 );
                    @( WUSER[_this_dot_1] );
                end
                while ( WUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WUSER[_this_dot_1] === 1 );
                    @( WUSER[_this_dot_1] );
                end
                while ( WUSER[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_BVALID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::BVALID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_BVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BVALID === 0 );
                    @( BVALID );
                end
                while ( BVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BVALID === 1 );
                    @( BVALID );
                end
                while ( BVALID !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_BRESP
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::BRESP>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_BRESP( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BRESP);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BRESP);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BRESP);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BRESP === 0 );
                    @( BRESP );
                end
                while ( BRESP !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BRESP === 1 );
                    @( BRESP );
                end
                while ( BRESP !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_BRESP_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::BRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_BRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BRESP[_this_dot_1] === 0 );
                    @( BRESP[_this_dot_1] );
                end
                while ( BRESP[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BRESP[_this_dot_1] === 1 );
                    @( BRESP[_this_dot_1] );
                end
                while ( BRESP[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_BID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::BID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_BID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BID === 0 );
                    @( BID );
                end
                while ( BID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BID === 1 );
                    @( BID );
                end
                while ( BID !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_BID_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::BID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_BID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BID[_this_dot_1] === 0 );
                    @( BID[_this_dot_1] );
                end
                while ( BID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BID[_this_dot_1] === 1 );
                    @( BID[_this_dot_1] );
                end
                while ( BID[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_BREADY
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::BREADY>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_BREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BREADY === 0 );
                    @( BREADY );
                end
                while ( BREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BREADY === 1 );
                    @( BREADY );
                end
                while ( BREADY !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_BUSER
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::BUSER>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_BUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BUSER === 0 );
                    @( BUSER );
                end
                while ( BUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BUSER === 1 );
                    @( BUSER );
                end
                while ( BUSER !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_BUSER_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi::BUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_BUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BUSER[_this_dot_1] === 0 );
                    @( BUSER[_this_dot_1] );
                end
                while ( BUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BUSER[_this_dot_1] === 1 );
                    @( BUSER[_this_dot_1] );
                end
                while ( BUSER[_this_dot_1] !== 0 );
            end
        end
    endtask

    //------------------------------------------------------------------------------
    // Tasks/functions to set/get wires
    //------------------------------------------------------------------------------


    //------------------------------------------------------------------------------
    // Function:- set_ACLK
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ACLK>.
    //
    // Parameters:
    //     ACLK_param - The value to set onto wire <axi::ACLK>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ACLK( logic ACLK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ACLK = ACLK_param;
        else
            m_ACLK <= ACLK_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ACLK
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ACLK>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ACLK>.
    //
    function automatic logic get_ACLK(  );
        return ACLK;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARESETn
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARESETn>.
    //
    // Parameters:
    //     ARESETn_param - The value to set onto wire <axi::ARESETn>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARESETn( logic ARESETn_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARESETn = ARESETn_param;
        else
            m_ARESETn <= ARESETn_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARESETn
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARESETn>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARESETn>.
    //
    function automatic logic get_ARESETn(  );
        return ARESETn;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWVALID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWVALID>.
    //
    // Parameters:
    //     AWVALID_param - The value to set onto wire <axi::AWVALID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWVALID( logic AWVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWVALID = AWVALID_param;
        else
            m_AWVALID <= AWVALID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWVALID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWVALID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWVALID>.
    //
    function automatic logic get_AWVALID(  );
        return AWVALID;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWADDR
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWADDR>.
    //
    // Parameters:
    //     AWADDR_param - The value to set onto wire <axi::AWADDR>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWADDR( logic [((AXI_ADDRESS_WIDTH) - 1):0]  AWADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWADDR = AWADDR_param;
        else
            m_AWADDR <= AWADDR_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_AWADDR_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::AWADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWADDR_param - The value to set onto wire <axi::AWADDR>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWADDR_index1( int _this_dot_1, logic  AWADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWADDR[_this_dot_1] = AWADDR_param;
        else
            m_AWADDR[_this_dot_1] <= AWADDR_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWADDR
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWADDR>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWADDR>.
    //
    function automatic logic [((AXI_ADDRESS_WIDTH) - 1):0]   get_AWADDR(  );
        return AWADDR;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_AWADDR_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::AWADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::AWADDR>.
    //
    function automatic logic   get_AWADDR_index1( int _this_dot_1 );
        return AWADDR[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWLEN
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWLEN>.
    //
    // Parameters:
    //     AWLEN_param - The value to set onto wire <axi::AWLEN>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWLEN( logic [3:0] AWLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWLEN = AWLEN_param;
        else
            m_AWLEN <= AWLEN_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_AWLEN_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::AWLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWLEN_param - The value to set onto wire <axi::AWLEN>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWLEN_index1( int _this_dot_1, logic  AWLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWLEN[_this_dot_1] = AWLEN_param;
        else
            m_AWLEN[_this_dot_1] <= AWLEN_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWLEN
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWLEN>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWLEN>.
    //
    function automatic logic [3:0]  get_AWLEN(  );
        return AWLEN;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_AWLEN_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::AWLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::AWLEN>.
    //
    function automatic logic   get_AWLEN_index1( int _this_dot_1 );
        return AWLEN[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWSIZE
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWSIZE>.
    //
    // Parameters:
    //     AWSIZE_param - The value to set onto wire <axi::AWSIZE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWSIZE( logic [2:0] AWSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWSIZE = AWSIZE_param;
        else
            m_AWSIZE <= AWSIZE_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_AWSIZE_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::AWSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWSIZE_param - The value to set onto wire <axi::AWSIZE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWSIZE_index1( int _this_dot_1, logic  AWSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWSIZE[_this_dot_1] = AWSIZE_param;
        else
            m_AWSIZE[_this_dot_1] <= AWSIZE_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWSIZE
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWSIZE>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWSIZE>.
    //
    function automatic logic [2:0]  get_AWSIZE(  );
        return AWSIZE;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_AWSIZE_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::AWSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::AWSIZE>.
    //
    function automatic logic   get_AWSIZE_index1( int _this_dot_1 );
        return AWSIZE[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWBURST
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWBURST>.
    //
    // Parameters:
    //     AWBURST_param - The value to set onto wire <axi::AWBURST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWBURST( logic [1:0] AWBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWBURST = AWBURST_param;
        else
            m_AWBURST <= AWBURST_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_AWBURST_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::AWBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWBURST_param - The value to set onto wire <axi::AWBURST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWBURST_index1( int _this_dot_1, logic  AWBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWBURST[_this_dot_1] = AWBURST_param;
        else
            m_AWBURST[_this_dot_1] <= AWBURST_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWBURST
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWBURST>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWBURST>.
    //
    function automatic logic [1:0]  get_AWBURST(  );
        return AWBURST;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_AWBURST_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::AWBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::AWBURST>.
    //
    function automatic logic   get_AWBURST_index1( int _this_dot_1 );
        return AWBURST[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWLOCK
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWLOCK>.
    //
    // Parameters:
    //     AWLOCK_param - The value to set onto wire <axi::AWLOCK>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWLOCK( logic [1:0] AWLOCK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWLOCK = AWLOCK_param;
        else
            m_AWLOCK <= AWLOCK_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_AWLOCK_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::AWLOCK>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWLOCK_param - The value to set onto wire <axi::AWLOCK>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWLOCK_index1( int _this_dot_1, logic  AWLOCK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWLOCK[_this_dot_1] = AWLOCK_param;
        else
            m_AWLOCK[_this_dot_1] <= AWLOCK_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWLOCK
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWLOCK>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWLOCK>.
    //
    function automatic logic [1:0]  get_AWLOCK(  );
        return AWLOCK;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_AWLOCK_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::AWLOCK>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::AWLOCK>.
    //
    function automatic logic   get_AWLOCK_index1( int _this_dot_1 );
        return AWLOCK[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWCACHE
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWCACHE>.
    //
    // Parameters:
    //     AWCACHE_param - The value to set onto wire <axi::AWCACHE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWCACHE( logic [3:0] AWCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWCACHE = AWCACHE_param;
        else
            m_AWCACHE <= AWCACHE_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_AWCACHE_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::AWCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWCACHE_param - The value to set onto wire <axi::AWCACHE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWCACHE_index1( int _this_dot_1, logic  AWCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWCACHE[_this_dot_1] = AWCACHE_param;
        else
            m_AWCACHE[_this_dot_1] <= AWCACHE_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWCACHE
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWCACHE>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWCACHE>.
    //
    function automatic logic [3:0]  get_AWCACHE(  );
        return AWCACHE;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_AWCACHE_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::AWCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::AWCACHE>.
    //
    function automatic logic   get_AWCACHE_index1( int _this_dot_1 );
        return AWCACHE[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWPROT
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWPROT>.
    //
    // Parameters:
    //     AWPROT_param - The value to set onto wire <axi::AWPROT>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWPROT( logic [2:0] AWPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWPROT = AWPROT_param;
        else
            m_AWPROT <= AWPROT_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_AWPROT_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::AWPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWPROT_param - The value to set onto wire <axi::AWPROT>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWPROT_index1( int _this_dot_1, logic  AWPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWPROT[_this_dot_1] = AWPROT_param;
        else
            m_AWPROT[_this_dot_1] <= AWPROT_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWPROT
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWPROT>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWPROT>.
    //
    function automatic logic [2:0]  get_AWPROT(  );
        return AWPROT;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_AWPROT_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::AWPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::AWPROT>.
    //
    function automatic logic   get_AWPROT_index1( int _this_dot_1 );
        return AWPROT[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWID>.
    //
    // Parameters:
    //     AWID_param - The value to set onto wire <axi::AWID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWID( logic [((AXI_ID_WIDTH) - 1):0]  AWID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWID = AWID_param;
        else
            m_AWID <= AWID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_AWID_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::AWID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWID_param - The value to set onto wire <axi::AWID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWID_index1( int _this_dot_1, logic  AWID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWID[_this_dot_1] = AWID_param;
        else
            m_AWID[_this_dot_1] <= AWID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWID>.
    //
    function automatic logic [((AXI_ID_WIDTH) - 1):0]   get_AWID(  );
        return AWID;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_AWID_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::AWID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::AWID>.
    //
    function automatic logic   get_AWID_index1( int _this_dot_1 );
        return AWID[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWREADY
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWREADY>.
    //
    // Parameters:
    //     AWREADY_param - The value to set onto wire <axi::AWREADY>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWREADY( logic AWREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWREADY = AWREADY_param;
        else
            m_AWREADY <= AWREADY_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWREADY
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWREADY>.
    //
    function automatic logic get_AWREADY(  );
        return AWREADY;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWUSER
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::AWUSER>.
    //
    // Parameters:
    //     AWUSER_param - The value to set onto wire <axi::AWUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWUSER( logic [7:0] AWUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWUSER = AWUSER_param;
        else
            m_AWUSER <= AWUSER_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_AWUSER_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::AWUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWUSER_param - The value to set onto wire <axi::AWUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWUSER_index1( int _this_dot_1, logic  AWUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWUSER[_this_dot_1] = AWUSER_param;
        else
            m_AWUSER[_this_dot_1] <= AWUSER_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWUSER
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::AWUSER>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::AWUSER>.
    //
    function automatic logic [7:0]  get_AWUSER(  );
        return AWUSER;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_AWUSER_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::AWUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::AWUSER>.
    //
    function automatic logic   get_AWUSER_index1( int _this_dot_1 );
        return AWUSER[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARVALID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARVALID>.
    //
    // Parameters:
    //     ARVALID_param - The value to set onto wire <axi::ARVALID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARVALID( logic ARVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARVALID = ARVALID_param;
        else
            m_ARVALID <= ARVALID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARVALID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARVALID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARVALID>.
    //
    function automatic logic get_ARVALID(  );
        return ARVALID;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARADDR
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARADDR>.
    //
    // Parameters:
    //     ARADDR_param - The value to set onto wire <axi::ARADDR>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARADDR( logic [((AXI_ADDRESS_WIDTH) - 1):0]  ARADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARADDR = ARADDR_param;
        else
            m_ARADDR <= ARADDR_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_ARADDR_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::ARADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARADDR_param - The value to set onto wire <axi::ARADDR>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARADDR_index1( int _this_dot_1, logic  ARADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARADDR[_this_dot_1] = ARADDR_param;
        else
            m_ARADDR[_this_dot_1] <= ARADDR_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARADDR
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARADDR>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARADDR>.
    //
    function automatic logic [((AXI_ADDRESS_WIDTH) - 1):0]   get_ARADDR(  );
        return ARADDR;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_ARADDR_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::ARADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::ARADDR>.
    //
    function automatic logic   get_ARADDR_index1( int _this_dot_1 );
        return ARADDR[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARLEN
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARLEN>.
    //
    // Parameters:
    //     ARLEN_param - The value to set onto wire <axi::ARLEN>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARLEN( logic [3:0] ARLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARLEN = ARLEN_param;
        else
            m_ARLEN <= ARLEN_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_ARLEN_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::ARLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARLEN_param - The value to set onto wire <axi::ARLEN>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARLEN_index1( int _this_dot_1, logic  ARLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARLEN[_this_dot_1] = ARLEN_param;
        else
            m_ARLEN[_this_dot_1] <= ARLEN_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARLEN
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARLEN>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARLEN>.
    //
    function automatic logic [3:0]  get_ARLEN(  );
        return ARLEN;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_ARLEN_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::ARLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::ARLEN>.
    //
    function automatic logic   get_ARLEN_index1( int _this_dot_1 );
        return ARLEN[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARSIZE
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARSIZE>.
    //
    // Parameters:
    //     ARSIZE_param - The value to set onto wire <axi::ARSIZE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARSIZE( logic [2:0] ARSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARSIZE = ARSIZE_param;
        else
            m_ARSIZE <= ARSIZE_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_ARSIZE_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::ARSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARSIZE_param - The value to set onto wire <axi::ARSIZE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARSIZE_index1( int _this_dot_1, logic  ARSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARSIZE[_this_dot_1] = ARSIZE_param;
        else
            m_ARSIZE[_this_dot_1] <= ARSIZE_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARSIZE
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARSIZE>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARSIZE>.
    //
    function automatic logic [2:0]  get_ARSIZE(  );
        return ARSIZE;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_ARSIZE_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::ARSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::ARSIZE>.
    //
    function automatic logic   get_ARSIZE_index1( int _this_dot_1 );
        return ARSIZE[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARBURST
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARBURST>.
    //
    // Parameters:
    //     ARBURST_param - The value to set onto wire <axi::ARBURST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARBURST( logic [1:0] ARBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARBURST = ARBURST_param;
        else
            m_ARBURST <= ARBURST_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_ARBURST_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::ARBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARBURST_param - The value to set onto wire <axi::ARBURST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARBURST_index1( int _this_dot_1, logic  ARBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARBURST[_this_dot_1] = ARBURST_param;
        else
            m_ARBURST[_this_dot_1] <= ARBURST_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARBURST
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARBURST>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARBURST>.
    //
    function automatic logic [1:0]  get_ARBURST(  );
        return ARBURST;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_ARBURST_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::ARBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::ARBURST>.
    //
    function automatic logic   get_ARBURST_index1( int _this_dot_1 );
        return ARBURST[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARLOCK
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARLOCK>.
    //
    // Parameters:
    //     ARLOCK_param - The value to set onto wire <axi::ARLOCK>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARLOCK( logic [1:0] ARLOCK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARLOCK = ARLOCK_param;
        else
            m_ARLOCK <= ARLOCK_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_ARLOCK_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::ARLOCK>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARLOCK_param - The value to set onto wire <axi::ARLOCK>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARLOCK_index1( int _this_dot_1, logic  ARLOCK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARLOCK[_this_dot_1] = ARLOCK_param;
        else
            m_ARLOCK[_this_dot_1] <= ARLOCK_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARLOCK
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARLOCK>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARLOCK>.
    //
    function automatic logic [1:0]  get_ARLOCK(  );
        return ARLOCK;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_ARLOCK_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::ARLOCK>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::ARLOCK>.
    //
    function automatic logic   get_ARLOCK_index1( int _this_dot_1 );
        return ARLOCK[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARCACHE
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARCACHE>.
    //
    // Parameters:
    //     ARCACHE_param - The value to set onto wire <axi::ARCACHE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARCACHE( logic [3:0] ARCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARCACHE = ARCACHE_param;
        else
            m_ARCACHE <= ARCACHE_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_ARCACHE_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::ARCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARCACHE_param - The value to set onto wire <axi::ARCACHE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARCACHE_index1( int _this_dot_1, logic  ARCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARCACHE[_this_dot_1] = ARCACHE_param;
        else
            m_ARCACHE[_this_dot_1] <= ARCACHE_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARCACHE
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARCACHE>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARCACHE>.
    //
    function automatic logic [3:0]  get_ARCACHE(  );
        return ARCACHE;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_ARCACHE_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::ARCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::ARCACHE>.
    //
    function automatic logic   get_ARCACHE_index1( int _this_dot_1 );
        return ARCACHE[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARPROT
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARPROT>.
    //
    // Parameters:
    //     ARPROT_param - The value to set onto wire <axi::ARPROT>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARPROT( logic [2:0] ARPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARPROT = ARPROT_param;
        else
            m_ARPROT <= ARPROT_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_ARPROT_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::ARPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARPROT_param - The value to set onto wire <axi::ARPROT>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARPROT_index1( int _this_dot_1, logic  ARPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARPROT[_this_dot_1] = ARPROT_param;
        else
            m_ARPROT[_this_dot_1] <= ARPROT_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARPROT
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARPROT>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARPROT>.
    //
    function automatic logic [2:0]  get_ARPROT(  );
        return ARPROT;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_ARPROT_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::ARPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::ARPROT>.
    //
    function automatic logic   get_ARPROT_index1( int _this_dot_1 );
        return ARPROT[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARID>.
    //
    // Parameters:
    //     ARID_param - The value to set onto wire <axi::ARID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARID( logic [((AXI_ID_WIDTH) - 1):0]  ARID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARID = ARID_param;
        else
            m_ARID <= ARID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_ARID_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::ARID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARID_param - The value to set onto wire <axi::ARID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARID_index1( int _this_dot_1, logic  ARID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARID[_this_dot_1] = ARID_param;
        else
            m_ARID[_this_dot_1] <= ARID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARID>.
    //
    function automatic logic [((AXI_ID_WIDTH) - 1):0]   get_ARID(  );
        return ARID;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_ARID_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::ARID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::ARID>.
    //
    function automatic logic   get_ARID_index1( int _this_dot_1 );
        return ARID[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARREADY
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARREADY>.
    //
    // Parameters:
    //     ARREADY_param - The value to set onto wire <axi::ARREADY>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARREADY( logic ARREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARREADY = ARREADY_param;
        else
            m_ARREADY <= ARREADY_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARREADY
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARREADY>.
    //
    function automatic logic get_ARREADY(  );
        return ARREADY;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARUSER
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::ARUSER>.
    //
    // Parameters:
    //     ARUSER_param - The value to set onto wire <axi::ARUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARUSER( logic [7:0] ARUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARUSER = ARUSER_param;
        else
            m_ARUSER <= ARUSER_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_ARUSER_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::ARUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARUSER_param - The value to set onto wire <axi::ARUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARUSER_index1( int _this_dot_1, logic  ARUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARUSER[_this_dot_1] = ARUSER_param;
        else
            m_ARUSER[_this_dot_1] <= ARUSER_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARUSER
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::ARUSER>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::ARUSER>.
    //
    function automatic logic [7:0]  get_ARUSER(  );
        return ARUSER;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_ARUSER_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::ARUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::ARUSER>.
    //
    function automatic logic   get_ARUSER_index1( int _this_dot_1 );
        return ARUSER[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_RVALID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::RVALID>.
    //
    // Parameters:
    //     RVALID_param - The value to set onto wire <axi::RVALID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RVALID( logic RVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RVALID = RVALID_param;
        else
            m_RVALID <= RVALID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_RVALID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::RVALID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::RVALID>.
    //
    function automatic logic get_RVALID(  );
        return RVALID;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_RLAST
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::RLAST>.
    //
    // Parameters:
    //     RLAST_param - The value to set onto wire <axi::RLAST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RLAST( logic RLAST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RLAST = RLAST_param;
        else
            m_RLAST <= RLAST_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_RLAST
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::RLAST>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::RLAST>.
    //
    function automatic logic get_RLAST(  );
        return RLAST;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_RDATA
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::RDATA>.
    //
    // Parameters:
    //     RDATA_param - The value to set onto wire <axi::RDATA>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RDATA( logic [((AXI_RDATA_WIDTH) - 1):0]  RDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RDATA = RDATA_param;
        else
            m_RDATA <= RDATA_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_RDATA_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::RDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     RDATA_param - The value to set onto wire <axi::RDATA>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RDATA_index1( int _this_dot_1, logic  RDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RDATA[_this_dot_1] = RDATA_param;
        else
            m_RDATA[_this_dot_1] <= RDATA_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_RDATA
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::RDATA>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::RDATA>.
    //
    function automatic logic [((AXI_RDATA_WIDTH) - 1):0]   get_RDATA(  );
        return RDATA;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_RDATA_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::RDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::RDATA>.
    //
    function automatic logic   get_RDATA_index1( int _this_dot_1 );
        return RDATA[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_RRESP
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::RRESP>.
    //
    // Parameters:
    //     RRESP_param - The value to set onto wire <axi::RRESP>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RRESP( logic [1:0] RRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RRESP = RRESP_param;
        else
            m_RRESP <= RRESP_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_RRESP_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::RRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     RRESP_param - The value to set onto wire <axi::RRESP>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RRESP_index1( int _this_dot_1, logic  RRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RRESP[_this_dot_1] = RRESP_param;
        else
            m_RRESP[_this_dot_1] <= RRESP_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_RRESP
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::RRESP>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::RRESP>.
    //
    function automatic logic [1:0]  get_RRESP(  );
        return RRESP;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_RRESP_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::RRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::RRESP>.
    //
    function automatic logic   get_RRESP_index1( int _this_dot_1 );
        return RRESP[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_RID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::RID>.
    //
    // Parameters:
    //     RID_param - The value to set onto wire <axi::RID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RID( logic [((AXI_ID_WIDTH) - 1):0]  RID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RID = RID_param;
        else
            m_RID <= RID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_RID_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::RID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     RID_param - The value to set onto wire <axi::RID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RID_index1( int _this_dot_1, logic  RID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RID[_this_dot_1] = RID_param;
        else
            m_RID[_this_dot_1] <= RID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_RID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::RID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::RID>.
    //
    function automatic logic [((AXI_ID_WIDTH) - 1):0]   get_RID(  );
        return RID;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_RID_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::RID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::RID>.
    //
    function automatic logic   get_RID_index1( int _this_dot_1 );
        return RID[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_RREADY
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::RREADY>.
    //
    // Parameters:
    //     RREADY_param - The value to set onto wire <axi::RREADY>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RREADY( logic RREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RREADY = RREADY_param;
        else
            m_RREADY <= RREADY_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_RREADY
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::RREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::RREADY>.
    //
    function automatic logic get_RREADY(  );
        return RREADY;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_RUSER
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::RUSER>.
    //
    // Parameters:
    //     RUSER_param - The value to set onto wire <axi::RUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RUSER( logic [7:0] RUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RUSER = RUSER_param;
        else
            m_RUSER <= RUSER_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_RUSER_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::RUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     RUSER_param - The value to set onto wire <axi::RUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RUSER_index1( int _this_dot_1, logic  RUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RUSER[_this_dot_1] = RUSER_param;
        else
            m_RUSER[_this_dot_1] <= RUSER_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_RUSER
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::RUSER>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::RUSER>.
    //
    function automatic logic [7:0]  get_RUSER(  );
        return RUSER;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_RUSER_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::RUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::RUSER>.
    //
    function automatic logic   get_RUSER_index1( int _this_dot_1 );
        return RUSER[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_WVALID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::WVALID>.
    //
    // Parameters:
    //     WVALID_param - The value to set onto wire <axi::WVALID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_WVALID( logic WVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WVALID = WVALID_param;
        else
            m_WVALID <= WVALID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_WVALID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::WVALID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::WVALID>.
    //
    function automatic logic get_WVALID(  );
        return WVALID;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_WLAST
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::WLAST>.
    //
    // Parameters:
    //     WLAST_param - The value to set onto wire <axi::WLAST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_WLAST( logic WLAST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WLAST = WLAST_param;
        else
            m_WLAST <= WLAST_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_WLAST
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::WLAST>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::WLAST>.
    //
    function automatic logic get_WLAST(  );
        return WLAST;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_WDATA
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::WDATA>.
    //
    // Parameters:
    //     WDATA_param - The value to set onto wire <axi::WDATA>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_WDATA( logic [((AXI_WDATA_WIDTH) - 1):0]  WDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WDATA = WDATA_param;
        else
            m_WDATA <= WDATA_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_WDATA_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::WDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     WDATA_param - The value to set onto wire <axi::WDATA>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_WDATA_index1( int _this_dot_1, logic  WDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WDATA[_this_dot_1] = WDATA_param;
        else
            m_WDATA[_this_dot_1] <= WDATA_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_WDATA
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::WDATA>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::WDATA>.
    //
    function automatic logic [((AXI_WDATA_WIDTH) - 1):0]   get_WDATA(  );
        return WDATA;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_WDATA_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::WDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::WDATA>.
    //
    function automatic logic   get_WDATA_index1( int _this_dot_1 );
        return WDATA[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_WSTRB
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::WSTRB>.
    //
    // Parameters:
    //     WSTRB_param - The value to set onto wire <axi::WSTRB>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_WSTRB( logic [(((AXI_WDATA_WIDTH / 8)) - 1):0]  WSTRB_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WSTRB = WSTRB_param;
        else
            m_WSTRB <= WSTRB_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_WSTRB_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::WSTRB>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     WSTRB_param - The value to set onto wire <axi::WSTRB>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_WSTRB_index1( int _this_dot_1, logic  WSTRB_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WSTRB[_this_dot_1] = WSTRB_param;
        else
            m_WSTRB[_this_dot_1] <= WSTRB_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_WSTRB
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::WSTRB>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::WSTRB>.
    //
    function automatic logic [(((AXI_WDATA_WIDTH / 8)) - 1):0]   get_WSTRB(  );
        return WSTRB;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_WSTRB_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::WSTRB>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::WSTRB>.
    //
    function automatic logic   get_WSTRB_index1( int _this_dot_1 );
        return WSTRB[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_WID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::WID>.
    //
    // Parameters:
    //     WID_param - The value to set onto wire <axi::WID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_WID( logic [((AXI_ID_WIDTH) - 1):0]  WID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WID = WID_param;
        else
            m_WID <= WID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_WID_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::WID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     WID_param - The value to set onto wire <axi::WID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_WID_index1( int _this_dot_1, logic  WID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WID[_this_dot_1] = WID_param;
        else
            m_WID[_this_dot_1] <= WID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_WID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::WID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::WID>.
    //
    function automatic logic [((AXI_ID_WIDTH) - 1):0]   get_WID(  );
        return WID;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_WID_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::WID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::WID>.
    //
    function automatic logic   get_WID_index1( int _this_dot_1 );
        return WID[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_WREADY
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::WREADY>.
    //
    // Parameters:
    //     WREADY_param - The value to set onto wire <axi::WREADY>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_WREADY( logic WREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WREADY = WREADY_param;
        else
            m_WREADY <= WREADY_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_WREADY
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::WREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::WREADY>.
    //
    function automatic logic get_WREADY(  );
        return WREADY;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_WUSER
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::WUSER>.
    //
    // Parameters:
    //     WUSER_param - The value to set onto wire <axi::WUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_WUSER( logic [7:0] WUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WUSER = WUSER_param;
        else
            m_WUSER <= WUSER_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_WUSER_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::WUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     WUSER_param - The value to set onto wire <axi::WUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_WUSER_index1( int _this_dot_1, logic  WUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WUSER[_this_dot_1] = WUSER_param;
        else
            m_WUSER[_this_dot_1] <= WUSER_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_WUSER
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::WUSER>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::WUSER>.
    //
    function automatic logic [7:0]  get_WUSER(  );
        return WUSER;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_WUSER_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::WUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::WUSER>.
    //
    function automatic logic   get_WUSER_index1( int _this_dot_1 );
        return WUSER[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_BVALID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::BVALID>.
    //
    // Parameters:
    //     BVALID_param - The value to set onto wire <axi::BVALID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_BVALID( logic BVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BVALID = BVALID_param;
        else
            m_BVALID <= BVALID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_BVALID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::BVALID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::BVALID>.
    //
    function automatic logic get_BVALID(  );
        return BVALID;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_BRESP
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::BRESP>.
    //
    // Parameters:
    //     BRESP_param - The value to set onto wire <axi::BRESP>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_BRESP( logic [1:0] BRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BRESP = BRESP_param;
        else
            m_BRESP <= BRESP_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_BRESP_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::BRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     BRESP_param - The value to set onto wire <axi::BRESP>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_BRESP_index1( int _this_dot_1, logic  BRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BRESP[_this_dot_1] = BRESP_param;
        else
            m_BRESP[_this_dot_1] <= BRESP_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_BRESP
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::BRESP>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::BRESP>.
    //
    function automatic logic [1:0]  get_BRESP(  );
        return BRESP;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_BRESP_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::BRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::BRESP>.
    //
    function automatic logic   get_BRESP_index1( int _this_dot_1 );
        return BRESP[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_BID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::BID>.
    //
    // Parameters:
    //     BID_param - The value to set onto wire <axi::BID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_BID( logic [((AXI_ID_WIDTH) - 1):0]  BID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BID = BID_param;
        else
            m_BID <= BID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_BID_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::BID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     BID_param - The value to set onto wire <axi::BID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_BID_index1( int _this_dot_1, logic  BID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BID[_this_dot_1] = BID_param;
        else
            m_BID[_this_dot_1] <= BID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_BID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::BID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::BID>.
    //
    function automatic logic [((AXI_ID_WIDTH) - 1):0]   get_BID(  );
        return BID;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_BID_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::BID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::BID>.
    //
    function automatic logic   get_BID_index1( int _this_dot_1 );
        return BID[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_BREADY
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::BREADY>.
    //
    // Parameters:
    //     BREADY_param - The value to set onto wire <axi::BREADY>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_BREADY( logic BREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BREADY = BREADY_param;
        else
            m_BREADY <= BREADY_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_BREADY
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::BREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::BREADY>.
    //
    function automatic logic get_BREADY(  );
        return BREADY;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_BUSER
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi::BUSER>.
    //
    // Parameters:
    //     BUSER_param - The value to set onto wire <axi::BUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_BUSER( logic [7:0] BUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BUSER = BUSER_param;
        else
            m_BUSER <= BUSER_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_BUSER_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi::BUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     BUSER_param - The value to set onto wire <axi::BUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_BUSER_index1( int _this_dot_1, logic  BUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BUSER[_this_dot_1] = BUSER_param;
        else
            m_BUSER[_this_dot_1] <= BUSER_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_BUSER
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi::BUSER>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi::BUSER>.
    //
    function automatic logic [7:0]  get_BUSER(  );
        return BUSER;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_BUSER_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi::BUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi::BUSER>.
    //
    function automatic logic   get_BUSER_index1( int _this_dot_1 );
        return BUSER[_this_dot_1];
    endfunction

    //------------------------------------------------------------------------------
    // Tasks to wait for a change to a global variable with read access
    //------------------------------------------------------------------------------


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_clk_init_value
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_clk_init_value>.
    //
    task automatic wait_for_config_clk_init_value(  );
        begin
            @( config_clk_init_value );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_clk_phase_shift
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_clk_phase_shift>.
    //
    task automatic wait_for_config_clk_phase_shift(  );
        begin
            @( config_clk_phase_shift );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_clk_1st_time
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_clk_1st_time>.
    //
    task automatic wait_for_config_clk_1st_time(  );
        begin
            @( config_clk_1st_time );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_clk_2nd_time
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_clk_2nd_time>.
    //
    task automatic wait_for_config_clk_2nd_time(  );
        begin
            @( config_clk_2nd_time );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_setup_time
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_setup_time>.
    //
    task automatic wait_for_config_setup_time(  );
        begin
            @( config_setup_time );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_hold_time
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_hold_time>.
    //
    task automatic wait_for_config_hold_time(  );
        begin
            @( config_hold_time );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_transaction_time_factor
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_max_transaction_time_factor>.
    //
    task automatic wait_for_config_max_transaction_time_factor(  );
        begin
            @( config_max_transaction_time_factor );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_timeout_max_data_transfer
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_timeout_max_data_transfer>.
    //
    task automatic wait_for_config_timeout_max_data_transfer(  );
        begin
            @( config_timeout_max_data_transfer );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_burst_timeout_factor
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_burst_timeout_factor>.
    //
    task automatic wait_for_config_burst_timeout_factor(  );
        begin
            @( config_burst_timeout_factor );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_latency_AWVALID_assertion_to_AWREADY
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_max_latency_AWVALID_assertion_to_AWREADY>.
    //
    task automatic wait_for_config_max_latency_AWVALID_assertion_to_AWREADY(  );
        begin
            @( config_max_latency_AWVALID_assertion_to_AWREADY );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_latency_ARVALID_assertion_to_ARREADY
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_max_latency_ARVALID_assertion_to_ARREADY>.
    //
    task automatic wait_for_config_max_latency_ARVALID_assertion_to_ARREADY(  );
        begin
            @( config_max_latency_ARVALID_assertion_to_ARREADY );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_latency_RVALID_assertion_to_RREADY
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_max_latency_RVALID_assertion_to_RREADY>.
    //
    task automatic wait_for_config_max_latency_RVALID_assertion_to_RREADY(  );
        begin
            @( config_max_latency_RVALID_assertion_to_RREADY );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_latency_BVALID_assertion_to_BREADY
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_max_latency_BVALID_assertion_to_BREADY>.
    //
    task automatic wait_for_config_max_latency_BVALID_assertion_to_BREADY(  );
        begin
            @( config_max_latency_BVALID_assertion_to_BREADY );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_latency_WVALID_assertion_to_WREADY
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_max_latency_WVALID_assertion_to_WREADY>.
    //
    task automatic wait_for_config_max_latency_WVALID_assertion_to_WREADY(  );
        begin
            @( config_max_latency_WVALID_assertion_to_WREADY );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_write_ctrl_first_ratio
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_write_ctrl_first_ratio>.
    //
    task automatic wait_for_config_write_ctrl_first_ratio(  );
        begin
            @( config_write_ctrl_first_ratio );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_write_data_first_ratio
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_write_data_first_ratio>.
    //
    task automatic wait_for_config_write_data_first_ratio(  );
        begin
            @( config_write_data_first_ratio );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_write_ctrl_to_data_mintime
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_write_ctrl_to_data_mintime>.
    //
    task automatic wait_for_config_write_ctrl_to_data_mintime(  );
        begin
            @( config_write_ctrl_to_data_mintime );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_write_data_to_ctrl_mintime
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_write_data_to_ctrl_mintime>.
    //
    task automatic wait_for_config_write_data_to_ctrl_mintime(  );
        begin
            @( config_write_data_to_ctrl_mintime );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_master_write_delay
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_master_write_delay>.
    //
    task automatic wait_for_config_master_write_delay(  );
        begin
            @( config_master_write_delay );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_reset_low_clocks
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_reset_low_clocks>.
    //
    task automatic wait_for_config_reset_low_clocks(  );
        begin
            @( config_reset_low_clocks );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_reset_hold_time
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_reset_hold_time>.
    //
    task automatic wait_for_config_reset_hold_time(  );
        begin
            @( config_reset_hold_time );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_protect_ready
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_protect_ready>.
    //
    task automatic wait_for_config_protect_ready(  );
        begin
            @( config_protect_ready );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_user_sideband
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_user_sideband>.
    //
    task automatic wait_for_config_enable_user_sideband(  );
        begin
            @( config_enable_user_sideband );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_extended_length_enable
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_extended_length_enable>.
    //
    task automatic wait_for_config_extended_length_enable(  );
        begin
            @( config_extended_length_enable );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_burst_reserved_value
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_burst_reserved_value>.
    //
    task automatic wait_for_config_enable_burst_reserved_value(  );
        begin
            @( config_enable_burst_reserved_value );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_lock_reserved_value
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_lock_reserved_value>.
    //
    task automatic wait_for_config_enable_lock_reserved_value(  );
        begin
            @( config_enable_lock_reserved_value );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_cache_reserved_value
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_cache_reserved_value>.
    //
    task automatic wait_for_config_enable_cache_reserved_value(  );
        begin
            @( config_enable_cache_reserved_value );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_all_assertions
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_all_assertions>.
    //
    task automatic wait_for_config_enable_all_assertions(  );
        begin
            @( config_enable_all_assertions );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_assertion
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_assertion>.
    //
    task automatic wait_for_config_enable_assertion(  );
        begin
            @( config_enable_assertion );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_assertion_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_assertion>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_config_enable_assertion_index1( input int _this_dot_1 );
        begin
            @( config_enable_assertion[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_error
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_error>.
    //
    task automatic wait_for_config_enable_error(  );
        begin
            @( config_enable_error );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_error_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_error>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_config_enable_error_index1( input int _this_dot_1 );
        begin
            @( config_enable_error[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_errors
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_errors>.
    //
    task automatic wait_for_config_enable_errors(  );
        begin
            @( config_enable_errors );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_all_assertion_errors
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_all_assertion_errors>.
    //
    task automatic wait_for_config_enable_all_assertion_errors(  );
        begin
            @( config_enable_all_assertion_errors );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_abstraction_level
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_abstraction_level>.
    //
    task automatic wait_for_config_abstraction_level(  );
        begin
            @( config_abstraction_level );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_start_addr
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_slave_start_addr>.
    //
    task automatic wait_for_config_slave_start_addr(  );
        begin
            @( config_slave_start_addr );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_start_addr_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_slave_start_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_config_slave_start_addr_index1( input int _this_dot_1 );
        begin
            @( config_slave_start_addr[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_end_addr
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_slave_end_addr>.
    //
    task automatic wait_for_config_slave_end_addr(  );
        begin
            @( config_slave_end_addr );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_end_addr_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_slave_end_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_config_slave_end_addr_index1( input int _this_dot_1 );
        begin
            @( config_slave_end_addr[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_slave_addr_range_in_bfm
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_slave_addr_range_in_bfm>.
    //
    task automatic wait_for_config_enable_slave_addr_range_in_bfm(  );
        begin
            @( config_enable_slave_addr_range_in_bfm );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_read_data_reordering_depth
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_read_data_reordering_depth>.
    //
    task automatic wait_for_config_read_data_reordering_depth(  );
        begin
            @( config_read_data_reordering_depth );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_read_data_reordering_depth_in_bfm
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_enable_read_data_reordering_depth_in_bfm>.
    //
    task automatic wait_for_config_enable_read_data_reordering_depth_in_bfm(  );
        begin
            @( config_enable_read_data_reordering_depth_in_bfm );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_awid_wid_mismatch
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_awid_wid_mismatch>.
    //
    task automatic wait_for_config_awid_wid_mismatch(  );
        begin
            @( config_awid_wid_mismatch );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_length_last_mismatch_error
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_length_last_mismatch_error>.
    //
    task automatic wait_for_config_length_last_mismatch_error(  );
        begin
            @( config_length_last_mismatch_error );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_master_error_position
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_master_error_position>.
    //
    task automatic wait_for_config_master_error_position(  );
        begin
            @( config_master_error_position );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_dummy_var
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::dummy_var>.
    //
    task automatic wait_for_dummy_var(  );
        begin
            @( dummy_var );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_wlast_length
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_wlast_length>.
    //
    task automatic wait_for_config_wlast_length(  );
        begin
            @( config_wlast_length );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_wid_for_awid_not_matching
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_wid_for_awid_not_matching>.
    //
    task automatic wait_for_config_wid_for_awid_not_matching(  );
        begin
            @( config_wid_for_awid_not_matching );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_wid_for_awid_not_matching_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_wid_for_awid_not_matching>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_config_wid_for_awid_not_matching_index1( input int _this_dot_1 );
        begin
            @( config_wid_for_awid_not_matching[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_support_exclusive_access
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_support_exclusive_access>.
    //
    task automatic wait_for_config_support_exclusive_access(  );
        begin
            @( config_support_exclusive_access );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_write_data_interleaving_depth
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_write_data_interleaving_depth>.
    //
    task automatic wait_for_config_write_data_interleaving_depth(  );
        begin
            @( config_write_data_interleaving_depth );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_status_master_error
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::status_master_error>.
    //
    task automatic wait_for_status_master_error(  );
        begin
            @( status_master_error );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_status_master_error_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::status_master_error>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_status_master_error_index1( input int _this_dot_1 );
        begin
            @( status_master_error[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_status_num_reads_waiting_for_resp
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::status_num_reads_waiting_for_resp>.
    //
    task automatic wait_for_status_num_reads_waiting_for_resp(  );
        begin
            @( status_num_reads_waiting_for_resp );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_status_num_writes_waiting_for_response
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::status_num_writes_waiting_for_response>.
    //
    task automatic wait_for_status_num_writes_waiting_for_response(  );
        begin
            @( status_num_writes_waiting_for_response );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_check_total_num_wdata_outstanding
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::check_total_num_wdata_outstanding>.
    //
    task automatic wait_for_check_total_num_wdata_outstanding(  );
        begin
            @( check_total_num_wdata_outstanding );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_total_num_wdata_outstanding
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::total_num_wdata_outstanding>.
    //
    task automatic wait_for_total_num_wdata_outstanding(  );
        begin
            @( total_num_wdata_outstanding );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_check_max_num_wdata_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::check_max_num_wdata_outstanding_per_id>.
    //
    task automatic wait_for_check_max_num_wdata_outstanding_per_id(  );
        begin
            @( check_max_num_wdata_outstanding_per_id );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_max_num_wdata_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::max_num_wdata_outstanding_per_id>.
    //
    task automatic wait_for_max_num_wdata_outstanding_per_id(  );
        begin
            @( max_num_wdata_outstanding_per_id );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_check_max_num_waddr_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::check_max_num_waddr_outstanding_per_id>.
    //
    task automatic wait_for_check_max_num_waddr_outstanding_per_id(  );
        begin
            @( check_max_num_waddr_outstanding_per_id );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_max_num_waddr_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::max_num_waddr_outstanding_per_id>.
    //
    task automatic wait_for_max_num_waddr_outstanding_per_id(  );
        begin
            @( max_num_waddr_outstanding_per_id );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_check_total_num_waddr_outstanding
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::check_total_num_waddr_outstanding>.
    //
    task automatic wait_for_check_total_num_waddr_outstanding(  );
        begin
            @( check_total_num_waddr_outstanding );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_total_num_waddr_outstanding
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::total_num_waddr_outstanding>.
    //
    task automatic wait_for_total_num_waddr_outstanding(  );
        begin
            @( total_num_waddr_outstanding );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_status_outstanding_num_for_waddr
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::status_outstanding_num_for_waddr>.
    //
    task automatic wait_for_status_outstanding_num_for_waddr(  );
        begin
            @( status_outstanding_num_for_waddr );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_start_finding_outstanding_waddr
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::start_finding_outstanding_waddr>.
    //
    task automatic wait_for_start_finding_outstanding_waddr(  );
        begin
            @( start_finding_outstanding_waddr );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_status_outstanding_num_for_wdata
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::status_outstanding_num_for_wdata>.
    //
    task automatic wait_for_status_outstanding_num_for_wdata(  );
        begin
            @( status_outstanding_num_for_wdata );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_start_finding_outstanding_wdata
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::start_finding_outstanding_wdata>.
    //
    task automatic wait_for_start_finding_outstanding_wdata(  );
        begin
            @( start_finding_outstanding_wdata );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_find_waddr_outstanding_for_wid
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::find_waddr_outstanding_for_wid>.
    //
    task automatic wait_for_find_waddr_outstanding_for_wid(  );
        begin
            @( find_waddr_outstanding_for_wid );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_find_waddr_outstanding_for_wid_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::find_waddr_outstanding_for_wid>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_find_waddr_outstanding_for_wid_index1( input int _this_dot_1 );
        begin
            @( find_waddr_outstanding_for_wid[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_find_wdata_outstanding_for_wid
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::find_wdata_outstanding_for_wid>.
    //
    task automatic wait_for_find_wdata_outstanding_for_wid(  );
        begin
            @( find_wdata_outstanding_for_wid );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_find_wdata_outstanding_for_wid_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::find_wdata_outstanding_for_wid>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_find_wdata_outstanding_for_wid_index1( input int _this_dot_1 );
        begin
            @( find_wdata_outstanding_for_wid[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_change_in_wdata_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::change_in_wdata_outstanding_per_id>.
    //
    task automatic wait_for_change_in_wdata_outstanding_per_id(  );
        begin
            @( change_in_wdata_outstanding_per_id );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_start_finding_change_in_wdata
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::start_finding_change_in_wdata>.
    //
    task automatic wait_for_start_finding_change_in_wdata(  );
        begin
            @( start_finding_change_in_wdata );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_find_change_in_wdata_outstanding_for_wid
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::find_change_in_wdata_outstanding_for_wid>.
    //
    task automatic wait_for_find_change_in_wdata_outstanding_for_wid(  );
        begin
            @( find_change_in_wdata_outstanding_for_wid );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_find_change_in_wdata_outstanding_for_wid_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::find_change_in_wdata_outstanding_for_wid>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_find_change_in_wdata_outstanding_for_wid_index1( input int _this_dot_1 );
        begin
            @( find_change_in_wdata_outstanding_for_wid[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_outstanding_wr
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_max_outstanding_wr>.
    //
    task automatic wait_for_config_max_outstanding_wr(  );
        begin
            @( config_max_outstanding_wr );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_outstanding_rd
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_max_outstanding_rd>.
    //
    task automatic wait_for_config_max_outstanding_rd(  );
        begin
            @( config_max_outstanding_rd );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_error_on_deleted_valid_cycles
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_error_on_deleted_valid_cycles>.
    //
    task automatic wait_for_config_error_on_deleted_valid_cycles(  );
        begin
            @( config_error_on_deleted_valid_cycles );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable>.
    //
    task automatic wait_for_config_stats_enable(  );
        begin
            @( config_stats_enable );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_AXI_read_occupancy
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_AXI_read_occupancy>.
    //
    task automatic wait_for_config_stats_enable_AXI_read_occupancy(  );
        begin
            @( config_stats_enable_AXI_read_occupancy );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_AXI_write_occupancy
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_AXI_write_occupancy>.
    //
    task automatic wait_for_config_stats_enable_AXI_write_occupancy(  );
        begin
            @( config_stats_enable_AXI_write_occupancy );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_data_occupancy
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_read_data_occupancy>.
    //
    task automatic wait_for_config_stats_enable_read_data_occupancy(  );
        begin
            @( config_stats_enable_read_data_occupancy );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_data_occupancy
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_write_data_occupancy>.
    //
    task automatic wait_for_config_stats_enable_write_data_occupancy(  );
        begin
            @( config_stats_enable_write_data_occupancy );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_latency
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_read_latency>.
    //
    task automatic wait_for_config_stats_enable_read_latency(  );
        begin
            @( config_stats_enable_read_latency );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_latency
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_write_latency>.
    //
    task automatic wait_for_config_stats_enable_write_latency(  );
        begin
            @( config_stats_enable_write_latency );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_address_waits
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_read_address_waits>.
    //
    task automatic wait_for_config_stats_enable_read_address_waits(  );
        begin
            @( config_stats_enable_read_address_waits );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_data_waits
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_read_data_waits>.
    //
    task automatic wait_for_config_stats_enable_read_data_waits(  );
        begin
            @( config_stats_enable_read_data_waits );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_address_waits
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_write_address_waits>.
    //
    task automatic wait_for_config_stats_enable_write_address_waits(  );
        begin
            @( config_stats_enable_write_address_waits );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_data_waits
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_write_data_waits>.
    //
    task automatic wait_for_config_stats_enable_write_data_waits(  );
        begin
            @( config_stats_enable_write_data_waits );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_response_waits
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_write_response_waits>.
    //
    task automatic wait_for_config_stats_enable_write_response_waits(  );
        begin
            @( config_stats_enable_write_response_waits );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_bandwidth
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_read_bandwidth>.
    //
    task automatic wait_for_config_stats_enable_read_bandwidth(  );
        begin
            @( config_stats_enable_read_bandwidth );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_bandwidth
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_enable_write_bandwidth>.
    //
    task automatic wait_for_config_stats_enable_write_bandwidth(  );
        begin
            @( config_stats_enable_write_bandwidth );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_AXI_read_occupancy_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_AXI_read_occupancy_step>.
    //
    task automatic wait_for_config_stats_AXI_read_occupancy_step(  );
        begin
            @( config_stats_AXI_read_occupancy_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_AXI_read_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_AXI_read_occupancy_multiple>.
    //
    task automatic wait_for_config_stats_AXI_read_occupancy_multiple(  );
        begin
            @( config_stats_AXI_read_occupancy_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_active
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_active>.
    //
    task automatic wait_for_stats_AXI_read_active(  );
        begin
            @( stats_AXI_read_active );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_occupancy_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_occupancy_sw>.
    //
    task automatic wait_for_stats_AXI_read_occupancy_sw(  );
        begin
            @( stats_AXI_read_occupancy_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_occupancy_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_occupancy_sw_updated>.
    //
    task automatic wait_for_stats_AXI_read_occupancy_sw_updated(  );
        begin
            @( stats_AXI_read_occupancy_sw_updated );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_idle_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_idle_sw>.
    //
    task automatic wait_for_stats_AXI_read_idle_sw(  );
        begin
            @( stats_AXI_read_idle_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_occupancy_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_occupancy_min>.
    //
    task automatic wait_for_stats_AXI_read_occupancy_min(  );
        begin
            @( stats_AXI_read_occupancy_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_idle_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_idle_min>.
    //
    task automatic wait_for_stats_AXI_read_idle_min(  );
        begin
            @( stats_AXI_read_idle_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_occupancy_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_occupancy_max>.
    //
    task automatic wait_for_stats_AXI_read_occupancy_max(  );
        begin
            @( stats_AXI_read_occupancy_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_idle_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_idle_max>.
    //
    task automatic wait_for_stats_AXI_read_idle_max(  );
        begin
            @( stats_AXI_read_idle_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_occupancy_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_occupancy_mean>.
    //
    task automatic wait_for_stats_AXI_read_occupancy_mean(  );
        begin
            @( stats_AXI_read_occupancy_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_idle_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_idle_mean>.
    //
    task automatic wait_for_stats_AXI_read_idle_mean(  );
        begin
            @( stats_AXI_read_idle_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_AXI_write_occupancy_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_AXI_write_occupancy_step>.
    //
    task automatic wait_for_config_stats_AXI_write_occupancy_step(  );
        begin
            @( config_stats_AXI_write_occupancy_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_AXI_write_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_AXI_write_occupancy_multiple>.
    //
    task automatic wait_for_config_stats_AXI_write_occupancy_multiple(  );
        begin
            @( config_stats_AXI_write_occupancy_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_active
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_active>.
    //
    task automatic wait_for_stats_AXI_write_active(  );
        begin
            @( stats_AXI_write_active );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_occupancy_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_occupancy_sw>.
    //
    task automatic wait_for_stats_AXI_write_occupancy_sw(  );
        begin
            @( stats_AXI_write_occupancy_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_occupancy_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_occupancy_sw_updated>.
    //
    task automatic wait_for_stats_AXI_write_occupancy_sw_updated(  );
        begin
            @( stats_AXI_write_occupancy_sw_updated );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_idle_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_idle_sw>.
    //
    task automatic wait_for_stats_AXI_write_idle_sw(  );
        begin
            @( stats_AXI_write_idle_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_occupancy_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_occupancy_min>.
    //
    task automatic wait_for_stats_AXI_write_occupancy_min(  );
        begin
            @( stats_AXI_write_occupancy_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_idle_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_idle_min>.
    //
    task automatic wait_for_stats_AXI_write_idle_min(  );
        begin
            @( stats_AXI_write_idle_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_occupancy_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_occupancy_max>.
    //
    task automatic wait_for_stats_AXI_write_occupancy_max(  );
        begin
            @( stats_AXI_write_occupancy_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_idle_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_idle_max>.
    //
    task automatic wait_for_stats_AXI_write_idle_max(  );
        begin
            @( stats_AXI_write_idle_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_occupancy_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_occupancy_mean>.
    //
    task automatic wait_for_stats_AXI_write_occupancy_mean(  );
        begin
            @( stats_AXI_write_occupancy_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_idle_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_idle_mean>.
    //
    task automatic wait_for_stats_AXI_write_idle_mean(  );
        begin
            @( stats_AXI_write_idle_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_read_data_occupancy_step>.
    //
    task automatic wait_for_config_stats_read_data_occupancy_step(  );
        begin
            @( config_stats_read_data_occupancy_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_read_data_occupancy_multiple>.
    //
    task automatic wait_for_config_stats_read_data_occupancy_multiple(  );
        begin
            @( config_stats_read_data_occupancy_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_occupancy_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_occupancy_sw>.
    //
    task automatic wait_for_stats_read_data_occupancy_sw(  );
        begin
            @( stats_read_data_occupancy_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_occupancy_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_occupancy_sw_updated>.
    //
    task automatic wait_for_stats_read_data_occupancy_sw_updated(  );
        begin
            @( stats_read_data_occupancy_sw_updated );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_idle_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_idle_sw>.
    //
    task automatic wait_for_stats_read_data_idle_sw(  );
        begin
            @( stats_read_data_idle_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_occupancy_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_occupancy_min>.
    //
    task automatic wait_for_stats_read_data_occupancy_min(  );
        begin
            @( stats_read_data_occupancy_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_idle_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_idle_min>.
    //
    task automatic wait_for_stats_read_data_idle_min(  );
        begin
            @( stats_read_data_idle_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_occupancy_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_occupancy_max>.
    //
    task automatic wait_for_stats_read_data_occupancy_max(  );
        begin
            @( stats_read_data_occupancy_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_idle_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_idle_max>.
    //
    task automatic wait_for_stats_read_data_idle_max(  );
        begin
            @( stats_read_data_idle_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_occupancy_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_occupancy_mean>.
    //
    task automatic wait_for_stats_read_data_occupancy_mean(  );
        begin
            @( stats_read_data_occupancy_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_idle_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_idle_mean>.
    //
    task automatic wait_for_stats_read_data_idle_mean(  );
        begin
            @( stats_read_data_idle_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_data_occupancy_step>.
    //
    task automatic wait_for_config_stats_write_data_occupancy_step(  );
        begin
            @( config_stats_write_data_occupancy_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_data_occupancy_multiple>.
    //
    task automatic wait_for_config_stats_write_data_occupancy_multiple(  );
        begin
            @( config_stats_write_data_occupancy_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_occupancy_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_occupancy_sw>.
    //
    task automatic wait_for_stats_write_data_occupancy_sw(  );
        begin
            @( stats_write_data_occupancy_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_occupancy_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_occupancy_sw_updated>.
    //
    task automatic wait_for_stats_write_data_occupancy_sw_updated(  );
        begin
            @( stats_write_data_occupancy_sw_updated );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_idle_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_idle_sw>.
    //
    task automatic wait_for_stats_write_data_idle_sw(  );
        begin
            @( stats_write_data_idle_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_occupancy_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_occupancy_min>.
    //
    task automatic wait_for_stats_write_data_occupancy_min(  );
        begin
            @( stats_write_data_occupancy_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_idle_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_idle_min>.
    //
    task automatic wait_for_stats_write_data_idle_min(  );
        begin
            @( stats_write_data_idle_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_occupancy_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_occupancy_max>.
    //
    task automatic wait_for_stats_write_data_occupancy_max(  );
        begin
            @( stats_write_data_occupancy_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_idle_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_idle_max>.
    //
    task automatic wait_for_stats_write_data_idle_max(  );
        begin
            @( stats_write_data_idle_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_occupancy_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_occupancy_mean>.
    //
    task automatic wait_for_stats_write_data_occupancy_mean(  );
        begin
            @( stats_write_data_occupancy_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_idle_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_idle_mean>.
    //
    task automatic wait_for_stats_write_data_idle_mean(  );
        begin
            @( stats_write_data_idle_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_bandwidth_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_read_bandwidth_step>.
    //
    task automatic wait_for_config_stats_read_bandwidth_step(  );
        begin
            @( config_stats_read_bandwidth_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_read_bandwidth_multiple>.
    //
    task automatic wait_for_config_stats_read_bandwidth_multiple(  );
        begin
            @( config_stats_read_bandwidth_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_bandwidth_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_bandwidth_sw>.
    //
    task automatic wait_for_stats_read_bandwidth_sw(  );
        begin
            @( stats_read_bandwidth_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_bandwidth_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_bandwidth_sw_updated>.
    //
    task automatic wait_for_stats_read_bandwidth_sw_updated(  );
        begin
            @( stats_read_bandwidth_sw_updated );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_bandwidth_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_bandwidth_min>.
    //
    task automatic wait_for_stats_read_bandwidth_min(  );
        begin
            @( stats_read_bandwidth_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_bandwidth_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_bandwidth_max>.
    //
    task automatic wait_for_stats_read_bandwidth_max(  );
        begin
            @( stats_read_bandwidth_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_bandwidth_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_bandwidth_mean>.
    //
    task automatic wait_for_stats_read_bandwidth_mean(  );
        begin
            @( stats_read_bandwidth_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_bandwidth_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_bandwidth_step>.
    //
    task automatic wait_for_config_stats_write_bandwidth_step(  );
        begin
            @( config_stats_write_bandwidth_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_bandwidth_multiple>.
    //
    task automatic wait_for_config_stats_write_bandwidth_multiple(  );
        begin
            @( config_stats_write_bandwidth_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_bandwidth_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_bandwidth_sw>.
    //
    task automatic wait_for_stats_write_bandwidth_sw(  );
        begin
            @( stats_write_bandwidth_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_bandwidth_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_bandwidth_sw_updated>.
    //
    task automatic wait_for_stats_write_bandwidth_sw_updated(  );
        begin
            @( stats_write_bandwidth_sw_updated );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_bandwidth_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_bandwidth_min>.
    //
    task automatic wait_for_stats_write_bandwidth_min(  );
        begin
            @( stats_write_bandwidth_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_bandwidth_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_bandwidth_max>.
    //
    task automatic wait_for_stats_write_bandwidth_max(  );
        begin
            @( stats_write_bandwidth_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_bandwidth_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_bandwidth_mean>.
    //
    task automatic wait_for_stats_write_bandwidth_mean(  );
        begin
            @( stats_write_bandwidth_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_latency_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_read_latency_step>.
    //
    task automatic wait_for_config_stats_read_latency_step(  );
        begin
            @( config_stats_read_latency_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_latency_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_read_latency_multiple>.
    //
    task automatic wait_for_config_stats_read_latency_multiple(  );
        begin
            @( config_stats_read_latency_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_latency_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_latency_sw_updated>.
    //
    task automatic wait_for_stats_read_latency_sw_updated(  );
        begin
            @( stats_read_latency_sw_updated );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_data_latency_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_data_latency_inst>.
    //
    task automatic wait_for_stats_read_address_data_latency_inst(  );
        begin
            @( stats_read_address_data_latency_inst );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_data_latency_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_data_latency_sw>.
    //
    task automatic wait_for_stats_read_address_data_latency_sw(  );
        begin
            @( stats_read_address_data_latency_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_data_latency_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_data_latency_min>.
    //
    task automatic wait_for_stats_read_address_data_latency_min(  );
        begin
            @( stats_read_address_data_latency_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_data_latency_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_data_latency_max>.
    //
    task automatic wait_for_stats_read_address_data_latency_max(  );
        begin
            @( stats_read_address_data_latency_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_data_latency_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_data_latency_mean>.
    //
    task automatic wait_for_stats_read_address_data_latency_mean(  );
        begin
            @( stats_read_address_data_latency_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_address_latency_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_address_latency_inst>.
    //
    task automatic wait_for_stats_read_address_address_latency_inst(  );
        begin
            @( stats_read_address_address_latency_inst );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_address_latency_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_address_latency_sw>.
    //
    task automatic wait_for_stats_read_address_address_latency_sw(  );
        begin
            @( stats_read_address_address_latency_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_address_latency_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_address_latency_min>.
    //
    task automatic wait_for_stats_read_address_address_latency_min(  );
        begin
            @( stats_read_address_address_latency_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_address_latency_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_address_latency_max>.
    //
    task automatic wait_for_stats_read_address_address_latency_max(  );
        begin
            @( stats_read_address_address_latency_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_address_latency_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_address_latency_mean>.
    //
    task automatic wait_for_stats_read_address_address_latency_mean(  );
        begin
            @( stats_read_address_address_latency_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_latency_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_latency_step>.
    //
    task automatic wait_for_config_stats_write_latency_step(  );
        begin
            @( config_stats_write_latency_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_latency_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_latency_multiple>.
    //
    task automatic wait_for_config_stats_write_latency_multiple(  );
        begin
            @( config_stats_write_latency_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_latency_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_latency_sw_updated>.
    //
    task automatic wait_for_stats_write_latency_sw_updated(  );
        begin
            @( stats_write_latency_sw_updated );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_data_latency_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_data_latency_inst>.
    //
    task automatic wait_for_stats_write_address_data_latency_inst(  );
        begin
            @( stats_write_address_data_latency_inst );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_data_latency_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_data_latency_sw>.
    //
    task automatic wait_for_stats_write_address_data_latency_sw(  );
        begin
            @( stats_write_address_data_latency_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_data_latency_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_data_latency_min>.
    //
    task automatic wait_for_stats_write_address_data_latency_min(  );
        begin
            @( stats_write_address_data_latency_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_data_latency_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_data_latency_max>.
    //
    task automatic wait_for_stats_write_address_data_latency_max(  );
        begin
            @( stats_write_address_data_latency_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_data_latency_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_data_latency_mean>.
    //
    task automatic wait_for_stats_write_address_data_latency_mean(  );
        begin
            @( stats_write_address_data_latency_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_response_latency_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_response_latency_inst>.
    //
    task automatic wait_for_stats_write_data_response_latency_inst(  );
        begin
            @( stats_write_data_response_latency_inst );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_response_latency_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_response_latency_sw>.
    //
    task automatic wait_for_stats_write_data_response_latency_sw(  );
        begin
            @( stats_write_data_response_latency_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_response_latency_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_response_latency_min>.
    //
    task automatic wait_for_stats_write_data_response_latency_min(  );
        begin
            @( stats_write_data_response_latency_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_response_latency_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_response_latency_max>.
    //
    task automatic wait_for_stats_write_data_response_latency_max(  );
        begin
            @( stats_write_data_response_latency_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_response_latency_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_response_latency_mean>.
    //
    task automatic wait_for_stats_write_data_response_latency_mean(  );
        begin
            @( stats_write_data_response_latency_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_address_latency_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_address_latency_inst>.
    //
    task automatic wait_for_stats_write_address_address_latency_inst(  );
        begin
            @( stats_write_address_address_latency_inst );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_address_latency_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_address_latency_sw>.
    //
    task automatic wait_for_stats_write_address_address_latency_sw(  );
        begin
            @( stats_write_address_address_latency_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_address_latency_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_address_latency_min>.
    //
    task automatic wait_for_stats_write_address_address_latency_min(  );
        begin
            @( stats_write_address_address_latency_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_address_latency_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_address_latency_max>.
    //
    task automatic wait_for_stats_write_address_address_latency_max(  );
        begin
            @( stats_write_address_address_latency_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_address_latency_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_address_latency_mean>.
    //
    task automatic wait_for_stats_write_address_address_latency_mean(  );
        begin
            @( stats_write_address_address_latency_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_address_waits_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_read_address_waits_step>.
    //
    task automatic wait_for_config_stats_read_address_waits_step(  );
        begin
            @( config_stats_read_address_waits_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_read_address_waits_multiple>.
    //
    task automatic wait_for_config_stats_read_address_waits_multiple(  );
        begin
            @( config_stats_read_address_waits_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_waits_inst>.
    //
    task automatic wait_for_stats_read_address_waits_inst(  );
        begin
            @( stats_read_address_waits_inst );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_waits_sw>.
    //
    task automatic wait_for_stats_read_address_waits_sw(  );
        begin
            @( stats_read_address_waits_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_waits_sw_updated>.
    //
    task automatic wait_for_stats_read_address_waits_sw_updated(  );
        begin
            @( stats_read_address_waits_sw_updated );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_waits_min>.
    //
    task automatic wait_for_stats_read_address_waits_min(  );
        begin
            @( stats_read_address_waits_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_waits_max>.
    //
    task automatic wait_for_stats_read_address_waits_max(  );
        begin
            @( stats_read_address_waits_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_address_waits_mean>.
    //
    task automatic wait_for_stats_read_address_waits_mean(  );
        begin
            @( stats_read_address_waits_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_data_waits_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_read_data_waits_step>.
    //
    task automatic wait_for_config_stats_read_data_waits_step(  );
        begin
            @( config_stats_read_data_waits_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_read_data_waits_multiple>.
    //
    task automatic wait_for_config_stats_read_data_waits_multiple(  );
        begin
            @( config_stats_read_data_waits_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_waits_inst>.
    //
    task automatic wait_for_stats_read_data_waits_inst(  );
        begin
            @( stats_read_data_waits_inst );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_waits_sw>.
    //
    task automatic wait_for_stats_read_data_waits_sw(  );
        begin
            @( stats_read_data_waits_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_waits_sw_updated>.
    //
    task automatic wait_for_stats_read_data_waits_sw_updated(  );
        begin
            @( stats_read_data_waits_sw_updated );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_waits_min>.
    //
    task automatic wait_for_stats_read_data_waits_min(  );
        begin
            @( stats_read_data_waits_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_waits_max>.
    //
    task automatic wait_for_stats_read_data_waits_max(  );
        begin
            @( stats_read_data_waits_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_waits_mean>.
    //
    task automatic wait_for_stats_read_data_waits_mean(  );
        begin
            @( stats_read_data_waits_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_address_waits_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_address_waits_step>.
    //
    task automatic wait_for_config_stats_write_address_waits_step(  );
        begin
            @( config_stats_write_address_waits_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_address_waits_multiple>.
    //
    task automatic wait_for_config_stats_write_address_waits_multiple(  );
        begin
            @( config_stats_write_address_waits_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_waits_inst>.
    //
    task automatic wait_for_stats_write_address_waits_inst(  );
        begin
            @( stats_write_address_waits_inst );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_waits_sw>.
    //
    task automatic wait_for_stats_write_address_waits_sw(  );
        begin
            @( stats_write_address_waits_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_waits_sw_updated>.
    //
    task automatic wait_for_stats_write_address_waits_sw_updated(  );
        begin
            @( stats_write_address_waits_sw_updated );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_waits_min>.
    //
    task automatic wait_for_stats_write_address_waits_min(  );
        begin
            @( stats_write_address_waits_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_waits_max>.
    //
    task automatic wait_for_stats_write_address_waits_max(  );
        begin
            @( stats_write_address_waits_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_address_waits_mean>.
    //
    task automatic wait_for_stats_write_address_waits_mean(  );
        begin
            @( stats_write_address_waits_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_data_waits_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_data_waits_step>.
    //
    task automatic wait_for_config_stats_write_data_waits_step(  );
        begin
            @( config_stats_write_data_waits_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_data_waits_multiple>.
    //
    task automatic wait_for_config_stats_write_data_waits_multiple(  );
        begin
            @( config_stats_write_data_waits_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_waits_inst>.
    //
    task automatic wait_for_stats_write_data_waits_inst(  );
        begin
            @( stats_write_data_waits_inst );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_waits_sw>.
    //
    task automatic wait_for_stats_write_data_waits_sw(  );
        begin
            @( stats_write_data_waits_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_waits_sw_updated>.
    //
    task automatic wait_for_stats_write_data_waits_sw_updated(  );
        begin
            @( stats_write_data_waits_sw_updated );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_waits_min>.
    //
    task automatic wait_for_stats_write_data_waits_min(  );
        begin
            @( stats_write_data_waits_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_waits_max>.
    //
    task automatic wait_for_stats_write_data_waits_max(  );
        begin
            @( stats_write_data_waits_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_waits_mean>.
    //
    task automatic wait_for_stats_write_data_waits_mean(  );
        begin
            @( stats_write_data_waits_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_response_waits_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_response_waits_step>.
    //
    task automatic wait_for_config_stats_write_response_waits_step(  );
        begin
            @( config_stats_write_response_waits_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_response_waits_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::config_stats_write_response_waits_multiple>.
    //
    task automatic wait_for_config_stats_write_response_waits_multiple(  );
        begin
            @( config_stats_write_response_waits_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_response_waits_inst>.
    //
    task automatic wait_for_stats_write_response_waits_inst(  );
        begin
            @( stats_write_response_waits_inst );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_response_waits_sw>.
    //
    task automatic wait_for_stats_write_response_waits_sw(  );
        begin
            @( stats_write_response_waits_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_sw_updated
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_response_waits_sw_updated>.
    //
    task automatic wait_for_stats_write_response_waits_sw_updated(  );
        begin
            @( stats_write_response_waits_sw_updated );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_response_waits_min>.
    //
    task automatic wait_for_stats_write_response_waits_min(  );
        begin
            @( stats_write_response_waits_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_response_waits_max>.
    //
    task automatic wait_for_stats_write_response_waits_max(  );
        begin
            @( stats_write_response_waits_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_response_waits_mean>.
    //
    task automatic wait_for_stats_write_response_waits_mean(  );
        begin
            @( stats_write_response_waits_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_rw_transaction_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_rw_transaction_last_duration>.
    //
    task automatic wait_for_stats_rw_transaction_last_duration(  );
        begin
            @( stats_rw_transaction_last_duration );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_read_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_read_last_duration>.
    //
    task automatic wait_for_stats_AXI_read_last_duration(  );
        begin
            @( stats_AXI_read_last_duration );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_AXI_write_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_AXI_write_last_duration>.
    //
    task automatic wait_for_stats_AXI_write_last_duration(  );
        begin
            @( stats_AXI_write_last_duration );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_addr_channel_phase_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_addr_channel_phase_last_duration>.
    //
    task automatic wait_for_stats_read_addr_channel_phase_last_duration(  );
        begin
            @( stats_read_addr_channel_phase_last_duration );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_burst_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_data_burst_last_duration>.
    //
    task automatic wait_for_stats_read_data_burst_last_duration(  );
        begin
            @( stats_read_data_burst_last_duration );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_channel_phase_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_read_channel_phase_last_duration>.
    //
    task automatic wait_for_stats_read_channel_phase_last_duration(  );
        begin
            @( stats_read_channel_phase_last_duration );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_addr_channel_phase_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_addr_channel_phase_last_duration>.
    //
    task automatic wait_for_stats_write_addr_channel_phase_last_duration(  );
        begin
            @( stats_write_addr_channel_phase_last_duration );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_burst_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_data_burst_last_duration>.
    //
    task automatic wait_for_stats_write_data_burst_last_duration(  );
        begin
            @( stats_write_data_burst_last_duration );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_channel_phase_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_channel_phase_last_duration>.
    //
    task automatic wait_for_stats_write_channel_phase_last_duration(  );
        begin
            @( stats_write_channel_phase_last_duration );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_resp_channel_phase_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi::stats_write_resp_channel_phase_last_duration>.
    //
    task automatic wait_for_stats_write_resp_channel_phase_last_duration(  );
        begin
            @( stats_write_resp_channel_phase_last_duration );
        end
    endtask


    //------------------------------------------------------------------------------
    // Functions to set global variables with write access
    //------------------------------------------------------------------------------


    //------------------------------------------------------------------------------
    // Function:- set_config_clk_init_value
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_clk_init_value>.
    //
    // Parameters:
    //     config_clk_init_value_param - The value to assign to variable <axi::config_clk_init_value>.
    //
    function automatic void set_config_clk_init_value( bit config_clk_init_value_param );
        config_clk_init_value = config_clk_init_value_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_clk_phase_shift
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_clk_phase_shift>.
    //
    // Parameters:
    //     config_clk_phase_shift_param - The value to assign to variable <axi::config_clk_phase_shift>.
    //
    function automatic void set_config_clk_phase_shift( int config_clk_phase_shift_param );
        config_clk_phase_shift = config_clk_phase_shift_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_clk_1st_time
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_clk_1st_time>.
    //
    // Parameters:
    //     config_clk_1st_time_param - The value to assign to variable <axi::config_clk_1st_time>.
    //
    function automatic void set_config_clk_1st_time( int config_clk_1st_time_param );
        config_clk_1st_time = config_clk_1st_time_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_clk_2nd_time
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_clk_2nd_time>.
    //
    // Parameters:
    //     config_clk_2nd_time_param - The value to assign to variable <axi::config_clk_2nd_time>.
    //
    function automatic void set_config_clk_2nd_time( int config_clk_2nd_time_param );
        config_clk_2nd_time = config_clk_2nd_time_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_setup_time
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_setup_time>.
    //
    // Parameters:
    //     config_setup_time_param - The value to assign to variable <axi::config_setup_time>.
    //
    function automatic void set_config_setup_time( int config_setup_time_param );
        config_setup_time = config_setup_time_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_hold_time
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_hold_time>.
    //
    // Parameters:
    //     config_hold_time_param - The value to assign to variable <axi::config_hold_time>.
    //
    function automatic void set_config_hold_time( int config_hold_time_param );
        config_hold_time = config_hold_time_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_max_transaction_time_factor
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_max_transaction_time_factor>.
    //
    // Parameters:
    //     config_max_transaction_time_factor_param - The value to assign to variable <axi::config_max_transaction_time_factor>.
    //
    function automatic void set_config_max_transaction_time_factor( int unsigned config_max_transaction_time_factor_param );
        config_max_transaction_time_factor = config_max_transaction_time_factor_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_timeout_max_data_transfer
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_timeout_max_data_transfer>.
    //
    // Parameters:
    //     config_timeout_max_data_transfer_param - The value to assign to variable <axi::config_timeout_max_data_transfer>.
    //
    function automatic void set_config_timeout_max_data_transfer( int config_timeout_max_data_transfer_param );
        config_timeout_max_data_transfer = config_timeout_max_data_transfer_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_burst_timeout_factor
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_burst_timeout_factor>.
    //
    // Parameters:
    //     config_burst_timeout_factor_param - The value to assign to variable <axi::config_burst_timeout_factor>.
    //
    function automatic void set_config_burst_timeout_factor( int unsigned config_burst_timeout_factor_param );
        config_burst_timeout_factor = config_burst_timeout_factor_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_max_latency_AWVALID_assertion_to_AWREADY
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_max_latency_AWVALID_assertion_to_AWREADY>.
    //
    // Parameters:
    //     config_max_latency_AWVALID_assertion_to_AWREADY_param - The value to assign to variable <axi::config_max_latency_AWVALID_assertion_to_AWREADY>.
    //
    function automatic void set_config_max_latency_AWVALID_assertion_to_AWREADY( int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
        config_max_latency_AWVALID_assertion_to_AWREADY = config_max_latency_AWVALID_assertion_to_AWREADY_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_max_latency_ARVALID_assertion_to_ARREADY
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_max_latency_ARVALID_assertion_to_ARREADY>.
    //
    // Parameters:
    //     config_max_latency_ARVALID_assertion_to_ARREADY_param - The value to assign to variable <axi::config_max_latency_ARVALID_assertion_to_ARREADY>.
    //
    function automatic void set_config_max_latency_ARVALID_assertion_to_ARREADY( int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
        config_max_latency_ARVALID_assertion_to_ARREADY = config_max_latency_ARVALID_assertion_to_ARREADY_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_max_latency_RVALID_assertion_to_RREADY
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_max_latency_RVALID_assertion_to_RREADY>.
    //
    // Parameters:
    //     config_max_latency_RVALID_assertion_to_RREADY_param - The value to assign to variable <axi::config_max_latency_RVALID_assertion_to_RREADY>.
    //
    function automatic void set_config_max_latency_RVALID_assertion_to_RREADY( int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
        config_max_latency_RVALID_assertion_to_RREADY = config_max_latency_RVALID_assertion_to_RREADY_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_max_latency_BVALID_assertion_to_BREADY
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_max_latency_BVALID_assertion_to_BREADY>.
    //
    // Parameters:
    //     config_max_latency_BVALID_assertion_to_BREADY_param - The value to assign to variable <axi::config_max_latency_BVALID_assertion_to_BREADY>.
    //
    function automatic void set_config_max_latency_BVALID_assertion_to_BREADY( int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
        config_max_latency_BVALID_assertion_to_BREADY = config_max_latency_BVALID_assertion_to_BREADY_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_max_latency_WVALID_assertion_to_WREADY
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_max_latency_WVALID_assertion_to_WREADY>.
    //
    // Parameters:
    //     config_max_latency_WVALID_assertion_to_WREADY_param - The value to assign to variable <axi::config_max_latency_WVALID_assertion_to_WREADY>.
    //
    function automatic void set_config_max_latency_WVALID_assertion_to_WREADY( int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
        config_max_latency_WVALID_assertion_to_WREADY = config_max_latency_WVALID_assertion_to_WREADY_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_write_ctrl_first_ratio
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_write_ctrl_first_ratio>.
    //
    // Parameters:
    //     config_write_ctrl_first_ratio_param - The value to assign to variable <axi::config_write_ctrl_first_ratio>.
    //
    function automatic void set_config_write_ctrl_first_ratio( int config_write_ctrl_first_ratio_param );
        config_write_ctrl_first_ratio = config_write_ctrl_first_ratio_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_write_data_first_ratio
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_write_data_first_ratio>.
    //
    // Parameters:
    //     config_write_data_first_ratio_param - The value to assign to variable <axi::config_write_data_first_ratio>.
    //
    function automatic void set_config_write_data_first_ratio( int config_write_data_first_ratio_param );
        config_write_data_first_ratio = config_write_data_first_ratio_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_write_ctrl_to_data_mintime
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_write_ctrl_to_data_mintime>.
    //
    // Parameters:
    //     config_write_ctrl_to_data_mintime_param - The value to assign to variable <axi::config_write_ctrl_to_data_mintime>.
    //
    function automatic void set_config_write_ctrl_to_data_mintime( int unsigned config_write_ctrl_to_data_mintime_param );
        config_write_ctrl_to_data_mintime = config_write_ctrl_to_data_mintime_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_write_data_to_ctrl_mintime
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_write_data_to_ctrl_mintime>.
    //
    // Parameters:
    //     config_write_data_to_ctrl_mintime_param - The value to assign to variable <axi::config_write_data_to_ctrl_mintime>.
    //
    function automatic void set_config_write_data_to_ctrl_mintime( int unsigned config_write_data_to_ctrl_mintime_param );
        config_write_data_to_ctrl_mintime = config_write_data_to_ctrl_mintime_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_master_write_delay
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_master_write_delay>.
    //
    // Parameters:
    //     config_master_write_delay_param - The value to assign to variable <axi::config_master_write_delay>.
    //
    function automatic void set_config_master_write_delay( bit config_master_write_delay_param );
        config_master_write_delay = config_master_write_delay_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_reset_low_clocks
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_reset_low_clocks>.
    //
    // Parameters:
    //     config_reset_low_clocks_param - The value to assign to variable <axi::config_reset_low_clocks>.
    //
    function automatic void set_config_reset_low_clocks( int config_reset_low_clocks_param );
        config_reset_low_clocks = config_reset_low_clocks_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_reset_hold_time
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_reset_hold_time>.
    //
    // Parameters:
    //     config_reset_hold_time_param - The value to assign to variable <axi::config_reset_hold_time>.
    //
    function automatic void set_config_reset_hold_time( int config_reset_hold_time_param );
        config_reset_hold_time = config_reset_hold_time_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_protect_ready
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_protect_ready>.
    //
    // Parameters:
    //     config_protect_ready_param - The value to assign to variable <axi::config_protect_ready>.
    //
    function automatic void set_config_protect_ready( bit config_protect_ready_param );
        config_protect_ready = config_protect_ready_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_user_sideband
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_user_sideband>.
    //
    // Parameters:
    //     config_enable_user_sideband_param - The value to assign to variable <axi::config_enable_user_sideband>.
    //
    function automatic void set_config_enable_user_sideband( bit config_enable_user_sideband_param );
        config_enable_user_sideband = config_enable_user_sideband_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_extended_length_enable
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_extended_length_enable>.
    //
    // Parameters:
    //     config_extended_length_enable_param - The value to assign to variable <axi::config_extended_length_enable>.
    //
    function automatic void set_config_extended_length_enable( bit config_extended_length_enable_param );
        config_extended_length_enable = config_extended_length_enable_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_burst_reserved_value
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_burst_reserved_value>.
    //
    // Parameters:
    //     config_enable_burst_reserved_value_param - The value to assign to variable <axi::config_enable_burst_reserved_value>.
    //
    function automatic void set_config_enable_burst_reserved_value( bit config_enable_burst_reserved_value_param );
        config_enable_burst_reserved_value = config_enable_burst_reserved_value_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_lock_reserved_value
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_lock_reserved_value>.
    //
    // Parameters:
    //     config_enable_lock_reserved_value_param - The value to assign to variable <axi::config_enable_lock_reserved_value>.
    //
    function automatic void set_config_enable_lock_reserved_value( bit config_enable_lock_reserved_value_param );
        config_enable_lock_reserved_value = config_enable_lock_reserved_value_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_cache_reserved_value
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_cache_reserved_value>.
    //
    // Parameters:
    //     config_enable_cache_reserved_value_param - The value to assign to variable <axi::config_enable_cache_reserved_value>.
    //
    function automatic void set_config_enable_cache_reserved_value( bit config_enable_cache_reserved_value_param );
        config_enable_cache_reserved_value = config_enable_cache_reserved_value_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_all_assertions
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_all_assertions>.
    //
    // Parameters:
    //     config_enable_all_assertions_param - The value to assign to variable <axi::config_enable_all_assertions>.
    //
    function automatic void set_config_enable_all_assertions( bit config_enable_all_assertions_param );
        config_enable_all_assertions = config_enable_all_assertions_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_assertion
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_assertion>.
    //
    // Parameters:
    //     config_enable_assertion_param - The value to assign to variable <axi::config_enable_assertion>.
    //
    function automatic void set_config_enable_assertion( bit [255:0] config_enable_assertion_param );
        config_enable_assertion = config_enable_assertion_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_assertion_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi::config_enable_assertion>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_enable_assertion_param - The value to assign to variable <axi::config_enable_assertion>.
    //
    function automatic void set_config_enable_assertion_index1( int _this_dot_1, bit  config_enable_assertion_param );
        config_enable_assertion[_this_dot_1] = config_enable_assertion_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_error
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_error>.
    //
    // Parameters:
    //     config_enable_error_param - The value to assign to variable <axi::config_enable_error>.
    //
    function automatic void set_config_enable_error( bit [255:0] config_enable_error_param );
        config_enable_error = config_enable_error_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_error_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi::config_enable_error>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_enable_error_param - The value to assign to variable <axi::config_enable_error>.
    //
    function automatic void set_config_enable_error_index1( int _this_dot_1, bit  config_enable_error_param );
        config_enable_error[_this_dot_1] = config_enable_error_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_errors
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_errors>.
    //
    // Parameters:
    //     config_enable_errors_param - The value to assign to variable <axi::config_enable_errors>.
    //
    function automatic void set_config_enable_errors( bit config_enable_errors_param );
        config_enable_errors = config_enable_errors_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_all_assertion_errors
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_all_assertion_errors>.
    //
    // Parameters:
    //     config_enable_all_assertion_errors_param - The value to assign to variable <axi::config_enable_all_assertion_errors>.
    //
    function automatic void set_config_enable_all_assertion_errors( bit config_enable_all_assertion_errors_param );
        config_enable_all_assertion_errors = config_enable_all_assertion_errors_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_abstraction_level
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_abstraction_level>.
    //
    // Parameters:
    //     config_abstraction_level_param - The value to assign to variable <axi::config_abstraction_level>.
    //
    function automatic void set_config_abstraction_level( axi_abstraction_level_e config_abstraction_level_param );
        config_abstraction_level = config_abstraction_level_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_slave_start_addr
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_slave_start_addr>.
    //
    // Parameters:
    //     config_slave_start_addr_param - The value to assign to variable <axi::config_slave_start_addr>.
    //
    function automatic void set_config_slave_start_addr( bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param );
        config_slave_start_addr = config_slave_start_addr_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_slave_start_addr_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi::config_slave_start_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_slave_start_addr_param - The value to assign to variable <axi::config_slave_start_addr>.
    //
    function automatic void set_config_slave_start_addr_index1( int _this_dot_1, bit  config_slave_start_addr_param );
        config_slave_start_addr[_this_dot_1] = config_slave_start_addr_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_slave_end_addr
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_slave_end_addr>.
    //
    // Parameters:
    //     config_slave_end_addr_param - The value to assign to variable <axi::config_slave_end_addr>.
    //
    function automatic void set_config_slave_end_addr( bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param );
        config_slave_end_addr = config_slave_end_addr_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_slave_end_addr_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi::config_slave_end_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_slave_end_addr_param - The value to assign to variable <axi::config_slave_end_addr>.
    //
    function automatic void set_config_slave_end_addr_index1( int _this_dot_1, bit  config_slave_end_addr_param );
        config_slave_end_addr[_this_dot_1] = config_slave_end_addr_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_slave_addr_range_in_bfm
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_slave_addr_range_in_bfm>.
    //
    // Parameters:
    //     config_enable_slave_addr_range_in_bfm_param - The value to assign to variable <axi::config_enable_slave_addr_range_in_bfm>.
    //
    function automatic void set_config_enable_slave_addr_range_in_bfm( bit config_enable_slave_addr_range_in_bfm_param );
        config_enable_slave_addr_range_in_bfm = config_enable_slave_addr_range_in_bfm_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_read_data_reordering_depth
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_read_data_reordering_depth>.
    //
    // Parameters:
    //     config_read_data_reordering_depth_param - The value to assign to variable <axi::config_read_data_reordering_depth>.
    //
    function automatic void set_config_read_data_reordering_depth( int unsigned config_read_data_reordering_depth_param );
        config_read_data_reordering_depth = config_read_data_reordering_depth_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_read_data_reordering_depth_in_bfm
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_enable_read_data_reordering_depth_in_bfm>.
    //
    // Parameters:
    //     config_enable_read_data_reordering_depth_in_bfm_param - The value to assign to variable <axi::config_enable_read_data_reordering_depth_in_bfm>.
    //
    function automatic void set_config_enable_read_data_reordering_depth_in_bfm( bit config_enable_read_data_reordering_depth_in_bfm_param );
        config_enable_read_data_reordering_depth_in_bfm = config_enable_read_data_reordering_depth_in_bfm_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_awid_wid_mismatch
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_awid_wid_mismatch>.
    //
    // Parameters:
    //     config_awid_wid_mismatch_param - The value to assign to variable <axi::config_awid_wid_mismatch>.
    //
    function automatic void set_config_awid_wid_mismatch( bit config_awid_wid_mismatch_param );
        config_awid_wid_mismatch = config_awid_wid_mismatch_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_length_last_mismatch_error
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_length_last_mismatch_error>.
    //
    // Parameters:
    //     config_length_last_mismatch_error_param - The value to assign to variable <axi::config_length_last_mismatch_error>.
    //
    function automatic void set_config_length_last_mismatch_error( bit config_length_last_mismatch_error_param );
        config_length_last_mismatch_error = config_length_last_mismatch_error_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_master_error_position
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_master_error_position>.
    //
    // Parameters:
    //     config_master_error_position_param - The value to assign to variable <axi::config_master_error_position>.
    //
    function automatic void set_config_master_error_position( axi_error_e config_master_error_position_param );
        config_master_error_position = config_master_error_position_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_dummy_var
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::dummy_var>.
    //
    // Parameters:
    //     dummy_var_param - The value to assign to variable <axi::dummy_var>.
    //
    function automatic void set_dummy_var( axi_assertion_type_e dummy_var_param );
        dummy_var = dummy_var_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_wlast_length
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_wlast_length>.
    //
    // Parameters:
    //     config_wlast_length_param - The value to assign to variable <axi::config_wlast_length>.
    //
    function automatic void set_config_wlast_length( int config_wlast_length_param );
        config_wlast_length = config_wlast_length_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_wid_for_awid_not_matching
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_wid_for_awid_not_matching>.
    //
    // Parameters:
    //     config_wid_for_awid_not_matching_param - The value to assign to variable <axi::config_wid_for_awid_not_matching>.
    //
    function automatic void set_config_wid_for_awid_not_matching( bit [((AXI_ID_WIDTH) - 1):0]  config_wid_for_awid_not_matching_param );
        config_wid_for_awid_not_matching = config_wid_for_awid_not_matching_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_wid_for_awid_not_matching_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi::config_wid_for_awid_not_matching>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_wid_for_awid_not_matching_param - The value to assign to variable <axi::config_wid_for_awid_not_matching>.
    //
    function automatic void set_config_wid_for_awid_not_matching_index1( int _this_dot_1, bit  config_wid_for_awid_not_matching_param );
        config_wid_for_awid_not_matching[_this_dot_1] = config_wid_for_awid_not_matching_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_support_exclusive_access
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_support_exclusive_access>.
    //
    // Parameters:
    //     config_support_exclusive_access_param - The value to assign to variable <axi::config_support_exclusive_access>.
    //
    function automatic void set_config_support_exclusive_access( bit config_support_exclusive_access_param );
        config_support_exclusive_access = config_support_exclusive_access_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_write_data_interleaving_depth
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_write_data_interleaving_depth>.
    //
    // Parameters:
    //     config_write_data_interleaving_depth_param - The value to assign to variable <axi::config_write_data_interleaving_depth>.
    //
    function automatic void set_config_write_data_interleaving_depth( int config_write_data_interleaving_depth_param );
        config_write_data_interleaving_depth = config_write_data_interleaving_depth_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_status_master_error
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::status_master_error>.
    //
    // Parameters:
    //     status_master_error_param - The value to assign to variable <axi::status_master_error>.
    //
    function automatic void set_status_master_error( bit [15:0] status_master_error_param );
        status_master_error = status_master_error_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_status_master_error_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi::status_master_error>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     status_master_error_param - The value to assign to variable <axi::status_master_error>.
    //
    function automatic void set_status_master_error_index1( int _this_dot_1, bit  status_master_error_param );
        status_master_error[_this_dot_1] = status_master_error_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_check_total_num_wdata_outstanding
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::check_total_num_wdata_outstanding>.
    //
    // Parameters:
    //     check_total_num_wdata_outstanding_param - The value to assign to variable <axi::check_total_num_wdata_outstanding>.
    //
    function automatic void set_check_total_num_wdata_outstanding( bit check_total_num_wdata_outstanding_param );
        check_total_num_wdata_outstanding = check_total_num_wdata_outstanding_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_total_num_wdata_outstanding
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::total_num_wdata_outstanding>.
    //
    // Parameters:
    //     total_num_wdata_outstanding_param - The value to assign to variable <axi::total_num_wdata_outstanding>.
    //
    function automatic void set_total_num_wdata_outstanding( int total_num_wdata_outstanding_param );
        total_num_wdata_outstanding = total_num_wdata_outstanding_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_check_max_num_wdata_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::check_max_num_wdata_outstanding_per_id>.
    //
    // Parameters:
    //     check_max_num_wdata_outstanding_per_id_param - The value to assign to variable <axi::check_max_num_wdata_outstanding_per_id>.
    //
    function automatic void set_check_max_num_wdata_outstanding_per_id( bit check_max_num_wdata_outstanding_per_id_param );
        check_max_num_wdata_outstanding_per_id = check_max_num_wdata_outstanding_per_id_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_max_num_wdata_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::max_num_wdata_outstanding_per_id>.
    //
    // Parameters:
    //     max_num_wdata_outstanding_per_id_param - The value to assign to variable <axi::max_num_wdata_outstanding_per_id>.
    //
    function automatic void set_max_num_wdata_outstanding_per_id( int max_num_wdata_outstanding_per_id_param );
        max_num_wdata_outstanding_per_id = max_num_wdata_outstanding_per_id_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_check_max_num_waddr_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::check_max_num_waddr_outstanding_per_id>.
    //
    // Parameters:
    //     check_max_num_waddr_outstanding_per_id_param - The value to assign to variable <axi::check_max_num_waddr_outstanding_per_id>.
    //
    function automatic void set_check_max_num_waddr_outstanding_per_id( bit check_max_num_waddr_outstanding_per_id_param );
        check_max_num_waddr_outstanding_per_id = check_max_num_waddr_outstanding_per_id_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_max_num_waddr_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::max_num_waddr_outstanding_per_id>.
    //
    // Parameters:
    //     max_num_waddr_outstanding_per_id_param - The value to assign to variable <axi::max_num_waddr_outstanding_per_id>.
    //
    function automatic void set_max_num_waddr_outstanding_per_id( int max_num_waddr_outstanding_per_id_param );
        max_num_waddr_outstanding_per_id = max_num_waddr_outstanding_per_id_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_check_total_num_waddr_outstanding
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::check_total_num_waddr_outstanding>.
    //
    // Parameters:
    //     check_total_num_waddr_outstanding_param - The value to assign to variable <axi::check_total_num_waddr_outstanding>.
    //
    function automatic void set_check_total_num_waddr_outstanding( bit check_total_num_waddr_outstanding_param );
        check_total_num_waddr_outstanding = check_total_num_waddr_outstanding_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_total_num_waddr_outstanding
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::total_num_waddr_outstanding>.
    //
    // Parameters:
    //     total_num_waddr_outstanding_param - The value to assign to variable <axi::total_num_waddr_outstanding>.
    //
    function automatic void set_total_num_waddr_outstanding( int total_num_waddr_outstanding_param );
        total_num_waddr_outstanding = total_num_waddr_outstanding_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_status_outstanding_num_for_waddr
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::status_outstanding_num_for_waddr>.
    //
    // Parameters:
    //     status_outstanding_num_for_waddr_param - The value to assign to variable <axi::status_outstanding_num_for_waddr>.
    //
    function automatic void set_status_outstanding_num_for_waddr( int status_outstanding_num_for_waddr_param );
        status_outstanding_num_for_waddr = status_outstanding_num_for_waddr_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_start_finding_outstanding_waddr
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::start_finding_outstanding_waddr>.
    //
    // Parameters:
    //     start_finding_outstanding_waddr_param - The value to assign to variable <axi::start_finding_outstanding_waddr>.
    //
    function automatic void set_start_finding_outstanding_waddr( bit start_finding_outstanding_waddr_param );
        start_finding_outstanding_waddr = start_finding_outstanding_waddr_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_status_outstanding_num_for_wdata
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::status_outstanding_num_for_wdata>.
    //
    // Parameters:
    //     status_outstanding_num_for_wdata_param - The value to assign to variable <axi::status_outstanding_num_for_wdata>.
    //
    function automatic void set_status_outstanding_num_for_wdata( int status_outstanding_num_for_wdata_param );
        status_outstanding_num_for_wdata = status_outstanding_num_for_wdata_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_start_finding_outstanding_wdata
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::start_finding_outstanding_wdata>.
    //
    // Parameters:
    //     start_finding_outstanding_wdata_param - The value to assign to variable <axi::start_finding_outstanding_wdata>.
    //
    function automatic void set_start_finding_outstanding_wdata( bit start_finding_outstanding_wdata_param );
        start_finding_outstanding_wdata = start_finding_outstanding_wdata_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_find_waddr_outstanding_for_wid
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::find_waddr_outstanding_for_wid>.
    //
    // Parameters:
    //     find_waddr_outstanding_for_wid_param - The value to assign to variable <axi::find_waddr_outstanding_for_wid>.
    //
    function automatic void set_find_waddr_outstanding_for_wid( bit [((AXI_ID_WIDTH) - 1):0]  find_waddr_outstanding_for_wid_param );
        find_waddr_outstanding_for_wid = find_waddr_outstanding_for_wid_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_find_waddr_outstanding_for_wid_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi::find_waddr_outstanding_for_wid>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     find_waddr_outstanding_for_wid_param - The value to assign to variable <axi::find_waddr_outstanding_for_wid>.
    //
    function automatic void set_find_waddr_outstanding_for_wid_index1( int _this_dot_1, bit  find_waddr_outstanding_for_wid_param );
        find_waddr_outstanding_for_wid[_this_dot_1] = find_waddr_outstanding_for_wid_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_find_wdata_outstanding_for_wid
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::find_wdata_outstanding_for_wid>.
    //
    // Parameters:
    //     find_wdata_outstanding_for_wid_param - The value to assign to variable <axi::find_wdata_outstanding_for_wid>.
    //
    function automatic void set_find_wdata_outstanding_for_wid( bit [((AXI_ID_WIDTH) - 1):0]  find_wdata_outstanding_for_wid_param );
        find_wdata_outstanding_for_wid = find_wdata_outstanding_for_wid_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_find_wdata_outstanding_for_wid_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi::find_wdata_outstanding_for_wid>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     find_wdata_outstanding_for_wid_param - The value to assign to variable <axi::find_wdata_outstanding_for_wid>.
    //
    function automatic void set_find_wdata_outstanding_for_wid_index1( int _this_dot_1, bit  find_wdata_outstanding_for_wid_param );
        find_wdata_outstanding_for_wid[_this_dot_1] = find_wdata_outstanding_for_wid_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_change_in_wdata_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::change_in_wdata_outstanding_per_id>.
    //
    // Parameters:
    //     change_in_wdata_outstanding_per_id_param - The value to assign to variable <axi::change_in_wdata_outstanding_per_id>.
    //
    function automatic void set_change_in_wdata_outstanding_per_id( bit change_in_wdata_outstanding_per_id_param );
        change_in_wdata_outstanding_per_id = change_in_wdata_outstanding_per_id_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_start_finding_change_in_wdata
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::start_finding_change_in_wdata>.
    //
    // Parameters:
    //     start_finding_change_in_wdata_param - The value to assign to variable <axi::start_finding_change_in_wdata>.
    //
    function automatic void set_start_finding_change_in_wdata( bit start_finding_change_in_wdata_param );
        start_finding_change_in_wdata = start_finding_change_in_wdata_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_find_change_in_wdata_outstanding_for_wid
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::find_change_in_wdata_outstanding_for_wid>.
    //
    // Parameters:
    //     find_change_in_wdata_outstanding_for_wid_param - The value to assign to variable <axi::find_change_in_wdata_outstanding_for_wid>.
    //
    function automatic void set_find_change_in_wdata_outstanding_for_wid( bit [((AXI_ID_WIDTH) - 1):0]  find_change_in_wdata_outstanding_for_wid_param );
        find_change_in_wdata_outstanding_for_wid = find_change_in_wdata_outstanding_for_wid_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_find_change_in_wdata_outstanding_for_wid_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi::find_change_in_wdata_outstanding_for_wid>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     find_change_in_wdata_outstanding_for_wid_param - The value to assign to variable <axi::find_change_in_wdata_outstanding_for_wid>.
    //
    function automatic void set_find_change_in_wdata_outstanding_for_wid_index1( int _this_dot_1, bit  find_change_in_wdata_outstanding_for_wid_param );
        find_change_in_wdata_outstanding_for_wid[_this_dot_1] = find_change_in_wdata_outstanding_for_wid_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_max_outstanding_wr
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_max_outstanding_wr>.
    //
    // Parameters:
    //     config_max_outstanding_wr_param - The value to assign to variable <axi::config_max_outstanding_wr>.
    //
    function automatic void set_config_max_outstanding_wr( int config_max_outstanding_wr_param );
        config_max_outstanding_wr = config_max_outstanding_wr_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_max_outstanding_rd
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_max_outstanding_rd>.
    //
    // Parameters:
    //     config_max_outstanding_rd_param - The value to assign to variable <axi::config_max_outstanding_rd>.
    //
    function automatic void set_config_max_outstanding_rd( int config_max_outstanding_rd_param );
        config_max_outstanding_rd = config_max_outstanding_rd_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_error_on_deleted_valid_cycles
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_error_on_deleted_valid_cycles>.
    //
    // Parameters:
    //     config_error_on_deleted_valid_cycles_param - The value to assign to variable <axi::config_error_on_deleted_valid_cycles>.
    //
    function automatic void set_config_error_on_deleted_valid_cycles( bit config_error_on_deleted_valid_cycles_param );
        config_error_on_deleted_valid_cycles = config_error_on_deleted_valid_cycles_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable>.
    //
    // Parameters:
    //     config_stats_enable_param - The value to assign to variable <axi::config_stats_enable>.
    //
    function automatic void set_config_stats_enable( bit config_stats_enable_param );
        config_stats_enable = config_stats_enable_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_AXI_read_occupancy
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_AXI_read_occupancy>.
    //
    // Parameters:
    //     config_stats_enable_AXI_read_occupancy_param - The value to assign to variable <axi::config_stats_enable_AXI_read_occupancy>.
    //
    function automatic void set_config_stats_enable_AXI_read_occupancy( bit config_stats_enable_AXI_read_occupancy_param );
        config_stats_enable_AXI_read_occupancy = config_stats_enable_AXI_read_occupancy_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_AXI_write_occupancy
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_AXI_write_occupancy>.
    //
    // Parameters:
    //     config_stats_enable_AXI_write_occupancy_param - The value to assign to variable <axi::config_stats_enable_AXI_write_occupancy>.
    //
    function automatic void set_config_stats_enable_AXI_write_occupancy( bit config_stats_enable_AXI_write_occupancy_param );
        config_stats_enable_AXI_write_occupancy = config_stats_enable_AXI_write_occupancy_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_data_occupancy
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_read_data_occupancy>.
    //
    // Parameters:
    //     config_stats_enable_read_data_occupancy_param - The value to assign to variable <axi::config_stats_enable_read_data_occupancy>.
    //
    function automatic void set_config_stats_enable_read_data_occupancy( bit config_stats_enable_read_data_occupancy_param );
        config_stats_enable_read_data_occupancy = config_stats_enable_read_data_occupancy_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_data_occupancy
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_write_data_occupancy>.
    //
    // Parameters:
    //     config_stats_enable_write_data_occupancy_param - The value to assign to variable <axi::config_stats_enable_write_data_occupancy>.
    //
    function automatic void set_config_stats_enable_write_data_occupancy( bit config_stats_enable_write_data_occupancy_param );
        config_stats_enable_write_data_occupancy = config_stats_enable_write_data_occupancy_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_latency
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_read_latency>.
    //
    // Parameters:
    //     config_stats_enable_read_latency_param - The value to assign to variable <axi::config_stats_enable_read_latency>.
    //
    function automatic void set_config_stats_enable_read_latency( bit config_stats_enable_read_latency_param );
        config_stats_enable_read_latency = config_stats_enable_read_latency_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_latency
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_write_latency>.
    //
    // Parameters:
    //     config_stats_enable_write_latency_param - The value to assign to variable <axi::config_stats_enable_write_latency>.
    //
    function automatic void set_config_stats_enable_write_latency( bit config_stats_enable_write_latency_param );
        config_stats_enable_write_latency = config_stats_enable_write_latency_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_address_waits
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_read_address_waits>.
    //
    // Parameters:
    //     config_stats_enable_read_address_waits_param - The value to assign to variable <axi::config_stats_enable_read_address_waits>.
    //
    function automatic void set_config_stats_enable_read_address_waits( bit config_stats_enable_read_address_waits_param );
        config_stats_enable_read_address_waits = config_stats_enable_read_address_waits_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_data_waits
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_read_data_waits>.
    //
    // Parameters:
    //     config_stats_enable_read_data_waits_param - The value to assign to variable <axi::config_stats_enable_read_data_waits>.
    //
    function automatic void set_config_stats_enable_read_data_waits( bit config_stats_enable_read_data_waits_param );
        config_stats_enable_read_data_waits = config_stats_enable_read_data_waits_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_address_waits
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_write_address_waits>.
    //
    // Parameters:
    //     config_stats_enable_write_address_waits_param - The value to assign to variable <axi::config_stats_enable_write_address_waits>.
    //
    function automatic void set_config_stats_enable_write_address_waits( bit config_stats_enable_write_address_waits_param );
        config_stats_enable_write_address_waits = config_stats_enable_write_address_waits_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_data_waits
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_write_data_waits>.
    //
    // Parameters:
    //     config_stats_enable_write_data_waits_param - The value to assign to variable <axi::config_stats_enable_write_data_waits>.
    //
    function automatic void set_config_stats_enable_write_data_waits( bit config_stats_enable_write_data_waits_param );
        config_stats_enable_write_data_waits = config_stats_enable_write_data_waits_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_response_waits
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_write_response_waits>.
    //
    // Parameters:
    //     config_stats_enable_write_response_waits_param - The value to assign to variable <axi::config_stats_enable_write_response_waits>.
    //
    function automatic void set_config_stats_enable_write_response_waits( bit config_stats_enable_write_response_waits_param );
        config_stats_enable_write_response_waits = config_stats_enable_write_response_waits_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_bandwidth
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_read_bandwidth>.
    //
    // Parameters:
    //     config_stats_enable_read_bandwidth_param - The value to assign to variable <axi::config_stats_enable_read_bandwidth>.
    //
    function automatic void set_config_stats_enable_read_bandwidth( bit config_stats_enable_read_bandwidth_param );
        config_stats_enable_read_bandwidth = config_stats_enable_read_bandwidth_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_bandwidth
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_enable_write_bandwidth>.
    //
    // Parameters:
    //     config_stats_enable_write_bandwidth_param - The value to assign to variable <axi::config_stats_enable_write_bandwidth>.
    //
    function automatic void set_config_stats_enable_write_bandwidth( bit config_stats_enable_write_bandwidth_param );
        config_stats_enable_write_bandwidth = config_stats_enable_write_bandwidth_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_AXI_read_occupancy_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_AXI_read_occupancy_step>.
    //
    // Parameters:
    //     config_stats_AXI_read_occupancy_step_param - The value to assign to variable <axi::config_stats_AXI_read_occupancy_step>.
    //
    function automatic void set_config_stats_AXI_read_occupancy_step( int config_stats_AXI_read_occupancy_step_param );
        config_stats_AXI_read_occupancy_step = config_stats_AXI_read_occupancy_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_AXI_read_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_AXI_read_occupancy_multiple>.
    //
    // Parameters:
    //     config_stats_AXI_read_occupancy_multiple_param - The value to assign to variable <axi::config_stats_AXI_read_occupancy_multiple>.
    //
    function automatic void set_config_stats_AXI_read_occupancy_multiple( int config_stats_AXI_read_occupancy_multiple_param );
        config_stats_AXI_read_occupancy_multiple = config_stats_AXI_read_occupancy_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_AXI_write_occupancy_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_AXI_write_occupancy_step>.
    //
    // Parameters:
    //     config_stats_AXI_write_occupancy_step_param - The value to assign to variable <axi::config_stats_AXI_write_occupancy_step>.
    //
    function automatic void set_config_stats_AXI_write_occupancy_step( int config_stats_AXI_write_occupancy_step_param );
        config_stats_AXI_write_occupancy_step = config_stats_AXI_write_occupancy_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_AXI_write_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_AXI_write_occupancy_multiple>.
    //
    // Parameters:
    //     config_stats_AXI_write_occupancy_multiple_param - The value to assign to variable <axi::config_stats_AXI_write_occupancy_multiple>.
    //
    function automatic void set_config_stats_AXI_write_occupancy_multiple( int config_stats_AXI_write_occupancy_multiple_param );
        config_stats_AXI_write_occupancy_multiple = config_stats_AXI_write_occupancy_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_read_data_occupancy_step>.
    //
    // Parameters:
    //     config_stats_read_data_occupancy_step_param - The value to assign to variable <axi::config_stats_read_data_occupancy_step>.
    //
    function automatic void set_config_stats_read_data_occupancy_step( int config_stats_read_data_occupancy_step_param );
        config_stats_read_data_occupancy_step = config_stats_read_data_occupancy_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_read_data_occupancy_multiple>.
    //
    // Parameters:
    //     config_stats_read_data_occupancy_multiple_param - The value to assign to variable <axi::config_stats_read_data_occupancy_multiple>.
    //
    function automatic void set_config_stats_read_data_occupancy_multiple( int config_stats_read_data_occupancy_multiple_param );
        config_stats_read_data_occupancy_multiple = config_stats_read_data_occupancy_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_data_occupancy_step>.
    //
    // Parameters:
    //     config_stats_write_data_occupancy_step_param - The value to assign to variable <axi::config_stats_write_data_occupancy_step>.
    //
    function automatic void set_config_stats_write_data_occupancy_step( int config_stats_write_data_occupancy_step_param );
        config_stats_write_data_occupancy_step = config_stats_write_data_occupancy_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_data_occupancy_multiple>.
    //
    // Parameters:
    //     config_stats_write_data_occupancy_multiple_param - The value to assign to variable <axi::config_stats_write_data_occupancy_multiple>.
    //
    function automatic void set_config_stats_write_data_occupancy_multiple( int config_stats_write_data_occupancy_multiple_param );
        config_stats_write_data_occupancy_multiple = config_stats_write_data_occupancy_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_bandwidth_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_read_bandwidth_step>.
    //
    // Parameters:
    //     config_stats_read_bandwidth_step_param - The value to assign to variable <axi::config_stats_read_bandwidth_step>.
    //
    function automatic void set_config_stats_read_bandwidth_step( int config_stats_read_bandwidth_step_param );
        config_stats_read_bandwidth_step = config_stats_read_bandwidth_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_read_bandwidth_multiple>.
    //
    // Parameters:
    //     config_stats_read_bandwidth_multiple_param - The value to assign to variable <axi::config_stats_read_bandwidth_multiple>.
    //
    function automatic void set_config_stats_read_bandwidth_multiple( int config_stats_read_bandwidth_multiple_param );
        config_stats_read_bandwidth_multiple = config_stats_read_bandwidth_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_bandwidth_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_bandwidth_step>.
    //
    // Parameters:
    //     config_stats_write_bandwidth_step_param - The value to assign to variable <axi::config_stats_write_bandwidth_step>.
    //
    function automatic void set_config_stats_write_bandwidth_step( int config_stats_write_bandwidth_step_param );
        config_stats_write_bandwidth_step = config_stats_write_bandwidth_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_bandwidth_multiple>.
    //
    // Parameters:
    //     config_stats_write_bandwidth_multiple_param - The value to assign to variable <axi::config_stats_write_bandwidth_multiple>.
    //
    function automatic void set_config_stats_write_bandwidth_multiple( int config_stats_write_bandwidth_multiple_param );
        config_stats_write_bandwidth_multiple = config_stats_write_bandwidth_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_latency_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_read_latency_step>.
    //
    // Parameters:
    //     config_stats_read_latency_step_param - The value to assign to variable <axi::config_stats_read_latency_step>.
    //
    function automatic void set_config_stats_read_latency_step( int config_stats_read_latency_step_param );
        config_stats_read_latency_step = config_stats_read_latency_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_latency_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_read_latency_multiple>.
    //
    // Parameters:
    //     config_stats_read_latency_multiple_param - The value to assign to variable <axi::config_stats_read_latency_multiple>.
    //
    function automatic void set_config_stats_read_latency_multiple( int config_stats_read_latency_multiple_param );
        config_stats_read_latency_multiple = config_stats_read_latency_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_latency_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_latency_step>.
    //
    // Parameters:
    //     config_stats_write_latency_step_param - The value to assign to variable <axi::config_stats_write_latency_step>.
    //
    function automatic void set_config_stats_write_latency_step( int config_stats_write_latency_step_param );
        config_stats_write_latency_step = config_stats_write_latency_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_latency_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_latency_multiple>.
    //
    // Parameters:
    //     config_stats_write_latency_multiple_param - The value to assign to variable <axi::config_stats_write_latency_multiple>.
    //
    function automatic void set_config_stats_write_latency_multiple( int config_stats_write_latency_multiple_param );
        config_stats_write_latency_multiple = config_stats_write_latency_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_address_waits_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_read_address_waits_step>.
    //
    // Parameters:
    //     config_stats_read_address_waits_step_param - The value to assign to variable <axi::config_stats_read_address_waits_step>.
    //
    function automatic void set_config_stats_read_address_waits_step( int config_stats_read_address_waits_step_param );
        config_stats_read_address_waits_step = config_stats_read_address_waits_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_read_address_waits_multiple>.
    //
    // Parameters:
    //     config_stats_read_address_waits_multiple_param - The value to assign to variable <axi::config_stats_read_address_waits_multiple>.
    //
    function automatic void set_config_stats_read_address_waits_multiple( int config_stats_read_address_waits_multiple_param );
        config_stats_read_address_waits_multiple = config_stats_read_address_waits_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_data_waits_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_read_data_waits_step>.
    //
    // Parameters:
    //     config_stats_read_data_waits_step_param - The value to assign to variable <axi::config_stats_read_data_waits_step>.
    //
    function automatic void set_config_stats_read_data_waits_step( int config_stats_read_data_waits_step_param );
        config_stats_read_data_waits_step = config_stats_read_data_waits_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_read_data_waits_multiple>.
    //
    // Parameters:
    //     config_stats_read_data_waits_multiple_param - The value to assign to variable <axi::config_stats_read_data_waits_multiple>.
    //
    function automatic void set_config_stats_read_data_waits_multiple( int config_stats_read_data_waits_multiple_param );
        config_stats_read_data_waits_multiple = config_stats_read_data_waits_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_address_waits_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_address_waits_step>.
    //
    // Parameters:
    //     config_stats_write_address_waits_step_param - The value to assign to variable <axi::config_stats_write_address_waits_step>.
    //
    function automatic void set_config_stats_write_address_waits_step( int config_stats_write_address_waits_step_param );
        config_stats_write_address_waits_step = config_stats_write_address_waits_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_address_waits_multiple>.
    //
    // Parameters:
    //     config_stats_write_address_waits_multiple_param - The value to assign to variable <axi::config_stats_write_address_waits_multiple>.
    //
    function automatic void set_config_stats_write_address_waits_multiple( int config_stats_write_address_waits_multiple_param );
        config_stats_write_address_waits_multiple = config_stats_write_address_waits_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_data_waits_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_data_waits_step>.
    //
    // Parameters:
    //     config_stats_write_data_waits_step_param - The value to assign to variable <axi::config_stats_write_data_waits_step>.
    //
    function automatic void set_config_stats_write_data_waits_step( int config_stats_write_data_waits_step_param );
        config_stats_write_data_waits_step = config_stats_write_data_waits_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_data_waits_multiple>.
    //
    // Parameters:
    //     config_stats_write_data_waits_multiple_param - The value to assign to variable <axi::config_stats_write_data_waits_multiple>.
    //
    function automatic void set_config_stats_write_data_waits_multiple( int config_stats_write_data_waits_multiple_param );
        config_stats_write_data_waits_multiple = config_stats_write_data_waits_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_response_waits_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_response_waits_step>.
    //
    // Parameters:
    //     config_stats_write_response_waits_step_param - The value to assign to variable <axi::config_stats_write_response_waits_step>.
    //
    function automatic void set_config_stats_write_response_waits_step( int config_stats_write_response_waits_step_param );
        config_stats_write_response_waits_step = config_stats_write_response_waits_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_response_waits_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi::config_stats_write_response_waits_multiple>.
    //
    // Parameters:
    //     config_stats_write_response_waits_multiple_param - The value to assign to variable <axi::config_stats_write_response_waits_multiple>.
    //
    function automatic void set_config_stats_write_response_waits_multiple( int config_stats_write_response_waits_multiple_param );
        config_stats_write_response_waits_multiple = config_stats_write_response_waits_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Functions to get global variables with read access
    //------------------------------------------------------------------------------


    //------------------------------------------------------------------------------
    // Function:- get_config_clk_init_value
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_clk_init_value>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_clk_init_value>.
    //
    function automatic bit get_config_clk_init_value(  );
        return config_clk_init_value;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_clk_phase_shift
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_clk_phase_shift>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_clk_phase_shift>.
    //
    function automatic int get_config_clk_phase_shift(  );
        return config_clk_phase_shift;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_clk_1st_time
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_clk_1st_time>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_clk_1st_time>.
    //
    function automatic int get_config_clk_1st_time(  );
        return config_clk_1st_time;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_clk_2nd_time
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_clk_2nd_time>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_clk_2nd_time>.
    //
    function automatic int get_config_clk_2nd_time(  );
        return config_clk_2nd_time;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_setup_time
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_setup_time>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_setup_time>.
    //
    function automatic int get_config_setup_time(  );
        return config_setup_time;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_hold_time
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_hold_time>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_hold_time>.
    //
    function automatic int get_config_hold_time(  );
        return config_hold_time;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_max_transaction_time_factor
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_max_transaction_time_factor>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_max_transaction_time_factor>.
    //
    function automatic int unsigned get_config_max_transaction_time_factor(  );
        return config_max_transaction_time_factor;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_timeout_max_data_transfer
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_timeout_max_data_transfer>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_timeout_max_data_transfer>.
    //
    function automatic int get_config_timeout_max_data_transfer(  );
        return config_timeout_max_data_transfer;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_burst_timeout_factor
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_burst_timeout_factor>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_burst_timeout_factor>.
    //
    function automatic int unsigned get_config_burst_timeout_factor(  );
        return config_burst_timeout_factor;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_max_latency_AWVALID_assertion_to_AWREADY
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_max_latency_AWVALID_assertion_to_AWREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_max_latency_AWVALID_assertion_to_AWREADY>.
    //
    function automatic int unsigned get_config_max_latency_AWVALID_assertion_to_AWREADY(  );
        return config_max_latency_AWVALID_assertion_to_AWREADY;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_max_latency_ARVALID_assertion_to_ARREADY
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_max_latency_ARVALID_assertion_to_ARREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_max_latency_ARVALID_assertion_to_ARREADY>.
    //
    function automatic int unsigned get_config_max_latency_ARVALID_assertion_to_ARREADY(  );
        return config_max_latency_ARVALID_assertion_to_ARREADY;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_max_latency_RVALID_assertion_to_RREADY
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_max_latency_RVALID_assertion_to_RREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_max_latency_RVALID_assertion_to_RREADY>.
    //
    function automatic int unsigned get_config_max_latency_RVALID_assertion_to_RREADY(  );
        return config_max_latency_RVALID_assertion_to_RREADY;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_max_latency_BVALID_assertion_to_BREADY
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_max_latency_BVALID_assertion_to_BREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_max_latency_BVALID_assertion_to_BREADY>.
    //
    function automatic int unsigned get_config_max_latency_BVALID_assertion_to_BREADY(  );
        return config_max_latency_BVALID_assertion_to_BREADY;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_max_latency_WVALID_assertion_to_WREADY
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_max_latency_WVALID_assertion_to_WREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_max_latency_WVALID_assertion_to_WREADY>.
    //
    function automatic int unsigned get_config_max_latency_WVALID_assertion_to_WREADY(  );
        return config_max_latency_WVALID_assertion_to_WREADY;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_write_ctrl_first_ratio
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_write_ctrl_first_ratio>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_write_ctrl_first_ratio>.
    //
    function automatic int get_config_write_ctrl_first_ratio(  );
        return config_write_ctrl_first_ratio;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_write_data_first_ratio
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_write_data_first_ratio>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_write_data_first_ratio>.
    //
    function automatic int get_config_write_data_first_ratio(  );
        return config_write_data_first_ratio;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_write_ctrl_to_data_mintime
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_write_ctrl_to_data_mintime>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_write_ctrl_to_data_mintime>.
    //
    function automatic int unsigned get_config_write_ctrl_to_data_mintime(  );
        return config_write_ctrl_to_data_mintime;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_write_data_to_ctrl_mintime
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_write_data_to_ctrl_mintime>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_write_data_to_ctrl_mintime>.
    //
    function automatic int unsigned get_config_write_data_to_ctrl_mintime(  );
        return config_write_data_to_ctrl_mintime;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_master_write_delay
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_master_write_delay>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_master_write_delay>.
    //
    function automatic bit get_config_master_write_delay(  );
        return config_master_write_delay;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_reset_low_clocks
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_reset_low_clocks>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_reset_low_clocks>.
    //
    function automatic int get_config_reset_low_clocks(  );
        return config_reset_low_clocks;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_reset_hold_time
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_reset_hold_time>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_reset_hold_time>.
    //
    function automatic int get_config_reset_hold_time(  );
        return config_reset_hold_time;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_protect_ready
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_protect_ready>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_protect_ready>.
    //
    function automatic bit get_config_protect_ready(  );
        return config_protect_ready;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_user_sideband
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_user_sideband>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_user_sideband>.
    //
    function automatic bit get_config_enable_user_sideband(  );
        return config_enable_user_sideband;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_extended_length_enable
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_extended_length_enable>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_extended_length_enable>.
    //
    function automatic bit get_config_extended_length_enable(  );
        return config_extended_length_enable;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_burst_reserved_value
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_burst_reserved_value>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_burst_reserved_value>.
    //
    function automatic bit get_config_enable_burst_reserved_value(  );
        return config_enable_burst_reserved_value;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_lock_reserved_value
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_lock_reserved_value>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_lock_reserved_value>.
    //
    function automatic bit get_config_enable_lock_reserved_value(  );
        return config_enable_lock_reserved_value;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_cache_reserved_value
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_cache_reserved_value>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_cache_reserved_value>.
    //
    function automatic bit get_config_enable_cache_reserved_value(  );
        return config_enable_cache_reserved_value;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_all_assertions
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_all_assertions>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_all_assertions>.
    //
    function automatic bit get_config_enable_all_assertions(  );
        return config_enable_all_assertions;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_assertion
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_assertion>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_assertion>.
    //
    function automatic bit [255:0]  get_config_enable_assertion(  );
        return config_enable_assertion;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_assertion_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi::config_enable_assertion>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_assertion>.
    //
    function automatic bit   get_config_enable_assertion_index1( int _this_dot_1 );
        return config_enable_assertion[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_error
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_error>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_error>.
    //
    function automatic bit [255:0]  get_config_enable_error(  );
        return config_enable_error;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_error_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi::config_enable_error>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_error>.
    //
    function automatic bit   get_config_enable_error_index1( int _this_dot_1 );
        return config_enable_error[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_errors
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_errors>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_errors>.
    //
    function automatic bit get_config_enable_errors(  );
        return config_enable_errors;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_all_assertion_errors
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_all_assertion_errors>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_all_assertion_errors>.
    //
    function automatic bit get_config_enable_all_assertion_errors(  );
        return config_enable_all_assertion_errors;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_abstraction_level
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_abstraction_level>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_abstraction_level>.
    //
    function automatic axi_abstraction_level_e get_config_abstraction_level(  );
        return config_abstraction_level;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_slave_start_addr
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_slave_start_addr>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_slave_start_addr>.
    //
    function automatic bit [((AXI_ADDRESS_WIDTH) - 1):0]   get_config_slave_start_addr(  );
        return config_slave_start_addr;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_slave_start_addr_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi::config_slave_start_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi::config_slave_start_addr>.
    //
    function automatic bit   get_config_slave_start_addr_index1( int _this_dot_1 );
        return config_slave_start_addr[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_slave_end_addr
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_slave_end_addr>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_slave_end_addr>.
    //
    function automatic bit [((AXI_ADDRESS_WIDTH) - 1):0]   get_config_slave_end_addr(  );
        return config_slave_end_addr;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_slave_end_addr_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi::config_slave_end_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi::config_slave_end_addr>.
    //
    function automatic bit   get_config_slave_end_addr_index1( int _this_dot_1 );
        return config_slave_end_addr[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_slave_addr_range_in_bfm
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_slave_addr_range_in_bfm>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_slave_addr_range_in_bfm>.
    //
    function automatic bit get_config_enable_slave_addr_range_in_bfm(  );
        return config_enable_slave_addr_range_in_bfm;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_read_data_reordering_depth
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_read_data_reordering_depth>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_read_data_reordering_depth>.
    //
    function automatic int unsigned get_config_read_data_reordering_depth(  );
        return config_read_data_reordering_depth;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_read_data_reordering_depth_in_bfm
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_enable_read_data_reordering_depth_in_bfm>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_enable_read_data_reordering_depth_in_bfm>.
    //
    function automatic bit get_config_enable_read_data_reordering_depth_in_bfm(  );
        return config_enable_read_data_reordering_depth_in_bfm;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_awid_wid_mismatch
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_awid_wid_mismatch>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_awid_wid_mismatch>.
    //
    function automatic bit get_config_awid_wid_mismatch(  );
        return config_awid_wid_mismatch;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_length_last_mismatch_error
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_length_last_mismatch_error>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_length_last_mismatch_error>.
    //
    function automatic bit get_config_length_last_mismatch_error(  );
        return config_length_last_mismatch_error;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_master_error_position
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_master_error_position>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_master_error_position>.
    //
    function automatic axi_error_e get_config_master_error_position(  );
        return config_master_error_position;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_dummy_var
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::dummy_var>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::dummy_var>.
    //
    function automatic axi_assertion_type_e get_dummy_var(  );
        return dummy_var;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_wlast_length
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_wlast_length>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_wlast_length>.
    //
    function automatic int get_config_wlast_length(  );
        return config_wlast_length;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_wid_for_awid_not_matching
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_wid_for_awid_not_matching>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_wid_for_awid_not_matching>.
    //
    function automatic bit [((AXI_ID_WIDTH) - 1):0]   get_config_wid_for_awid_not_matching(  );
        return config_wid_for_awid_not_matching;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_wid_for_awid_not_matching_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi::config_wid_for_awid_not_matching>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi::config_wid_for_awid_not_matching>.
    //
    function automatic bit   get_config_wid_for_awid_not_matching_index1( int _this_dot_1 );
        return config_wid_for_awid_not_matching[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_support_exclusive_access
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_support_exclusive_access>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_support_exclusive_access>.
    //
    function automatic bit get_config_support_exclusive_access(  );
        return config_support_exclusive_access;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_write_data_interleaving_depth
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_write_data_interleaving_depth>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_write_data_interleaving_depth>.
    //
    function automatic int get_config_write_data_interleaving_depth(  );
        return config_write_data_interleaving_depth;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_status_master_error
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::status_master_error>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::status_master_error>.
    //
    function automatic bit [15:0]  get_status_master_error(  );
        return status_master_error;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_status_master_error_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi::status_master_error>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi::status_master_error>.
    //
    function automatic bit   get_status_master_error_index1( int _this_dot_1 );
        return status_master_error[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_status_num_reads_waiting_for_resp
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::status_num_reads_waiting_for_resp>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::status_num_reads_waiting_for_resp>.
    //
    function automatic int get_status_num_reads_waiting_for_resp(  );
        return status_num_reads_waiting_for_resp;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_status_num_writes_waiting_for_response
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::status_num_writes_waiting_for_response>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::status_num_writes_waiting_for_response>.
    //
    function automatic int get_status_num_writes_waiting_for_response(  );
        return status_num_writes_waiting_for_response;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_check_total_num_wdata_outstanding
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::check_total_num_wdata_outstanding>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::check_total_num_wdata_outstanding>.
    //
    function automatic bit get_check_total_num_wdata_outstanding(  );
        return check_total_num_wdata_outstanding;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_total_num_wdata_outstanding
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::total_num_wdata_outstanding>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::total_num_wdata_outstanding>.
    //
    function automatic int get_total_num_wdata_outstanding(  );
        return total_num_wdata_outstanding;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_check_max_num_wdata_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::check_max_num_wdata_outstanding_per_id>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::check_max_num_wdata_outstanding_per_id>.
    //
    function automatic bit get_check_max_num_wdata_outstanding_per_id(  );
        return check_max_num_wdata_outstanding_per_id;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_max_num_wdata_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::max_num_wdata_outstanding_per_id>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::max_num_wdata_outstanding_per_id>.
    //
    function automatic int get_max_num_wdata_outstanding_per_id(  );
        return max_num_wdata_outstanding_per_id;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_check_max_num_waddr_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::check_max_num_waddr_outstanding_per_id>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::check_max_num_waddr_outstanding_per_id>.
    //
    function automatic bit get_check_max_num_waddr_outstanding_per_id(  );
        return check_max_num_waddr_outstanding_per_id;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_max_num_waddr_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::max_num_waddr_outstanding_per_id>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::max_num_waddr_outstanding_per_id>.
    //
    function automatic int get_max_num_waddr_outstanding_per_id(  );
        return max_num_waddr_outstanding_per_id;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_check_total_num_waddr_outstanding
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::check_total_num_waddr_outstanding>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::check_total_num_waddr_outstanding>.
    //
    function automatic bit get_check_total_num_waddr_outstanding(  );
        return check_total_num_waddr_outstanding;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_total_num_waddr_outstanding
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::total_num_waddr_outstanding>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::total_num_waddr_outstanding>.
    //
    function automatic int get_total_num_waddr_outstanding(  );
        return total_num_waddr_outstanding;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_status_outstanding_num_for_waddr
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::status_outstanding_num_for_waddr>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::status_outstanding_num_for_waddr>.
    //
    function automatic int get_status_outstanding_num_for_waddr(  );
        return status_outstanding_num_for_waddr;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_start_finding_outstanding_waddr
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::start_finding_outstanding_waddr>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::start_finding_outstanding_waddr>.
    //
    function automatic bit get_start_finding_outstanding_waddr(  );
        return start_finding_outstanding_waddr;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_status_outstanding_num_for_wdata
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::status_outstanding_num_for_wdata>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::status_outstanding_num_for_wdata>.
    //
    function automatic int get_status_outstanding_num_for_wdata(  );
        return status_outstanding_num_for_wdata;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_start_finding_outstanding_wdata
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::start_finding_outstanding_wdata>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::start_finding_outstanding_wdata>.
    //
    function automatic bit get_start_finding_outstanding_wdata(  );
        return start_finding_outstanding_wdata;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_find_waddr_outstanding_for_wid
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::find_waddr_outstanding_for_wid>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::find_waddr_outstanding_for_wid>.
    //
    function automatic bit [((AXI_ID_WIDTH) - 1):0]   get_find_waddr_outstanding_for_wid(  );
        return find_waddr_outstanding_for_wid;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_find_waddr_outstanding_for_wid_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi::find_waddr_outstanding_for_wid>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi::find_waddr_outstanding_for_wid>.
    //
    function automatic bit   get_find_waddr_outstanding_for_wid_index1( int _this_dot_1 );
        return find_waddr_outstanding_for_wid[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_find_wdata_outstanding_for_wid
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::find_wdata_outstanding_for_wid>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::find_wdata_outstanding_for_wid>.
    //
    function automatic bit [((AXI_ID_WIDTH) - 1):0]   get_find_wdata_outstanding_for_wid(  );
        return find_wdata_outstanding_for_wid;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_find_wdata_outstanding_for_wid_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi::find_wdata_outstanding_for_wid>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi::find_wdata_outstanding_for_wid>.
    //
    function automatic bit   get_find_wdata_outstanding_for_wid_index1( int _this_dot_1 );
        return find_wdata_outstanding_for_wid[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_change_in_wdata_outstanding_per_id
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::change_in_wdata_outstanding_per_id>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::change_in_wdata_outstanding_per_id>.
    //
    function automatic bit get_change_in_wdata_outstanding_per_id(  );
        return change_in_wdata_outstanding_per_id;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_start_finding_change_in_wdata
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::start_finding_change_in_wdata>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::start_finding_change_in_wdata>.
    //
    function automatic bit get_start_finding_change_in_wdata(  );
        return start_finding_change_in_wdata;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_find_change_in_wdata_outstanding_for_wid
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::find_change_in_wdata_outstanding_for_wid>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::find_change_in_wdata_outstanding_for_wid>.
    //
    function automatic bit [((AXI_ID_WIDTH) - 1):0]   get_find_change_in_wdata_outstanding_for_wid(  );
        return find_change_in_wdata_outstanding_for_wid;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_find_change_in_wdata_outstanding_for_wid_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi::find_change_in_wdata_outstanding_for_wid>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi::find_change_in_wdata_outstanding_for_wid>.
    //
    function automatic bit   get_find_change_in_wdata_outstanding_for_wid_index1( int _this_dot_1 );
        return find_change_in_wdata_outstanding_for_wid[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_max_outstanding_wr
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_max_outstanding_wr>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_max_outstanding_wr>.
    //
    function automatic int get_config_max_outstanding_wr(  );
        return config_max_outstanding_wr;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_max_outstanding_rd
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_max_outstanding_rd>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_max_outstanding_rd>.
    //
    function automatic int get_config_max_outstanding_rd(  );
        return config_max_outstanding_rd;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_error_on_deleted_valid_cycles
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_error_on_deleted_valid_cycles>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_error_on_deleted_valid_cycles>.
    //
    function automatic bit get_config_error_on_deleted_valid_cycles(  );
        return config_error_on_deleted_valid_cycles;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable>.
    //
    function automatic bit get_config_stats_enable(  );
        return config_stats_enable;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_AXI_read_occupancy
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_AXI_read_occupancy>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_AXI_read_occupancy>.
    //
    function automatic bit get_config_stats_enable_AXI_read_occupancy(  );
        return config_stats_enable_AXI_read_occupancy;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_AXI_write_occupancy
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_AXI_write_occupancy>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_AXI_write_occupancy>.
    //
    function automatic bit get_config_stats_enable_AXI_write_occupancy(  );
        return config_stats_enable_AXI_write_occupancy;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_data_occupancy
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_read_data_occupancy>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_read_data_occupancy>.
    //
    function automatic bit get_config_stats_enable_read_data_occupancy(  );
        return config_stats_enable_read_data_occupancy;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_data_occupancy
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_write_data_occupancy>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_write_data_occupancy>.
    //
    function automatic bit get_config_stats_enable_write_data_occupancy(  );
        return config_stats_enable_write_data_occupancy;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_latency
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_read_latency>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_read_latency>.
    //
    function automatic bit get_config_stats_enable_read_latency(  );
        return config_stats_enable_read_latency;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_latency
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_write_latency>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_write_latency>.
    //
    function automatic bit get_config_stats_enable_write_latency(  );
        return config_stats_enable_write_latency;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_address_waits
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_read_address_waits>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_read_address_waits>.
    //
    function automatic bit get_config_stats_enable_read_address_waits(  );
        return config_stats_enable_read_address_waits;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_data_waits
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_read_data_waits>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_read_data_waits>.
    //
    function automatic bit get_config_stats_enable_read_data_waits(  );
        return config_stats_enable_read_data_waits;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_address_waits
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_write_address_waits>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_write_address_waits>.
    //
    function automatic bit get_config_stats_enable_write_address_waits(  );
        return config_stats_enable_write_address_waits;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_data_waits
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_write_data_waits>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_write_data_waits>.
    //
    function automatic bit get_config_stats_enable_write_data_waits(  );
        return config_stats_enable_write_data_waits;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_response_waits
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_write_response_waits>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_write_response_waits>.
    //
    function automatic bit get_config_stats_enable_write_response_waits(  );
        return config_stats_enable_write_response_waits;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_bandwidth
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_read_bandwidth>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_read_bandwidth>.
    //
    function automatic bit get_config_stats_enable_read_bandwidth(  );
        return config_stats_enable_read_bandwidth;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_bandwidth
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_enable_write_bandwidth>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_enable_write_bandwidth>.
    //
    function automatic bit get_config_stats_enable_write_bandwidth(  );
        return config_stats_enable_write_bandwidth;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_AXI_read_occupancy_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_AXI_read_occupancy_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_AXI_read_occupancy_step>.
    //
    function automatic int get_config_stats_AXI_read_occupancy_step(  );
        return config_stats_AXI_read_occupancy_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_AXI_read_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_AXI_read_occupancy_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_AXI_read_occupancy_multiple>.
    //
    function automatic int get_config_stats_AXI_read_occupancy_multiple(  );
        return config_stats_AXI_read_occupancy_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_active
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_active>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_active>.
    //
    function automatic bit get_stats_AXI_read_active(  );
        return stats_AXI_read_active;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_occupancy_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_occupancy_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_occupancy_sw>.
    //
    function automatic int get_stats_AXI_read_occupancy_sw(  );
        return stats_AXI_read_occupancy_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_occupancy_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_occupancy_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_occupancy_sw_updated>.
    //
    function automatic int get_stats_AXI_read_occupancy_sw_updated(  );
        return stats_AXI_read_occupancy_sw_updated;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_idle_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_idle_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_idle_sw>.
    //
    function automatic int get_stats_AXI_read_idle_sw(  );
        return stats_AXI_read_idle_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_occupancy_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_occupancy_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_occupancy_min>.
    //
    function automatic int get_stats_AXI_read_occupancy_min(  );
        return stats_AXI_read_occupancy_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_idle_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_idle_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_idle_min>.
    //
    function automatic int get_stats_AXI_read_idle_min(  );
        return stats_AXI_read_idle_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_occupancy_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_occupancy_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_occupancy_max>.
    //
    function automatic int get_stats_AXI_read_occupancy_max(  );
        return stats_AXI_read_occupancy_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_idle_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_idle_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_idle_max>.
    //
    function automatic int get_stats_AXI_read_idle_max(  );
        return stats_AXI_read_idle_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_occupancy_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_occupancy_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_occupancy_mean>.
    //
    function automatic int get_stats_AXI_read_occupancy_mean(  );
        return stats_AXI_read_occupancy_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_idle_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_idle_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_idle_mean>.
    //
    function automatic int get_stats_AXI_read_idle_mean(  );
        return stats_AXI_read_idle_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_AXI_write_occupancy_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_AXI_write_occupancy_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_AXI_write_occupancy_step>.
    //
    function automatic int get_config_stats_AXI_write_occupancy_step(  );
        return config_stats_AXI_write_occupancy_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_AXI_write_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_AXI_write_occupancy_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_AXI_write_occupancy_multiple>.
    //
    function automatic int get_config_stats_AXI_write_occupancy_multiple(  );
        return config_stats_AXI_write_occupancy_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_active
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_active>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_active>.
    //
    function automatic bit get_stats_AXI_write_active(  );
        return stats_AXI_write_active;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_occupancy_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_occupancy_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_occupancy_sw>.
    //
    function automatic int get_stats_AXI_write_occupancy_sw(  );
        return stats_AXI_write_occupancy_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_occupancy_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_occupancy_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_occupancy_sw_updated>.
    //
    function automatic int get_stats_AXI_write_occupancy_sw_updated(  );
        return stats_AXI_write_occupancy_sw_updated;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_idle_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_idle_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_idle_sw>.
    //
    function automatic int get_stats_AXI_write_idle_sw(  );
        return stats_AXI_write_idle_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_occupancy_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_occupancy_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_occupancy_min>.
    //
    function automatic int get_stats_AXI_write_occupancy_min(  );
        return stats_AXI_write_occupancy_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_idle_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_idle_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_idle_min>.
    //
    function automatic int get_stats_AXI_write_idle_min(  );
        return stats_AXI_write_idle_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_occupancy_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_occupancy_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_occupancy_max>.
    //
    function automatic int get_stats_AXI_write_occupancy_max(  );
        return stats_AXI_write_occupancy_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_idle_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_idle_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_idle_max>.
    //
    function automatic int get_stats_AXI_write_idle_max(  );
        return stats_AXI_write_idle_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_occupancy_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_occupancy_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_occupancy_mean>.
    //
    function automatic int get_stats_AXI_write_occupancy_mean(  );
        return stats_AXI_write_occupancy_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_idle_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_idle_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_idle_mean>.
    //
    function automatic int get_stats_AXI_write_idle_mean(  );
        return stats_AXI_write_idle_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_read_data_occupancy_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_read_data_occupancy_step>.
    //
    function automatic int get_config_stats_read_data_occupancy_step(  );
        return config_stats_read_data_occupancy_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_read_data_occupancy_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_read_data_occupancy_multiple>.
    //
    function automatic int get_config_stats_read_data_occupancy_multiple(  );
        return config_stats_read_data_occupancy_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_occupancy_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_occupancy_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_occupancy_sw>.
    //
    function automatic int get_stats_read_data_occupancy_sw(  );
        return stats_read_data_occupancy_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_occupancy_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_occupancy_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_occupancy_sw_updated>.
    //
    function automatic int get_stats_read_data_occupancy_sw_updated(  );
        return stats_read_data_occupancy_sw_updated;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_idle_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_idle_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_idle_sw>.
    //
    function automatic int get_stats_read_data_idle_sw(  );
        return stats_read_data_idle_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_occupancy_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_occupancy_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_occupancy_min>.
    //
    function automatic int get_stats_read_data_occupancy_min(  );
        return stats_read_data_occupancy_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_idle_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_idle_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_idle_min>.
    //
    function automatic int get_stats_read_data_idle_min(  );
        return stats_read_data_idle_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_occupancy_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_occupancy_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_occupancy_max>.
    //
    function automatic int get_stats_read_data_occupancy_max(  );
        return stats_read_data_occupancy_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_idle_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_idle_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_idle_max>.
    //
    function automatic int get_stats_read_data_idle_max(  );
        return stats_read_data_idle_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_occupancy_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_occupancy_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_occupancy_mean>.
    //
    function automatic int get_stats_read_data_occupancy_mean(  );
        return stats_read_data_occupancy_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_idle_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_idle_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_idle_mean>.
    //
    function automatic int get_stats_read_data_idle_mean(  );
        return stats_read_data_idle_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_data_occupancy_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_data_occupancy_step>.
    //
    function automatic int get_config_stats_write_data_occupancy_step(  );
        return config_stats_write_data_occupancy_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_data_occupancy_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_data_occupancy_multiple>.
    //
    function automatic int get_config_stats_write_data_occupancy_multiple(  );
        return config_stats_write_data_occupancy_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_occupancy_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_occupancy_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_occupancy_sw>.
    //
    function automatic int get_stats_write_data_occupancy_sw(  );
        return stats_write_data_occupancy_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_occupancy_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_occupancy_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_occupancy_sw_updated>.
    //
    function automatic int get_stats_write_data_occupancy_sw_updated(  );
        return stats_write_data_occupancy_sw_updated;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_idle_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_idle_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_idle_sw>.
    //
    function automatic int get_stats_write_data_idle_sw(  );
        return stats_write_data_idle_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_occupancy_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_occupancy_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_occupancy_min>.
    //
    function automatic int get_stats_write_data_occupancy_min(  );
        return stats_write_data_occupancy_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_idle_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_idle_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_idle_min>.
    //
    function automatic int get_stats_write_data_idle_min(  );
        return stats_write_data_idle_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_occupancy_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_occupancy_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_occupancy_max>.
    //
    function automatic int get_stats_write_data_occupancy_max(  );
        return stats_write_data_occupancy_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_idle_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_idle_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_idle_max>.
    //
    function automatic int get_stats_write_data_idle_max(  );
        return stats_write_data_idle_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_occupancy_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_occupancy_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_occupancy_mean>.
    //
    function automatic int get_stats_write_data_occupancy_mean(  );
        return stats_write_data_occupancy_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_idle_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_idle_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_idle_mean>.
    //
    function automatic int get_stats_write_data_idle_mean(  );
        return stats_write_data_idle_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_bandwidth_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_read_bandwidth_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_read_bandwidth_step>.
    //
    function automatic int get_config_stats_read_bandwidth_step(  );
        return config_stats_read_bandwidth_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_read_bandwidth_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_read_bandwidth_multiple>.
    //
    function automatic int get_config_stats_read_bandwidth_multiple(  );
        return config_stats_read_bandwidth_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_bandwidth_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_bandwidth_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_bandwidth_sw>.
    //
    function automatic int get_stats_read_bandwidth_sw(  );
        return stats_read_bandwidth_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_bandwidth_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_bandwidth_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_bandwidth_sw_updated>.
    //
    function automatic int get_stats_read_bandwidth_sw_updated(  );
        return stats_read_bandwidth_sw_updated;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_bandwidth_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_bandwidth_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_bandwidth_min>.
    //
    function automatic int get_stats_read_bandwidth_min(  );
        return stats_read_bandwidth_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_bandwidth_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_bandwidth_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_bandwidth_max>.
    //
    function automatic int get_stats_read_bandwidth_max(  );
        return stats_read_bandwidth_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_bandwidth_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_bandwidth_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_bandwidth_mean>.
    //
    function automatic int get_stats_read_bandwidth_mean(  );
        return stats_read_bandwidth_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_bandwidth_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_bandwidth_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_bandwidth_step>.
    //
    function automatic int get_config_stats_write_bandwidth_step(  );
        return config_stats_write_bandwidth_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_bandwidth_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_bandwidth_multiple>.
    //
    function automatic int get_config_stats_write_bandwidth_multiple(  );
        return config_stats_write_bandwidth_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_bandwidth_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_bandwidth_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_bandwidth_sw>.
    //
    function automatic int get_stats_write_bandwidth_sw(  );
        return stats_write_bandwidth_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_bandwidth_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_bandwidth_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_bandwidth_sw_updated>.
    //
    function automatic int get_stats_write_bandwidth_sw_updated(  );
        return stats_write_bandwidth_sw_updated;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_bandwidth_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_bandwidth_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_bandwidth_min>.
    //
    function automatic int get_stats_write_bandwidth_min(  );
        return stats_write_bandwidth_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_bandwidth_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_bandwidth_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_bandwidth_max>.
    //
    function automatic int get_stats_write_bandwidth_max(  );
        return stats_write_bandwidth_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_bandwidth_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_bandwidth_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_bandwidth_mean>.
    //
    function automatic int get_stats_write_bandwidth_mean(  );
        return stats_write_bandwidth_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_latency_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_read_latency_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_read_latency_step>.
    //
    function automatic int get_config_stats_read_latency_step(  );
        return config_stats_read_latency_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_latency_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_read_latency_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_read_latency_multiple>.
    //
    function automatic int get_config_stats_read_latency_multiple(  );
        return config_stats_read_latency_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_latency_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_latency_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_latency_sw_updated>.
    //
    function automatic int get_stats_read_latency_sw_updated(  );
        return stats_read_latency_sw_updated;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_data_latency_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_data_latency_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_data_latency_inst>.
    //
    function automatic int get_stats_read_address_data_latency_inst(  );
        return stats_read_address_data_latency_inst;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_data_latency_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_data_latency_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_data_latency_sw>.
    //
    function automatic int get_stats_read_address_data_latency_sw(  );
        return stats_read_address_data_latency_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_data_latency_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_data_latency_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_data_latency_min>.
    //
    function automatic int get_stats_read_address_data_latency_min(  );
        return stats_read_address_data_latency_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_data_latency_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_data_latency_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_data_latency_max>.
    //
    function automatic int get_stats_read_address_data_latency_max(  );
        return stats_read_address_data_latency_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_data_latency_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_data_latency_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_data_latency_mean>.
    //
    function automatic int get_stats_read_address_data_latency_mean(  );
        return stats_read_address_data_latency_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_address_latency_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_address_latency_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_address_latency_inst>.
    //
    function automatic int get_stats_read_address_address_latency_inst(  );
        return stats_read_address_address_latency_inst;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_address_latency_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_address_latency_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_address_latency_sw>.
    //
    function automatic int get_stats_read_address_address_latency_sw(  );
        return stats_read_address_address_latency_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_address_latency_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_address_latency_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_address_latency_min>.
    //
    function automatic int get_stats_read_address_address_latency_min(  );
        return stats_read_address_address_latency_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_address_latency_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_address_latency_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_address_latency_max>.
    //
    function automatic int get_stats_read_address_address_latency_max(  );
        return stats_read_address_address_latency_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_address_latency_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_address_latency_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_address_latency_mean>.
    //
    function automatic int get_stats_read_address_address_latency_mean(  );
        return stats_read_address_address_latency_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_latency_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_latency_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_latency_step>.
    //
    function automatic int get_config_stats_write_latency_step(  );
        return config_stats_write_latency_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_latency_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_latency_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_latency_multiple>.
    //
    function automatic int get_config_stats_write_latency_multiple(  );
        return config_stats_write_latency_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_latency_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_latency_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_latency_sw_updated>.
    //
    function automatic int get_stats_write_latency_sw_updated(  );
        return stats_write_latency_sw_updated;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_data_latency_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_data_latency_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_data_latency_inst>.
    //
    function automatic int get_stats_write_address_data_latency_inst(  );
        return stats_write_address_data_latency_inst;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_data_latency_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_data_latency_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_data_latency_sw>.
    //
    function automatic int get_stats_write_address_data_latency_sw(  );
        return stats_write_address_data_latency_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_data_latency_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_data_latency_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_data_latency_min>.
    //
    function automatic int get_stats_write_address_data_latency_min(  );
        return stats_write_address_data_latency_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_data_latency_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_data_latency_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_data_latency_max>.
    //
    function automatic int get_stats_write_address_data_latency_max(  );
        return stats_write_address_data_latency_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_data_latency_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_data_latency_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_data_latency_mean>.
    //
    function automatic int get_stats_write_address_data_latency_mean(  );
        return stats_write_address_data_latency_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_response_latency_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_response_latency_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_response_latency_inst>.
    //
    function automatic int get_stats_write_data_response_latency_inst(  );
        return stats_write_data_response_latency_inst;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_response_latency_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_response_latency_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_response_latency_sw>.
    //
    function automatic int get_stats_write_data_response_latency_sw(  );
        return stats_write_data_response_latency_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_response_latency_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_response_latency_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_response_latency_min>.
    //
    function automatic int get_stats_write_data_response_latency_min(  );
        return stats_write_data_response_latency_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_response_latency_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_response_latency_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_response_latency_max>.
    //
    function automatic int get_stats_write_data_response_latency_max(  );
        return stats_write_data_response_latency_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_response_latency_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_response_latency_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_response_latency_mean>.
    //
    function automatic int get_stats_write_data_response_latency_mean(  );
        return stats_write_data_response_latency_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_address_latency_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_address_latency_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_address_latency_inst>.
    //
    function automatic int get_stats_write_address_address_latency_inst(  );
        return stats_write_address_address_latency_inst;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_address_latency_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_address_latency_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_address_latency_sw>.
    //
    function automatic int get_stats_write_address_address_latency_sw(  );
        return stats_write_address_address_latency_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_address_latency_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_address_latency_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_address_latency_min>.
    //
    function automatic int get_stats_write_address_address_latency_min(  );
        return stats_write_address_address_latency_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_address_latency_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_address_latency_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_address_latency_max>.
    //
    function automatic int get_stats_write_address_address_latency_max(  );
        return stats_write_address_address_latency_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_address_latency_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_address_latency_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_address_latency_mean>.
    //
    function automatic int get_stats_write_address_address_latency_mean(  );
        return stats_write_address_address_latency_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_address_waits_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_read_address_waits_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_read_address_waits_step>.
    //
    function automatic int get_config_stats_read_address_waits_step(  );
        return config_stats_read_address_waits_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_read_address_waits_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_read_address_waits_multiple>.
    //
    function automatic int get_config_stats_read_address_waits_multiple(  );
        return config_stats_read_address_waits_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_waits_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_waits_inst>.
    //
    function automatic int get_stats_read_address_waits_inst(  );
        return stats_read_address_waits_inst;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_waits_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_waits_sw>.
    //
    function automatic int get_stats_read_address_waits_sw(  );
        return stats_read_address_waits_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_waits_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_waits_sw_updated>.
    //
    function automatic int get_stats_read_address_waits_sw_updated(  );
        return stats_read_address_waits_sw_updated;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_waits_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_waits_min>.
    //
    function automatic int get_stats_read_address_waits_min(  );
        return stats_read_address_waits_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_waits_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_waits_max>.
    //
    function automatic int get_stats_read_address_waits_max(  );
        return stats_read_address_waits_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_address_waits_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_address_waits_mean>.
    //
    function automatic int get_stats_read_address_waits_mean(  );
        return stats_read_address_waits_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_data_waits_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_read_data_waits_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_read_data_waits_step>.
    //
    function automatic int get_config_stats_read_data_waits_step(  );
        return config_stats_read_data_waits_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_read_data_waits_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_read_data_waits_multiple>.
    //
    function automatic int get_config_stats_read_data_waits_multiple(  );
        return config_stats_read_data_waits_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_waits_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_waits_inst>.
    //
    function automatic int get_stats_read_data_waits_inst(  );
        return stats_read_data_waits_inst;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_waits_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_waits_sw>.
    //
    function automatic int get_stats_read_data_waits_sw(  );
        return stats_read_data_waits_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_waits_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_waits_sw_updated>.
    //
    function automatic int get_stats_read_data_waits_sw_updated(  );
        return stats_read_data_waits_sw_updated;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_waits_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_waits_min>.
    //
    function automatic int get_stats_read_data_waits_min(  );
        return stats_read_data_waits_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_waits_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_waits_max>.
    //
    function automatic int get_stats_read_data_waits_max(  );
        return stats_read_data_waits_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_waits_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_waits_mean>.
    //
    function automatic int get_stats_read_data_waits_mean(  );
        return stats_read_data_waits_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_address_waits_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_address_waits_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_address_waits_step>.
    //
    function automatic int get_config_stats_write_address_waits_step(  );
        return config_stats_write_address_waits_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_address_waits_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_address_waits_multiple>.
    //
    function automatic int get_config_stats_write_address_waits_multiple(  );
        return config_stats_write_address_waits_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_waits_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_waits_inst>.
    //
    function automatic int get_stats_write_address_waits_inst(  );
        return stats_write_address_waits_inst;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_waits_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_waits_sw>.
    //
    function automatic int get_stats_write_address_waits_sw(  );
        return stats_write_address_waits_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_waits_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_waits_sw_updated>.
    //
    function automatic int get_stats_write_address_waits_sw_updated(  );
        return stats_write_address_waits_sw_updated;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_waits_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_waits_min>.
    //
    function automatic int get_stats_write_address_waits_min(  );
        return stats_write_address_waits_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_waits_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_waits_max>.
    //
    function automatic int get_stats_write_address_waits_max(  );
        return stats_write_address_waits_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_address_waits_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_address_waits_mean>.
    //
    function automatic int get_stats_write_address_waits_mean(  );
        return stats_write_address_waits_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_data_waits_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_data_waits_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_data_waits_step>.
    //
    function automatic int get_config_stats_write_data_waits_step(  );
        return config_stats_write_data_waits_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_data_waits_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_data_waits_multiple>.
    //
    function automatic int get_config_stats_write_data_waits_multiple(  );
        return config_stats_write_data_waits_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_waits_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_waits_inst>.
    //
    function automatic int get_stats_write_data_waits_inst(  );
        return stats_write_data_waits_inst;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_waits_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_waits_sw>.
    //
    function automatic int get_stats_write_data_waits_sw(  );
        return stats_write_data_waits_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_waits_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_waits_sw_updated>.
    //
    function automatic int get_stats_write_data_waits_sw_updated(  );
        return stats_write_data_waits_sw_updated;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_waits_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_waits_min>.
    //
    function automatic int get_stats_write_data_waits_min(  );
        return stats_write_data_waits_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_waits_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_waits_max>.
    //
    function automatic int get_stats_write_data_waits_max(  );
        return stats_write_data_waits_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_waits_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_waits_mean>.
    //
    function automatic int get_stats_write_data_waits_mean(  );
        return stats_write_data_waits_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_response_waits_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_response_waits_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_response_waits_step>.
    //
    function automatic int get_config_stats_write_response_waits_step(  );
        return config_stats_write_response_waits_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_response_waits_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::config_stats_write_response_waits_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::config_stats_write_response_waits_multiple>.
    //
    function automatic int get_config_stats_write_response_waits_multiple(  );
        return config_stats_write_response_waits_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_response_waits_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_response_waits_inst>.
    //
    function automatic int get_stats_write_response_waits_inst(  );
        return stats_write_response_waits_inst;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_response_waits_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_response_waits_sw>.
    //
    function automatic int get_stats_write_response_waits_sw(  );
        return stats_write_response_waits_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_sw_updated
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_response_waits_sw_updated>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_response_waits_sw_updated>.
    //
    function automatic int get_stats_write_response_waits_sw_updated(  );
        return stats_write_response_waits_sw_updated;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_response_waits_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_response_waits_min>.
    //
    function automatic int get_stats_write_response_waits_min(  );
        return stats_write_response_waits_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_response_waits_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_response_waits_max>.
    //
    function automatic int get_stats_write_response_waits_max(  );
        return stats_write_response_waits_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_response_waits_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_response_waits_mean>.
    //
    function automatic int get_stats_write_response_waits_mean(  );
        return stats_write_response_waits_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_rw_transaction_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_rw_transaction_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_rw_transaction_last_duration>.
    //
    function automatic int get_stats_rw_transaction_last_duration(  );
        return stats_rw_transaction_last_duration;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_read_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_read_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_read_last_duration>.
    //
    function automatic int get_stats_AXI_read_last_duration(  );
        return stats_AXI_read_last_duration;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_AXI_write_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_AXI_write_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_AXI_write_last_duration>.
    //
    function automatic int get_stats_AXI_write_last_duration(  );
        return stats_AXI_write_last_duration;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_addr_channel_phase_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_addr_channel_phase_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_addr_channel_phase_last_duration>.
    //
    function automatic int get_stats_read_addr_channel_phase_last_duration(  );
        return stats_read_addr_channel_phase_last_duration;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_burst_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_data_burst_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_data_burst_last_duration>.
    //
    function automatic int get_stats_read_data_burst_last_duration(  );
        return stats_read_data_burst_last_duration;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_channel_phase_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_read_channel_phase_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_read_channel_phase_last_duration>.
    //
    function automatic int get_stats_read_channel_phase_last_duration(  );
        return stats_read_channel_phase_last_duration;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_addr_channel_phase_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_addr_channel_phase_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_addr_channel_phase_last_duration>.
    //
    function automatic int get_stats_write_addr_channel_phase_last_duration(  );
        return stats_write_addr_channel_phase_last_duration;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_burst_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_data_burst_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_data_burst_last_duration>.
    //
    function automatic int get_stats_write_data_burst_last_duration(  );
        return stats_write_data_burst_last_duration;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_channel_phase_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_channel_phase_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_channel_phase_last_duration>.
    //
    function automatic int get_stats_write_channel_phase_last_duration(  );
        return stats_write_channel_phase_last_duration;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_resp_channel_phase_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi::stats_write_resp_channel_phase_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi::stats_write_resp_channel_phase_last_duration>.
    //
    function automatic int get_stats_write_resp_channel_phase_last_duration(  );
        return stats_write_resp_channel_phase_last_duration;
    endfunction


    //------------------------------------------------------------------------------
    // Functions to set/get generic interface configuration
    //------------------------------------------------------------------------------

    function void set_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0,
        input int arg10 = 0
    );
        axi_set_interface( what, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10 );
    endfunction

    function int get_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0
    );
        return axi_get_interface( what, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 );
    endfunction

    //------------------------------------------------------------------------------
    // Functions to get the hierarchic name of this interface
    //------------------------------------------------------------------------------
    function string get_full_name();
        return axi_get_full_name();
    endfunction

    //------------------------------------------------------------------------------
    // Functions to set/get the abstraction levels of interface ends
    //------------------------------------------------------------------------------

    //------------------------------------------------------------------------------
    // Function: axi_set_master_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to set whether the <master> end of the interface is WLM or TLM connected.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels,
    //     how they affect the behaviour of the QVIP, and guidelines for setting them.
    //
    // Parameters:
    //    wire_level - Set to 1 to be WLM connected.
    //    TLM_level -  Set to 1 to be TLM connected.
    //------------------------------------------------------------------------------
    function void axi_set_master_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi_set_master_end_abstraction_level( wire_level, TLM_level );
    endfunction

    //------------------------------------------------------------------------------
    // Function: axi_get_master_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to return the Abstraction level setting for the master end.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels
    //     and how they affect the behaviour of the MVC.
    //
    // Parameters:
    //
    //    wire_level - Value = 1 if this end is WLM connected.
    //    TLM_level -  Value = 1 if this end is TLM connected.
    //------------------------------------------------------------------------------
    function void axi_get_master_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi_get_master_end_abstraction_level( wire_level, TLM_level );
    endfunction

    //------------------------------------------------------------------------------
    // Function: axi_set_slave_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to set whether the <slave> end of the interface is WLM or TLM connected.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels,
    //     how they affect the behaviour of the QVIP, and guidelines for setting them.
    //
    // Parameters:
    //    wire_level - Set to 1 to be WLM connected.
    //    TLM_level -  Set to 1 to be TLM connected.
    //------------------------------------------------------------------------------
    function void axi_set_slave_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi_set_slave_end_abstraction_level( wire_level, TLM_level );
    endfunction

    //------------------------------------------------------------------------------
    // Function: axi_get_slave_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to return the Abstraction level setting for the slave end.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels
    //     and how they affect the behaviour of the MVC.
    //
    // Parameters:
    //
    //    wire_level - Value = 1 if this end is WLM connected.
    //    TLM_level -  Value = 1 if this end is TLM connected.
    //------------------------------------------------------------------------------
    function void axi_get_slave_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi_get_slave_end_abstraction_level( wire_level, TLM_level );
    endfunction

    //------------------------------------------------------------------------------
    // Function: axi_set_clock_source_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to set whether the <clock_source> end of the interface is WLM or TLM connected.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels,
    //     how they affect the behaviour of the QVIP, and guidelines for setting them.
    //
    // Parameters:
    //    wire_level - Set to 1 to be WLM connected.
    //    TLM_level -  Set to 1 to be TLM connected.
    //------------------------------------------------------------------------------
    function void axi_set_clock_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi_set_clock_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

    //------------------------------------------------------------------------------
    // Function: axi_get_clock_source_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to return the Abstraction level setting for the clock_source end.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels
    //     and how they affect the behaviour of the MVC.
    //
    // Parameters:
    //
    //    wire_level - Value = 1 if this end is WLM connected.
    //    TLM_level -  Value = 1 if this end is TLM connected.
    //------------------------------------------------------------------------------
    function void axi_get_clock_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi_get_clock_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

    //------------------------------------------------------------------------------
    // Function: axi_set_reset_source_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to set whether the <reset_source> end of the interface is WLM or TLM connected.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels,
    //     how they affect the behaviour of the QVIP, and guidelines for setting them.
    //
    // Parameters:
    //    wire_level - Set to 1 to be WLM connected.
    //    TLM_level -  Set to 1 to be TLM connected.
    //------------------------------------------------------------------------------
    function void axi_set_reset_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi_set_reset_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

    //------------------------------------------------------------------------------
    // Function: axi_get_reset_source_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to return the Abstraction level setting for the reset_source end.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels
    //     and how they affect the behaviour of the MVC.
    //
    // Parameters:
    //
    //    wire_level - Value = 1 if this end is WLM connected.
    //    TLM_level -  Value = 1 if this end is TLM connected.
    //------------------------------------------------------------------------------
    function void axi_get_reset_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi_get_reset_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

// Variable monitors

    function automatic void axi_local_set_config_clk_init_value_from_SystemVerilog( ref bit config_clk_init_value_param );
        axi_set_config_clk_init_value_from_SystemVerilog( config_clk_init_value );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_clk_init_value_from_SystemVerilog( config_clk_init_value );
            end
        end
    end

    function automatic void axi_local_set_config_clk_phase_shift_from_SystemVerilog( ref int config_clk_phase_shift_param );
        axi_set_config_clk_phase_shift_from_SystemVerilog( config_clk_phase_shift );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_clk_phase_shift_from_SystemVerilog( config_clk_phase_shift );
            end
        end
    end

    function automatic void axi_local_set_config_clk_1st_time_from_SystemVerilog( ref int config_clk_1st_time_param );
        axi_set_config_clk_1st_time_from_SystemVerilog( config_clk_1st_time );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_clk_1st_time_from_SystemVerilog( config_clk_1st_time );
            end
        end
    end

    function automatic void axi_local_set_config_clk_2nd_time_from_SystemVerilog( ref int config_clk_2nd_time_param );
        axi_set_config_clk_2nd_time_from_SystemVerilog( config_clk_2nd_time );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_clk_2nd_time_from_SystemVerilog( config_clk_2nd_time );
            end
        end
    end

    function automatic void axi_local_set_config_setup_time_from_SystemVerilog( ref int config_setup_time_param );
        axi_set_config_setup_time_from_SystemVerilog( config_setup_time );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_setup_time_from_SystemVerilog( config_setup_time );
            end
        end
    end

    function automatic void axi_local_set_config_hold_time_from_SystemVerilog( ref int config_hold_time_param );
        axi_set_config_hold_time_from_SystemVerilog( config_hold_time );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_hold_time_from_SystemVerilog( config_hold_time );
            end
        end
    end

    function automatic void axi_local_set_config_max_transaction_time_factor_from_SystemVerilog( ref int unsigned config_max_transaction_time_factor_param );
        axi_set_config_max_transaction_time_factor_from_SystemVerilog( config_max_transaction_time_factor );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_transaction_time_factor_from_SystemVerilog( config_max_transaction_time_factor );
            end
        end
    end

    function automatic void axi_local_set_config_timeout_max_data_transfer_from_SystemVerilog( ref int config_timeout_max_data_transfer_param );
        axi_set_config_timeout_max_data_transfer_from_SystemVerilog( config_timeout_max_data_transfer );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_timeout_max_data_transfer_from_SystemVerilog( config_timeout_max_data_transfer );
            end
        end
    end

    function automatic void axi_local_set_config_burst_timeout_factor_from_SystemVerilog( ref int unsigned config_burst_timeout_factor_param );
        axi_set_config_burst_timeout_factor_from_SystemVerilog( config_burst_timeout_factor );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_burst_timeout_factor_from_SystemVerilog( config_burst_timeout_factor );
            end
        end
    end

    function automatic void axi_local_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog( ref int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
        axi_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog( config_max_latency_AWVALID_assertion_to_AWREADY );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog( config_max_latency_AWVALID_assertion_to_AWREADY );
            end
        end
    end

    function automatic void axi_local_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog( ref int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
        axi_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog( config_max_latency_ARVALID_assertion_to_ARREADY );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog( config_max_latency_ARVALID_assertion_to_ARREADY );
            end
        end
    end

    function automatic void axi_local_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog( ref int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
        axi_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog( config_max_latency_RVALID_assertion_to_RREADY );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog( config_max_latency_RVALID_assertion_to_RREADY );
            end
        end
    end

    function automatic void axi_local_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog( ref int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
        axi_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog( config_max_latency_BVALID_assertion_to_BREADY );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog( config_max_latency_BVALID_assertion_to_BREADY );
            end
        end
    end

    function automatic void axi_local_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog( ref int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
        axi_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog( config_max_latency_WVALID_assertion_to_WREADY );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog( config_max_latency_WVALID_assertion_to_WREADY );
            end
        end
    end

    function automatic void axi_local_set_config_write_ctrl_first_ratio_from_SystemVerilog( ref int config_write_ctrl_first_ratio_param );
        axi_set_config_write_ctrl_first_ratio_from_SystemVerilog( config_write_ctrl_first_ratio );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_write_ctrl_first_ratio_from_SystemVerilog( config_write_ctrl_first_ratio );
            end
        end
    end

    function automatic void axi_local_set_config_write_data_first_ratio_from_SystemVerilog( ref int config_write_data_first_ratio_param );
        axi_set_config_write_data_first_ratio_from_SystemVerilog( config_write_data_first_ratio );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_write_data_first_ratio_from_SystemVerilog( config_write_data_first_ratio );
            end
        end
    end

    function automatic void axi_local_set_config_write_ctrl_to_data_mintime_from_SystemVerilog( ref int unsigned config_write_ctrl_to_data_mintime_param );
        axi_set_config_write_ctrl_to_data_mintime_from_SystemVerilog( config_write_ctrl_to_data_mintime );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_write_ctrl_to_data_mintime_from_SystemVerilog( config_write_ctrl_to_data_mintime );
            end
        end
    end

    function automatic void axi_local_set_config_write_data_to_ctrl_mintime_from_SystemVerilog( ref int unsigned config_write_data_to_ctrl_mintime_param );
        axi_set_config_write_data_to_ctrl_mintime_from_SystemVerilog( config_write_data_to_ctrl_mintime );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_write_data_to_ctrl_mintime_from_SystemVerilog( config_write_data_to_ctrl_mintime );
            end
        end
    end

    function automatic void axi_local_set_config_master_write_delay_from_SystemVerilog( ref bit config_master_write_delay_param );
        axi_set_config_master_write_delay_from_SystemVerilog( config_master_write_delay );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_master_write_delay_from_SystemVerilog( config_master_write_delay );
            end
        end
    end

    function automatic void axi_local_set_config_reset_low_clocks_from_SystemVerilog( ref int config_reset_low_clocks_param );
        axi_set_config_reset_low_clocks_from_SystemVerilog( config_reset_low_clocks );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_reset_low_clocks_from_SystemVerilog( config_reset_low_clocks );
            end
        end
    end

    function automatic void axi_local_set_config_reset_hold_time_from_SystemVerilog( ref int config_reset_hold_time_param );
        axi_set_config_reset_hold_time_from_SystemVerilog( config_reset_hold_time );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_reset_hold_time_from_SystemVerilog( config_reset_hold_time );
            end
        end
    end

    function automatic void axi_local_set_config_protect_ready_from_SystemVerilog( ref bit config_protect_ready_param );
        axi_set_config_protect_ready_from_SystemVerilog( config_protect_ready );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_protect_ready_from_SystemVerilog( config_protect_ready );
            end
        end
    end

    function automatic void axi_local_set_config_enable_user_sideband_from_SystemVerilog( ref bit config_enable_user_sideband_param );
        axi_set_config_enable_user_sideband_from_SystemVerilog( config_enable_user_sideband );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_user_sideband_from_SystemVerilog( config_enable_user_sideband );
            end
        end
    end

    function automatic void axi_local_set_config_extended_length_enable_from_SystemVerilog( ref bit config_extended_length_enable_param );
        axi_set_config_extended_length_enable_from_SystemVerilog( config_extended_length_enable );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_extended_length_enable_from_SystemVerilog( config_extended_length_enable );
            end
        end
    end

    function automatic void axi_local_set_config_enable_burst_reserved_value_from_SystemVerilog( ref bit config_enable_burst_reserved_value_param );
        axi_set_config_enable_burst_reserved_value_from_SystemVerilog( config_enable_burst_reserved_value );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_burst_reserved_value_from_SystemVerilog( config_enable_burst_reserved_value );
            end
        end
    end

    function automatic void axi_local_set_config_enable_lock_reserved_value_from_SystemVerilog( ref bit config_enable_lock_reserved_value_param );
        axi_set_config_enable_lock_reserved_value_from_SystemVerilog( config_enable_lock_reserved_value );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_lock_reserved_value_from_SystemVerilog( config_enable_lock_reserved_value );
            end
        end
    end

    function automatic void axi_local_set_config_enable_cache_reserved_value_from_SystemVerilog( ref bit config_enable_cache_reserved_value_param );
        axi_set_config_enable_cache_reserved_value_from_SystemVerilog( config_enable_cache_reserved_value );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_cache_reserved_value_from_SystemVerilog( config_enable_cache_reserved_value );
            end
        end
    end

    function automatic void axi_local_set_config_enable_all_assertions_from_SystemVerilog( ref bit config_enable_all_assertions_param );
        axi_set_config_enable_all_assertions_from_SystemVerilog( config_enable_all_assertions );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_all_assertions_from_SystemVerilog( config_enable_all_assertions );
            end
        end
    end

    function automatic void axi_local_set_config_enable_assertion_from_SystemVerilog( ref bit [255:0] config_enable_assertion_param );
        axi_set_config_enable_assertion_from_SystemVerilog( config_enable_assertion );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_assertion_from_SystemVerilog( config_enable_assertion );
            end
        end
    end

    function automatic void axi_local_set_config_enable_error_from_SystemVerilog( ref bit [255:0] config_enable_error_param );
        axi_set_config_enable_error_from_SystemVerilog( config_enable_error );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_error_from_SystemVerilog( config_enable_error );
            end
        end
    end

    function automatic void axi_local_set_config_enable_errors_from_SystemVerilog( ref bit config_enable_errors_param );
        axi_set_config_enable_errors_from_SystemVerilog( config_enable_errors );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_errors_from_SystemVerilog( config_enable_errors );
            end
        end
    end

    function automatic void axi_local_set_config_enable_all_assertion_errors_from_SystemVerilog( ref bit config_enable_all_assertion_errors_param );
        axi_set_config_enable_all_assertion_errors_from_SystemVerilog( config_enable_all_assertion_errors );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_all_assertion_errors_from_SystemVerilog( config_enable_all_assertion_errors );
            end
        end
    end

    function automatic void axi_local_set_config_abstraction_level_from_SystemVerilog( ref axi_abstraction_level_e config_abstraction_level_param );
        axi_set_config_abstraction_level_from_SystemVerilog( config_abstraction_level );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_abstraction_level_from_SystemVerilog( config_abstraction_level );
            end
        end
    end

    function automatic void axi_local_set_config_slave_start_addr_from_SystemVerilog( ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param );
        axi_set_config_slave_start_addr_from_SystemVerilog( config_slave_start_addr );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_slave_start_addr_from_SystemVerilog( config_slave_start_addr );
            end
        end
    end

    function automatic void axi_local_set_config_slave_end_addr_from_SystemVerilog( ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param );
        axi_set_config_slave_end_addr_from_SystemVerilog( config_slave_end_addr );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_slave_end_addr_from_SystemVerilog( config_slave_end_addr );
            end
        end
    end

    function automatic void axi_local_set_config_enable_slave_addr_range_in_bfm_from_SystemVerilog( ref bit config_enable_slave_addr_range_in_bfm_param );
        axi_set_config_enable_slave_addr_range_in_bfm_from_SystemVerilog( config_enable_slave_addr_range_in_bfm );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_slave_addr_range_in_bfm_from_SystemVerilog( config_enable_slave_addr_range_in_bfm );
            end
        end
    end

    function automatic void axi_local_set_config_read_data_reordering_depth_from_SystemVerilog( ref int unsigned config_read_data_reordering_depth_param );
        axi_set_config_read_data_reordering_depth_from_SystemVerilog( config_read_data_reordering_depth );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_read_data_reordering_depth_from_SystemVerilog( config_read_data_reordering_depth );
            end
        end
    end

    function automatic void axi_local_set_config_enable_read_data_reordering_depth_in_bfm_from_SystemVerilog( ref bit config_enable_read_data_reordering_depth_in_bfm_param );
        axi_set_config_enable_read_data_reordering_depth_in_bfm_from_SystemVerilog( config_enable_read_data_reordering_depth_in_bfm );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_read_data_reordering_depth_in_bfm_from_SystemVerilog( config_enable_read_data_reordering_depth_in_bfm );
            end
        end
    end

    function automatic void axi_local_set_config_awid_wid_mismatch_from_SystemVerilog( ref bit config_awid_wid_mismatch_param );
        axi_set_config_awid_wid_mismatch_from_SystemVerilog( config_awid_wid_mismatch );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_awid_wid_mismatch_from_SystemVerilog( config_awid_wid_mismatch );
            end
        end
    end

    function automatic void axi_local_set_config_length_last_mismatch_error_from_SystemVerilog( ref bit config_length_last_mismatch_error_param );
        axi_set_config_length_last_mismatch_error_from_SystemVerilog( config_length_last_mismatch_error );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_length_last_mismatch_error_from_SystemVerilog( config_length_last_mismatch_error );
            end
        end
    end

    function automatic void axi_local_set_config_master_error_position_from_SystemVerilog( ref axi_error_e config_master_error_position_param );
        axi_set_config_master_error_position_from_SystemVerilog( config_master_error_position );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_master_error_position_from_SystemVerilog( config_master_error_position );
            end
        end
    end

    function automatic void axi_local_set_dummy_var_from_SystemVerilog( ref axi_assertion_type_e dummy_var_param );
        axi_set_dummy_var_from_SystemVerilog( dummy_var );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_dummy_var_from_SystemVerilog( dummy_var );
            end
        end
    end

    function automatic void axi_local_set_config_wlast_length_from_SystemVerilog( ref int config_wlast_length_param );
        axi_set_config_wlast_length_from_SystemVerilog( config_wlast_length );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_wlast_length_from_SystemVerilog( config_wlast_length );
            end
        end
    end

    function automatic void axi_local_set_config_wid_for_awid_not_matching_from_SystemVerilog( ref bit [((AXI_ID_WIDTH) - 1):0]  config_wid_for_awid_not_matching_param );
        axi_set_config_wid_for_awid_not_matching_from_SystemVerilog( config_wid_for_awid_not_matching );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_wid_for_awid_not_matching_from_SystemVerilog( config_wid_for_awid_not_matching );
            end
        end
    end

    function automatic void axi_local_set_config_support_exclusive_access_from_SystemVerilog( ref bit config_support_exclusive_access_param );
        axi_set_config_support_exclusive_access_from_SystemVerilog( config_support_exclusive_access );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_support_exclusive_access_from_SystemVerilog( config_support_exclusive_access );
            end
        end
    end

    function automatic void axi_local_set_config_write_data_interleaving_depth_from_SystemVerilog( ref int config_write_data_interleaving_depth_param );
        axi_set_config_write_data_interleaving_depth_from_SystemVerilog( config_write_data_interleaving_depth );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_write_data_interleaving_depth_from_SystemVerilog( config_write_data_interleaving_depth );
            end
        end
    end

    function automatic void axi_local_set_status_master_error_from_SystemVerilog( ref bit [15:0] status_master_error_param );
        axi_set_status_master_error_from_SystemVerilog( status_master_error );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_status_master_error_from_SystemVerilog( status_master_error );
            end
        end
    end

    function automatic void axi_local_set_check_total_num_wdata_outstanding_from_SystemVerilog( ref bit check_total_num_wdata_outstanding_param );
        axi_set_check_total_num_wdata_outstanding_from_SystemVerilog( check_total_num_wdata_outstanding );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_check_total_num_wdata_outstanding_from_SystemVerilog( check_total_num_wdata_outstanding );
            end
        end
    end

    function automatic void axi_local_set_total_num_wdata_outstanding_from_SystemVerilog( ref int total_num_wdata_outstanding_param );
        axi_set_total_num_wdata_outstanding_from_SystemVerilog( total_num_wdata_outstanding );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_total_num_wdata_outstanding_from_SystemVerilog( total_num_wdata_outstanding );
            end
        end
    end

    function automatic void axi_local_set_check_max_num_wdata_outstanding_per_id_from_SystemVerilog( ref bit check_max_num_wdata_outstanding_per_id_param );
        axi_set_check_max_num_wdata_outstanding_per_id_from_SystemVerilog( check_max_num_wdata_outstanding_per_id );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_check_max_num_wdata_outstanding_per_id_from_SystemVerilog( check_max_num_wdata_outstanding_per_id );
            end
        end
    end

    function automatic void axi_local_set_max_num_wdata_outstanding_per_id_from_SystemVerilog( ref int max_num_wdata_outstanding_per_id_param );
        axi_set_max_num_wdata_outstanding_per_id_from_SystemVerilog( max_num_wdata_outstanding_per_id );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_max_num_wdata_outstanding_per_id_from_SystemVerilog( max_num_wdata_outstanding_per_id );
            end
        end
    end

    function automatic void axi_local_set_check_max_num_waddr_outstanding_per_id_from_SystemVerilog( ref bit check_max_num_waddr_outstanding_per_id_param );
        axi_set_check_max_num_waddr_outstanding_per_id_from_SystemVerilog( check_max_num_waddr_outstanding_per_id );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_check_max_num_waddr_outstanding_per_id_from_SystemVerilog( check_max_num_waddr_outstanding_per_id );
            end
        end
    end

    function automatic void axi_local_set_max_num_waddr_outstanding_per_id_from_SystemVerilog( ref int max_num_waddr_outstanding_per_id_param );
        axi_set_max_num_waddr_outstanding_per_id_from_SystemVerilog( max_num_waddr_outstanding_per_id );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_max_num_waddr_outstanding_per_id_from_SystemVerilog( max_num_waddr_outstanding_per_id );
            end
        end
    end

    function automatic void axi_local_set_check_total_num_waddr_outstanding_from_SystemVerilog( ref bit check_total_num_waddr_outstanding_param );
        axi_set_check_total_num_waddr_outstanding_from_SystemVerilog( check_total_num_waddr_outstanding );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_check_total_num_waddr_outstanding_from_SystemVerilog( check_total_num_waddr_outstanding );
            end
        end
    end

    function automatic void axi_local_set_total_num_waddr_outstanding_from_SystemVerilog( ref int total_num_waddr_outstanding_param );
        axi_set_total_num_waddr_outstanding_from_SystemVerilog( total_num_waddr_outstanding );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_total_num_waddr_outstanding_from_SystemVerilog( total_num_waddr_outstanding );
            end
        end
    end

    function automatic void axi_local_set_status_outstanding_num_for_waddr_from_SystemVerilog( ref int status_outstanding_num_for_waddr_param );
        axi_set_status_outstanding_num_for_waddr_from_SystemVerilog( status_outstanding_num_for_waddr );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_status_outstanding_num_for_waddr_from_SystemVerilog( status_outstanding_num_for_waddr );
            end
        end
    end

    function automatic void axi_local_set_start_finding_outstanding_waddr_from_SystemVerilog( ref bit start_finding_outstanding_waddr_param );
        axi_set_start_finding_outstanding_waddr_from_SystemVerilog( start_finding_outstanding_waddr );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_start_finding_outstanding_waddr_from_SystemVerilog( start_finding_outstanding_waddr );
            end
        end
    end

    function automatic void axi_local_set_status_outstanding_num_for_wdata_from_SystemVerilog( ref int status_outstanding_num_for_wdata_param );
        axi_set_status_outstanding_num_for_wdata_from_SystemVerilog( status_outstanding_num_for_wdata );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_status_outstanding_num_for_wdata_from_SystemVerilog( status_outstanding_num_for_wdata );
            end
        end
    end

    function automatic void axi_local_set_start_finding_outstanding_wdata_from_SystemVerilog( ref bit start_finding_outstanding_wdata_param );
        axi_set_start_finding_outstanding_wdata_from_SystemVerilog( start_finding_outstanding_wdata );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_start_finding_outstanding_wdata_from_SystemVerilog( start_finding_outstanding_wdata );
            end
        end
    end

    function automatic void axi_local_set_find_waddr_outstanding_for_wid_from_SystemVerilog( ref bit [((AXI_ID_WIDTH) - 1):0]  find_waddr_outstanding_for_wid_param );
        axi_set_find_waddr_outstanding_for_wid_from_SystemVerilog( find_waddr_outstanding_for_wid );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_find_waddr_outstanding_for_wid_from_SystemVerilog( find_waddr_outstanding_for_wid );
            end
        end
    end

    function automatic void axi_local_set_find_wdata_outstanding_for_wid_from_SystemVerilog( ref bit [((AXI_ID_WIDTH) - 1):0]  find_wdata_outstanding_for_wid_param );
        axi_set_find_wdata_outstanding_for_wid_from_SystemVerilog( find_wdata_outstanding_for_wid );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_find_wdata_outstanding_for_wid_from_SystemVerilog( find_wdata_outstanding_for_wid );
            end
        end
    end

    function automatic void axi_local_set_change_in_wdata_outstanding_per_id_from_SystemVerilog( ref bit change_in_wdata_outstanding_per_id_param );
        axi_set_change_in_wdata_outstanding_per_id_from_SystemVerilog( change_in_wdata_outstanding_per_id );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_change_in_wdata_outstanding_per_id_from_SystemVerilog( change_in_wdata_outstanding_per_id );
            end
        end
    end

    function automatic void axi_local_set_start_finding_change_in_wdata_from_SystemVerilog( ref bit start_finding_change_in_wdata_param );
        axi_set_start_finding_change_in_wdata_from_SystemVerilog( start_finding_change_in_wdata );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_start_finding_change_in_wdata_from_SystemVerilog( start_finding_change_in_wdata );
            end
        end
    end

    function automatic void axi_local_set_find_change_in_wdata_outstanding_for_wid_from_SystemVerilog( ref bit [((AXI_ID_WIDTH) - 1):0]  find_change_in_wdata_outstanding_for_wid_param );
        axi_set_find_change_in_wdata_outstanding_for_wid_from_SystemVerilog( find_change_in_wdata_outstanding_for_wid );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_find_change_in_wdata_outstanding_for_wid_from_SystemVerilog( find_change_in_wdata_outstanding_for_wid );
            end
        end
    end

    function automatic void axi_local_set_config_max_outstanding_wr_from_SystemVerilog( ref int config_max_outstanding_wr_param );
        axi_set_config_max_outstanding_wr_from_SystemVerilog( config_max_outstanding_wr );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_outstanding_wr_from_SystemVerilog( config_max_outstanding_wr );
            end
        end
    end

    function automatic void axi_local_set_config_max_outstanding_rd_from_SystemVerilog( ref int config_max_outstanding_rd_param );
        axi_set_config_max_outstanding_rd_from_SystemVerilog( config_max_outstanding_rd );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_outstanding_rd_from_SystemVerilog( config_max_outstanding_rd );
            end
        end
    end

    function automatic void axi_local_set_config_error_on_deleted_valid_cycles_from_SystemVerilog( ref bit config_error_on_deleted_valid_cycles_param );
        axi_set_config_error_on_deleted_valid_cycles_from_SystemVerilog( config_error_on_deleted_valid_cycles );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_error_on_deleted_valid_cycles_from_SystemVerilog( config_error_on_deleted_valid_cycles );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_from_SystemVerilog( ref bit config_stats_enable_param );
        axi_set_config_stats_enable_from_SystemVerilog( config_stats_enable );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_from_SystemVerilog( config_stats_enable );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_AXI_read_occupancy_from_SystemVerilog( ref bit config_stats_enable_AXI_read_occupancy_param );
        axi_set_config_stats_enable_AXI_read_occupancy_from_SystemVerilog( config_stats_enable_AXI_read_occupancy );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_AXI_read_occupancy_from_SystemVerilog( config_stats_enable_AXI_read_occupancy );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_AXI_write_occupancy_from_SystemVerilog( ref bit config_stats_enable_AXI_write_occupancy_param );
        axi_set_config_stats_enable_AXI_write_occupancy_from_SystemVerilog( config_stats_enable_AXI_write_occupancy );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_AXI_write_occupancy_from_SystemVerilog( config_stats_enable_AXI_write_occupancy );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_read_data_occupancy_from_SystemVerilog( ref bit config_stats_enable_read_data_occupancy_param );
        axi_set_config_stats_enable_read_data_occupancy_from_SystemVerilog( config_stats_enable_read_data_occupancy );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_read_data_occupancy_from_SystemVerilog( config_stats_enable_read_data_occupancy );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_write_data_occupancy_from_SystemVerilog( ref bit config_stats_enable_write_data_occupancy_param );
        axi_set_config_stats_enable_write_data_occupancy_from_SystemVerilog( config_stats_enable_write_data_occupancy );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_write_data_occupancy_from_SystemVerilog( config_stats_enable_write_data_occupancy );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_read_latency_from_SystemVerilog( ref bit config_stats_enable_read_latency_param );
        axi_set_config_stats_enable_read_latency_from_SystemVerilog( config_stats_enable_read_latency );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_read_latency_from_SystemVerilog( config_stats_enable_read_latency );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_write_latency_from_SystemVerilog( ref bit config_stats_enable_write_latency_param );
        axi_set_config_stats_enable_write_latency_from_SystemVerilog( config_stats_enable_write_latency );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_write_latency_from_SystemVerilog( config_stats_enable_write_latency );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_read_address_waits_from_SystemVerilog( ref bit config_stats_enable_read_address_waits_param );
        axi_set_config_stats_enable_read_address_waits_from_SystemVerilog( config_stats_enable_read_address_waits );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_read_address_waits_from_SystemVerilog( config_stats_enable_read_address_waits );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_read_data_waits_from_SystemVerilog( ref bit config_stats_enable_read_data_waits_param );
        axi_set_config_stats_enable_read_data_waits_from_SystemVerilog( config_stats_enable_read_data_waits );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_read_data_waits_from_SystemVerilog( config_stats_enable_read_data_waits );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_write_address_waits_from_SystemVerilog( ref bit config_stats_enable_write_address_waits_param );
        axi_set_config_stats_enable_write_address_waits_from_SystemVerilog( config_stats_enable_write_address_waits );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_write_address_waits_from_SystemVerilog( config_stats_enable_write_address_waits );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_write_data_waits_from_SystemVerilog( ref bit config_stats_enable_write_data_waits_param );
        axi_set_config_stats_enable_write_data_waits_from_SystemVerilog( config_stats_enable_write_data_waits );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_write_data_waits_from_SystemVerilog( config_stats_enable_write_data_waits );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_write_response_waits_from_SystemVerilog( ref bit config_stats_enable_write_response_waits_param );
        axi_set_config_stats_enable_write_response_waits_from_SystemVerilog( config_stats_enable_write_response_waits );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_write_response_waits_from_SystemVerilog( config_stats_enable_write_response_waits );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_read_bandwidth_from_SystemVerilog( ref bit config_stats_enable_read_bandwidth_param );
        axi_set_config_stats_enable_read_bandwidth_from_SystemVerilog( config_stats_enable_read_bandwidth );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_read_bandwidth_from_SystemVerilog( config_stats_enable_read_bandwidth );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_write_bandwidth_from_SystemVerilog( ref bit config_stats_enable_write_bandwidth_param );
        axi_set_config_stats_enable_write_bandwidth_from_SystemVerilog( config_stats_enable_write_bandwidth );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_write_bandwidth_from_SystemVerilog( config_stats_enable_write_bandwidth );
            end
        end
    end

    function automatic void axi_local_set_config_stats_AXI_read_occupancy_step_from_SystemVerilog( ref int config_stats_AXI_read_occupancy_step_param );
        axi_set_config_stats_AXI_read_occupancy_step_from_SystemVerilog( config_stats_AXI_read_occupancy_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_AXI_read_occupancy_step_from_SystemVerilog( config_stats_AXI_read_occupancy_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_AXI_read_occupancy_multiple_from_SystemVerilog( ref int config_stats_AXI_read_occupancy_multiple_param );
        axi_set_config_stats_AXI_read_occupancy_multiple_from_SystemVerilog( config_stats_AXI_read_occupancy_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_AXI_read_occupancy_multiple_from_SystemVerilog( config_stats_AXI_read_occupancy_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_AXI_write_occupancy_step_from_SystemVerilog( ref int config_stats_AXI_write_occupancy_step_param );
        axi_set_config_stats_AXI_write_occupancy_step_from_SystemVerilog( config_stats_AXI_write_occupancy_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_AXI_write_occupancy_step_from_SystemVerilog( config_stats_AXI_write_occupancy_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_AXI_write_occupancy_multiple_from_SystemVerilog( ref int config_stats_AXI_write_occupancy_multiple_param );
        axi_set_config_stats_AXI_write_occupancy_multiple_from_SystemVerilog( config_stats_AXI_write_occupancy_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_AXI_write_occupancy_multiple_from_SystemVerilog( config_stats_AXI_write_occupancy_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_data_occupancy_step_from_SystemVerilog( ref int config_stats_read_data_occupancy_step_param );
        axi_set_config_stats_read_data_occupancy_step_from_SystemVerilog( config_stats_read_data_occupancy_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_data_occupancy_step_from_SystemVerilog( config_stats_read_data_occupancy_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog( ref int config_stats_read_data_occupancy_multiple_param );
        axi_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog( config_stats_read_data_occupancy_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog( config_stats_read_data_occupancy_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_data_occupancy_step_from_SystemVerilog( ref int config_stats_write_data_occupancy_step_param );
        axi_set_config_stats_write_data_occupancy_step_from_SystemVerilog( config_stats_write_data_occupancy_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_data_occupancy_step_from_SystemVerilog( config_stats_write_data_occupancy_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog( ref int config_stats_write_data_occupancy_multiple_param );
        axi_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog( config_stats_write_data_occupancy_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog( config_stats_write_data_occupancy_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_bandwidth_step_from_SystemVerilog( ref int config_stats_read_bandwidth_step_param );
        axi_set_config_stats_read_bandwidth_step_from_SystemVerilog( config_stats_read_bandwidth_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_bandwidth_step_from_SystemVerilog( config_stats_read_bandwidth_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_bandwidth_multiple_from_SystemVerilog( ref int config_stats_read_bandwidth_multiple_param );
        axi_set_config_stats_read_bandwidth_multiple_from_SystemVerilog( config_stats_read_bandwidth_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_bandwidth_multiple_from_SystemVerilog( config_stats_read_bandwidth_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_bandwidth_step_from_SystemVerilog( ref int config_stats_write_bandwidth_step_param );
        axi_set_config_stats_write_bandwidth_step_from_SystemVerilog( config_stats_write_bandwidth_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_bandwidth_step_from_SystemVerilog( config_stats_write_bandwidth_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_bandwidth_multiple_from_SystemVerilog( ref int config_stats_write_bandwidth_multiple_param );
        axi_set_config_stats_write_bandwidth_multiple_from_SystemVerilog( config_stats_write_bandwidth_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_bandwidth_multiple_from_SystemVerilog( config_stats_write_bandwidth_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_latency_step_from_SystemVerilog( ref int config_stats_read_latency_step_param );
        axi_set_config_stats_read_latency_step_from_SystemVerilog( config_stats_read_latency_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_latency_step_from_SystemVerilog( config_stats_read_latency_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_latency_multiple_from_SystemVerilog( ref int config_stats_read_latency_multiple_param );
        axi_set_config_stats_read_latency_multiple_from_SystemVerilog( config_stats_read_latency_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_latency_multiple_from_SystemVerilog( config_stats_read_latency_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_latency_step_from_SystemVerilog( ref int config_stats_write_latency_step_param );
        axi_set_config_stats_write_latency_step_from_SystemVerilog( config_stats_write_latency_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_latency_step_from_SystemVerilog( config_stats_write_latency_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_latency_multiple_from_SystemVerilog( ref int config_stats_write_latency_multiple_param );
        axi_set_config_stats_write_latency_multiple_from_SystemVerilog( config_stats_write_latency_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_latency_multiple_from_SystemVerilog( config_stats_write_latency_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_address_waits_step_from_SystemVerilog( ref int config_stats_read_address_waits_step_param );
        axi_set_config_stats_read_address_waits_step_from_SystemVerilog( config_stats_read_address_waits_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_address_waits_step_from_SystemVerilog( config_stats_read_address_waits_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_address_waits_multiple_from_SystemVerilog( ref int config_stats_read_address_waits_multiple_param );
        axi_set_config_stats_read_address_waits_multiple_from_SystemVerilog( config_stats_read_address_waits_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_address_waits_multiple_from_SystemVerilog( config_stats_read_address_waits_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_data_waits_step_from_SystemVerilog( ref int config_stats_read_data_waits_step_param );
        axi_set_config_stats_read_data_waits_step_from_SystemVerilog( config_stats_read_data_waits_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_data_waits_step_from_SystemVerilog( config_stats_read_data_waits_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_data_waits_multiple_from_SystemVerilog( ref int config_stats_read_data_waits_multiple_param );
        axi_set_config_stats_read_data_waits_multiple_from_SystemVerilog( config_stats_read_data_waits_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_data_waits_multiple_from_SystemVerilog( config_stats_read_data_waits_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_address_waits_step_from_SystemVerilog( ref int config_stats_write_address_waits_step_param );
        axi_set_config_stats_write_address_waits_step_from_SystemVerilog( config_stats_write_address_waits_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_address_waits_step_from_SystemVerilog( config_stats_write_address_waits_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_address_waits_multiple_from_SystemVerilog( ref int config_stats_write_address_waits_multiple_param );
        axi_set_config_stats_write_address_waits_multiple_from_SystemVerilog( config_stats_write_address_waits_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_address_waits_multiple_from_SystemVerilog( config_stats_write_address_waits_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_data_waits_step_from_SystemVerilog( ref int config_stats_write_data_waits_step_param );
        axi_set_config_stats_write_data_waits_step_from_SystemVerilog( config_stats_write_data_waits_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_data_waits_step_from_SystemVerilog( config_stats_write_data_waits_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_data_waits_multiple_from_SystemVerilog( ref int config_stats_write_data_waits_multiple_param );
        axi_set_config_stats_write_data_waits_multiple_from_SystemVerilog( config_stats_write_data_waits_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_data_waits_multiple_from_SystemVerilog( config_stats_write_data_waits_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_response_waits_step_from_SystemVerilog( ref int config_stats_write_response_waits_step_param );
        axi_set_config_stats_write_response_waits_step_from_SystemVerilog( config_stats_write_response_waits_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_response_waits_step_from_SystemVerilog( config_stats_write_response_waits_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_response_waits_multiple_from_SystemVerilog( ref int config_stats_write_response_waits_multiple_param );
        axi_set_config_stats_write_response_waits_multiple_from_SystemVerilog( config_stats_write_response_waits_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_response_waits_multiple_from_SystemVerilog( config_stats_write_response_waits_multiple );
            end
        end
    end

    //------------------------------------------------------------------------------
    // Transaction interface
    //------------------------------------------------------------------------------

    task automatic dvc_activate_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi_size_e size,
        ref axi_burst_e burst,
        ref axi_lock_e lock,
        ref axi_cache_e cache,
        ref axi_prot_e prot,
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [3:0] burst_length,
        ref bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref axi_response_e resp[],
        ref bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        ref bit [7:0] resp_user,
        ref axi_rw_e read_or_write,
        ref int address_to_data_latency,
        ref int data_to_response_latency,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        ref int address_valid_delay,
        ref int data_valid_delay[],
        ref int write_response_valid_delay,
        ref int address_ready_delay,
        ref int data_ready_delay[],
        ref int write_response_ready_delay,
        ref bit write_data_with_address,
        input int _unit_id = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int resp_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_valid_delay_DIMS0;
                automatic int data_ready_delay_DIMS0;
                // Call function to provide sized and unsized params.
                // In addition gets back updated sizes of unsized params.
                axi_rw_transaction_ActivatesActivatingActivate_SystemVerilog(_comms_semantic,_as_end, _trans_id, addr, size, burst, lock, cache, prot, id, burst_length, data_words, data_words_DIMS0, write_strobes, write_strobes_DIMS0, resp, resp_DIMS0, addr_user, data_user, data_user_DIMS0, resp_user, read_or_write, address_to_data_latency, data_to_response_latency, write_address_to_data_delay, write_data_to_address_delay, write_data_beats_delay, write_data_beats_delay_DIMS0, address_valid_delay, data_valid_delay, data_valid_delay_DIMS0, write_response_valid_delay, address_ready_delay, data_ready_delay, data_ready_delay_DIMS0, write_response_ready_delay, write_data_with_address, _unit_id); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    data_words = new [data_words_DIMS0];
                end
                else
                begin
                    data_words = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    write_strobes = new [1];  // Create dummy instead of a zero sized array
                end
                if (resp_DIMS0 != 0)
                begin
                    resp = new [resp_DIMS0];
                end
                else
                begin
                    resp = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_user_DIMS0 != 0)
                begin
                    data_user = new [data_user_DIMS0];
                end
                else
                begin
                    data_user = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    write_data_beats_delay = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_valid_delay_DIMS0 != 0)
                begin
                    data_valid_delay = new [data_valid_delay_DIMS0];
                end
                else
                begin
                    data_valid_delay = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_ready_delay_DIMS0 != 0)
                begin
                    data_ready_delay = new [data_ready_delay_DIMS0];
                end
                else
                begin
                    data_ready_delay = new [1];  // Create dummy instead of a zero sized array
                end
                // Call function to get the sized and unsized params
                axi_rw_transaction_ActivatesActivatingActivate_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, addr, size, burst, lock, cache, prot, id, burst_length, data_words, write_strobes, resp, addr_user, data_user, resp_user, read_or_write, address_to_data_latency, data_to_response_latency, write_address_to_data_delay, write_data_to_address_delay, write_data_beats_delay, address_valid_delay, data_valid_delay, write_response_valid_delay, address_ready_delay, data_ready_delay, write_response_ready_delay, write_data_with_address, _unit_id); // DPI call to imported task
                if (data_words_DIMS0 == 0)
                    data_words.delete;  // Delete each zero sized param
                if (write_strobes_DIMS0 == 0)
                    write_strobes.delete;  // Delete each zero sized param
                if (resp_DIMS0 == 0)
                    resp.delete;  // Delete each zero sized param
                if (data_user_DIMS0 == 0)
                    data_user.delete;  // Delete each zero sized param
                if (write_data_beats_delay_DIMS0 == 0)
                    write_data_beats_delay.delete;  // Delete each zero sized param
                if (data_valid_delay_DIMS0 == 0)
                    data_valid_delay.delete;  // Delete each zero sized param
                if (data_ready_delay_DIMS0 == 0)
                    data_ready_delay.delete;  // Delete each zero sized param
            end // Block to create unsized data arrays
        end
    endtask

    task automatic dvc_get_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        ref bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref axi_response_e resp[],
        output bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output axi_rw_e read_or_write,
        output int address_to_data_latency,
        output int data_to_response_latency,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        output int address_valid_delay,
        ref int data_valid_delay[],
        output int write_response_valid_delay,
        output int address_ready_delay,
        ref int data_ready_delay[],
        output int write_response_ready_delay,
        output bit write_data_with_address,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int resp_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_valid_delay_DIMS0;
                automatic int data_ready_delay_DIMS0;
                // Call function to get unsized params sizes.
                axi_rw_transaction_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, write_strobes_DIMS0, resp_DIMS0, data_user_DIMS0, write_data_beats_delay_DIMS0, data_valid_delay_DIMS0, data_ready_delay_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    data_words = new [data_words_DIMS0];
                end
                else
                begin
                    data_words = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    write_strobes = new [1];  // Create dummy instead of a zero sized array
                end
                if (resp_DIMS0 != 0)
                begin
                    resp = new [resp_DIMS0];
                end
                else
                begin
                    resp = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_user_DIMS0 != 0)
                begin
                    data_user = new [data_user_DIMS0];
                end
                else
                begin
                    data_user = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    write_data_beats_delay = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_valid_delay_DIMS0 != 0)
                begin
                    data_valid_delay = new [data_valid_delay_DIMS0];
                end
                else
                begin
                    data_valid_delay = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_ready_delay_DIMS0 != 0)
                begin
                    data_ready_delay = new [data_ready_delay_DIMS0];
                end
                else
                begin
                    data_ready_delay = new [1];  // Create dummy instead of a zero sized array
                end
                // Call function to get the sized and unsized params
                axi_rw_transaction_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, addr, size, burst, lock, cache, prot, id, burst_length, data_words, write_strobes, resp, addr_user, data_user, resp_user, read_or_write, address_to_data_latency, data_to_response_latency, write_address_to_data_delay, write_data_to_address_delay, write_data_beats_delay, address_valid_delay, data_valid_delay, write_response_valid_delay, address_ready_delay, data_ready_delay, write_response_ready_delay, write_data_with_address, _unit_id, _using); // DPI call to imported task
                if (data_words_DIMS0 == 0)
                    data_words.delete;  // Delete each zero sized param
                if (write_strobes_DIMS0 == 0)
                    write_strobes.delete;  // Delete each zero sized param
                if (resp_DIMS0 == 0)
                    resp.delete;  // Delete each zero sized param
                if (data_user_DIMS0 == 0)
                    data_user.delete;  // Delete each zero sized param
                if (write_data_beats_delay_DIMS0 == 0)
                    write_data_beats_delay.delete;  // Delete each zero sized param
                if (data_valid_delay_DIMS0 == 0)
                    data_valid_delay.delete;  // Delete each zero sized param
                if (data_ready_delay_DIMS0 == 0)
                    data_ready_delay.delete;  // Delete each zero sized param
            end // Block to create unsized data arrays
        end
    endtask

    task automatic dvc_activate_AXI_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi_size_e size,
        ref axi_burst_e burst,
        ref axi_lock_e lock,
        ref axi_cache_e cache,
        ref axi_prot_e prot,
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        ref bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        ref int address_to_data_latency,
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int address_valid_delay,
        input int _unit_id = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int resp_DIMS0;
                automatic int data_user_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Call function to provide sized and unsized params.
                // In addition gets back updated sizes of unsized params.
                axi_AXI_read_ActivatesActivatingActivate_SystemVerilog(_comms_semantic,_as_end, _trans_id, addr, size, burst, lock, cache, prot, id, burst_length, data_words, data_words_DIMS0, resp, resp_DIMS0, addr_user, data_user, data_user_DIMS0, address_to_data_latency, addr_start_time, addr_end_time, data_start_time, data_start_time_DIMS0, data_end_time, data_end_time_DIMS0, address_valid_delay, _unit_id); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    data_words = new [data_words_DIMS0];
                end
                else
                begin
                    data_words = new [1];  // Create dummy instead of a zero sized array
                end
                if (resp_DIMS0 != 0)
                begin
                    resp = new [resp_DIMS0];
                end
                else
                begin
                    resp = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_user_DIMS0 != 0)
                begin
                    data_user = new [data_user_DIMS0];
                end
                else
                begin
                    data_user = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    data_start_time = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    data_end_time = new [1];  // Create dummy instead of a zero sized array
                end
                // Call function to get the sized and unsized params
                axi_AXI_read_ActivatesActivatingActivate_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, addr, size, burst, lock, cache, prot, id, burst_length, data_words, resp, addr_user, data_user, address_to_data_latency, addr_start_time, addr_end_time, data_start_time, data_end_time, address_valid_delay, _unit_id); // DPI call to imported task
                if (data_words_DIMS0 == 0)
                    data_words.delete;  // Delete each zero sized param
                if (resp_DIMS0 == 0)
                    resp.delete;  // Delete each zero sized param
                if (data_user_DIMS0 == 0)
                    data_user.delete;  // Delete each zero sized param
                if (data_start_time_DIMS0 == 0)
                    data_start_time.delete;  // Delete each zero sized param
                if (data_end_time_DIMS0 == 0)
                    data_end_time.delete;  // Delete each zero sized param
            end // Block to create unsized data arrays
        end
    endtask

    task automatic dvc_get_AXI_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        output bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        output int address_to_data_latency,
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output int address_valid_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int resp_DIMS0;
                automatic int data_user_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Call function to get unsized params sizes.
                axi_AXI_read_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, resp_DIMS0, data_user_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    data_words = new [data_words_DIMS0];
                end
                else
                begin
                    data_words = new [1];  // Create dummy instead of a zero sized array
                end
                if (resp_DIMS0 != 0)
                begin
                    resp = new [resp_DIMS0];
                end
                else
                begin
                    resp = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_user_DIMS0 != 0)
                begin
                    data_user = new [data_user_DIMS0];
                end
                else
                begin
                    data_user = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    data_start_time = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    data_end_time = new [1];  // Create dummy instead of a zero sized array
                end
                // Call function to get the sized and unsized params
                axi_AXI_read_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, addr, size, burst, lock, cache, prot, id, burst_length, data_words, resp, addr_user, data_user, address_to_data_latency, addr_start_time, addr_end_time, data_start_time, data_end_time, address_valid_delay, _unit_id, _using); // DPI call to imported task
                if (data_words_DIMS0 == 0)
                    data_words.delete;  // Delete each zero sized param
                if (resp_DIMS0 == 0)
                    resp.delete;  // Delete each zero sized param
                if (data_user_DIMS0 == 0)
                    data_user.delete;  // Delete each zero sized param
                if (data_start_time_DIMS0 == 0)
                    data_start_time.delete;  // Delete each zero sized param
                if (data_end_time_DIMS0 == 0)
                    data_end_time.delete;  // Delete each zero sized param
            end // Block to create unsized data arrays
        end
    endtask

    task automatic dvc_activate_AXI_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi_size_e size,
        ref axi_burst_e burst,
        ref axi_lock_e lock,
        ref axi_cache_e cache,
        ref axi_prot_e prot,
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [3:0] burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref axi_response_e resp,
        ref bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        ref bit [7:0] resp_user,
        ref int address_to_data_latency,
        ref int data_to_response_latency,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref longint wr_resp_start_time,
        ref longint wr_resp_end_time,
        ref int address_valid_delay,
        input int _unit_id = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Call function to provide sized and unsized params.
                // In addition gets back updated sizes of unsized params.
                axi_AXI_write_ActivatesActivatingActivate_SystemVerilog(_comms_semantic,_as_end, _trans_id, addr, size, burst, lock, cache, prot, id, burst_length, data_words, data_words_DIMS0, write_strobes, write_strobes_DIMS0, resp, addr_user, data_user, data_user_DIMS0, resp_user, address_to_data_latency, data_to_response_latency, write_address_to_data_delay, write_data_to_address_delay, write_data_beats_delay, write_data_beats_delay_DIMS0, addr_start_time, addr_end_time, data_start_time, data_start_time_DIMS0, data_end_time, data_end_time_DIMS0, wr_resp_start_time, wr_resp_end_time, address_valid_delay, _unit_id); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    data_words = new [data_words_DIMS0];
                end
                else
                begin
                    data_words = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    write_strobes = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_user_DIMS0 != 0)
                begin
                    data_user = new [data_user_DIMS0];
                end
                else
                begin
                    data_user = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    write_data_beats_delay = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    data_start_time = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    data_end_time = new [1];  // Create dummy instead of a zero sized array
                end
                // Call function to get the sized and unsized params
                axi_AXI_write_ActivatesActivatingActivate_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, addr, size, burst, lock, cache, prot, id, burst_length, data_words, write_strobes, resp, addr_user, data_user, resp_user, address_to_data_latency, data_to_response_latency, write_address_to_data_delay, write_data_to_address_delay, write_data_beats_delay, addr_start_time, addr_end_time, data_start_time, data_end_time, wr_resp_start_time, wr_resp_end_time, address_valid_delay, _unit_id); // DPI call to imported task
                if (data_words_DIMS0 == 0)
                    data_words.delete;  // Delete each zero sized param
                if (write_strobes_DIMS0 == 0)
                    write_strobes.delete;  // Delete each zero sized param
                if (data_user_DIMS0 == 0)
                    data_user.delete;  // Delete each zero sized param
                if (write_data_beats_delay_DIMS0 == 0)
                    write_data_beats_delay.delete;  // Delete each zero sized param
                if (data_start_time_DIMS0 == 0)
                    data_start_time.delete;  // Delete each zero sized param
                if (data_end_time_DIMS0 == 0)
                    data_end_time.delete;  // Delete each zero sized param
            end // Block to create unsized data arrays
        end
    endtask

    task automatic dvc_get_AXI_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output axi_response_e resp,
        output bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output int address_to_data_latency,
        output int data_to_response_latency,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output longint wr_resp_start_time,
        output longint wr_resp_end_time,
        output int address_valid_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Call function to get unsized params sizes.
                axi_AXI_write_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, write_strobes_DIMS0, data_user_DIMS0, write_data_beats_delay_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    data_words = new [data_words_DIMS0];
                end
                else
                begin
                    data_words = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    write_strobes = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_user_DIMS0 != 0)
                begin
                    data_user = new [data_user_DIMS0];
                end
                else
                begin
                    data_user = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    write_data_beats_delay = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    data_start_time = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    data_end_time = new [1];  // Create dummy instead of a zero sized array
                end
                // Call function to get the sized and unsized params
                axi_AXI_write_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, addr, size, burst, lock, cache, prot, id, burst_length, data_words, write_strobes, resp, addr_user, data_user, resp_user, address_to_data_latency, data_to_response_latency, write_address_to_data_delay, write_data_to_address_delay, write_data_beats_delay, addr_start_time, addr_end_time, data_start_time, data_end_time, wr_resp_start_time, wr_resp_end_time, address_valid_delay, _unit_id, _using); // DPI call to imported task
                if (data_words_DIMS0 == 0)
                    data_words.delete;  // Delete each zero sized param
                if (write_strobes_DIMS0 == 0)
                    write_strobes.delete;  // Delete each zero sized param
                if (data_user_DIMS0 == 0)
                    data_user.delete;  // Delete each zero sized param
                if (write_data_beats_delay_DIMS0 == 0)
                    write_data_beats_delay.delete;  // Delete each zero sized param
                if (data_start_time_DIMS0 == 0)
                    data_start_time.delete;  // Delete each zero sized param
                if (data_end_time_DIMS0 == 0)
                    data_end_time.delete;  // Delete each zero sized param
            end // Block to create unsized data arrays
        end
    endtask

    task automatic dvc_activate_data_resp
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref axi_response_e resp,
        ref bit [7:0] data_user [],
        ref bit [7:0] resp_user,
        ref longint data_start,
        ref longint data_end,
        ref longint response_start,
        ref int write_data_beats_delay[],
        ref longint data_beat_start_time[],
        ref longint data_beat_end_time[],
        ref longint response_end_time,
        input int _unit_id = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_beat_start_time_DIMS0;
                automatic int data_beat_end_time_DIMS0;
                // Call function to provide sized and unsized params.
                // In addition gets back updated sizes of unsized params.
                axi_data_resp_ActivatesActivatingActivate_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, data_words, data_words_DIMS0, write_strobes, write_strobes_DIMS0, id, resp, data_user, data_user_DIMS0, resp_user, data_start, data_end, response_start, write_data_beats_delay, write_data_beats_delay_DIMS0, data_beat_start_time, data_beat_start_time_DIMS0, data_beat_end_time, data_beat_end_time_DIMS0, response_end_time, _unit_id); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    data_words = new [data_words_DIMS0];
                end
                else
                begin
                    data_words = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    write_strobes = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_user_DIMS0 != 0)
                begin
                    data_user = new [data_user_DIMS0];
                end
                else
                begin
                    data_user = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    write_data_beats_delay = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_beat_start_time_DIMS0 != 0)
                begin
                    data_beat_start_time = new [data_beat_start_time_DIMS0];
                end
                else
                begin
                    data_beat_start_time = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_beat_end_time_DIMS0 != 0)
                begin
                    data_beat_end_time = new [data_beat_end_time_DIMS0];
                end
                else
                begin
                    data_beat_end_time = new [1];  // Create dummy instead of a zero sized array
                end
                // Call function to get the sized and unsized params
                axi_data_resp_ActivatesActivatingActivate_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, data_words, write_strobes, id, resp, data_user, resp_user, data_start, data_end, response_start, write_data_beats_delay, data_beat_start_time, data_beat_end_time, response_end_time, _unit_id); // DPI call to imported task
                if (data_words_DIMS0 == 0)
                    data_words.delete;  // Delete each zero sized param
                if (write_strobes_DIMS0 == 0)
                    write_strobes.delete;  // Delete each zero sized param
                if (data_user_DIMS0 == 0)
                    data_user.delete;  // Delete each zero sized param
                if (write_data_beats_delay_DIMS0 == 0)
                    write_data_beats_delay.delete;  // Delete each zero sized param
                if (data_beat_start_time_DIMS0 == 0)
                    data_beat_start_time.delete;  // Delete each zero sized param
                if (data_beat_end_time_DIMS0 == 0)
                    data_beat_end_time.delete;  // Delete each zero sized param
            end // Block to create unsized data arrays
        end
    endtask

    task automatic dvc_get_data_resp
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output axi_response_e resp,
        ref bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output longint data_start,
        output longint data_end,
        output longint response_start,
        ref int write_data_beats_delay[],
        ref longint data_beat_start_time[],
        ref longint data_beat_end_time[],
        output longint response_end_time,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_beat_start_time_DIMS0;
                automatic int data_beat_end_time_DIMS0;
                // Call function to get unsized params sizes.
                axi_data_resp_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, write_strobes_DIMS0, data_user_DIMS0, write_data_beats_delay_DIMS0, data_beat_start_time_DIMS0, data_beat_end_time_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    data_words = new [data_words_DIMS0];
                end
                else
                begin
                    data_words = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    write_strobes = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_user_DIMS0 != 0)
                begin
                    data_user = new [data_user_DIMS0];
                end
                else
                begin
                    data_user = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    write_data_beats_delay = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_beat_start_time_DIMS0 != 0)
                begin
                    data_beat_start_time = new [data_beat_start_time_DIMS0];
                end
                else
                begin
                    data_beat_start_time = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_beat_end_time_DIMS0 != 0)
                begin
                    data_beat_end_time = new [data_beat_end_time_DIMS0];
                end
                else
                begin
                    data_beat_end_time = new [1];  // Create dummy instead of a zero sized array
                end
                // Call function to get the sized and unsized params
                axi_data_resp_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, data_words, write_strobes, id, resp, data_user, resp_user, data_start, data_end, response_start, write_data_beats_delay, data_beat_start_time, data_beat_end_time, response_end_time, _unit_id, _using); // DPI call to imported task
                if (data_words_DIMS0 == 0)
                    data_words.delete;  // Delete each zero sized param
                if (write_strobes_DIMS0 == 0)
                    write_strobes.delete;  // Delete each zero sized param
                if (data_user_DIMS0 == 0)
                    data_user.delete;  // Delete each zero sized param
                if (write_data_beats_delay_DIMS0 == 0)
                    write_data_beats_delay.delete;  // Delete each zero sized param
                if (data_beat_start_time_DIMS0 == 0)
                    data_beat_start_time.delete;  // Delete each zero sized param
                if (data_beat_end_time_DIMS0 == 0)
                    data_beat_end_time.delete;  // Delete each zero sized param
            end // Block to create unsized data arrays
        end
    endtask

    task automatic dvc_put_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to provide sized and unsized params.
            axi_read_data_burst_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, burst_length, data_words, resp, id, data_user, data_start_time, data_end_time, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int resp_DIMS0;
                automatic int data_user_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Call function to get unsized params sizes.
                axi_read_data_burst_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, resp_DIMS0, data_user_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    data_words = new [data_words_DIMS0];
                end
                else
                begin
                    data_words = new [1];  // Create dummy instead of a zero sized array
                end
                if (resp_DIMS0 != 0)
                begin
                    resp = new [resp_DIMS0];
                end
                else
                begin
                    resp = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_user_DIMS0 != 0)
                begin
                    data_user = new [data_user_DIMS0];
                end
                else
                begin
                    data_user = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    data_start_time = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    data_end_time = new [1];  // Create dummy instead of a zero sized array
                end
                // Call function to get the sized and unsized params
                axi_read_data_burst_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, data_words, resp, id, data_user, data_start_time, data_end_time, _unit_id, _using); // DPI call to imported task
                if (data_words_DIMS0 == 0)
                    data_words.delete;  // Delete each zero sized param
                if (resp_DIMS0 == 0)
                    resp.delete;  // Delete each zero sized param
                if (data_user_DIMS0 == 0)
                    data_user.delete;  // Delete each zero sized param
                if (data_start_time_DIMS0 == 0)
                    data_start_time.delete;  // Delete each zero sized param
                if (data_end_time_DIMS0 == 0)
                    data_end_time.delete;  // Delete each zero sized param
            end // Block to create unsized data arrays
        end
    endtask

    task automatic dvc_put_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref int write_data_beats_delay[],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to provide sized and unsized params.
            axi_write_data_burst_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, burst_length, data_words, write_strobes, id, data_user, write_data_beats_delay, data_start_time, data_end_time, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref int write_data_beats_delay[],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Call function to get unsized params sizes.
                axi_write_data_burst_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, write_strobes_DIMS0, data_user_DIMS0, write_data_beats_delay_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    data_words = new [data_words_DIMS0];
                end
                else
                begin
                    data_words = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    write_strobes = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_user_DIMS0 != 0)
                begin
                    data_user = new [data_user_DIMS0];
                end
                else
                begin
                    data_user = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    write_data_beats_delay = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    data_start_time = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    data_end_time = new [1];  // Create dummy instead of a zero sized array
                end
                // Call function to get the sized and unsized params
                axi_write_data_burst_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, data_words, write_strobes, id, data_user, write_data_beats_delay, data_start_time, data_end_time, _unit_id, _using); // DPI call to imported task
                if (data_words_DIMS0 == 0)
                    data_words.delete;  // Delete each zero sized param
                if (write_strobes_DIMS0 == 0)
                    write_strobes.delete;  // Delete each zero sized param
                if (data_user_DIMS0 == 0)
                    data_user.delete;  // Delete each zero sized param
                if (write_data_beats_delay_DIMS0 == 0)
                    write_data_beats_delay.delete;  // Delete each zero sized param
                if (data_start_time_DIMS0 == 0)
                    data_start_time.delete;  // Delete each zero sized param
                if (data_end_time_DIMS0 == 0)
                    data_end_time.delete;  // Delete each zero sized param
            end // Block to create unsized data arrays
        end
    endtask

    task automatic dvc_put_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_read_addr_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, addr, burst_length, size, burst, lock, cache, prot, id, addr_user, address_valid_delay, address_ready_delay, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_read_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, addr, burst_length, size, burst, lock, cache, prot, id, addr_user, address_valid_delay, address_ready_delay, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int data_ready_delay,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_read_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, last, data, resp, id, data_user, data_ready_delay, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_read_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, last, data, resp, id, data_user, data_ready_delay, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_addr_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, addr, burst_length, size, burst, lock, cache, prot, id, addr_user, address_valid_delay, address_ready_delay, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, addr, burst_length, size, burst, lock, cache, prot, id, addr_user, address_valid_delay, address_ready_delay, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int data_ready_delay,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, last, data, write_strobes, id, data_user, data_ready_delay, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, last, data, write_strobes, id, data_user, data_ready_delay, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] resp_user,
        input int write_response_ready_delay,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_resp_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, resp, id, resp_user, write_response_ready_delay, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] resp_user,
        output int write_response_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_resp_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, resp, id, resp_user, write_response_ready_delay, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_read_addr_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, addr, burst_length, size, burst, lock, cache, prot, id, addr_user, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_read_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, addr, burst_length, size, burst, lock, cache, prot, id, addr_user, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_read_addr_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_read_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_read_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, last, data, resp, id, data_user, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_read_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, last, data, resp, id, data_user, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_read_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_read_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_addr_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, addr, burst_length, size, burst, lock, cache, prot, id, addr_user, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, addr, burst_length, size, burst, lock, cache, prot, id, addr_user, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_addr_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  strb,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, last, data, strb, id, data_user, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  strb,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, last, data, strb, id, data_user, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] resp_user,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_resp_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, resp, id, resp_user, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] resp_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_resp_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, resp, id, resp_user, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_resp_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_resp_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    //-------------------------------------------------------------------------------------
    // Task which blocks and outputs an error if the interface has not initialized properly
    //-------------------------------------------------------------------------------------

    task _initialized();
        if (_interface_ref == 0)
        begin
            $display("Error: %m - Questa Verification IP failed to initialise. Please check questa_mvc.log for details");
            wait(_interface_ref!=0);
        end
    endtask

endinterface

`endif // MODEL_TECH
`ifdef INCA
// *****************************************************************************
//
// Copyright 2007-2013 Mentor Graphics Corporation
// All Rights Reserved.
//
// THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION WHICH IS THE PROPERTY OF
// MENTOR GRAPHICS CORPORATION OR ITS LICENSORS AND IS SUBJECT TO LICENSE TERMS.
//
// *****************************************************************************
// SystemVerilog           Version: 20130911_Questa_10.2c
// *****************************************************************************

// Title: axi
//

import QUESTA_MVC::questa_mvc_reporter;
import QUESTA_MVC::questa_mvc_item_comms_semantic;
import QUESTA_MVC::questa_mvc_edge;
import QUESTA_MVC::QUESTA_MVC_POSEDGE;
import QUESTA_MVC::QUESTA_MVC_NEGEDGE;
import QUESTA_MVC::QUESTA_MVC_ANYEDGE;
import QUESTA_MVC::QUESTA_MVC_0_TO_1_EDGE;
import QUESTA_MVC::QUESTA_MVC_1_TO_0_EDGE;

//------------------------------------------------------------------------------
//
// Interface:- axi
//
//------------------------------------------------------------------------------
//  This interface contains all the wires and BFM configuration variables.
// 
// For all Configuration variables set/get/wait functions are available in the
// interface.
// 
// For e.g.
// 
// bit config_master_write_delay:
// 
// >   function void set_config_master_write_delay( bit arg1 )
// >
// >   function bit get_config_master_write_delay()
// >
// >   task wait_for_config_master_write_delay()
// 
// bit [255:0] config_enable_assertion:
// 
// >     task wait_for_config_enable_assertion()
// >     
// >     task wait_for_config_enable_assertion_index1( input int _this_dot_1 )
// >     
// >     function void set_config_enable_assertion( bit [255:0] arg2 )
// >     
// >     function set_config_enable_assertion_index1( int _this_dot_1, bit  arg3 )
// >     
// >     function bit [255:0]  get_config_enable_assertion()
// >     
// >     function bit get_config_enable_assertion_index1( int _this_dot_1 ) 
// >
// 
//------------------------------------------------------------------------------
(* cy_so="libaxi_IN_SystemVerilog_MTI_full" *)
(* on_lib_load="axi_IN_SystemVerilog_load" *)
interface mgc_common_axi
    #(int AXI_ADDRESS_WIDTH = 64, int AXI_RDATA_WIDTH = 1024, int AXI_WDATA_WIDTH = 1024, int AXI_ID_WIDTH = 18)
    (input wire iACLK, input wire iARESETn);
    // Constant: AXI_ADDRESS_WIDTH
    //
    // The width of the AWADDR and ARADDR signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2).
    //

    // Constant: AXI_RDATA_WIDTH
    //
    // The width of the RDATA signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6).
    //

    // Constant: AXI_WDATA_WIDTH
    //
    // The width of the WDATA signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.3).
    //

    // Constant: AXI_ID_WIDTH
    //
    // The width of the AWID, ARID, WID, RID and BID signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2).
    //

    //------------------------------------------------------------------------------
    //
    // Wires for interface: axi
    //
    //------------------------------------------------------------------------------

    // Wire: ACLK
    //
    //------------------------------------------------------------------------------
    // 
    //       Global Clock Signal
    //     
    //------------------------------------------------------------------------------
    wire ACLK;

    // Wire: ARESETn
    //
    //------------------------------------------------------------------------------
    // 
    //       Global Reset Signal. This signal is Active Low.
    //     
    //------------------------------------------------------------------------------
    wire ARESETn;

    // Wire: AWVALID
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Address Valid. 
    // 
    //       The source of this signal is Master and this signal indicates 
    //       that valid write address and control information are available.
    //     
    //------------------------------------------------------------------------------
    wire AWVALID;

    // Wire: AWADDR
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Address Signal.
    // 
    //       The source of this signal is Master.
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_ADDRESS_WIDTH) - 1):0]  AWADDR;

    // Wire: AWLEN
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Burst Length Signal.
    // 
    //       The source of this signal is Master.
    //       The width of this signal is set to 10 by default. If the signal width of 4 is required, a wrapper can be made over the dut to do so.
    //     
    //------------------------------------------------------------------------------
    wire [3:0] AWLEN;

    // Wire: AWSIZE
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Burst Size Signal.
    // 
    //       The source of this signal is Master.
    //     
    //------------------------------------------------------------------------------
    wire [2:0] AWSIZE;

    // Wire: AWBURST
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Burst Type Signal.
    // 
    //       The source of this signal is Master.
    //     
    //------------------------------------------------------------------------------
    wire [1:0] AWBURST;

    // Wire: AWLOCK
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Lock Type Signal. 
    // 
    //       The source of this signal is Master and this signal provides the 
    //       atomic characteristics of the transfer.
    //     
    //------------------------------------------------------------------------------
    wire [1:0] AWLOCK;

    // Wire: AWCACHE
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Cache type Signal. 
    // 
    //       The source of this signal is Master and this signal indicates the 
    //       bufferable, cacheable, write-through, write-back, and allocate 
    //       attributes of the transaction.
    //     
    //------------------------------------------------------------------------------
    wire [3:0] AWCACHE;

    // Wire: AWPROT
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Protection Type Signal. 
    // 
    //       The source of this signal is Master and this signal indicates the 
    //       normal, privileged, or secure protection level of the transaction 
    //       and whether it is a data access or instruction access.
    //     
    //------------------------------------------------------------------------------
    wire [2:0] AWPROT;

    // Wire: AWID
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Address ID.
    // 
    //       The source of this signal is Master and this signal is the 
    //       identification tag for the write address group of signals.
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_ID_WIDTH) - 1):0]  AWID;

    // Wire: AWREADY
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Address Ready Signal.
    // 
    //       The source of this signal is Slave and this signal indicates that 
    //       the valid write address and control information are available.
    //     
    //------------------------------------------------------------------------------
    wire AWREADY;

    // Wire: AWUSER
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Address User Signal.
    //     
    //------------------------------------------------------------------------------
    wire [7:0] AWUSER;

    // Wire: ARVALID
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Address Valid. 
    // 
    //       The source of this signal is Master and this signal indicates that 
    //       valid write address and control information are available.
    //     
    //------------------------------------------------------------------------------
    wire ARVALID;

    // Wire: ARADDR
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Address Signal.
    // 
    //       The source of this signal is Master.
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_ADDRESS_WIDTH) - 1):0]  ARADDR;

    // Wire: ARLEN
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Burst Length Signal.
    // 
    //       The source of this signal is Master.
    //       The width of this signal is set to 10 by default. If the signal width of 4 is required, a wrapper can be made over the dut to do so.
    //     
    //------------------------------------------------------------------------------
    wire [3:0] ARLEN;

    // Wire: ARSIZE
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Burst Size Signal.
    // 
    //       The source of this signal is Master.
    //     
    //------------------------------------------------------------------------------
    wire [2:0] ARSIZE;

    // Wire: ARBURST
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Burst Type Signal.
    // 
    //       The source of this signal is Master.
    //     
    //------------------------------------------------------------------------------
    wire [1:0] ARBURST;

    // Wire: ARLOCK
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Lock Type Signal. 
    // 
    //       The source of this signal is Master and this signal provides the 
    //       atomic characteristics of the transfer.
    //     
    //------------------------------------------------------------------------------
    wire [1:0] ARLOCK;

    // Wire: ARCACHE
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Cache type Signal. 
    // 
    //       The source of this signal is Master and this signal indicates the 
    //       bufferable, cacheable, write-through, write-back, and allocate 
    //       attributes of the transaction.
    //     
    //------------------------------------------------------------------------------
    wire [3:0] ARCACHE;

    // Wire: ARPROT
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Protection Type Signal. 
    // 
    //       The source of this signal is Master and this signal indicates the 
    //       normal, privileged, or secure protection level of the transaction 
    //       and whether it is a data access or instruction access.
    //     
    //------------------------------------------------------------------------------
    wire [2:0] ARPROT;

    // Wire: ARID
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Address ID.
    // 
    //       The source of this signal is Master and this signal is the 
    //       identification tag for the write address group of signals.
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_ID_WIDTH) - 1):0]  ARID;

    // Wire: ARREADY
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Address Ready Signal.
    // 
    //       The source of this signal is Slave and this signal indicates that 
    //       the valid write address and control information are available.
    //     
    //------------------------------------------------------------------------------
    wire ARREADY;

    // Wire: ARUSER
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Address User Signal.
    //     
    //------------------------------------------------------------------------------
    wire [7:0] ARUSER;

    // Wire: RVALID
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Valid Signal.
    // 
    //       The source of this signal is Slave and this signal indicates that 
    //       the read data is available and read transfer can complete.
    //     
    //------------------------------------------------------------------------------
    wire RVALID;

    // Wire: RLAST
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Last Signal.
    // 
    //       The source of this signal is Slave and this signal indicates 
    //       the last transfer in the read burst.
    //     
    //------------------------------------------------------------------------------
    wire RLAST;

    // Wire: RDATA
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Data Signal.
    // 
    //       The source of this signal is Slave and the read data bus can be 
    //       8, 16, 24, 32, 64, 128, 256, 512 or 1024 bits wide. 
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_RDATA_WIDTH) - 1):0]  RDATA;

    // Wire: RRESP
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Response Signal.
    // 
    //       The source of this signal is Slave and it indicates the status of read transfer.
    //       The allowable responses are OKAY, EXOKAY, SLVERR and DECERR. 
    //     
    //------------------------------------------------------------------------------
    wire [1:0] RRESP;

    // Wire: RID
    //
    //------------------------------------------------------------------------------
    // 
    //       Read ID Tag Signal.
    // 
    //       The source of this signal is Slave and it is the ID tag of the read data 
    //       group of signals.
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_ID_WIDTH) - 1):0]  RID;

    // Wire: RREADY
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Ready Signal.
    // 
    //       The source of this signal is Master and it indicates that the Master can
    //       accept the read data and response information.
    //     
    //------------------------------------------------------------------------------
    wire RREADY;

    // Wire: RUSER
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Data User Signal.
    //     
    //------------------------------------------------------------------------------
    wire [7:0] RUSER;

    // Wire: WVALID
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Valid Signal.
    // 
    //       The source of this signal is Master and this signal indicates that 
    //       the read data is available and read transfer can complete.
    //     
    //------------------------------------------------------------------------------
    wire WVALID;

    // Wire: WLAST
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Last Signal.
    // 
    //       The source of this signal is Master and this signal indicates 
    //       the last transfer in the read burst.
    //     
    //------------------------------------------------------------------------------
    wire WLAST;

    // Wire: WDATA
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Data Signal.
    // 
    //       The source of this signal is Master and the read data bus can be 
    //       8, 16, 24, 32, 64, 128, 256, 512 or 1024 bits wide. 
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_WDATA_WIDTH) - 1):0]  WDATA;

    // Wire: WSTRB
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Strobes Signal.
    // 
    //       The source of this signal is Master and this signal indicates which 
    //       byte lanes to update in the memory.
    //     
    //------------------------------------------------------------------------------
    wire [(((AXI_WDATA_WIDTH / 8)) - 1):0]  WSTRB;

    // Wire: WID
    //
    //------------------------------------------------------------------------------
    // 
    //       Write ID Tag Signal.
    // 
    //       The source of this signal is Master and it is the ID tag of the write 
    //       data transfer.
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_ID_WIDTH) - 1):0]  WID;

    // Wire: WREADY
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Ready Signal.
    // 
    //       The source of this signal is Slave and it indicates that the Slave can
    //       accept the write data.
    //     
    //------------------------------------------------------------------------------
    wire WREADY;

    // Wire: WUSER
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Data User Signal.
    //     
    //------------------------------------------------------------------------------
    wire [7:0] WUSER;

    // Wire: BVALID
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Response Valid Signal.
    // 
    //       The source of this signal is Slave and it indicates that a valid write
    //       response is available.
    //     
    //------------------------------------------------------------------------------
    wire BVALID;

    // Wire: BRESP
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Response Signal.
    // 
    //       The source of this signal is Slave and it indicates the status of the 
    //       write transaction. The allowable responses are OKAY, EXOKAY, SLVERR 
    //       and DECERR.
    //     
    //------------------------------------------------------------------------------
    wire [1:0] BRESP;

    // Wire: BID
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Response ID Signal.
    // 
    //       The source of this signal is Slave and it indicates the identifciation 
    //       tag of a write response.
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_ID_WIDTH) - 1):0]  BID;

    // Wire: BREADY
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Response Ready Signal.
    // 
    //       The source of this signal is Master and it indicates that the master 
    //       can accept the response information.
    //     
    //------------------------------------------------------------------------------
    wire BREADY;

    // Wire: BUSER
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Response User Signal.
    //     
    //------------------------------------------------------------------------------
    wire [7:0] BUSER;

    // Propagate global signals onto interface wires
    assign ACLK = iACLK;
    assign ARESETn = iARESETn;

    //------------------------------------------------------------------------------
    // Global Variables - config
    //------------------------------------------------------------------------------

    // Variable:- config_clk_init_value
    //
    // 
    //     Initial value of the clock signal generated by the AXI MVC built-in clock generator.
    //   
    //
    bit config_clk_init_value;

    // Variable:- config_clk_phase_shift
    //
    // 
    //     Number of time units to hold the initial value of the clock signal generated by the AXI
    //     MVC built-in clock generator. 
    //   
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    int config_clk_phase_shift;

    // Variable:- config_clk_1st_time
    //
    // 
    //     Number of time units for the first phase of the clock signal generated by the AXI MVC
    //     built-in clock generator.
    //   
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    int config_clk_1st_time;

    // Variable:- config_clk_2nd_time
    //
    // 
    //     Number of time units for the second phase of the clock signal generated by the AXI MVC
    //     built-in clock generator.
    //   
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    int config_clk_2nd_time;

    // Variable:- config_setup_time
    //
    // 
    //     Number of time units for the setup time to the active clock edge of ACLK.
    //   
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    int config_setup_time;

    // Variable:- config_hold_time
    //
    // 
    //     Number of time units for the hold time to the active clock edge of ACLK.
    //   
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    int config_hold_time;

    // Variable:- config_max_transaction_time_factor
    //
    //  This timeout "config_max_transaction_time_factor" is the timeout that sets the maximum timeout within which any read/write transaction is 
    //        expected to occur (and in turn all individual phases as well) of the AXI interface. 
    //        This timeout should be set as the maximum duration of read/write. 
    //        In short it indicates the maximum duration of a read/write transaction (From start of transaction to end of it).
    //        Its default value is 100000 clock cycles
    //     
    //
    int unsigned config_max_transaction_time_factor;

    // Variable:- config_timeout_max_data_transfer
    //
    //  This timeout "config_timeout_max_data_transfer" is actually a configuration which tells about the maximum number of write data beats that the AXI interface
    //       can generate as part of write data burst of write transfer. 
    //       It is actually not a timeout value and is the maximum number of beats of Write data that are expected. 
    //
    int config_timeout_max_data_transfer;

    // Variable:- config_burst_timeout_factor
    //
    // This timeout "config_burst_timeout_factor" represents the maximum delay between the individual phases of the AXI transactions.
    //      For example between read address phase and read data phase, write address and Write data phases. 
    //      If this delay exceeds between the phases then transaction will be  timed out.
    //      Its default value is 10000 clock cycles
    //     
    //
    int unsigned config_burst_timeout_factor;

    // Variable:- config_max_latency_AWVALID_assertion_to_AWREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <AWVALID> to the assertion of <AWREADY> (default 10000).
    // 
    // The error message <AXI_AWREADY_NOT_ASSERTED_AFTER_AWVALID> will be issued if this period elapses from the assertion of <AWVALID>.
    // 
    //
    int unsigned config_max_latency_AWVALID_assertion_to_AWREADY;

    // Variable:- config_max_latency_ARVALID_assertion_to_ARREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <ARVALID> to the assertion of <ARREADY> (default 10000).
    // 
    // The error message <AXI_ARREADY_NOT_ASSERTED_AFTER_ARVALID> will be issued if this period elapses from the assertion of <ARVALID>.
    // 
    //
    int unsigned config_max_latency_ARVALID_assertion_to_ARREADY;

    // Variable:- config_max_latency_RVALID_assertion_to_RREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <RVALID> to the assertion of <RREADY> (default 10000).
    // 
    // The error message <AXI_RREADY_NOT_ASSERTED_AFTER_RVALID> will be issued if this period elapses from the assertion of <RVALID>.
    // 
    //
    int unsigned config_max_latency_RVALID_assertion_to_RREADY;

    // Variable:- config_max_latency_BVALID_assertion_to_BREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <BVALID> to the assertion of <BREADY> (default 10000).
    // 
    // The error message <AXI_BREADY_NOT_ASSERTED_AFTER_BVALID> will be issued if this period elapses from the assertion of <BVALID>.
    // 
    //
    int unsigned config_max_latency_BVALID_assertion_to_BREADY;

    // Variable:- config_max_latency_WVALID_assertion_to_WREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <WVALID> to the assertion of <WREADY> (default 10000).
    // 
    // The error message <AXI_WREADY_NOT_ASSERTED_AFTER_WVALID> will be issued if this period elapses from the assertion of <WVALID>.
    // 
    //
    int unsigned config_max_latency_WVALID_assertion_to_WREADY;

    // Variable:- config_write_ctrl_first_ratio
    //
    // Data starts at same time as or after control phase.  Response follows data.
    //
    int config_write_ctrl_first_ratio;

    // Variable:- config_write_data_first_ratio
    //
    // control phase starts at same time as or after data phase.  Response follows data.
    //
    int config_write_data_first_ratio;

    // Variable:- config_write_ctrl_to_data_mintime
    //
    // Number of clocks from the start of control to the start of data in a write. This configuration parameter has been deprecated and maintained for backward compatibility. Instead use write_address_to_data_delay variable to control delay between write address phase and write data phase.
    //
    int unsigned config_write_ctrl_to_data_mintime;

    // Variable:- config_write_data_to_ctrl_mintime
    //
    // Number of clocks from the start of data to the start of control in a write
    //
    int unsigned config_write_data_to_ctrl_mintime;

    // Variable:- config_master_write_delay
    //
    // To configure the write sequence item delays to be inserted.
    //
    bit config_master_write_delay;

    // Variable:- config_reset_low_clocks
    //
    // 
    //     Number of clock cycles to hold the reset signal generated by the AXI MVC built-in reset
    //     generator at the start of an OVM test.
    //   
    //
    int config_reset_low_clocks;

    // Variable:- config_reset_hold_time
    //
    // 
    //     Number of time units to delay changing the reset signal generated by the AXI MVC
    //     built-in reset generator after a clock edge.
    //   
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    int config_reset_hold_time;

    // Variable:- config_protect_ready
    //
    // 
    //     Boolean to set ready stripes as protected (so don't recognize) 
    //   
    //
    bit config_protect_ready;

    // Variable:- config_enable_user_sideband
    //
    // 
    //     To enable the user sideband.
    //   
    //
    bit config_enable_user_sideband;

    // Variable:- config_extended_length_enable
    //
    // 
    //     To enable the extended burst length feature.
    //   
    //
    bit config_extended_length_enable;

    // Variable:- config_enable_burst_reserved_value
    //
    //  A configuration parameter to control the generation (within the QVIP) and coverage collection of the <axi_burst_e> reserved value AXI_BURST_RSVD
    //   when it is allowed as a legal value for the 'burst' parameter of <axi_master_AXI_write>/<axi_master_AXI_read>.
    // 
    //   1'b0 - randomized generation by the master and coverage collection by <axi_functional_coverage> is not performed for the <axi_burst_e> reserved value AXI_BURST_RSVD (default).
    //   1'b1 - randomized generation by the master and coverage collection by <axi_functional_coverage> is performed for the <axi_burst_e> reserved value AXI_BURST_RSVD.
    //   
    //
    bit config_enable_burst_reserved_value;

    // Variable:- config_enable_lock_reserved_value
    //
    //  A configuration parameter to control the coverage collection of the <axi_lock_e> reserved value AXI_LOCK_RSVD when it is allowed as a legal value for the 'lock'
    //   parameter of <axi_master_AXI_write>/<axi_master_AXI_read>.
    // 
    //   1'b0 - randomized generation by the master and coverage collection by <axi_functional_coverage> is not performed for the <axi_lock_e> reserved value AXI_LOCK_RSVD (default).
    //   1'b1 - randomized generation by the master and coverage collection by <axi_functional_coverage> is performed for the <axi_lock_e> reserved value AXI_LOCK_RSVD.
    //   
    //
    bit config_enable_lock_reserved_value;

    // Variable:- config_enable_cache_reserved_value
    //
    //  A configuration parameter to control the coverage collection of the <axi_cache_e> reserved values AXI_CACHE_RSVD0, AXI_CACHE_RSVD1
    //   AXI_CACHE_RSVD2 AXI_CACHE_RSVD3, AXI_CACHE_RSVD4, AXI_CACHE_RSVD5 when they are allowed as legal values for the 'cache'
    //   parameter of <axi_master_AXI_write>/<axi_master_AXI_read>.
    // 
    //   1'b0 - randomized generation by the master and coverage collection by <axi_functional_coverage> is not performed for the <axi_cache_e> reserved values(default).
    //   1'b1 - randomized generation by the master and coverage collection by <axi_functional_coverage> is performed for the <axi_cache_e> reserved values(default).
    //   
    //
    bit config_enable_cache_reserved_value;

    // Variable:- config_enable_all_assertions
    //
    // 
    //   Configuration parameter controlling whether the error messages(Assertions) issued from the QVIP are Enabled or Disabled.  
    //   By default, it is enabled.
    // 
    //
    bit config_enable_all_assertions;

    // Variable:- config_enable_assertion
    //
    // 
    //   An array of configuration parameters controlling whether specific error messages(Assertion) (of type <axi_assertion_type_e>)
    //   can be issued by the QVIP. By default, all errors are enabled. To suppress a particular error, set the corresponding bit to 0.
    //   e.g. config.m_bfm.set_config_enable_error_index1(AXI_RESET_SIGNAL_Z, 0);
    // 
    //
    bit [255:0] config_enable_assertion;

    // Variable:- config_enable_error
    //
    //  
    //   This configuration parameter has been deprecated and maintained for backward compatibility
    // 
    //
    bit [255:0] config_enable_error;

    // Variable:- config_enable_errors
    //
    //  
    //   This configuration parameter has been deprecated and maintained for backward compatibility
    // 
    //
    bit config_enable_errors;

    // Variable:- config_enable_all_assertion_errors
    //
    //  This configuration parameter has been deprecated and maintained for backward compatibility
    // 
    //
    bit config_enable_all_assertion_errors;

    // Variable:- config_abstraction_level
    //
    // 
    //     To set the Abstraction Level. 
    //   
    //
    axi_abstraction_level_e config_abstraction_level;

    // Variable:- config_slave_start_addr
    //
    // 
    //    A configuration parameter indicating start address for slave.
    //   
    //
    bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr;

    // Variable:- config_slave_end_addr
    //
    // 
    //    A configuration parameter indicating end address for slave.
    //   
    //
    bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr;

    // Variable:- config_enable_slave_addr_range_in_bfm
    //
    // 
    //    A configuration parameter indicating whether slave start and end address provided in bfm is valid or not.
    //    If set to 1 then slave start and end address provided in bfm will be considered valid.
    //   
    //
    bit config_enable_slave_addr_range_in_bfm;

    // Variable:- config_read_data_reordering_depth
    //
    // 
    //    A configuration parameter defining the read reordering depth of the slave end of the interface (SPEC3(A5.3.1)).
    // 
    //    Responses from the first <config_read_data_reordering_depth> outstanding read transactions, each with address <ARID> values different from any
    //    earlier outstanding read transaction(as seen by the slave) are expected, interleaved at random. A violation causes a <AXI_READ_REORDERING_VIOLATION> error.
    // 
    //    The default value of <config_read_data_reordering_depth> is (1 << AXI_ID_WIDTH), so that the slave is expected to process all transactions in any order (up to uniqueness of <ARID>).
    // 
    //    For a given <AXI_ID_WIDTH> parameter value, the maximum possible value of <config_read_data_reordering_depth> is 2**AXI_ID_WIDTH. The <AXI_PARAM_READ_REORDERING_DEPTH_EXCEEDS_MAX_ID>
    //    error report will be issued if <config_read_data_reordering_depth> exceeds this value.
    // 
    //    If the user-supplied value is 0, the <AXI4_PARAM_READ_REORDERING_DEPTH_EQUALS_ZERO> error will be issued, and the value will be set to 1.
    //   
    //
    int unsigned config_read_data_reordering_depth;

    // Variable:- config_enable_read_data_reordering_depth_in_bfm
    //
    // 
    //    A configuration parameter indicating whether read data reordering depth provided in bfm is valid or not.
    //    If set to 1 then read data reordering depth in bfm will be considered valid.
    //   
    //
    bit config_enable_read_data_reordering_depth_in_bfm;

    // Variable:- config_awid_wid_mismatch
    //
    // 
    //     Configuration to set a AWID WID mismatch error.
    //   
    //
    bit config_awid_wid_mismatch;

    // Variable:- config_length_last_mismatch_error
    //
    // 
    //     Configuration to set a AWLEN last mismatch error.
    //   
    //
    bit config_length_last_mismatch_error;

    // Variable:- config_master_error_position
    //
    // 
    //     To confgure the type of Master Error.
    //   
    //
    axi_error_e config_master_error_position;

    // Variable:- dummy_var
    //
    // 
    //     To configure the assertion type.
    //   
    //
    axi_assertion_type_e dummy_var;

    // Variable:- config_wlast_length
    //
    // 
    //     This configures the length of data phase after which wlast should be asserted.
    //     This has effect only when m_length_last_mismatch_error is set to 1.
    //   
    //
    int config_wlast_length;

    // Variable:- config_wid_for_awid_not_matching
    //
    // 
    //     This configures the value of WID when m_awid_wid_mismatch is set to 1.
    //   
    //
    bit [((AXI_ID_WIDTH) - 1):0]  config_wid_for_awid_not_matching;

    // Variable:- config_support_exclusive_access
    //
    // 
    //     This configures the support for exclusive slave.
    //     If set, it enables the exclusive support in slave.
    //     If cleared, it disables the exclusive support and every exclusive read/write will return OKAY response and 
    //     exclusive write will update the memory.  
    //   
    //
    bit config_support_exclusive_access;

    // Variable:- config_write_data_interleaving_depth
    //
    // 
    //     This configures the maximum number of different write transaction addresses for which write data can be supplied
    //     to the slave.
    //   
    //
    int config_write_data_interleaving_depth;

    // Variable:- status_master_error
    //
    // 
    //     This shows the Status of Master Error.
    //   
    //
    bit [15:0] status_master_error;

    // Variable:- check_total_num_wdata_outstanding
    //
    // 
    //    This variable is set to true and then BFM updates <total_num_wdata_outstanding> and set this variable to false to
    //    notify that required variable has been updated.
    //   
    //
    bit check_total_num_wdata_outstanding;

    // Variable:- total_num_wdata_outstanding
    //
    // 
    //    This represents the total number of outstanding write data bursts. This could be received by setting
    //    <check_total_num_wdata_outstanding> to true and then waiting for same variable to become false.
    //   
    //
    int total_num_wdata_outstanding;

    // Variable:- check_max_num_wdata_outstanding_per_id
    //
    // 
    //    This variable is set to true and then BFM updates <max_num_wdata_outstanding_per_id> and set this variable to false to
    //    notify that required variable has been updated.
    //   
    //
    bit check_max_num_wdata_outstanding_per_id;

    // Variable:- max_num_wdata_outstanding_per_id
    //
    // 
    //    This represents the maximum number of outstanding write data bursts for any id. This could be received by setting
    //    <check_max_num_wdata_outstanding_per_id> to true and then waiting for same variable to become false.
    //   
    //
    int max_num_wdata_outstanding_per_id;

    // Variable:- check_max_num_waddr_outstanding_per_id
    //
    // 
    //    This variable is set to true and then BFM updates <max_num_waddr_outstanding_per_id> and set this variable to false to
    //    notify that required variable has been updated.
    //   
    //
    bit check_max_num_waddr_outstanding_per_id;

    // Variable:- max_num_waddr_outstanding_per_id
    //
    // 
    //    This represents the maximum number of outstanding write address bursts for any id. This could be received by setting
    //    <check_max_num_waddr_outstanding_per_id> to true and then waiting for same variable to become false.
    //   
    //
    int max_num_waddr_outstanding_per_id;

    // Variable:- check_total_num_waddr_outstanding
    //
    // 
    //    This variable is set to true and then BFM updates <total_num_waddr_outstanding> and set this variable to false to
    //    notify that required variable has been updated.
    //   
    //
    bit check_total_num_waddr_outstanding;

    // Variable:- total_num_waddr_outstanding
    //
    // 
    //    This represents the total number of outstanding write address bursts. This could be received by setting
    //    <check_total_num_waddr_outstanding> to true and then waiting for same variable to become false.
    //   
    //
    int total_num_waddr_outstanding;

    // Variable:- status_outstanding_num_for_waddr
    //
    // 
    //     This gives the number of write address phases outstanding with WID of <find_waddr_outstanding_for_wid>
    //     when start_finding_outstanding_waddr is set to 1.
    //   
    //
    int status_outstanding_num_for_waddr;

    // Variable:- start_finding_outstanding_waddr
    //
    //  If set to 1, this variable starts the updation of the variable status_outstanding_num_for_waddr 
    //      with the number of outstanding write address bursts of WID = find_waddr_outstanding_for_wid
    //    
    //
    bit start_finding_outstanding_waddr;

    // Variable:- status_outstanding_num_for_wdata
    //
    // 
    //     This gives the number of write data phases outstanding with WID of <find_wdata_outstanding_for_wid>
    //     when start_finding_outstanding_wdata is set to 1.
    //   
    //
    int status_outstanding_num_for_wdata;

    // Variable:- start_finding_outstanding_wdata
    //
    //  If set to 1, this variable starts the updation of the variable status_outstanding_num_for_wdata 
    //      with the number of outstanding write data bursts of WID = find_wdata_outstanding_for_wid
    //    
    //
    bit start_finding_outstanding_wdata;

    // Variable:- find_waddr_outstanding_for_wid
    //
    //  
    //     This variable is the input WID, for which the number of outstanding write addr phases is
    //     required. If start_finding_outstanding_waddr is set to 1, the variable status_outstanding_num_for_waddr
    //     is updated with the number of outstanding write addr phases with a WID of find_waddr_outstanding_for_wid
    //   
    //
    bit [((AXI_ID_WIDTH) - 1):0]  find_waddr_outstanding_for_wid;

    // Variable:- find_wdata_outstanding_for_wid
    //
    //  
    //     This variable is the input WID, for which the number of outstanding write data phases is
    //     required. If start_finding_outstanding_wdata is set to 1, the variable status_outstanding_num_for_wdata
    //     is updated with the number of outstanding write data phases with a WID of find_wdata_outstanding_for_wid
    //   
    //
    bit [((AXI_ID_WIDTH) - 1):0]  find_wdata_outstanding_for_wid;

    // Variable:- change_in_wdata_outstanding_per_id
    //
    // 
    //     This variable helps to wait for a change in number of outstanding write data phases per id.
    //   
    //
    bit change_in_wdata_outstanding_per_id;

    // Variable:- start_finding_change_in_wdata
    //
    //  This variable keeps a track of a change in the number of outstanding
    //      write data phases for WID find_change_in_wdata_outstanding_for_wid
    //    
    //
    bit start_finding_change_in_wdata;

    // Variable:- find_change_in_wdata_outstanding_for_wid
    //
    //  
    //     This variable is the input WID, for which the change in number of outstanding write data phases is
    //     required. If start_finding_change_in_wdata is set to 1, the variable start_finding_outstanding_wdata
    //     is cleared again when the number of outstanding write data phases with a WID of find_change_in_wdata_outstanding_for_wid
    //     modifies
    //   
    //
    bit [((AXI_ID_WIDTH) - 1):0]  find_change_in_wdata_outstanding_for_wid;

    // Variable:- config_max_outstanding_wr
    //
    int config_max_outstanding_wr;

    // Variable:- config_max_outstanding_rd
    //
    int config_max_outstanding_rd;

    // Variable:- config_error_on_deleted_valid_cycles
    //
    bit config_error_on_deleted_valid_cycles;

    // Variable:- config_stats_enable
    //
    //  A flag to globally enable/disable performance attributes calculation
    // 
    // Flag settings are:
    // - disabled = 1'b0 (default)
    // - enabled  = 1'b1
    // 
    //
    bit config_stats_enable;

    // Variable:- config_stats_enable_AXI_read_occupancy
    //
    //  A configuration flag to enable/disable the read channel occupancy statistics gathering.
    // 
    // The read channel occupancy is calculated as a percentage of time the read channel (or part of it) is occupied
    // and is measured from the first rising clock that an appropriate *VALID signal is asserted.
    // The read channel is deemed to be occupied if there is a read transaction active.
    // An active read transaction does not necessarily relate to activity on any of the read channel buses
    // as there may be gaps of time between the read transaction phases.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_AXI_read_occupancy;

    // Variable:- config_stats_enable_AXI_write_occupancy
    //
    //  A configuration flag to enable/disable the write channel occupancy statistics gathering.
    // 
    // The write channel occupancy is calculated as a percentage of time the write channel (or part of it) is occupied
    // and is measured from the first rising clock that an appropriate *VALID signal is asserted.
    // The write channel is deemed to be occupied if there is a write transaction active.
    // An active write transaction does not necessarily relate to activity on any of the write channel buses
    // as there may be gaps of time between the write transaction phases.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_AXI_write_occupancy;

    // Variable:- config_stats_enable_read_data_occupancy
    //
    //  A configuration flag to enable/disable the read data occupancy statistics gathering.
    // 
    // The read data occupancy is calculated as a percentage of time the read data channel (or part of it) is occupied
    // and is measured from the first rising clock that an appropriate *VALID signal is asserted.
    // The read data channel is deemed to be occupied if there is a read data phase active and is measured
    // at the phase level, giving a true indication of activity.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_read_data_occupancy;

    // Variable:- config_stats_enable_write_data_occupancy
    //
    //  A configuration flag to enable/disable the write data occupancy statistics gathering.
    // 
    // The write data occupancy is calculated as a percentage of time the write data channel (or part of it) is occupied
    // and is measured from the first rising clock that an appropriate *VALID signal is asserted.
    // The write data channel is deemed to be occupied if there is a write data phase active and is measured
    // at the phase level, giving a true indication of activity.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_write_data_occupancy;

    // Variable:- config_stats_enable_read_latency
    //
    //  A configuration flag to enable/disable the read latency statistics gathering.
    // 
    // The read latency is calculated as the number of clock cycles between the read channel phases.
    // It is measured from the clock edge when the first phase ends (*VALID and *READY are high)
    // to when the next phase starts (*VALID is high).
    // 
    // The latencies measured are:
    // -       read address (end) to read data (start). The calculation is updated at the end of the transaction.
    // -       read address (end) to the next read address (start). The calculation is updated when the latter of the two address phases occurs.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_read_latency;

    // Variable:- config_stats_enable_write_latency
    //
    //  A configuration flag to enable/disable the write latency statistics gathering.
    // 
    // The write latency is calculated as the number of clock cycles between the write channel phases.
    // It is measured from the clock edge when the first phase ends (*VALID and *READY are high)
    // to when the next phase starts (*VALID is high).
    // 
    // The latencies measured are:
    // -       write address (end) to write data (start) The calculation is updated at the end of the transaction.
    // -       write data (end) to write response (start). The calculation is updated at the end of the transaction.
    // -       write address (end) to the next write address (start). The calculation is updated when the latter of the two address phases occurs.
    // 
    // Note that the write address/write data latency calculation may result in negative value as the address and data can happen in either order, or in parallel.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_write_latency;

    // Variable:- config_stats_enable_read_address_waits
    //
    //  A configuration flag to enable/disable the read address wait states statistics gathering.
    // 
    // The read address wait is calculated as the length of time a particular address phase is active for, in clock cycles.
    // This is determined by the number of clock cycles between its *VALID and *READY handshake signals.
    // If an address phase lasts a single clock (*VALID and *READY are both high) then the wait is zero.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_read_address_waits;

    // Variable:- config_stats_enable_read_data_waits
    //
    //  A configuration flag to enable/disable the read data wait states statistics gathering.
    // 
    // The read data wait is calculated as the length of time a particular data phase is active for, in clock cycles.
    // This is determined by the number of clock cycles between its *VALID and *READY handshake signals.
    // If a data phase lasts a single clock (*VALID and *READY are both high) then the wait is zero.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_read_data_waits;

    // Variable:- config_stats_enable_write_address_waits
    //
    //  A configuration flag to enable/disable the write address wait states statistics gathering.
    // 
    // The write address wait is calculated as the length of time a particular address phase is active for, in clock cycles.
    // This is determined by the number of clock cycles between its *VALID and *READY handshake signals.
    // If an address phase lasts a single clock (*VALID and *READY are both high) then the wait is zero.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_write_address_waits;

    // Variable:- config_stats_enable_write_data_waits
    //
    //  A configuration flag to enable/disable the write data wait states statistics gathering.
    // 
    // The write data wait is calculated as the length of time a particular data phase is active for, in clock cycles.
    // This is determined by the number of clock cycles between its *VALID and *READY handshake signals.
    // If a data phase lasts a single clock (*VALID and *READY are both high) then the wait is zero.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_write_data_waits;

    // Variable:- config_stats_enable_write_response_waits
    //
    //  A configuration flag to enable/disable the write response wait states statistics gathering.
    // 
    // The write response wait is calculated as the length of time a particular response phase is active for, in clock cycles.
    // This is determined by the number of clock cycles between its *VALID and *READY handshake signals.
    // If a response phase lasts a single clock (*VALID and *READY are both high) then the wait is zero.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_write_response_waits;

    // Variable:- config_stats_enable_read_bandwidth
    //
    //  A configuration flag to enable/disable the read bandwidth statistics gathering.
    // 
    // The read bandwidth is calculated as the amount of data transferred within a sliding window,
    // taking into account the read transfer size parameter.
    // The contribution from any specific read transaction is measured at the end of the transaction.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_read_bandwidth;

    // Variable:- config_stats_enable_write_bandwidth
    //
    //  A configuration flag to enable/disable the write bandwidth statistics gathering.
    // 
    // The write bandwidth is calculated as the amount of data transferred within a sliding window,
    // taking into account the write transfer size parameter.
    // The contribution from any specific write transaction is measured at the end of the transaction.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_write_bandwidth;

    // Variable:- config_stats_AXI_read_occupancy_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_AXI_read_occupancy> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_AXI_read_occupancy_step;

    // Variable:- config_stats_AXI_read_occupancy_multiple
    //
    //  A configuration variable for setting the read occupancy multiple of the <config_stats_enable_AXI_read_occupancy> sliding window.
    // 
    // The read occupancy multiple is the number of <config_stats_AXI_read_occupancy_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_AXI_read_occupancy_multiple;

    // Variable:- config_stats_AXI_write_occupancy_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_AXI_write_occupancy> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_AXI_write_occupancy_step;

    // Variable:- config_stats_AXI_write_occupancy_multiple
    //
    //  A configuration variable for setting the write occupancy multiple of the <config_stats_enable_AXI_write_occupancy> sliding window.
    // 
    // The read occupancy multiple is the number of <config_stats_AXI_write_occupancy_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_AXI_write_occupancy_multiple;

    // Variable:- config_stats_read_data_occupancy_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_read_data_occupancy_step;

    // Variable:- config_stats_read_data_occupancy_multiple
    //
    //  A configuration variable for setting the read data occupancy multiple of the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    // The read data occupancy multiple is the number of <config_stats_read_data_occupancy_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_read_data_occupancy_multiple;

    // Variable:- config_stats_write_data_occupancy_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_write_data_occupancy_step;

    // Variable:- config_stats_write_data_occupancy_multiple
    //
    //  A configuration variable for setting the write data occupancy multiple of the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    // The write data occupancy multiple is the number of <config_stats_write_data_occupancy_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_write_data_occupancy_multiple;

    // Variable:- config_stats_read_bandwidth_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_read_bandwidth> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_read_bandwidth_step;

    // Variable:- config_stats_read_bandwidth_multiple
    //
    //  A configuration variable for setting the read bandwidth multiple of the <config_stats_enable_read_bandwidth> sliding window.
    // 
    // The read bandwidth multiple is the number of <config_stats_read_bandwidth_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_read_bandwidth_multiple;

    // Variable:- config_stats_write_bandwidth_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_write_bandwidth> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_write_bandwidth_step;

    // Variable:- config_stats_write_bandwidth_multiple
    //
    //  A configuration variable for setting the write bandwidth multiple of the <config_stats_enable_write_bandwidth> sliding window.
    // 
    // The write bandwidth multiple is the number of <config_stats_write_bandwidth_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_write_bandwidth_multiple;

    // Variable:- config_stats_read_latency_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_read_latency> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_read_latency_step;

    // Variable:- config_stats_read_latency_multiple
    //
    //  A configuration variable for setting the read latency multiple of the <config_stats_enable_read_latency> sliding window.
    // 
    // The read latency multiple is the number of <config_stats_read_latency_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_read_latency_multiple;

    // Variable:- config_stats_write_latency_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_write_latency> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_write_latency_step;

    // Variable:- config_stats_write_latency_multiple
    //
    //  A configuration variable for setting the write latency multiple of the <config_stats_enable_write_latency> sliding window.
    // 
    // The write latency multiple is the number of <config_stats_write_latency_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_write_latency_multiple;

    // Variable:- config_stats_read_address_waits_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_read_address_waits> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_read_address_waits_step;

    // Variable:- config_stats_read_address_waits_multiple
    //
    //  A configuration variable for setting the read address wait states multiple of the <config_stats_enable_read_address_waits> sliding window.
    // 
    // The read address wait states multiple is the number of <config_stats_read_address_waits_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_read_address_waits_multiple;

    // Variable:- config_stats_read_data_waits_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_read_data_waits> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_read_data_waits_step;

    // Variable:- config_stats_read_data_waits_multiple
    //
    //  A configuration variable for setting the read data wait states multiple of the <config_stats_enable_read_data_waits> sliding window.
    // 
    // The read data wait states multiple is the number of <config_stats_read_data_waits_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_read_data_waits_multiple;

    // Variable:- config_stats_write_address_waits_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_write_address_waits> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_write_address_waits_step;

    // Variable:- config_stats_write_address_waits_multiple
    //
    //  A configuration variable for setting the write address wait states multiple of the <config_stats_enable_write_address_waits> sliding window.
    // 
    // The write address wait states multiple is the number of <config_stats_write_address_waits_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_write_address_waits_multiple;

    // Variable:- config_stats_write_data_waits_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_write_data_waits> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_write_data_waits_step;

    // Variable:- config_stats_write_data_waits_multiple
    //
    //  A configuration variable for setting the write data wait states multiple of the <config_stats_enable_write_data_waits> sliding window.
    // 
    // The write data wait states multiple is the number of <config_stats_write_data_waits_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_write_data_waits_multiple;

    // Variable:- config_stats_write_response_waits_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_write_response_waits> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_write_response_waits_step;

    // Variable:- config_stats_write_response_waits_multiple
    //
    //  A configuration variable for setting the write response wait states multiple of the <config_stats_enable_write_response_waits> sliding window.
    // 
    // The write response wait states multiple is the number of <config_stats_write_response_waits_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_write_response_waits_multiple;

    //------------------------------------------------------------------------------
    // Global Variables - status
    //------------------------------------------------------------------------------

    // Variable:- status_num_reads_waiting_for_resp
    //
    // 
    //     This shows the number of outstanding read transactions
    //   
    //
    int status_num_reads_waiting_for_resp;

    // Variable:- status_num_writes_waiting_for_response
    //
    // 
    //     This shows the number of outstanding write transactions that have not received a response
    //   
    //
    int status_num_writes_waiting_for_response;

    // Variable:- stats_AXI_read_active
    //
    //  A flag for indicating that there is one or more active read transactions.
    // 
    //
    bit stats_AXI_read_active;

    // Variable:- stats_AXI_read_occupancy_sw
    //
    //  A variable for holding the calculation of the read occupancy <config_stats_enable_AXI_read_occupancy> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_AXI_read_occupancy_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_AXI_read_occupancy_sw;

    // Variable:- stats_AXI_read_occupancy_sw_updated
    //
    //  A variable for holding the number of times the <stats_AXI_read_occupancy_sw> and <stats_AXI_read_idle_sw> sliding window statistics
    // have been updated, plus their respective min, max and mean values.
    // The value is incremented after every <config_stats_AXI_read_occupancy_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest value of the following statistics.
    // - <stats_AXI_read_occupancy_sw>
    // - <stats_AXI_read_occupancy_min>
    // - <stats_AXI_read_occupancy_max>
    // - <stats_AXI_read_occupancy_mean>
    // - <stats_AXI_read_idle_sw>
    // - <stats_AXI_read_idle_min>
    // - <stats_AXI_read_idle_max>
    // - <stats_AXI_read_idle_mean>
    // 
    //
    int stats_AXI_read_occupancy_sw_updated;

    // Variable:- stats_AXI_read_idle_sw
    //
    //  A variable for holding the calculation of the read idle <config_stats_enable_AXI_read_occupancy> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_AXI_read_idle_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_AXI_read_idle_sw;

    // Variable:- stats_AXI_read_occupancy_min
    //
    //  A variable for holding the minimum read occupancy metric within the <config_stats_enable_AXI_read_occupancy> sliding window.
    // 
    //
    int stats_AXI_read_occupancy_min;

    // Variable:- stats_AXI_read_idle_min
    //
    //  A variable for holding the minimum read idle metric within the <config_stats_enable_AXI_read_occupancy> sliding window.
    // 
    //
    int stats_AXI_read_idle_min;

    // Variable:- stats_AXI_read_occupancy_max
    //
    //  A variable for holding the maximum read occupancy metric within the <config_stats_enable_AXI_read_occupancy> sliding window.
    // 
    //
    int stats_AXI_read_occupancy_max;

    // Variable:- stats_AXI_read_idle_max
    //
    //  A variable for holding the maximum read idle metric within <config_stats_enable_AXI_read_occupancy> the sliding window.
    // 
    //
    int stats_AXI_read_idle_max;

    // Variable:- stats_AXI_read_occupancy_mean
    //
    //  A variable for holding the mean read occupancy metric within the <config_stats_enable_AXI_read_occupancy> sliding window.
    // 
    //
    int stats_AXI_read_occupancy_mean;

    // Variable:- stats_AXI_read_idle_mean
    //
    //  A variable for holding the mean read idle metric within the <config_stats_enable_AXI_read_occupancy> sliding window.
    // 
    //
    int stats_AXI_read_idle_mean;

    // Variable:- stats_AXI_write_active
    //
    //  A flag for indicating that there is one or more active write transactions.
    // 
    //
    bit stats_AXI_write_active;

    // Variable:- stats_AXI_write_occupancy_sw
    //
    //  A variable for holding the calculation of the write occupancy sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_AXI_write_occupancy_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_AXI_write_occupancy_sw;

    // Variable:- stats_AXI_write_occupancy_sw_updated
    //
    //  A variable for holding the number of times the <stats_AXI_write_occupancy_sw> and <stats_AXI_write_idle_sw> sliding window statistics
    // have been updated, plus their respective min, max and mean values.
    // The value is incremented after every <config_stats_AXI_write_occupancy_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest values of the following statistics.
    // - <stats_AXI_write_occupancy_sw>
    // - <stats_AXI_write_occupancy_min>
    // - <stats_AXI_write_occupancy_max>
    // - <stats_AXI_write_occupancy_mean>
    // - <stats_AXI_write_idle_sw>
    // - <stats_AXI_write_idle_min>
    // - <stats_AXI_write_idle_max>
    // - <stats_AXI_write_idle_mean>
    // 
    //
    int stats_AXI_write_occupancy_sw_updated;

    // Variable:- stats_AXI_write_idle_sw
    //
    //  A variable for holding the calculation of the write idle sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_AXI_write_idle_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_AXI_write_idle_sw;

    // Variable:- stats_AXI_write_occupancy_min
    //
    //  A variable for holding the minimum write occupancy metric within the <config_stats_enable_AXI_write_occupancy> sliding window.
    // 
    //
    int stats_AXI_write_occupancy_min;

    // Variable:- stats_AXI_write_idle_min
    //
    //  A variable for holding the minimum write idle metric within the <config_stats_enable_AXI_write_occupancy> sliding window.
    // 
    //
    int stats_AXI_write_idle_min;

    // Variable:- stats_AXI_write_occupancy_max
    //
    //  A variable for holding the maximum write occupancy metric within the <config_stats_enable_AXI_write_occupancy> sliding window.
    // 
    //
    int stats_AXI_write_occupancy_max;

    // Variable:- stats_AXI_write_idle_max
    //
    //  A variable for holding the maximum write idle metric within <config_stats_enable_AXI_write_occupancy> the sliding window.
    // 
    //
    int stats_AXI_write_idle_max;

    // Variable:- stats_AXI_write_occupancy_mean
    //
    //  A variable for holding the mean write occupancy metric within the <config_stats_enable_AXI_write_occupancy> sliding window.
    // 
    //
    int stats_AXI_write_occupancy_mean;

    // Variable:- stats_AXI_write_idle_mean
    //
    //  A variable for holding the mean write idle metric within the <config_stats_enable_AXI_write_occupancy> sliding window.
    // 
    //
    int stats_AXI_write_idle_mean;

    // Variable:- stats_read_data_occupancy_sw
    //
    //  A variable for holding the calculation of the read data occupancy <config_stats_enable_read_data_occupancy> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <config_stats_enable_read_data_occupancy> statistic is calculated based on all of the segments.
    // 
    //
    int stats_read_data_occupancy_sw;

    // Variable:- stats_read_data_occupancy_sw_updated
    //
    //  A variable for holding the number of times the <stats_read_data_occupancy_sw> and <stats_read_data_idle_sw> sliding window statistics have been updated,
    //  plus their respective min, max and mean values.
    // The value is incremented after every <config_stats_read_data_occupancy_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest values of the following statistics
    // - <stats_read_data_occupancy_sw>
    // - <stats_read_data_occupancy_min>
    // - <stats_read_data_occupancy_max>
    // - <stats_read_data_occupancy_mean>
    // - <stats_read_data_idle_sw>
    // - <stats_read_data_idle_min>
    // - <stats_read_data_idle_max>
    // - <stats_read_data_idle_mean>
    // 
    //
    int stats_read_data_occupancy_sw_updated;

    // Variable:- stats_read_data_idle_sw
    //
    //  A variable for holding the calculation of the read data idle <config_stats_enable_read_data_occupancy> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_read_data_idle_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_read_data_idle_sw;

    // Variable:- stats_read_data_occupancy_min
    //
    //  A variable for holding the minimum read data occupancy metric within the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    //
    int stats_read_data_occupancy_min;

    // Variable:- stats_read_data_idle_min
    //
    //  A variable for holding the minimum read data idle metric within the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    //
    int stats_read_data_idle_min;

    // Variable:- stats_read_data_occupancy_max
    //
    //  A variable for holding the maximum read data metric within the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    //
    int stats_read_data_occupancy_max;

    // Variable:- stats_read_data_idle_max
    //
    //  A variable for holding the maximum read data idle metric within the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    //
    int stats_read_data_idle_max;

    // Variable:- stats_read_data_occupancy_mean
    //
    //  A variable for holding the mean read data occupancy metric within the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    //
    int stats_read_data_occupancy_mean;

    // Variable:- stats_read_data_idle_mean
    //
    //  A variable for holding the mean read data idle occupancy metric within the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    //
    int stats_read_data_idle_mean;

    // Variable:- stats_write_data_occupancy_sw
    //
    //  A variable for holding the calculation of the write data occupancy <config_stats_enable_write_data_occupancy> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_data_occupancy_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_data_occupancy_sw;

    // Variable:- stats_write_data_occupancy_sw_updated
    //
    //  A variable for holding the number of times the <stats_write_data_occupancy_sw> and <stats_write_data_idle_sw>sliding window statistics have been updated,
    //  plus their respective min, max and mean values.
    // The value is incremented after every <config_stats_write_data_occupancy_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest values of the following statistics.
    // - <stats_write_data_occupancy_sw>
    // - <stats_write_data_occupancy_min>
    // - <stats_write_data_occupancy_max>
    // - <stats_write_data_occupancy_min>
    // - <stats_write_data_idle_sw>
    // - <stats_write_data_idle_min>
    // - <stats_write_data_idle_max>
    // - <stats_write_data_idle_mean>
    // 
    //
    int stats_write_data_occupancy_sw_updated;

    // Variable:- stats_write_data_idle_sw
    //
    //  A variable for holding the calculation of the write data idle <config_stats_enable_write_data_occupancy> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_data_idle_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_data_idle_sw;

    // Variable:- stats_write_data_occupancy_min
    //
    //  A variable for holding the minimum write data occupancy metric within the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    //
    int stats_write_data_occupancy_min;

    // Variable:- stats_write_data_idle_min
    //
    //  A variable for holding the mean write data idle occupancy metric within the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    //
    int stats_write_data_idle_min;

    // Variable:- stats_write_data_occupancy_max
    //
    //  A variable for holding the maximum write data metric within the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    //
    int stats_write_data_occupancy_max;

    // Variable:- stats_write_data_idle_max
    //
    //  A variable for holding the maximum write data idle metric within the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    //
    int stats_write_data_idle_max;

    // Variable:- stats_write_data_occupancy_mean
    //
    //  A variable for holding the mean write data occupancy metric within the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    //
    int stats_write_data_occupancy_mean;

    // Variable:- stats_write_data_idle_mean
    //
    //  A variable for holding the mean write data idle occupancy metric within the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    //
    int stats_write_data_idle_mean;

    // Variable:- stats_read_bandwidth_sw
    //
    //  A variable for holding the calculation of the read bandwidth <config_stats_enable_read_bandwidth> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_read_bandwidth_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_read_bandwidth_sw;

    // Variable:- stats_read_bandwidth_sw_updated
    //
    //  A variable for holding the number of times the <stats_read_bandwidth_sw> sliding window statistic has been updated.
    // The value is incremented after every <config_stats_read_bandwidth_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest values of the following statistics.
    // - <stats_read_bandwidth_sw>
    // - <stats_read_bandwidth_min>
    // - <stats_read_bandwidth_max>
    // - <stats_read_bandwidth_mean>
    // 
    //
    int stats_read_bandwidth_sw_updated;

    // Variable:- stats_read_bandwidth_min
    //
    //  A variable for holding the minimum read bandwidth metric within the <config_stats_enable_read_bandwidth> sliding window.
    // 
    //
    int stats_read_bandwidth_min;

    // Variable:- stats_read_bandwidth_max
    //
    //  A variable for holding the maximum read bandwidth metric within the <config_stats_enable_read_bandwidth> sliding window.
    // 
    //
    int stats_read_bandwidth_max;

    // Variable:- stats_read_bandwidth_mean
    //
    //  A variable for holding the mean read bandwidth metric within the <config_stats_enable_read_bandwidth> sliding window.
    // 
    //
    int stats_read_bandwidth_mean;

    // Variable:- stats_write_bandwidth_sw
    //
    //  A variable for holding the calculation of the write bandwidth <config_stats_enable_write_bandwidth> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_bandwidth_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_bandwidth_sw;

    // Variable:- stats_write_bandwidth_sw_updated
    //
    //  A variable for holding the number of times the <stats_write_bandwidth_sw> sliding window statistic has been updated.
    // The value is incremented after every <config_stats_write_bandwidth_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest values of the following staistics
    // - <stats_write_bandwidth_sw>
    // - <stats_write_bandwidth_min>
    // - <stats_write_bandwidth_max>
    // - <stats_write_bandwidth_mean>
    // 
    //
    int stats_write_bandwidth_sw_updated;

    // Variable:- stats_write_bandwidth_min
    //
    //  A variable for holding the minimum write bandwidth metric within the <config_stats_enable_write_bandwidth> sliding window.
    // 
    //
    int stats_write_bandwidth_min;

    // Variable:- stats_write_bandwidth_max
    //
    //  A variable for holding the maximum write bandwidth metric within the <config_stats_enable_write_bandwidth> sliding window.
    // 
    //
    int stats_write_bandwidth_max;

    // Variable:- stats_write_bandwidth_mean
    //
    //  A variable for holding the mean write bandwidth metric within the <config_stats_enable_write_bandwidth> sliding window.
    // 
    //
    int stats_write_bandwidth_mean;

    // Variable:- stats_read_latency_sw_updated
    //
    //  A variable for holding the number of times the <stats_read_address_data_latency_sw> sliding window statistic has been updated.
    // The value is incremented after every <config_stats_read_latency_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest values of the following statistics.
    // - <stats_read_address_data_latency_sw>
    // - <stats_read_address_data_latency_min>
    // - <stats_read_address_data_latency_max>
    // - <stats_read_address_data_latency_mean>
    // 
    //
    int stats_read_latency_sw_updated;

    // Variable:- stats_read_address_data_latency_inst
    //
    //  A variable for holding the instantaneous read address to read data latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_data_latency_inst;

    // Variable:- stats_read_address_data_latency_sw
    //
    //  A variable for holding the calculation of the read address to read data latency <config_stats_enable_read_latency> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_read_address_data_latency_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_read_address_data_latency_sw;

    // Variable:- stats_read_address_data_latency_min
    //
    //  A variable for holding the minimum read address to read data latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_data_latency_min;

    // Variable:- stats_read_address_data_latency_max
    //
    //  A variable for holding the maximum read address to read data latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_data_latency_max;

    // Variable:- stats_read_address_data_latency_mean
    //
    //  A variable for holding the mean read address to read data latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_data_latency_mean;

    // Variable:- stats_read_address_address_latency_inst
    //
    //  A variable for holding the instantaneous read address to read address latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_address_latency_inst;

    // Variable:- stats_read_address_address_latency_sw
    //
    //  A variable for holding the calculation of the read address to read address latency <config_stats_enable_read_latency> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_read_address_address_latency_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_read_address_address_latency_sw;

    // Variable:- stats_read_address_address_latency_min
    //
    //  A variable for holding the minimum read address to read address latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_address_latency_min;

    // Variable:- stats_read_address_address_latency_max
    //
    //  A variable for holding the maximum read address to read address latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_address_latency_max;

    // Variable:- stats_read_address_address_latency_mean
    //
    //  A variable for holding the mean read address to read address latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_address_latency_mean;

    // Variable:- stats_write_latency_sw_updated
    //
    //  A variable for holding the number of times the <stats_write_address_data_latency_sw> sliding window statistic has been updated.
    // The value is incremented after every <config_stats_write_latency_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest value of the following statistics
    // - <stats_write_address_data_latency_sw>
    // - <stats_write_address_data_latency_min>
    // - <stats_write_address_data_latency_max>
    // - <stats_write_address_data_latency_mean>
    // 
    //
    int stats_write_latency_sw_updated;

    // Variable:- stats_write_address_data_latency_inst
    //
    //  A variable for holding the instantaneous write address to write data latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_data_latency_inst;

    // Variable:- stats_write_address_data_latency_sw
    //
    //  A variable for holding the calculation of the write address to write data latency <config_stats_enable_write_latency> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_address_data_latency_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_address_data_latency_sw;

    // Variable:- stats_write_address_data_latency_min
    //
    //  A variable for holding the minimum write address to write data latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_data_latency_min;

    // Variable:- stats_write_address_data_latency_max
    //
    //  A variable for holding the maximum write address to write data latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_data_latency_max;

    // Variable:- stats_write_address_data_latency_mean
    //
    //  A variable for holding the mean write address to write data latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_data_latency_mean;

    // Variable:- stats_write_data_response_latency_inst
    //
    //  A variable for holding the instantaneous write data to write response latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_data_response_latency_inst;

    // Variable:- stats_write_data_response_latency_sw
    //
    //  A variable for holding the calculation of the write data to write response latency <config_stats_enable_write_latency> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_data_response_latency_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_data_response_latency_sw;

    // Variable:- stats_write_data_response_latency_min
    //
    //  A variable for holding the minimum write data to write response latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_data_response_latency_min;

    // Variable:- stats_write_data_response_latency_max
    //
    //  A variable for holding the maximum write data to write response latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_data_response_latency_max;

    // Variable:- stats_write_data_response_latency_mean
    //
    //  A variable for holding the mean write data to write response latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_data_response_latency_mean;

    // Variable:- stats_write_address_address_latency_inst
    //
    //  A variable for holding the instantaneous write address to write address latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_address_latency_inst;

    // Variable:- stats_write_address_address_latency_sw
    //
    //  A variable for holding the calculation of the write address to write address latency <config_stats_enable_write_latency> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_address_address_latency_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_address_address_latency_sw;

    // Variable:- stats_write_address_address_latency_min
    //
    //  A variable for holding the minimum write address to write address latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_address_latency_min;

    // Variable:- stats_write_address_address_latency_max
    //
    //  A variable for holding the maximum write address to write address latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_address_latency_max;

    // Variable:- stats_write_address_address_latency_mean
    //
    //  A variable for holding the mean write address to write address latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_address_latency_mean;

    // Variable:- stats_read_address_waits_inst
    //
    //  A variable for holding the instantaneous read address wait states metric within the <config_stats_enable_read_address_waits> sliding window.
    // 
    //
    int stats_read_address_waits_inst;

    // Variable:- stats_read_address_waits_sw
    //
    //  A variable for holding the calculation of the read address wait states <config_stats_enable_read_address_waits> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_read_address_waits_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_read_address_waits_sw;

    // Variable:- stats_read_address_waits_sw_updated
    //
    //  A variable for holding the number of times the <stats_read_address_waits_sw> sliding window statistic has been updated.
    // It is incremented after every <config_stats_read_address_waits_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest value of the following statistics
    // - <stats_read_address_waits_sw>
    // - <stats_read_address_waits_min>
    // - <stats_read_address_waits_max>
    // - <stats_read_address_waits_mean>
    // 
    //
    int stats_read_address_waits_sw_updated;

    // Variable:- stats_read_address_waits_min
    //
    //  A variable for holding the minimum read address wait states metric within the <config_stats_enable_read_address_waits> sliding window.
    // 
    //
    int stats_read_address_waits_min;

    // Variable:- stats_read_address_waits_max
    //
    //  A variable for holding the maximum read address wait states metric within the <config_stats_enable_read_address_waits> sliding window.
    // 
    //
    int stats_read_address_waits_max;

    // Variable:- stats_read_address_waits_mean
    //
    //  A variable for holding the mean read address wait states metric within the <config_stats_enable_read_address_waits> sliding window.
    // 
    //
    int stats_read_address_waits_mean;

    // Variable:- stats_read_data_waits_inst
    //
    //  A variable for holding the instantaneous read data wait states metric within the <config_stats_enable_read_data_waits> sliding window.
    // 
    //
    int stats_read_data_waits_inst;

    // Variable:- stats_read_data_waits_sw
    //
    //  A variable for holding the calculation of the read data wait states <config_stats_enable_read_data_waits> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_read_data_waits_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_read_data_waits_sw;

    // Variable:- stats_read_data_waits_sw_updated
    //
    //  A variable for holding the number of times the <stats_read_data_waits_sw> sliding window statistic has been updated.
    // It is incremented after every <config_stats_read_data_waits_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest value of the following statistics
    // - <stats_read_data_waits_sw>
    // - <stats_read_data_waits_min>
    // - <stats_read_data_waits_max>
    // - <stats_read_data_waits_mean>
    // 
    //
    int stats_read_data_waits_sw_updated;

    // Variable:- stats_read_data_waits_min
    //
    //  A variable for holding the minimum read data wait states metric within the <config_stats_enable_read_data_waits> sliding window.
    // 
    //
    int stats_read_data_waits_min;

    // Variable:- stats_read_data_waits_max
    //
    //  A variable for holding the maximum read data wait states metric within the <config_stats_enable_read_data_waits> sliding window.
    // 
    //
    int stats_read_data_waits_max;

    // Variable:- stats_read_data_waits_mean
    //
    //  A variable for holding the mean read data wait states metric within the <config_stats_enable_read_data_waits> sliding window.
    // 
    //
    int stats_read_data_waits_mean;

    // Variable:- stats_write_address_waits_inst
    //
    //  A variable for holding the instantaneous write address wait states metric within the <config_stats_enable_write_address_waits> sliding window.
    // 
    //
    int stats_write_address_waits_inst;

    // Variable:- stats_write_address_waits_sw
    //
    //  A variable for holding the calculation of the write address wait states <config_stats_enable_write_address_waits> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_address_waits_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_address_waits_sw;

    // Variable:- stats_write_address_waits_sw_updated
    //
    //  A variable for holding the number of times the <stats_write_address_waits_sw> sliding window statistic has been updated.
    // It is incremented after every <config_stats_write_address_waits_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest value of the following statistics
    // - <stats_write_address_waits_sw>
    // - <stats_write_address_waits_min>
    // - <stats_write_address_waits_max>
    // - <stats_write_address_waits_mean>
    // 
    //
    int stats_write_address_waits_sw_updated;

    // Variable:- stats_write_address_waits_min
    //
    //  A variable for holding the minimum write address wait states metric within the <config_stats_enable_write_address_waits> sliding window.
    // 
    //
    int stats_write_address_waits_min;

    // Variable:- stats_write_address_waits_max
    //
    //  A variable for holding the maximum write address wait states metric within the <config_stats_enable_write_address_waits> sliding window.
    // 
    //
    int stats_write_address_waits_max;

    // Variable:- stats_write_address_waits_mean
    //
    //  A variable for holding the mean write address wait states metric within the <config_stats_enable_write_address_waits> sliding window.
    // 
    //
    int stats_write_address_waits_mean;

    // Variable:- stats_write_data_waits_inst
    //
    //  A variable for holding the instantaneous write data wait states metric within the <config_stats_enable_write_data_waits> sliding window.
    // 
    //
    int stats_write_data_waits_inst;

    // Variable:- stats_write_data_waits_sw
    //
    //  A variable for holding the calculation of the write data wait states <config_stats_enable_write_data_waits> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_data_waits_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_data_waits_sw;

    // Variable:- stats_write_data_waits_sw_updated
    //
    //  A variable for holding the number of times the <stats_write_data_waits_sw> sliding window statistic has been updated.
    // It is incremented after every <config_stats_write_data_waits_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest value of the following statistics.
    // - <stats_write_data_waits_sw>
    // - <stats_write_data_waits_min>
    // - <stats_write_data_waits_max>
    // - <stats_write_data_waits_mean>
    // 
    //
    int stats_write_data_waits_sw_updated;

    // Variable:- stats_write_data_waits_min
    //
    //  A variable for holding the minimum write data wait states metric within the <config_stats_enable_write_data_waits> sliding window.
    // 
    //
    int stats_write_data_waits_min;

    // Variable:- stats_write_data_waits_max
    //
    //  A variable for holding the maximum write data wait states metric within the <config_stats_enable_write_data_waits> sliding window.
    // 
    //
    int stats_write_data_waits_max;

    // Variable:- stats_write_data_waits_mean
    //
    //  A variable for holding the mean write data wait states metric within the <config_stats_enable_write_data_waits> sliding window.
    // 
    //
    int stats_write_data_waits_mean;

    // Variable:- stats_write_response_waits_inst
    //
    //  A variable for holding the instantaneous write response wait states metric within the <config_stats_enable_write_response_waits> sliding window.
    // 
    //
    int stats_write_response_waits_inst;

    // Variable:- stats_write_response_waits_sw
    //
    //  A variable for holding the calculation of the write response wait states <config_stats_enable_write_response_waits> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_response_waits_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_response_waits_sw;

    // Variable:- stats_write_response_waits_sw_updated
    //
    //  A variable for holding the number of times the <stats_write_response_waits_sw> sliding window statistic has been updated.
    // It is incremented after every <config_stats_write_response_waits_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest value of the following statistics.
    // - <stats_write_response_waits_sw>
    // - <stats_write_response_waits_min>
    // - <stats_write_response_waits_max>
    // - <stats_write_response_waits_mean>
    // 
    //
    int stats_write_response_waits_sw_updated;

    // Variable:- stats_write_response_waits_min
    //
    //  A variable for holding the minimum write response wait states metric within the <config_stats_enable_write_response_waits> sliding window.
    // 
    //
    int stats_write_response_waits_min;

    // Variable:- stats_write_response_waits_max
    //
    //  A variable for holding the maximum write response wait states metric within the <config_stats_enable_write_response_waits> sliding window.
    // 
    //
    int stats_write_response_waits_max;

    // Variable:- stats_write_response_waits_mean
    //
    //  A variable for holding the mean write response wait states metric within the <config_stats_enable_write_response_waits> sliding window.
    // 
    //
    int stats_write_response_waits_mean;

    // Variable:- stats_rw_transaction_last_duration
    //
    //  A variable for holding the duration of the last read or write transaction.
    // 
    //
    int stats_rw_transaction_last_duration;

    // Variable:- stats_AXI_read_last_duration
    //
    //  A variable for holding the duration of the last read transaction.
    // 
    //
    int stats_AXI_read_last_duration;

    // Variable:- stats_AXI_write_last_duration
    //
    //  A variable for holding the duration of the last write transaction.
    // 
    //
    int stats_AXI_write_last_duration;

    // Variable:- stats_read_addr_channel_phase_last_duration
    //
    //  A variable for holding the duration of the last read address phase.
    // 
    //
    int stats_read_addr_channel_phase_last_duration;

    // Variable:- stats_read_data_burst_last_duration
    //
    //  A variable for holding the duration of the last read data burst.
    // 
    //
    int stats_read_data_burst_last_duration;

    // Variable:- stats_read_channel_phase_last_duration
    //
    //  A variable for holding the duration of the last read channel phase.
    // 
    //
    int stats_read_channel_phase_last_duration;

    // Variable:- stats_write_addr_channel_phase_last_duration
    //
    //  A variable for holding the duration of the last write address channel phase.
    // 
    //
    int stats_write_addr_channel_phase_last_duration;

    // Variable:- stats_write_data_burst_last_duration
    //
    //  A variable for holding the duration of the last write data burst.
    // 
    //
    int stats_write_data_burst_last_duration;

    // Variable:- stats_write_channel_phase_last_duration
    //
    //  A variable for holding the duration of the last write channel phase.
    // 
    //
    int stats_write_channel_phase_last_duration;

    // Variable:- stats_write_resp_channel_phase_last_duration
    //
    //  A variable for holding the duration of the last write response channel phase.
    // 
    //
    int stats_write_resp_channel_phase_last_duration;


    //------------------------------------------------------------------------------
    // Assertions
    //------------------------------------------------------------------------------
    // Documentation for assertions has been moved to <axi_assertions.svh>.

    import "DPI-C" context axi_get_axi_master_end = function longint axi_get_axi_master_end();
    import "DPI-C" context axi_get_axi_slave_end = function longint axi_get_axi_slave_end();
    import "DPI-C" context axi_get_axi_clock_source_end = function longint axi_get_axi_clock_source_end();
    import "DPI-C" context axi_get_axi_reset_source_end = function longint axi_get_axi_reset_source_end();
    import "DPI-C" context axi_get_axi__monitor_end = function longint axi_get_axi__monitor_end();
    // Declare user visible wires variables, for non-continuous assignments.
    logic m_ACLK = 'z;
    logic m_ARESETn = 'z;
    logic m_AWVALID = 'z;
    logic [((AXI_ADDRESS_WIDTH) - 1):0]  m_AWADDR = 'z;
    logic [3:0] m_AWLEN = 'z;
    logic [2:0] m_AWSIZE = 'z;
    logic [1:0] m_AWBURST = 'z;
    logic [1:0] m_AWLOCK = 'z;
    logic [3:0] m_AWCACHE = 'z;
    logic [2:0] m_AWPROT = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  m_AWID = 'z;
    logic m_AWREADY = 'z;
    logic [7:0] m_AWUSER = 'z;
    logic m_ARVALID = 'z;
    logic [((AXI_ADDRESS_WIDTH) - 1):0]  m_ARADDR = 'z;
    logic [3:0] m_ARLEN = 'z;
    logic [2:0] m_ARSIZE = 'z;
    logic [1:0] m_ARBURST = 'z;
    logic [1:0] m_ARLOCK = 'z;
    logic [3:0] m_ARCACHE = 'z;
    logic [2:0] m_ARPROT = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  m_ARID = 'z;
    logic m_ARREADY = 'z;
    logic [7:0] m_ARUSER = 'z;
    logic m_RVALID = 'z;
    logic m_RLAST = 'z;
    logic [((AXI_RDATA_WIDTH) - 1):0]  m_RDATA = 'z;
    logic [1:0] m_RRESP = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  m_RID = 'z;
    logic m_RREADY = 'z;
    logic [7:0] m_RUSER = 'z;
    logic m_WVALID = 'z;
    logic m_WLAST = 'z;
    logic [((AXI_WDATA_WIDTH) - 1):0]  m_WDATA = 'z;
    logic [(((AXI_WDATA_WIDTH / 8)) - 1):0]  m_WSTRB = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  m_WID = 'z;
    logic m_WREADY = 'z;
    logic [7:0] m_WUSER = 'z;
    logic m_BVALID = 'z;
    logic [1:0] m_BRESP = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  m_BID = 'z;
    logic m_BREADY = 'z;
    logic [7:0] m_BUSER = 'z;

    // Forces a sweep through the wire change checkers at time 0 to get around process kick-off order unknowns
    bit _check_t0_values;
    always_comb _check_t0_values = 1;


    //------------------------------------------------------------------------------
    // Generic Interface Configuration Support
    //------------------------------------------------------------------------------

    import "DPI-C" context axi_set_interface = function void axi_set_interface
    (
        input int what,
        input int arg1,
        input int arg2,
        input int arg3,
        input int arg4,
        input int arg5,
        input int arg6,
        input int arg7,
        input int arg8,
        input int arg9,
        input int arg10
    );
    import "DPI-C" context axi_get_interface = function int axi_get_interface
    (
        input int what,
        input int arg1,
        input int arg2,
        input int arg3,
        input int arg4,
        input int arg5,
        input int arg6,
        input int arg7,
        input int arg8,
        input int arg9
    );
    //------------------------------------------------------------------------------
    // Functions to get the hierarchic name of this interface
    //------------------------------------------------------------------------------
    import "DPI-C" context axi_get_full_name = function string axi_get_full_name();

    //------------------------------------------------------------------------------
    // Abstraction level Support
    //------------------------------------------------------------------------------

    import "DPI-C" context axi_set_master_end_abstraction_level = function void axi_set_master_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi_get_master_end_abstraction_level = function void axi_get_master_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    import "DPI-C" context axi_set_slave_end_abstraction_level = function void axi_set_slave_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi_get_slave_end_abstraction_level = function void axi_get_slave_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    import "DPI-C" context axi_set_clock_source_end_abstraction_level = function void axi_set_clock_source_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi_get_clock_source_end_abstraction_level = function void axi_get_clock_source_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    import "DPI-C" context axi_set_reset_source_end_abstraction_level = function void axi_set_reset_source_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi_get_reset_source_end_abstraction_level = function void axi_get_reset_source_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );

    //------------------------------------------------------------------------------
    // Wire Level Interface Support
    //------------------------------------------------------------------------------
    logic internal_ACLK = 'z;
    logic internal_ARESETn = 'z;
    logic internal_AWVALID = 'z;
    logic [((AXI_ADDRESS_WIDTH) - 1):0]  internal_AWADDR = 'z;
    logic [3:0] internal_AWLEN = 'z;
    logic [2:0] internal_AWSIZE = 'z;
    logic [1:0] internal_AWBURST = 'z;
    logic [1:0] internal_AWLOCK = 'z;
    logic [3:0] internal_AWCACHE = 'z;
    logic [2:0] internal_AWPROT = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  internal_AWID = 'z;
    logic internal_AWREADY = 'z;
    logic [7:0] internal_AWUSER = 'z;
    logic internal_ARVALID = 'z;
    logic [((AXI_ADDRESS_WIDTH) - 1):0]  internal_ARADDR = 'z;
    logic [3:0] internal_ARLEN = 'z;
    logic [2:0] internal_ARSIZE = 'z;
    logic [1:0] internal_ARBURST = 'z;
    logic [1:0] internal_ARLOCK = 'z;
    logic [3:0] internal_ARCACHE = 'z;
    logic [2:0] internal_ARPROT = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  internal_ARID = 'z;
    logic internal_ARREADY = 'z;
    logic [7:0] internal_ARUSER = 'z;
    logic internal_RVALID = 'z;
    logic internal_RLAST = 'z;
    logic [((AXI_RDATA_WIDTH) - 1):0]  internal_RDATA = 'z;
    logic [1:0] internal_RRESP = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  internal_RID = 'z;
    logic internal_RREADY = 'z;
    logic [7:0] internal_RUSER = 'z;
    logic internal_WVALID = 'z;
    logic internal_WLAST = 'z;
    logic [((AXI_WDATA_WIDTH) - 1):0]  internal_WDATA = 'z;
    logic [(((AXI_WDATA_WIDTH / 8)) - 1):0]  internal_WSTRB = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  internal_WID = 'z;
    logic internal_WREADY = 'z;
    logic [7:0] internal_WUSER = 'z;
    logic internal_BVALID = 'z;
    logic [1:0] internal_BRESP = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  internal_BID = 'z;
    logic internal_BREADY = 'z;
    logic [7:0] internal_BUSER = 'z;

    import "DPI-C" context function longint axi_initialise_SystemVerilog
    (
        int usage_code,
        input int AXI_ADDRESS_WIDTH,
        input int AXI_RDATA_WIDTH,
        input int AXI_WDATA_WIDTH,
        input int AXI_ID_WIDTH
    );

    // Handle to the linkage
    (* elab_init *) longint _interface_ref =
                                axi_initialise_SystemVerilog
                                (
                                    18102076,
                                    AXI_ADDRESS_WIDTH,
                                    AXI_RDATA_WIDTH,
                                    AXI_WDATA_WIDTH,
                                    AXI_ID_WIDTH
                                ); // DPI call to create transactor (called at elaboration time as initialiser)


    import "DPI-C" context function void axi_set_ACLK_from_SystemVerilog
    (
        input bit ACLK_param
    );
    import "DPI-C" context function void axi_propagate_ACLK_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ACLK_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ACLK_from_CY;
    export "DPI-C" function axi_initialise_ACLK_from_CY;

    import "DPI-C" context function void axi_set_ARESETn_from_SystemVerilog
    (
        input logic ARESETn_param
    );
    import "DPI-C" context function void axi_propagate_ARESETn_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARESETn_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARESETn_from_CY;
    export "DPI-C" function axi_initialise_ARESETn_from_CY;

    import "DPI-C" context function void axi_set_AWVALID_from_SystemVerilog
    (
        input logic AWVALID_param
    );
    import "DPI-C" context function void axi_propagate_AWVALID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWVALID_from_CY;
    export "DPI-C" function axi_initialise_AWVALID_from_CY;

    import "DPI-C" context function void axi_set_AWADDR_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  AWADDR_param
    );
    import "DPI-C" context function void axi_propagate_AWADDR_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWADDR_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWADDR_from_CY_index1;
    export "DPI-C" function axi_initialise_AWADDR_from_CY;

    import "DPI-C" context function void axi_set_AWLEN_from_SystemVerilog
    (
        input logic [3:0] AWLEN_param
    );
    import "DPI-C" context function void axi_propagate_AWLEN_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWLEN_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWLEN_from_CY;
    export "DPI-C" function axi_initialise_AWLEN_from_CY;

    import "DPI-C" context function void axi_set_AWSIZE_from_SystemVerilog
    (
        input logic [2:0] AWSIZE_param
    );
    import "DPI-C" context function void axi_propagate_AWSIZE_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWSIZE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWSIZE_from_CY;
    export "DPI-C" function axi_initialise_AWSIZE_from_CY;

    import "DPI-C" context function void axi_set_AWBURST_from_SystemVerilog
    (
        input logic [1:0] AWBURST_param
    );
    import "DPI-C" context function void axi_propagate_AWBURST_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWBURST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWBURST_from_CY;
    export "DPI-C" function axi_initialise_AWBURST_from_CY;

    import "DPI-C" context function void axi_set_AWLOCK_from_SystemVerilog
    (
        input logic [1:0] AWLOCK_param
    );
    import "DPI-C" context function void axi_propagate_AWLOCK_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWLOCK_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWLOCK_from_CY;
    export "DPI-C" function axi_initialise_AWLOCK_from_CY;

    import "DPI-C" context function void axi_set_AWCACHE_from_SystemVerilog
    (
        input logic [3:0] AWCACHE_param
    );
    import "DPI-C" context function void axi_propagate_AWCACHE_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWCACHE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWCACHE_from_CY;
    export "DPI-C" function axi_initialise_AWCACHE_from_CY;

    import "DPI-C" context function void axi_set_AWPROT_from_SystemVerilog
    (
        input logic [2:0] AWPROT_param
    );
    import "DPI-C" context function void axi_propagate_AWPROT_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWPROT_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWPROT_from_CY;
    export "DPI-C" function axi_initialise_AWPROT_from_CY;

    import "DPI-C" context function void axi_set_AWID_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  AWID_param
    );
    import "DPI-C" context function void axi_propagate_AWID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWID_from_CY_index1;
    export "DPI-C" function axi_initialise_AWID_from_CY;

    import "DPI-C" context function void axi_set_AWREADY_from_SystemVerilog
    (
        input logic AWREADY_param
    );
    import "DPI-C" context function void axi_propagate_AWREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWREADY_from_CY;
    export "DPI-C" function axi_initialise_AWREADY_from_CY;

    import "DPI-C" context function void axi_set_AWUSER_from_SystemVerilog
    (
        input logic [7:0] AWUSER_param
    );
    import "DPI-C" context function void axi_propagate_AWUSER_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWUSER_from_CY;
    export "DPI-C" function axi_initialise_AWUSER_from_CY;

    import "DPI-C" context function void axi_set_ARVALID_from_SystemVerilog
    (
        input logic ARVALID_param
    );
    import "DPI-C" context function void axi_propagate_ARVALID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARVALID_from_CY;
    export "DPI-C" function axi_initialise_ARVALID_from_CY;

    import "DPI-C" context function void axi_set_ARADDR_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  ARADDR_param
    );
    import "DPI-C" context function void axi_propagate_ARADDR_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARADDR_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARADDR_from_CY_index1;
    export "DPI-C" function axi_initialise_ARADDR_from_CY;

    import "DPI-C" context function void axi_set_ARLEN_from_SystemVerilog
    (
        input logic [3:0] ARLEN_param
    );
    import "DPI-C" context function void axi_propagate_ARLEN_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARLEN_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARLEN_from_CY;
    export "DPI-C" function axi_initialise_ARLEN_from_CY;

    import "DPI-C" context function void axi_set_ARSIZE_from_SystemVerilog
    (
        input logic [2:0] ARSIZE_param
    );
    import "DPI-C" context function void axi_propagate_ARSIZE_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARSIZE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARSIZE_from_CY;
    export "DPI-C" function axi_initialise_ARSIZE_from_CY;

    import "DPI-C" context function void axi_set_ARBURST_from_SystemVerilog
    (
        input logic [1:0] ARBURST_param
    );
    import "DPI-C" context function void axi_propagate_ARBURST_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARBURST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARBURST_from_CY;
    export "DPI-C" function axi_initialise_ARBURST_from_CY;

    import "DPI-C" context function void axi_set_ARLOCK_from_SystemVerilog
    (
        input logic [1:0] ARLOCK_param
    );
    import "DPI-C" context function void axi_propagate_ARLOCK_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARLOCK_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARLOCK_from_CY;
    export "DPI-C" function axi_initialise_ARLOCK_from_CY;

    import "DPI-C" context function void axi_set_ARCACHE_from_SystemVerilog
    (
        input logic [3:0] ARCACHE_param
    );
    import "DPI-C" context function void axi_propagate_ARCACHE_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARCACHE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARCACHE_from_CY;
    export "DPI-C" function axi_initialise_ARCACHE_from_CY;

    import "DPI-C" context function void axi_set_ARPROT_from_SystemVerilog
    (
        input logic [2:0] ARPROT_param
    );
    import "DPI-C" context function void axi_propagate_ARPROT_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARPROT_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARPROT_from_CY;
    export "DPI-C" function axi_initialise_ARPROT_from_CY;

    import "DPI-C" context function void axi_set_ARID_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  ARID_param
    );
    import "DPI-C" context function void axi_propagate_ARID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARID_from_CY_index1;
    export "DPI-C" function axi_initialise_ARID_from_CY;

    import "DPI-C" context function void axi_set_ARREADY_from_SystemVerilog
    (
        input logic ARREADY_param
    );
    import "DPI-C" context function void axi_propagate_ARREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARREADY_from_CY;
    export "DPI-C" function axi_initialise_ARREADY_from_CY;

    import "DPI-C" context function void axi_set_ARUSER_from_SystemVerilog
    (
        input logic [7:0] ARUSER_param
    );
    import "DPI-C" context function void axi_propagate_ARUSER_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARUSER_from_CY;
    export "DPI-C" function axi_initialise_ARUSER_from_CY;

    import "DPI-C" context function void axi_set_RVALID_from_SystemVerilog
    (
        input logic RVALID_param
    );
    import "DPI-C" context function void axi_propagate_RVALID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_RVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_RVALID_from_CY;
    export "DPI-C" function axi_initialise_RVALID_from_CY;

    import "DPI-C" context function void axi_set_RLAST_from_SystemVerilog
    (
        input logic RLAST_param
    );
    import "DPI-C" context function void axi_propagate_RLAST_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_RLAST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_RLAST_from_CY;
    export "DPI-C" function axi_initialise_RLAST_from_CY;

    import "DPI-C" context function void axi_set_RDATA_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  RDATA_param
    );
    import "DPI-C" context function void axi_propagate_RDATA_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_RDATA_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_RDATA_from_CY_index1;
    export "DPI-C" function axi_initialise_RDATA_from_CY;

    import "DPI-C" context function void axi_set_RRESP_from_SystemVerilog
    (
        input logic [1:0] RRESP_param
    );
    import "DPI-C" context function void axi_propagate_RRESP_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_RRESP_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_RRESP_from_CY;
    export "DPI-C" function axi_initialise_RRESP_from_CY;

    import "DPI-C" context function void axi_set_RID_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  RID_param
    );
    import "DPI-C" context function void axi_propagate_RID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_RID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_RID_from_CY_index1;
    export "DPI-C" function axi_initialise_RID_from_CY;

    import "DPI-C" context function void axi_set_RREADY_from_SystemVerilog
    (
        input logic RREADY_param
    );
    import "DPI-C" context function void axi_propagate_RREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_RREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_RREADY_from_CY;
    export "DPI-C" function axi_initialise_RREADY_from_CY;

    import "DPI-C" context function void axi_set_RUSER_from_SystemVerilog
    (
        input logic [7:0] RUSER_param
    );
    import "DPI-C" context function void axi_propagate_RUSER_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_RUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_RUSER_from_CY;
    export "DPI-C" function axi_initialise_RUSER_from_CY;

    import "DPI-C" context function void axi_set_WVALID_from_SystemVerilog
    (
        input logic WVALID_param
    );
    import "DPI-C" context function void axi_propagate_WVALID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_WVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_WVALID_from_CY;
    export "DPI-C" function axi_initialise_WVALID_from_CY;

    import "DPI-C" context function void axi_set_WLAST_from_SystemVerilog
    (
        input logic WLAST_param
    );
    import "DPI-C" context function void axi_propagate_WLAST_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_WLAST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_WLAST_from_CY;
    export "DPI-C" function axi_initialise_WLAST_from_CY;

    import "DPI-C" context function void axi_set_WDATA_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  WDATA_param
    );
    import "DPI-C" context function void axi_propagate_WDATA_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_WDATA_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_WDATA_from_CY_index1;
    export "DPI-C" function axi_initialise_WDATA_from_CY;

    import "DPI-C" context function void axi_set_WSTRB_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  WSTRB_param
    );
    import "DPI-C" context function void axi_propagate_WSTRB_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_WSTRB_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_WSTRB_from_CY_index1;
    export "DPI-C" function axi_initialise_WSTRB_from_CY;

    import "DPI-C" context function void axi_set_WID_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  WID_param
    );
    import "DPI-C" context function void axi_propagate_WID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_WID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_WID_from_CY_index1;
    export "DPI-C" function axi_initialise_WID_from_CY;

    import "DPI-C" context function void axi_set_WREADY_from_SystemVerilog
    (
        input logic WREADY_param
    );
    import "DPI-C" context function void axi_propagate_WREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_WREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_WREADY_from_CY;
    export "DPI-C" function axi_initialise_WREADY_from_CY;

    import "DPI-C" context function void axi_set_WUSER_from_SystemVerilog
    (
        input logic [7:0] WUSER_param
    );
    import "DPI-C" context function void axi_propagate_WUSER_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_WUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_WUSER_from_CY;
    export "DPI-C" function axi_initialise_WUSER_from_CY;

    import "DPI-C" context function void axi_set_BVALID_from_SystemVerilog
    (
        input logic BVALID_param
    );
    import "DPI-C" context function void axi_propagate_BVALID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_BVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_BVALID_from_CY;
    export "DPI-C" function axi_initialise_BVALID_from_CY;

    import "DPI-C" context function void axi_set_BRESP_from_SystemVerilog
    (
        input logic [1:0] BRESP_param
    );
    import "DPI-C" context function void axi_propagate_BRESP_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_BRESP_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_BRESP_from_CY;
    export "DPI-C" function axi_initialise_BRESP_from_CY;

    import "DPI-C" context function void axi_set_BID_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  BID_param
    );
    import "DPI-C" context function void axi_propagate_BID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_BID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_BID_from_CY_index1;
    export "DPI-C" function axi_initialise_BID_from_CY;

    import "DPI-C" context function void axi_set_BREADY_from_SystemVerilog
    (
        input logic BREADY_param
    );
    import "DPI-C" context function void axi_propagate_BREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_BREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_BREADY_from_CY;
    export "DPI-C" function axi_initialise_BREADY_from_CY;

    import "DPI-C" context function void axi_set_BUSER_from_SystemVerilog
    (
        input logic [7:0] BUSER_param
    );
    import "DPI-C" context function void axi_propagate_BUSER_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_BUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_BUSER_from_CY;
    export "DPI-C" function axi_initialise_BUSER_from_CY;

    import "DPI-C" context function void axi_set_config_clk_init_value_from_SystemVerilog
    (
        input bit config_clk_init_value_param
    );
    import "DPI-C" context function void axi_propagate_config_clk_init_value_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_clk_init_value_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_clk_init_value_from_CY;

    import "DPI-C" context function void axi_set_config_clk_phase_shift_from_SystemVerilog
    (
        input int config_clk_phase_shift_param
    );
    import "DPI-C" context function void axi_propagate_config_clk_phase_shift_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_clk_phase_shift_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_clk_phase_shift_from_CY;

    import "DPI-C" context function void axi_set_config_clk_1st_time_from_SystemVerilog
    (
        input int config_clk_1st_time_param
    );
    import "DPI-C" context function void axi_propagate_config_clk_1st_time_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_clk_1st_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_clk_1st_time_from_CY;

    import "DPI-C" context function void axi_set_config_clk_2nd_time_from_SystemVerilog
    (
        input int config_clk_2nd_time_param
    );
    import "DPI-C" context function void axi_propagate_config_clk_2nd_time_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_clk_2nd_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_clk_2nd_time_from_CY;

    import "DPI-C" context function void axi_set_config_setup_time_from_SystemVerilog
    (
        input int config_setup_time_param
    );
    import "DPI-C" context function void axi_propagate_config_setup_time_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_setup_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_setup_time_from_CY;

    import "DPI-C" context function void axi_set_config_hold_time_from_SystemVerilog
    (
        input int config_hold_time_param
    );
    import "DPI-C" context function void axi_propagate_config_hold_time_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_hold_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_hold_time_from_CY;

    import "DPI-C" context function void axi_set_config_max_transaction_time_factor_from_SystemVerilog
    (
        input int unsigned config_max_transaction_time_factor_param
    );
    import "DPI-C" context function void axi_propagate_config_max_transaction_time_factor_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_max_transaction_time_factor_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_transaction_time_factor_from_CY;

    import "DPI-C" context function void axi_set_config_timeout_max_data_transfer_from_SystemVerilog
    (
        input int config_timeout_max_data_transfer_param
    );
    import "DPI-C" context function void axi_propagate_config_timeout_max_data_transfer_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_timeout_max_data_transfer_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_timeout_max_data_transfer_from_CY;

    import "DPI-C" context function void axi_set_config_burst_timeout_factor_from_SystemVerilog
    (
        input int unsigned config_burst_timeout_factor_param
    );
    import "DPI-C" context function void axi_propagate_config_burst_timeout_factor_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_burst_timeout_factor_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_burst_timeout_factor_from_CY;

    import "DPI-C" context function void axi_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param
    );
    import "DPI-C" context function void axi_propagate_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_max_latency_AWVALID_assertion_to_AWREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_CY;

    import "DPI-C" context function void axi_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param
    );
    import "DPI-C" context function void axi_propagate_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_max_latency_ARVALID_assertion_to_ARREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_CY;

    import "DPI-C" context function void axi_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_RVALID_assertion_to_RREADY_param
    );
    import "DPI-C" context function void axi_propagate_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_max_latency_RVALID_assertion_to_RREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_latency_RVALID_assertion_to_RREADY_from_CY;

    import "DPI-C" context function void axi_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_BVALID_assertion_to_BREADY_param
    );
    import "DPI-C" context function void axi_propagate_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_max_latency_BVALID_assertion_to_BREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_latency_BVALID_assertion_to_BREADY_from_CY;

    import "DPI-C" context function void axi_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_WVALID_assertion_to_WREADY_param
    );
    import "DPI-C" context function void axi_propagate_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_max_latency_WVALID_assertion_to_WREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_latency_WVALID_assertion_to_WREADY_from_CY;

    import "DPI-C" context function void axi_set_config_write_ctrl_first_ratio_from_SystemVerilog
    (
        input int config_write_ctrl_first_ratio_param
    );
    import "DPI-C" context function void axi_propagate_config_write_ctrl_first_ratio_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_write_ctrl_first_ratio_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_write_ctrl_first_ratio_from_CY;

    import "DPI-C" context function void axi_set_config_write_data_first_ratio_from_SystemVerilog
    (
        input int config_write_data_first_ratio_param
    );
    import "DPI-C" context function void axi_propagate_config_write_data_first_ratio_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_write_data_first_ratio_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_write_data_first_ratio_from_CY;

    import "DPI-C" context function void axi_set_config_write_ctrl_to_data_mintime_from_SystemVerilog
    (
        input int unsigned config_write_ctrl_to_data_mintime_param
    );
    import "DPI-C" context function void axi_propagate_config_write_ctrl_to_data_mintime_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_write_ctrl_to_data_mintime_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_write_ctrl_to_data_mintime_from_CY;

    import "DPI-C" context function void axi_set_config_write_data_to_ctrl_mintime_from_SystemVerilog
    (
        input int unsigned config_write_data_to_ctrl_mintime_param
    );
    import "DPI-C" context function void axi_propagate_config_write_data_to_ctrl_mintime_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_write_data_to_ctrl_mintime_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_write_data_to_ctrl_mintime_from_CY;

    import "DPI-C" context function void axi_set_config_master_write_delay_from_SystemVerilog
    (
        input bit config_master_write_delay_param
    );
    import "DPI-C" context function void axi_propagate_config_master_write_delay_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_master_write_delay_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_master_write_delay_from_CY;

    import "DPI-C" context function void axi_set_config_reset_low_clocks_from_SystemVerilog
    (
        input int config_reset_low_clocks_param
    );
    import "DPI-C" context function void axi_propagate_config_reset_low_clocks_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_reset_low_clocks_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_reset_low_clocks_from_CY;

    import "DPI-C" context function void axi_set_config_reset_hold_time_from_SystemVerilog
    (
        input int config_reset_hold_time_param
    );
    import "DPI-C" context function void axi_propagate_config_reset_hold_time_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_reset_hold_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_reset_hold_time_from_CY;

    import "DPI-C" context function void axi_set_config_protect_ready_from_SystemVerilog
    (
        input bit config_protect_ready_param
    );
    import "DPI-C" context function void axi_propagate_config_protect_ready_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_protect_ready_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_protect_ready_from_CY;

    import "DPI-C" context function void axi_set_config_enable_user_sideband_from_SystemVerilog
    (
        input bit config_enable_user_sideband_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_user_sideband_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_user_sideband_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_user_sideband_from_CY;

    import "DPI-C" context function void axi_set_config_extended_length_enable_from_SystemVerilog
    (
        input bit config_extended_length_enable_param
    );
    import "DPI-C" context function void axi_propagate_config_extended_length_enable_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_extended_length_enable_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_extended_length_enable_from_CY;

    import "DPI-C" context function void axi_set_config_enable_burst_reserved_value_from_SystemVerilog
    (
        input bit config_enable_burst_reserved_value_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_burst_reserved_value_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_burst_reserved_value_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_burst_reserved_value_from_CY;

    import "DPI-C" context function void axi_set_config_enable_lock_reserved_value_from_SystemVerilog
    (
        input bit config_enable_lock_reserved_value_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_lock_reserved_value_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_lock_reserved_value_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_lock_reserved_value_from_CY;

    import "DPI-C" context function void axi_set_config_enable_cache_reserved_value_from_SystemVerilog
    (
        input bit config_enable_cache_reserved_value_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_cache_reserved_value_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_cache_reserved_value_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_cache_reserved_value_from_CY;

    import "DPI-C" context function void axi_set_config_enable_all_assertions_from_SystemVerilog
    (
        input bit config_enable_all_assertions_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_all_assertions_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_all_assertions_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_all_assertions_from_CY;

    import "DPI-C" context function void axi_set_config_enable_assertion_from_SystemVerilog
    (
        input bit [255:0] config_enable_assertion_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_assertion_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_assertion_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_assertion_from_CY;

    import "DPI-C" context function void axi_set_config_enable_error_from_SystemVerilog
    (
        input bit [255:0] config_enable_error_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_error_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_error_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_error_from_CY;

    import "DPI-C" context function void axi_set_config_enable_errors_from_SystemVerilog
    (
        input bit config_enable_errors_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_errors_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_errors_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_errors_from_CY;

    import "DPI-C" context function void axi_set_config_enable_all_assertion_errors_from_SystemVerilog
    (
        input bit config_enable_all_assertion_errors_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_all_assertion_errors_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_all_assertion_errors_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_all_assertion_errors_from_CY;

    import "DPI-C" context function void axi_set_config_abstraction_level_from_SystemVerilog
    (
        input int config_abstraction_level_param
    );
    import "DPI-C" context function void axi_propagate_config_abstraction_level_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_abstraction_level_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_abstraction_level_from_CY;

    import "DPI-C" context function void axi_set_config_slave_start_addr_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input bit  config_slave_start_addr_param
    );
    import "DPI-C" context function void axi_propagate_config_slave_start_addr_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_slave_start_addr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_slave_start_addr_from_CY_index1;

    import "DPI-C" context function void axi_set_config_slave_end_addr_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input bit  config_slave_end_addr_param
    );
    import "DPI-C" context function void axi_propagate_config_slave_end_addr_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_slave_end_addr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_slave_end_addr_from_CY_index1;

    import "DPI-C" context function void axi_set_config_enable_slave_addr_range_in_bfm_from_SystemVerilog
    (
        input bit config_enable_slave_addr_range_in_bfm_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_slave_addr_range_in_bfm_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_slave_addr_range_in_bfm_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_slave_addr_range_in_bfm_from_CY;

    import "DPI-C" context function void axi_set_config_read_data_reordering_depth_from_SystemVerilog
    (
        input int unsigned config_read_data_reordering_depth_param
    );
    import "DPI-C" context function void axi_propagate_config_read_data_reordering_depth_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_read_data_reordering_depth_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_read_data_reordering_depth_from_CY;

    import "DPI-C" context function void axi_set_config_enable_read_data_reordering_depth_in_bfm_from_SystemVerilog
    (
        input bit config_enable_read_data_reordering_depth_in_bfm_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_read_data_reordering_depth_in_bfm_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_read_data_reordering_depth_in_bfm_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_read_data_reordering_depth_in_bfm_from_CY;

    import "DPI-C" context function void axi_set_config_awid_wid_mismatch_from_SystemVerilog
    (
        input bit config_awid_wid_mismatch_param
    );
    import "DPI-C" context function void axi_propagate_config_awid_wid_mismatch_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_awid_wid_mismatch_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_awid_wid_mismatch_from_CY;

    import "DPI-C" context function void axi_set_config_length_last_mismatch_error_from_SystemVerilog
    (
        input bit config_length_last_mismatch_error_param
    );
    import "DPI-C" context function void axi_propagate_config_length_last_mismatch_error_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_length_last_mismatch_error_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_length_last_mismatch_error_from_CY;

    import "DPI-C" context function void axi_set_config_master_error_position_from_SystemVerilog
    (
        input int config_master_error_position_param
    );
    import "DPI-C" context function void axi_propagate_config_master_error_position_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_master_error_position_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_master_error_position_from_CY;

    import "DPI-C" context function void axi_set_dummy_var_from_SystemVerilog
    (
        input int dummy_var_param
    );
    import "DPI-C" context function void axi_propagate_dummy_var_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_dummy_var_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_dummy_var_from_CY;

    import "DPI-C" context function void axi_set_config_wlast_length_from_SystemVerilog
    (
        input int config_wlast_length_param
    );
    import "DPI-C" context function void axi_propagate_config_wlast_length_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_wlast_length_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_wlast_length_from_CY;

    import "DPI-C" context function void axi_set_config_wid_for_awid_not_matching_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input bit  config_wid_for_awid_not_matching_param
    );
    import "DPI-C" context function void axi_propagate_config_wid_for_awid_not_matching_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_wid_for_awid_not_matching_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_wid_for_awid_not_matching_from_CY_index1;

    import "DPI-C" context function void axi_set_config_support_exclusive_access_from_SystemVerilog
    (
        input bit config_support_exclusive_access_param
    );
    import "DPI-C" context function void axi_propagate_config_support_exclusive_access_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_support_exclusive_access_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_support_exclusive_access_from_CY;

    import "DPI-C" context function void axi_set_config_write_data_interleaving_depth_from_SystemVerilog
    (
        input int config_write_data_interleaving_depth_param
    );
    import "DPI-C" context function void axi_propagate_config_write_data_interleaving_depth_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_write_data_interleaving_depth_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_write_data_interleaving_depth_from_CY;

    import "DPI-C" context function void axi_set_status_master_error_from_SystemVerilog
    (
        input bit [15:0] status_master_error_param
    );
    import "DPI-C" context function void axi_propagate_status_master_error_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_status_master_error_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_status_master_error_from_CY;

    import "DPI-C" context function void axi_get_status_num_reads_waiting_for_resp_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_status_num_reads_waiting_for_resp_from_CY;

    import "DPI-C" context function void axi_get_status_num_writes_waiting_for_response_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_status_num_writes_waiting_for_response_from_CY;

    import "DPI-C" context function void axi_set_check_total_num_wdata_outstanding_from_SystemVerilog
    (
        input bit check_total_num_wdata_outstanding_param
    );
    import "DPI-C" context function void axi_propagate_check_total_num_wdata_outstanding_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_check_total_num_wdata_outstanding_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_check_total_num_wdata_outstanding_from_CY;

    import "DPI-C" context function void axi_set_total_num_wdata_outstanding_from_SystemVerilog
    (
        input int total_num_wdata_outstanding_param
    );
    import "DPI-C" context function void axi_propagate_total_num_wdata_outstanding_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_total_num_wdata_outstanding_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_total_num_wdata_outstanding_from_CY;

    import "DPI-C" context function void axi_set_check_max_num_wdata_outstanding_per_id_from_SystemVerilog
    (
        input bit check_max_num_wdata_outstanding_per_id_param
    );
    import "DPI-C" context function void axi_propagate_check_max_num_wdata_outstanding_per_id_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_check_max_num_wdata_outstanding_per_id_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_check_max_num_wdata_outstanding_per_id_from_CY;

    import "DPI-C" context function void axi_set_max_num_wdata_outstanding_per_id_from_SystemVerilog
    (
        input int max_num_wdata_outstanding_per_id_param
    );
    import "DPI-C" context function void axi_propagate_max_num_wdata_outstanding_per_id_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_max_num_wdata_outstanding_per_id_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_max_num_wdata_outstanding_per_id_from_CY;

    import "DPI-C" context function void axi_set_check_max_num_waddr_outstanding_per_id_from_SystemVerilog
    (
        input bit check_max_num_waddr_outstanding_per_id_param
    );
    import "DPI-C" context function void axi_propagate_check_max_num_waddr_outstanding_per_id_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_check_max_num_waddr_outstanding_per_id_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_check_max_num_waddr_outstanding_per_id_from_CY;

    import "DPI-C" context function void axi_set_max_num_waddr_outstanding_per_id_from_SystemVerilog
    (
        input int max_num_waddr_outstanding_per_id_param
    );
    import "DPI-C" context function void axi_propagate_max_num_waddr_outstanding_per_id_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_max_num_waddr_outstanding_per_id_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_max_num_waddr_outstanding_per_id_from_CY;

    import "DPI-C" context function void axi_set_check_total_num_waddr_outstanding_from_SystemVerilog
    (
        input bit check_total_num_waddr_outstanding_param
    );
    import "DPI-C" context function void axi_propagate_check_total_num_waddr_outstanding_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_check_total_num_waddr_outstanding_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_check_total_num_waddr_outstanding_from_CY;

    import "DPI-C" context function void axi_set_total_num_waddr_outstanding_from_SystemVerilog
    (
        input int total_num_waddr_outstanding_param
    );
    import "DPI-C" context function void axi_propagate_total_num_waddr_outstanding_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_total_num_waddr_outstanding_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_total_num_waddr_outstanding_from_CY;

    import "DPI-C" context function void axi_set_status_outstanding_num_for_waddr_from_SystemVerilog
    (
        input int status_outstanding_num_for_waddr_param
    );
    import "DPI-C" context function void axi_propagate_status_outstanding_num_for_waddr_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_status_outstanding_num_for_waddr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_status_outstanding_num_for_waddr_from_CY;

    import "DPI-C" context function void axi_set_start_finding_outstanding_waddr_from_SystemVerilog
    (
        input bit start_finding_outstanding_waddr_param
    );
    import "DPI-C" context function void axi_propagate_start_finding_outstanding_waddr_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_start_finding_outstanding_waddr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_start_finding_outstanding_waddr_from_CY;

    import "DPI-C" context function void axi_set_status_outstanding_num_for_wdata_from_SystemVerilog
    (
        input int status_outstanding_num_for_wdata_param
    );
    import "DPI-C" context function void axi_propagate_status_outstanding_num_for_wdata_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_status_outstanding_num_for_wdata_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_status_outstanding_num_for_wdata_from_CY;

    import "DPI-C" context function void axi_set_start_finding_outstanding_wdata_from_SystemVerilog
    (
        input bit start_finding_outstanding_wdata_param
    );
    import "DPI-C" context function void axi_propagate_start_finding_outstanding_wdata_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_start_finding_outstanding_wdata_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_start_finding_outstanding_wdata_from_CY;

    import "DPI-C" context function void axi_set_find_waddr_outstanding_for_wid_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input bit  find_waddr_outstanding_for_wid_param
    );
    import "DPI-C" context function void axi_propagate_find_waddr_outstanding_for_wid_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_find_waddr_outstanding_for_wid_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_find_waddr_outstanding_for_wid_from_CY_index1;

    import "DPI-C" context function void axi_set_find_wdata_outstanding_for_wid_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input bit  find_wdata_outstanding_for_wid_param
    );
    import "DPI-C" context function void axi_propagate_find_wdata_outstanding_for_wid_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_find_wdata_outstanding_for_wid_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_find_wdata_outstanding_for_wid_from_CY_index1;

    import "DPI-C" context function void axi_set_change_in_wdata_outstanding_per_id_from_SystemVerilog
    (
        input bit change_in_wdata_outstanding_per_id_param
    );
    import "DPI-C" context function void axi_propagate_change_in_wdata_outstanding_per_id_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_change_in_wdata_outstanding_per_id_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_change_in_wdata_outstanding_per_id_from_CY;

    import "DPI-C" context function void axi_set_start_finding_change_in_wdata_from_SystemVerilog
    (
        input bit start_finding_change_in_wdata_param
    );
    import "DPI-C" context function void axi_propagate_start_finding_change_in_wdata_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_start_finding_change_in_wdata_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_start_finding_change_in_wdata_from_CY;

    import "DPI-C" context function void axi_set_find_change_in_wdata_outstanding_for_wid_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input bit  find_change_in_wdata_outstanding_for_wid_param
    );
    import "DPI-C" context function void axi_propagate_find_change_in_wdata_outstanding_for_wid_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_find_change_in_wdata_outstanding_for_wid_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_find_change_in_wdata_outstanding_for_wid_from_CY_index1;

    import "DPI-C" context function void axi_set_config_max_outstanding_wr_from_SystemVerilog
    (
        input int config_max_outstanding_wr_param
    );
    import "DPI-C" context function void axi_propagate_config_max_outstanding_wr_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_max_outstanding_wr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_outstanding_wr_from_CY;

    import "DPI-C" context function void axi_set_config_max_outstanding_rd_from_SystemVerilog
    (
        input int config_max_outstanding_rd_param
    );
    import "DPI-C" context function void axi_propagate_config_max_outstanding_rd_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_max_outstanding_rd_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_outstanding_rd_from_CY;

    import "DPI-C" context function void axi_set_config_error_on_deleted_valid_cycles_from_SystemVerilog
    (
        input bit config_error_on_deleted_valid_cycles_param
    );
    import "DPI-C" context function void axi_propagate_config_error_on_deleted_valid_cycles_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_error_on_deleted_valid_cycles_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_error_on_deleted_valid_cycles_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_from_SystemVerilog
    (
        input bit config_stats_enable_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_AXI_read_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_AXI_read_occupancy_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_AXI_read_occupancy_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_AXI_read_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_AXI_read_occupancy_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_AXI_write_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_AXI_write_occupancy_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_AXI_write_occupancy_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_AXI_write_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_AXI_write_occupancy_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_read_data_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_read_data_occupancy_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_read_data_occupancy_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_read_data_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_read_data_occupancy_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_write_data_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_write_data_occupancy_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_write_data_occupancy_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_write_data_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_write_data_occupancy_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_read_latency_from_SystemVerilog
    (
        input bit config_stats_enable_read_latency_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_read_latency_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_read_latency_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_read_latency_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_write_latency_from_SystemVerilog
    (
        input bit config_stats_enable_write_latency_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_write_latency_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_write_latency_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_write_latency_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_read_address_waits_from_SystemVerilog
    (
        input bit config_stats_enable_read_address_waits_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_read_address_waits_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_read_address_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_read_address_waits_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_read_data_waits_from_SystemVerilog
    (
        input bit config_stats_enable_read_data_waits_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_read_data_waits_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_read_data_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_read_data_waits_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_write_address_waits_from_SystemVerilog
    (
        input bit config_stats_enable_write_address_waits_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_write_address_waits_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_write_address_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_write_address_waits_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_write_data_waits_from_SystemVerilog
    (
        input bit config_stats_enable_write_data_waits_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_write_data_waits_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_write_data_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_write_data_waits_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_write_response_waits_from_SystemVerilog
    (
        input bit config_stats_enable_write_response_waits_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_write_response_waits_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_write_response_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_write_response_waits_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_read_bandwidth_from_SystemVerilog
    (
        input bit config_stats_enable_read_bandwidth_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_read_bandwidth_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_read_bandwidth_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_read_bandwidth_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_write_bandwidth_from_SystemVerilog
    (
        input bit config_stats_enable_write_bandwidth_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_write_bandwidth_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_write_bandwidth_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_write_bandwidth_from_CY;

    import "DPI-C" context function void axi_set_config_stats_AXI_read_occupancy_step_from_SystemVerilog
    (
        input int config_stats_AXI_read_occupancy_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_AXI_read_occupancy_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_AXI_read_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_AXI_read_occupancy_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_AXI_read_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_AXI_read_occupancy_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_AXI_read_occupancy_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_AXI_read_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_AXI_read_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_active_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_active_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_occupancy_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_occupancy_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_occupancy_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_idle_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_occupancy_min_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_idle_min_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_occupancy_max_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_idle_max_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_occupancy_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_idle_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_AXI_write_occupancy_step_from_SystemVerilog
    (
        input int config_stats_AXI_write_occupancy_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_AXI_write_occupancy_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_AXI_write_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_AXI_write_occupancy_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_AXI_write_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_AXI_write_occupancy_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_AXI_write_occupancy_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_AXI_write_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_AXI_write_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_active_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_active_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_occupancy_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_occupancy_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_occupancy_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_idle_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_occupancy_min_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_idle_min_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_occupancy_max_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_idle_max_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_occupancy_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_idle_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_data_occupancy_step_from_SystemVerilog
    (
        input int config_stats_read_data_occupancy_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_read_data_occupancy_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_read_data_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_data_occupancy_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_read_data_occupancy_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_read_data_occupancy_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_read_data_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_data_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_occupancy_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_occupancy_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_occupancy_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_idle_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_occupancy_min_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_idle_min_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_occupancy_max_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_idle_max_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_occupancy_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_idle_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_data_occupancy_step_from_SystemVerilog
    (
        input int config_stats_write_data_occupancy_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_data_occupancy_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_data_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_data_occupancy_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_write_data_occupancy_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_data_occupancy_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_data_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_data_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_occupancy_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_occupancy_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_occupancy_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_idle_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_occupancy_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_idle_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_occupancy_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_idle_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_occupancy_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_idle_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_bandwidth_step_from_SystemVerilog
    (
        input int config_stats_read_bandwidth_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_read_bandwidth_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_read_bandwidth_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_bandwidth_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_bandwidth_multiple_from_SystemVerilog
    (
        input int config_stats_read_bandwidth_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_read_bandwidth_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_read_bandwidth_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_bandwidth_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_read_bandwidth_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_bandwidth_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_read_bandwidth_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_bandwidth_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_read_bandwidth_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_bandwidth_min_from_CY;

    import "DPI-C" context function void axi_get_stats_read_bandwidth_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_bandwidth_max_from_CY;

    import "DPI-C" context function void axi_get_stats_read_bandwidth_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_bandwidth_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_bandwidth_step_from_SystemVerilog
    (
        input int config_stats_write_bandwidth_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_bandwidth_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_bandwidth_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_bandwidth_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_bandwidth_multiple_from_SystemVerilog
    (
        input int config_stats_write_bandwidth_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_bandwidth_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_bandwidth_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_bandwidth_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_write_bandwidth_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_bandwidth_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_bandwidth_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_bandwidth_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_write_bandwidth_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_bandwidth_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_bandwidth_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_bandwidth_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_bandwidth_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_bandwidth_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_latency_step_from_SystemVerilog
    (
        input int config_stats_read_latency_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_read_latency_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_read_latency_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_latency_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_latency_multiple_from_SystemVerilog
    (
        input int config_stats_read_latency_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_read_latency_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_read_latency_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_latency_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_read_latency_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_latency_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_data_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_data_latency_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_data_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_data_latency_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_data_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_data_latency_min_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_data_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_data_latency_max_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_data_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_data_latency_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_address_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_address_latency_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_address_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_address_latency_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_address_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_address_latency_min_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_address_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_address_latency_max_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_address_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_address_latency_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_latency_step_from_SystemVerilog
    (
        input int config_stats_write_latency_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_latency_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_latency_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_latency_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_latency_multiple_from_SystemVerilog
    (
        input int config_stats_write_latency_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_latency_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_latency_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_latency_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_write_latency_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_latency_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_data_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_data_latency_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_data_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_data_latency_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_data_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_data_latency_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_data_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_data_latency_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_data_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_data_latency_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_response_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_response_latency_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_response_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_response_latency_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_response_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_response_latency_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_response_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_response_latency_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_response_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_response_latency_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_address_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_address_latency_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_address_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_address_latency_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_address_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_address_latency_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_address_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_address_latency_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_address_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_address_latency_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_address_waits_step_from_SystemVerilog
    (
        input int config_stats_read_address_waits_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_read_address_waits_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_read_address_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_address_waits_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_address_waits_multiple_from_SystemVerilog
    (
        input int config_stats_read_address_waits_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_read_address_waits_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_read_address_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_address_waits_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_waits_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_waits_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_waits_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_waits_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_waits_min_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_waits_max_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_waits_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_data_waits_step_from_SystemVerilog
    (
        input int config_stats_read_data_waits_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_read_data_waits_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_read_data_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_data_waits_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_data_waits_multiple_from_SystemVerilog
    (
        input int config_stats_read_data_waits_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_read_data_waits_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_read_data_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_data_waits_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_waits_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_waits_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_waits_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_waits_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_waits_min_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_waits_max_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_waits_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_address_waits_step_from_SystemVerilog
    (
        input int config_stats_write_address_waits_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_address_waits_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_address_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_address_waits_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_address_waits_multiple_from_SystemVerilog
    (
        input int config_stats_write_address_waits_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_address_waits_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_address_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_address_waits_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_waits_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_waits_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_waits_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_waits_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_waits_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_waits_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_waits_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_data_waits_step_from_SystemVerilog
    (
        input int config_stats_write_data_waits_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_data_waits_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_data_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_data_waits_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_data_waits_multiple_from_SystemVerilog
    (
        input int config_stats_write_data_waits_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_data_waits_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_data_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_data_waits_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_waits_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_waits_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_waits_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_waits_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_waits_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_waits_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_waits_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_response_waits_step_from_SystemVerilog
    (
        input int config_stats_write_response_waits_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_response_waits_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_response_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_response_waits_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_response_waits_multiple_from_SystemVerilog
    (
        input int config_stats_write_response_waits_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_response_waits_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_response_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_response_waits_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_write_response_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_response_waits_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_write_response_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_response_waits_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_response_waits_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_response_waits_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_write_response_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_response_waits_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_response_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_response_waits_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_response_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_response_waits_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_rw_transaction_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_rw_transaction_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_read_addr_channel_phase_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_addr_channel_phase_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_burst_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_burst_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_read_channel_phase_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_channel_phase_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_write_addr_channel_phase_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_addr_channel_phase_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_burst_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_burst_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_write_channel_phase_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_channel_phase_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_write_resp_channel_phase_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_resp_channel_phase_last_duration_from_CY;

    function void axi_set_ACLK_from_CY( bit ACLK_param );
        internal_ACLK = ACLK_param;
    endfunction

    function void axi_initialise_ACLK_from_CY();
        internal_ACLK = 'z;
        m_ACLK = 'z;
    endfunction

    function void axi_set_ARESETn_from_CY( logic ARESETn_param );
        internal_ARESETn = ARESETn_param;
    endfunction

    function void axi_initialise_ARESETn_from_CY();
        internal_ARESETn = 'z;
        m_ARESETn = 'z;
    endfunction

    function void axi_set_AWVALID_from_CY( logic AWVALID_param );
        internal_AWVALID = AWVALID_param;
    endfunction

    function void axi_initialise_AWVALID_from_CY();
        internal_AWVALID = 'z;
        m_AWVALID = 'z;
    endfunction

    function void axi_set_AWADDR_from_CY_index1( int _this_dot_1, logic  AWADDR_param );
        internal_AWADDR[_this_dot_1] = AWADDR_param;
    endfunction

    function void axi_initialise_AWADDR_from_CY();
        internal_AWADDR = 'z;
        m_AWADDR = 'z;
    endfunction

    function void axi_set_AWLEN_from_CY( logic [3:0] AWLEN_param );
        internal_AWLEN = AWLEN_param;
    endfunction

    function void axi_initialise_AWLEN_from_CY();
        internal_AWLEN = 'z;
        m_AWLEN = 'z;
    endfunction

    function void axi_set_AWSIZE_from_CY( logic [2:0] AWSIZE_param );
        internal_AWSIZE = AWSIZE_param;
    endfunction

    function void axi_initialise_AWSIZE_from_CY();
        internal_AWSIZE = 'z;
        m_AWSIZE = 'z;
    endfunction

    function void axi_set_AWBURST_from_CY( logic [1:0] AWBURST_param );
        internal_AWBURST = AWBURST_param;
    endfunction

    function void axi_initialise_AWBURST_from_CY();
        internal_AWBURST = 'z;
        m_AWBURST = 'z;
    endfunction

    function void axi_set_AWLOCK_from_CY( logic [1:0] AWLOCK_param );
        internal_AWLOCK = AWLOCK_param;
    endfunction

    function void axi_initialise_AWLOCK_from_CY();
        internal_AWLOCK = 'z;
        m_AWLOCK = 'z;
    endfunction

    function void axi_set_AWCACHE_from_CY( logic [3:0] AWCACHE_param );
        internal_AWCACHE = AWCACHE_param;
    endfunction

    function void axi_initialise_AWCACHE_from_CY();
        internal_AWCACHE = 'z;
        m_AWCACHE = 'z;
    endfunction

    function void axi_set_AWPROT_from_CY( logic [2:0] AWPROT_param );
        internal_AWPROT = AWPROT_param;
    endfunction

    function void axi_initialise_AWPROT_from_CY();
        internal_AWPROT = 'z;
        m_AWPROT = 'z;
    endfunction

    function void axi_set_AWID_from_CY_index1( int _this_dot_1, logic  AWID_param );
        internal_AWID[_this_dot_1] = AWID_param;
    endfunction

    function void axi_initialise_AWID_from_CY();
        internal_AWID = 'z;
        m_AWID = 'z;
    endfunction

    function void axi_set_AWREADY_from_CY( logic AWREADY_param );
        internal_AWREADY = AWREADY_param;
    endfunction

    function void axi_initialise_AWREADY_from_CY();
        internal_AWREADY = 'z;
        m_AWREADY = 'z;
    endfunction

    function void axi_set_AWUSER_from_CY( logic [7:0] AWUSER_param );
        internal_AWUSER = AWUSER_param;
    endfunction

    function void axi_initialise_AWUSER_from_CY();
        internal_AWUSER = 'z;
        m_AWUSER = 'z;
    endfunction

    function void axi_set_ARVALID_from_CY( logic ARVALID_param );
        internal_ARVALID = ARVALID_param;
    endfunction

    function void axi_initialise_ARVALID_from_CY();
        internal_ARVALID = 'z;
        m_ARVALID = 'z;
    endfunction

    function void axi_set_ARADDR_from_CY_index1( int _this_dot_1, logic  ARADDR_param );
        internal_ARADDR[_this_dot_1] = ARADDR_param;
    endfunction

    function void axi_initialise_ARADDR_from_CY();
        internal_ARADDR = 'z;
        m_ARADDR = 'z;
    endfunction

    function void axi_set_ARLEN_from_CY( logic [3:0] ARLEN_param );
        internal_ARLEN = ARLEN_param;
    endfunction

    function void axi_initialise_ARLEN_from_CY();
        internal_ARLEN = 'z;
        m_ARLEN = 'z;
    endfunction

    function void axi_set_ARSIZE_from_CY( logic [2:0] ARSIZE_param );
        internal_ARSIZE = ARSIZE_param;
    endfunction

    function void axi_initialise_ARSIZE_from_CY();
        internal_ARSIZE = 'z;
        m_ARSIZE = 'z;
    endfunction

    function void axi_set_ARBURST_from_CY( logic [1:0] ARBURST_param );
        internal_ARBURST = ARBURST_param;
    endfunction

    function void axi_initialise_ARBURST_from_CY();
        internal_ARBURST = 'z;
        m_ARBURST = 'z;
    endfunction

    function void axi_set_ARLOCK_from_CY( logic [1:0] ARLOCK_param );
        internal_ARLOCK = ARLOCK_param;
    endfunction

    function void axi_initialise_ARLOCK_from_CY();
        internal_ARLOCK = 'z;
        m_ARLOCK = 'z;
    endfunction

    function void axi_set_ARCACHE_from_CY( logic [3:0] ARCACHE_param );
        internal_ARCACHE = ARCACHE_param;
    endfunction

    function void axi_initialise_ARCACHE_from_CY();
        internal_ARCACHE = 'z;
        m_ARCACHE = 'z;
    endfunction

    function void axi_set_ARPROT_from_CY( logic [2:0] ARPROT_param );
        internal_ARPROT = ARPROT_param;
    endfunction

    function void axi_initialise_ARPROT_from_CY();
        internal_ARPROT = 'z;
        m_ARPROT = 'z;
    endfunction

    function void axi_set_ARID_from_CY_index1( int _this_dot_1, logic  ARID_param );
        internal_ARID[_this_dot_1] = ARID_param;
    endfunction

    function void axi_initialise_ARID_from_CY();
        internal_ARID = 'z;
        m_ARID = 'z;
    endfunction

    function void axi_set_ARREADY_from_CY( logic ARREADY_param );
        internal_ARREADY = ARREADY_param;
    endfunction

    function void axi_initialise_ARREADY_from_CY();
        internal_ARREADY = 'z;
        m_ARREADY = 'z;
    endfunction

    function void axi_set_ARUSER_from_CY( logic [7:0] ARUSER_param );
        internal_ARUSER = ARUSER_param;
    endfunction

    function void axi_initialise_ARUSER_from_CY();
        internal_ARUSER = 'z;
        m_ARUSER = 'z;
    endfunction

    function void axi_set_RVALID_from_CY( logic RVALID_param );
        internal_RVALID = RVALID_param;
    endfunction

    function void axi_initialise_RVALID_from_CY();
        internal_RVALID = 'z;
        m_RVALID = 'z;
    endfunction

    function void axi_set_RLAST_from_CY( logic RLAST_param );
        internal_RLAST = RLAST_param;
    endfunction

    function void axi_initialise_RLAST_from_CY();
        internal_RLAST = 'z;
        m_RLAST = 'z;
    endfunction

    function void axi_set_RDATA_from_CY_index1( int _this_dot_1, logic  RDATA_param );
        internal_RDATA[_this_dot_1] = RDATA_param;
    endfunction

    function void axi_initialise_RDATA_from_CY();
        internal_RDATA = 'z;
        m_RDATA = 'z;
    endfunction

    function void axi_set_RRESP_from_CY( logic [1:0] RRESP_param );
        internal_RRESP = RRESP_param;
    endfunction

    function void axi_initialise_RRESP_from_CY();
        internal_RRESP = 'z;
        m_RRESP = 'z;
    endfunction

    function void axi_set_RID_from_CY_index1( int _this_dot_1, logic  RID_param );
        internal_RID[_this_dot_1] = RID_param;
    endfunction

    function void axi_initialise_RID_from_CY();
        internal_RID = 'z;
        m_RID = 'z;
    endfunction

    function void axi_set_RREADY_from_CY( logic RREADY_param );
        internal_RREADY = RREADY_param;
    endfunction

    function void axi_initialise_RREADY_from_CY();
        internal_RREADY = 'z;
        m_RREADY = 'z;
    endfunction

    function void axi_set_RUSER_from_CY( logic [7:0] RUSER_param );
        internal_RUSER = RUSER_param;
    endfunction

    function void axi_initialise_RUSER_from_CY();
        internal_RUSER = 'z;
        m_RUSER = 'z;
    endfunction

    function void axi_set_WVALID_from_CY( logic WVALID_param );
        internal_WVALID = WVALID_param;
    endfunction

    function void axi_initialise_WVALID_from_CY();
        internal_WVALID = 'z;
        m_WVALID = 'z;
    endfunction

    function void axi_set_WLAST_from_CY( logic WLAST_param );
        internal_WLAST = WLAST_param;
    endfunction

    function void axi_initialise_WLAST_from_CY();
        internal_WLAST = 'z;
        m_WLAST = 'z;
    endfunction

    function void axi_set_WDATA_from_CY_index1( int _this_dot_1, logic  WDATA_param );
        internal_WDATA[_this_dot_1] = WDATA_param;
    endfunction

    function void axi_initialise_WDATA_from_CY();
        internal_WDATA = 'z;
        m_WDATA = 'z;
    endfunction

    function void axi_set_WSTRB_from_CY_index1( int _this_dot_1, logic  WSTRB_param );
        internal_WSTRB[_this_dot_1] = WSTRB_param;
    endfunction

    function void axi_initialise_WSTRB_from_CY();
        internal_WSTRB = 'z;
        m_WSTRB = 'z;
    endfunction

    function void axi_set_WID_from_CY_index1( int _this_dot_1, logic  WID_param );
        internal_WID[_this_dot_1] = WID_param;
    endfunction

    function void axi_initialise_WID_from_CY();
        internal_WID = 'z;
        m_WID = 'z;
    endfunction

    function void axi_set_WREADY_from_CY( logic WREADY_param );
        internal_WREADY = WREADY_param;
    endfunction

    function void axi_initialise_WREADY_from_CY();
        internal_WREADY = 'z;
        m_WREADY = 'z;
    endfunction

    function void axi_set_WUSER_from_CY( logic [7:0] WUSER_param );
        internal_WUSER = WUSER_param;
    endfunction

    function void axi_initialise_WUSER_from_CY();
        internal_WUSER = 'z;
        m_WUSER = 'z;
    endfunction

    function void axi_set_BVALID_from_CY( logic BVALID_param );
        internal_BVALID = BVALID_param;
    endfunction

    function void axi_initialise_BVALID_from_CY();
        internal_BVALID = 'z;
        m_BVALID = 'z;
    endfunction

    function void axi_set_BRESP_from_CY( logic [1:0] BRESP_param );
        internal_BRESP = BRESP_param;
    endfunction

    function void axi_initialise_BRESP_from_CY();
        internal_BRESP = 'z;
        m_BRESP = 'z;
    endfunction

    function void axi_set_BID_from_CY_index1( int _this_dot_1, logic  BID_param );
        internal_BID[_this_dot_1] = BID_param;
    endfunction

    function void axi_initialise_BID_from_CY();
        internal_BID = 'z;
        m_BID = 'z;
    endfunction

    function void axi_set_BREADY_from_CY( logic BREADY_param );
        internal_BREADY = BREADY_param;
    endfunction

    function void axi_initialise_BREADY_from_CY();
        internal_BREADY = 'z;
        m_BREADY = 'z;
    endfunction

    function void axi_set_BUSER_from_CY( logic [7:0] BUSER_param );
        internal_BUSER = BUSER_param;
    endfunction

    function void axi_initialise_BUSER_from_CY();
        internal_BUSER = 'z;
        m_BUSER = 'z;
    endfunction

    function void axi_set_config_clk_init_value_from_CY( bit config_clk_init_value_param );
        config_clk_init_value = config_clk_init_value_param;
    endfunction

    function void axi_set_config_clk_phase_shift_from_CY( int config_clk_phase_shift_param );
        config_clk_phase_shift = config_clk_phase_shift_param;
    endfunction

    function void axi_set_config_clk_1st_time_from_CY( int config_clk_1st_time_param );
        config_clk_1st_time = config_clk_1st_time_param;
    endfunction

    function void axi_set_config_clk_2nd_time_from_CY( int config_clk_2nd_time_param );
        config_clk_2nd_time = config_clk_2nd_time_param;
    endfunction

    function void axi_set_config_setup_time_from_CY( int config_setup_time_param );
        config_setup_time = config_setup_time_param;
    endfunction

    function void axi_set_config_hold_time_from_CY( int config_hold_time_param );
        config_hold_time = config_hold_time_param;
    endfunction

    function void axi_set_config_max_transaction_time_factor_from_CY( int unsigned config_max_transaction_time_factor_param );
        config_max_transaction_time_factor = config_max_transaction_time_factor_param;
    endfunction

    function void axi_set_config_timeout_max_data_transfer_from_CY( int config_timeout_max_data_transfer_param );
        config_timeout_max_data_transfer = config_timeout_max_data_transfer_param;
    endfunction

    function void axi_set_config_burst_timeout_factor_from_CY( int unsigned config_burst_timeout_factor_param );
        config_burst_timeout_factor = config_burst_timeout_factor_param;
    endfunction

    function void axi_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_CY( int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
        config_max_latency_AWVALID_assertion_to_AWREADY = config_max_latency_AWVALID_assertion_to_AWREADY_param;
    endfunction

    function void axi_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_CY( int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
        config_max_latency_ARVALID_assertion_to_ARREADY = config_max_latency_ARVALID_assertion_to_ARREADY_param;
    endfunction

    function void axi_set_config_max_latency_RVALID_assertion_to_RREADY_from_CY( int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
        config_max_latency_RVALID_assertion_to_RREADY = config_max_latency_RVALID_assertion_to_RREADY_param;
    endfunction

    function void axi_set_config_max_latency_BVALID_assertion_to_BREADY_from_CY( int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
        config_max_latency_BVALID_assertion_to_BREADY = config_max_latency_BVALID_assertion_to_BREADY_param;
    endfunction

    function void axi_set_config_max_latency_WVALID_assertion_to_WREADY_from_CY( int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
        config_max_latency_WVALID_assertion_to_WREADY = config_max_latency_WVALID_assertion_to_WREADY_param;
    endfunction

    function void axi_set_config_write_ctrl_first_ratio_from_CY( int config_write_ctrl_first_ratio_param );
        config_write_ctrl_first_ratio = config_write_ctrl_first_ratio_param;
    endfunction

    function void axi_set_config_write_data_first_ratio_from_CY( int config_write_data_first_ratio_param );
        config_write_data_first_ratio = config_write_data_first_ratio_param;
    endfunction

    function void axi_set_config_write_ctrl_to_data_mintime_from_CY( int unsigned config_write_ctrl_to_data_mintime_param );
        config_write_ctrl_to_data_mintime = config_write_ctrl_to_data_mintime_param;
    endfunction

    function void axi_set_config_write_data_to_ctrl_mintime_from_CY( int unsigned config_write_data_to_ctrl_mintime_param );
        config_write_data_to_ctrl_mintime = config_write_data_to_ctrl_mintime_param;
    endfunction

    function void axi_set_config_master_write_delay_from_CY( bit config_master_write_delay_param );
        config_master_write_delay = config_master_write_delay_param;
    endfunction

    function void axi_set_config_reset_low_clocks_from_CY( int config_reset_low_clocks_param );
        config_reset_low_clocks = config_reset_low_clocks_param;
    endfunction

    function void axi_set_config_reset_hold_time_from_CY( int config_reset_hold_time_param );
        config_reset_hold_time = config_reset_hold_time_param;
    endfunction

    function void axi_set_config_protect_ready_from_CY( bit config_protect_ready_param );
        config_protect_ready = config_protect_ready_param;
    endfunction

    function void axi_set_config_enable_user_sideband_from_CY( bit config_enable_user_sideband_param );
        config_enable_user_sideband = config_enable_user_sideband_param;
    endfunction

    function void axi_set_config_extended_length_enable_from_CY( bit config_extended_length_enable_param );
        config_extended_length_enable = config_extended_length_enable_param;
    endfunction

    function void axi_set_config_enable_burst_reserved_value_from_CY( bit config_enable_burst_reserved_value_param );
        config_enable_burst_reserved_value = config_enable_burst_reserved_value_param;
    endfunction

    function void axi_set_config_enable_lock_reserved_value_from_CY( bit config_enable_lock_reserved_value_param );
        config_enable_lock_reserved_value = config_enable_lock_reserved_value_param;
    endfunction

    function void axi_set_config_enable_cache_reserved_value_from_CY( bit config_enable_cache_reserved_value_param );
        config_enable_cache_reserved_value = config_enable_cache_reserved_value_param;
    endfunction

    function void axi_set_config_enable_all_assertions_from_CY( bit config_enable_all_assertions_param );
        config_enable_all_assertions = config_enable_all_assertions_param;
    endfunction

    function void axi_set_config_enable_assertion_from_CY( bit [255:0] config_enable_assertion_param );
        config_enable_assertion = config_enable_assertion_param;
    endfunction

    function void axi_set_config_enable_error_from_CY( bit [255:0] config_enable_error_param );
        config_enable_error = config_enable_error_param;
    endfunction

    function void axi_set_config_enable_errors_from_CY( bit config_enable_errors_param );
        config_enable_errors = config_enable_errors_param;
    endfunction

    function void axi_set_config_enable_all_assertion_errors_from_CY( bit config_enable_all_assertion_errors_param );
        config_enable_all_assertion_errors = config_enable_all_assertion_errors_param;
    endfunction

    function void axi_set_config_abstraction_level_from_CY(     int config_abstraction_level_param);
        config_abstraction_level = axi_abstraction_level_e'( config_abstraction_level_param );
    endfunction

    function void axi_set_config_slave_start_addr_from_CY_index1( int _this_dot_1, bit  config_slave_start_addr_param );
        config_slave_start_addr[_this_dot_1] = config_slave_start_addr_param;
    endfunction

    function void axi_set_config_slave_end_addr_from_CY_index1( int _this_dot_1, bit  config_slave_end_addr_param );
        config_slave_end_addr[_this_dot_1] = config_slave_end_addr_param;
    endfunction

    function void axi_set_config_enable_slave_addr_range_in_bfm_from_CY( bit config_enable_slave_addr_range_in_bfm_param );
        config_enable_slave_addr_range_in_bfm = config_enable_slave_addr_range_in_bfm_param;
    endfunction

    function void axi_set_config_read_data_reordering_depth_from_CY( int unsigned config_read_data_reordering_depth_param );
        config_read_data_reordering_depth = config_read_data_reordering_depth_param;
    endfunction

    function void axi_set_config_enable_read_data_reordering_depth_in_bfm_from_CY( bit config_enable_read_data_reordering_depth_in_bfm_param );
        config_enable_read_data_reordering_depth_in_bfm = config_enable_read_data_reordering_depth_in_bfm_param;
    endfunction

    function void axi_set_config_awid_wid_mismatch_from_CY( bit config_awid_wid_mismatch_param );
        config_awid_wid_mismatch = config_awid_wid_mismatch_param;
    endfunction

    function void axi_set_config_length_last_mismatch_error_from_CY( bit config_length_last_mismatch_error_param );
        config_length_last_mismatch_error = config_length_last_mismatch_error_param;
    endfunction

    function void axi_set_config_master_error_position_from_CY(     int config_master_error_position_param);
        config_master_error_position = axi_error_e'( config_master_error_position_param );
    endfunction

    function void axi_set_dummy_var_from_CY(     int dummy_var_param);
        dummy_var = axi_assertion_type_e'( dummy_var_param );
    endfunction

    function void axi_set_config_wlast_length_from_CY( int config_wlast_length_param );
        config_wlast_length = config_wlast_length_param;
    endfunction

    function void axi_set_config_wid_for_awid_not_matching_from_CY_index1( int _this_dot_1, bit  config_wid_for_awid_not_matching_param );
        config_wid_for_awid_not_matching[_this_dot_1] = config_wid_for_awid_not_matching_param;
    endfunction

    function void axi_set_config_support_exclusive_access_from_CY( bit config_support_exclusive_access_param );
        config_support_exclusive_access = config_support_exclusive_access_param;
    endfunction

    function void axi_set_config_write_data_interleaving_depth_from_CY( int config_write_data_interleaving_depth_param );
        config_write_data_interleaving_depth = config_write_data_interleaving_depth_param;
    endfunction

    function void axi_set_status_master_error_from_CY( bit [15:0] status_master_error_param );
        status_master_error = status_master_error_param;
    endfunction

    function void axi_set_status_num_reads_waiting_for_resp_from_CY( int status_num_reads_waiting_for_resp_param );
        status_num_reads_waiting_for_resp = status_num_reads_waiting_for_resp_param;
    endfunction

    function void axi_set_status_num_writes_waiting_for_response_from_CY( int status_num_writes_waiting_for_response_param );
        status_num_writes_waiting_for_response = status_num_writes_waiting_for_response_param;
    endfunction

    function void axi_set_check_total_num_wdata_outstanding_from_CY( bit check_total_num_wdata_outstanding_param );
        check_total_num_wdata_outstanding = check_total_num_wdata_outstanding_param;
    endfunction

    function void axi_set_total_num_wdata_outstanding_from_CY( int total_num_wdata_outstanding_param );
        total_num_wdata_outstanding = total_num_wdata_outstanding_param;
    endfunction

    function void axi_set_check_max_num_wdata_outstanding_per_id_from_CY( bit check_max_num_wdata_outstanding_per_id_param );
        check_max_num_wdata_outstanding_per_id = check_max_num_wdata_outstanding_per_id_param;
    endfunction

    function void axi_set_max_num_wdata_outstanding_per_id_from_CY( int max_num_wdata_outstanding_per_id_param );
        max_num_wdata_outstanding_per_id = max_num_wdata_outstanding_per_id_param;
    endfunction

    function void axi_set_check_max_num_waddr_outstanding_per_id_from_CY( bit check_max_num_waddr_outstanding_per_id_param );
        check_max_num_waddr_outstanding_per_id = check_max_num_waddr_outstanding_per_id_param;
    endfunction

    function void axi_set_max_num_waddr_outstanding_per_id_from_CY( int max_num_waddr_outstanding_per_id_param );
        max_num_waddr_outstanding_per_id = max_num_waddr_outstanding_per_id_param;
    endfunction

    function void axi_set_check_total_num_waddr_outstanding_from_CY( bit check_total_num_waddr_outstanding_param );
        check_total_num_waddr_outstanding = check_total_num_waddr_outstanding_param;
    endfunction

    function void axi_set_total_num_waddr_outstanding_from_CY( int total_num_waddr_outstanding_param );
        total_num_waddr_outstanding = total_num_waddr_outstanding_param;
    endfunction

    function void axi_set_status_outstanding_num_for_waddr_from_CY( int status_outstanding_num_for_waddr_param );
        status_outstanding_num_for_waddr = status_outstanding_num_for_waddr_param;
    endfunction

    function void axi_set_start_finding_outstanding_waddr_from_CY( bit start_finding_outstanding_waddr_param );
        start_finding_outstanding_waddr = start_finding_outstanding_waddr_param;
    endfunction

    function void axi_set_status_outstanding_num_for_wdata_from_CY( int status_outstanding_num_for_wdata_param );
        status_outstanding_num_for_wdata = status_outstanding_num_for_wdata_param;
    endfunction

    function void axi_set_start_finding_outstanding_wdata_from_CY( bit start_finding_outstanding_wdata_param );
        start_finding_outstanding_wdata = start_finding_outstanding_wdata_param;
    endfunction

    function void axi_set_find_waddr_outstanding_for_wid_from_CY_index1( int _this_dot_1, bit  find_waddr_outstanding_for_wid_param );
        find_waddr_outstanding_for_wid[_this_dot_1] = find_waddr_outstanding_for_wid_param;
    endfunction

    function void axi_set_find_wdata_outstanding_for_wid_from_CY_index1( int _this_dot_1, bit  find_wdata_outstanding_for_wid_param );
        find_wdata_outstanding_for_wid[_this_dot_1] = find_wdata_outstanding_for_wid_param;
    endfunction

    function void axi_set_change_in_wdata_outstanding_per_id_from_CY( bit change_in_wdata_outstanding_per_id_param );
        change_in_wdata_outstanding_per_id = change_in_wdata_outstanding_per_id_param;
    endfunction

    function void axi_set_start_finding_change_in_wdata_from_CY( bit start_finding_change_in_wdata_param );
        start_finding_change_in_wdata = start_finding_change_in_wdata_param;
    endfunction

    function void axi_set_find_change_in_wdata_outstanding_for_wid_from_CY_index1( int _this_dot_1, bit  find_change_in_wdata_outstanding_for_wid_param );
        find_change_in_wdata_outstanding_for_wid[_this_dot_1] = find_change_in_wdata_outstanding_for_wid_param;
    endfunction

    function void axi_set_config_max_outstanding_wr_from_CY( int config_max_outstanding_wr_param );
        config_max_outstanding_wr = config_max_outstanding_wr_param;
    endfunction

    function void axi_set_config_max_outstanding_rd_from_CY( int config_max_outstanding_rd_param );
        config_max_outstanding_rd = config_max_outstanding_rd_param;
    endfunction

    function void axi_set_config_error_on_deleted_valid_cycles_from_CY( bit config_error_on_deleted_valid_cycles_param );
        config_error_on_deleted_valid_cycles = config_error_on_deleted_valid_cycles_param;
    endfunction

    function void axi_set_config_stats_enable_from_CY( bit config_stats_enable_param );
        config_stats_enable = config_stats_enable_param;
    endfunction

    function void axi_set_config_stats_enable_AXI_read_occupancy_from_CY( bit config_stats_enable_AXI_read_occupancy_param );
        config_stats_enable_AXI_read_occupancy = config_stats_enable_AXI_read_occupancy_param;
    endfunction

    function void axi_set_config_stats_enable_AXI_write_occupancy_from_CY( bit config_stats_enable_AXI_write_occupancy_param );
        config_stats_enable_AXI_write_occupancy = config_stats_enable_AXI_write_occupancy_param;
    endfunction

    function void axi_set_config_stats_enable_read_data_occupancy_from_CY( bit config_stats_enable_read_data_occupancy_param );
        config_stats_enable_read_data_occupancy = config_stats_enable_read_data_occupancy_param;
    endfunction

    function void axi_set_config_stats_enable_write_data_occupancy_from_CY( bit config_stats_enable_write_data_occupancy_param );
        config_stats_enable_write_data_occupancy = config_stats_enable_write_data_occupancy_param;
    endfunction

    function void axi_set_config_stats_enable_read_latency_from_CY( bit config_stats_enable_read_latency_param );
        config_stats_enable_read_latency = config_stats_enable_read_latency_param;
    endfunction

    function void axi_set_config_stats_enable_write_latency_from_CY( bit config_stats_enable_write_latency_param );
        config_stats_enable_write_latency = config_stats_enable_write_latency_param;
    endfunction

    function void axi_set_config_stats_enable_read_address_waits_from_CY( bit config_stats_enable_read_address_waits_param );
        config_stats_enable_read_address_waits = config_stats_enable_read_address_waits_param;
    endfunction

    function void axi_set_config_stats_enable_read_data_waits_from_CY( bit config_stats_enable_read_data_waits_param );
        config_stats_enable_read_data_waits = config_stats_enable_read_data_waits_param;
    endfunction

    function void axi_set_config_stats_enable_write_address_waits_from_CY( bit config_stats_enable_write_address_waits_param );
        config_stats_enable_write_address_waits = config_stats_enable_write_address_waits_param;
    endfunction

    function void axi_set_config_stats_enable_write_data_waits_from_CY( bit config_stats_enable_write_data_waits_param );
        config_stats_enable_write_data_waits = config_stats_enable_write_data_waits_param;
    endfunction

    function void axi_set_config_stats_enable_write_response_waits_from_CY( bit config_stats_enable_write_response_waits_param );
        config_stats_enable_write_response_waits = config_stats_enable_write_response_waits_param;
    endfunction

    function void axi_set_config_stats_enable_read_bandwidth_from_CY( bit config_stats_enable_read_bandwidth_param );
        config_stats_enable_read_bandwidth = config_stats_enable_read_bandwidth_param;
    endfunction

    function void axi_set_config_stats_enable_write_bandwidth_from_CY( bit config_stats_enable_write_bandwidth_param );
        config_stats_enable_write_bandwidth = config_stats_enable_write_bandwidth_param;
    endfunction

    function void axi_set_config_stats_AXI_read_occupancy_step_from_CY( int config_stats_AXI_read_occupancy_step_param );
        config_stats_AXI_read_occupancy_step = config_stats_AXI_read_occupancy_step_param;
    endfunction

    function void axi_set_config_stats_AXI_read_occupancy_multiple_from_CY( int config_stats_AXI_read_occupancy_multiple_param );
        config_stats_AXI_read_occupancy_multiple = config_stats_AXI_read_occupancy_multiple_param;
    endfunction

    function void axi_set_stats_AXI_read_active_from_CY( bit stats_AXI_read_active_param );
        stats_AXI_read_active = stats_AXI_read_active_param;
    endfunction

    function void axi_set_stats_AXI_read_occupancy_sw_from_CY( int stats_AXI_read_occupancy_sw_param );
        stats_AXI_read_occupancy_sw = stats_AXI_read_occupancy_sw_param;
    endfunction

    function void axi_set_stats_AXI_read_occupancy_sw_updated_from_CY( int stats_AXI_read_occupancy_sw_updated_param );
        stats_AXI_read_occupancy_sw_updated = stats_AXI_read_occupancy_sw_updated_param;
    endfunction

    function void axi_set_stats_AXI_read_idle_sw_from_CY( int stats_AXI_read_idle_sw_param );
        stats_AXI_read_idle_sw = stats_AXI_read_idle_sw_param;
    endfunction

    function void axi_set_stats_AXI_read_occupancy_min_from_CY( int stats_AXI_read_occupancy_min_param );
        stats_AXI_read_occupancy_min = stats_AXI_read_occupancy_min_param;
    endfunction

    function void axi_set_stats_AXI_read_idle_min_from_CY( int stats_AXI_read_idle_min_param );
        stats_AXI_read_idle_min = stats_AXI_read_idle_min_param;
    endfunction

    function void axi_set_stats_AXI_read_occupancy_max_from_CY( int stats_AXI_read_occupancy_max_param );
        stats_AXI_read_occupancy_max = stats_AXI_read_occupancy_max_param;
    endfunction

    function void axi_set_stats_AXI_read_idle_max_from_CY( int stats_AXI_read_idle_max_param );
        stats_AXI_read_idle_max = stats_AXI_read_idle_max_param;
    endfunction

    function void axi_set_stats_AXI_read_occupancy_mean_from_CY( int stats_AXI_read_occupancy_mean_param );
        stats_AXI_read_occupancy_mean = stats_AXI_read_occupancy_mean_param;
    endfunction

    function void axi_set_stats_AXI_read_idle_mean_from_CY( int stats_AXI_read_idle_mean_param );
        stats_AXI_read_idle_mean = stats_AXI_read_idle_mean_param;
    endfunction

    function void axi_set_config_stats_AXI_write_occupancy_step_from_CY( int config_stats_AXI_write_occupancy_step_param );
        config_stats_AXI_write_occupancy_step = config_stats_AXI_write_occupancy_step_param;
    endfunction

    function void axi_set_config_stats_AXI_write_occupancy_multiple_from_CY( int config_stats_AXI_write_occupancy_multiple_param );
        config_stats_AXI_write_occupancy_multiple = config_stats_AXI_write_occupancy_multiple_param;
    endfunction

    function void axi_set_stats_AXI_write_active_from_CY( bit stats_AXI_write_active_param );
        stats_AXI_write_active = stats_AXI_write_active_param;
    endfunction

    function void axi_set_stats_AXI_write_occupancy_sw_from_CY( int stats_AXI_write_occupancy_sw_param );
        stats_AXI_write_occupancy_sw = stats_AXI_write_occupancy_sw_param;
    endfunction

    function void axi_set_stats_AXI_write_occupancy_sw_updated_from_CY( int stats_AXI_write_occupancy_sw_updated_param );
        stats_AXI_write_occupancy_sw_updated = stats_AXI_write_occupancy_sw_updated_param;
    endfunction

    function void axi_set_stats_AXI_write_idle_sw_from_CY( int stats_AXI_write_idle_sw_param );
        stats_AXI_write_idle_sw = stats_AXI_write_idle_sw_param;
    endfunction

    function void axi_set_stats_AXI_write_occupancy_min_from_CY( int stats_AXI_write_occupancy_min_param );
        stats_AXI_write_occupancy_min = stats_AXI_write_occupancy_min_param;
    endfunction

    function void axi_set_stats_AXI_write_idle_min_from_CY( int stats_AXI_write_idle_min_param );
        stats_AXI_write_idle_min = stats_AXI_write_idle_min_param;
    endfunction

    function void axi_set_stats_AXI_write_occupancy_max_from_CY( int stats_AXI_write_occupancy_max_param );
        stats_AXI_write_occupancy_max = stats_AXI_write_occupancy_max_param;
    endfunction

    function void axi_set_stats_AXI_write_idle_max_from_CY( int stats_AXI_write_idle_max_param );
        stats_AXI_write_idle_max = stats_AXI_write_idle_max_param;
    endfunction

    function void axi_set_stats_AXI_write_occupancy_mean_from_CY( int stats_AXI_write_occupancy_mean_param );
        stats_AXI_write_occupancy_mean = stats_AXI_write_occupancy_mean_param;
    endfunction

    function void axi_set_stats_AXI_write_idle_mean_from_CY( int stats_AXI_write_idle_mean_param );
        stats_AXI_write_idle_mean = stats_AXI_write_idle_mean_param;
    endfunction

    function void axi_set_config_stats_read_data_occupancy_step_from_CY( int config_stats_read_data_occupancy_step_param );
        config_stats_read_data_occupancy_step = config_stats_read_data_occupancy_step_param;
    endfunction

    function void axi_set_config_stats_read_data_occupancy_multiple_from_CY( int config_stats_read_data_occupancy_multiple_param );
        config_stats_read_data_occupancy_multiple = config_stats_read_data_occupancy_multiple_param;
    endfunction

    function void axi_set_stats_read_data_occupancy_sw_from_CY( int stats_read_data_occupancy_sw_param );
        stats_read_data_occupancy_sw = stats_read_data_occupancy_sw_param;
    endfunction

    function void axi_set_stats_read_data_occupancy_sw_updated_from_CY( int stats_read_data_occupancy_sw_updated_param );
        stats_read_data_occupancy_sw_updated = stats_read_data_occupancy_sw_updated_param;
    endfunction

    function void axi_set_stats_read_data_idle_sw_from_CY( int stats_read_data_idle_sw_param );
        stats_read_data_idle_sw = stats_read_data_idle_sw_param;
    endfunction

    function void axi_set_stats_read_data_occupancy_min_from_CY( int stats_read_data_occupancy_min_param );
        stats_read_data_occupancy_min = stats_read_data_occupancy_min_param;
    endfunction

    function void axi_set_stats_read_data_idle_min_from_CY( int stats_read_data_idle_min_param );
        stats_read_data_idle_min = stats_read_data_idle_min_param;
    endfunction

    function void axi_set_stats_read_data_occupancy_max_from_CY( int stats_read_data_occupancy_max_param );
        stats_read_data_occupancy_max = stats_read_data_occupancy_max_param;
    endfunction

    function void axi_set_stats_read_data_idle_max_from_CY( int stats_read_data_idle_max_param );
        stats_read_data_idle_max = stats_read_data_idle_max_param;
    endfunction

    function void axi_set_stats_read_data_occupancy_mean_from_CY( int stats_read_data_occupancy_mean_param );
        stats_read_data_occupancy_mean = stats_read_data_occupancy_mean_param;
    endfunction

    function void axi_set_stats_read_data_idle_mean_from_CY( int stats_read_data_idle_mean_param );
        stats_read_data_idle_mean = stats_read_data_idle_mean_param;
    endfunction

    function void axi_set_config_stats_write_data_occupancy_step_from_CY( int config_stats_write_data_occupancy_step_param );
        config_stats_write_data_occupancy_step = config_stats_write_data_occupancy_step_param;
    endfunction

    function void axi_set_config_stats_write_data_occupancy_multiple_from_CY( int config_stats_write_data_occupancy_multiple_param );
        config_stats_write_data_occupancy_multiple = config_stats_write_data_occupancy_multiple_param;
    endfunction

    function void axi_set_stats_write_data_occupancy_sw_from_CY( int stats_write_data_occupancy_sw_param );
        stats_write_data_occupancy_sw = stats_write_data_occupancy_sw_param;
    endfunction

    function void axi_set_stats_write_data_occupancy_sw_updated_from_CY( int stats_write_data_occupancy_sw_updated_param );
        stats_write_data_occupancy_sw_updated = stats_write_data_occupancy_sw_updated_param;
    endfunction

    function void axi_set_stats_write_data_idle_sw_from_CY( int stats_write_data_idle_sw_param );
        stats_write_data_idle_sw = stats_write_data_idle_sw_param;
    endfunction

    function void axi_set_stats_write_data_occupancy_min_from_CY( int stats_write_data_occupancy_min_param );
        stats_write_data_occupancy_min = stats_write_data_occupancy_min_param;
    endfunction

    function void axi_set_stats_write_data_idle_min_from_CY( int stats_write_data_idle_min_param );
        stats_write_data_idle_min = stats_write_data_idle_min_param;
    endfunction

    function void axi_set_stats_write_data_occupancy_max_from_CY( int stats_write_data_occupancy_max_param );
        stats_write_data_occupancy_max = stats_write_data_occupancy_max_param;
    endfunction

    function void axi_set_stats_write_data_idle_max_from_CY( int stats_write_data_idle_max_param );
        stats_write_data_idle_max = stats_write_data_idle_max_param;
    endfunction

    function void axi_set_stats_write_data_occupancy_mean_from_CY( int stats_write_data_occupancy_mean_param );
        stats_write_data_occupancy_mean = stats_write_data_occupancy_mean_param;
    endfunction

    function void axi_set_stats_write_data_idle_mean_from_CY( int stats_write_data_idle_mean_param );
        stats_write_data_idle_mean = stats_write_data_idle_mean_param;
    endfunction

    function void axi_set_config_stats_read_bandwidth_step_from_CY( int config_stats_read_bandwidth_step_param );
        config_stats_read_bandwidth_step = config_stats_read_bandwidth_step_param;
    endfunction

    function void axi_set_config_stats_read_bandwidth_multiple_from_CY( int config_stats_read_bandwidth_multiple_param );
        config_stats_read_bandwidth_multiple = config_stats_read_bandwidth_multiple_param;
    endfunction

    function void axi_set_stats_read_bandwidth_sw_from_CY( int stats_read_bandwidth_sw_param );
        stats_read_bandwidth_sw = stats_read_bandwidth_sw_param;
    endfunction

    function void axi_set_stats_read_bandwidth_sw_updated_from_CY( int stats_read_bandwidth_sw_updated_param );
        stats_read_bandwidth_sw_updated = stats_read_bandwidth_sw_updated_param;
    endfunction

    function void axi_set_stats_read_bandwidth_min_from_CY( int stats_read_bandwidth_min_param );
        stats_read_bandwidth_min = stats_read_bandwidth_min_param;
    endfunction

    function void axi_set_stats_read_bandwidth_max_from_CY( int stats_read_bandwidth_max_param );
        stats_read_bandwidth_max = stats_read_bandwidth_max_param;
    endfunction

    function void axi_set_stats_read_bandwidth_mean_from_CY( int stats_read_bandwidth_mean_param );
        stats_read_bandwidth_mean = stats_read_bandwidth_mean_param;
    endfunction

    function void axi_set_config_stats_write_bandwidth_step_from_CY( int config_stats_write_bandwidth_step_param );
        config_stats_write_bandwidth_step = config_stats_write_bandwidth_step_param;
    endfunction

    function void axi_set_config_stats_write_bandwidth_multiple_from_CY( int config_stats_write_bandwidth_multiple_param );
        config_stats_write_bandwidth_multiple = config_stats_write_bandwidth_multiple_param;
    endfunction

    function void axi_set_stats_write_bandwidth_sw_from_CY( int stats_write_bandwidth_sw_param );
        stats_write_bandwidth_sw = stats_write_bandwidth_sw_param;
    endfunction

    function void axi_set_stats_write_bandwidth_sw_updated_from_CY( int stats_write_bandwidth_sw_updated_param );
        stats_write_bandwidth_sw_updated = stats_write_bandwidth_sw_updated_param;
    endfunction

    function void axi_set_stats_write_bandwidth_min_from_CY( int stats_write_bandwidth_min_param );
        stats_write_bandwidth_min = stats_write_bandwidth_min_param;
    endfunction

    function void axi_set_stats_write_bandwidth_max_from_CY( int stats_write_bandwidth_max_param );
        stats_write_bandwidth_max = stats_write_bandwidth_max_param;
    endfunction

    function void axi_set_stats_write_bandwidth_mean_from_CY( int stats_write_bandwidth_mean_param );
        stats_write_bandwidth_mean = stats_write_bandwidth_mean_param;
    endfunction

    function void axi_set_config_stats_read_latency_step_from_CY( int config_stats_read_latency_step_param );
        config_stats_read_latency_step = config_stats_read_latency_step_param;
    endfunction

    function void axi_set_config_stats_read_latency_multiple_from_CY( int config_stats_read_latency_multiple_param );
        config_stats_read_latency_multiple = config_stats_read_latency_multiple_param;
    endfunction

    function void axi_set_stats_read_latency_sw_updated_from_CY( int stats_read_latency_sw_updated_param );
        stats_read_latency_sw_updated = stats_read_latency_sw_updated_param;
    endfunction

    function void axi_set_stats_read_address_data_latency_inst_from_CY( int stats_read_address_data_latency_inst_param );
        stats_read_address_data_latency_inst = stats_read_address_data_latency_inst_param;
    endfunction

    function void axi_set_stats_read_address_data_latency_sw_from_CY( int stats_read_address_data_latency_sw_param );
        stats_read_address_data_latency_sw = stats_read_address_data_latency_sw_param;
    endfunction

    function void axi_set_stats_read_address_data_latency_min_from_CY( int stats_read_address_data_latency_min_param );
        stats_read_address_data_latency_min = stats_read_address_data_latency_min_param;
    endfunction

    function void axi_set_stats_read_address_data_latency_max_from_CY( int stats_read_address_data_latency_max_param );
        stats_read_address_data_latency_max = stats_read_address_data_latency_max_param;
    endfunction

    function void axi_set_stats_read_address_data_latency_mean_from_CY( int stats_read_address_data_latency_mean_param );
        stats_read_address_data_latency_mean = stats_read_address_data_latency_mean_param;
    endfunction

    function void axi_set_stats_read_address_address_latency_inst_from_CY( int stats_read_address_address_latency_inst_param );
        stats_read_address_address_latency_inst = stats_read_address_address_latency_inst_param;
    endfunction

    function void axi_set_stats_read_address_address_latency_sw_from_CY( int stats_read_address_address_latency_sw_param );
        stats_read_address_address_latency_sw = stats_read_address_address_latency_sw_param;
    endfunction

    function void axi_set_stats_read_address_address_latency_min_from_CY( int stats_read_address_address_latency_min_param );
        stats_read_address_address_latency_min = stats_read_address_address_latency_min_param;
    endfunction

    function void axi_set_stats_read_address_address_latency_max_from_CY( int stats_read_address_address_latency_max_param );
        stats_read_address_address_latency_max = stats_read_address_address_latency_max_param;
    endfunction

    function void axi_set_stats_read_address_address_latency_mean_from_CY( int stats_read_address_address_latency_mean_param );
        stats_read_address_address_latency_mean = stats_read_address_address_latency_mean_param;
    endfunction

    function void axi_set_config_stats_write_latency_step_from_CY( int config_stats_write_latency_step_param );
        config_stats_write_latency_step = config_stats_write_latency_step_param;
    endfunction

    function void axi_set_config_stats_write_latency_multiple_from_CY( int config_stats_write_latency_multiple_param );
        config_stats_write_latency_multiple = config_stats_write_latency_multiple_param;
    endfunction

    function void axi_set_stats_write_latency_sw_updated_from_CY( int stats_write_latency_sw_updated_param );
        stats_write_latency_sw_updated = stats_write_latency_sw_updated_param;
    endfunction

    function void axi_set_stats_write_address_data_latency_inst_from_CY( int stats_write_address_data_latency_inst_param );
        stats_write_address_data_latency_inst = stats_write_address_data_latency_inst_param;
    endfunction

    function void axi_set_stats_write_address_data_latency_sw_from_CY( int stats_write_address_data_latency_sw_param );
        stats_write_address_data_latency_sw = stats_write_address_data_latency_sw_param;
    endfunction

    function void axi_set_stats_write_address_data_latency_min_from_CY( int stats_write_address_data_latency_min_param );
        stats_write_address_data_latency_min = stats_write_address_data_latency_min_param;
    endfunction

    function void axi_set_stats_write_address_data_latency_max_from_CY( int stats_write_address_data_latency_max_param );
        stats_write_address_data_latency_max = stats_write_address_data_latency_max_param;
    endfunction

    function void axi_set_stats_write_address_data_latency_mean_from_CY( int stats_write_address_data_latency_mean_param );
        stats_write_address_data_latency_mean = stats_write_address_data_latency_mean_param;
    endfunction

    function void axi_set_stats_write_data_response_latency_inst_from_CY( int stats_write_data_response_latency_inst_param );
        stats_write_data_response_latency_inst = stats_write_data_response_latency_inst_param;
    endfunction

    function void axi_set_stats_write_data_response_latency_sw_from_CY( int stats_write_data_response_latency_sw_param );
        stats_write_data_response_latency_sw = stats_write_data_response_latency_sw_param;
    endfunction

    function void axi_set_stats_write_data_response_latency_min_from_CY( int stats_write_data_response_latency_min_param );
        stats_write_data_response_latency_min = stats_write_data_response_latency_min_param;
    endfunction

    function void axi_set_stats_write_data_response_latency_max_from_CY( int stats_write_data_response_latency_max_param );
        stats_write_data_response_latency_max = stats_write_data_response_latency_max_param;
    endfunction

    function void axi_set_stats_write_data_response_latency_mean_from_CY( int stats_write_data_response_latency_mean_param );
        stats_write_data_response_latency_mean = stats_write_data_response_latency_mean_param;
    endfunction

    function void axi_set_stats_write_address_address_latency_inst_from_CY( int stats_write_address_address_latency_inst_param );
        stats_write_address_address_latency_inst = stats_write_address_address_latency_inst_param;
    endfunction

    function void axi_set_stats_write_address_address_latency_sw_from_CY( int stats_write_address_address_latency_sw_param );
        stats_write_address_address_latency_sw = stats_write_address_address_latency_sw_param;
    endfunction

    function void axi_set_stats_write_address_address_latency_min_from_CY( int stats_write_address_address_latency_min_param );
        stats_write_address_address_latency_min = stats_write_address_address_latency_min_param;
    endfunction

    function void axi_set_stats_write_address_address_latency_max_from_CY( int stats_write_address_address_latency_max_param );
        stats_write_address_address_latency_max = stats_write_address_address_latency_max_param;
    endfunction

    function void axi_set_stats_write_address_address_latency_mean_from_CY( int stats_write_address_address_latency_mean_param );
        stats_write_address_address_latency_mean = stats_write_address_address_latency_mean_param;
    endfunction

    function void axi_set_config_stats_read_address_waits_step_from_CY( int config_stats_read_address_waits_step_param );
        config_stats_read_address_waits_step = config_stats_read_address_waits_step_param;
    endfunction

    function void axi_set_config_stats_read_address_waits_multiple_from_CY( int config_stats_read_address_waits_multiple_param );
        config_stats_read_address_waits_multiple = config_stats_read_address_waits_multiple_param;
    endfunction

    function void axi_set_stats_read_address_waits_inst_from_CY( int stats_read_address_waits_inst_param );
        stats_read_address_waits_inst = stats_read_address_waits_inst_param;
    endfunction

    function void axi_set_stats_read_address_waits_sw_from_CY( int stats_read_address_waits_sw_param );
        stats_read_address_waits_sw = stats_read_address_waits_sw_param;
    endfunction

    function void axi_set_stats_read_address_waits_sw_updated_from_CY( int stats_read_address_waits_sw_updated_param );
        stats_read_address_waits_sw_updated = stats_read_address_waits_sw_updated_param;
    endfunction

    function void axi_set_stats_read_address_waits_min_from_CY( int stats_read_address_waits_min_param );
        stats_read_address_waits_min = stats_read_address_waits_min_param;
    endfunction

    function void axi_set_stats_read_address_waits_max_from_CY( int stats_read_address_waits_max_param );
        stats_read_address_waits_max = stats_read_address_waits_max_param;
    endfunction

    function void axi_set_stats_read_address_waits_mean_from_CY( int stats_read_address_waits_mean_param );
        stats_read_address_waits_mean = stats_read_address_waits_mean_param;
    endfunction

    function void axi_set_config_stats_read_data_waits_step_from_CY( int config_stats_read_data_waits_step_param );
        config_stats_read_data_waits_step = config_stats_read_data_waits_step_param;
    endfunction

    function void axi_set_config_stats_read_data_waits_multiple_from_CY( int config_stats_read_data_waits_multiple_param );
        config_stats_read_data_waits_multiple = config_stats_read_data_waits_multiple_param;
    endfunction

    function void axi_set_stats_read_data_waits_inst_from_CY( int stats_read_data_waits_inst_param );
        stats_read_data_waits_inst = stats_read_data_waits_inst_param;
    endfunction

    function void axi_set_stats_read_data_waits_sw_from_CY( int stats_read_data_waits_sw_param );
        stats_read_data_waits_sw = stats_read_data_waits_sw_param;
    endfunction

    function void axi_set_stats_read_data_waits_sw_updated_from_CY( int stats_read_data_waits_sw_updated_param );
        stats_read_data_waits_sw_updated = stats_read_data_waits_sw_updated_param;
    endfunction

    function void axi_set_stats_read_data_waits_min_from_CY( int stats_read_data_waits_min_param );
        stats_read_data_waits_min = stats_read_data_waits_min_param;
    endfunction

    function void axi_set_stats_read_data_waits_max_from_CY( int stats_read_data_waits_max_param );
        stats_read_data_waits_max = stats_read_data_waits_max_param;
    endfunction

    function void axi_set_stats_read_data_waits_mean_from_CY( int stats_read_data_waits_mean_param );
        stats_read_data_waits_mean = stats_read_data_waits_mean_param;
    endfunction

    function void axi_set_config_stats_write_address_waits_step_from_CY( int config_stats_write_address_waits_step_param );
        config_stats_write_address_waits_step = config_stats_write_address_waits_step_param;
    endfunction

    function void axi_set_config_stats_write_address_waits_multiple_from_CY( int config_stats_write_address_waits_multiple_param );
        config_stats_write_address_waits_multiple = config_stats_write_address_waits_multiple_param;
    endfunction

    function void axi_set_stats_write_address_waits_inst_from_CY( int stats_write_address_waits_inst_param );
        stats_write_address_waits_inst = stats_write_address_waits_inst_param;
    endfunction

    function void axi_set_stats_write_address_waits_sw_from_CY( int stats_write_address_waits_sw_param );
        stats_write_address_waits_sw = stats_write_address_waits_sw_param;
    endfunction

    function void axi_set_stats_write_address_waits_sw_updated_from_CY( int stats_write_address_waits_sw_updated_param );
        stats_write_address_waits_sw_updated = stats_write_address_waits_sw_updated_param;
    endfunction

    function void axi_set_stats_write_address_waits_min_from_CY( int stats_write_address_waits_min_param );
        stats_write_address_waits_min = stats_write_address_waits_min_param;
    endfunction

    function void axi_set_stats_write_address_waits_max_from_CY( int stats_write_address_waits_max_param );
        stats_write_address_waits_max = stats_write_address_waits_max_param;
    endfunction

    function void axi_set_stats_write_address_waits_mean_from_CY( int stats_write_address_waits_mean_param );
        stats_write_address_waits_mean = stats_write_address_waits_mean_param;
    endfunction

    function void axi_set_config_stats_write_data_waits_step_from_CY( int config_stats_write_data_waits_step_param );
        config_stats_write_data_waits_step = config_stats_write_data_waits_step_param;
    endfunction

    function void axi_set_config_stats_write_data_waits_multiple_from_CY( int config_stats_write_data_waits_multiple_param );
        config_stats_write_data_waits_multiple = config_stats_write_data_waits_multiple_param;
    endfunction

    function void axi_set_stats_write_data_waits_inst_from_CY( int stats_write_data_waits_inst_param );
        stats_write_data_waits_inst = stats_write_data_waits_inst_param;
    endfunction

    function void axi_set_stats_write_data_waits_sw_from_CY( int stats_write_data_waits_sw_param );
        stats_write_data_waits_sw = stats_write_data_waits_sw_param;
    endfunction

    function void axi_set_stats_write_data_waits_sw_updated_from_CY( int stats_write_data_waits_sw_updated_param );
        stats_write_data_waits_sw_updated = stats_write_data_waits_sw_updated_param;
    endfunction

    function void axi_set_stats_write_data_waits_min_from_CY( int stats_write_data_waits_min_param );
        stats_write_data_waits_min = stats_write_data_waits_min_param;
    endfunction

    function void axi_set_stats_write_data_waits_max_from_CY( int stats_write_data_waits_max_param );
        stats_write_data_waits_max = stats_write_data_waits_max_param;
    endfunction

    function void axi_set_stats_write_data_waits_mean_from_CY( int stats_write_data_waits_mean_param );
        stats_write_data_waits_mean = stats_write_data_waits_mean_param;
    endfunction

    function void axi_set_config_stats_write_response_waits_step_from_CY( int config_stats_write_response_waits_step_param );
        config_stats_write_response_waits_step = config_stats_write_response_waits_step_param;
    endfunction

    function void axi_set_config_stats_write_response_waits_multiple_from_CY( int config_stats_write_response_waits_multiple_param );
        config_stats_write_response_waits_multiple = config_stats_write_response_waits_multiple_param;
    endfunction

    function void axi_set_stats_write_response_waits_inst_from_CY( int stats_write_response_waits_inst_param );
        stats_write_response_waits_inst = stats_write_response_waits_inst_param;
    endfunction

    function void axi_set_stats_write_response_waits_sw_from_CY( int stats_write_response_waits_sw_param );
        stats_write_response_waits_sw = stats_write_response_waits_sw_param;
    endfunction

    function void axi_set_stats_write_response_waits_sw_updated_from_CY( int stats_write_response_waits_sw_updated_param );
        stats_write_response_waits_sw_updated = stats_write_response_waits_sw_updated_param;
    endfunction

    function void axi_set_stats_write_response_waits_min_from_CY( int stats_write_response_waits_min_param );
        stats_write_response_waits_min = stats_write_response_waits_min_param;
    endfunction

    function void axi_set_stats_write_response_waits_max_from_CY( int stats_write_response_waits_max_param );
        stats_write_response_waits_max = stats_write_response_waits_max_param;
    endfunction

    function void axi_set_stats_write_response_waits_mean_from_CY( int stats_write_response_waits_mean_param );
        stats_write_response_waits_mean = stats_write_response_waits_mean_param;
    endfunction

    function void axi_set_stats_rw_transaction_last_duration_from_CY( int stats_rw_transaction_last_duration_param );
        stats_rw_transaction_last_duration = stats_rw_transaction_last_duration_param;
    endfunction

    function void axi_set_stats_AXI_read_last_duration_from_CY( int stats_AXI_read_last_duration_param );
        stats_AXI_read_last_duration = stats_AXI_read_last_duration_param;
    endfunction

    function void axi_set_stats_AXI_write_last_duration_from_CY( int stats_AXI_write_last_duration_param );
        stats_AXI_write_last_duration = stats_AXI_write_last_duration_param;
    endfunction

    function void axi_set_stats_read_addr_channel_phase_last_duration_from_CY( int stats_read_addr_channel_phase_last_duration_param );
        stats_read_addr_channel_phase_last_duration = stats_read_addr_channel_phase_last_duration_param;
    endfunction

    function void axi_set_stats_read_data_burst_last_duration_from_CY( int stats_read_data_burst_last_duration_param );
        stats_read_data_burst_last_duration = stats_read_data_burst_last_duration_param;
    endfunction

    function void axi_set_stats_read_channel_phase_last_duration_from_CY( int stats_read_channel_phase_last_duration_param );
        stats_read_channel_phase_last_duration = stats_read_channel_phase_last_duration_param;
    endfunction

    function void axi_set_stats_write_addr_channel_phase_last_duration_from_CY( int stats_write_addr_channel_phase_last_duration_param );
        stats_write_addr_channel_phase_last_duration = stats_write_addr_channel_phase_last_duration_param;
    endfunction

    function void axi_set_stats_write_data_burst_last_duration_from_CY( int stats_write_data_burst_last_duration_param );
        stats_write_data_burst_last_duration = stats_write_data_burst_last_duration_param;
    endfunction

    function void axi_set_stats_write_channel_phase_last_duration_from_CY( int stats_write_channel_phase_last_duration_param );
        stats_write_channel_phase_last_duration = stats_write_channel_phase_last_duration_param;
    endfunction

    function void axi_set_stats_write_resp_channel_phase_last_duration_from_CY( int stats_write_resp_channel_phase_last_duration_param );
        stats_write_resp_channel_phase_last_duration = stats_write_resp_channel_phase_last_duration_param;
    endfunction

    //------------------------------------------------------------------------------
    // TLM Interface Support
    //------------------------------------------------------------------------------

    export "DPI-C" axi_get_temp_static_rw_transaction_addr = function axi_get_temp_static_rw_transaction_addr;
    export "DPI-C" axi_set_temp_static_rw_transaction_addr = function axi_set_temp_static_rw_transaction_addr;
    export "DPI-C" axi_get_temp_static_rw_transaction_id = function axi_get_temp_static_rw_transaction_id;
    export "DPI-C" axi_set_temp_static_rw_transaction_id = function axi_set_temp_static_rw_transaction_id;
    export "DPI-C" axi_get_temp_static_rw_transaction_data_words = function axi_get_temp_static_rw_transaction_data_words;
    export "DPI-C" axi_set_temp_static_rw_transaction_data_words = function axi_set_temp_static_rw_transaction_data_words;
    export "DPI-C" axi_get_temp_static_rw_transaction_write_strobes = function axi_get_temp_static_rw_transaction_write_strobes;
    export "DPI-C" axi_set_temp_static_rw_transaction_write_strobes = function axi_set_temp_static_rw_transaction_write_strobes;
    export "DPI-C" axi_get_temp_static_rw_transaction_resp = function axi_get_temp_static_rw_transaction_resp;
    export "DPI-C" axi_set_temp_static_rw_transaction_resp = function axi_set_temp_static_rw_transaction_resp;
    export "DPI-C" axi_get_temp_static_rw_transaction_data_user = function axi_get_temp_static_rw_transaction_data_user;
    export "DPI-C" axi_set_temp_static_rw_transaction_data_user = function axi_set_temp_static_rw_transaction_data_user;
    export "DPI-C" axi_get_temp_static_rw_transaction_write_data_beats_delay = function axi_get_temp_static_rw_transaction_write_data_beats_delay;
    export "DPI-C" axi_set_temp_static_rw_transaction_write_data_beats_delay = function axi_set_temp_static_rw_transaction_write_data_beats_delay;
    export "DPI-C" axi_get_temp_static_rw_transaction_data_valid_delay = function axi_get_temp_static_rw_transaction_data_valid_delay;
    export "DPI-C" axi_set_temp_static_rw_transaction_data_valid_delay = function axi_set_temp_static_rw_transaction_data_valid_delay;
    export "DPI-C" axi_get_temp_static_rw_transaction_data_ready_delay = function axi_get_temp_static_rw_transaction_data_ready_delay;
    export "DPI-C" axi_set_temp_static_rw_transaction_data_ready_delay = function axi_set_temp_static_rw_transaction_data_ready_delay;
    import "DPI-C" context axi_rw_transaction_ActivatesActivatingActivate_SystemVerilog =
    task axi_rw_transaction_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout int prot,
        inout bit [3:0] burst_length,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout bit [7:0] addr_user,
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout bit [7:0] resp_user,
        inout int read_or_write,
        inout int address_to_data_latency,
        inout int data_to_response_latency,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int address_valid_delay,
        inout int data_valid_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_response_valid_delay,
        inout int address_ready_delay,
        inout int data_ready_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_response_ready_delay,
        inout bit write_data_with_address,
        input int _unit_id
    );
    import "DPI-C" context axi_rw_transaction_ActivatesActivatingActivate_open_SystemVerilog =
    task axi_rw_transaction_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout int prot,
        inout bit [((4) - 1):0] burst_length,
        inout bit [((8) - 1):0] addr_user,
        inout bit [((8) - 1):0] resp_user,
        inout int read_or_write,
        inout int address_to_data_latency,
        inout int data_to_response_latency,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int address_valid_delay,
        inout int write_response_valid_delay,
        inout int address_ready_delay,
        inout int write_response_ready_delay,
        inout bit write_data_with_address,
        input int _unit_id
    );
    import "DPI-C" context axi_rw_transaction_ReceivedReceivingReceive_SystemVerilog =
    task axi_rw_transaction_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_valid_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_ready_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_rw_transaction_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_rw_transaction_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output int prot,
        output bit [((4) - 1):0] burst_length,
        output bit [((8) - 1):0] addr_user,
        output bit [((8) - 1):0] resp_user,
        output int read_or_write,
        output int address_to_data_latency,
        output int data_to_response_latency,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        output int address_valid_delay,
        output int write_response_valid_delay,
        output int address_ready_delay,
        output int write_response_ready_delay,
        output bit write_data_with_address,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_AXI_read_addr = function axi_get_temp_static_AXI_read_addr;
    export "DPI-C" axi_set_temp_static_AXI_read_addr = function axi_set_temp_static_AXI_read_addr;
    export "DPI-C" axi_get_temp_static_AXI_read_id = function axi_get_temp_static_AXI_read_id;
    export "DPI-C" axi_set_temp_static_AXI_read_id = function axi_set_temp_static_AXI_read_id;
    export "DPI-C" axi_get_temp_static_AXI_read_data_words = function axi_get_temp_static_AXI_read_data_words;
    export "DPI-C" axi_set_temp_static_AXI_read_data_words = function axi_set_temp_static_AXI_read_data_words;
    export "DPI-C" axi_get_temp_static_AXI_read_resp = function axi_get_temp_static_AXI_read_resp;
    export "DPI-C" axi_set_temp_static_AXI_read_resp = function axi_set_temp_static_AXI_read_resp;
    export "DPI-C" axi_get_temp_static_AXI_read_data_user = function axi_get_temp_static_AXI_read_data_user;
    export "DPI-C" axi_set_temp_static_AXI_read_data_user = function axi_set_temp_static_AXI_read_data_user;
    export "DPI-C" axi_get_temp_static_AXI_read_data_start_time = function axi_get_temp_static_AXI_read_data_start_time;
    export "DPI-C" axi_set_temp_static_AXI_read_data_start_time = function axi_set_temp_static_AXI_read_data_start_time;
    export "DPI-C" axi_get_temp_static_AXI_read_data_end_time = function axi_get_temp_static_AXI_read_data_end_time;
    export "DPI-C" axi_set_temp_static_AXI_read_data_end_time = function axi_set_temp_static_AXI_read_data_end_time;
    import "DPI-C" context axi_AXI_read_ActivatesActivatingActivate_SystemVerilog =
    task axi_AXI_read_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout int prot,
        inout bit [3:0] burst_length,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout bit [7:0] addr_user,
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int address_to_data_latency,
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_read_ActivatesActivatingActivate_open_SystemVerilog =
    task axi_AXI_read_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout int prot,
        inout bit [((4) - 1):0] burst_length,
        inout bit [((8) - 1):0] addr_user,
        inout int address_to_data_latency,
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_read_ReceivedReceivingReceive_SystemVerilog =
    task axi_AXI_read_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_AXI_read_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_AXI_read_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output int prot,
        output bit [((4) - 1):0] burst_length,
        output bit [((8) - 1):0] addr_user,
        output int address_to_data_latency,
        output longint addr_start_time,
        output longint addr_end_time,
        output int address_valid_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_AXI_write_addr = function axi_get_temp_static_AXI_write_addr;
    export "DPI-C" axi_set_temp_static_AXI_write_addr = function axi_set_temp_static_AXI_write_addr;
    export "DPI-C" axi_get_temp_static_AXI_write_id = function axi_get_temp_static_AXI_write_id;
    export "DPI-C" axi_set_temp_static_AXI_write_id = function axi_set_temp_static_AXI_write_id;
    export "DPI-C" axi_get_temp_static_AXI_write_data_words = function axi_get_temp_static_AXI_write_data_words;
    export "DPI-C" axi_set_temp_static_AXI_write_data_words = function axi_set_temp_static_AXI_write_data_words;
    export "DPI-C" axi_get_temp_static_AXI_write_write_strobes = function axi_get_temp_static_AXI_write_write_strobes;
    export "DPI-C" axi_set_temp_static_AXI_write_write_strobes = function axi_set_temp_static_AXI_write_write_strobes;
    export "DPI-C" axi_get_temp_static_AXI_write_data_user = function axi_get_temp_static_AXI_write_data_user;
    export "DPI-C" axi_set_temp_static_AXI_write_data_user = function axi_set_temp_static_AXI_write_data_user;
    export "DPI-C" axi_get_temp_static_AXI_write_write_data_beats_delay = function axi_get_temp_static_AXI_write_write_data_beats_delay;
    export "DPI-C" axi_set_temp_static_AXI_write_write_data_beats_delay = function axi_set_temp_static_AXI_write_write_data_beats_delay;
    export "DPI-C" axi_get_temp_static_AXI_write_data_start_time = function axi_get_temp_static_AXI_write_data_start_time;
    export "DPI-C" axi_set_temp_static_AXI_write_data_start_time = function axi_set_temp_static_AXI_write_data_start_time;
    export "DPI-C" axi_get_temp_static_AXI_write_data_end_time = function axi_get_temp_static_AXI_write_data_end_time;
    export "DPI-C" axi_set_temp_static_AXI_write_data_end_time = function axi_set_temp_static_AXI_write_data_end_time;
    import "DPI-C" context axi_AXI_write_ActivatesActivatingActivate_SystemVerilog =
    task axi_AXI_write_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout int prot,
        inout bit [3:0] burst_length,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp,
        inout bit [7:0] addr_user,
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout bit [7:0] resp_user,
        inout int address_to_data_latency,
        inout int data_to_response_latency,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout longint wr_resp_start_time,
        inout longint wr_resp_end_time,
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_write_ActivatesActivatingActivate_open_SystemVerilog =
    task axi_AXI_write_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout int prot,
        inout bit [((4) - 1):0] burst_length,
        inout int resp,
        inout bit [((8) - 1):0] addr_user,
        inout bit [((8) - 1):0] resp_user,
        inout int address_to_data_latency,
        inout int data_to_response_latency,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout longint wr_resp_start_time,
        inout longint wr_resp_end_time,
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_write_ReceivedReceivingReceive_SystemVerilog =
    task axi_AXI_write_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_AXI_write_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_AXI_write_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output int prot,
        output bit [((4) - 1):0] burst_length,
        output int resp,
        output bit [((8) - 1):0] addr_user,
        output bit [((8) - 1):0] resp_user,
        output int address_to_data_latency,
        output int data_to_response_latency,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        output longint addr_start_time,
        output longint addr_end_time,
        output longint wr_resp_start_time,
        output longint wr_resp_end_time,
        output int address_valid_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_data_resp_data_words = function axi_get_temp_static_data_resp_data_words;
    export "DPI-C" axi_set_temp_static_data_resp_data_words = function axi_set_temp_static_data_resp_data_words;
    export "DPI-C" axi_get_temp_static_data_resp_write_strobes = function axi_get_temp_static_data_resp_write_strobes;
    export "DPI-C" axi_set_temp_static_data_resp_write_strobes = function axi_set_temp_static_data_resp_write_strobes;
    export "DPI-C" axi_get_temp_static_data_resp_id = function axi_get_temp_static_data_resp_id;
    export "DPI-C" axi_set_temp_static_data_resp_id = function axi_set_temp_static_data_resp_id;
    export "DPI-C" axi_get_temp_static_data_resp_data_user = function axi_get_temp_static_data_resp_data_user;
    export "DPI-C" axi_set_temp_static_data_resp_data_user = function axi_set_temp_static_data_resp_data_user;
    export "DPI-C" axi_get_temp_static_data_resp_write_data_beats_delay = function axi_get_temp_static_data_resp_write_data_beats_delay;
    export "DPI-C" axi_set_temp_static_data_resp_write_data_beats_delay = function axi_set_temp_static_data_resp_write_data_beats_delay;
    export "DPI-C" axi_get_temp_static_data_resp_data_beat_start_time = function axi_get_temp_static_data_resp_data_beat_start_time;
    export "DPI-C" axi_set_temp_static_data_resp_data_beat_start_time = function axi_set_temp_static_data_resp_data_beat_start_time;
    export "DPI-C" axi_get_temp_static_data_resp_data_beat_end_time = function axi_get_temp_static_data_resp_data_beat_end_time;
    export "DPI-C" axi_set_temp_static_data_resp_data_beat_end_time = function axi_set_temp_static_data_resp_data_beat_end_time;
    import "DPI-C" context axi_data_resp_ActivatesActivatingActivate_SystemVerilog =
    task axi_data_resp_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int burst_length,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp,
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout bit [7:0] resp_user,
        inout longint data_start,
        inout longint data_end,
        inout longint response_start,
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_beat_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_beat_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout longint response_end_time,
        input int _unit_id
    );
    import "DPI-C" context axi_data_resp_ActivatesActivatingActivate_open_SystemVerilog =
    task axi_data_resp_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int burst_length,
        inout int resp,
        inout bit [((8) - 1):0] resp_user,
        inout longint data_start,
        inout longint data_end,
        inout longint response_start,
        inout longint response_end_time,
        input int _unit_id
    );
    import "DPI-C" context axi_data_resp_ReceivedReceivingReceive_SystemVerilog =
    task axi_data_resp_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_beat_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_beat_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_data_resp_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_data_resp_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int burst_length,
        output int resp,
        output bit [((8) - 1):0] resp_user,
        output longint data_start,
        output longint data_end,
        output longint response_start,
        output longint response_end_time,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_read_data_burst_data_words = function axi_get_temp_static_read_data_burst_data_words;
    export "DPI-C" axi_set_temp_static_read_data_burst_data_words = function axi_set_temp_static_read_data_burst_data_words;
    export "DPI-C" axi_get_temp_static_read_data_burst_resp = function axi_get_temp_static_read_data_burst_resp;
    export "DPI-C" axi_set_temp_static_read_data_burst_resp = function axi_set_temp_static_read_data_burst_resp;
    export "DPI-C" axi_get_temp_static_read_data_burst_id = function axi_get_temp_static_read_data_burst_id;
    export "DPI-C" axi_set_temp_static_read_data_burst_id = function axi_set_temp_static_read_data_burst_id;
    export "DPI-C" axi_get_temp_static_read_data_burst_data_user = function axi_get_temp_static_read_data_burst_data_user;
    export "DPI-C" axi_set_temp_static_read_data_burst_data_user = function axi_set_temp_static_read_data_burst_data_user;
    export "DPI-C" axi_get_temp_static_read_data_burst_data_start_time = function axi_get_temp_static_read_data_burst_data_start_time;
    export "DPI-C" axi_set_temp_static_read_data_burst_data_start_time = function axi_set_temp_static_read_data_burst_data_start_time;
    export "DPI-C" axi_get_temp_static_read_data_burst_data_end_time = function axi_get_temp_static_read_data_burst_data_end_time;
    export "DPI-C" axi_set_temp_static_read_data_burst_data_end_time = function axi_set_temp_static_read_data_burst_data_end_time;
    import "DPI-C" context axi_read_data_burst_SendSendingSent_SystemVerilog =
    task axi_read_data_burst_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [3:0] burst_length,
        input int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi_read_data_burst_ReceivedReceivingReceive_SystemVerilog =
    task axi_read_data_burst_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_data_burst_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_read_data_burst_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((4) - 1):0] burst_length,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_write_data_burst_data_words = function axi_get_temp_static_write_data_burst_data_words;
    export "DPI-C" axi_set_temp_static_write_data_burst_data_words = function axi_set_temp_static_write_data_burst_data_words;
    export "DPI-C" axi_get_temp_static_write_data_burst_write_strobes = function axi_get_temp_static_write_data_burst_write_strobes;
    export "DPI-C" axi_set_temp_static_write_data_burst_write_strobes = function axi_set_temp_static_write_data_burst_write_strobes;
    export "DPI-C" axi_get_temp_static_write_data_burst_id = function axi_get_temp_static_write_data_burst_id;
    export "DPI-C" axi_set_temp_static_write_data_burst_id = function axi_set_temp_static_write_data_burst_id;
    export "DPI-C" axi_get_temp_static_write_data_burst_data_user = function axi_get_temp_static_write_data_burst_data_user;
    export "DPI-C" axi_set_temp_static_write_data_burst_data_user = function axi_set_temp_static_write_data_burst_data_user;
    export "DPI-C" axi_get_temp_static_write_data_burst_write_data_beats_delay = function axi_get_temp_static_write_data_burst_write_data_beats_delay;
    export "DPI-C" axi_set_temp_static_write_data_burst_write_data_beats_delay = function axi_set_temp_static_write_data_burst_write_data_beats_delay;
    export "DPI-C" axi_get_temp_static_write_data_burst_data_start_time = function axi_get_temp_static_write_data_burst_data_start_time;
    export "DPI-C" axi_set_temp_static_write_data_burst_data_start_time = function axi_set_temp_static_write_data_burst_data_start_time;
    export "DPI-C" axi_get_temp_static_write_data_burst_data_end_time = function axi_get_temp_static_write_data_burst_data_end_time;
    export "DPI-C" axi_set_temp_static_write_data_burst_data_end_time = function axi_set_temp_static_write_data_burst_data_end_time;
    import "DPI-C" context axi_write_data_burst_SendSendingSent_SystemVerilog =
    task axi_write_data_burst_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int burst_length,
        input int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi_write_data_burst_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_data_burst_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_data_burst_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_write_data_burst_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int burst_length,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_read_addr_channel_phase_addr = function axi_get_temp_static_read_addr_channel_phase_addr;
    export "DPI-C" axi_set_temp_static_read_addr_channel_phase_addr = function axi_set_temp_static_read_addr_channel_phase_addr;
    export "DPI-C" axi_get_temp_static_read_addr_channel_phase_id = function axi_get_temp_static_read_addr_channel_phase_id;
    export "DPI-C" axi_set_temp_static_read_addr_channel_phase_id = function axi_set_temp_static_read_addr_channel_phase_id;
    import "DPI-C" context axi_read_addr_channel_phase_SendSendingSent_SystemVerilog =
    task axi_read_addr_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [3:0] burst_length,
        input int size,
        input int burst,
        input int lock,
        input int cache,
        input int prot,
        input bit [7:0] addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_read_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi_read_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_read_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((4) - 1):0] burst_length,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output int prot,
        output bit [((8) - 1):0] addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_read_channel_phase_data = function axi_get_temp_static_read_channel_phase_data;
    export "DPI-C" axi_set_temp_static_read_channel_phase_data = function axi_set_temp_static_read_channel_phase_data;
    export "DPI-C" axi_get_temp_static_read_channel_phase_id = function axi_get_temp_static_read_channel_phase_id;
    export "DPI-C" axi_set_temp_static_read_channel_phase_id = function axi_set_temp_static_read_channel_phase_id;
    import "DPI-C" context axi_read_channel_phase_SendSendingSent_SystemVerilog =
    task axi_read_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit last,
        input int resp,
        input bit [7:0] data_user,
        input int data_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_read_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi_read_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_channel_phase_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_read_channel_phase_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit last,
        output int resp,
        output bit [((8) - 1):0] data_user,
        output int data_ready_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_write_addr_channel_phase_addr = function axi_get_temp_static_write_addr_channel_phase_addr;
    export "DPI-C" axi_set_temp_static_write_addr_channel_phase_addr = function axi_set_temp_static_write_addr_channel_phase_addr;
    export "DPI-C" axi_get_temp_static_write_addr_channel_phase_id = function axi_get_temp_static_write_addr_channel_phase_id;
    export "DPI-C" axi_set_temp_static_write_addr_channel_phase_id = function axi_set_temp_static_write_addr_channel_phase_id;
    import "DPI-C" context axi_write_addr_channel_phase_SendSendingSent_SystemVerilog =
    task axi_write_addr_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [3:0] burst_length,
        input int size,
        input int burst,
        input int lock,
        input int cache,
        input int prot,
        input bit [7:0] addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_write_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_write_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((4) - 1):0] burst_length,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output int prot,
        output bit [((8) - 1):0] addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_write_channel_phase_data = function axi_get_temp_static_write_channel_phase_data;
    export "DPI-C" axi_set_temp_static_write_channel_phase_data = function axi_set_temp_static_write_channel_phase_data;
    export "DPI-C" axi_get_temp_static_write_channel_phase_write_strobes = function axi_get_temp_static_write_channel_phase_write_strobes;
    export "DPI-C" axi_set_temp_static_write_channel_phase_write_strobes = function axi_set_temp_static_write_channel_phase_write_strobes;
    export "DPI-C" axi_get_temp_static_write_channel_phase_id = function axi_get_temp_static_write_channel_phase_id;
    export "DPI-C" axi_set_temp_static_write_channel_phase_id = function axi_set_temp_static_write_channel_phase_id;
    import "DPI-C" context axi_write_channel_phase_SendSendingSent_SystemVerilog =
    task axi_write_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [7:0] data_user,
        input int data_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_write_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_channel_phase_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_write_channel_phase_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit last,
        output bit [((8) - 1):0] data_user,
        output int data_ready_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_write_resp_channel_phase_id = function axi_get_temp_static_write_resp_channel_phase_id;
    export "DPI-C" axi_set_temp_static_write_resp_channel_phase_id = function axi_set_temp_static_write_resp_channel_phase_id;
    import "DPI-C" context axi_write_resp_channel_phase_SendSendingSent_SystemVerilog =
    task axi_write_resp_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int resp,
        input bit [7:0] resp_user,
        input int write_response_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_write_resp_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_resp_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_resp_channel_phase_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_write_resp_channel_phase_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int resp,
        output bit [((8) - 1):0] resp_user,
        output int write_response_ready_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_read_addr_channel_cycle_addr = function axi_get_temp_static_read_addr_channel_cycle_addr;
    export "DPI-C" axi_set_temp_static_read_addr_channel_cycle_addr = function axi_set_temp_static_read_addr_channel_cycle_addr;
    export "DPI-C" axi_get_temp_static_read_addr_channel_cycle_id = function axi_get_temp_static_read_addr_channel_cycle_id;
    export "DPI-C" axi_set_temp_static_read_addr_channel_cycle_id = function axi_set_temp_static_read_addr_channel_cycle_id;
    import "DPI-C" context axi_read_addr_channel_cycle_SendSendingSent_SystemVerilog =
    task axi_read_addr_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [3:0] burst_length,
        input int size,
        input int burst,
        input int lock,
        input int cache,
        input int prot,
        input bit [7:0] addr_user,
        input int _unit_id
    );
    import "DPI-C" context axi_read_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi_read_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_read_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((4) - 1):0] burst_length,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output int prot,
        output bit [((8) - 1):0] addr_user,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_addr_channel_ready_SendSendingSent_SystemVerilog =
    task axi_read_addr_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_read_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi_read_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_read_channel_cycle_data = function axi_get_temp_static_read_channel_cycle_data;
    export "DPI-C" axi_set_temp_static_read_channel_cycle_data = function axi_set_temp_static_read_channel_cycle_data;
    export "DPI-C" axi_get_temp_static_read_channel_cycle_id = function axi_get_temp_static_read_channel_cycle_id;
    export "DPI-C" axi_set_temp_static_read_channel_cycle_id = function axi_set_temp_static_read_channel_cycle_id;
    import "DPI-C" context axi_read_channel_cycle_SendSendingSent_SystemVerilog =
    task axi_read_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit last,
        input int resp,
        input bit [7:0] data_user,
        input int _unit_id
    );
    import "DPI-C" context axi_read_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi_read_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_read_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit last,
        output int resp,
        output bit [((8) - 1):0] data_user,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_channel_ready_SendSendingSent_SystemVerilog =
    task axi_read_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_read_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi_read_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_write_addr_channel_cycle_addr = function axi_get_temp_static_write_addr_channel_cycle_addr;
    export "DPI-C" axi_set_temp_static_write_addr_channel_cycle_addr = function axi_set_temp_static_write_addr_channel_cycle_addr;
    export "DPI-C" axi_get_temp_static_write_addr_channel_cycle_id = function axi_get_temp_static_write_addr_channel_cycle_id;
    export "DPI-C" axi_set_temp_static_write_addr_channel_cycle_id = function axi_set_temp_static_write_addr_channel_cycle_id;
    import "DPI-C" context axi_write_addr_channel_cycle_SendSendingSent_SystemVerilog =
    task axi_write_addr_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [3:0] burst_length,
        input int size,
        input int burst,
        input int lock,
        input int cache,
        input int prot,
        input bit [7:0] addr_user,
        input int _unit_id
    );
    import "DPI-C" context axi_write_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_write_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((4) - 1):0] burst_length,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output int prot,
        output bit [((8) - 1):0] addr_user,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_addr_channel_ready_SendSendingSent_SystemVerilog =
    task axi_write_addr_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_write_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_write_channel_cycle_data = function axi_get_temp_static_write_channel_cycle_data;
    export "DPI-C" axi_set_temp_static_write_channel_cycle_data = function axi_set_temp_static_write_channel_cycle_data;
    export "DPI-C" axi_get_temp_static_write_channel_cycle_strb = function axi_get_temp_static_write_channel_cycle_strb;
    export "DPI-C" axi_set_temp_static_write_channel_cycle_strb = function axi_set_temp_static_write_channel_cycle_strb;
    export "DPI-C" axi_get_temp_static_write_channel_cycle_id = function axi_get_temp_static_write_channel_cycle_id;
    export "DPI-C" axi_set_temp_static_write_channel_cycle_id = function axi_set_temp_static_write_channel_cycle_id;
    import "DPI-C" context axi_write_channel_cycle_SendSendingSent_SystemVerilog =
    task axi_write_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [7:0] data_user,
        input int _unit_id
    );
    import "DPI-C" context axi_write_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_write_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit last,
        output bit [((8) - 1):0] data_user,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_channel_ready_SendSendingSent_SystemVerilog =
    task axi_write_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_write_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_write_resp_channel_cycle_id = function axi_get_temp_static_write_resp_channel_cycle_id;
    export "DPI-C" axi_set_temp_static_write_resp_channel_cycle_id = function axi_set_temp_static_write_resp_channel_cycle_id;
    import "DPI-C" context axi_write_resp_channel_cycle_SendSendingSent_SystemVerilog =
    task axi_write_resp_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int resp,
        input bit [7:0] resp_user,
        input int _unit_id
    );
    import "DPI-C" context axi_write_resp_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_resp_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_resp_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_write_resp_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int resp,
        output bit [((8) - 1):0] resp_user,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_resp_channel_ready_SendSendingSent_SystemVerilog =
    task axi_write_resp_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_write_resp_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_resp_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_end_of_timestep_VPI_SystemVerilog =
    task axi_end_of_timestep_VPI_SystemVerilog();
    import "DPI-C" context function longint axi_get_interface_handle();

    // Waiter task and control
    reg wait_for_control = 0;

    always @(posedge wait_for_control)
    begin
        disable wait_for;
        wait_for_control = 0;
    end

    export "DPI-C" axi_wait_for = task wait_for;

    task wait_for();
        begin
            wait(0 == 1);
        end
    endtask

    // handle control
    longint last_handle = 0;

    longint last_start_time = 0;

    longint last_end_time = 0;

    export "DPI-C" axi_set_last_handle_and_times = function set_last_handle_and_times;

    function void set_last_handle_and_times(longint _handle, longint _start, longint _end);
        last_handle = _handle;
        last_start_time = _start;
        last_end_time = _end;
    endfunction

    // Drive wires (from Cohesive) 
    assign ACLK = internal_ACLK;
    assign ARESETn = internal_ARESETn;
    assign AWVALID = internal_AWVALID;
    assign AWADDR = internal_AWADDR;
    assign AWLEN = internal_AWLEN;
    assign AWSIZE = internal_AWSIZE;
    assign AWBURST = internal_AWBURST;
    assign AWLOCK = internal_AWLOCK;
    assign AWCACHE = internal_AWCACHE;
    assign AWPROT = internal_AWPROT;
    assign AWID = internal_AWID;
    assign AWREADY = internal_AWREADY;
    assign AWUSER = internal_AWUSER;
    assign ARVALID = internal_ARVALID;
    assign ARADDR = internal_ARADDR;
    assign ARLEN = internal_ARLEN;
    assign ARSIZE = internal_ARSIZE;
    assign ARBURST = internal_ARBURST;
    assign ARLOCK = internal_ARLOCK;
    assign ARCACHE = internal_ARCACHE;
    assign ARPROT = internal_ARPROT;
    assign ARID = internal_ARID;
    assign ARREADY = internal_ARREADY;
    assign ARUSER = internal_ARUSER;
    assign RVALID = internal_RVALID;
    assign RLAST = internal_RLAST;
    assign RDATA = internal_RDATA;
    assign RRESP = internal_RRESP;
    assign RID = internal_RID;
    assign RREADY = internal_RREADY;
    assign RUSER = internal_RUSER;
    assign WVALID = internal_WVALID;
    assign WLAST = internal_WLAST;
    assign WDATA = internal_WDATA;
    assign WSTRB = internal_WSTRB;
    assign WID = internal_WID;
    assign WREADY = internal_WREADY;
    assign WUSER = internal_WUSER;
    assign BVALID = internal_BVALID;
    assign BRESP = internal_BRESP;
    assign BID = internal_BID;
    assign BREADY = internal_BREADY;
    assign BUSER = internal_BUSER;
    // Drive wires (from User) 
    assign ACLK = m_ACLK;
    assign ARESETn = m_ARESETn;
    assign AWVALID = m_AWVALID;
    assign AWADDR = m_AWADDR;
    assign AWLEN = m_AWLEN;
    assign AWSIZE = m_AWSIZE;
    assign AWBURST = m_AWBURST;
    assign AWLOCK = m_AWLOCK;
    assign AWCACHE = m_AWCACHE;
    assign AWPROT = m_AWPROT;
    assign AWID = m_AWID;
    assign AWREADY = m_AWREADY;
    assign AWUSER = m_AWUSER;
    assign ARVALID = m_ARVALID;
    assign ARADDR = m_ARADDR;
    assign ARLEN = m_ARLEN;
    assign ARSIZE = m_ARSIZE;
    assign ARBURST = m_ARBURST;
    assign ARLOCK = m_ARLOCK;
    assign ARCACHE = m_ARCACHE;
    assign ARPROT = m_ARPROT;
    assign ARID = m_ARID;
    assign ARREADY = m_ARREADY;
    assign ARUSER = m_ARUSER;
    assign RVALID = m_RVALID;
    assign RLAST = m_RLAST;
    assign RDATA = m_RDATA;
    assign RRESP = m_RRESP;
    assign RID = m_RID;
    assign RREADY = m_RREADY;
    assign RUSER = m_RUSER;
    assign WVALID = m_WVALID;
    assign WLAST = m_WLAST;
    assign WDATA = m_WDATA;
    assign WSTRB = m_WSTRB;
    assign WID = m_WID;
    assign WREADY = m_WREADY;
    assign WUSER = m_WUSER;
    assign BVALID = m_BVALID;
    assign BRESP = m_BRESP;
    assign BID = m_BID;
    assign BREADY = m_BREADY;
    assign BUSER = m_BUSER;

    reg ACLK_changed = 0;
    reg ARESETn_changed = 0;
    reg AWVALID_changed = 0;
    reg AWADDR_changed = 0;
    reg AWLEN_changed = 0;
    reg AWSIZE_changed = 0;
    reg AWBURST_changed = 0;
    reg AWLOCK_changed = 0;
    reg AWCACHE_changed = 0;
    reg AWPROT_changed = 0;
    reg AWID_changed = 0;
    reg AWREADY_changed = 0;
    reg AWUSER_changed = 0;
    reg ARVALID_changed = 0;
    reg ARADDR_changed = 0;
    reg ARLEN_changed = 0;
    reg ARSIZE_changed = 0;
    reg ARBURST_changed = 0;
    reg ARLOCK_changed = 0;
    reg ARCACHE_changed = 0;
    reg ARPROT_changed = 0;
    reg ARID_changed = 0;
    reg ARREADY_changed = 0;
    reg ARUSER_changed = 0;
    reg RVALID_changed = 0;
    reg RLAST_changed = 0;
    reg RDATA_changed = 0;
    reg RRESP_changed = 0;
    reg RID_changed = 0;
    reg RREADY_changed = 0;
    reg RUSER_changed = 0;
    reg WVALID_changed = 0;
    reg WLAST_changed = 0;
    reg WDATA_changed = 0;
    reg WSTRB_changed = 0;
    reg WID_changed = 0;
    reg WREADY_changed = 0;
    reg WUSER_changed = 0;
    reg BVALID_changed = 0;
    reg BRESP_changed = 0;
    reg BID_changed = 0;
    reg BREADY_changed = 0;
    reg BUSER_changed = 0;
    reg config_clk_init_value_changed = 0;
    reg config_clk_phase_shift_changed = 0;
    reg config_clk_1st_time_changed = 0;
    reg config_clk_2nd_time_changed = 0;
    reg config_setup_time_changed = 0;
    reg config_hold_time_changed = 0;
    reg config_max_transaction_time_factor_changed = 0;
    reg config_timeout_max_data_transfer_changed = 0;
    reg config_burst_timeout_factor_changed = 0;
    reg config_max_latency_AWVALID_assertion_to_AWREADY_changed = 0;
    reg config_max_latency_ARVALID_assertion_to_ARREADY_changed = 0;
    reg config_max_latency_RVALID_assertion_to_RREADY_changed = 0;
    reg config_max_latency_BVALID_assertion_to_BREADY_changed = 0;
    reg config_max_latency_WVALID_assertion_to_WREADY_changed = 0;
    reg config_write_ctrl_first_ratio_changed = 0;
    reg config_write_data_first_ratio_changed = 0;
    reg config_write_ctrl_to_data_mintime_changed = 0;
    reg config_write_data_to_ctrl_mintime_changed = 0;
    reg config_master_write_delay_changed = 0;
    reg config_reset_low_clocks_changed = 0;
    reg config_reset_hold_time_changed = 0;
    reg config_protect_ready_changed = 0;
    reg config_enable_user_sideband_changed = 0;
    reg config_extended_length_enable_changed = 0;
    reg config_enable_burst_reserved_value_changed = 0;
    reg config_enable_lock_reserved_value_changed = 0;
    reg config_enable_cache_reserved_value_changed = 0;
    reg config_enable_all_assertions_changed = 0;
    reg config_enable_assertion_changed = 0;
    reg config_enable_error_changed = 0;
    reg config_enable_errors_changed = 0;
    reg config_enable_all_assertion_errors_changed = 0;
    reg config_abstraction_level_changed = 0;
    reg config_slave_start_addr_changed = 0;
    reg config_slave_end_addr_changed = 0;
    reg config_enable_slave_addr_range_in_bfm_changed = 0;
    reg config_read_data_reordering_depth_changed = 0;
    reg config_enable_read_data_reordering_depth_in_bfm_changed = 0;
    reg config_awid_wid_mismatch_changed = 0;
    reg config_length_last_mismatch_error_changed = 0;
    reg config_master_error_position_changed = 0;
    reg dummy_var_changed = 0;
    reg config_wlast_length_changed = 0;
    reg config_wid_for_awid_not_matching_changed = 0;
    reg config_support_exclusive_access_changed = 0;
    reg config_write_data_interleaving_depth_changed = 0;
    reg status_master_error_changed = 0;
    reg status_num_reads_waiting_for_resp_changed = 0;
    reg status_num_writes_waiting_for_response_changed = 0;
    reg check_total_num_wdata_outstanding_changed = 0;
    reg total_num_wdata_outstanding_changed = 0;
    reg check_max_num_wdata_outstanding_per_id_changed = 0;
    reg max_num_wdata_outstanding_per_id_changed = 0;
    reg check_max_num_waddr_outstanding_per_id_changed = 0;
    reg max_num_waddr_outstanding_per_id_changed = 0;
    reg check_total_num_waddr_outstanding_changed = 0;
    reg total_num_waddr_outstanding_changed = 0;
    reg status_outstanding_num_for_waddr_changed = 0;
    reg start_finding_outstanding_waddr_changed = 0;
    reg status_outstanding_num_for_wdata_changed = 0;
    reg start_finding_outstanding_wdata_changed = 0;
    reg find_waddr_outstanding_for_wid_changed = 0;
    reg find_wdata_outstanding_for_wid_changed = 0;
    reg change_in_wdata_outstanding_per_id_changed = 0;
    reg start_finding_change_in_wdata_changed = 0;
    reg find_change_in_wdata_outstanding_for_wid_changed = 0;
    reg config_max_outstanding_wr_changed = 0;
    reg config_max_outstanding_rd_changed = 0;
    reg config_error_on_deleted_valid_cycles_changed = 0;
    reg config_stats_enable_changed = 0;
    reg config_stats_enable_AXI_read_occupancy_changed = 0;
    reg config_stats_enable_AXI_write_occupancy_changed = 0;
    reg config_stats_enable_read_data_occupancy_changed = 0;
    reg config_stats_enable_write_data_occupancy_changed = 0;
    reg config_stats_enable_read_latency_changed = 0;
    reg config_stats_enable_write_latency_changed = 0;
    reg config_stats_enable_read_address_waits_changed = 0;
    reg config_stats_enable_read_data_waits_changed = 0;
    reg config_stats_enable_write_address_waits_changed = 0;
    reg config_stats_enable_write_data_waits_changed = 0;
    reg config_stats_enable_write_response_waits_changed = 0;
    reg config_stats_enable_read_bandwidth_changed = 0;
    reg config_stats_enable_write_bandwidth_changed = 0;
    reg config_stats_AXI_read_occupancy_step_changed = 0;
    reg config_stats_AXI_read_occupancy_multiple_changed = 0;
    reg stats_AXI_read_active_changed = 0;
    reg stats_AXI_read_occupancy_sw_changed = 0;
    reg stats_AXI_read_occupancy_sw_updated_changed = 0;
    reg stats_AXI_read_idle_sw_changed = 0;
    reg stats_AXI_read_occupancy_min_changed = 0;
    reg stats_AXI_read_idle_min_changed = 0;
    reg stats_AXI_read_occupancy_max_changed = 0;
    reg stats_AXI_read_idle_max_changed = 0;
    reg stats_AXI_read_occupancy_mean_changed = 0;
    reg stats_AXI_read_idle_mean_changed = 0;
    reg config_stats_AXI_write_occupancy_step_changed = 0;
    reg config_stats_AXI_write_occupancy_multiple_changed = 0;
    reg stats_AXI_write_active_changed = 0;
    reg stats_AXI_write_occupancy_sw_changed = 0;
    reg stats_AXI_write_occupancy_sw_updated_changed = 0;
    reg stats_AXI_write_idle_sw_changed = 0;
    reg stats_AXI_write_occupancy_min_changed = 0;
    reg stats_AXI_write_idle_min_changed = 0;
    reg stats_AXI_write_occupancy_max_changed = 0;
    reg stats_AXI_write_idle_max_changed = 0;
    reg stats_AXI_write_occupancy_mean_changed = 0;
    reg stats_AXI_write_idle_mean_changed = 0;
    reg config_stats_read_data_occupancy_step_changed = 0;
    reg config_stats_read_data_occupancy_multiple_changed = 0;
    reg stats_read_data_occupancy_sw_changed = 0;
    reg stats_read_data_occupancy_sw_updated_changed = 0;
    reg stats_read_data_idle_sw_changed = 0;
    reg stats_read_data_occupancy_min_changed = 0;
    reg stats_read_data_idle_min_changed = 0;
    reg stats_read_data_occupancy_max_changed = 0;
    reg stats_read_data_idle_max_changed = 0;
    reg stats_read_data_occupancy_mean_changed = 0;
    reg stats_read_data_idle_mean_changed = 0;
    reg config_stats_write_data_occupancy_step_changed = 0;
    reg config_stats_write_data_occupancy_multiple_changed = 0;
    reg stats_write_data_occupancy_sw_changed = 0;
    reg stats_write_data_occupancy_sw_updated_changed = 0;
    reg stats_write_data_idle_sw_changed = 0;
    reg stats_write_data_occupancy_min_changed = 0;
    reg stats_write_data_idle_min_changed = 0;
    reg stats_write_data_occupancy_max_changed = 0;
    reg stats_write_data_idle_max_changed = 0;
    reg stats_write_data_occupancy_mean_changed = 0;
    reg stats_write_data_idle_mean_changed = 0;
    reg config_stats_read_bandwidth_step_changed = 0;
    reg config_stats_read_bandwidth_multiple_changed = 0;
    reg stats_read_bandwidth_sw_changed = 0;
    reg stats_read_bandwidth_sw_updated_changed = 0;
    reg stats_read_bandwidth_min_changed = 0;
    reg stats_read_bandwidth_max_changed = 0;
    reg stats_read_bandwidth_mean_changed = 0;
    reg config_stats_write_bandwidth_step_changed = 0;
    reg config_stats_write_bandwidth_multiple_changed = 0;
    reg stats_write_bandwidth_sw_changed = 0;
    reg stats_write_bandwidth_sw_updated_changed = 0;
    reg stats_write_bandwidth_min_changed = 0;
    reg stats_write_bandwidth_max_changed = 0;
    reg stats_write_bandwidth_mean_changed = 0;
    reg config_stats_read_latency_step_changed = 0;
    reg config_stats_read_latency_multiple_changed = 0;
    reg stats_read_latency_sw_updated_changed = 0;
    reg stats_read_address_data_latency_inst_changed = 0;
    reg stats_read_address_data_latency_sw_changed = 0;
    reg stats_read_address_data_latency_min_changed = 0;
    reg stats_read_address_data_latency_max_changed = 0;
    reg stats_read_address_data_latency_mean_changed = 0;
    reg stats_read_address_address_latency_inst_changed = 0;
    reg stats_read_address_address_latency_sw_changed = 0;
    reg stats_read_address_address_latency_min_changed = 0;
    reg stats_read_address_address_latency_max_changed = 0;
    reg stats_read_address_address_latency_mean_changed = 0;
    reg config_stats_write_latency_step_changed = 0;
    reg config_stats_write_latency_multiple_changed = 0;
    reg stats_write_latency_sw_updated_changed = 0;
    reg stats_write_address_data_latency_inst_changed = 0;
    reg stats_write_address_data_latency_sw_changed = 0;
    reg stats_write_address_data_latency_min_changed = 0;
    reg stats_write_address_data_latency_max_changed = 0;
    reg stats_write_address_data_latency_mean_changed = 0;
    reg stats_write_data_response_latency_inst_changed = 0;
    reg stats_write_data_response_latency_sw_changed = 0;
    reg stats_write_data_response_latency_min_changed = 0;
    reg stats_write_data_response_latency_max_changed = 0;
    reg stats_write_data_response_latency_mean_changed = 0;
    reg stats_write_address_address_latency_inst_changed = 0;
    reg stats_write_address_address_latency_sw_changed = 0;
    reg stats_write_address_address_latency_min_changed = 0;
    reg stats_write_address_address_latency_max_changed = 0;
    reg stats_write_address_address_latency_mean_changed = 0;
    reg config_stats_read_address_waits_step_changed = 0;
    reg config_stats_read_address_waits_multiple_changed = 0;
    reg stats_read_address_waits_inst_changed = 0;
    reg stats_read_address_waits_sw_changed = 0;
    reg stats_read_address_waits_sw_updated_changed = 0;
    reg stats_read_address_waits_min_changed = 0;
    reg stats_read_address_waits_max_changed = 0;
    reg stats_read_address_waits_mean_changed = 0;
    reg config_stats_read_data_waits_step_changed = 0;
    reg config_stats_read_data_waits_multiple_changed = 0;
    reg stats_read_data_waits_inst_changed = 0;
    reg stats_read_data_waits_sw_changed = 0;
    reg stats_read_data_waits_sw_updated_changed = 0;
    reg stats_read_data_waits_min_changed = 0;
    reg stats_read_data_waits_max_changed = 0;
    reg stats_read_data_waits_mean_changed = 0;
    reg config_stats_write_address_waits_step_changed = 0;
    reg config_stats_write_address_waits_multiple_changed = 0;
    reg stats_write_address_waits_inst_changed = 0;
    reg stats_write_address_waits_sw_changed = 0;
    reg stats_write_address_waits_sw_updated_changed = 0;
    reg stats_write_address_waits_min_changed = 0;
    reg stats_write_address_waits_max_changed = 0;
    reg stats_write_address_waits_mean_changed = 0;
    reg config_stats_write_data_waits_step_changed = 0;
    reg config_stats_write_data_waits_multiple_changed = 0;
    reg stats_write_data_waits_inst_changed = 0;
    reg stats_write_data_waits_sw_changed = 0;
    reg stats_write_data_waits_sw_updated_changed = 0;
    reg stats_write_data_waits_min_changed = 0;
    reg stats_write_data_waits_max_changed = 0;
    reg stats_write_data_waits_mean_changed = 0;
    reg config_stats_write_response_waits_step_changed = 0;
    reg config_stats_write_response_waits_multiple_changed = 0;
    reg stats_write_response_waits_inst_changed = 0;
    reg stats_write_response_waits_sw_changed = 0;
    reg stats_write_response_waits_sw_updated_changed = 0;
    reg stats_write_response_waits_min_changed = 0;
    reg stats_write_response_waits_max_changed = 0;
    reg stats_write_response_waits_mean_changed = 0;
    reg stats_rw_transaction_last_duration_changed = 0;
    reg stats_AXI_read_last_duration_changed = 0;
    reg stats_AXI_write_last_duration_changed = 0;
    reg stats_read_addr_channel_phase_last_duration_changed = 0;
    reg stats_read_data_burst_last_duration_changed = 0;
    reg stats_read_channel_phase_last_duration_changed = 0;
    reg stats_write_addr_channel_phase_last_duration_changed = 0;
    reg stats_write_data_burst_last_duration_changed = 0;
    reg stats_write_channel_phase_last_duration_changed = 0;
    reg stats_write_resp_channel_phase_last_duration_changed = 0;

    reg end_of_timestep_control = 0;


    // SV wire change monitors

    function automatic void axi_local_set_ACLK_from_SystemVerilog(  );
            axi_set_ACLK_from_SystemVerilog(ACLK); // DPI call to imported task
        
        axi_propagate_ACLK_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ACLK or posedge _check_t0_values )
    begin
        axi_local_set_ACLK_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARESETn_from_SystemVerilog(  );
            axi_set_ARESETn_from_SystemVerilog(ARESETn); // DPI call to imported task
        
        axi_propagate_ARESETn_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARESETn or posedge _check_t0_values )
    begin
        axi_local_set_ARESETn_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWVALID_from_SystemVerilog(  );
            axi_set_AWVALID_from_SystemVerilog(AWVALID); // DPI call to imported task
        
        axi_propagate_AWVALID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWVALID or posedge _check_t0_values )
    begin
        axi_local_set_AWVALID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWADDR_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ADDRESS_WIDTH ); _this_dot_1++)
        begin
            axi_set_AWADDR_from_SystemVerilog_index1(_this_dot_1,AWADDR[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi_propagate_AWADDR_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWADDR or posedge _check_t0_values )
    begin
        axi_local_set_AWADDR_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWLEN_from_SystemVerilog(  );
            axi_set_AWLEN_from_SystemVerilog(AWLEN); // DPI call to imported task
        
        axi_propagate_AWLEN_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWLEN or posedge _check_t0_values )
    begin
        axi_local_set_AWLEN_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWSIZE_from_SystemVerilog(  );
            axi_set_AWSIZE_from_SystemVerilog(AWSIZE); // DPI call to imported task
        
        axi_propagate_AWSIZE_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWSIZE or posedge _check_t0_values )
    begin
        axi_local_set_AWSIZE_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWBURST_from_SystemVerilog(  );
            axi_set_AWBURST_from_SystemVerilog(AWBURST); // DPI call to imported task
        
        axi_propagate_AWBURST_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWBURST or posedge _check_t0_values )
    begin
        axi_local_set_AWBURST_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWLOCK_from_SystemVerilog(  );
            axi_set_AWLOCK_from_SystemVerilog(AWLOCK); // DPI call to imported task
        
        axi_propagate_AWLOCK_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWLOCK or posedge _check_t0_values )
    begin
        axi_local_set_AWLOCK_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWCACHE_from_SystemVerilog(  );
            axi_set_AWCACHE_from_SystemVerilog(AWCACHE); // DPI call to imported task
        
        axi_propagate_AWCACHE_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWCACHE or posedge _check_t0_values )
    begin
        axi_local_set_AWCACHE_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWPROT_from_SystemVerilog(  );
            axi_set_AWPROT_from_SystemVerilog(AWPROT); // DPI call to imported task
        
        axi_propagate_AWPROT_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWPROT or posedge _check_t0_values )
    begin
        axi_local_set_AWPROT_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWID_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ID_WIDTH ); _this_dot_1++)
        begin
            axi_set_AWID_from_SystemVerilog_index1(_this_dot_1,AWID[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi_propagate_AWID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWID or posedge _check_t0_values )
    begin
        axi_local_set_AWID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWREADY_from_SystemVerilog(  );
            axi_set_AWREADY_from_SystemVerilog(AWREADY); // DPI call to imported task
        
        axi_propagate_AWREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWREADY or posedge _check_t0_values )
    begin
        axi_local_set_AWREADY_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWUSER_from_SystemVerilog(  );
            axi_set_AWUSER_from_SystemVerilog(AWUSER); // DPI call to imported task
        
        axi_propagate_AWUSER_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWUSER or posedge _check_t0_values )
    begin
        axi_local_set_AWUSER_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARVALID_from_SystemVerilog(  );
            axi_set_ARVALID_from_SystemVerilog(ARVALID); // DPI call to imported task
        
        axi_propagate_ARVALID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARVALID or posedge _check_t0_values )
    begin
        axi_local_set_ARVALID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARADDR_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ADDRESS_WIDTH ); _this_dot_1++)
        begin
            axi_set_ARADDR_from_SystemVerilog_index1(_this_dot_1,ARADDR[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi_propagate_ARADDR_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARADDR or posedge _check_t0_values )
    begin
        axi_local_set_ARADDR_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARLEN_from_SystemVerilog(  );
            axi_set_ARLEN_from_SystemVerilog(ARLEN); // DPI call to imported task
        
        axi_propagate_ARLEN_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARLEN or posedge _check_t0_values )
    begin
        axi_local_set_ARLEN_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARSIZE_from_SystemVerilog(  );
            axi_set_ARSIZE_from_SystemVerilog(ARSIZE); // DPI call to imported task
        
        axi_propagate_ARSIZE_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARSIZE or posedge _check_t0_values )
    begin
        axi_local_set_ARSIZE_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARBURST_from_SystemVerilog(  );
            axi_set_ARBURST_from_SystemVerilog(ARBURST); // DPI call to imported task
        
        axi_propagate_ARBURST_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARBURST or posedge _check_t0_values )
    begin
        axi_local_set_ARBURST_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARLOCK_from_SystemVerilog(  );
            axi_set_ARLOCK_from_SystemVerilog(ARLOCK); // DPI call to imported task
        
        axi_propagate_ARLOCK_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARLOCK or posedge _check_t0_values )
    begin
        axi_local_set_ARLOCK_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARCACHE_from_SystemVerilog(  );
            axi_set_ARCACHE_from_SystemVerilog(ARCACHE); // DPI call to imported task
        
        axi_propagate_ARCACHE_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARCACHE or posedge _check_t0_values )
    begin
        axi_local_set_ARCACHE_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARPROT_from_SystemVerilog(  );
            axi_set_ARPROT_from_SystemVerilog(ARPROT); // DPI call to imported task
        
        axi_propagate_ARPROT_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARPROT or posedge _check_t0_values )
    begin
        axi_local_set_ARPROT_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARID_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ID_WIDTH ); _this_dot_1++)
        begin
            axi_set_ARID_from_SystemVerilog_index1(_this_dot_1,ARID[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi_propagate_ARID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARID or posedge _check_t0_values )
    begin
        axi_local_set_ARID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARREADY_from_SystemVerilog(  );
            axi_set_ARREADY_from_SystemVerilog(ARREADY); // DPI call to imported task
        
        axi_propagate_ARREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARREADY or posedge _check_t0_values )
    begin
        axi_local_set_ARREADY_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARUSER_from_SystemVerilog(  );
            axi_set_ARUSER_from_SystemVerilog(ARUSER); // DPI call to imported task
        
        axi_propagate_ARUSER_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARUSER or posedge _check_t0_values )
    begin
        axi_local_set_ARUSER_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_RVALID_from_SystemVerilog(  );
            axi_set_RVALID_from_SystemVerilog(RVALID); // DPI call to imported task
        
        axi_propagate_RVALID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RVALID or posedge _check_t0_values )
    begin
        axi_local_set_RVALID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_RLAST_from_SystemVerilog(  );
            axi_set_RLAST_from_SystemVerilog(RLAST); // DPI call to imported task
        
        axi_propagate_RLAST_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RLAST or posedge _check_t0_values )
    begin
        axi_local_set_RLAST_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_RDATA_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_RDATA_WIDTH ); _this_dot_1++)
        begin
            axi_set_RDATA_from_SystemVerilog_index1(_this_dot_1,RDATA[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi_propagate_RDATA_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RDATA or posedge _check_t0_values )
    begin
        axi_local_set_RDATA_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_RRESP_from_SystemVerilog(  );
            axi_set_RRESP_from_SystemVerilog(RRESP); // DPI call to imported task
        
        axi_propagate_RRESP_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RRESP or posedge _check_t0_values )
    begin
        axi_local_set_RRESP_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_RID_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ID_WIDTH ); _this_dot_1++)
        begin
            axi_set_RID_from_SystemVerilog_index1(_this_dot_1,RID[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi_propagate_RID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RID or posedge _check_t0_values )
    begin
        axi_local_set_RID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_RREADY_from_SystemVerilog(  );
            axi_set_RREADY_from_SystemVerilog(RREADY); // DPI call to imported task
        
        axi_propagate_RREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RREADY or posedge _check_t0_values )
    begin
        axi_local_set_RREADY_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_RUSER_from_SystemVerilog(  );
            axi_set_RUSER_from_SystemVerilog(RUSER); // DPI call to imported task
        
        axi_propagate_RUSER_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RUSER or posedge _check_t0_values )
    begin
        axi_local_set_RUSER_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_WVALID_from_SystemVerilog(  );
            axi_set_WVALID_from_SystemVerilog(WVALID); // DPI call to imported task
        
        axi_propagate_WVALID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WVALID or posedge _check_t0_values )
    begin
        axi_local_set_WVALID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_WLAST_from_SystemVerilog(  );
            axi_set_WLAST_from_SystemVerilog(WLAST); // DPI call to imported task
        
        axi_propagate_WLAST_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WLAST or posedge _check_t0_values )
    begin
        axi_local_set_WLAST_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_WDATA_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_WDATA_WIDTH ); _this_dot_1++)
        begin
            axi_set_WDATA_from_SystemVerilog_index1(_this_dot_1,WDATA[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi_propagate_WDATA_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WDATA or posedge _check_t0_values )
    begin
        axi_local_set_WDATA_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_WSTRB_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( (AXI_WDATA_WIDTH / 8) ); _this_dot_1++)
        begin
            axi_set_WSTRB_from_SystemVerilog_index1(_this_dot_1,WSTRB[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi_propagate_WSTRB_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WSTRB or posedge _check_t0_values )
    begin
        axi_local_set_WSTRB_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_WID_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ID_WIDTH ); _this_dot_1++)
        begin
            axi_set_WID_from_SystemVerilog_index1(_this_dot_1,WID[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi_propagate_WID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WID or posedge _check_t0_values )
    begin
        axi_local_set_WID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_WREADY_from_SystemVerilog(  );
            axi_set_WREADY_from_SystemVerilog(WREADY); // DPI call to imported task
        
        axi_propagate_WREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WREADY or posedge _check_t0_values )
    begin
        axi_local_set_WREADY_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_WUSER_from_SystemVerilog(  );
            axi_set_WUSER_from_SystemVerilog(WUSER); // DPI call to imported task
        
        axi_propagate_WUSER_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WUSER or posedge _check_t0_values )
    begin
        axi_local_set_WUSER_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_BVALID_from_SystemVerilog(  );
            axi_set_BVALID_from_SystemVerilog(BVALID); // DPI call to imported task
        
        axi_propagate_BVALID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( BVALID or posedge _check_t0_values )
    begin
        axi_local_set_BVALID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_BRESP_from_SystemVerilog(  );
            axi_set_BRESP_from_SystemVerilog(BRESP); // DPI call to imported task
        
        axi_propagate_BRESP_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( BRESP or posedge _check_t0_values )
    begin
        axi_local_set_BRESP_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_BID_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ID_WIDTH ); _this_dot_1++)
        begin
            axi_set_BID_from_SystemVerilog_index1(_this_dot_1,BID[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi_propagate_BID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( BID or posedge _check_t0_values )
    begin
        axi_local_set_BID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_BREADY_from_SystemVerilog(  );
            axi_set_BREADY_from_SystemVerilog(BREADY); // DPI call to imported task
        
        axi_propagate_BREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( BREADY or posedge _check_t0_values )
    begin
        axi_local_set_BREADY_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_BUSER_from_SystemVerilog(  );
            axi_set_BUSER_from_SystemVerilog(BUSER); // DPI call to imported task
        
        axi_propagate_BUSER_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( BUSER or posedge _check_t0_values )
    begin
        axi_local_set_BUSER_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end


    // CY wire and variable changed flag monitors

    always @(posedge ACLK_changed or posedge _check_t0_values )
    begin
        while (ACLK_changed == 1'b1)
        begin
            axi_get_ACLK_into_SystemVerilog(  ); // DPI call to imported task
            ACLK_changed = 1'b0;
            #0  #0 if ( ACLK !== internal_ACLK )
            begin
                axi_local_set_ACLK_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARESETn_changed or posedge _check_t0_values )
    begin
        while (ARESETn_changed == 1'b1)
        begin
            axi_get_ARESETn_into_SystemVerilog(  ); // DPI call to imported task
            ARESETn_changed = 1'b0;
            #0  #0 if ( ARESETn !== internal_ARESETn )
            begin
                axi_local_set_ARESETn_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWVALID_changed or posedge _check_t0_values )
    begin
        while (AWVALID_changed == 1'b1)
        begin
            axi_get_AWVALID_into_SystemVerilog(  ); // DPI call to imported task
            AWVALID_changed = 1'b0;
            #0  #0 if ( AWVALID !== internal_AWVALID )
            begin
                axi_local_set_AWVALID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWADDR_changed or posedge _check_t0_values )
    begin
        while (AWADDR_changed == 1'b1)
        begin
            axi_get_AWADDR_into_SystemVerilog(  ); // DPI call to imported task
            AWADDR_changed = 1'b0;
            #0  #0 if ( AWADDR !== internal_AWADDR )
            begin
                axi_local_set_AWADDR_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWLEN_changed or posedge _check_t0_values )
    begin
        while (AWLEN_changed == 1'b1)
        begin
            axi_get_AWLEN_into_SystemVerilog(  ); // DPI call to imported task
            AWLEN_changed = 1'b0;
            #0  #0 if ( AWLEN !== internal_AWLEN )
            begin
                axi_local_set_AWLEN_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWSIZE_changed or posedge _check_t0_values )
    begin
        while (AWSIZE_changed == 1'b1)
        begin
            axi_get_AWSIZE_into_SystemVerilog(  ); // DPI call to imported task
            AWSIZE_changed = 1'b0;
            #0  #0 if ( AWSIZE !== internal_AWSIZE )
            begin
                axi_local_set_AWSIZE_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWBURST_changed or posedge _check_t0_values )
    begin
        while (AWBURST_changed == 1'b1)
        begin
            axi_get_AWBURST_into_SystemVerilog(  ); // DPI call to imported task
            AWBURST_changed = 1'b0;
            #0  #0 if ( AWBURST !== internal_AWBURST )
            begin
                axi_local_set_AWBURST_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWLOCK_changed or posedge _check_t0_values )
    begin
        while (AWLOCK_changed == 1'b1)
        begin
            axi_get_AWLOCK_into_SystemVerilog(  ); // DPI call to imported task
            AWLOCK_changed = 1'b0;
            #0  #0 if ( AWLOCK !== internal_AWLOCK )
            begin
                axi_local_set_AWLOCK_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWCACHE_changed or posedge _check_t0_values )
    begin
        while (AWCACHE_changed == 1'b1)
        begin
            axi_get_AWCACHE_into_SystemVerilog(  ); // DPI call to imported task
            AWCACHE_changed = 1'b0;
            #0  #0 if ( AWCACHE !== internal_AWCACHE )
            begin
                axi_local_set_AWCACHE_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWPROT_changed or posedge _check_t0_values )
    begin
        while (AWPROT_changed == 1'b1)
        begin
            axi_get_AWPROT_into_SystemVerilog(  ); // DPI call to imported task
            AWPROT_changed = 1'b0;
            #0  #0 if ( AWPROT !== internal_AWPROT )
            begin
                axi_local_set_AWPROT_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWID_changed or posedge _check_t0_values )
    begin
        while (AWID_changed == 1'b1)
        begin
            axi_get_AWID_into_SystemVerilog(  ); // DPI call to imported task
            AWID_changed = 1'b0;
            #0  #0 if ( AWID !== internal_AWID )
            begin
                axi_local_set_AWID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWREADY_changed or posedge _check_t0_values )
    begin
        while (AWREADY_changed == 1'b1)
        begin
            axi_get_AWREADY_into_SystemVerilog(  ); // DPI call to imported task
            AWREADY_changed = 1'b0;
            #0  #0 if ( AWREADY !== internal_AWREADY )
            begin
                axi_local_set_AWREADY_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWUSER_changed or posedge _check_t0_values )
    begin
        while (AWUSER_changed == 1'b1)
        begin
            axi_get_AWUSER_into_SystemVerilog(  ); // DPI call to imported task
            AWUSER_changed = 1'b0;
            #0  #0 if ( AWUSER !== internal_AWUSER )
            begin
                axi_local_set_AWUSER_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARVALID_changed or posedge _check_t0_values )
    begin
        while (ARVALID_changed == 1'b1)
        begin
            axi_get_ARVALID_into_SystemVerilog(  ); // DPI call to imported task
            ARVALID_changed = 1'b0;
            #0  #0 if ( ARVALID !== internal_ARVALID )
            begin
                axi_local_set_ARVALID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARADDR_changed or posedge _check_t0_values )
    begin
        while (ARADDR_changed == 1'b1)
        begin
            axi_get_ARADDR_into_SystemVerilog(  ); // DPI call to imported task
            ARADDR_changed = 1'b0;
            #0  #0 if ( ARADDR !== internal_ARADDR )
            begin
                axi_local_set_ARADDR_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARLEN_changed or posedge _check_t0_values )
    begin
        while (ARLEN_changed == 1'b1)
        begin
            axi_get_ARLEN_into_SystemVerilog(  ); // DPI call to imported task
            ARLEN_changed = 1'b0;
            #0  #0 if ( ARLEN !== internal_ARLEN )
            begin
                axi_local_set_ARLEN_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARSIZE_changed or posedge _check_t0_values )
    begin
        while (ARSIZE_changed == 1'b1)
        begin
            axi_get_ARSIZE_into_SystemVerilog(  ); // DPI call to imported task
            ARSIZE_changed = 1'b0;
            #0  #0 if ( ARSIZE !== internal_ARSIZE )
            begin
                axi_local_set_ARSIZE_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARBURST_changed or posedge _check_t0_values )
    begin
        while (ARBURST_changed == 1'b1)
        begin
            axi_get_ARBURST_into_SystemVerilog(  ); // DPI call to imported task
            ARBURST_changed = 1'b0;
            #0  #0 if ( ARBURST !== internal_ARBURST )
            begin
                axi_local_set_ARBURST_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARLOCK_changed or posedge _check_t0_values )
    begin
        while (ARLOCK_changed == 1'b1)
        begin
            axi_get_ARLOCK_into_SystemVerilog(  ); // DPI call to imported task
            ARLOCK_changed = 1'b0;
            #0  #0 if ( ARLOCK !== internal_ARLOCK )
            begin
                axi_local_set_ARLOCK_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARCACHE_changed or posedge _check_t0_values )
    begin
        while (ARCACHE_changed == 1'b1)
        begin
            axi_get_ARCACHE_into_SystemVerilog(  ); // DPI call to imported task
            ARCACHE_changed = 1'b0;
            #0  #0 if ( ARCACHE !== internal_ARCACHE )
            begin
                axi_local_set_ARCACHE_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARPROT_changed or posedge _check_t0_values )
    begin
        while (ARPROT_changed == 1'b1)
        begin
            axi_get_ARPROT_into_SystemVerilog(  ); // DPI call to imported task
            ARPROT_changed = 1'b0;
            #0  #0 if ( ARPROT !== internal_ARPROT )
            begin
                axi_local_set_ARPROT_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARID_changed or posedge _check_t0_values )
    begin
        while (ARID_changed == 1'b1)
        begin
            axi_get_ARID_into_SystemVerilog(  ); // DPI call to imported task
            ARID_changed = 1'b0;
            #0  #0 if ( ARID !== internal_ARID )
            begin
                axi_local_set_ARID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARREADY_changed or posedge _check_t0_values )
    begin
        while (ARREADY_changed == 1'b1)
        begin
            axi_get_ARREADY_into_SystemVerilog(  ); // DPI call to imported task
            ARREADY_changed = 1'b0;
            #0  #0 if ( ARREADY !== internal_ARREADY )
            begin
                axi_local_set_ARREADY_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARUSER_changed or posedge _check_t0_values )
    begin
        while (ARUSER_changed == 1'b1)
        begin
            axi_get_ARUSER_into_SystemVerilog(  ); // DPI call to imported task
            ARUSER_changed = 1'b0;
            #0  #0 if ( ARUSER !== internal_ARUSER )
            begin
                axi_local_set_ARUSER_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RVALID_changed or posedge _check_t0_values )
    begin
        while (RVALID_changed == 1'b1)
        begin
            axi_get_RVALID_into_SystemVerilog(  ); // DPI call to imported task
            RVALID_changed = 1'b0;
            #0  #0 if ( RVALID !== internal_RVALID )
            begin
                axi_local_set_RVALID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RLAST_changed or posedge _check_t0_values )
    begin
        while (RLAST_changed == 1'b1)
        begin
            axi_get_RLAST_into_SystemVerilog(  ); // DPI call to imported task
            RLAST_changed = 1'b0;
            #0  #0 if ( RLAST !== internal_RLAST )
            begin
                axi_local_set_RLAST_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RDATA_changed or posedge _check_t0_values )
    begin
        while (RDATA_changed == 1'b1)
        begin
            axi_get_RDATA_into_SystemVerilog(  ); // DPI call to imported task
            RDATA_changed = 1'b0;
            #0  #0 if ( RDATA !== internal_RDATA )
            begin
                axi_local_set_RDATA_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RRESP_changed or posedge _check_t0_values )
    begin
        while (RRESP_changed == 1'b1)
        begin
            axi_get_RRESP_into_SystemVerilog(  ); // DPI call to imported task
            RRESP_changed = 1'b0;
            #0  #0 if ( RRESP !== internal_RRESP )
            begin
                axi_local_set_RRESP_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RID_changed or posedge _check_t0_values )
    begin
        while (RID_changed == 1'b1)
        begin
            axi_get_RID_into_SystemVerilog(  ); // DPI call to imported task
            RID_changed = 1'b0;
            #0  #0 if ( RID !== internal_RID )
            begin
                axi_local_set_RID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RREADY_changed or posedge _check_t0_values )
    begin
        while (RREADY_changed == 1'b1)
        begin
            axi_get_RREADY_into_SystemVerilog(  ); // DPI call to imported task
            RREADY_changed = 1'b0;
            #0  #0 if ( RREADY !== internal_RREADY )
            begin
                axi_local_set_RREADY_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RUSER_changed or posedge _check_t0_values )
    begin
        while (RUSER_changed == 1'b1)
        begin
            axi_get_RUSER_into_SystemVerilog(  ); // DPI call to imported task
            RUSER_changed = 1'b0;
            #0  #0 if ( RUSER !== internal_RUSER )
            begin
                axi_local_set_RUSER_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WVALID_changed or posedge _check_t0_values )
    begin
        while (WVALID_changed == 1'b1)
        begin
            axi_get_WVALID_into_SystemVerilog(  ); // DPI call to imported task
            WVALID_changed = 1'b0;
            #0  #0 if ( WVALID !== internal_WVALID )
            begin
                axi_local_set_WVALID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WLAST_changed or posedge _check_t0_values )
    begin
        while (WLAST_changed == 1'b1)
        begin
            axi_get_WLAST_into_SystemVerilog(  ); // DPI call to imported task
            WLAST_changed = 1'b0;
            #0  #0 if ( WLAST !== internal_WLAST )
            begin
                axi_local_set_WLAST_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WDATA_changed or posedge _check_t0_values )
    begin
        while (WDATA_changed == 1'b1)
        begin
            axi_get_WDATA_into_SystemVerilog(  ); // DPI call to imported task
            WDATA_changed = 1'b0;
            #0  #0 if ( WDATA !== internal_WDATA )
            begin
                axi_local_set_WDATA_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WSTRB_changed or posedge _check_t0_values )
    begin
        while (WSTRB_changed == 1'b1)
        begin
            axi_get_WSTRB_into_SystemVerilog(  ); // DPI call to imported task
            WSTRB_changed = 1'b0;
            #0  #0 if ( WSTRB !== internal_WSTRB )
            begin
                axi_local_set_WSTRB_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WID_changed or posedge _check_t0_values )
    begin
        while (WID_changed == 1'b1)
        begin
            axi_get_WID_into_SystemVerilog(  ); // DPI call to imported task
            WID_changed = 1'b0;
            #0  #0 if ( WID !== internal_WID )
            begin
                axi_local_set_WID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WREADY_changed or posedge _check_t0_values )
    begin
        while (WREADY_changed == 1'b1)
        begin
            axi_get_WREADY_into_SystemVerilog(  ); // DPI call to imported task
            WREADY_changed = 1'b0;
            #0  #0 if ( WREADY !== internal_WREADY )
            begin
                axi_local_set_WREADY_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WUSER_changed or posedge _check_t0_values )
    begin
        while (WUSER_changed == 1'b1)
        begin
            axi_get_WUSER_into_SystemVerilog(  ); // DPI call to imported task
            WUSER_changed = 1'b0;
            #0  #0 if ( WUSER !== internal_WUSER )
            begin
                axi_local_set_WUSER_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge BVALID_changed or posedge _check_t0_values )
    begin
        while (BVALID_changed == 1'b1)
        begin
            axi_get_BVALID_into_SystemVerilog(  ); // DPI call to imported task
            BVALID_changed = 1'b0;
            #0  #0 if ( BVALID !== internal_BVALID )
            begin
                axi_local_set_BVALID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge BRESP_changed or posedge _check_t0_values )
    begin
        while (BRESP_changed == 1'b1)
        begin
            axi_get_BRESP_into_SystemVerilog(  ); // DPI call to imported task
            BRESP_changed = 1'b0;
            #0  #0 if ( BRESP !== internal_BRESP )
            begin
                axi_local_set_BRESP_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge BID_changed or posedge _check_t0_values )
    begin
        while (BID_changed == 1'b1)
        begin
            axi_get_BID_into_SystemVerilog(  ); // DPI call to imported task
            BID_changed = 1'b0;
            #0  #0 if ( BID !== internal_BID )
            begin
                axi_local_set_BID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge BREADY_changed or posedge _check_t0_values )
    begin
        while (BREADY_changed == 1'b1)
        begin
            axi_get_BREADY_into_SystemVerilog(  ); // DPI call to imported task
            BREADY_changed = 1'b0;
            #0  #0 if ( BREADY !== internal_BREADY )
            begin
                axi_local_set_BREADY_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge BUSER_changed or posedge _check_t0_values )
    begin
        while (BUSER_changed == 1'b1)
        begin
            axi_get_BUSER_into_SystemVerilog(  ); // DPI call to imported task
            BUSER_changed = 1'b0;
            #0  #0 if ( BUSER !== internal_BUSER )
            begin
                axi_local_set_BUSER_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge config_clk_init_value_changed or posedge _check_t0_values )
    begin
        if (config_clk_init_value_changed == 1'b1)
        begin
            axi_get_config_clk_init_value_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_init_value_changed = 1'b0;
        end
    end

    always @(posedge config_clk_phase_shift_changed or posedge _check_t0_values )
    begin
        if (config_clk_phase_shift_changed == 1'b1)
        begin
            axi_get_config_clk_phase_shift_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_phase_shift_changed = 1'b0;
        end
    end

    always @(posedge config_clk_1st_time_changed or posedge _check_t0_values )
    begin
        if (config_clk_1st_time_changed == 1'b1)
        begin
            axi_get_config_clk_1st_time_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_1st_time_changed = 1'b0;
        end
    end

    always @(posedge config_clk_2nd_time_changed or posedge _check_t0_values )
    begin
        if (config_clk_2nd_time_changed == 1'b1)
        begin
            axi_get_config_clk_2nd_time_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_2nd_time_changed = 1'b0;
        end
    end

    always @(posedge config_setup_time_changed or posedge _check_t0_values )
    begin
        if (config_setup_time_changed == 1'b1)
        begin
            axi_get_config_setup_time_into_SystemVerilog(  ); // DPI call to imported task
            config_setup_time_changed = 1'b0;
        end
    end

    always @(posedge config_hold_time_changed or posedge _check_t0_values )
    begin
        if (config_hold_time_changed == 1'b1)
        begin
            axi_get_config_hold_time_into_SystemVerilog(  ); // DPI call to imported task
            config_hold_time_changed = 1'b0;
        end
    end

    always @(posedge config_max_transaction_time_factor_changed or posedge _check_t0_values )
    begin
        if (config_max_transaction_time_factor_changed == 1'b1)
        begin
            axi_get_config_max_transaction_time_factor_into_SystemVerilog(  ); // DPI call to imported task
            config_max_transaction_time_factor_changed = 1'b0;
        end
    end

    always @(posedge config_timeout_max_data_transfer_changed or posedge _check_t0_values )
    begin
        if (config_timeout_max_data_transfer_changed == 1'b1)
        begin
            axi_get_config_timeout_max_data_transfer_into_SystemVerilog(  ); // DPI call to imported task
            config_timeout_max_data_transfer_changed = 1'b0;
        end
    end

    always @(posedge config_burst_timeout_factor_changed or posedge _check_t0_values )
    begin
        if (config_burst_timeout_factor_changed == 1'b1)
        begin
            axi_get_config_burst_timeout_factor_into_SystemVerilog(  ); // DPI call to imported task
            config_burst_timeout_factor_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_AWVALID_assertion_to_AWREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_AWVALID_assertion_to_AWREADY_changed == 1'b1)
        begin
            axi_get_config_max_latency_AWVALID_assertion_to_AWREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_AWVALID_assertion_to_AWREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_ARVALID_assertion_to_ARREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_ARVALID_assertion_to_ARREADY_changed == 1'b1)
        begin
            axi_get_config_max_latency_ARVALID_assertion_to_ARREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_ARVALID_assertion_to_ARREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_RVALID_assertion_to_RREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_RVALID_assertion_to_RREADY_changed == 1'b1)
        begin
            axi_get_config_max_latency_RVALID_assertion_to_RREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_RVALID_assertion_to_RREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_BVALID_assertion_to_BREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_BVALID_assertion_to_BREADY_changed == 1'b1)
        begin
            axi_get_config_max_latency_BVALID_assertion_to_BREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_BVALID_assertion_to_BREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_WVALID_assertion_to_WREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_WVALID_assertion_to_WREADY_changed == 1'b1)
        begin
            axi_get_config_max_latency_WVALID_assertion_to_WREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_WVALID_assertion_to_WREADY_changed = 1'b0;
        end
    end

    always @(posedge config_write_ctrl_first_ratio_changed or posedge _check_t0_values )
    begin
        if (config_write_ctrl_first_ratio_changed == 1'b1)
        begin
            axi_get_config_write_ctrl_first_ratio_into_SystemVerilog(  ); // DPI call to imported task
            config_write_ctrl_first_ratio_changed = 1'b0;
        end
    end

    always @(posedge config_write_data_first_ratio_changed or posedge _check_t0_values )
    begin
        if (config_write_data_first_ratio_changed == 1'b1)
        begin
            axi_get_config_write_data_first_ratio_into_SystemVerilog(  ); // DPI call to imported task
            config_write_data_first_ratio_changed = 1'b0;
        end
    end

    always @(posedge config_write_ctrl_to_data_mintime_changed or posedge _check_t0_values )
    begin
        if (config_write_ctrl_to_data_mintime_changed == 1'b1)
        begin
            axi_get_config_write_ctrl_to_data_mintime_into_SystemVerilog(  ); // DPI call to imported task
            config_write_ctrl_to_data_mintime_changed = 1'b0;
        end
    end

    always @(posedge config_write_data_to_ctrl_mintime_changed or posedge _check_t0_values )
    begin
        if (config_write_data_to_ctrl_mintime_changed == 1'b1)
        begin
            axi_get_config_write_data_to_ctrl_mintime_into_SystemVerilog(  ); // DPI call to imported task
            config_write_data_to_ctrl_mintime_changed = 1'b0;
        end
    end

    always @(posedge config_master_write_delay_changed or posedge _check_t0_values )
    begin
        if (config_master_write_delay_changed == 1'b1)
        begin
            axi_get_config_master_write_delay_into_SystemVerilog(  ); // DPI call to imported task
            config_master_write_delay_changed = 1'b0;
        end
    end

    always @(posedge config_reset_low_clocks_changed or posedge _check_t0_values )
    begin
        if (config_reset_low_clocks_changed == 1'b1)
        begin
            axi_get_config_reset_low_clocks_into_SystemVerilog(  ); // DPI call to imported task
            config_reset_low_clocks_changed = 1'b0;
        end
    end

    always @(posedge config_reset_hold_time_changed or posedge _check_t0_values )
    begin
        if (config_reset_hold_time_changed == 1'b1)
        begin
            axi_get_config_reset_hold_time_into_SystemVerilog(  ); // DPI call to imported task
            config_reset_hold_time_changed = 1'b0;
        end
    end

    always @(posedge config_protect_ready_changed or posedge _check_t0_values )
    begin
        if (config_protect_ready_changed == 1'b1)
        begin
            axi_get_config_protect_ready_into_SystemVerilog(  ); // DPI call to imported task
            config_protect_ready_changed = 1'b0;
        end
    end

    always @(posedge config_enable_user_sideband_changed or posedge _check_t0_values )
    begin
        if (config_enable_user_sideband_changed == 1'b1)
        begin
            axi_get_config_enable_user_sideband_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_user_sideband_changed = 1'b0;
        end
    end

    always @(posedge config_extended_length_enable_changed or posedge _check_t0_values )
    begin
        if (config_extended_length_enable_changed == 1'b1)
        begin
            axi_get_config_extended_length_enable_into_SystemVerilog(  ); // DPI call to imported task
            config_extended_length_enable_changed = 1'b0;
        end
    end

    always @(posedge config_enable_burst_reserved_value_changed or posedge _check_t0_values )
    begin
        if (config_enable_burst_reserved_value_changed == 1'b1)
        begin
            axi_get_config_enable_burst_reserved_value_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_burst_reserved_value_changed = 1'b0;
        end
    end

    always @(posedge config_enable_lock_reserved_value_changed or posedge _check_t0_values )
    begin
        if (config_enable_lock_reserved_value_changed == 1'b1)
        begin
            axi_get_config_enable_lock_reserved_value_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_lock_reserved_value_changed = 1'b0;
        end
    end

    always @(posedge config_enable_cache_reserved_value_changed or posedge _check_t0_values )
    begin
        if (config_enable_cache_reserved_value_changed == 1'b1)
        begin
            axi_get_config_enable_cache_reserved_value_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_cache_reserved_value_changed = 1'b0;
        end
    end

    always @(posedge config_enable_all_assertions_changed or posedge _check_t0_values )
    begin
        if (config_enable_all_assertions_changed == 1'b1)
        begin
            axi_get_config_enable_all_assertions_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_all_assertions_changed = 1'b0;
        end
    end

    always @(posedge config_enable_assertion_changed or posedge _check_t0_values )
    begin
        if (config_enable_assertion_changed == 1'b1)
        begin
            axi_get_config_enable_assertion_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_assertion_changed = 1'b0;
        end
    end

    always @(posedge config_enable_error_changed or posedge _check_t0_values )
    begin
        if (config_enable_error_changed == 1'b1)
        begin
            axi_get_config_enable_error_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_error_changed = 1'b0;
        end
    end

    always @(posedge config_enable_errors_changed or posedge _check_t0_values )
    begin
        if (config_enable_errors_changed == 1'b1)
        begin
            axi_get_config_enable_errors_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_errors_changed = 1'b0;
        end
    end

    always @(posedge config_enable_all_assertion_errors_changed or posedge _check_t0_values )
    begin
        if (config_enable_all_assertion_errors_changed == 1'b1)
        begin
            axi_get_config_enable_all_assertion_errors_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_all_assertion_errors_changed = 1'b0;
        end
    end

    always @(posedge config_abstraction_level_changed or posedge _check_t0_values )
    begin
        if (config_abstraction_level_changed == 1'b1)
        begin
            axi_get_config_abstraction_level_into_SystemVerilog(  ); // DPI call to imported task
            config_abstraction_level_changed = 1'b0;
        end
    end

    always @(posedge config_slave_start_addr_changed or posedge _check_t0_values )
    begin
        if (config_slave_start_addr_changed == 1'b1)
        begin
            axi_get_config_slave_start_addr_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_start_addr_changed = 1'b0;
        end
    end

    always @(posedge config_slave_end_addr_changed or posedge _check_t0_values )
    begin
        if (config_slave_end_addr_changed == 1'b1)
        begin
            axi_get_config_slave_end_addr_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_end_addr_changed = 1'b0;
        end
    end

    always @(posedge config_enable_slave_addr_range_in_bfm_changed or posedge _check_t0_values )
    begin
        if (config_enable_slave_addr_range_in_bfm_changed == 1'b1)
        begin
            axi_get_config_enable_slave_addr_range_in_bfm_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_slave_addr_range_in_bfm_changed = 1'b0;
        end
    end

    always @(posedge config_read_data_reordering_depth_changed or posedge _check_t0_values )
    begin
        if (config_read_data_reordering_depth_changed == 1'b1)
        begin
            axi_get_config_read_data_reordering_depth_into_SystemVerilog(  ); // DPI call to imported task
            config_read_data_reordering_depth_changed = 1'b0;
        end
    end

    always @(posedge config_enable_read_data_reordering_depth_in_bfm_changed or posedge _check_t0_values )
    begin
        if (config_enable_read_data_reordering_depth_in_bfm_changed == 1'b1)
        begin
            axi_get_config_enable_read_data_reordering_depth_in_bfm_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_read_data_reordering_depth_in_bfm_changed = 1'b0;
        end
    end

    always @(posedge config_awid_wid_mismatch_changed or posedge _check_t0_values )
    begin
        if (config_awid_wid_mismatch_changed == 1'b1)
        begin
            axi_get_config_awid_wid_mismatch_into_SystemVerilog(  ); // DPI call to imported task
            config_awid_wid_mismatch_changed = 1'b0;
        end
    end

    always @(posedge config_length_last_mismatch_error_changed or posedge _check_t0_values )
    begin
        if (config_length_last_mismatch_error_changed == 1'b1)
        begin
            axi_get_config_length_last_mismatch_error_into_SystemVerilog(  ); // DPI call to imported task
            config_length_last_mismatch_error_changed = 1'b0;
        end
    end

    always @(posedge config_master_error_position_changed or posedge _check_t0_values )
    begin
        if (config_master_error_position_changed == 1'b1)
        begin
            axi_get_config_master_error_position_into_SystemVerilog(  ); // DPI call to imported task
            config_master_error_position_changed = 1'b0;
        end
    end

    always @(posedge dummy_var_changed or posedge _check_t0_values )
    begin
        if (dummy_var_changed == 1'b1)
        begin
            axi_get_dummy_var_into_SystemVerilog(  ); // DPI call to imported task
            dummy_var_changed = 1'b0;
        end
    end

    always @(posedge config_wlast_length_changed or posedge _check_t0_values )
    begin
        if (config_wlast_length_changed == 1'b1)
        begin
            axi_get_config_wlast_length_into_SystemVerilog(  ); // DPI call to imported task
            config_wlast_length_changed = 1'b0;
        end
    end

    always @(posedge config_wid_for_awid_not_matching_changed or posedge _check_t0_values )
    begin
        if (config_wid_for_awid_not_matching_changed == 1'b1)
        begin
            axi_get_config_wid_for_awid_not_matching_into_SystemVerilog(  ); // DPI call to imported task
            config_wid_for_awid_not_matching_changed = 1'b0;
        end
    end

    always @(posedge config_support_exclusive_access_changed or posedge _check_t0_values )
    begin
        if (config_support_exclusive_access_changed == 1'b1)
        begin
            axi_get_config_support_exclusive_access_into_SystemVerilog(  ); // DPI call to imported task
            config_support_exclusive_access_changed = 1'b0;
        end
    end

    always @(posedge config_write_data_interleaving_depth_changed or posedge _check_t0_values )
    begin
        if (config_write_data_interleaving_depth_changed == 1'b1)
        begin
            axi_get_config_write_data_interleaving_depth_into_SystemVerilog(  ); // DPI call to imported task
            config_write_data_interleaving_depth_changed = 1'b0;
        end
    end

    always @(posedge status_master_error_changed or posedge _check_t0_values )
    begin
        if (status_master_error_changed == 1'b1)
        begin
            axi_get_status_master_error_into_SystemVerilog(  ); // DPI call to imported task
            status_master_error_changed = 1'b0;
        end
    end

    always @(posedge status_num_reads_waiting_for_resp_changed or posedge _check_t0_values )
    begin
        if (status_num_reads_waiting_for_resp_changed == 1'b1)
        begin
            axi_get_status_num_reads_waiting_for_resp_into_SystemVerilog(  ); // DPI call to imported task
            status_num_reads_waiting_for_resp_changed = 1'b0;
        end
    end

    always @(posedge status_num_writes_waiting_for_response_changed or posedge _check_t0_values )
    begin
        if (status_num_writes_waiting_for_response_changed == 1'b1)
        begin
            axi_get_status_num_writes_waiting_for_response_into_SystemVerilog(  ); // DPI call to imported task
            status_num_writes_waiting_for_response_changed = 1'b0;
        end
    end

    always @(posedge check_total_num_wdata_outstanding_changed or posedge _check_t0_values )
    begin
        if (check_total_num_wdata_outstanding_changed == 1'b1)
        begin
            axi_get_check_total_num_wdata_outstanding_into_SystemVerilog(  ); // DPI call to imported task
            check_total_num_wdata_outstanding_changed = 1'b0;
        end
    end

    always @(posedge total_num_wdata_outstanding_changed or posedge _check_t0_values )
    begin
        if (total_num_wdata_outstanding_changed == 1'b1)
        begin
            axi_get_total_num_wdata_outstanding_into_SystemVerilog(  ); // DPI call to imported task
            total_num_wdata_outstanding_changed = 1'b0;
        end
    end

    always @(posedge check_max_num_wdata_outstanding_per_id_changed or posedge _check_t0_values )
    begin
        if (check_max_num_wdata_outstanding_per_id_changed == 1'b1)
        begin
            axi_get_check_max_num_wdata_outstanding_per_id_into_SystemVerilog(  ); // DPI call to imported task
            check_max_num_wdata_outstanding_per_id_changed = 1'b0;
        end
    end

    always @(posedge max_num_wdata_outstanding_per_id_changed or posedge _check_t0_values )
    begin
        if (max_num_wdata_outstanding_per_id_changed == 1'b1)
        begin
            axi_get_max_num_wdata_outstanding_per_id_into_SystemVerilog(  ); // DPI call to imported task
            max_num_wdata_outstanding_per_id_changed = 1'b0;
        end
    end

    always @(posedge check_max_num_waddr_outstanding_per_id_changed or posedge _check_t0_values )
    begin
        if (check_max_num_waddr_outstanding_per_id_changed == 1'b1)
        begin
            axi_get_check_max_num_waddr_outstanding_per_id_into_SystemVerilog(  ); // DPI call to imported task
            check_max_num_waddr_outstanding_per_id_changed = 1'b0;
        end
    end

    always @(posedge max_num_waddr_outstanding_per_id_changed or posedge _check_t0_values )
    begin
        if (max_num_waddr_outstanding_per_id_changed == 1'b1)
        begin
            axi_get_max_num_waddr_outstanding_per_id_into_SystemVerilog(  ); // DPI call to imported task
            max_num_waddr_outstanding_per_id_changed = 1'b0;
        end
    end

    always @(posedge check_total_num_waddr_outstanding_changed or posedge _check_t0_values )
    begin
        if (check_total_num_waddr_outstanding_changed == 1'b1)
        begin
            axi_get_check_total_num_waddr_outstanding_into_SystemVerilog(  ); // DPI call to imported task
            check_total_num_waddr_outstanding_changed = 1'b0;
        end
    end

    always @(posedge total_num_waddr_outstanding_changed or posedge _check_t0_values )
    begin
        if (total_num_waddr_outstanding_changed == 1'b1)
        begin
            axi_get_total_num_waddr_outstanding_into_SystemVerilog(  ); // DPI call to imported task
            total_num_waddr_outstanding_changed = 1'b0;
        end
    end

    always @(posedge status_outstanding_num_for_waddr_changed or posedge _check_t0_values )
    begin
        if (status_outstanding_num_for_waddr_changed == 1'b1)
        begin
            axi_get_status_outstanding_num_for_waddr_into_SystemVerilog(  ); // DPI call to imported task
            status_outstanding_num_for_waddr_changed = 1'b0;
        end
    end

    always @(posedge start_finding_outstanding_waddr_changed or posedge _check_t0_values )
    begin
        if (start_finding_outstanding_waddr_changed == 1'b1)
        begin
            axi_get_start_finding_outstanding_waddr_into_SystemVerilog(  ); // DPI call to imported task
            start_finding_outstanding_waddr_changed = 1'b0;
        end
    end

    always @(posedge status_outstanding_num_for_wdata_changed or posedge _check_t0_values )
    begin
        if (status_outstanding_num_for_wdata_changed == 1'b1)
        begin
            axi_get_status_outstanding_num_for_wdata_into_SystemVerilog(  ); // DPI call to imported task
            status_outstanding_num_for_wdata_changed = 1'b0;
        end
    end

    always @(posedge start_finding_outstanding_wdata_changed or posedge _check_t0_values )
    begin
        if (start_finding_outstanding_wdata_changed == 1'b1)
        begin
            axi_get_start_finding_outstanding_wdata_into_SystemVerilog(  ); // DPI call to imported task
            start_finding_outstanding_wdata_changed = 1'b0;
        end
    end

    always @(posedge find_waddr_outstanding_for_wid_changed or posedge _check_t0_values )
    begin
        if (find_waddr_outstanding_for_wid_changed == 1'b1)
        begin
            axi_get_find_waddr_outstanding_for_wid_into_SystemVerilog(  ); // DPI call to imported task
            find_waddr_outstanding_for_wid_changed = 1'b0;
        end
    end

    always @(posedge find_wdata_outstanding_for_wid_changed or posedge _check_t0_values )
    begin
        if (find_wdata_outstanding_for_wid_changed == 1'b1)
        begin
            axi_get_find_wdata_outstanding_for_wid_into_SystemVerilog(  ); // DPI call to imported task
            find_wdata_outstanding_for_wid_changed = 1'b0;
        end
    end

    always @(posedge change_in_wdata_outstanding_per_id_changed or posedge _check_t0_values )
    begin
        if (change_in_wdata_outstanding_per_id_changed == 1'b1)
        begin
            axi_get_change_in_wdata_outstanding_per_id_into_SystemVerilog(  ); // DPI call to imported task
            change_in_wdata_outstanding_per_id_changed = 1'b0;
        end
    end

    always @(posedge start_finding_change_in_wdata_changed or posedge _check_t0_values )
    begin
        if (start_finding_change_in_wdata_changed == 1'b1)
        begin
            axi_get_start_finding_change_in_wdata_into_SystemVerilog(  ); // DPI call to imported task
            start_finding_change_in_wdata_changed = 1'b0;
        end
    end

    always @(posedge find_change_in_wdata_outstanding_for_wid_changed or posedge _check_t0_values )
    begin
        if (find_change_in_wdata_outstanding_for_wid_changed == 1'b1)
        begin
            axi_get_find_change_in_wdata_outstanding_for_wid_into_SystemVerilog(  ); // DPI call to imported task
            find_change_in_wdata_outstanding_for_wid_changed = 1'b0;
        end
    end

    always @(posedge config_max_outstanding_wr_changed or posedge _check_t0_values )
    begin
        if (config_max_outstanding_wr_changed == 1'b1)
        begin
            axi_get_config_max_outstanding_wr_into_SystemVerilog(  ); // DPI call to imported task
            config_max_outstanding_wr_changed = 1'b0;
        end
    end

    always @(posedge config_max_outstanding_rd_changed or posedge _check_t0_values )
    begin
        if (config_max_outstanding_rd_changed == 1'b1)
        begin
            axi_get_config_max_outstanding_rd_into_SystemVerilog(  ); // DPI call to imported task
            config_max_outstanding_rd_changed = 1'b0;
        end
    end

    always @(posedge config_error_on_deleted_valid_cycles_changed or posedge _check_t0_values )
    begin
        if (config_error_on_deleted_valid_cycles_changed == 1'b1)
        begin
            axi_get_config_error_on_deleted_valid_cycles_into_SystemVerilog(  ); // DPI call to imported task
            config_error_on_deleted_valid_cycles_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_changed == 1'b1)
        begin
            axi_get_config_stats_enable_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_AXI_read_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_AXI_read_occupancy_changed == 1'b1)
        begin
            axi_get_config_stats_enable_AXI_read_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_AXI_read_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_AXI_write_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_AXI_write_occupancy_changed == 1'b1)
        begin
            axi_get_config_stats_enable_AXI_write_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_AXI_write_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_data_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_data_occupancy_changed == 1'b1)
        begin
            axi_get_config_stats_enable_read_data_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_data_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_data_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_data_occupancy_changed == 1'b1)
        begin
            axi_get_config_stats_enable_write_data_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_data_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_latency_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_latency_changed == 1'b1)
        begin
            axi_get_config_stats_enable_read_latency_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_latency_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_latency_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_latency_changed == 1'b1)
        begin
            axi_get_config_stats_enable_write_latency_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_latency_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_address_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_address_waits_changed == 1'b1)
        begin
            axi_get_config_stats_enable_read_address_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_address_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_data_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_data_waits_changed == 1'b1)
        begin
            axi_get_config_stats_enable_read_data_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_data_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_address_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_address_waits_changed == 1'b1)
        begin
            axi_get_config_stats_enable_write_address_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_address_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_data_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_data_waits_changed == 1'b1)
        begin
            axi_get_config_stats_enable_write_data_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_data_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_response_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_response_waits_changed == 1'b1)
        begin
            axi_get_config_stats_enable_write_response_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_response_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_bandwidth_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_bandwidth_changed == 1'b1)
        begin
            axi_get_config_stats_enable_read_bandwidth_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_bandwidth_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_bandwidth_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_bandwidth_changed == 1'b1)
        begin
            axi_get_config_stats_enable_write_bandwidth_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_bandwidth_changed = 1'b0;
        end
    end

    always @(posedge config_stats_AXI_read_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_AXI_read_occupancy_step_changed == 1'b1)
        begin
            axi_get_config_stats_AXI_read_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_AXI_read_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_AXI_read_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_AXI_read_occupancy_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_AXI_read_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_AXI_read_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_active_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_active_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_active_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_active_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_occupancy_sw_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_occupancy_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_occupancy_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_occupancy_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_occupancy_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_idle_sw_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_occupancy_min_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_idle_min_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_occupancy_max_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_idle_max_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_occupancy_mean_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_idle_mean_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_AXI_write_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_AXI_write_occupancy_step_changed == 1'b1)
        begin
            axi_get_config_stats_AXI_write_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_AXI_write_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_AXI_write_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_AXI_write_occupancy_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_AXI_write_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_AXI_write_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_active_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_active_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_active_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_active_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_occupancy_sw_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_occupancy_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_occupancy_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_occupancy_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_occupancy_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_idle_sw_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_occupancy_min_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_idle_min_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_occupancy_max_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_idle_max_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_occupancy_mean_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_idle_mean_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_occupancy_step_changed == 1'b1)
        begin
            axi_get_config_stats_read_data_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_occupancy_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_read_data_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_sw_changed == 1'b1)
        begin
            axi_get_stats_read_data_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_read_data_occupancy_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_sw_changed == 1'b1)
        begin
            axi_get_stats_read_data_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_min_changed == 1'b1)
        begin
            axi_get_stats_read_data_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_min_changed == 1'b1)
        begin
            axi_get_stats_read_data_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_max_changed == 1'b1)
        begin
            axi_get_stats_read_data_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_max_changed == 1'b1)
        begin
            axi_get_stats_read_data_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_mean_changed == 1'b1)
        begin
            axi_get_stats_read_data_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_mean_changed == 1'b1)
        begin
            axi_get_stats_read_data_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_occupancy_step_changed == 1'b1)
        begin
            axi_get_config_stats_write_data_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_occupancy_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_write_data_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_sw_changed == 1'b1)
        begin
            axi_get_stats_write_data_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_write_data_occupancy_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_sw_changed == 1'b1)
        begin
            axi_get_stats_write_data_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_min_changed == 1'b1)
        begin
            axi_get_stats_write_data_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_min_changed == 1'b1)
        begin
            axi_get_stats_write_data_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_max_changed == 1'b1)
        begin
            axi_get_stats_write_data_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_max_changed == 1'b1)
        begin
            axi_get_stats_write_data_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_mean_changed == 1'b1)
        begin
            axi_get_stats_write_data_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_mean_changed == 1'b1)
        begin
            axi_get_stats_write_data_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_bandwidth_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_bandwidth_step_changed == 1'b1)
        begin
            axi_get_config_stats_read_bandwidth_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_bandwidth_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_bandwidth_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_bandwidth_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_read_bandwidth_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_bandwidth_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_sw_changed == 1'b1)
        begin
            axi_get_stats_read_bandwidth_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_read_bandwidth_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_min_changed == 1'b1)
        begin
            axi_get_stats_read_bandwidth_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_max_changed == 1'b1)
        begin
            axi_get_stats_read_bandwidth_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_mean_changed == 1'b1)
        begin
            axi_get_stats_read_bandwidth_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_bandwidth_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_bandwidth_step_changed == 1'b1)
        begin
            axi_get_config_stats_write_bandwidth_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_bandwidth_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_bandwidth_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_bandwidth_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_write_bandwidth_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_bandwidth_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_sw_changed == 1'b1)
        begin
            axi_get_stats_write_bandwidth_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_write_bandwidth_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_min_changed == 1'b1)
        begin
            axi_get_stats_write_bandwidth_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_max_changed == 1'b1)
        begin
            axi_get_stats_write_bandwidth_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_mean_changed == 1'b1)
        begin
            axi_get_stats_write_bandwidth_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_latency_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_latency_step_changed == 1'b1)
        begin
            axi_get_config_stats_read_latency_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_latency_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_latency_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_latency_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_read_latency_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_latency_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_latency_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_read_latency_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_read_latency_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_latency_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_inst_changed == 1'b1)
        begin
            axi_get_stats_read_address_data_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_sw_changed == 1'b1)
        begin
            axi_get_stats_read_address_data_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_min_changed == 1'b1)
        begin
            axi_get_stats_read_address_data_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_max_changed == 1'b1)
        begin
            axi_get_stats_read_address_data_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_mean_changed == 1'b1)
        begin
            axi_get_stats_read_address_data_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_inst_changed == 1'b1)
        begin
            axi_get_stats_read_address_address_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_sw_changed == 1'b1)
        begin
            axi_get_stats_read_address_address_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_min_changed == 1'b1)
        begin
            axi_get_stats_read_address_address_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_max_changed == 1'b1)
        begin
            axi_get_stats_read_address_address_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_mean_changed == 1'b1)
        begin
            axi_get_stats_read_address_address_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_latency_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_latency_step_changed == 1'b1)
        begin
            axi_get_config_stats_write_latency_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_latency_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_latency_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_latency_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_write_latency_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_latency_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_latency_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_write_latency_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_write_latency_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_latency_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_data_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_data_latency_inst_changed == 1'b1)
        begin
            axi_get_stats_write_address_data_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_data_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_data_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_data_latency_sw_changed == 1'b1)
        begin
            axi_get_stats_write_address_data_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_data_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_data_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_data_latency_min_changed == 1'b1)
        begin
            axi_get_stats_write_address_data_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_data_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_data_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_data_latency_max_changed == 1'b1)
        begin
            axi_get_stats_write_address_data_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_data_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_data_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_data_latency_mean_changed == 1'b1)
        begin
            axi_get_stats_write_address_data_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_data_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_response_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_response_latency_inst_changed == 1'b1)
        begin
            axi_get_stats_write_data_response_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_response_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_response_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_response_latency_sw_changed == 1'b1)
        begin
            axi_get_stats_write_data_response_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_response_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_response_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_response_latency_min_changed == 1'b1)
        begin
            axi_get_stats_write_data_response_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_response_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_response_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_response_latency_max_changed == 1'b1)
        begin
            axi_get_stats_write_data_response_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_response_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_response_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_response_latency_mean_changed == 1'b1)
        begin
            axi_get_stats_write_data_response_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_response_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_inst_changed == 1'b1)
        begin
            axi_get_stats_write_address_address_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_sw_changed == 1'b1)
        begin
            axi_get_stats_write_address_address_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_min_changed == 1'b1)
        begin
            axi_get_stats_write_address_address_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_max_changed == 1'b1)
        begin
            axi_get_stats_write_address_address_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_mean_changed == 1'b1)
        begin
            axi_get_stats_write_address_address_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_address_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_address_waits_step_changed == 1'b1)
        begin
            axi_get_config_stats_read_address_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_address_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_address_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_address_waits_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_read_address_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_address_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_inst_changed == 1'b1)
        begin
            axi_get_stats_read_address_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_sw_changed == 1'b1)
        begin
            axi_get_stats_read_address_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_read_address_waits_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_min_changed == 1'b1)
        begin
            axi_get_stats_read_address_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_max_changed == 1'b1)
        begin
            axi_get_stats_read_address_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_mean_changed == 1'b1)
        begin
            axi_get_stats_read_address_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_waits_step_changed == 1'b1)
        begin
            axi_get_config_stats_read_data_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_waits_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_read_data_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_inst_changed == 1'b1)
        begin
            axi_get_stats_read_data_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_sw_changed == 1'b1)
        begin
            axi_get_stats_read_data_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_read_data_waits_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_min_changed == 1'b1)
        begin
            axi_get_stats_read_data_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_max_changed == 1'b1)
        begin
            axi_get_stats_read_data_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_mean_changed == 1'b1)
        begin
            axi_get_stats_read_data_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_address_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_address_waits_step_changed == 1'b1)
        begin
            axi_get_config_stats_write_address_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_address_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_address_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_address_waits_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_write_address_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_address_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_inst_changed == 1'b1)
        begin
            axi_get_stats_write_address_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_sw_changed == 1'b1)
        begin
            axi_get_stats_write_address_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_write_address_waits_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_min_changed == 1'b1)
        begin
            axi_get_stats_write_address_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_max_changed == 1'b1)
        begin
            axi_get_stats_write_address_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_mean_changed == 1'b1)
        begin
            axi_get_stats_write_address_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_waits_step_changed == 1'b1)
        begin
            axi_get_config_stats_write_data_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_waits_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_write_data_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_inst_changed == 1'b1)
        begin
            axi_get_stats_write_data_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_sw_changed == 1'b1)
        begin
            axi_get_stats_write_data_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_write_data_waits_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_min_changed == 1'b1)
        begin
            axi_get_stats_write_data_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_max_changed == 1'b1)
        begin
            axi_get_stats_write_data_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_mean_changed == 1'b1)
        begin
            axi_get_stats_write_data_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_response_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_response_waits_step_changed == 1'b1)
        begin
            axi_get_config_stats_write_response_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_response_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_response_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_response_waits_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_write_response_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_response_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_inst_changed == 1'b1)
        begin
            axi_get_stats_write_response_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_sw_changed == 1'b1)
        begin
            axi_get_stats_write_response_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_write_response_waits_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_min_changed == 1'b1)
        begin
            axi_get_stats_write_response_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_max_changed == 1'b1)
        begin
            axi_get_stats_write_response_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_mean_changed == 1'b1)
        begin
            axi_get_stats_write_response_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_rw_transaction_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_rw_transaction_last_duration_changed == 1'b1)
        begin
            axi_get_stats_rw_transaction_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_rw_transaction_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_last_duration_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_last_duration_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_read_addr_channel_phase_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_read_addr_channel_phase_last_duration_changed == 1'b1)
        begin
            axi_get_stats_read_addr_channel_phase_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_addr_channel_phase_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_burst_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_burst_last_duration_changed == 1'b1)
        begin
            axi_get_stats_read_data_burst_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_burst_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_read_channel_phase_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_read_channel_phase_last_duration_changed == 1'b1)
        begin
            axi_get_stats_read_channel_phase_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_channel_phase_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_write_addr_channel_phase_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_write_addr_channel_phase_last_duration_changed == 1'b1)
        begin
            axi_get_stats_write_addr_channel_phase_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_addr_channel_phase_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_burst_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_burst_last_duration_changed == 1'b1)
        begin
            axi_get_stats_write_data_burst_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_burst_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_write_channel_phase_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_write_channel_phase_last_duration_changed == 1'b1)
        begin
            axi_get_stats_write_channel_phase_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_channel_phase_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_write_resp_channel_phase_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_write_resp_channel_phase_last_duration_changed == 1'b1)
        begin
            axi_get_stats_write_resp_channel_phase_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_resp_channel_phase_last_duration_changed = 1'b0;
        end
    end


    function longint do_get_last_handle();
        return last_handle;
    endfunction


    function longint do_get_last_start_time();
        return last_start_time;
    endfunction


    function longint do_get_last_end_time();
        return last_end_time;
    endfunction


        bit report_available;

        // Function for getting a message from QUESTA_MVC. Returns 1 if a message was returned, 0 otherwise.
        import "DPI-C" questa_mvc_sv_get_report =  function bit get_report( input longint recipient,
                                     output string category,     output string objectName,
                                     output string instanceName, output string error_no,
                                     output string typ,          output string mess );
        questa_mvc_reporter endPoint[longint];
        initial report_available = 0;

        always @report_available
        begin
            longint recipient;
            string category;
            string objectName;
            string instanceName;
            string severity;
            string mess;
            string error_no;

            if ( endPoint.first( recipient ) )
              begin
                do
                  begin
                      while ( get_report( recipient, category, objectName, instanceName, error_no, severity, mess ) )
                        begin
                          endPoint[recipient].report_message( category, "axi", 0, objectName, instanceName, error_no, severity, mess );
                        end
                  end
                while (endPoint.next(recipient));
              end
            report_available = 0;
        end

        import "DPI-C" context questa_mvc_register_end_point = function void questa_mvc_register_end_point( input longint as_end, input string name );

        // A function for registering a reporter to capture any reports coming from as_end
        function automatic void register_end_point( input longint as_end, input questa_mvc_reporter rep = null );
            if ( rep != null )
              begin
                if ( ( rep.name == "" ) || ( rep.name == "NULL" ) )
                  begin
                    $display("Error: %m: Reporter passed to register_end_point has a reserved name. Neither an empty string nor the string 'NULL' can be used.");
                  end
                else
                  begin
                    questa_mvc_register_end_point( as_end, rep.name );
                    endPoint[as_end] = rep;
                  end
              end
            else
              begin
                questa_mvc_register_end_point( as_end, "NULL" );
                endPoint.delete( as_end );
              end
        endfunction

    //------------------------------------------------------------------------------
    // Tasks for registering reports
    //------------------------------------------------------------------------------
    function void do_register_interface_reporter( input questa_mvc_reporter _rep = null );
        register_end_point( _interface_ref, _rep );
    endfunction

    function void do_register_master_reporter
    (
        input questa_mvc_reporter rep = null
    );
        register_end_point( axi_get_axi_master_end(), rep );
    endfunction

    function void do_register_slave_reporter
    (
        input questa_mvc_reporter rep = null
    );
        register_end_point( axi_get_axi_slave_end(), rep );
    endfunction

    function void do_register_clock_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
        register_end_point( axi_get_axi_clock_source_end(), rep );
    endfunction

    function void do_register_reset_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
        register_end_point( axi_get_axi_reset_source_end(), rep );
    endfunction


    // Start end_of_timestep timer
    initial
    forever
    begin
        wait_end_of_timestep();
    end


    bit non_blocking_end_of_timestep_control = 0;

    export "DPI-C" axi_wait_end_of_timestep = task wait_end_of_timestep;

    task wait_end_of_timestep();
        begin
            wait(non_blocking_end_of_timestep_control == 1);
            axi_end_of_timestep_VPI_SystemVerilog();
            non_blocking_end_of_timestep_control = 0;
        end
    endtask

    always @( posedge end_of_timestep_control or posedge _check_t0_values )
    begin
        if ( end_of_timestep_control == 1 )
        begin
            non_blocking_end_of_timestep_control <= 1;
            end_of_timestep_control = 0;
        end
    end

    //------------------------------------------------------------------------------
    // Tasks to wait for a number of specified edges on a wire
    //------------------------------------------------------------------------------

    task automatic do_wait_for_ACLK( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ACLK);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ACLK);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ACLK);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ACLK === 0 );
                    @( ACLK );
                end
                while ( ACLK !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ACLK === 1 );
                    @( ACLK );
                end
                while ( ACLK !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARESETn( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARESETn);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARESETn);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARESETn);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARESETn === 0 );
                    @( ARESETn );
                end
                while ( ARESETn !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARESETn === 1 );
                    @( ARESETn );
                end
                while ( ARESETn !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWVALID === 0 );
                    @( AWVALID );
                end
                while ( AWVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWVALID === 1 );
                    @( AWVALID );
                end
                while ( AWVALID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWADDR( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWADDR);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWADDR);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWADDR);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWADDR === 0 );
                    @( AWADDR );
                end
                while ( AWADDR !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWADDR === 1 );
                    @( AWADDR );
                end
                while ( AWADDR !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWADDR[_this_dot_1] === 0 );
                    @( AWADDR[_this_dot_1] );
                end
                while ( AWADDR[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWADDR[_this_dot_1] === 1 );
                    @( AWADDR[_this_dot_1] );
                end
                while ( AWADDR[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWLEN( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWLEN);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWLEN);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWLEN);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWLEN === 0 );
                    @( AWLEN );
                end
                while ( AWLEN !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWLEN === 1 );
                    @( AWLEN );
                end
                while ( AWLEN !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWLEN[_this_dot_1] === 0 );
                    @( AWLEN[_this_dot_1] );
                end
                while ( AWLEN[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWLEN[_this_dot_1] === 1 );
                    @( AWLEN[_this_dot_1] );
                end
                while ( AWLEN[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWSIZE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWSIZE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWSIZE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWSIZE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWSIZE === 0 );
                    @( AWSIZE );
                end
                while ( AWSIZE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWSIZE === 1 );
                    @( AWSIZE );
                end
                while ( AWSIZE !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWSIZE[_this_dot_1] === 0 );
                    @( AWSIZE[_this_dot_1] );
                end
                while ( AWSIZE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWSIZE[_this_dot_1] === 1 );
                    @( AWSIZE[_this_dot_1] );
                end
                while ( AWSIZE[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWBURST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWBURST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWBURST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWBURST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWBURST === 0 );
                    @( AWBURST );
                end
                while ( AWBURST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWBURST === 1 );
                    @( AWBURST );
                end
                while ( AWBURST !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWBURST[_this_dot_1] === 0 );
                    @( AWBURST[_this_dot_1] );
                end
                while ( AWBURST[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWBURST[_this_dot_1] === 1 );
                    @( AWBURST[_this_dot_1] );
                end
                while ( AWBURST[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWLOCK( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWLOCK);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWLOCK);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWLOCK);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWLOCK === 0 );
                    @( AWLOCK );
                end
                while ( AWLOCK !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWLOCK === 1 );
                    @( AWLOCK );
                end
                while ( AWLOCK !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWLOCK_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWLOCK[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWLOCK[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWLOCK[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWLOCK[_this_dot_1] === 0 );
                    @( AWLOCK[_this_dot_1] );
                end
                while ( AWLOCK[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWLOCK[_this_dot_1] === 1 );
                    @( AWLOCK[_this_dot_1] );
                end
                while ( AWLOCK[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWCACHE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWCACHE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWCACHE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWCACHE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWCACHE === 0 );
                    @( AWCACHE );
                end
                while ( AWCACHE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWCACHE === 1 );
                    @( AWCACHE );
                end
                while ( AWCACHE !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWCACHE[_this_dot_1] === 0 );
                    @( AWCACHE[_this_dot_1] );
                end
                while ( AWCACHE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWCACHE[_this_dot_1] === 1 );
                    @( AWCACHE[_this_dot_1] );
                end
                while ( AWCACHE[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWPROT( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWPROT);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWPROT);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWPROT);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWPROT === 0 );
                    @( AWPROT );
                end
                while ( AWPROT !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWPROT === 1 );
                    @( AWPROT );
                end
                while ( AWPROT !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWPROT[_this_dot_1] === 0 );
                    @( AWPROT[_this_dot_1] );
                end
                while ( AWPROT[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWPROT[_this_dot_1] === 1 );
                    @( AWPROT[_this_dot_1] );
                end
                while ( AWPROT[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWID === 0 );
                    @( AWID );
                end
                while ( AWID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWID === 1 );
                    @( AWID );
                end
                while ( AWID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWID[_this_dot_1] === 0 );
                    @( AWID[_this_dot_1] );
                end
                while ( AWID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWID[_this_dot_1] === 1 );
                    @( AWID[_this_dot_1] );
                end
                while ( AWID[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWREADY === 0 );
                    @( AWREADY );
                end
                while ( AWREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWREADY === 1 );
                    @( AWREADY );
                end
                while ( AWREADY !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWUSER === 0 );
                    @( AWUSER );
                end
                while ( AWUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWUSER === 1 );
                    @( AWUSER );
                end
                while ( AWUSER !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWUSER[_this_dot_1] === 0 );
                    @( AWUSER[_this_dot_1] );
                end
                while ( AWUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWUSER[_this_dot_1] === 1 );
                    @( AWUSER[_this_dot_1] );
                end
                while ( AWUSER[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARVALID === 0 );
                    @( ARVALID );
                end
                while ( ARVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARVALID === 1 );
                    @( ARVALID );
                end
                while ( ARVALID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARADDR( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARADDR);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARADDR);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARADDR);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARADDR === 0 );
                    @( ARADDR );
                end
                while ( ARADDR !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARADDR === 1 );
                    @( ARADDR );
                end
                while ( ARADDR !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARADDR[_this_dot_1] === 0 );
                    @( ARADDR[_this_dot_1] );
                end
                while ( ARADDR[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARADDR[_this_dot_1] === 1 );
                    @( ARADDR[_this_dot_1] );
                end
                while ( ARADDR[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARLEN( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARLEN);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARLEN);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARLEN);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARLEN === 0 );
                    @( ARLEN );
                end
                while ( ARLEN !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARLEN === 1 );
                    @( ARLEN );
                end
                while ( ARLEN !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARLEN[_this_dot_1] === 0 );
                    @( ARLEN[_this_dot_1] );
                end
                while ( ARLEN[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARLEN[_this_dot_1] === 1 );
                    @( ARLEN[_this_dot_1] );
                end
                while ( ARLEN[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARSIZE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARSIZE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARSIZE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARSIZE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARSIZE === 0 );
                    @( ARSIZE );
                end
                while ( ARSIZE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARSIZE === 1 );
                    @( ARSIZE );
                end
                while ( ARSIZE !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARSIZE[_this_dot_1] === 0 );
                    @( ARSIZE[_this_dot_1] );
                end
                while ( ARSIZE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARSIZE[_this_dot_1] === 1 );
                    @( ARSIZE[_this_dot_1] );
                end
                while ( ARSIZE[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARBURST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARBURST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARBURST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARBURST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARBURST === 0 );
                    @( ARBURST );
                end
                while ( ARBURST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARBURST === 1 );
                    @( ARBURST );
                end
                while ( ARBURST !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARBURST[_this_dot_1] === 0 );
                    @( ARBURST[_this_dot_1] );
                end
                while ( ARBURST[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARBURST[_this_dot_1] === 1 );
                    @( ARBURST[_this_dot_1] );
                end
                while ( ARBURST[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARLOCK( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARLOCK);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARLOCK);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARLOCK);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARLOCK === 0 );
                    @( ARLOCK );
                end
                while ( ARLOCK !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARLOCK === 1 );
                    @( ARLOCK );
                end
                while ( ARLOCK !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARLOCK_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARLOCK[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARLOCK[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARLOCK[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARLOCK[_this_dot_1] === 0 );
                    @( ARLOCK[_this_dot_1] );
                end
                while ( ARLOCK[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARLOCK[_this_dot_1] === 1 );
                    @( ARLOCK[_this_dot_1] );
                end
                while ( ARLOCK[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARCACHE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARCACHE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARCACHE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARCACHE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARCACHE === 0 );
                    @( ARCACHE );
                end
                while ( ARCACHE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARCACHE === 1 );
                    @( ARCACHE );
                end
                while ( ARCACHE !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARCACHE[_this_dot_1] === 0 );
                    @( ARCACHE[_this_dot_1] );
                end
                while ( ARCACHE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARCACHE[_this_dot_1] === 1 );
                    @( ARCACHE[_this_dot_1] );
                end
                while ( ARCACHE[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARPROT( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARPROT);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARPROT);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARPROT);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARPROT === 0 );
                    @( ARPROT );
                end
                while ( ARPROT !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARPROT === 1 );
                    @( ARPROT );
                end
                while ( ARPROT !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARPROT[_this_dot_1] === 0 );
                    @( ARPROT[_this_dot_1] );
                end
                while ( ARPROT[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARPROT[_this_dot_1] === 1 );
                    @( ARPROT[_this_dot_1] );
                end
                while ( ARPROT[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARID === 0 );
                    @( ARID );
                end
                while ( ARID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARID === 1 );
                    @( ARID );
                end
                while ( ARID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARID[_this_dot_1] === 0 );
                    @( ARID[_this_dot_1] );
                end
                while ( ARID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARID[_this_dot_1] === 1 );
                    @( ARID[_this_dot_1] );
                end
                while ( ARID[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARREADY === 0 );
                    @( ARREADY );
                end
                while ( ARREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARREADY === 1 );
                    @( ARREADY );
                end
                while ( ARREADY !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARUSER === 0 );
                    @( ARUSER );
                end
                while ( ARUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARUSER === 1 );
                    @( ARUSER );
                end
                while ( ARUSER !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARUSER[_this_dot_1] === 0 );
                    @( ARUSER[_this_dot_1] );
                end
                while ( ARUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARUSER[_this_dot_1] === 1 );
                    @( ARUSER[_this_dot_1] );
                end
                while ( ARUSER[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RVALID === 0 );
                    @( RVALID );
                end
                while ( RVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RVALID === 1 );
                    @( RVALID );
                end
                while ( RVALID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RLAST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RLAST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RLAST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RLAST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RLAST === 0 );
                    @( RLAST );
                end
                while ( RLAST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RLAST === 1 );
                    @( RLAST );
                end
                while ( RLAST !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RDATA( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RDATA);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RDATA);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RDATA);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RDATA === 0 );
                    @( RDATA );
                end
                while ( RDATA !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RDATA === 1 );
                    @( RDATA );
                end
                while ( RDATA !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RDATA[_this_dot_1] === 0 );
                    @( RDATA[_this_dot_1] );
                end
                while ( RDATA[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RDATA[_this_dot_1] === 1 );
                    @( RDATA[_this_dot_1] );
                end
                while ( RDATA[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RRESP( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RRESP);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RRESP);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RRESP);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RRESP === 0 );
                    @( RRESP );
                end
                while ( RRESP !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RRESP === 1 );
                    @( RRESP );
                end
                while ( RRESP !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RRESP[_this_dot_1] === 0 );
                    @( RRESP[_this_dot_1] );
                end
                while ( RRESP[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RRESP[_this_dot_1] === 1 );
                    @( RRESP[_this_dot_1] );
                end
                while ( RRESP[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RID === 0 );
                    @( RID );
                end
                while ( RID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RID === 1 );
                    @( RID );
                end
                while ( RID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RID[_this_dot_1] === 0 );
                    @( RID[_this_dot_1] );
                end
                while ( RID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RID[_this_dot_1] === 1 );
                    @( RID[_this_dot_1] );
                end
                while ( RID[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RREADY === 0 );
                    @( RREADY );
                end
                while ( RREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RREADY === 1 );
                    @( RREADY );
                end
                while ( RREADY !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RUSER === 0 );
                    @( RUSER );
                end
                while ( RUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RUSER === 1 );
                    @( RUSER );
                end
                while ( RUSER !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RUSER[_this_dot_1] === 0 );
                    @( RUSER[_this_dot_1] );
                end
                while ( RUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RUSER[_this_dot_1] === 1 );
                    @( RUSER[_this_dot_1] );
                end
                while ( RUSER[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WVALID === 0 );
                    @( WVALID );
                end
                while ( WVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WVALID === 1 );
                    @( WVALID );
                end
                while ( WVALID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WLAST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WLAST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WLAST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WLAST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WLAST === 0 );
                    @( WLAST );
                end
                while ( WLAST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WLAST === 1 );
                    @( WLAST );
                end
                while ( WLAST !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WDATA( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WDATA);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WDATA);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WDATA);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WDATA === 0 );
                    @( WDATA );
                end
                while ( WDATA !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WDATA === 1 );
                    @( WDATA );
                end
                while ( WDATA !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WDATA[_this_dot_1] === 0 );
                    @( WDATA[_this_dot_1] );
                end
                while ( WDATA[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WDATA[_this_dot_1] === 1 );
                    @( WDATA[_this_dot_1] );
                end
                while ( WDATA[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WSTRB( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WSTRB);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WSTRB);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WSTRB);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WSTRB === 0 );
                    @( WSTRB );
                end
                while ( WSTRB !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WSTRB === 1 );
                    @( WSTRB );
                end
                while ( WSTRB !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WSTRB_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WSTRB[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WSTRB[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WSTRB[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WSTRB[_this_dot_1] === 0 );
                    @( WSTRB[_this_dot_1] );
                end
                while ( WSTRB[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WSTRB[_this_dot_1] === 1 );
                    @( WSTRB[_this_dot_1] );
                end
                while ( WSTRB[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WID === 0 );
                    @( WID );
                end
                while ( WID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WID === 1 );
                    @( WID );
                end
                while ( WID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WID[_this_dot_1] === 0 );
                    @( WID[_this_dot_1] );
                end
                while ( WID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WID[_this_dot_1] === 1 );
                    @( WID[_this_dot_1] );
                end
                while ( WID[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WREADY === 0 );
                    @( WREADY );
                end
                while ( WREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WREADY === 1 );
                    @( WREADY );
                end
                while ( WREADY !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WUSER === 0 );
                    @( WUSER );
                end
                while ( WUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WUSER === 1 );
                    @( WUSER );
                end
                while ( WUSER !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WUSER[_this_dot_1] === 0 );
                    @( WUSER[_this_dot_1] );
                end
                while ( WUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WUSER[_this_dot_1] === 1 );
                    @( WUSER[_this_dot_1] );
                end
                while ( WUSER[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BVALID === 0 );
                    @( BVALID );
                end
                while ( BVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BVALID === 1 );
                    @( BVALID );
                end
                while ( BVALID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BRESP( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BRESP);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BRESP);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BRESP);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BRESP === 0 );
                    @( BRESP );
                end
                while ( BRESP !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BRESP === 1 );
                    @( BRESP );
                end
                while ( BRESP !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BRESP[_this_dot_1] === 0 );
                    @( BRESP[_this_dot_1] );
                end
                while ( BRESP[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BRESP[_this_dot_1] === 1 );
                    @( BRESP[_this_dot_1] );
                end
                while ( BRESP[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BID === 0 );
                    @( BID );
                end
                while ( BID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BID === 1 );
                    @( BID );
                end
                while ( BID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BID[_this_dot_1] === 0 );
                    @( BID[_this_dot_1] );
                end
                while ( BID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BID[_this_dot_1] === 1 );
                    @( BID[_this_dot_1] );
                end
                while ( BID[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BREADY === 0 );
                    @( BREADY );
                end
                while ( BREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BREADY === 1 );
                    @( BREADY );
                end
                while ( BREADY !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BUSER === 0 );
                    @( BUSER );
                end
                while ( BUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BUSER === 1 );
                    @( BUSER );
                end
                while ( BUSER !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BUSER[_this_dot_1] === 0 );
                    @( BUSER[_this_dot_1] );
                end
                while ( BUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BUSER[_this_dot_1] === 1 );
                    @( BUSER[_this_dot_1] );
                end
                while ( BUSER[_this_dot_1] !== 0 );
            end
        end
    endtask

    //------------------------------------------------------------------------------
    // Tasks/functions to set/get wires
    //------------------------------------------------------------------------------

    task automatic do_set_ACLK( logic ACLK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ACLK = ACLK_param;
        else
            m_ACLK <= ACLK_param;
    endtask

    function automatic logic do_get_ACLK(  );
        return ACLK;
    endfunction

    task automatic do_set_ARESETn( logic ARESETn_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARESETn = ARESETn_param;
        else
            m_ARESETn <= ARESETn_param;
    endtask

    function automatic logic do_get_ARESETn(  );
        return ARESETn;
    endfunction

    task automatic do_set_AWVALID( logic AWVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWVALID = AWVALID_param;
        else
            m_AWVALID <= AWVALID_param;
    endtask

    function automatic logic do_get_AWVALID(  );
        return AWVALID;
    endfunction

    task automatic do_set_AWADDR( logic [((AXI_ADDRESS_WIDTH) - 1):0]  AWADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWADDR = AWADDR_param;
        else
            m_AWADDR <= AWADDR_param;
    endtask

    task automatic do_set_AWADDR_index1( int _this_dot_1, logic  AWADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWADDR[_this_dot_1] = AWADDR_param;
        else
            m_AWADDR[_this_dot_1] <= AWADDR_param;
    endtask

    function automatic logic [((AXI_ADDRESS_WIDTH) - 1):0]   do_get_AWADDR(  );
        return AWADDR;
    endfunction

    function automatic logic   do_get_AWADDR_index1( int _this_dot_1 );
        return AWADDR[_this_dot_1];
    endfunction

    task automatic do_set_AWLEN( logic [3:0] AWLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWLEN = AWLEN_param;
        else
            m_AWLEN <= AWLEN_param;
    endtask

    task automatic do_set_AWLEN_index1( int _this_dot_1, logic  AWLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWLEN[_this_dot_1] = AWLEN_param;
        else
            m_AWLEN[_this_dot_1] <= AWLEN_param;
    endtask

    function automatic logic [3:0]  do_get_AWLEN(  );
        return AWLEN;
    endfunction

    function automatic logic   do_get_AWLEN_index1( int _this_dot_1 );
        return AWLEN[_this_dot_1];
    endfunction

    task automatic do_set_AWSIZE( logic [2:0] AWSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWSIZE = AWSIZE_param;
        else
            m_AWSIZE <= AWSIZE_param;
    endtask

    task automatic do_set_AWSIZE_index1( int _this_dot_1, logic  AWSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWSIZE[_this_dot_1] = AWSIZE_param;
        else
            m_AWSIZE[_this_dot_1] <= AWSIZE_param;
    endtask

    function automatic logic [2:0]  do_get_AWSIZE(  );
        return AWSIZE;
    endfunction

    function automatic logic   do_get_AWSIZE_index1( int _this_dot_1 );
        return AWSIZE[_this_dot_1];
    endfunction

    task automatic do_set_AWBURST( logic [1:0] AWBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWBURST = AWBURST_param;
        else
            m_AWBURST <= AWBURST_param;
    endtask

    task automatic do_set_AWBURST_index1( int _this_dot_1, logic  AWBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWBURST[_this_dot_1] = AWBURST_param;
        else
            m_AWBURST[_this_dot_1] <= AWBURST_param;
    endtask

    function automatic logic [1:0]  do_get_AWBURST(  );
        return AWBURST;
    endfunction

    function automatic logic   do_get_AWBURST_index1( int _this_dot_1 );
        return AWBURST[_this_dot_1];
    endfunction

    task automatic do_set_AWLOCK( logic [1:0] AWLOCK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWLOCK = AWLOCK_param;
        else
            m_AWLOCK <= AWLOCK_param;
    endtask

    task automatic do_set_AWLOCK_index1( int _this_dot_1, logic  AWLOCK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWLOCK[_this_dot_1] = AWLOCK_param;
        else
            m_AWLOCK[_this_dot_1] <= AWLOCK_param;
    endtask

    function automatic logic [1:0]  do_get_AWLOCK(  );
        return AWLOCK;
    endfunction

    function automatic logic   do_get_AWLOCK_index1( int _this_dot_1 );
        return AWLOCK[_this_dot_1];
    endfunction

    task automatic do_set_AWCACHE( logic [3:0] AWCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWCACHE = AWCACHE_param;
        else
            m_AWCACHE <= AWCACHE_param;
    endtask

    task automatic do_set_AWCACHE_index1( int _this_dot_1, logic  AWCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWCACHE[_this_dot_1] = AWCACHE_param;
        else
            m_AWCACHE[_this_dot_1] <= AWCACHE_param;
    endtask

    function automatic logic [3:0]  do_get_AWCACHE(  );
        return AWCACHE;
    endfunction

    function automatic logic   do_get_AWCACHE_index1( int _this_dot_1 );
        return AWCACHE[_this_dot_1];
    endfunction

    task automatic do_set_AWPROT( logic [2:0] AWPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWPROT = AWPROT_param;
        else
            m_AWPROT <= AWPROT_param;
    endtask

    task automatic do_set_AWPROT_index1( int _this_dot_1, logic  AWPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWPROT[_this_dot_1] = AWPROT_param;
        else
            m_AWPROT[_this_dot_1] <= AWPROT_param;
    endtask

    function automatic logic [2:0]  do_get_AWPROT(  );
        return AWPROT;
    endfunction

    function automatic logic   do_get_AWPROT_index1( int _this_dot_1 );
        return AWPROT[_this_dot_1];
    endfunction

    task automatic do_set_AWID( logic [((AXI_ID_WIDTH) - 1):0]  AWID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWID = AWID_param;
        else
            m_AWID <= AWID_param;
    endtask

    task automatic do_set_AWID_index1( int _this_dot_1, logic  AWID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWID[_this_dot_1] = AWID_param;
        else
            m_AWID[_this_dot_1] <= AWID_param;
    endtask

    function automatic logic [((AXI_ID_WIDTH) - 1):0]   do_get_AWID(  );
        return AWID;
    endfunction

    function automatic logic   do_get_AWID_index1( int _this_dot_1 );
        return AWID[_this_dot_1];
    endfunction

    task automatic do_set_AWREADY( logic AWREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWREADY = AWREADY_param;
        else
            m_AWREADY <= AWREADY_param;
    endtask

    function automatic logic do_get_AWREADY(  );
        return AWREADY;
    endfunction

    task automatic do_set_AWUSER( logic [7:0] AWUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWUSER = AWUSER_param;
        else
            m_AWUSER <= AWUSER_param;
    endtask

    task automatic do_set_AWUSER_index1( int _this_dot_1, logic  AWUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWUSER[_this_dot_1] = AWUSER_param;
        else
            m_AWUSER[_this_dot_1] <= AWUSER_param;
    endtask

    function automatic logic [7:0]  do_get_AWUSER(  );
        return AWUSER;
    endfunction

    function automatic logic   do_get_AWUSER_index1( int _this_dot_1 );
        return AWUSER[_this_dot_1];
    endfunction

    task automatic do_set_ARVALID( logic ARVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARVALID = ARVALID_param;
        else
            m_ARVALID <= ARVALID_param;
    endtask

    function automatic logic do_get_ARVALID(  );
        return ARVALID;
    endfunction

    task automatic do_set_ARADDR( logic [((AXI_ADDRESS_WIDTH) - 1):0]  ARADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARADDR = ARADDR_param;
        else
            m_ARADDR <= ARADDR_param;
    endtask

    task automatic do_set_ARADDR_index1( int _this_dot_1, logic  ARADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARADDR[_this_dot_1] = ARADDR_param;
        else
            m_ARADDR[_this_dot_1] <= ARADDR_param;
    endtask

    function automatic logic [((AXI_ADDRESS_WIDTH) - 1):0]   do_get_ARADDR(  );
        return ARADDR;
    endfunction

    function automatic logic   do_get_ARADDR_index1( int _this_dot_1 );
        return ARADDR[_this_dot_1];
    endfunction

    task automatic do_set_ARLEN( logic [3:0] ARLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARLEN = ARLEN_param;
        else
            m_ARLEN <= ARLEN_param;
    endtask

    task automatic do_set_ARLEN_index1( int _this_dot_1, logic  ARLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARLEN[_this_dot_1] = ARLEN_param;
        else
            m_ARLEN[_this_dot_1] <= ARLEN_param;
    endtask

    function automatic logic [3:0]  do_get_ARLEN(  );
        return ARLEN;
    endfunction

    function automatic logic   do_get_ARLEN_index1( int _this_dot_1 );
        return ARLEN[_this_dot_1];
    endfunction

    task automatic do_set_ARSIZE( logic [2:0] ARSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARSIZE = ARSIZE_param;
        else
            m_ARSIZE <= ARSIZE_param;
    endtask

    task automatic do_set_ARSIZE_index1( int _this_dot_1, logic  ARSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARSIZE[_this_dot_1] = ARSIZE_param;
        else
            m_ARSIZE[_this_dot_1] <= ARSIZE_param;
    endtask

    function automatic logic [2:0]  do_get_ARSIZE(  );
        return ARSIZE;
    endfunction

    function automatic logic   do_get_ARSIZE_index1( int _this_dot_1 );
        return ARSIZE[_this_dot_1];
    endfunction

    task automatic do_set_ARBURST( logic [1:0] ARBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARBURST = ARBURST_param;
        else
            m_ARBURST <= ARBURST_param;
    endtask

    task automatic do_set_ARBURST_index1( int _this_dot_1, logic  ARBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARBURST[_this_dot_1] = ARBURST_param;
        else
            m_ARBURST[_this_dot_1] <= ARBURST_param;
    endtask

    function automatic logic [1:0]  do_get_ARBURST(  );
        return ARBURST;
    endfunction

    function automatic logic   do_get_ARBURST_index1( int _this_dot_1 );
        return ARBURST[_this_dot_1];
    endfunction

    task automatic do_set_ARLOCK( logic [1:0] ARLOCK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARLOCK = ARLOCK_param;
        else
            m_ARLOCK <= ARLOCK_param;
    endtask

    task automatic do_set_ARLOCK_index1( int _this_dot_1, logic  ARLOCK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARLOCK[_this_dot_1] = ARLOCK_param;
        else
            m_ARLOCK[_this_dot_1] <= ARLOCK_param;
    endtask

    function automatic logic [1:0]  do_get_ARLOCK(  );
        return ARLOCK;
    endfunction

    function automatic logic   do_get_ARLOCK_index1( int _this_dot_1 );
        return ARLOCK[_this_dot_1];
    endfunction

    task automatic do_set_ARCACHE( logic [3:0] ARCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARCACHE = ARCACHE_param;
        else
            m_ARCACHE <= ARCACHE_param;
    endtask

    task automatic do_set_ARCACHE_index1( int _this_dot_1, logic  ARCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARCACHE[_this_dot_1] = ARCACHE_param;
        else
            m_ARCACHE[_this_dot_1] <= ARCACHE_param;
    endtask

    function automatic logic [3:0]  do_get_ARCACHE(  );
        return ARCACHE;
    endfunction

    function automatic logic   do_get_ARCACHE_index1( int _this_dot_1 );
        return ARCACHE[_this_dot_1];
    endfunction

    task automatic do_set_ARPROT( logic [2:0] ARPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARPROT = ARPROT_param;
        else
            m_ARPROT <= ARPROT_param;
    endtask

    task automatic do_set_ARPROT_index1( int _this_dot_1, logic  ARPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARPROT[_this_dot_1] = ARPROT_param;
        else
            m_ARPROT[_this_dot_1] <= ARPROT_param;
    endtask

    function automatic logic [2:0]  do_get_ARPROT(  );
        return ARPROT;
    endfunction

    function automatic logic   do_get_ARPROT_index1( int _this_dot_1 );
        return ARPROT[_this_dot_1];
    endfunction

    task automatic do_set_ARID( logic [((AXI_ID_WIDTH) - 1):0]  ARID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARID = ARID_param;
        else
            m_ARID <= ARID_param;
    endtask

    task automatic do_set_ARID_index1( int _this_dot_1, logic  ARID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARID[_this_dot_1] = ARID_param;
        else
            m_ARID[_this_dot_1] <= ARID_param;
    endtask

    function automatic logic [((AXI_ID_WIDTH) - 1):0]   do_get_ARID(  );
        return ARID;
    endfunction

    function automatic logic   do_get_ARID_index1( int _this_dot_1 );
        return ARID[_this_dot_1];
    endfunction

    task automatic do_set_ARREADY( logic ARREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARREADY = ARREADY_param;
        else
            m_ARREADY <= ARREADY_param;
    endtask

    function automatic logic do_get_ARREADY(  );
        return ARREADY;
    endfunction

    task automatic do_set_ARUSER( logic [7:0] ARUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARUSER = ARUSER_param;
        else
            m_ARUSER <= ARUSER_param;
    endtask

    task automatic do_set_ARUSER_index1( int _this_dot_1, logic  ARUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARUSER[_this_dot_1] = ARUSER_param;
        else
            m_ARUSER[_this_dot_1] <= ARUSER_param;
    endtask

    function automatic logic [7:0]  do_get_ARUSER(  );
        return ARUSER;
    endfunction

    function automatic logic   do_get_ARUSER_index1( int _this_dot_1 );
        return ARUSER[_this_dot_1];
    endfunction

    task automatic do_set_RVALID( logic RVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RVALID = RVALID_param;
        else
            m_RVALID <= RVALID_param;
    endtask

    function automatic logic do_get_RVALID(  );
        return RVALID;
    endfunction

    task automatic do_set_RLAST( logic RLAST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RLAST = RLAST_param;
        else
            m_RLAST <= RLAST_param;
    endtask

    function automatic logic do_get_RLAST(  );
        return RLAST;
    endfunction

    task automatic do_set_RDATA( logic [((AXI_RDATA_WIDTH) - 1):0]  RDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RDATA = RDATA_param;
        else
            m_RDATA <= RDATA_param;
    endtask

    task automatic do_set_RDATA_index1( int _this_dot_1, logic  RDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RDATA[_this_dot_1] = RDATA_param;
        else
            m_RDATA[_this_dot_1] <= RDATA_param;
    endtask

    function automatic logic [((AXI_RDATA_WIDTH) - 1):0]   do_get_RDATA(  );
        return RDATA;
    endfunction

    function automatic logic   do_get_RDATA_index1( int _this_dot_1 );
        return RDATA[_this_dot_1];
    endfunction

    task automatic do_set_RRESP( logic [1:0] RRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RRESP = RRESP_param;
        else
            m_RRESP <= RRESP_param;
    endtask

    task automatic do_set_RRESP_index1( int _this_dot_1, logic  RRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RRESP[_this_dot_1] = RRESP_param;
        else
            m_RRESP[_this_dot_1] <= RRESP_param;
    endtask

    function automatic logic [1:0]  do_get_RRESP(  );
        return RRESP;
    endfunction

    function automatic logic   do_get_RRESP_index1( int _this_dot_1 );
        return RRESP[_this_dot_1];
    endfunction

    task automatic do_set_RID( logic [((AXI_ID_WIDTH) - 1):0]  RID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RID = RID_param;
        else
            m_RID <= RID_param;
    endtask

    task automatic do_set_RID_index1( int _this_dot_1, logic  RID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RID[_this_dot_1] = RID_param;
        else
            m_RID[_this_dot_1] <= RID_param;
    endtask

    function automatic logic [((AXI_ID_WIDTH) - 1):0]   do_get_RID(  );
        return RID;
    endfunction

    function automatic logic   do_get_RID_index1( int _this_dot_1 );
        return RID[_this_dot_1];
    endfunction

    task automatic do_set_RREADY( logic RREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RREADY = RREADY_param;
        else
            m_RREADY <= RREADY_param;
    endtask

    function automatic logic do_get_RREADY(  );
        return RREADY;
    endfunction

    task automatic do_set_RUSER( logic [7:0] RUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RUSER = RUSER_param;
        else
            m_RUSER <= RUSER_param;
    endtask

    task automatic do_set_RUSER_index1( int _this_dot_1, logic  RUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RUSER[_this_dot_1] = RUSER_param;
        else
            m_RUSER[_this_dot_1] <= RUSER_param;
    endtask

    function automatic logic [7:0]  do_get_RUSER(  );
        return RUSER;
    endfunction

    function automatic logic   do_get_RUSER_index1( int _this_dot_1 );
        return RUSER[_this_dot_1];
    endfunction

    task automatic do_set_WVALID( logic WVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WVALID = WVALID_param;
        else
            m_WVALID <= WVALID_param;
    endtask

    function automatic logic do_get_WVALID(  );
        return WVALID;
    endfunction

    task automatic do_set_WLAST( logic WLAST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WLAST = WLAST_param;
        else
            m_WLAST <= WLAST_param;
    endtask

    function automatic logic do_get_WLAST(  );
        return WLAST;
    endfunction

    task automatic do_set_WDATA( logic [((AXI_WDATA_WIDTH) - 1):0]  WDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WDATA = WDATA_param;
        else
            m_WDATA <= WDATA_param;
    endtask

    task automatic do_set_WDATA_index1( int _this_dot_1, logic  WDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WDATA[_this_dot_1] = WDATA_param;
        else
            m_WDATA[_this_dot_1] <= WDATA_param;
    endtask

    function automatic logic [((AXI_WDATA_WIDTH) - 1):0]   do_get_WDATA(  );
        return WDATA;
    endfunction

    function automatic logic   do_get_WDATA_index1( int _this_dot_1 );
        return WDATA[_this_dot_1];
    endfunction

    task automatic do_set_WSTRB( logic [(((AXI_WDATA_WIDTH / 8)) - 1):0]  WSTRB_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WSTRB = WSTRB_param;
        else
            m_WSTRB <= WSTRB_param;
    endtask

    task automatic do_set_WSTRB_index1( int _this_dot_1, logic  WSTRB_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WSTRB[_this_dot_1] = WSTRB_param;
        else
            m_WSTRB[_this_dot_1] <= WSTRB_param;
    endtask

    function automatic logic [(((AXI_WDATA_WIDTH / 8)) - 1):0]   do_get_WSTRB(  );
        return WSTRB;
    endfunction

    function automatic logic   do_get_WSTRB_index1( int _this_dot_1 );
        return WSTRB[_this_dot_1];
    endfunction

    task automatic do_set_WID( logic [((AXI_ID_WIDTH) - 1):0]  WID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WID = WID_param;
        else
            m_WID <= WID_param;
    endtask

    task automatic do_set_WID_index1( int _this_dot_1, logic  WID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WID[_this_dot_1] = WID_param;
        else
            m_WID[_this_dot_1] <= WID_param;
    endtask

    function automatic logic [((AXI_ID_WIDTH) - 1):0]   do_get_WID(  );
        return WID;
    endfunction

    function automatic logic   do_get_WID_index1( int _this_dot_1 );
        return WID[_this_dot_1];
    endfunction

    task automatic do_set_WREADY( logic WREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WREADY = WREADY_param;
        else
            m_WREADY <= WREADY_param;
    endtask

    function automatic logic do_get_WREADY(  );
        return WREADY;
    endfunction

    task automatic do_set_WUSER( logic [7:0] WUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WUSER = WUSER_param;
        else
            m_WUSER <= WUSER_param;
    endtask

    task automatic do_set_WUSER_index1( int _this_dot_1, logic  WUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WUSER[_this_dot_1] = WUSER_param;
        else
            m_WUSER[_this_dot_1] <= WUSER_param;
    endtask

    function automatic logic [7:0]  do_get_WUSER(  );
        return WUSER;
    endfunction

    function automatic logic   do_get_WUSER_index1( int _this_dot_1 );
        return WUSER[_this_dot_1];
    endfunction

    task automatic do_set_BVALID( logic BVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BVALID = BVALID_param;
        else
            m_BVALID <= BVALID_param;
    endtask

    function automatic logic do_get_BVALID(  );
        return BVALID;
    endfunction

    task automatic do_set_BRESP( logic [1:0] BRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BRESP = BRESP_param;
        else
            m_BRESP <= BRESP_param;
    endtask

    task automatic do_set_BRESP_index1( int _this_dot_1, logic  BRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BRESP[_this_dot_1] = BRESP_param;
        else
            m_BRESP[_this_dot_1] <= BRESP_param;
    endtask

    function automatic logic [1:0]  do_get_BRESP(  );
        return BRESP;
    endfunction

    function automatic logic   do_get_BRESP_index1( int _this_dot_1 );
        return BRESP[_this_dot_1];
    endfunction

    task automatic do_set_BID( logic [((AXI_ID_WIDTH) - 1):0]  BID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BID = BID_param;
        else
            m_BID <= BID_param;
    endtask

    task automatic do_set_BID_index1( int _this_dot_1, logic  BID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BID[_this_dot_1] = BID_param;
        else
            m_BID[_this_dot_1] <= BID_param;
    endtask

    function automatic logic [((AXI_ID_WIDTH) - 1):0]   do_get_BID(  );
        return BID;
    endfunction

    function automatic logic   do_get_BID_index1( int _this_dot_1 );
        return BID[_this_dot_1];
    endfunction

    task automatic do_set_BREADY( logic BREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BREADY = BREADY_param;
        else
            m_BREADY <= BREADY_param;
    endtask

    function automatic logic do_get_BREADY(  );
        return BREADY;
    endfunction

    task automatic do_set_BUSER( logic [7:0] BUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BUSER = BUSER_param;
        else
            m_BUSER <= BUSER_param;
    endtask

    task automatic do_set_BUSER_index1( int _this_dot_1, logic  BUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BUSER[_this_dot_1] = BUSER_param;
        else
            m_BUSER[_this_dot_1] <= BUSER_param;
    endtask

    function automatic logic [7:0]  do_get_BUSER(  );
        return BUSER;
    endfunction

    function automatic logic   do_get_BUSER_index1( int _this_dot_1 );
        return BUSER[_this_dot_1];
    endfunction

    //------------------------------------------------------------------------------
    // Tasks to wait for a change to a global variable with read access
    //------------------------------------------------------------------------------

    task automatic do_wait_for_config_clk_init_value(  );
        begin
            bit _temp_config_clk_init_value;
            _temp_config_clk_init_value = config_clk_init_value;
            wait( _temp_config_clk_init_value != config_clk_init_value );
        end
    endtask

    task automatic do_wait_for_config_clk_phase_shift(  );
        begin
            int _temp_config_clk_phase_shift;
            _temp_config_clk_phase_shift = config_clk_phase_shift;
            wait( _temp_config_clk_phase_shift != config_clk_phase_shift );
        end
    endtask

    task automatic do_wait_for_config_clk_1st_time(  );
        begin
            int _temp_config_clk_1st_time;
            _temp_config_clk_1st_time = config_clk_1st_time;
            wait( _temp_config_clk_1st_time != config_clk_1st_time );
        end
    endtask

    task automatic do_wait_for_config_clk_2nd_time(  );
        begin
            int _temp_config_clk_2nd_time;
            _temp_config_clk_2nd_time = config_clk_2nd_time;
            wait( _temp_config_clk_2nd_time != config_clk_2nd_time );
        end
    endtask

    task automatic do_wait_for_config_setup_time(  );
        begin
            int _temp_config_setup_time;
            _temp_config_setup_time = config_setup_time;
            wait( _temp_config_setup_time != config_setup_time );
        end
    endtask

    task automatic do_wait_for_config_hold_time(  );
        begin
            int _temp_config_hold_time;
            _temp_config_hold_time = config_hold_time;
            wait( _temp_config_hold_time != config_hold_time );
        end
    endtask

    task automatic do_wait_for_config_max_transaction_time_factor(  );
        begin
            int unsigned _temp_config_max_transaction_time_factor;
            _temp_config_max_transaction_time_factor = config_max_transaction_time_factor;
            wait( _temp_config_max_transaction_time_factor != config_max_transaction_time_factor );
        end
    endtask

    task automatic do_wait_for_config_timeout_max_data_transfer(  );
        begin
            int _temp_config_timeout_max_data_transfer;
            _temp_config_timeout_max_data_transfer = config_timeout_max_data_transfer;
            wait( _temp_config_timeout_max_data_transfer != config_timeout_max_data_transfer );
        end
    endtask

    task automatic do_wait_for_config_burst_timeout_factor(  );
        begin
            int unsigned _temp_config_burst_timeout_factor;
            _temp_config_burst_timeout_factor = config_burst_timeout_factor;
            wait( _temp_config_burst_timeout_factor != config_burst_timeout_factor );
        end
    endtask

    task automatic do_wait_for_config_max_latency_AWVALID_assertion_to_AWREADY(  );
        begin
            int unsigned _temp_config_max_latency_AWVALID_assertion_to_AWREADY;
            _temp_config_max_latency_AWVALID_assertion_to_AWREADY = config_max_latency_AWVALID_assertion_to_AWREADY;
            wait( _temp_config_max_latency_AWVALID_assertion_to_AWREADY != config_max_latency_AWVALID_assertion_to_AWREADY );
        end
    endtask

    task automatic do_wait_for_config_max_latency_ARVALID_assertion_to_ARREADY(  );
        begin
            int unsigned _temp_config_max_latency_ARVALID_assertion_to_ARREADY;
            _temp_config_max_latency_ARVALID_assertion_to_ARREADY = config_max_latency_ARVALID_assertion_to_ARREADY;
            wait( _temp_config_max_latency_ARVALID_assertion_to_ARREADY != config_max_latency_ARVALID_assertion_to_ARREADY );
        end
    endtask

    task automatic do_wait_for_config_max_latency_RVALID_assertion_to_RREADY(  );
        begin
            int unsigned _temp_config_max_latency_RVALID_assertion_to_RREADY;
            _temp_config_max_latency_RVALID_assertion_to_RREADY = config_max_latency_RVALID_assertion_to_RREADY;
            wait( _temp_config_max_latency_RVALID_assertion_to_RREADY != config_max_latency_RVALID_assertion_to_RREADY );
        end
    endtask

    task automatic do_wait_for_config_max_latency_BVALID_assertion_to_BREADY(  );
        begin
            int unsigned _temp_config_max_latency_BVALID_assertion_to_BREADY;
            _temp_config_max_latency_BVALID_assertion_to_BREADY = config_max_latency_BVALID_assertion_to_BREADY;
            wait( _temp_config_max_latency_BVALID_assertion_to_BREADY != config_max_latency_BVALID_assertion_to_BREADY );
        end
    endtask

    task automatic do_wait_for_config_max_latency_WVALID_assertion_to_WREADY(  );
        begin
            int unsigned _temp_config_max_latency_WVALID_assertion_to_WREADY;
            _temp_config_max_latency_WVALID_assertion_to_WREADY = config_max_latency_WVALID_assertion_to_WREADY;
            wait( _temp_config_max_latency_WVALID_assertion_to_WREADY != config_max_latency_WVALID_assertion_to_WREADY );
        end
    endtask

    task automatic do_wait_for_config_write_ctrl_first_ratio(  );
        begin
            int _temp_config_write_ctrl_first_ratio;
            _temp_config_write_ctrl_first_ratio = config_write_ctrl_first_ratio;
            wait( _temp_config_write_ctrl_first_ratio != config_write_ctrl_first_ratio );
        end
    endtask

    task automatic do_wait_for_config_write_data_first_ratio(  );
        begin
            int _temp_config_write_data_first_ratio;
            _temp_config_write_data_first_ratio = config_write_data_first_ratio;
            wait( _temp_config_write_data_first_ratio != config_write_data_first_ratio );
        end
    endtask

    task automatic do_wait_for_config_write_ctrl_to_data_mintime(  );
        begin
            int unsigned _temp_config_write_ctrl_to_data_mintime;
            _temp_config_write_ctrl_to_data_mintime = config_write_ctrl_to_data_mintime;
            wait( _temp_config_write_ctrl_to_data_mintime != config_write_ctrl_to_data_mintime );
        end
    endtask

    task automatic do_wait_for_config_write_data_to_ctrl_mintime(  );
        begin
            int unsigned _temp_config_write_data_to_ctrl_mintime;
            _temp_config_write_data_to_ctrl_mintime = config_write_data_to_ctrl_mintime;
            wait( _temp_config_write_data_to_ctrl_mintime != config_write_data_to_ctrl_mintime );
        end
    endtask

    task automatic do_wait_for_config_master_write_delay(  );
        begin
            bit _temp_config_master_write_delay;
            _temp_config_master_write_delay = config_master_write_delay;
            wait( _temp_config_master_write_delay != config_master_write_delay );
        end
    endtask

    task automatic do_wait_for_config_reset_low_clocks(  );
        begin
            int _temp_config_reset_low_clocks;
            _temp_config_reset_low_clocks = config_reset_low_clocks;
            wait( _temp_config_reset_low_clocks != config_reset_low_clocks );
        end
    endtask

    task automatic do_wait_for_config_reset_hold_time(  );
        begin
            int _temp_config_reset_hold_time;
            _temp_config_reset_hold_time = config_reset_hold_time;
            wait( _temp_config_reset_hold_time != config_reset_hold_time );
        end
    endtask

    task automatic do_wait_for_config_protect_ready(  );
        begin
            bit _temp_config_protect_ready;
            _temp_config_protect_ready = config_protect_ready;
            wait( _temp_config_protect_ready != config_protect_ready );
        end
    endtask

    task automatic do_wait_for_config_enable_user_sideband(  );
        begin
            bit _temp_config_enable_user_sideband;
            _temp_config_enable_user_sideband = config_enable_user_sideband;
            wait( _temp_config_enable_user_sideband != config_enable_user_sideband );
        end
    endtask

    task automatic do_wait_for_config_extended_length_enable(  );
        begin
            bit _temp_config_extended_length_enable;
            _temp_config_extended_length_enable = config_extended_length_enable;
            wait( _temp_config_extended_length_enable != config_extended_length_enable );
        end
    endtask

    task automatic do_wait_for_config_enable_burst_reserved_value(  );
        begin
            bit _temp_config_enable_burst_reserved_value;
            _temp_config_enable_burst_reserved_value = config_enable_burst_reserved_value;
            wait( _temp_config_enable_burst_reserved_value != config_enable_burst_reserved_value );
        end
    endtask

    task automatic do_wait_for_config_enable_lock_reserved_value(  );
        begin
            bit _temp_config_enable_lock_reserved_value;
            _temp_config_enable_lock_reserved_value = config_enable_lock_reserved_value;
            wait( _temp_config_enable_lock_reserved_value != config_enable_lock_reserved_value );
        end
    endtask

    task automatic do_wait_for_config_enable_cache_reserved_value(  );
        begin
            bit _temp_config_enable_cache_reserved_value;
            _temp_config_enable_cache_reserved_value = config_enable_cache_reserved_value;
            wait( _temp_config_enable_cache_reserved_value != config_enable_cache_reserved_value );
        end
    endtask

    task automatic do_wait_for_config_enable_all_assertions(  );
        begin
            bit _temp_config_enable_all_assertions;
            _temp_config_enable_all_assertions = config_enable_all_assertions;
            wait( _temp_config_enable_all_assertions != config_enable_all_assertions );
        end
    endtask

    task automatic do_wait_for_config_enable_assertion(  );
        begin
            bit [255:0] _temp_config_enable_assertion;
            _temp_config_enable_assertion = config_enable_assertion;
            wait( _temp_config_enable_assertion != config_enable_assertion );
        end
    endtask

    task automatic do_wait_for_config_enable_assertion_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_enable_assertion;
            _temp_config_enable_assertion = config_enable_assertion[_this_dot_1];
            wait( _temp_config_enable_assertion != config_enable_assertion[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_enable_error(  );
        begin
            bit [255:0] _temp_config_enable_error;
            _temp_config_enable_error = config_enable_error;
            wait( _temp_config_enable_error != config_enable_error );
        end
    endtask

    task automatic do_wait_for_config_enable_error_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_enable_error;
            _temp_config_enable_error = config_enable_error[_this_dot_1];
            wait( _temp_config_enable_error != config_enable_error[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_enable_errors(  );
        begin
            bit _temp_config_enable_errors;
            _temp_config_enable_errors = config_enable_errors;
            wait( _temp_config_enable_errors != config_enable_errors );
        end
    endtask

    task automatic do_wait_for_config_enable_all_assertion_errors(  );
        begin
            bit _temp_config_enable_all_assertion_errors;
            _temp_config_enable_all_assertion_errors = config_enable_all_assertion_errors;
            wait( _temp_config_enable_all_assertion_errors != config_enable_all_assertion_errors );
        end
    endtask

    task automatic do_wait_for_config_abstraction_level(  );
        begin
            axi_abstraction_level_e _temp_config_abstraction_level;
            _temp_config_abstraction_level = config_abstraction_level;
            wait( _temp_config_abstraction_level != config_abstraction_level );
        end
    endtask

    task automatic do_wait_for_config_slave_start_addr(  );
        begin
            bit [((AXI_ADDRESS_WIDTH) - 1):0]  _temp_config_slave_start_addr;
            _temp_config_slave_start_addr = config_slave_start_addr;
            wait( _temp_config_slave_start_addr != config_slave_start_addr );
        end
    endtask

    task automatic do_wait_for_config_slave_start_addr_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_slave_start_addr;
            _temp_config_slave_start_addr = config_slave_start_addr[_this_dot_1];
            wait( _temp_config_slave_start_addr != config_slave_start_addr[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_slave_end_addr(  );
        begin
            bit [((AXI_ADDRESS_WIDTH) - 1):0]  _temp_config_slave_end_addr;
            _temp_config_slave_end_addr = config_slave_end_addr;
            wait( _temp_config_slave_end_addr != config_slave_end_addr );
        end
    endtask

    task automatic do_wait_for_config_slave_end_addr_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_slave_end_addr;
            _temp_config_slave_end_addr = config_slave_end_addr[_this_dot_1];
            wait( _temp_config_slave_end_addr != config_slave_end_addr[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_enable_slave_addr_range_in_bfm(  );
        begin
            bit _temp_config_enable_slave_addr_range_in_bfm;
            _temp_config_enable_slave_addr_range_in_bfm = config_enable_slave_addr_range_in_bfm;
            wait( _temp_config_enable_slave_addr_range_in_bfm != config_enable_slave_addr_range_in_bfm );
        end
    endtask

    task automatic do_wait_for_config_read_data_reordering_depth(  );
        begin
            int unsigned _temp_config_read_data_reordering_depth;
            _temp_config_read_data_reordering_depth = config_read_data_reordering_depth;
            wait( _temp_config_read_data_reordering_depth != config_read_data_reordering_depth );
        end
    endtask

    task automatic do_wait_for_config_enable_read_data_reordering_depth_in_bfm(  );
        begin
            bit _temp_config_enable_read_data_reordering_depth_in_bfm;
            _temp_config_enable_read_data_reordering_depth_in_bfm = config_enable_read_data_reordering_depth_in_bfm;
            wait( _temp_config_enable_read_data_reordering_depth_in_bfm != config_enable_read_data_reordering_depth_in_bfm );
        end
    endtask

    task automatic do_wait_for_config_awid_wid_mismatch(  );
        begin
            bit _temp_config_awid_wid_mismatch;
            _temp_config_awid_wid_mismatch = config_awid_wid_mismatch;
            wait( _temp_config_awid_wid_mismatch != config_awid_wid_mismatch );
        end
    endtask

    task automatic do_wait_for_config_length_last_mismatch_error(  );
        begin
            bit _temp_config_length_last_mismatch_error;
            _temp_config_length_last_mismatch_error = config_length_last_mismatch_error;
            wait( _temp_config_length_last_mismatch_error != config_length_last_mismatch_error );
        end
    endtask

    task automatic do_wait_for_config_master_error_position(  );
        begin
            axi_error_e _temp_config_master_error_position;
            _temp_config_master_error_position = config_master_error_position;
            wait( _temp_config_master_error_position != config_master_error_position );
        end
    endtask

    task automatic do_wait_for_dummy_var(  );
        begin
            axi_assertion_type_e _temp_dummy_var;
            _temp_dummy_var = dummy_var;
            wait( _temp_dummy_var != dummy_var );
        end
    endtask

    task automatic do_wait_for_config_wlast_length(  );
        begin
            int _temp_config_wlast_length;
            _temp_config_wlast_length = config_wlast_length;
            wait( _temp_config_wlast_length != config_wlast_length );
        end
    endtask

    task automatic do_wait_for_config_wid_for_awid_not_matching(  );
        begin
            bit [((AXI_ID_WIDTH) - 1):0]  _temp_config_wid_for_awid_not_matching;
            _temp_config_wid_for_awid_not_matching = config_wid_for_awid_not_matching;
            wait( _temp_config_wid_for_awid_not_matching != config_wid_for_awid_not_matching );
        end
    endtask

    task automatic do_wait_for_config_wid_for_awid_not_matching_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_wid_for_awid_not_matching;
            _temp_config_wid_for_awid_not_matching = config_wid_for_awid_not_matching[_this_dot_1];
            wait( _temp_config_wid_for_awid_not_matching != config_wid_for_awid_not_matching[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_support_exclusive_access(  );
        begin
            bit _temp_config_support_exclusive_access;
            _temp_config_support_exclusive_access = config_support_exclusive_access;
            wait( _temp_config_support_exclusive_access != config_support_exclusive_access );
        end
    endtask

    task automatic do_wait_for_config_write_data_interleaving_depth(  );
        begin
            int _temp_config_write_data_interleaving_depth;
            _temp_config_write_data_interleaving_depth = config_write_data_interleaving_depth;
            wait( _temp_config_write_data_interleaving_depth != config_write_data_interleaving_depth );
        end
    endtask

    task automatic do_wait_for_status_master_error(  );
        begin
            bit [15:0] _temp_status_master_error;
            _temp_status_master_error = status_master_error;
            wait( _temp_status_master_error != status_master_error );
        end
    endtask

    task automatic do_wait_for_status_master_error_index1( input int _this_dot_1 );
        begin
            bit  _temp_status_master_error;
            _temp_status_master_error = status_master_error[_this_dot_1];
            wait( _temp_status_master_error != status_master_error[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_status_num_reads_waiting_for_resp(  );
        begin
            int _temp_status_num_reads_waiting_for_resp;
            _temp_status_num_reads_waiting_for_resp = status_num_reads_waiting_for_resp;
            wait( _temp_status_num_reads_waiting_for_resp != status_num_reads_waiting_for_resp );
        end
    endtask

    task automatic do_wait_for_status_num_writes_waiting_for_response(  );
        begin
            int _temp_status_num_writes_waiting_for_response;
            _temp_status_num_writes_waiting_for_response = status_num_writes_waiting_for_response;
            wait( _temp_status_num_writes_waiting_for_response != status_num_writes_waiting_for_response );
        end
    endtask

    task automatic do_wait_for_check_total_num_wdata_outstanding(  );
        begin
            bit _temp_check_total_num_wdata_outstanding;
            _temp_check_total_num_wdata_outstanding = check_total_num_wdata_outstanding;
            wait( _temp_check_total_num_wdata_outstanding != check_total_num_wdata_outstanding );
        end
    endtask

    task automatic do_wait_for_total_num_wdata_outstanding(  );
        begin
            int _temp_total_num_wdata_outstanding;
            _temp_total_num_wdata_outstanding = total_num_wdata_outstanding;
            wait( _temp_total_num_wdata_outstanding != total_num_wdata_outstanding );
        end
    endtask

    task automatic do_wait_for_check_max_num_wdata_outstanding_per_id(  );
        begin
            bit _temp_check_max_num_wdata_outstanding_per_id;
            _temp_check_max_num_wdata_outstanding_per_id = check_max_num_wdata_outstanding_per_id;
            wait( _temp_check_max_num_wdata_outstanding_per_id != check_max_num_wdata_outstanding_per_id );
        end
    endtask

    task automatic do_wait_for_max_num_wdata_outstanding_per_id(  );
        begin
            int _temp_max_num_wdata_outstanding_per_id;
            _temp_max_num_wdata_outstanding_per_id = max_num_wdata_outstanding_per_id;
            wait( _temp_max_num_wdata_outstanding_per_id != max_num_wdata_outstanding_per_id );
        end
    endtask

    task automatic do_wait_for_check_max_num_waddr_outstanding_per_id(  );
        begin
            bit _temp_check_max_num_waddr_outstanding_per_id;
            _temp_check_max_num_waddr_outstanding_per_id = check_max_num_waddr_outstanding_per_id;
            wait( _temp_check_max_num_waddr_outstanding_per_id != check_max_num_waddr_outstanding_per_id );
        end
    endtask

    task automatic do_wait_for_max_num_waddr_outstanding_per_id(  );
        begin
            int _temp_max_num_waddr_outstanding_per_id;
            _temp_max_num_waddr_outstanding_per_id = max_num_waddr_outstanding_per_id;
            wait( _temp_max_num_waddr_outstanding_per_id != max_num_waddr_outstanding_per_id );
        end
    endtask

    task automatic do_wait_for_check_total_num_waddr_outstanding(  );
        begin
            bit _temp_check_total_num_waddr_outstanding;
            _temp_check_total_num_waddr_outstanding = check_total_num_waddr_outstanding;
            wait( _temp_check_total_num_waddr_outstanding != check_total_num_waddr_outstanding );
        end
    endtask

    task automatic do_wait_for_total_num_waddr_outstanding(  );
        begin
            int _temp_total_num_waddr_outstanding;
            _temp_total_num_waddr_outstanding = total_num_waddr_outstanding;
            wait( _temp_total_num_waddr_outstanding != total_num_waddr_outstanding );
        end
    endtask

    task automatic do_wait_for_status_outstanding_num_for_waddr(  );
        begin
            int _temp_status_outstanding_num_for_waddr;
            _temp_status_outstanding_num_for_waddr = status_outstanding_num_for_waddr;
            wait( _temp_status_outstanding_num_for_waddr != status_outstanding_num_for_waddr );
        end
    endtask

    task automatic do_wait_for_start_finding_outstanding_waddr(  );
        begin
            bit _temp_start_finding_outstanding_waddr;
            _temp_start_finding_outstanding_waddr = start_finding_outstanding_waddr;
            wait( _temp_start_finding_outstanding_waddr != start_finding_outstanding_waddr );
        end
    endtask

    task automatic do_wait_for_status_outstanding_num_for_wdata(  );
        begin
            int _temp_status_outstanding_num_for_wdata;
            _temp_status_outstanding_num_for_wdata = status_outstanding_num_for_wdata;
            wait( _temp_status_outstanding_num_for_wdata != status_outstanding_num_for_wdata );
        end
    endtask

    task automatic do_wait_for_start_finding_outstanding_wdata(  );
        begin
            bit _temp_start_finding_outstanding_wdata;
            _temp_start_finding_outstanding_wdata = start_finding_outstanding_wdata;
            wait( _temp_start_finding_outstanding_wdata != start_finding_outstanding_wdata );
        end
    endtask

    task automatic do_wait_for_find_waddr_outstanding_for_wid(  );
        begin
            bit [((AXI_ID_WIDTH) - 1):0]  _temp_find_waddr_outstanding_for_wid;
            _temp_find_waddr_outstanding_for_wid = find_waddr_outstanding_for_wid;
            wait( _temp_find_waddr_outstanding_for_wid != find_waddr_outstanding_for_wid );
        end
    endtask

    task automatic do_wait_for_find_waddr_outstanding_for_wid_index1( input int _this_dot_1 );
        begin
            bit  _temp_find_waddr_outstanding_for_wid;
            _temp_find_waddr_outstanding_for_wid = find_waddr_outstanding_for_wid[_this_dot_1];
            wait( _temp_find_waddr_outstanding_for_wid != find_waddr_outstanding_for_wid[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_find_wdata_outstanding_for_wid(  );
        begin
            bit [((AXI_ID_WIDTH) - 1):0]  _temp_find_wdata_outstanding_for_wid;
            _temp_find_wdata_outstanding_for_wid = find_wdata_outstanding_for_wid;
            wait( _temp_find_wdata_outstanding_for_wid != find_wdata_outstanding_for_wid );
        end
    endtask

    task automatic do_wait_for_find_wdata_outstanding_for_wid_index1( input int _this_dot_1 );
        begin
            bit  _temp_find_wdata_outstanding_for_wid;
            _temp_find_wdata_outstanding_for_wid = find_wdata_outstanding_for_wid[_this_dot_1];
            wait( _temp_find_wdata_outstanding_for_wid != find_wdata_outstanding_for_wid[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_change_in_wdata_outstanding_per_id(  );
        begin
            bit _temp_change_in_wdata_outstanding_per_id;
            _temp_change_in_wdata_outstanding_per_id = change_in_wdata_outstanding_per_id;
            wait( _temp_change_in_wdata_outstanding_per_id != change_in_wdata_outstanding_per_id );
        end
    endtask

    task automatic do_wait_for_start_finding_change_in_wdata(  );
        begin
            bit _temp_start_finding_change_in_wdata;
            _temp_start_finding_change_in_wdata = start_finding_change_in_wdata;
            wait( _temp_start_finding_change_in_wdata != start_finding_change_in_wdata );
        end
    endtask

    task automatic do_wait_for_find_change_in_wdata_outstanding_for_wid(  );
        begin
            bit [((AXI_ID_WIDTH) - 1):0]  _temp_find_change_in_wdata_outstanding_for_wid;
            _temp_find_change_in_wdata_outstanding_for_wid = find_change_in_wdata_outstanding_for_wid;
            wait( _temp_find_change_in_wdata_outstanding_for_wid != find_change_in_wdata_outstanding_for_wid );
        end
    endtask

    task automatic do_wait_for_find_change_in_wdata_outstanding_for_wid_index1( input int _this_dot_1 );
        begin
            bit  _temp_find_change_in_wdata_outstanding_for_wid;
            _temp_find_change_in_wdata_outstanding_for_wid = find_change_in_wdata_outstanding_for_wid[_this_dot_1];
            wait( _temp_find_change_in_wdata_outstanding_for_wid != find_change_in_wdata_outstanding_for_wid[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_max_outstanding_wr(  );
        begin
            int _temp_config_max_outstanding_wr;
            _temp_config_max_outstanding_wr = config_max_outstanding_wr;
            wait( _temp_config_max_outstanding_wr != config_max_outstanding_wr );
        end
    endtask

    task automatic do_wait_for_config_max_outstanding_rd(  );
        begin
            int _temp_config_max_outstanding_rd;
            _temp_config_max_outstanding_rd = config_max_outstanding_rd;
            wait( _temp_config_max_outstanding_rd != config_max_outstanding_rd );
        end
    endtask

    task automatic do_wait_for_config_error_on_deleted_valid_cycles(  );
        begin
            bit _temp_config_error_on_deleted_valid_cycles;
            _temp_config_error_on_deleted_valid_cycles = config_error_on_deleted_valid_cycles;
            wait( _temp_config_error_on_deleted_valid_cycles != config_error_on_deleted_valid_cycles );
        end
    endtask

    task automatic do_wait_for_config_stats_enable(  );
        begin
            bit _temp_config_stats_enable;
            _temp_config_stats_enable = config_stats_enable;
            wait( _temp_config_stats_enable != config_stats_enable );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_AXI_read_occupancy(  );
        begin
            bit _temp_config_stats_enable_AXI_read_occupancy;
            _temp_config_stats_enable_AXI_read_occupancy = config_stats_enable_AXI_read_occupancy;
            wait( _temp_config_stats_enable_AXI_read_occupancy != config_stats_enable_AXI_read_occupancy );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_AXI_write_occupancy(  );
        begin
            bit _temp_config_stats_enable_AXI_write_occupancy;
            _temp_config_stats_enable_AXI_write_occupancy = config_stats_enable_AXI_write_occupancy;
            wait( _temp_config_stats_enable_AXI_write_occupancy != config_stats_enable_AXI_write_occupancy );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_data_occupancy(  );
        begin
            bit _temp_config_stats_enable_read_data_occupancy;
            _temp_config_stats_enable_read_data_occupancy = config_stats_enable_read_data_occupancy;
            wait( _temp_config_stats_enable_read_data_occupancy != config_stats_enable_read_data_occupancy );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_data_occupancy(  );
        begin
            bit _temp_config_stats_enable_write_data_occupancy;
            _temp_config_stats_enable_write_data_occupancy = config_stats_enable_write_data_occupancy;
            wait( _temp_config_stats_enable_write_data_occupancy != config_stats_enable_write_data_occupancy );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_latency(  );
        begin
            bit _temp_config_stats_enable_read_latency;
            _temp_config_stats_enable_read_latency = config_stats_enable_read_latency;
            wait( _temp_config_stats_enable_read_latency != config_stats_enable_read_latency );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_latency(  );
        begin
            bit _temp_config_stats_enable_write_latency;
            _temp_config_stats_enable_write_latency = config_stats_enable_write_latency;
            wait( _temp_config_stats_enable_write_latency != config_stats_enable_write_latency );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_address_waits(  );
        begin
            bit _temp_config_stats_enable_read_address_waits;
            _temp_config_stats_enable_read_address_waits = config_stats_enable_read_address_waits;
            wait( _temp_config_stats_enable_read_address_waits != config_stats_enable_read_address_waits );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_data_waits(  );
        begin
            bit _temp_config_stats_enable_read_data_waits;
            _temp_config_stats_enable_read_data_waits = config_stats_enable_read_data_waits;
            wait( _temp_config_stats_enable_read_data_waits != config_stats_enable_read_data_waits );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_address_waits(  );
        begin
            bit _temp_config_stats_enable_write_address_waits;
            _temp_config_stats_enable_write_address_waits = config_stats_enable_write_address_waits;
            wait( _temp_config_stats_enable_write_address_waits != config_stats_enable_write_address_waits );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_data_waits(  );
        begin
            bit _temp_config_stats_enable_write_data_waits;
            _temp_config_stats_enable_write_data_waits = config_stats_enable_write_data_waits;
            wait( _temp_config_stats_enable_write_data_waits != config_stats_enable_write_data_waits );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_response_waits(  );
        begin
            bit _temp_config_stats_enable_write_response_waits;
            _temp_config_stats_enable_write_response_waits = config_stats_enable_write_response_waits;
            wait( _temp_config_stats_enable_write_response_waits != config_stats_enable_write_response_waits );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_bandwidth(  );
        begin
            bit _temp_config_stats_enable_read_bandwidth;
            _temp_config_stats_enable_read_bandwidth = config_stats_enable_read_bandwidth;
            wait( _temp_config_stats_enable_read_bandwidth != config_stats_enable_read_bandwidth );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_bandwidth(  );
        begin
            bit _temp_config_stats_enable_write_bandwidth;
            _temp_config_stats_enable_write_bandwidth = config_stats_enable_write_bandwidth;
            wait( _temp_config_stats_enable_write_bandwidth != config_stats_enable_write_bandwidth );
        end
    endtask

    task automatic do_wait_for_config_stats_AXI_read_occupancy_step(  );
        begin
            int _temp_config_stats_AXI_read_occupancy_step;
            _temp_config_stats_AXI_read_occupancy_step = config_stats_AXI_read_occupancy_step;
            wait( _temp_config_stats_AXI_read_occupancy_step != config_stats_AXI_read_occupancy_step );
        end
    endtask

    task automatic do_wait_for_config_stats_AXI_read_occupancy_multiple(  );
        begin
            int _temp_config_stats_AXI_read_occupancy_multiple;
            _temp_config_stats_AXI_read_occupancy_multiple = config_stats_AXI_read_occupancy_multiple;
            wait( _temp_config_stats_AXI_read_occupancy_multiple != config_stats_AXI_read_occupancy_multiple );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_active(  );
        begin
            bit _temp_stats_AXI_read_active;
            _temp_stats_AXI_read_active = stats_AXI_read_active;
            wait( _temp_stats_AXI_read_active != stats_AXI_read_active );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_occupancy_sw(  );
        begin
            int _temp_stats_AXI_read_occupancy_sw;
            _temp_stats_AXI_read_occupancy_sw = stats_AXI_read_occupancy_sw;
            wait( _temp_stats_AXI_read_occupancy_sw != stats_AXI_read_occupancy_sw );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_occupancy_sw_updated(  );
        begin
            int _temp_stats_AXI_read_occupancy_sw_updated;
            _temp_stats_AXI_read_occupancy_sw_updated = stats_AXI_read_occupancy_sw_updated;
            wait( _temp_stats_AXI_read_occupancy_sw_updated != stats_AXI_read_occupancy_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_idle_sw(  );
        begin
            int _temp_stats_AXI_read_idle_sw;
            _temp_stats_AXI_read_idle_sw = stats_AXI_read_idle_sw;
            wait( _temp_stats_AXI_read_idle_sw != stats_AXI_read_idle_sw );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_occupancy_min(  );
        begin
            int _temp_stats_AXI_read_occupancy_min;
            _temp_stats_AXI_read_occupancy_min = stats_AXI_read_occupancy_min;
            wait( _temp_stats_AXI_read_occupancy_min != stats_AXI_read_occupancy_min );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_idle_min(  );
        begin
            int _temp_stats_AXI_read_idle_min;
            _temp_stats_AXI_read_idle_min = stats_AXI_read_idle_min;
            wait( _temp_stats_AXI_read_idle_min != stats_AXI_read_idle_min );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_occupancy_max(  );
        begin
            int _temp_stats_AXI_read_occupancy_max;
            _temp_stats_AXI_read_occupancy_max = stats_AXI_read_occupancy_max;
            wait( _temp_stats_AXI_read_occupancy_max != stats_AXI_read_occupancy_max );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_idle_max(  );
        begin
            int _temp_stats_AXI_read_idle_max;
            _temp_stats_AXI_read_idle_max = stats_AXI_read_idle_max;
            wait( _temp_stats_AXI_read_idle_max != stats_AXI_read_idle_max );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_occupancy_mean(  );
        begin
            int _temp_stats_AXI_read_occupancy_mean;
            _temp_stats_AXI_read_occupancy_mean = stats_AXI_read_occupancy_mean;
            wait( _temp_stats_AXI_read_occupancy_mean != stats_AXI_read_occupancy_mean );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_idle_mean(  );
        begin
            int _temp_stats_AXI_read_idle_mean;
            _temp_stats_AXI_read_idle_mean = stats_AXI_read_idle_mean;
            wait( _temp_stats_AXI_read_idle_mean != stats_AXI_read_idle_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_AXI_write_occupancy_step(  );
        begin
            int _temp_config_stats_AXI_write_occupancy_step;
            _temp_config_stats_AXI_write_occupancy_step = config_stats_AXI_write_occupancy_step;
            wait( _temp_config_stats_AXI_write_occupancy_step != config_stats_AXI_write_occupancy_step );
        end
    endtask

    task automatic do_wait_for_config_stats_AXI_write_occupancy_multiple(  );
        begin
            int _temp_config_stats_AXI_write_occupancy_multiple;
            _temp_config_stats_AXI_write_occupancy_multiple = config_stats_AXI_write_occupancy_multiple;
            wait( _temp_config_stats_AXI_write_occupancy_multiple != config_stats_AXI_write_occupancy_multiple );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_active(  );
        begin
            bit _temp_stats_AXI_write_active;
            _temp_stats_AXI_write_active = stats_AXI_write_active;
            wait( _temp_stats_AXI_write_active != stats_AXI_write_active );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_occupancy_sw(  );
        begin
            int _temp_stats_AXI_write_occupancy_sw;
            _temp_stats_AXI_write_occupancy_sw = stats_AXI_write_occupancy_sw;
            wait( _temp_stats_AXI_write_occupancy_sw != stats_AXI_write_occupancy_sw );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_occupancy_sw_updated(  );
        begin
            int _temp_stats_AXI_write_occupancy_sw_updated;
            _temp_stats_AXI_write_occupancy_sw_updated = stats_AXI_write_occupancy_sw_updated;
            wait( _temp_stats_AXI_write_occupancy_sw_updated != stats_AXI_write_occupancy_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_idle_sw(  );
        begin
            int _temp_stats_AXI_write_idle_sw;
            _temp_stats_AXI_write_idle_sw = stats_AXI_write_idle_sw;
            wait( _temp_stats_AXI_write_idle_sw != stats_AXI_write_idle_sw );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_occupancy_min(  );
        begin
            int _temp_stats_AXI_write_occupancy_min;
            _temp_stats_AXI_write_occupancy_min = stats_AXI_write_occupancy_min;
            wait( _temp_stats_AXI_write_occupancy_min != stats_AXI_write_occupancy_min );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_idle_min(  );
        begin
            int _temp_stats_AXI_write_idle_min;
            _temp_stats_AXI_write_idle_min = stats_AXI_write_idle_min;
            wait( _temp_stats_AXI_write_idle_min != stats_AXI_write_idle_min );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_occupancy_max(  );
        begin
            int _temp_stats_AXI_write_occupancy_max;
            _temp_stats_AXI_write_occupancy_max = stats_AXI_write_occupancy_max;
            wait( _temp_stats_AXI_write_occupancy_max != stats_AXI_write_occupancy_max );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_idle_max(  );
        begin
            int _temp_stats_AXI_write_idle_max;
            _temp_stats_AXI_write_idle_max = stats_AXI_write_idle_max;
            wait( _temp_stats_AXI_write_idle_max != stats_AXI_write_idle_max );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_occupancy_mean(  );
        begin
            int _temp_stats_AXI_write_occupancy_mean;
            _temp_stats_AXI_write_occupancy_mean = stats_AXI_write_occupancy_mean;
            wait( _temp_stats_AXI_write_occupancy_mean != stats_AXI_write_occupancy_mean );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_idle_mean(  );
        begin
            int _temp_stats_AXI_write_idle_mean;
            _temp_stats_AXI_write_idle_mean = stats_AXI_write_idle_mean;
            wait( _temp_stats_AXI_write_idle_mean != stats_AXI_write_idle_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_read_data_occupancy_step(  );
        begin
            int _temp_config_stats_read_data_occupancy_step;
            _temp_config_stats_read_data_occupancy_step = config_stats_read_data_occupancy_step;
            wait( _temp_config_stats_read_data_occupancy_step != config_stats_read_data_occupancy_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_data_occupancy_multiple(  );
        begin
            int _temp_config_stats_read_data_occupancy_multiple;
            _temp_config_stats_read_data_occupancy_multiple = config_stats_read_data_occupancy_multiple;
            wait( _temp_config_stats_read_data_occupancy_multiple != config_stats_read_data_occupancy_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_data_occupancy_sw(  );
        begin
            int _temp_stats_read_data_occupancy_sw;
            _temp_stats_read_data_occupancy_sw = stats_read_data_occupancy_sw;
            wait( _temp_stats_read_data_occupancy_sw != stats_read_data_occupancy_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_data_occupancy_sw_updated(  );
        begin
            int _temp_stats_read_data_occupancy_sw_updated;
            _temp_stats_read_data_occupancy_sw_updated = stats_read_data_occupancy_sw_updated;
            wait( _temp_stats_read_data_occupancy_sw_updated != stats_read_data_occupancy_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_read_data_idle_sw(  );
        begin
            int _temp_stats_read_data_idle_sw;
            _temp_stats_read_data_idle_sw = stats_read_data_idle_sw;
            wait( _temp_stats_read_data_idle_sw != stats_read_data_idle_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_data_occupancy_min(  );
        begin
            int _temp_stats_read_data_occupancy_min;
            _temp_stats_read_data_occupancy_min = stats_read_data_occupancy_min;
            wait( _temp_stats_read_data_occupancy_min != stats_read_data_occupancy_min );
        end
    endtask

    task automatic do_wait_for_stats_read_data_idle_min(  );
        begin
            int _temp_stats_read_data_idle_min;
            _temp_stats_read_data_idle_min = stats_read_data_idle_min;
            wait( _temp_stats_read_data_idle_min != stats_read_data_idle_min );
        end
    endtask

    task automatic do_wait_for_stats_read_data_occupancy_max(  );
        begin
            int _temp_stats_read_data_occupancy_max;
            _temp_stats_read_data_occupancy_max = stats_read_data_occupancy_max;
            wait( _temp_stats_read_data_occupancy_max != stats_read_data_occupancy_max );
        end
    endtask

    task automatic do_wait_for_stats_read_data_idle_max(  );
        begin
            int _temp_stats_read_data_idle_max;
            _temp_stats_read_data_idle_max = stats_read_data_idle_max;
            wait( _temp_stats_read_data_idle_max != stats_read_data_idle_max );
        end
    endtask

    task automatic do_wait_for_stats_read_data_occupancy_mean(  );
        begin
            int _temp_stats_read_data_occupancy_mean;
            _temp_stats_read_data_occupancy_mean = stats_read_data_occupancy_mean;
            wait( _temp_stats_read_data_occupancy_mean != stats_read_data_occupancy_mean );
        end
    endtask

    task automatic do_wait_for_stats_read_data_idle_mean(  );
        begin
            int _temp_stats_read_data_idle_mean;
            _temp_stats_read_data_idle_mean = stats_read_data_idle_mean;
            wait( _temp_stats_read_data_idle_mean != stats_read_data_idle_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_data_occupancy_step(  );
        begin
            int _temp_config_stats_write_data_occupancy_step;
            _temp_config_stats_write_data_occupancy_step = config_stats_write_data_occupancy_step;
            wait( _temp_config_stats_write_data_occupancy_step != config_stats_write_data_occupancy_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_data_occupancy_multiple(  );
        begin
            int _temp_config_stats_write_data_occupancy_multiple;
            _temp_config_stats_write_data_occupancy_multiple = config_stats_write_data_occupancy_multiple;
            wait( _temp_config_stats_write_data_occupancy_multiple != config_stats_write_data_occupancy_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_data_occupancy_sw(  );
        begin
            int _temp_stats_write_data_occupancy_sw;
            _temp_stats_write_data_occupancy_sw = stats_write_data_occupancy_sw;
            wait( _temp_stats_write_data_occupancy_sw != stats_write_data_occupancy_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_data_occupancy_sw_updated(  );
        begin
            int _temp_stats_write_data_occupancy_sw_updated;
            _temp_stats_write_data_occupancy_sw_updated = stats_write_data_occupancy_sw_updated;
            wait( _temp_stats_write_data_occupancy_sw_updated != stats_write_data_occupancy_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_write_data_idle_sw(  );
        begin
            int _temp_stats_write_data_idle_sw;
            _temp_stats_write_data_idle_sw = stats_write_data_idle_sw;
            wait( _temp_stats_write_data_idle_sw != stats_write_data_idle_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_data_occupancy_min(  );
        begin
            int _temp_stats_write_data_occupancy_min;
            _temp_stats_write_data_occupancy_min = stats_write_data_occupancy_min;
            wait( _temp_stats_write_data_occupancy_min != stats_write_data_occupancy_min );
        end
    endtask

    task automatic do_wait_for_stats_write_data_idle_min(  );
        begin
            int _temp_stats_write_data_idle_min;
            _temp_stats_write_data_idle_min = stats_write_data_idle_min;
            wait( _temp_stats_write_data_idle_min != stats_write_data_idle_min );
        end
    endtask

    task automatic do_wait_for_stats_write_data_occupancy_max(  );
        begin
            int _temp_stats_write_data_occupancy_max;
            _temp_stats_write_data_occupancy_max = stats_write_data_occupancy_max;
            wait( _temp_stats_write_data_occupancy_max != stats_write_data_occupancy_max );
        end
    endtask

    task automatic do_wait_for_stats_write_data_idle_max(  );
        begin
            int _temp_stats_write_data_idle_max;
            _temp_stats_write_data_idle_max = stats_write_data_idle_max;
            wait( _temp_stats_write_data_idle_max != stats_write_data_idle_max );
        end
    endtask

    task automatic do_wait_for_stats_write_data_occupancy_mean(  );
        begin
            int _temp_stats_write_data_occupancy_mean;
            _temp_stats_write_data_occupancy_mean = stats_write_data_occupancy_mean;
            wait( _temp_stats_write_data_occupancy_mean != stats_write_data_occupancy_mean );
        end
    endtask

    task automatic do_wait_for_stats_write_data_idle_mean(  );
        begin
            int _temp_stats_write_data_idle_mean;
            _temp_stats_write_data_idle_mean = stats_write_data_idle_mean;
            wait( _temp_stats_write_data_idle_mean != stats_write_data_idle_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_read_bandwidth_step(  );
        begin
            int _temp_config_stats_read_bandwidth_step;
            _temp_config_stats_read_bandwidth_step = config_stats_read_bandwidth_step;
            wait( _temp_config_stats_read_bandwidth_step != config_stats_read_bandwidth_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_bandwidth_multiple(  );
        begin
            int _temp_config_stats_read_bandwidth_multiple;
            _temp_config_stats_read_bandwidth_multiple = config_stats_read_bandwidth_multiple;
            wait( _temp_config_stats_read_bandwidth_multiple != config_stats_read_bandwidth_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_bandwidth_sw(  );
        begin
            int _temp_stats_read_bandwidth_sw;
            _temp_stats_read_bandwidth_sw = stats_read_bandwidth_sw;
            wait( _temp_stats_read_bandwidth_sw != stats_read_bandwidth_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_bandwidth_sw_updated(  );
        begin
            int _temp_stats_read_bandwidth_sw_updated;
            _temp_stats_read_bandwidth_sw_updated = stats_read_bandwidth_sw_updated;
            wait( _temp_stats_read_bandwidth_sw_updated != stats_read_bandwidth_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_read_bandwidth_min(  );
        begin
            int _temp_stats_read_bandwidth_min;
            _temp_stats_read_bandwidth_min = stats_read_bandwidth_min;
            wait( _temp_stats_read_bandwidth_min != stats_read_bandwidth_min );
        end
    endtask

    task automatic do_wait_for_stats_read_bandwidth_max(  );
        begin
            int _temp_stats_read_bandwidth_max;
            _temp_stats_read_bandwidth_max = stats_read_bandwidth_max;
            wait( _temp_stats_read_bandwidth_max != stats_read_bandwidth_max );
        end
    endtask

    task automatic do_wait_for_stats_read_bandwidth_mean(  );
        begin
            int _temp_stats_read_bandwidth_mean;
            _temp_stats_read_bandwidth_mean = stats_read_bandwidth_mean;
            wait( _temp_stats_read_bandwidth_mean != stats_read_bandwidth_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_bandwidth_step(  );
        begin
            int _temp_config_stats_write_bandwidth_step;
            _temp_config_stats_write_bandwidth_step = config_stats_write_bandwidth_step;
            wait( _temp_config_stats_write_bandwidth_step != config_stats_write_bandwidth_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_bandwidth_multiple(  );
        begin
            int _temp_config_stats_write_bandwidth_multiple;
            _temp_config_stats_write_bandwidth_multiple = config_stats_write_bandwidth_multiple;
            wait( _temp_config_stats_write_bandwidth_multiple != config_stats_write_bandwidth_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_bandwidth_sw(  );
        begin
            int _temp_stats_write_bandwidth_sw;
            _temp_stats_write_bandwidth_sw = stats_write_bandwidth_sw;
            wait( _temp_stats_write_bandwidth_sw != stats_write_bandwidth_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_bandwidth_sw_updated(  );
        begin
            int _temp_stats_write_bandwidth_sw_updated;
            _temp_stats_write_bandwidth_sw_updated = stats_write_bandwidth_sw_updated;
            wait( _temp_stats_write_bandwidth_sw_updated != stats_write_bandwidth_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_write_bandwidth_min(  );
        begin
            int _temp_stats_write_bandwidth_min;
            _temp_stats_write_bandwidth_min = stats_write_bandwidth_min;
            wait( _temp_stats_write_bandwidth_min != stats_write_bandwidth_min );
        end
    endtask

    task automatic do_wait_for_stats_write_bandwidth_max(  );
        begin
            int _temp_stats_write_bandwidth_max;
            _temp_stats_write_bandwidth_max = stats_write_bandwidth_max;
            wait( _temp_stats_write_bandwidth_max != stats_write_bandwidth_max );
        end
    endtask

    task automatic do_wait_for_stats_write_bandwidth_mean(  );
        begin
            int _temp_stats_write_bandwidth_mean;
            _temp_stats_write_bandwidth_mean = stats_write_bandwidth_mean;
            wait( _temp_stats_write_bandwidth_mean != stats_write_bandwidth_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_read_latency_step(  );
        begin
            int _temp_config_stats_read_latency_step;
            _temp_config_stats_read_latency_step = config_stats_read_latency_step;
            wait( _temp_config_stats_read_latency_step != config_stats_read_latency_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_latency_multiple(  );
        begin
            int _temp_config_stats_read_latency_multiple;
            _temp_config_stats_read_latency_multiple = config_stats_read_latency_multiple;
            wait( _temp_config_stats_read_latency_multiple != config_stats_read_latency_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_latency_sw_updated(  );
        begin
            int _temp_stats_read_latency_sw_updated;
            _temp_stats_read_latency_sw_updated = stats_read_latency_sw_updated;
            wait( _temp_stats_read_latency_sw_updated != stats_read_latency_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_read_address_data_latency_inst(  );
        begin
            int _temp_stats_read_address_data_latency_inst;
            _temp_stats_read_address_data_latency_inst = stats_read_address_data_latency_inst;
            wait( _temp_stats_read_address_data_latency_inst != stats_read_address_data_latency_inst );
        end
    endtask

    task automatic do_wait_for_stats_read_address_data_latency_sw(  );
        begin
            int _temp_stats_read_address_data_latency_sw;
            _temp_stats_read_address_data_latency_sw = stats_read_address_data_latency_sw;
            wait( _temp_stats_read_address_data_latency_sw != stats_read_address_data_latency_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_address_data_latency_min(  );
        begin
            int _temp_stats_read_address_data_latency_min;
            _temp_stats_read_address_data_latency_min = stats_read_address_data_latency_min;
            wait( _temp_stats_read_address_data_latency_min != stats_read_address_data_latency_min );
        end
    endtask

    task automatic do_wait_for_stats_read_address_data_latency_max(  );
        begin
            int _temp_stats_read_address_data_latency_max;
            _temp_stats_read_address_data_latency_max = stats_read_address_data_latency_max;
            wait( _temp_stats_read_address_data_latency_max != stats_read_address_data_latency_max );
        end
    endtask

    task automatic do_wait_for_stats_read_address_data_latency_mean(  );
        begin
            int _temp_stats_read_address_data_latency_mean;
            _temp_stats_read_address_data_latency_mean = stats_read_address_data_latency_mean;
            wait( _temp_stats_read_address_data_latency_mean != stats_read_address_data_latency_mean );
        end
    endtask

    task automatic do_wait_for_stats_read_address_address_latency_inst(  );
        begin
            int _temp_stats_read_address_address_latency_inst;
            _temp_stats_read_address_address_latency_inst = stats_read_address_address_latency_inst;
            wait( _temp_stats_read_address_address_latency_inst != stats_read_address_address_latency_inst );
        end
    endtask

    task automatic do_wait_for_stats_read_address_address_latency_sw(  );
        begin
            int _temp_stats_read_address_address_latency_sw;
            _temp_stats_read_address_address_latency_sw = stats_read_address_address_latency_sw;
            wait( _temp_stats_read_address_address_latency_sw != stats_read_address_address_latency_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_address_address_latency_min(  );
        begin
            int _temp_stats_read_address_address_latency_min;
            _temp_stats_read_address_address_latency_min = stats_read_address_address_latency_min;
            wait( _temp_stats_read_address_address_latency_min != stats_read_address_address_latency_min );
        end
    endtask

    task automatic do_wait_for_stats_read_address_address_latency_max(  );
        begin
            int _temp_stats_read_address_address_latency_max;
            _temp_stats_read_address_address_latency_max = stats_read_address_address_latency_max;
            wait( _temp_stats_read_address_address_latency_max != stats_read_address_address_latency_max );
        end
    endtask

    task automatic do_wait_for_stats_read_address_address_latency_mean(  );
        begin
            int _temp_stats_read_address_address_latency_mean;
            _temp_stats_read_address_address_latency_mean = stats_read_address_address_latency_mean;
            wait( _temp_stats_read_address_address_latency_mean != stats_read_address_address_latency_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_latency_step(  );
        begin
            int _temp_config_stats_write_latency_step;
            _temp_config_stats_write_latency_step = config_stats_write_latency_step;
            wait( _temp_config_stats_write_latency_step != config_stats_write_latency_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_latency_multiple(  );
        begin
            int _temp_config_stats_write_latency_multiple;
            _temp_config_stats_write_latency_multiple = config_stats_write_latency_multiple;
            wait( _temp_config_stats_write_latency_multiple != config_stats_write_latency_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_latency_sw_updated(  );
        begin
            int _temp_stats_write_latency_sw_updated;
            _temp_stats_write_latency_sw_updated = stats_write_latency_sw_updated;
            wait( _temp_stats_write_latency_sw_updated != stats_write_latency_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_write_address_data_latency_inst(  );
        begin
            int _temp_stats_write_address_data_latency_inst;
            _temp_stats_write_address_data_latency_inst = stats_write_address_data_latency_inst;
            wait( _temp_stats_write_address_data_latency_inst != stats_write_address_data_latency_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_address_data_latency_sw(  );
        begin
            int _temp_stats_write_address_data_latency_sw;
            _temp_stats_write_address_data_latency_sw = stats_write_address_data_latency_sw;
            wait( _temp_stats_write_address_data_latency_sw != stats_write_address_data_latency_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_address_data_latency_min(  );
        begin
            int _temp_stats_write_address_data_latency_min;
            _temp_stats_write_address_data_latency_min = stats_write_address_data_latency_min;
            wait( _temp_stats_write_address_data_latency_min != stats_write_address_data_latency_min );
        end
    endtask

    task automatic do_wait_for_stats_write_address_data_latency_max(  );
        begin
            int _temp_stats_write_address_data_latency_max;
            _temp_stats_write_address_data_latency_max = stats_write_address_data_latency_max;
            wait( _temp_stats_write_address_data_latency_max != stats_write_address_data_latency_max );
        end
    endtask

    task automatic do_wait_for_stats_write_address_data_latency_mean(  );
        begin
            int _temp_stats_write_address_data_latency_mean;
            _temp_stats_write_address_data_latency_mean = stats_write_address_data_latency_mean;
            wait( _temp_stats_write_address_data_latency_mean != stats_write_address_data_latency_mean );
        end
    endtask

    task automatic do_wait_for_stats_write_data_response_latency_inst(  );
        begin
            int _temp_stats_write_data_response_latency_inst;
            _temp_stats_write_data_response_latency_inst = stats_write_data_response_latency_inst;
            wait( _temp_stats_write_data_response_latency_inst != stats_write_data_response_latency_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_data_response_latency_sw(  );
        begin
            int _temp_stats_write_data_response_latency_sw;
            _temp_stats_write_data_response_latency_sw = stats_write_data_response_latency_sw;
            wait( _temp_stats_write_data_response_latency_sw != stats_write_data_response_latency_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_data_response_latency_min(  );
        begin
            int _temp_stats_write_data_response_latency_min;
            _temp_stats_write_data_response_latency_min = stats_write_data_response_latency_min;
            wait( _temp_stats_write_data_response_latency_min != stats_write_data_response_latency_min );
        end
    endtask

    task automatic do_wait_for_stats_write_data_response_latency_max(  );
        begin
            int _temp_stats_write_data_response_latency_max;
            _temp_stats_write_data_response_latency_max = stats_write_data_response_latency_max;
            wait( _temp_stats_write_data_response_latency_max != stats_write_data_response_latency_max );
        end
    endtask

    task automatic do_wait_for_stats_write_data_response_latency_mean(  );
        begin
            int _temp_stats_write_data_response_latency_mean;
            _temp_stats_write_data_response_latency_mean = stats_write_data_response_latency_mean;
            wait( _temp_stats_write_data_response_latency_mean != stats_write_data_response_latency_mean );
        end
    endtask

    task automatic do_wait_for_stats_write_address_address_latency_inst(  );
        begin
            int _temp_stats_write_address_address_latency_inst;
            _temp_stats_write_address_address_latency_inst = stats_write_address_address_latency_inst;
            wait( _temp_stats_write_address_address_latency_inst != stats_write_address_address_latency_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_address_address_latency_sw(  );
        begin
            int _temp_stats_write_address_address_latency_sw;
            _temp_stats_write_address_address_latency_sw = stats_write_address_address_latency_sw;
            wait( _temp_stats_write_address_address_latency_sw != stats_write_address_address_latency_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_address_address_latency_min(  );
        begin
            int _temp_stats_write_address_address_latency_min;
            _temp_stats_write_address_address_latency_min = stats_write_address_address_latency_min;
            wait( _temp_stats_write_address_address_latency_min != stats_write_address_address_latency_min );
        end
    endtask

    task automatic do_wait_for_stats_write_address_address_latency_max(  );
        begin
            int _temp_stats_write_address_address_latency_max;
            _temp_stats_write_address_address_latency_max = stats_write_address_address_latency_max;
            wait( _temp_stats_write_address_address_latency_max != stats_write_address_address_latency_max );
        end
    endtask

    task automatic do_wait_for_stats_write_address_address_latency_mean(  );
        begin
            int _temp_stats_write_address_address_latency_mean;
            _temp_stats_write_address_address_latency_mean = stats_write_address_address_latency_mean;
            wait( _temp_stats_write_address_address_latency_mean != stats_write_address_address_latency_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_read_address_waits_step(  );
        begin
            int _temp_config_stats_read_address_waits_step;
            _temp_config_stats_read_address_waits_step = config_stats_read_address_waits_step;
            wait( _temp_config_stats_read_address_waits_step != config_stats_read_address_waits_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_address_waits_multiple(  );
        begin
            int _temp_config_stats_read_address_waits_multiple;
            _temp_config_stats_read_address_waits_multiple = config_stats_read_address_waits_multiple;
            wait( _temp_config_stats_read_address_waits_multiple != config_stats_read_address_waits_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_inst(  );
        begin
            int _temp_stats_read_address_waits_inst;
            _temp_stats_read_address_waits_inst = stats_read_address_waits_inst;
            wait( _temp_stats_read_address_waits_inst != stats_read_address_waits_inst );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_sw(  );
        begin
            int _temp_stats_read_address_waits_sw;
            _temp_stats_read_address_waits_sw = stats_read_address_waits_sw;
            wait( _temp_stats_read_address_waits_sw != stats_read_address_waits_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_sw_updated(  );
        begin
            int _temp_stats_read_address_waits_sw_updated;
            _temp_stats_read_address_waits_sw_updated = stats_read_address_waits_sw_updated;
            wait( _temp_stats_read_address_waits_sw_updated != stats_read_address_waits_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_min(  );
        begin
            int _temp_stats_read_address_waits_min;
            _temp_stats_read_address_waits_min = stats_read_address_waits_min;
            wait( _temp_stats_read_address_waits_min != stats_read_address_waits_min );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_max(  );
        begin
            int _temp_stats_read_address_waits_max;
            _temp_stats_read_address_waits_max = stats_read_address_waits_max;
            wait( _temp_stats_read_address_waits_max != stats_read_address_waits_max );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_mean(  );
        begin
            int _temp_stats_read_address_waits_mean;
            _temp_stats_read_address_waits_mean = stats_read_address_waits_mean;
            wait( _temp_stats_read_address_waits_mean != stats_read_address_waits_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_read_data_waits_step(  );
        begin
            int _temp_config_stats_read_data_waits_step;
            _temp_config_stats_read_data_waits_step = config_stats_read_data_waits_step;
            wait( _temp_config_stats_read_data_waits_step != config_stats_read_data_waits_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_data_waits_multiple(  );
        begin
            int _temp_config_stats_read_data_waits_multiple;
            _temp_config_stats_read_data_waits_multiple = config_stats_read_data_waits_multiple;
            wait( _temp_config_stats_read_data_waits_multiple != config_stats_read_data_waits_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_inst(  );
        begin
            int _temp_stats_read_data_waits_inst;
            _temp_stats_read_data_waits_inst = stats_read_data_waits_inst;
            wait( _temp_stats_read_data_waits_inst != stats_read_data_waits_inst );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_sw(  );
        begin
            int _temp_stats_read_data_waits_sw;
            _temp_stats_read_data_waits_sw = stats_read_data_waits_sw;
            wait( _temp_stats_read_data_waits_sw != stats_read_data_waits_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_sw_updated(  );
        begin
            int _temp_stats_read_data_waits_sw_updated;
            _temp_stats_read_data_waits_sw_updated = stats_read_data_waits_sw_updated;
            wait( _temp_stats_read_data_waits_sw_updated != stats_read_data_waits_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_min(  );
        begin
            int _temp_stats_read_data_waits_min;
            _temp_stats_read_data_waits_min = stats_read_data_waits_min;
            wait( _temp_stats_read_data_waits_min != stats_read_data_waits_min );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_max(  );
        begin
            int _temp_stats_read_data_waits_max;
            _temp_stats_read_data_waits_max = stats_read_data_waits_max;
            wait( _temp_stats_read_data_waits_max != stats_read_data_waits_max );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_mean(  );
        begin
            int _temp_stats_read_data_waits_mean;
            _temp_stats_read_data_waits_mean = stats_read_data_waits_mean;
            wait( _temp_stats_read_data_waits_mean != stats_read_data_waits_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_address_waits_step(  );
        begin
            int _temp_config_stats_write_address_waits_step;
            _temp_config_stats_write_address_waits_step = config_stats_write_address_waits_step;
            wait( _temp_config_stats_write_address_waits_step != config_stats_write_address_waits_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_address_waits_multiple(  );
        begin
            int _temp_config_stats_write_address_waits_multiple;
            _temp_config_stats_write_address_waits_multiple = config_stats_write_address_waits_multiple;
            wait( _temp_config_stats_write_address_waits_multiple != config_stats_write_address_waits_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_inst(  );
        begin
            int _temp_stats_write_address_waits_inst;
            _temp_stats_write_address_waits_inst = stats_write_address_waits_inst;
            wait( _temp_stats_write_address_waits_inst != stats_write_address_waits_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_sw(  );
        begin
            int _temp_stats_write_address_waits_sw;
            _temp_stats_write_address_waits_sw = stats_write_address_waits_sw;
            wait( _temp_stats_write_address_waits_sw != stats_write_address_waits_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_sw_updated(  );
        begin
            int _temp_stats_write_address_waits_sw_updated;
            _temp_stats_write_address_waits_sw_updated = stats_write_address_waits_sw_updated;
            wait( _temp_stats_write_address_waits_sw_updated != stats_write_address_waits_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_min(  );
        begin
            int _temp_stats_write_address_waits_min;
            _temp_stats_write_address_waits_min = stats_write_address_waits_min;
            wait( _temp_stats_write_address_waits_min != stats_write_address_waits_min );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_max(  );
        begin
            int _temp_stats_write_address_waits_max;
            _temp_stats_write_address_waits_max = stats_write_address_waits_max;
            wait( _temp_stats_write_address_waits_max != stats_write_address_waits_max );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_mean(  );
        begin
            int _temp_stats_write_address_waits_mean;
            _temp_stats_write_address_waits_mean = stats_write_address_waits_mean;
            wait( _temp_stats_write_address_waits_mean != stats_write_address_waits_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_data_waits_step(  );
        begin
            int _temp_config_stats_write_data_waits_step;
            _temp_config_stats_write_data_waits_step = config_stats_write_data_waits_step;
            wait( _temp_config_stats_write_data_waits_step != config_stats_write_data_waits_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_data_waits_multiple(  );
        begin
            int _temp_config_stats_write_data_waits_multiple;
            _temp_config_stats_write_data_waits_multiple = config_stats_write_data_waits_multiple;
            wait( _temp_config_stats_write_data_waits_multiple != config_stats_write_data_waits_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_inst(  );
        begin
            int _temp_stats_write_data_waits_inst;
            _temp_stats_write_data_waits_inst = stats_write_data_waits_inst;
            wait( _temp_stats_write_data_waits_inst != stats_write_data_waits_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_sw(  );
        begin
            int _temp_stats_write_data_waits_sw;
            _temp_stats_write_data_waits_sw = stats_write_data_waits_sw;
            wait( _temp_stats_write_data_waits_sw != stats_write_data_waits_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_sw_updated(  );
        begin
            int _temp_stats_write_data_waits_sw_updated;
            _temp_stats_write_data_waits_sw_updated = stats_write_data_waits_sw_updated;
            wait( _temp_stats_write_data_waits_sw_updated != stats_write_data_waits_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_min(  );
        begin
            int _temp_stats_write_data_waits_min;
            _temp_stats_write_data_waits_min = stats_write_data_waits_min;
            wait( _temp_stats_write_data_waits_min != stats_write_data_waits_min );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_max(  );
        begin
            int _temp_stats_write_data_waits_max;
            _temp_stats_write_data_waits_max = stats_write_data_waits_max;
            wait( _temp_stats_write_data_waits_max != stats_write_data_waits_max );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_mean(  );
        begin
            int _temp_stats_write_data_waits_mean;
            _temp_stats_write_data_waits_mean = stats_write_data_waits_mean;
            wait( _temp_stats_write_data_waits_mean != stats_write_data_waits_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_response_waits_step(  );
        begin
            int _temp_config_stats_write_response_waits_step;
            _temp_config_stats_write_response_waits_step = config_stats_write_response_waits_step;
            wait( _temp_config_stats_write_response_waits_step != config_stats_write_response_waits_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_response_waits_multiple(  );
        begin
            int _temp_config_stats_write_response_waits_multiple;
            _temp_config_stats_write_response_waits_multiple = config_stats_write_response_waits_multiple;
            wait( _temp_config_stats_write_response_waits_multiple != config_stats_write_response_waits_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_inst(  );
        begin
            int _temp_stats_write_response_waits_inst;
            _temp_stats_write_response_waits_inst = stats_write_response_waits_inst;
            wait( _temp_stats_write_response_waits_inst != stats_write_response_waits_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_sw(  );
        begin
            int _temp_stats_write_response_waits_sw;
            _temp_stats_write_response_waits_sw = stats_write_response_waits_sw;
            wait( _temp_stats_write_response_waits_sw != stats_write_response_waits_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_sw_updated(  );
        begin
            int _temp_stats_write_response_waits_sw_updated;
            _temp_stats_write_response_waits_sw_updated = stats_write_response_waits_sw_updated;
            wait( _temp_stats_write_response_waits_sw_updated != stats_write_response_waits_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_min(  );
        begin
            int _temp_stats_write_response_waits_min;
            _temp_stats_write_response_waits_min = stats_write_response_waits_min;
            wait( _temp_stats_write_response_waits_min != stats_write_response_waits_min );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_max(  );
        begin
            int _temp_stats_write_response_waits_max;
            _temp_stats_write_response_waits_max = stats_write_response_waits_max;
            wait( _temp_stats_write_response_waits_max != stats_write_response_waits_max );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_mean(  );
        begin
            int _temp_stats_write_response_waits_mean;
            _temp_stats_write_response_waits_mean = stats_write_response_waits_mean;
            wait( _temp_stats_write_response_waits_mean != stats_write_response_waits_mean );
        end
    endtask

    task automatic do_wait_for_stats_rw_transaction_last_duration(  );
        begin
            int _temp_stats_rw_transaction_last_duration;
            _temp_stats_rw_transaction_last_duration = stats_rw_transaction_last_duration;
            wait( _temp_stats_rw_transaction_last_duration != stats_rw_transaction_last_duration );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_last_duration(  );
        begin
            int _temp_stats_AXI_read_last_duration;
            _temp_stats_AXI_read_last_duration = stats_AXI_read_last_duration;
            wait( _temp_stats_AXI_read_last_duration != stats_AXI_read_last_duration );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_last_duration(  );
        begin
            int _temp_stats_AXI_write_last_duration;
            _temp_stats_AXI_write_last_duration = stats_AXI_write_last_duration;
            wait( _temp_stats_AXI_write_last_duration != stats_AXI_write_last_duration );
        end
    endtask

    task automatic do_wait_for_stats_read_addr_channel_phase_last_duration(  );
        begin
            int _temp_stats_read_addr_channel_phase_last_duration;
            _temp_stats_read_addr_channel_phase_last_duration = stats_read_addr_channel_phase_last_duration;
            wait( _temp_stats_read_addr_channel_phase_last_duration != stats_read_addr_channel_phase_last_duration );
        end
    endtask

    task automatic do_wait_for_stats_read_data_burst_last_duration(  );
        begin
            int _temp_stats_read_data_burst_last_duration;
            _temp_stats_read_data_burst_last_duration = stats_read_data_burst_last_duration;
            wait( _temp_stats_read_data_burst_last_duration != stats_read_data_burst_last_duration );
        end
    endtask

    task automatic do_wait_for_stats_read_channel_phase_last_duration(  );
        begin
            int _temp_stats_read_channel_phase_last_duration;
            _temp_stats_read_channel_phase_last_duration = stats_read_channel_phase_last_duration;
            wait( _temp_stats_read_channel_phase_last_duration != stats_read_channel_phase_last_duration );
        end
    endtask

    task automatic do_wait_for_stats_write_addr_channel_phase_last_duration(  );
        begin
            int _temp_stats_write_addr_channel_phase_last_duration;
            _temp_stats_write_addr_channel_phase_last_duration = stats_write_addr_channel_phase_last_duration;
            wait( _temp_stats_write_addr_channel_phase_last_duration != stats_write_addr_channel_phase_last_duration );
        end
    endtask

    task automatic do_wait_for_stats_write_data_burst_last_duration(  );
        begin
            int _temp_stats_write_data_burst_last_duration;
            _temp_stats_write_data_burst_last_duration = stats_write_data_burst_last_duration;
            wait( _temp_stats_write_data_burst_last_duration != stats_write_data_burst_last_duration );
        end
    endtask

    task automatic do_wait_for_stats_write_channel_phase_last_duration(  );
        begin
            int _temp_stats_write_channel_phase_last_duration;
            _temp_stats_write_channel_phase_last_duration = stats_write_channel_phase_last_duration;
            wait( _temp_stats_write_channel_phase_last_duration != stats_write_channel_phase_last_duration );
        end
    endtask

    task automatic do_wait_for_stats_write_resp_channel_phase_last_duration(  );
        begin
            int _temp_stats_write_resp_channel_phase_last_duration;
            _temp_stats_write_resp_channel_phase_last_duration = stats_write_resp_channel_phase_last_duration;
            wait( _temp_stats_write_resp_channel_phase_last_duration != stats_write_resp_channel_phase_last_duration );
        end
    endtask


    //------------------------------------------------------------------------------
    // Functions to set global variables with write access
    //------------------------------------------------------------------------------

    function automatic void do_set_config_clk_init_value( bit config_clk_init_value_param );
        config_clk_init_value = config_clk_init_value_param;
    endfunction

    function automatic void do_set_config_clk_phase_shift( int config_clk_phase_shift_param );
        config_clk_phase_shift = config_clk_phase_shift_param;
    endfunction

    function automatic void do_set_config_clk_1st_time( int config_clk_1st_time_param );
        config_clk_1st_time = config_clk_1st_time_param;
    endfunction

    function automatic void do_set_config_clk_2nd_time( int config_clk_2nd_time_param );
        config_clk_2nd_time = config_clk_2nd_time_param;
    endfunction

    function automatic void do_set_config_setup_time( int config_setup_time_param );
        config_setup_time = config_setup_time_param;
    endfunction

    function automatic void do_set_config_hold_time( int config_hold_time_param );
        config_hold_time = config_hold_time_param;
    endfunction

    function automatic void do_set_config_max_transaction_time_factor( int unsigned config_max_transaction_time_factor_param );
        config_max_transaction_time_factor = config_max_transaction_time_factor_param;
    endfunction

    function automatic void do_set_config_timeout_max_data_transfer( int config_timeout_max_data_transfer_param );
        config_timeout_max_data_transfer = config_timeout_max_data_transfer_param;
    endfunction

    function automatic void do_set_config_burst_timeout_factor( int unsigned config_burst_timeout_factor_param );
        config_burst_timeout_factor = config_burst_timeout_factor_param;
    endfunction

    function automatic void do_set_config_max_latency_AWVALID_assertion_to_AWREADY( int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
        config_max_latency_AWVALID_assertion_to_AWREADY = config_max_latency_AWVALID_assertion_to_AWREADY_param;
    endfunction

    function automatic void do_set_config_max_latency_ARVALID_assertion_to_ARREADY( int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
        config_max_latency_ARVALID_assertion_to_ARREADY = config_max_latency_ARVALID_assertion_to_ARREADY_param;
    endfunction

    function automatic void do_set_config_max_latency_RVALID_assertion_to_RREADY( int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
        config_max_latency_RVALID_assertion_to_RREADY = config_max_latency_RVALID_assertion_to_RREADY_param;
    endfunction

    function automatic void do_set_config_max_latency_BVALID_assertion_to_BREADY( int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
        config_max_latency_BVALID_assertion_to_BREADY = config_max_latency_BVALID_assertion_to_BREADY_param;
    endfunction

    function automatic void do_set_config_max_latency_WVALID_assertion_to_WREADY( int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
        config_max_latency_WVALID_assertion_to_WREADY = config_max_latency_WVALID_assertion_to_WREADY_param;
    endfunction

    function automatic void do_set_config_write_ctrl_first_ratio( int config_write_ctrl_first_ratio_param );
        config_write_ctrl_first_ratio = config_write_ctrl_first_ratio_param;
    endfunction

    function automatic void do_set_config_write_data_first_ratio( int config_write_data_first_ratio_param );
        config_write_data_first_ratio = config_write_data_first_ratio_param;
    endfunction

    function automatic void do_set_config_write_ctrl_to_data_mintime( int unsigned config_write_ctrl_to_data_mintime_param );
        config_write_ctrl_to_data_mintime = config_write_ctrl_to_data_mintime_param;
    endfunction

    function automatic void do_set_config_write_data_to_ctrl_mintime( int unsigned config_write_data_to_ctrl_mintime_param );
        config_write_data_to_ctrl_mintime = config_write_data_to_ctrl_mintime_param;
    endfunction

    function automatic void do_set_config_master_write_delay( bit config_master_write_delay_param );
        config_master_write_delay = config_master_write_delay_param;
    endfunction

    function automatic void do_set_config_reset_low_clocks( int config_reset_low_clocks_param );
        config_reset_low_clocks = config_reset_low_clocks_param;
    endfunction

    function automatic void do_set_config_reset_hold_time( int config_reset_hold_time_param );
        config_reset_hold_time = config_reset_hold_time_param;
    endfunction

    function automatic void do_set_config_protect_ready( bit config_protect_ready_param );
        config_protect_ready = config_protect_ready_param;
    endfunction

    function automatic void do_set_config_enable_user_sideband( bit config_enable_user_sideband_param );
        config_enable_user_sideband = config_enable_user_sideband_param;
    endfunction

    function automatic void do_set_config_extended_length_enable( bit config_extended_length_enable_param );
        config_extended_length_enable = config_extended_length_enable_param;
    endfunction

    function automatic void do_set_config_enable_burst_reserved_value( bit config_enable_burst_reserved_value_param );
        config_enable_burst_reserved_value = config_enable_burst_reserved_value_param;
    endfunction

    function automatic void do_set_config_enable_lock_reserved_value( bit config_enable_lock_reserved_value_param );
        config_enable_lock_reserved_value = config_enable_lock_reserved_value_param;
    endfunction

    function automatic void do_set_config_enable_cache_reserved_value( bit config_enable_cache_reserved_value_param );
        config_enable_cache_reserved_value = config_enable_cache_reserved_value_param;
    endfunction

    function automatic void do_set_config_enable_all_assertions( bit config_enable_all_assertions_param );
        config_enable_all_assertions = config_enable_all_assertions_param;
    endfunction

    function automatic void do_set_config_enable_assertion( bit [255:0] config_enable_assertion_param );
        config_enable_assertion = config_enable_assertion_param;
    endfunction

    function automatic void do_set_config_enable_assertion_index1( int _this_dot_1, bit  config_enable_assertion_param );
        config_enable_assertion[_this_dot_1] = config_enable_assertion_param;
    endfunction

    function automatic void do_set_config_enable_error( bit [255:0] config_enable_error_param );
        config_enable_error = config_enable_error_param;
    endfunction

    function automatic void do_set_config_enable_error_index1( int _this_dot_1, bit  config_enable_error_param );
        config_enable_error[_this_dot_1] = config_enable_error_param;
    endfunction

    function automatic void do_set_config_enable_errors( bit config_enable_errors_param );
        config_enable_errors = config_enable_errors_param;
    endfunction

    function automatic void do_set_config_enable_all_assertion_errors( bit config_enable_all_assertion_errors_param );
        config_enable_all_assertion_errors = config_enable_all_assertion_errors_param;
    endfunction

    function automatic void do_set_config_abstraction_level( axi_abstraction_level_e config_abstraction_level_param );
        config_abstraction_level = config_abstraction_level_param;
    endfunction

    function automatic void do_set_config_slave_start_addr( bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param );
        config_slave_start_addr = config_slave_start_addr_param;
    endfunction

    function automatic void do_set_config_slave_start_addr_index1( int _this_dot_1, bit  config_slave_start_addr_param );
        config_slave_start_addr[_this_dot_1] = config_slave_start_addr_param;
    endfunction

    function automatic void do_set_config_slave_end_addr( bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param );
        config_slave_end_addr = config_slave_end_addr_param;
    endfunction

    function automatic void do_set_config_slave_end_addr_index1( int _this_dot_1, bit  config_slave_end_addr_param );
        config_slave_end_addr[_this_dot_1] = config_slave_end_addr_param;
    endfunction

    function automatic void do_set_config_enable_slave_addr_range_in_bfm( bit config_enable_slave_addr_range_in_bfm_param );
        config_enable_slave_addr_range_in_bfm = config_enable_slave_addr_range_in_bfm_param;
    endfunction

    function automatic void do_set_config_read_data_reordering_depth( int unsigned config_read_data_reordering_depth_param );
        config_read_data_reordering_depth = config_read_data_reordering_depth_param;
    endfunction

    function automatic void do_set_config_enable_read_data_reordering_depth_in_bfm( bit config_enable_read_data_reordering_depth_in_bfm_param );
        config_enable_read_data_reordering_depth_in_bfm = config_enable_read_data_reordering_depth_in_bfm_param;
    endfunction

    function automatic void do_set_config_awid_wid_mismatch( bit config_awid_wid_mismatch_param );
        config_awid_wid_mismatch = config_awid_wid_mismatch_param;
    endfunction

    function automatic void do_set_config_length_last_mismatch_error( bit config_length_last_mismatch_error_param );
        config_length_last_mismatch_error = config_length_last_mismatch_error_param;
    endfunction

    function automatic void do_set_config_master_error_position( axi_error_e config_master_error_position_param );
        config_master_error_position = config_master_error_position_param;
    endfunction

    function automatic void do_set_dummy_var( axi_assertion_type_e dummy_var_param );
        dummy_var = dummy_var_param;
    endfunction

    function automatic void do_set_config_wlast_length( int config_wlast_length_param );
        config_wlast_length = config_wlast_length_param;
    endfunction

    function automatic void do_set_config_wid_for_awid_not_matching( bit [((AXI_ID_WIDTH) - 1):0]  config_wid_for_awid_not_matching_param );
        config_wid_for_awid_not_matching = config_wid_for_awid_not_matching_param;
    endfunction

    function automatic void do_set_config_wid_for_awid_not_matching_index1( int _this_dot_1, bit  config_wid_for_awid_not_matching_param );
        config_wid_for_awid_not_matching[_this_dot_1] = config_wid_for_awid_not_matching_param;
    endfunction

    function automatic void do_set_config_support_exclusive_access( bit config_support_exclusive_access_param );
        config_support_exclusive_access = config_support_exclusive_access_param;
    endfunction

    function automatic void do_set_config_write_data_interleaving_depth( int config_write_data_interleaving_depth_param );
        config_write_data_interleaving_depth = config_write_data_interleaving_depth_param;
    endfunction

    function automatic void do_set_status_master_error( bit [15:0] status_master_error_param );
        status_master_error = status_master_error_param;
    endfunction

    function automatic void do_set_status_master_error_index1( int _this_dot_1, bit  status_master_error_param );
        status_master_error[_this_dot_1] = status_master_error_param;
    endfunction

    function automatic void do_set_check_total_num_wdata_outstanding( bit check_total_num_wdata_outstanding_param );
        check_total_num_wdata_outstanding = check_total_num_wdata_outstanding_param;
    endfunction

    function automatic void do_set_total_num_wdata_outstanding( int total_num_wdata_outstanding_param );
        total_num_wdata_outstanding = total_num_wdata_outstanding_param;
    endfunction

    function automatic void do_set_check_max_num_wdata_outstanding_per_id( bit check_max_num_wdata_outstanding_per_id_param );
        check_max_num_wdata_outstanding_per_id = check_max_num_wdata_outstanding_per_id_param;
    endfunction

    function automatic void do_set_max_num_wdata_outstanding_per_id( int max_num_wdata_outstanding_per_id_param );
        max_num_wdata_outstanding_per_id = max_num_wdata_outstanding_per_id_param;
    endfunction

    function automatic void do_set_check_max_num_waddr_outstanding_per_id( bit check_max_num_waddr_outstanding_per_id_param );
        check_max_num_waddr_outstanding_per_id = check_max_num_waddr_outstanding_per_id_param;
    endfunction

    function automatic void do_set_max_num_waddr_outstanding_per_id( int max_num_waddr_outstanding_per_id_param );
        max_num_waddr_outstanding_per_id = max_num_waddr_outstanding_per_id_param;
    endfunction

    function automatic void do_set_check_total_num_waddr_outstanding( bit check_total_num_waddr_outstanding_param );
        check_total_num_waddr_outstanding = check_total_num_waddr_outstanding_param;
    endfunction

    function automatic void do_set_total_num_waddr_outstanding( int total_num_waddr_outstanding_param );
        total_num_waddr_outstanding = total_num_waddr_outstanding_param;
    endfunction

    function automatic void do_set_status_outstanding_num_for_waddr( int status_outstanding_num_for_waddr_param );
        status_outstanding_num_for_waddr = status_outstanding_num_for_waddr_param;
    endfunction

    function automatic void do_set_start_finding_outstanding_waddr( bit start_finding_outstanding_waddr_param );
        start_finding_outstanding_waddr = start_finding_outstanding_waddr_param;
    endfunction

    function automatic void do_set_status_outstanding_num_for_wdata( int status_outstanding_num_for_wdata_param );
        status_outstanding_num_for_wdata = status_outstanding_num_for_wdata_param;
    endfunction

    function automatic void do_set_start_finding_outstanding_wdata( bit start_finding_outstanding_wdata_param );
        start_finding_outstanding_wdata = start_finding_outstanding_wdata_param;
    endfunction

    function automatic void do_set_find_waddr_outstanding_for_wid( bit [((AXI_ID_WIDTH) - 1):0]  find_waddr_outstanding_for_wid_param );
        find_waddr_outstanding_for_wid = find_waddr_outstanding_for_wid_param;
    endfunction

    function automatic void do_set_find_waddr_outstanding_for_wid_index1( int _this_dot_1, bit  find_waddr_outstanding_for_wid_param );
        find_waddr_outstanding_for_wid[_this_dot_1] = find_waddr_outstanding_for_wid_param;
    endfunction

    function automatic void do_set_find_wdata_outstanding_for_wid( bit [((AXI_ID_WIDTH) - 1):0]  find_wdata_outstanding_for_wid_param );
        find_wdata_outstanding_for_wid = find_wdata_outstanding_for_wid_param;
    endfunction

    function automatic void do_set_find_wdata_outstanding_for_wid_index1( int _this_dot_1, bit  find_wdata_outstanding_for_wid_param );
        find_wdata_outstanding_for_wid[_this_dot_1] = find_wdata_outstanding_for_wid_param;
    endfunction

    function automatic void do_set_change_in_wdata_outstanding_per_id( bit change_in_wdata_outstanding_per_id_param );
        change_in_wdata_outstanding_per_id = change_in_wdata_outstanding_per_id_param;
    endfunction

    function automatic void do_set_start_finding_change_in_wdata( bit start_finding_change_in_wdata_param );
        start_finding_change_in_wdata = start_finding_change_in_wdata_param;
    endfunction

    function automatic void do_set_find_change_in_wdata_outstanding_for_wid( bit [((AXI_ID_WIDTH) - 1):0]  find_change_in_wdata_outstanding_for_wid_param );
        find_change_in_wdata_outstanding_for_wid = find_change_in_wdata_outstanding_for_wid_param;
    endfunction

    function automatic void do_set_find_change_in_wdata_outstanding_for_wid_index1( int _this_dot_1, bit  find_change_in_wdata_outstanding_for_wid_param );
        find_change_in_wdata_outstanding_for_wid[_this_dot_1] = find_change_in_wdata_outstanding_for_wid_param;
    endfunction

    function automatic void do_set_config_max_outstanding_wr( int config_max_outstanding_wr_param );
        config_max_outstanding_wr = config_max_outstanding_wr_param;
    endfunction

    function automatic void do_set_config_max_outstanding_rd( int config_max_outstanding_rd_param );
        config_max_outstanding_rd = config_max_outstanding_rd_param;
    endfunction

    function automatic void do_set_config_error_on_deleted_valid_cycles( bit config_error_on_deleted_valid_cycles_param );
        config_error_on_deleted_valid_cycles = config_error_on_deleted_valid_cycles_param;
    endfunction

    function automatic void do_set_config_stats_enable( bit config_stats_enable_param );
        config_stats_enable = config_stats_enable_param;
    endfunction

    function automatic void do_set_config_stats_enable_AXI_read_occupancy( bit config_stats_enable_AXI_read_occupancy_param );
        config_stats_enable_AXI_read_occupancy = config_stats_enable_AXI_read_occupancy_param;
    endfunction

    function automatic void do_set_config_stats_enable_AXI_write_occupancy( bit config_stats_enable_AXI_write_occupancy_param );
        config_stats_enable_AXI_write_occupancy = config_stats_enable_AXI_write_occupancy_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_data_occupancy( bit config_stats_enable_read_data_occupancy_param );
        config_stats_enable_read_data_occupancy = config_stats_enable_read_data_occupancy_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_data_occupancy( bit config_stats_enable_write_data_occupancy_param );
        config_stats_enable_write_data_occupancy = config_stats_enable_write_data_occupancy_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_latency( bit config_stats_enable_read_latency_param );
        config_stats_enable_read_latency = config_stats_enable_read_latency_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_latency( bit config_stats_enable_write_latency_param );
        config_stats_enable_write_latency = config_stats_enable_write_latency_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_address_waits( bit config_stats_enable_read_address_waits_param );
        config_stats_enable_read_address_waits = config_stats_enable_read_address_waits_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_data_waits( bit config_stats_enable_read_data_waits_param );
        config_stats_enable_read_data_waits = config_stats_enable_read_data_waits_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_address_waits( bit config_stats_enable_write_address_waits_param );
        config_stats_enable_write_address_waits = config_stats_enable_write_address_waits_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_data_waits( bit config_stats_enable_write_data_waits_param );
        config_stats_enable_write_data_waits = config_stats_enable_write_data_waits_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_response_waits( bit config_stats_enable_write_response_waits_param );
        config_stats_enable_write_response_waits = config_stats_enable_write_response_waits_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_bandwidth( bit config_stats_enable_read_bandwidth_param );
        config_stats_enable_read_bandwidth = config_stats_enable_read_bandwidth_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_bandwidth( bit config_stats_enable_write_bandwidth_param );
        config_stats_enable_write_bandwidth = config_stats_enable_write_bandwidth_param;
    endfunction

    function automatic void do_set_config_stats_AXI_read_occupancy_step( int config_stats_AXI_read_occupancy_step_param );
        config_stats_AXI_read_occupancy_step = config_stats_AXI_read_occupancy_step_param;
    endfunction

    function automatic void do_set_config_stats_AXI_read_occupancy_multiple( int config_stats_AXI_read_occupancy_multiple_param );
        config_stats_AXI_read_occupancy_multiple = config_stats_AXI_read_occupancy_multiple_param;
    endfunction

    function automatic void do_set_config_stats_AXI_write_occupancy_step( int config_stats_AXI_write_occupancy_step_param );
        config_stats_AXI_write_occupancy_step = config_stats_AXI_write_occupancy_step_param;
    endfunction

    function automatic void do_set_config_stats_AXI_write_occupancy_multiple( int config_stats_AXI_write_occupancy_multiple_param );
        config_stats_AXI_write_occupancy_multiple = config_stats_AXI_write_occupancy_multiple_param;
    endfunction

    function automatic void do_set_config_stats_read_data_occupancy_step( int config_stats_read_data_occupancy_step_param );
        config_stats_read_data_occupancy_step = config_stats_read_data_occupancy_step_param;
    endfunction

    function automatic void do_set_config_stats_read_data_occupancy_multiple( int config_stats_read_data_occupancy_multiple_param );
        config_stats_read_data_occupancy_multiple = config_stats_read_data_occupancy_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_data_occupancy_step( int config_stats_write_data_occupancy_step_param );
        config_stats_write_data_occupancy_step = config_stats_write_data_occupancy_step_param;
    endfunction

    function automatic void do_set_config_stats_write_data_occupancy_multiple( int config_stats_write_data_occupancy_multiple_param );
        config_stats_write_data_occupancy_multiple = config_stats_write_data_occupancy_multiple_param;
    endfunction

    function automatic void do_set_config_stats_read_bandwidth_step( int config_stats_read_bandwidth_step_param );
        config_stats_read_bandwidth_step = config_stats_read_bandwidth_step_param;
    endfunction

    function automatic void do_set_config_stats_read_bandwidth_multiple( int config_stats_read_bandwidth_multiple_param );
        config_stats_read_bandwidth_multiple = config_stats_read_bandwidth_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_bandwidth_step( int config_stats_write_bandwidth_step_param );
        config_stats_write_bandwidth_step = config_stats_write_bandwidth_step_param;
    endfunction

    function automatic void do_set_config_stats_write_bandwidth_multiple( int config_stats_write_bandwidth_multiple_param );
        config_stats_write_bandwidth_multiple = config_stats_write_bandwidth_multiple_param;
    endfunction

    function automatic void do_set_config_stats_read_latency_step( int config_stats_read_latency_step_param );
        config_stats_read_latency_step = config_stats_read_latency_step_param;
    endfunction

    function automatic void do_set_config_stats_read_latency_multiple( int config_stats_read_latency_multiple_param );
        config_stats_read_latency_multiple = config_stats_read_latency_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_latency_step( int config_stats_write_latency_step_param );
        config_stats_write_latency_step = config_stats_write_latency_step_param;
    endfunction

    function automatic void do_set_config_stats_write_latency_multiple( int config_stats_write_latency_multiple_param );
        config_stats_write_latency_multiple = config_stats_write_latency_multiple_param;
    endfunction

    function automatic void do_set_config_stats_read_address_waits_step( int config_stats_read_address_waits_step_param );
        config_stats_read_address_waits_step = config_stats_read_address_waits_step_param;
    endfunction

    function automatic void do_set_config_stats_read_address_waits_multiple( int config_stats_read_address_waits_multiple_param );
        config_stats_read_address_waits_multiple = config_stats_read_address_waits_multiple_param;
    endfunction

    function automatic void do_set_config_stats_read_data_waits_step( int config_stats_read_data_waits_step_param );
        config_stats_read_data_waits_step = config_stats_read_data_waits_step_param;
    endfunction

    function automatic void do_set_config_stats_read_data_waits_multiple( int config_stats_read_data_waits_multiple_param );
        config_stats_read_data_waits_multiple = config_stats_read_data_waits_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_address_waits_step( int config_stats_write_address_waits_step_param );
        config_stats_write_address_waits_step = config_stats_write_address_waits_step_param;
    endfunction

    function automatic void do_set_config_stats_write_address_waits_multiple( int config_stats_write_address_waits_multiple_param );
        config_stats_write_address_waits_multiple = config_stats_write_address_waits_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_data_waits_step( int config_stats_write_data_waits_step_param );
        config_stats_write_data_waits_step = config_stats_write_data_waits_step_param;
    endfunction

    function automatic void do_set_config_stats_write_data_waits_multiple( int config_stats_write_data_waits_multiple_param );
        config_stats_write_data_waits_multiple = config_stats_write_data_waits_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_response_waits_step( int config_stats_write_response_waits_step_param );
        config_stats_write_response_waits_step = config_stats_write_response_waits_step_param;
    endfunction

    function automatic void do_set_config_stats_write_response_waits_multiple( int config_stats_write_response_waits_multiple_param );
        config_stats_write_response_waits_multiple = config_stats_write_response_waits_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Functions to get global variables with read access
    //------------------------------------------------------------------------------

    function automatic bit do_get_config_clk_init_value(  );
        return config_clk_init_value;
    endfunction

    function automatic int do_get_config_clk_phase_shift(  );
        return config_clk_phase_shift;
    endfunction

    function automatic int do_get_config_clk_1st_time(  );
        return config_clk_1st_time;
    endfunction

    function automatic int do_get_config_clk_2nd_time(  );
        return config_clk_2nd_time;
    endfunction

    function automatic int do_get_config_setup_time(  );
        return config_setup_time;
    endfunction

    function automatic int do_get_config_hold_time(  );
        return config_hold_time;
    endfunction

    function automatic int unsigned do_get_config_max_transaction_time_factor(  );
        return config_max_transaction_time_factor;
    endfunction

    function automatic int do_get_config_timeout_max_data_transfer(  );
        return config_timeout_max_data_transfer;
    endfunction

    function automatic int unsigned do_get_config_burst_timeout_factor(  );
        return config_burst_timeout_factor;
    endfunction

    function automatic int unsigned do_get_config_max_latency_AWVALID_assertion_to_AWREADY(  );
        return config_max_latency_AWVALID_assertion_to_AWREADY;
    endfunction

    function automatic int unsigned do_get_config_max_latency_ARVALID_assertion_to_ARREADY(  );
        return config_max_latency_ARVALID_assertion_to_ARREADY;
    endfunction

    function automatic int unsigned do_get_config_max_latency_RVALID_assertion_to_RREADY(  );
        return config_max_latency_RVALID_assertion_to_RREADY;
    endfunction

    function automatic int unsigned do_get_config_max_latency_BVALID_assertion_to_BREADY(  );
        return config_max_latency_BVALID_assertion_to_BREADY;
    endfunction

    function automatic int unsigned do_get_config_max_latency_WVALID_assertion_to_WREADY(  );
        return config_max_latency_WVALID_assertion_to_WREADY;
    endfunction

    function automatic int do_get_config_write_ctrl_first_ratio(  );
        return config_write_ctrl_first_ratio;
    endfunction

    function automatic int do_get_config_write_data_first_ratio(  );
        return config_write_data_first_ratio;
    endfunction

    function automatic int unsigned do_get_config_write_ctrl_to_data_mintime(  );
        return config_write_ctrl_to_data_mintime;
    endfunction

    function automatic int unsigned do_get_config_write_data_to_ctrl_mintime(  );
        return config_write_data_to_ctrl_mintime;
    endfunction

    function automatic bit do_get_config_master_write_delay(  );
        return config_master_write_delay;
    endfunction

    function automatic int do_get_config_reset_low_clocks(  );
        return config_reset_low_clocks;
    endfunction

    function automatic int do_get_config_reset_hold_time(  );
        return config_reset_hold_time;
    endfunction

    function automatic bit do_get_config_protect_ready(  );
        return config_protect_ready;
    endfunction

    function automatic bit do_get_config_enable_user_sideband(  );
        return config_enable_user_sideband;
    endfunction

    function automatic bit do_get_config_extended_length_enable(  );
        return config_extended_length_enable;
    endfunction

    function automatic bit do_get_config_enable_burst_reserved_value(  );
        return config_enable_burst_reserved_value;
    endfunction

    function automatic bit do_get_config_enable_lock_reserved_value(  );
        return config_enable_lock_reserved_value;
    endfunction

    function automatic bit do_get_config_enable_cache_reserved_value(  );
        return config_enable_cache_reserved_value;
    endfunction

    function automatic bit do_get_config_enable_all_assertions(  );
        return config_enable_all_assertions;
    endfunction

    function automatic bit [255:0]  do_get_config_enable_assertion(  );
        return config_enable_assertion;
    endfunction

    function automatic bit   do_get_config_enable_assertion_index1( int _this_dot_1 );
        return config_enable_assertion[_this_dot_1];
    endfunction

    function automatic bit [255:0]  do_get_config_enable_error(  );
        return config_enable_error;
    endfunction

    function automatic bit   do_get_config_enable_error_index1( int _this_dot_1 );
        return config_enable_error[_this_dot_1];
    endfunction

    function automatic bit do_get_config_enable_errors(  );
        return config_enable_errors;
    endfunction

    function automatic bit do_get_config_enable_all_assertion_errors(  );
        return config_enable_all_assertion_errors;
    endfunction

    function automatic axi_abstraction_level_e do_get_config_abstraction_level(  );
        return config_abstraction_level;
    endfunction

    function automatic bit [((AXI_ADDRESS_WIDTH) - 1):0]   do_get_config_slave_start_addr(  );
        return config_slave_start_addr;
    endfunction

    function automatic bit   do_get_config_slave_start_addr_index1( int _this_dot_1 );
        return config_slave_start_addr[_this_dot_1];
    endfunction

    function automatic bit [((AXI_ADDRESS_WIDTH) - 1):0]   do_get_config_slave_end_addr(  );
        return config_slave_end_addr;
    endfunction

    function automatic bit   do_get_config_slave_end_addr_index1( int _this_dot_1 );
        return config_slave_end_addr[_this_dot_1];
    endfunction

    function automatic bit do_get_config_enable_slave_addr_range_in_bfm(  );
        return config_enable_slave_addr_range_in_bfm;
    endfunction

    function automatic int unsigned do_get_config_read_data_reordering_depth(  );
        return config_read_data_reordering_depth;
    endfunction

    function automatic bit do_get_config_enable_read_data_reordering_depth_in_bfm(  );
        return config_enable_read_data_reordering_depth_in_bfm;
    endfunction

    function automatic bit do_get_config_awid_wid_mismatch(  );
        return config_awid_wid_mismatch;
    endfunction

    function automatic bit do_get_config_length_last_mismatch_error(  );
        return config_length_last_mismatch_error;
    endfunction

    function automatic axi_error_e do_get_config_master_error_position(  );
        return config_master_error_position;
    endfunction

    function automatic axi_assertion_type_e do_get_dummy_var(  );
        return dummy_var;
    endfunction

    function automatic int do_get_config_wlast_length(  );
        return config_wlast_length;
    endfunction

    function automatic bit [((AXI_ID_WIDTH) - 1):0]   do_get_config_wid_for_awid_not_matching(  );
        return config_wid_for_awid_not_matching;
    endfunction

    function automatic bit   do_get_config_wid_for_awid_not_matching_index1( int _this_dot_1 );
        return config_wid_for_awid_not_matching[_this_dot_1];
    endfunction

    function automatic bit do_get_config_support_exclusive_access(  );
        return config_support_exclusive_access;
    endfunction

    function automatic int do_get_config_write_data_interleaving_depth(  );
        return config_write_data_interleaving_depth;
    endfunction

    function automatic bit [15:0]  do_get_status_master_error(  );
        return status_master_error;
    endfunction

    function automatic bit   do_get_status_master_error_index1( int _this_dot_1 );
        return status_master_error[_this_dot_1];
    endfunction

    function automatic int do_get_status_num_reads_waiting_for_resp(  );
        return status_num_reads_waiting_for_resp;
    endfunction

    function automatic int do_get_status_num_writes_waiting_for_response(  );
        return status_num_writes_waiting_for_response;
    endfunction

    function automatic bit do_get_check_total_num_wdata_outstanding(  );
        return check_total_num_wdata_outstanding;
    endfunction

    function automatic int do_get_total_num_wdata_outstanding(  );
        return total_num_wdata_outstanding;
    endfunction

    function automatic bit do_get_check_max_num_wdata_outstanding_per_id(  );
        return check_max_num_wdata_outstanding_per_id;
    endfunction

    function automatic int do_get_max_num_wdata_outstanding_per_id(  );
        return max_num_wdata_outstanding_per_id;
    endfunction

    function automatic bit do_get_check_max_num_waddr_outstanding_per_id(  );
        return check_max_num_waddr_outstanding_per_id;
    endfunction

    function automatic int do_get_max_num_waddr_outstanding_per_id(  );
        return max_num_waddr_outstanding_per_id;
    endfunction

    function automatic bit do_get_check_total_num_waddr_outstanding(  );
        return check_total_num_waddr_outstanding;
    endfunction

    function automatic int do_get_total_num_waddr_outstanding(  );
        return total_num_waddr_outstanding;
    endfunction

    function automatic int do_get_status_outstanding_num_for_waddr(  );
        return status_outstanding_num_for_waddr;
    endfunction

    function automatic bit do_get_start_finding_outstanding_waddr(  );
        return start_finding_outstanding_waddr;
    endfunction

    function automatic int do_get_status_outstanding_num_for_wdata(  );
        return status_outstanding_num_for_wdata;
    endfunction

    function automatic bit do_get_start_finding_outstanding_wdata(  );
        return start_finding_outstanding_wdata;
    endfunction

    function automatic bit [((AXI_ID_WIDTH) - 1):0]   do_get_find_waddr_outstanding_for_wid(  );
        return find_waddr_outstanding_for_wid;
    endfunction

    function automatic bit   do_get_find_waddr_outstanding_for_wid_index1( int _this_dot_1 );
        return find_waddr_outstanding_for_wid[_this_dot_1];
    endfunction

    function automatic bit [((AXI_ID_WIDTH) - 1):0]   do_get_find_wdata_outstanding_for_wid(  );
        return find_wdata_outstanding_for_wid;
    endfunction

    function automatic bit   do_get_find_wdata_outstanding_for_wid_index1( int _this_dot_1 );
        return find_wdata_outstanding_for_wid[_this_dot_1];
    endfunction

    function automatic bit do_get_change_in_wdata_outstanding_per_id(  );
        return change_in_wdata_outstanding_per_id;
    endfunction

    function automatic bit do_get_start_finding_change_in_wdata(  );
        return start_finding_change_in_wdata;
    endfunction

    function automatic bit [((AXI_ID_WIDTH) - 1):0]   do_get_find_change_in_wdata_outstanding_for_wid(  );
        return find_change_in_wdata_outstanding_for_wid;
    endfunction

    function automatic bit   do_get_find_change_in_wdata_outstanding_for_wid_index1( int _this_dot_1 );
        return find_change_in_wdata_outstanding_for_wid[_this_dot_1];
    endfunction

    function automatic int do_get_config_max_outstanding_wr(  );
        return config_max_outstanding_wr;
    endfunction

    function automatic int do_get_config_max_outstanding_rd(  );
        return config_max_outstanding_rd;
    endfunction

    function automatic bit do_get_config_error_on_deleted_valid_cycles(  );
        return config_error_on_deleted_valid_cycles;
    endfunction

    function automatic bit do_get_config_stats_enable(  );
        return config_stats_enable;
    endfunction

    function automatic bit do_get_config_stats_enable_AXI_read_occupancy(  );
        return config_stats_enable_AXI_read_occupancy;
    endfunction

    function automatic bit do_get_config_stats_enable_AXI_write_occupancy(  );
        return config_stats_enable_AXI_write_occupancy;
    endfunction

    function automatic bit do_get_config_stats_enable_read_data_occupancy(  );
        return config_stats_enable_read_data_occupancy;
    endfunction

    function automatic bit do_get_config_stats_enable_write_data_occupancy(  );
        return config_stats_enable_write_data_occupancy;
    endfunction

    function automatic bit do_get_config_stats_enable_read_latency(  );
        return config_stats_enable_read_latency;
    endfunction

    function automatic bit do_get_config_stats_enable_write_latency(  );
        return config_stats_enable_write_latency;
    endfunction

    function automatic bit do_get_config_stats_enable_read_address_waits(  );
        return config_stats_enable_read_address_waits;
    endfunction

    function automatic bit do_get_config_stats_enable_read_data_waits(  );
        return config_stats_enable_read_data_waits;
    endfunction

    function automatic bit do_get_config_stats_enable_write_address_waits(  );
        return config_stats_enable_write_address_waits;
    endfunction

    function automatic bit do_get_config_stats_enable_write_data_waits(  );
        return config_stats_enable_write_data_waits;
    endfunction

    function automatic bit do_get_config_stats_enable_write_response_waits(  );
        return config_stats_enable_write_response_waits;
    endfunction

    function automatic bit do_get_config_stats_enable_read_bandwidth(  );
        return config_stats_enable_read_bandwidth;
    endfunction

    function automatic bit do_get_config_stats_enable_write_bandwidth(  );
        return config_stats_enable_write_bandwidth;
    endfunction

    function automatic int do_get_config_stats_AXI_read_occupancy_step(  );
        return config_stats_AXI_read_occupancy_step;
    endfunction

    function automatic int do_get_config_stats_AXI_read_occupancy_multiple(  );
        return config_stats_AXI_read_occupancy_multiple;
    endfunction

    function automatic bit do_get_stats_AXI_read_active(  );
        return stats_AXI_read_active;
    endfunction

    function automatic int do_get_stats_AXI_read_occupancy_sw(  );
        return stats_AXI_read_occupancy_sw;
    endfunction

    function automatic int do_get_stats_AXI_read_occupancy_sw_updated(  );
        return stats_AXI_read_occupancy_sw_updated;
    endfunction

    function automatic int do_get_stats_AXI_read_idle_sw(  );
        return stats_AXI_read_idle_sw;
    endfunction

    function automatic int do_get_stats_AXI_read_occupancy_min(  );
        return stats_AXI_read_occupancy_min;
    endfunction

    function automatic int do_get_stats_AXI_read_idle_min(  );
        return stats_AXI_read_idle_min;
    endfunction

    function automatic int do_get_stats_AXI_read_occupancy_max(  );
        return stats_AXI_read_occupancy_max;
    endfunction

    function automatic int do_get_stats_AXI_read_idle_max(  );
        return stats_AXI_read_idle_max;
    endfunction

    function automatic int do_get_stats_AXI_read_occupancy_mean(  );
        return stats_AXI_read_occupancy_mean;
    endfunction

    function automatic int do_get_stats_AXI_read_idle_mean(  );
        return stats_AXI_read_idle_mean;
    endfunction

    function automatic int do_get_config_stats_AXI_write_occupancy_step(  );
        return config_stats_AXI_write_occupancy_step;
    endfunction

    function automatic int do_get_config_stats_AXI_write_occupancy_multiple(  );
        return config_stats_AXI_write_occupancy_multiple;
    endfunction

    function automatic bit do_get_stats_AXI_write_active(  );
        return stats_AXI_write_active;
    endfunction

    function automatic int do_get_stats_AXI_write_occupancy_sw(  );
        return stats_AXI_write_occupancy_sw;
    endfunction

    function automatic int do_get_stats_AXI_write_occupancy_sw_updated(  );
        return stats_AXI_write_occupancy_sw_updated;
    endfunction

    function automatic int do_get_stats_AXI_write_idle_sw(  );
        return stats_AXI_write_idle_sw;
    endfunction

    function automatic int do_get_stats_AXI_write_occupancy_min(  );
        return stats_AXI_write_occupancy_min;
    endfunction

    function automatic int do_get_stats_AXI_write_idle_min(  );
        return stats_AXI_write_idle_min;
    endfunction

    function automatic int do_get_stats_AXI_write_occupancy_max(  );
        return stats_AXI_write_occupancy_max;
    endfunction

    function automatic int do_get_stats_AXI_write_idle_max(  );
        return stats_AXI_write_idle_max;
    endfunction

    function automatic int do_get_stats_AXI_write_occupancy_mean(  );
        return stats_AXI_write_occupancy_mean;
    endfunction

    function automatic int do_get_stats_AXI_write_idle_mean(  );
        return stats_AXI_write_idle_mean;
    endfunction

    function automatic int do_get_config_stats_read_data_occupancy_step(  );
        return config_stats_read_data_occupancy_step;
    endfunction

    function automatic int do_get_config_stats_read_data_occupancy_multiple(  );
        return config_stats_read_data_occupancy_multiple;
    endfunction

    function automatic int do_get_stats_read_data_occupancy_sw(  );
        return stats_read_data_occupancy_sw;
    endfunction

    function automatic int do_get_stats_read_data_occupancy_sw_updated(  );
        return stats_read_data_occupancy_sw_updated;
    endfunction

    function automatic int do_get_stats_read_data_idle_sw(  );
        return stats_read_data_idle_sw;
    endfunction

    function automatic int do_get_stats_read_data_occupancy_min(  );
        return stats_read_data_occupancy_min;
    endfunction

    function automatic int do_get_stats_read_data_idle_min(  );
        return stats_read_data_idle_min;
    endfunction

    function automatic int do_get_stats_read_data_occupancy_max(  );
        return stats_read_data_occupancy_max;
    endfunction

    function automatic int do_get_stats_read_data_idle_max(  );
        return stats_read_data_idle_max;
    endfunction

    function automatic int do_get_stats_read_data_occupancy_mean(  );
        return stats_read_data_occupancy_mean;
    endfunction

    function automatic int do_get_stats_read_data_idle_mean(  );
        return stats_read_data_idle_mean;
    endfunction

    function automatic int do_get_config_stats_write_data_occupancy_step(  );
        return config_stats_write_data_occupancy_step;
    endfunction

    function automatic int do_get_config_stats_write_data_occupancy_multiple(  );
        return config_stats_write_data_occupancy_multiple;
    endfunction

    function automatic int do_get_stats_write_data_occupancy_sw(  );
        return stats_write_data_occupancy_sw;
    endfunction

    function automatic int do_get_stats_write_data_occupancy_sw_updated(  );
        return stats_write_data_occupancy_sw_updated;
    endfunction

    function automatic int do_get_stats_write_data_idle_sw(  );
        return stats_write_data_idle_sw;
    endfunction

    function automatic int do_get_stats_write_data_occupancy_min(  );
        return stats_write_data_occupancy_min;
    endfunction

    function automatic int do_get_stats_write_data_idle_min(  );
        return stats_write_data_idle_min;
    endfunction

    function automatic int do_get_stats_write_data_occupancy_max(  );
        return stats_write_data_occupancy_max;
    endfunction

    function automatic int do_get_stats_write_data_idle_max(  );
        return stats_write_data_idle_max;
    endfunction

    function automatic int do_get_stats_write_data_occupancy_mean(  );
        return stats_write_data_occupancy_mean;
    endfunction

    function automatic int do_get_stats_write_data_idle_mean(  );
        return stats_write_data_idle_mean;
    endfunction

    function automatic int do_get_config_stats_read_bandwidth_step(  );
        return config_stats_read_bandwidth_step;
    endfunction

    function automatic int do_get_config_stats_read_bandwidth_multiple(  );
        return config_stats_read_bandwidth_multiple;
    endfunction

    function automatic int do_get_stats_read_bandwidth_sw(  );
        return stats_read_bandwidth_sw;
    endfunction

    function automatic int do_get_stats_read_bandwidth_sw_updated(  );
        return stats_read_bandwidth_sw_updated;
    endfunction

    function automatic int do_get_stats_read_bandwidth_min(  );
        return stats_read_bandwidth_min;
    endfunction

    function automatic int do_get_stats_read_bandwidth_max(  );
        return stats_read_bandwidth_max;
    endfunction

    function automatic int do_get_stats_read_bandwidth_mean(  );
        return stats_read_bandwidth_mean;
    endfunction

    function automatic int do_get_config_stats_write_bandwidth_step(  );
        return config_stats_write_bandwidth_step;
    endfunction

    function automatic int do_get_config_stats_write_bandwidth_multiple(  );
        return config_stats_write_bandwidth_multiple;
    endfunction

    function automatic int do_get_stats_write_bandwidth_sw(  );
        return stats_write_bandwidth_sw;
    endfunction

    function automatic int do_get_stats_write_bandwidth_sw_updated(  );
        return stats_write_bandwidth_sw_updated;
    endfunction

    function automatic int do_get_stats_write_bandwidth_min(  );
        return stats_write_bandwidth_min;
    endfunction

    function automatic int do_get_stats_write_bandwidth_max(  );
        return stats_write_bandwidth_max;
    endfunction

    function automatic int do_get_stats_write_bandwidth_mean(  );
        return stats_write_bandwidth_mean;
    endfunction

    function automatic int do_get_config_stats_read_latency_step(  );
        return config_stats_read_latency_step;
    endfunction

    function automatic int do_get_config_stats_read_latency_multiple(  );
        return config_stats_read_latency_multiple;
    endfunction

    function automatic int do_get_stats_read_latency_sw_updated(  );
        return stats_read_latency_sw_updated;
    endfunction

    function automatic int do_get_stats_read_address_data_latency_inst(  );
        return stats_read_address_data_latency_inst;
    endfunction

    function automatic int do_get_stats_read_address_data_latency_sw(  );
        return stats_read_address_data_latency_sw;
    endfunction

    function automatic int do_get_stats_read_address_data_latency_min(  );
        return stats_read_address_data_latency_min;
    endfunction

    function automatic int do_get_stats_read_address_data_latency_max(  );
        return stats_read_address_data_latency_max;
    endfunction

    function automatic int do_get_stats_read_address_data_latency_mean(  );
        return stats_read_address_data_latency_mean;
    endfunction

    function automatic int do_get_stats_read_address_address_latency_inst(  );
        return stats_read_address_address_latency_inst;
    endfunction

    function automatic int do_get_stats_read_address_address_latency_sw(  );
        return stats_read_address_address_latency_sw;
    endfunction

    function automatic int do_get_stats_read_address_address_latency_min(  );
        return stats_read_address_address_latency_min;
    endfunction

    function automatic int do_get_stats_read_address_address_latency_max(  );
        return stats_read_address_address_latency_max;
    endfunction

    function automatic int do_get_stats_read_address_address_latency_mean(  );
        return stats_read_address_address_latency_mean;
    endfunction

    function automatic int do_get_config_stats_write_latency_step(  );
        return config_stats_write_latency_step;
    endfunction

    function automatic int do_get_config_stats_write_latency_multiple(  );
        return config_stats_write_latency_multiple;
    endfunction

    function automatic int do_get_stats_write_latency_sw_updated(  );
        return stats_write_latency_sw_updated;
    endfunction

    function automatic int do_get_stats_write_address_data_latency_inst(  );
        return stats_write_address_data_latency_inst;
    endfunction

    function automatic int do_get_stats_write_address_data_latency_sw(  );
        return stats_write_address_data_latency_sw;
    endfunction

    function automatic int do_get_stats_write_address_data_latency_min(  );
        return stats_write_address_data_latency_min;
    endfunction

    function automatic int do_get_stats_write_address_data_latency_max(  );
        return stats_write_address_data_latency_max;
    endfunction

    function automatic int do_get_stats_write_address_data_latency_mean(  );
        return stats_write_address_data_latency_mean;
    endfunction

    function automatic int do_get_stats_write_data_response_latency_inst(  );
        return stats_write_data_response_latency_inst;
    endfunction

    function automatic int do_get_stats_write_data_response_latency_sw(  );
        return stats_write_data_response_latency_sw;
    endfunction

    function automatic int do_get_stats_write_data_response_latency_min(  );
        return stats_write_data_response_latency_min;
    endfunction

    function automatic int do_get_stats_write_data_response_latency_max(  );
        return stats_write_data_response_latency_max;
    endfunction

    function automatic int do_get_stats_write_data_response_latency_mean(  );
        return stats_write_data_response_latency_mean;
    endfunction

    function automatic int do_get_stats_write_address_address_latency_inst(  );
        return stats_write_address_address_latency_inst;
    endfunction

    function automatic int do_get_stats_write_address_address_latency_sw(  );
        return stats_write_address_address_latency_sw;
    endfunction

    function automatic int do_get_stats_write_address_address_latency_min(  );
        return stats_write_address_address_latency_min;
    endfunction

    function automatic int do_get_stats_write_address_address_latency_max(  );
        return stats_write_address_address_latency_max;
    endfunction

    function automatic int do_get_stats_write_address_address_latency_mean(  );
        return stats_write_address_address_latency_mean;
    endfunction

    function automatic int do_get_config_stats_read_address_waits_step(  );
        return config_stats_read_address_waits_step;
    endfunction

    function automatic int do_get_config_stats_read_address_waits_multiple(  );
        return config_stats_read_address_waits_multiple;
    endfunction

    function automatic int do_get_stats_read_address_waits_inst(  );
        return stats_read_address_waits_inst;
    endfunction

    function automatic int do_get_stats_read_address_waits_sw(  );
        return stats_read_address_waits_sw;
    endfunction

    function automatic int do_get_stats_read_address_waits_sw_updated(  );
        return stats_read_address_waits_sw_updated;
    endfunction

    function automatic int do_get_stats_read_address_waits_min(  );
        return stats_read_address_waits_min;
    endfunction

    function automatic int do_get_stats_read_address_waits_max(  );
        return stats_read_address_waits_max;
    endfunction

    function automatic int do_get_stats_read_address_waits_mean(  );
        return stats_read_address_waits_mean;
    endfunction

    function automatic int do_get_config_stats_read_data_waits_step(  );
        return config_stats_read_data_waits_step;
    endfunction

    function automatic int do_get_config_stats_read_data_waits_multiple(  );
        return config_stats_read_data_waits_multiple;
    endfunction

    function automatic int do_get_stats_read_data_waits_inst(  );
        return stats_read_data_waits_inst;
    endfunction

    function automatic int do_get_stats_read_data_waits_sw(  );
        return stats_read_data_waits_sw;
    endfunction

    function automatic int do_get_stats_read_data_waits_sw_updated(  );
        return stats_read_data_waits_sw_updated;
    endfunction

    function automatic int do_get_stats_read_data_waits_min(  );
        return stats_read_data_waits_min;
    endfunction

    function automatic int do_get_stats_read_data_waits_max(  );
        return stats_read_data_waits_max;
    endfunction

    function automatic int do_get_stats_read_data_waits_mean(  );
        return stats_read_data_waits_mean;
    endfunction

    function automatic int do_get_config_stats_write_address_waits_step(  );
        return config_stats_write_address_waits_step;
    endfunction

    function automatic int do_get_config_stats_write_address_waits_multiple(  );
        return config_stats_write_address_waits_multiple;
    endfunction

    function automatic int do_get_stats_write_address_waits_inst(  );
        return stats_write_address_waits_inst;
    endfunction

    function automatic int do_get_stats_write_address_waits_sw(  );
        return stats_write_address_waits_sw;
    endfunction

    function automatic int do_get_stats_write_address_waits_sw_updated(  );
        return stats_write_address_waits_sw_updated;
    endfunction

    function automatic int do_get_stats_write_address_waits_min(  );
        return stats_write_address_waits_min;
    endfunction

    function automatic int do_get_stats_write_address_waits_max(  );
        return stats_write_address_waits_max;
    endfunction

    function automatic int do_get_stats_write_address_waits_mean(  );
        return stats_write_address_waits_mean;
    endfunction

    function automatic int do_get_config_stats_write_data_waits_step(  );
        return config_stats_write_data_waits_step;
    endfunction

    function automatic int do_get_config_stats_write_data_waits_multiple(  );
        return config_stats_write_data_waits_multiple;
    endfunction

    function automatic int do_get_stats_write_data_waits_inst(  );
        return stats_write_data_waits_inst;
    endfunction

    function automatic int do_get_stats_write_data_waits_sw(  );
        return stats_write_data_waits_sw;
    endfunction

    function automatic int do_get_stats_write_data_waits_sw_updated(  );
        return stats_write_data_waits_sw_updated;
    endfunction

    function automatic int do_get_stats_write_data_waits_min(  );
        return stats_write_data_waits_min;
    endfunction

    function automatic int do_get_stats_write_data_waits_max(  );
        return stats_write_data_waits_max;
    endfunction

    function automatic int do_get_stats_write_data_waits_mean(  );
        return stats_write_data_waits_mean;
    endfunction

    function automatic int do_get_config_stats_write_response_waits_step(  );
        return config_stats_write_response_waits_step;
    endfunction

    function automatic int do_get_config_stats_write_response_waits_multiple(  );
        return config_stats_write_response_waits_multiple;
    endfunction

    function automatic int do_get_stats_write_response_waits_inst(  );
        return stats_write_response_waits_inst;
    endfunction

    function automatic int do_get_stats_write_response_waits_sw(  );
        return stats_write_response_waits_sw;
    endfunction

    function automatic int do_get_stats_write_response_waits_sw_updated(  );
        return stats_write_response_waits_sw_updated;
    endfunction

    function automatic int do_get_stats_write_response_waits_min(  );
        return stats_write_response_waits_min;
    endfunction

    function automatic int do_get_stats_write_response_waits_max(  );
        return stats_write_response_waits_max;
    endfunction

    function automatic int do_get_stats_write_response_waits_mean(  );
        return stats_write_response_waits_mean;
    endfunction

    function automatic int do_get_stats_rw_transaction_last_duration(  );
        return stats_rw_transaction_last_duration;
    endfunction

    function automatic int do_get_stats_AXI_read_last_duration(  );
        return stats_AXI_read_last_duration;
    endfunction

    function automatic int do_get_stats_AXI_write_last_duration(  );
        return stats_AXI_write_last_duration;
    endfunction

    function automatic int do_get_stats_read_addr_channel_phase_last_duration(  );
        return stats_read_addr_channel_phase_last_duration;
    endfunction

    function automatic int do_get_stats_read_data_burst_last_duration(  );
        return stats_read_data_burst_last_duration;
    endfunction

    function automatic int do_get_stats_read_channel_phase_last_duration(  );
        return stats_read_channel_phase_last_duration;
    endfunction

    function automatic int do_get_stats_write_addr_channel_phase_last_duration(  );
        return stats_write_addr_channel_phase_last_duration;
    endfunction

    function automatic int do_get_stats_write_data_burst_last_duration(  );
        return stats_write_data_burst_last_duration;
    endfunction

    function automatic int do_get_stats_write_channel_phase_last_duration(  );
        return stats_write_channel_phase_last_duration;
    endfunction

    function automatic int do_get_stats_write_resp_channel_phase_last_duration(  );
        return stats_write_resp_channel_phase_last_duration;
    endfunction


    //------------------------------------------------------------------------------
    // Interface end access functions
    //------------------------------------------------------------------------------

    function longint do_get_axi_master_end();
        return axi_get_axi_master_end();
    endfunction

    function longint do_get_axi_slave_end();
        return axi_get_axi_slave_end();
    endfunction

    function longint do_get_axi_clock_source_end();
        return axi_get_axi_clock_source_end();
    endfunction

    function longint do_get_axi_reset_source_end();
        return axi_get_axi_reset_source_end();
    endfunction

    function longint do_get_axi__monitor_end();
        return axi_get_axi__monitor_end();
    endfunction

    //------------------------------------------------------------------------------
    // Functions to set/get generic interface configuration
    //------------------------------------------------------------------------------

    function void do_set_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0,
        input int arg10 = 0
    );
        axi_set_interface( what, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10 );
    endfunction

    function int do_get_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0
    );
        return axi_get_interface( what, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 );
    endfunction

    //------------------------------------------------------------------------------
    // Functions to get the hierarchic name of this interface
    //------------------------------------------------------------------------------
    function string do_get_full_name();
        return axi_get_full_name();
    endfunction

    //------------------------------------------------------------------------------
    // Functions to set/get the abstraction levels of interface ends
    //------------------------------------------------------------------------------

    function void do_axi_set_master_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi_set_master_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi_get_master_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi_get_master_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi_set_slave_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi_set_slave_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi_get_slave_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi_get_slave_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi_set_clock_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi_set_clock_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi_get_clock_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi_get_clock_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi_set_reset_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi_set_reset_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi_get_reset_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi_get_reset_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

// Variable monitors

    function automatic void axi_local_set_config_clk_init_value_from_SystemVerilog( ref bit config_clk_init_value_param );
            axi_set_config_clk_init_value_from_SystemVerilog(config_clk_init_value); // DPI call to imported task
        
            axi_propagate_config_clk_init_value_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_clk_init_value_from_SystemVerilog( config_clk_init_value );
            end
        end
    end

    function automatic void axi_local_set_config_clk_phase_shift_from_SystemVerilog( ref int config_clk_phase_shift_param );
            axi_set_config_clk_phase_shift_from_SystemVerilog(config_clk_phase_shift); // DPI call to imported task
        
            axi_propagate_config_clk_phase_shift_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_clk_phase_shift_from_SystemVerilog( config_clk_phase_shift );
            end
        end
    end

    function automatic void axi_local_set_config_clk_1st_time_from_SystemVerilog( ref int config_clk_1st_time_param );
            axi_set_config_clk_1st_time_from_SystemVerilog(config_clk_1st_time); // DPI call to imported task
        
            axi_propagate_config_clk_1st_time_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_clk_1st_time_from_SystemVerilog( config_clk_1st_time );
            end
        end
    end

    function automatic void axi_local_set_config_clk_2nd_time_from_SystemVerilog( ref int config_clk_2nd_time_param );
            axi_set_config_clk_2nd_time_from_SystemVerilog(config_clk_2nd_time); // DPI call to imported task
        
            axi_propagate_config_clk_2nd_time_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_clk_2nd_time_from_SystemVerilog( config_clk_2nd_time );
            end
        end
    end

    function automatic void axi_local_set_config_setup_time_from_SystemVerilog( ref int config_setup_time_param );
            axi_set_config_setup_time_from_SystemVerilog(config_setup_time); // DPI call to imported task
        
            axi_propagate_config_setup_time_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_setup_time_from_SystemVerilog( config_setup_time );
            end
        end
    end

    function automatic void axi_local_set_config_hold_time_from_SystemVerilog( ref int config_hold_time_param );
            axi_set_config_hold_time_from_SystemVerilog(config_hold_time); // DPI call to imported task
        
            axi_propagate_config_hold_time_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_hold_time_from_SystemVerilog( config_hold_time );
            end
        end
    end

    function automatic void axi_local_set_config_max_transaction_time_factor_from_SystemVerilog( ref int unsigned config_max_transaction_time_factor_param );
            axi_set_config_max_transaction_time_factor_from_SystemVerilog(config_max_transaction_time_factor); // DPI call to imported task
        
            axi_propagate_config_max_transaction_time_factor_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_transaction_time_factor_from_SystemVerilog( config_max_transaction_time_factor );
            end
        end
    end

    function automatic void axi_local_set_config_timeout_max_data_transfer_from_SystemVerilog( ref int config_timeout_max_data_transfer_param );
            axi_set_config_timeout_max_data_transfer_from_SystemVerilog(config_timeout_max_data_transfer); // DPI call to imported task
        
            axi_propagate_config_timeout_max_data_transfer_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_timeout_max_data_transfer_from_SystemVerilog( config_timeout_max_data_transfer );
            end
        end
    end

    function automatic void axi_local_set_config_burst_timeout_factor_from_SystemVerilog( ref int unsigned config_burst_timeout_factor_param );
            axi_set_config_burst_timeout_factor_from_SystemVerilog(config_burst_timeout_factor); // DPI call to imported task
        
            axi_propagate_config_burst_timeout_factor_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_burst_timeout_factor_from_SystemVerilog( config_burst_timeout_factor );
            end
        end
    end

    function automatic void axi_local_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog( ref int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
            axi_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog(config_max_latency_AWVALID_assertion_to_AWREADY); // DPI call to imported task
        
            axi_propagate_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog( config_max_latency_AWVALID_assertion_to_AWREADY );
            end
        end
    end

    function automatic void axi_local_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog( ref int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
            axi_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog(config_max_latency_ARVALID_assertion_to_ARREADY); // DPI call to imported task
        
            axi_propagate_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog( config_max_latency_ARVALID_assertion_to_ARREADY );
            end
        end
    end

    function automatic void axi_local_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog( ref int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
            axi_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog(config_max_latency_RVALID_assertion_to_RREADY); // DPI call to imported task
        
            axi_propagate_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog( config_max_latency_RVALID_assertion_to_RREADY );
            end
        end
    end

    function automatic void axi_local_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog( ref int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
            axi_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog(config_max_latency_BVALID_assertion_to_BREADY); // DPI call to imported task
        
            axi_propagate_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog( config_max_latency_BVALID_assertion_to_BREADY );
            end
        end
    end

    function automatic void axi_local_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog( ref int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
            axi_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog(config_max_latency_WVALID_assertion_to_WREADY); // DPI call to imported task
        
            axi_propagate_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog( config_max_latency_WVALID_assertion_to_WREADY );
            end
        end
    end

    function automatic void axi_local_set_config_write_ctrl_first_ratio_from_SystemVerilog( ref int config_write_ctrl_first_ratio_param );
            axi_set_config_write_ctrl_first_ratio_from_SystemVerilog(config_write_ctrl_first_ratio); // DPI call to imported task
        
            axi_propagate_config_write_ctrl_first_ratio_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_write_ctrl_first_ratio_from_SystemVerilog( config_write_ctrl_first_ratio );
            end
        end
    end

    function automatic void axi_local_set_config_write_data_first_ratio_from_SystemVerilog( ref int config_write_data_first_ratio_param );
            axi_set_config_write_data_first_ratio_from_SystemVerilog(config_write_data_first_ratio); // DPI call to imported task
        
            axi_propagate_config_write_data_first_ratio_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_write_data_first_ratio_from_SystemVerilog( config_write_data_first_ratio );
            end
        end
    end

    function automatic void axi_local_set_config_write_ctrl_to_data_mintime_from_SystemVerilog( ref int unsigned config_write_ctrl_to_data_mintime_param );
            axi_set_config_write_ctrl_to_data_mintime_from_SystemVerilog(config_write_ctrl_to_data_mintime); // DPI call to imported task
        
            axi_propagate_config_write_ctrl_to_data_mintime_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_write_ctrl_to_data_mintime_from_SystemVerilog( config_write_ctrl_to_data_mintime );
            end
        end
    end

    function automatic void axi_local_set_config_write_data_to_ctrl_mintime_from_SystemVerilog( ref int unsigned config_write_data_to_ctrl_mintime_param );
            axi_set_config_write_data_to_ctrl_mintime_from_SystemVerilog(config_write_data_to_ctrl_mintime); // DPI call to imported task
        
            axi_propagate_config_write_data_to_ctrl_mintime_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_write_data_to_ctrl_mintime_from_SystemVerilog( config_write_data_to_ctrl_mintime );
            end
        end
    end

    function automatic void axi_local_set_config_master_write_delay_from_SystemVerilog( ref bit config_master_write_delay_param );
            axi_set_config_master_write_delay_from_SystemVerilog(config_master_write_delay); // DPI call to imported task
        
            axi_propagate_config_master_write_delay_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_master_write_delay_from_SystemVerilog( config_master_write_delay );
            end
        end
    end

    function automatic void axi_local_set_config_reset_low_clocks_from_SystemVerilog( ref int config_reset_low_clocks_param );
            axi_set_config_reset_low_clocks_from_SystemVerilog(config_reset_low_clocks); // DPI call to imported task
        
            axi_propagate_config_reset_low_clocks_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_reset_low_clocks_from_SystemVerilog( config_reset_low_clocks );
            end
        end
    end

    function automatic void axi_local_set_config_reset_hold_time_from_SystemVerilog( ref int config_reset_hold_time_param );
            axi_set_config_reset_hold_time_from_SystemVerilog(config_reset_hold_time); // DPI call to imported task
        
            axi_propagate_config_reset_hold_time_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_reset_hold_time_from_SystemVerilog( config_reset_hold_time );
            end
        end
    end

    function automatic void axi_local_set_config_protect_ready_from_SystemVerilog( ref bit config_protect_ready_param );
            axi_set_config_protect_ready_from_SystemVerilog(config_protect_ready); // DPI call to imported task
        
            axi_propagate_config_protect_ready_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_protect_ready_from_SystemVerilog( config_protect_ready );
            end
        end
    end

    function automatic void axi_local_set_config_enable_user_sideband_from_SystemVerilog( ref bit config_enable_user_sideband_param );
            axi_set_config_enable_user_sideband_from_SystemVerilog(config_enable_user_sideband); // DPI call to imported task
        
            axi_propagate_config_enable_user_sideband_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_user_sideband_from_SystemVerilog( config_enable_user_sideband );
            end
        end
    end

    function automatic void axi_local_set_config_extended_length_enable_from_SystemVerilog( ref bit config_extended_length_enable_param );
            axi_set_config_extended_length_enable_from_SystemVerilog(config_extended_length_enable); // DPI call to imported task
        
            axi_propagate_config_extended_length_enable_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_extended_length_enable_from_SystemVerilog( config_extended_length_enable );
            end
        end
    end

    function automatic void axi_local_set_config_enable_burst_reserved_value_from_SystemVerilog( ref bit config_enable_burst_reserved_value_param );
            axi_set_config_enable_burst_reserved_value_from_SystemVerilog(config_enable_burst_reserved_value); // DPI call to imported task
        
            axi_propagate_config_enable_burst_reserved_value_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_burst_reserved_value_from_SystemVerilog( config_enable_burst_reserved_value );
            end
        end
    end

    function automatic void axi_local_set_config_enable_lock_reserved_value_from_SystemVerilog( ref bit config_enable_lock_reserved_value_param );
            axi_set_config_enable_lock_reserved_value_from_SystemVerilog(config_enable_lock_reserved_value); // DPI call to imported task
        
            axi_propagate_config_enable_lock_reserved_value_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_lock_reserved_value_from_SystemVerilog( config_enable_lock_reserved_value );
            end
        end
    end

    function automatic void axi_local_set_config_enable_cache_reserved_value_from_SystemVerilog( ref bit config_enable_cache_reserved_value_param );
            axi_set_config_enable_cache_reserved_value_from_SystemVerilog(config_enable_cache_reserved_value); // DPI call to imported task
        
            axi_propagate_config_enable_cache_reserved_value_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_cache_reserved_value_from_SystemVerilog( config_enable_cache_reserved_value );
            end
        end
    end

    function automatic void axi_local_set_config_enable_all_assertions_from_SystemVerilog( ref bit config_enable_all_assertions_param );
            axi_set_config_enable_all_assertions_from_SystemVerilog(config_enable_all_assertions); // DPI call to imported task
        
            axi_propagate_config_enable_all_assertions_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_all_assertions_from_SystemVerilog( config_enable_all_assertions );
            end
        end
    end

    function automatic void axi_local_set_config_enable_assertion_from_SystemVerilog( ref bit [255:0] config_enable_assertion_param );
            axi_set_config_enable_assertion_from_SystemVerilog(config_enable_assertion); // DPI call to imported task
        
            axi_propagate_config_enable_assertion_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_assertion_from_SystemVerilog( config_enable_assertion );
            end
        end
    end

    function automatic void axi_local_set_config_enable_error_from_SystemVerilog( ref bit [255:0] config_enable_error_param );
            axi_set_config_enable_error_from_SystemVerilog(config_enable_error); // DPI call to imported task
        
            axi_propagate_config_enable_error_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_error_from_SystemVerilog( config_enable_error );
            end
        end
    end

    function automatic void axi_local_set_config_enable_errors_from_SystemVerilog( ref bit config_enable_errors_param );
            axi_set_config_enable_errors_from_SystemVerilog(config_enable_errors); // DPI call to imported task
        
            axi_propagate_config_enable_errors_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_errors_from_SystemVerilog( config_enable_errors );
            end
        end
    end

    function automatic void axi_local_set_config_enable_all_assertion_errors_from_SystemVerilog( ref bit config_enable_all_assertion_errors_param );
            axi_set_config_enable_all_assertion_errors_from_SystemVerilog(config_enable_all_assertion_errors); // DPI call to imported task
        
            axi_propagate_config_enable_all_assertion_errors_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_all_assertion_errors_from_SystemVerilog( config_enable_all_assertion_errors );
            end
        end
    end

    function automatic void axi_local_set_config_abstraction_level_from_SystemVerilog( ref axi_abstraction_level_e config_abstraction_level_param );
        int tmp_config_abstraction_level;
        tmp_config_abstraction_level = int'( config_abstraction_level );
            axi_set_config_abstraction_level_from_SystemVerilog(
            tmp_config_abstraction_level
            ); // DPI call to imported task
        
            axi_propagate_config_abstraction_level_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_abstraction_level_from_SystemVerilog( config_abstraction_level );
            end
        end
    end

    function automatic void axi_local_set_config_slave_start_addr_from_SystemVerilog( ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ADDRESS_WIDTH ); _this_dot_1++)
        begin
            axi_set_config_slave_start_addr_from_SystemVerilog_index1(_this_dot_1,config_slave_start_addr[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
            axi_propagate_config_slave_start_addr_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_slave_start_addr_from_SystemVerilog( config_slave_start_addr );
            end
        end
    end

    function automatic void axi_local_set_config_slave_end_addr_from_SystemVerilog( ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ADDRESS_WIDTH ); _this_dot_1++)
        begin
            axi_set_config_slave_end_addr_from_SystemVerilog_index1(_this_dot_1,config_slave_end_addr[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
            axi_propagate_config_slave_end_addr_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_slave_end_addr_from_SystemVerilog( config_slave_end_addr );
            end
        end
    end

    function automatic void axi_local_set_config_enable_slave_addr_range_in_bfm_from_SystemVerilog( ref bit config_enable_slave_addr_range_in_bfm_param );
            axi_set_config_enable_slave_addr_range_in_bfm_from_SystemVerilog(config_enable_slave_addr_range_in_bfm); // DPI call to imported task
        
            axi_propagate_config_enable_slave_addr_range_in_bfm_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_slave_addr_range_in_bfm_from_SystemVerilog( config_enable_slave_addr_range_in_bfm );
            end
        end
    end

    function automatic void axi_local_set_config_read_data_reordering_depth_from_SystemVerilog( ref int unsigned config_read_data_reordering_depth_param );
            axi_set_config_read_data_reordering_depth_from_SystemVerilog(config_read_data_reordering_depth); // DPI call to imported task
        
            axi_propagate_config_read_data_reordering_depth_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_read_data_reordering_depth_from_SystemVerilog( config_read_data_reordering_depth );
            end
        end
    end

    function automatic void axi_local_set_config_enable_read_data_reordering_depth_in_bfm_from_SystemVerilog( ref bit config_enable_read_data_reordering_depth_in_bfm_param );
            axi_set_config_enable_read_data_reordering_depth_in_bfm_from_SystemVerilog(config_enable_read_data_reordering_depth_in_bfm); // DPI call to imported task
        
            axi_propagate_config_enable_read_data_reordering_depth_in_bfm_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_read_data_reordering_depth_in_bfm_from_SystemVerilog( config_enable_read_data_reordering_depth_in_bfm );
            end
        end
    end

    function automatic void axi_local_set_config_awid_wid_mismatch_from_SystemVerilog( ref bit config_awid_wid_mismatch_param );
            axi_set_config_awid_wid_mismatch_from_SystemVerilog(config_awid_wid_mismatch); // DPI call to imported task
        
            axi_propagate_config_awid_wid_mismatch_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_awid_wid_mismatch_from_SystemVerilog( config_awid_wid_mismatch );
            end
        end
    end

    function automatic void axi_local_set_config_length_last_mismatch_error_from_SystemVerilog( ref bit config_length_last_mismatch_error_param );
            axi_set_config_length_last_mismatch_error_from_SystemVerilog(config_length_last_mismatch_error); // DPI call to imported task
        
            axi_propagate_config_length_last_mismatch_error_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_length_last_mismatch_error_from_SystemVerilog( config_length_last_mismatch_error );
            end
        end
    end

    function automatic void axi_local_set_config_master_error_position_from_SystemVerilog( ref axi_error_e config_master_error_position_param );
        int tmp_config_master_error_position;
        tmp_config_master_error_position = int'( config_master_error_position );
            axi_set_config_master_error_position_from_SystemVerilog(
            tmp_config_master_error_position
            ); // DPI call to imported task
        
            axi_propagate_config_master_error_position_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_master_error_position_from_SystemVerilog( config_master_error_position );
            end
        end
    end

    function automatic void axi_local_set_dummy_var_from_SystemVerilog( ref axi_assertion_type_e dummy_var_param );
        int tmp_dummy_var;
        tmp_dummy_var = int'( dummy_var );
            axi_set_dummy_var_from_SystemVerilog(
            tmp_dummy_var
            ); // DPI call to imported task
        
            axi_propagate_dummy_var_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_dummy_var_from_SystemVerilog( dummy_var );
            end
        end
    end

    function automatic void axi_local_set_config_wlast_length_from_SystemVerilog( ref int config_wlast_length_param );
            axi_set_config_wlast_length_from_SystemVerilog(config_wlast_length); // DPI call to imported task
        
            axi_propagate_config_wlast_length_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_wlast_length_from_SystemVerilog( config_wlast_length );
            end
        end
    end

    function automatic void axi_local_set_config_wid_for_awid_not_matching_from_SystemVerilog( ref bit [((AXI_ID_WIDTH) - 1):0]  config_wid_for_awid_not_matching_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ID_WIDTH ); _this_dot_1++)
        begin
            axi_set_config_wid_for_awid_not_matching_from_SystemVerilog_index1(_this_dot_1,config_wid_for_awid_not_matching[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
            axi_propagate_config_wid_for_awid_not_matching_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_wid_for_awid_not_matching_from_SystemVerilog( config_wid_for_awid_not_matching );
            end
        end
    end

    function automatic void axi_local_set_config_support_exclusive_access_from_SystemVerilog( ref bit config_support_exclusive_access_param );
            axi_set_config_support_exclusive_access_from_SystemVerilog(config_support_exclusive_access); // DPI call to imported task
        
            axi_propagate_config_support_exclusive_access_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_support_exclusive_access_from_SystemVerilog( config_support_exclusive_access );
            end
        end
    end

    function automatic void axi_local_set_config_write_data_interleaving_depth_from_SystemVerilog( ref int config_write_data_interleaving_depth_param );
            axi_set_config_write_data_interleaving_depth_from_SystemVerilog(config_write_data_interleaving_depth); // DPI call to imported task
        
            axi_propagate_config_write_data_interleaving_depth_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_write_data_interleaving_depth_from_SystemVerilog( config_write_data_interleaving_depth );
            end
        end
    end

    function automatic void axi_local_set_status_master_error_from_SystemVerilog( ref bit [15:0] status_master_error_param );
            axi_set_status_master_error_from_SystemVerilog(status_master_error); // DPI call to imported task
        
            axi_propagate_status_master_error_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_status_master_error_from_SystemVerilog( status_master_error );
            end
        end
    end

    function automatic void axi_local_set_check_total_num_wdata_outstanding_from_SystemVerilog( ref bit check_total_num_wdata_outstanding_param );
            axi_set_check_total_num_wdata_outstanding_from_SystemVerilog(check_total_num_wdata_outstanding); // DPI call to imported task
        
            axi_propagate_check_total_num_wdata_outstanding_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_check_total_num_wdata_outstanding_from_SystemVerilog( check_total_num_wdata_outstanding );
            end
        end
    end

    function automatic void axi_local_set_total_num_wdata_outstanding_from_SystemVerilog( ref int total_num_wdata_outstanding_param );
            axi_set_total_num_wdata_outstanding_from_SystemVerilog(total_num_wdata_outstanding); // DPI call to imported task
        
            axi_propagate_total_num_wdata_outstanding_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_total_num_wdata_outstanding_from_SystemVerilog( total_num_wdata_outstanding );
            end
        end
    end

    function automatic void axi_local_set_check_max_num_wdata_outstanding_per_id_from_SystemVerilog( ref bit check_max_num_wdata_outstanding_per_id_param );
            axi_set_check_max_num_wdata_outstanding_per_id_from_SystemVerilog(check_max_num_wdata_outstanding_per_id); // DPI call to imported task
        
            axi_propagate_check_max_num_wdata_outstanding_per_id_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_check_max_num_wdata_outstanding_per_id_from_SystemVerilog( check_max_num_wdata_outstanding_per_id );
            end
        end
    end

    function automatic void axi_local_set_max_num_wdata_outstanding_per_id_from_SystemVerilog( ref int max_num_wdata_outstanding_per_id_param );
            axi_set_max_num_wdata_outstanding_per_id_from_SystemVerilog(max_num_wdata_outstanding_per_id); // DPI call to imported task
        
            axi_propagate_max_num_wdata_outstanding_per_id_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_max_num_wdata_outstanding_per_id_from_SystemVerilog( max_num_wdata_outstanding_per_id );
            end
        end
    end

    function automatic void axi_local_set_check_max_num_waddr_outstanding_per_id_from_SystemVerilog( ref bit check_max_num_waddr_outstanding_per_id_param );
            axi_set_check_max_num_waddr_outstanding_per_id_from_SystemVerilog(check_max_num_waddr_outstanding_per_id); // DPI call to imported task
        
            axi_propagate_check_max_num_waddr_outstanding_per_id_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_check_max_num_waddr_outstanding_per_id_from_SystemVerilog( check_max_num_waddr_outstanding_per_id );
            end
        end
    end

    function automatic void axi_local_set_max_num_waddr_outstanding_per_id_from_SystemVerilog( ref int max_num_waddr_outstanding_per_id_param );
            axi_set_max_num_waddr_outstanding_per_id_from_SystemVerilog(max_num_waddr_outstanding_per_id); // DPI call to imported task
        
            axi_propagate_max_num_waddr_outstanding_per_id_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_max_num_waddr_outstanding_per_id_from_SystemVerilog( max_num_waddr_outstanding_per_id );
            end
        end
    end

    function automatic void axi_local_set_check_total_num_waddr_outstanding_from_SystemVerilog( ref bit check_total_num_waddr_outstanding_param );
            axi_set_check_total_num_waddr_outstanding_from_SystemVerilog(check_total_num_waddr_outstanding); // DPI call to imported task
        
            axi_propagate_check_total_num_waddr_outstanding_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_check_total_num_waddr_outstanding_from_SystemVerilog( check_total_num_waddr_outstanding );
            end
        end
    end

    function automatic void axi_local_set_total_num_waddr_outstanding_from_SystemVerilog( ref int total_num_waddr_outstanding_param );
            axi_set_total_num_waddr_outstanding_from_SystemVerilog(total_num_waddr_outstanding); // DPI call to imported task
        
            axi_propagate_total_num_waddr_outstanding_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_total_num_waddr_outstanding_from_SystemVerilog( total_num_waddr_outstanding );
            end
        end
    end

    function automatic void axi_local_set_status_outstanding_num_for_waddr_from_SystemVerilog( ref int status_outstanding_num_for_waddr_param );
            axi_set_status_outstanding_num_for_waddr_from_SystemVerilog(status_outstanding_num_for_waddr); // DPI call to imported task
        
            axi_propagate_status_outstanding_num_for_waddr_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_status_outstanding_num_for_waddr_from_SystemVerilog( status_outstanding_num_for_waddr );
            end
        end
    end

    function automatic void axi_local_set_start_finding_outstanding_waddr_from_SystemVerilog( ref bit start_finding_outstanding_waddr_param );
            axi_set_start_finding_outstanding_waddr_from_SystemVerilog(start_finding_outstanding_waddr); // DPI call to imported task
        
            axi_propagate_start_finding_outstanding_waddr_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_start_finding_outstanding_waddr_from_SystemVerilog( start_finding_outstanding_waddr );
            end
        end
    end

    function automatic void axi_local_set_status_outstanding_num_for_wdata_from_SystemVerilog( ref int status_outstanding_num_for_wdata_param );
            axi_set_status_outstanding_num_for_wdata_from_SystemVerilog(status_outstanding_num_for_wdata); // DPI call to imported task
        
            axi_propagate_status_outstanding_num_for_wdata_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_status_outstanding_num_for_wdata_from_SystemVerilog( status_outstanding_num_for_wdata );
            end
        end
    end

    function automatic void axi_local_set_start_finding_outstanding_wdata_from_SystemVerilog( ref bit start_finding_outstanding_wdata_param );
            axi_set_start_finding_outstanding_wdata_from_SystemVerilog(start_finding_outstanding_wdata); // DPI call to imported task
        
            axi_propagate_start_finding_outstanding_wdata_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_start_finding_outstanding_wdata_from_SystemVerilog( start_finding_outstanding_wdata );
            end
        end
    end

    function automatic void axi_local_set_find_waddr_outstanding_for_wid_from_SystemVerilog( ref bit [((AXI_ID_WIDTH) - 1):0]  find_waddr_outstanding_for_wid_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ID_WIDTH ); _this_dot_1++)
        begin
            axi_set_find_waddr_outstanding_for_wid_from_SystemVerilog_index1(_this_dot_1,find_waddr_outstanding_for_wid[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
            axi_propagate_find_waddr_outstanding_for_wid_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_find_waddr_outstanding_for_wid_from_SystemVerilog( find_waddr_outstanding_for_wid );
            end
        end
    end

    function automatic void axi_local_set_find_wdata_outstanding_for_wid_from_SystemVerilog( ref bit [((AXI_ID_WIDTH) - 1):0]  find_wdata_outstanding_for_wid_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ID_WIDTH ); _this_dot_1++)
        begin
            axi_set_find_wdata_outstanding_for_wid_from_SystemVerilog_index1(_this_dot_1,find_wdata_outstanding_for_wid[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
            axi_propagate_find_wdata_outstanding_for_wid_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_find_wdata_outstanding_for_wid_from_SystemVerilog( find_wdata_outstanding_for_wid );
            end
        end
    end

    function automatic void axi_local_set_change_in_wdata_outstanding_per_id_from_SystemVerilog( ref bit change_in_wdata_outstanding_per_id_param );
            axi_set_change_in_wdata_outstanding_per_id_from_SystemVerilog(change_in_wdata_outstanding_per_id); // DPI call to imported task
        
            axi_propagate_change_in_wdata_outstanding_per_id_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_change_in_wdata_outstanding_per_id_from_SystemVerilog( change_in_wdata_outstanding_per_id );
            end
        end
    end

    function automatic void axi_local_set_start_finding_change_in_wdata_from_SystemVerilog( ref bit start_finding_change_in_wdata_param );
            axi_set_start_finding_change_in_wdata_from_SystemVerilog(start_finding_change_in_wdata); // DPI call to imported task
        
            axi_propagate_start_finding_change_in_wdata_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_start_finding_change_in_wdata_from_SystemVerilog( start_finding_change_in_wdata );
            end
        end
    end

    function automatic void axi_local_set_find_change_in_wdata_outstanding_for_wid_from_SystemVerilog( ref bit [((AXI_ID_WIDTH) - 1):0]  find_change_in_wdata_outstanding_for_wid_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ID_WIDTH ); _this_dot_1++)
        begin
            axi_set_find_change_in_wdata_outstanding_for_wid_from_SystemVerilog_index1(_this_dot_1,find_change_in_wdata_outstanding_for_wid[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
            axi_propagate_find_change_in_wdata_outstanding_for_wid_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_find_change_in_wdata_outstanding_for_wid_from_SystemVerilog( find_change_in_wdata_outstanding_for_wid );
            end
        end
    end

    function automatic void axi_local_set_config_max_outstanding_wr_from_SystemVerilog( ref int config_max_outstanding_wr_param );
            axi_set_config_max_outstanding_wr_from_SystemVerilog(config_max_outstanding_wr); // DPI call to imported task
        
            axi_propagate_config_max_outstanding_wr_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_outstanding_wr_from_SystemVerilog( config_max_outstanding_wr );
            end
        end
    end

    function automatic void axi_local_set_config_max_outstanding_rd_from_SystemVerilog( ref int config_max_outstanding_rd_param );
            axi_set_config_max_outstanding_rd_from_SystemVerilog(config_max_outstanding_rd); // DPI call to imported task
        
            axi_propagate_config_max_outstanding_rd_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_outstanding_rd_from_SystemVerilog( config_max_outstanding_rd );
            end
        end
    end

    function automatic void axi_local_set_config_error_on_deleted_valid_cycles_from_SystemVerilog( ref bit config_error_on_deleted_valid_cycles_param );
            axi_set_config_error_on_deleted_valid_cycles_from_SystemVerilog(config_error_on_deleted_valid_cycles); // DPI call to imported task
        
            axi_propagate_config_error_on_deleted_valid_cycles_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_error_on_deleted_valid_cycles_from_SystemVerilog( config_error_on_deleted_valid_cycles );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_from_SystemVerilog( ref bit config_stats_enable_param );
            axi_set_config_stats_enable_from_SystemVerilog(config_stats_enable); // DPI call to imported task
        
            axi_propagate_config_stats_enable_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_from_SystemVerilog( config_stats_enable );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_AXI_read_occupancy_from_SystemVerilog( ref bit config_stats_enable_AXI_read_occupancy_param );
            axi_set_config_stats_enable_AXI_read_occupancy_from_SystemVerilog(config_stats_enable_AXI_read_occupancy); // DPI call to imported task
        
            axi_propagate_config_stats_enable_AXI_read_occupancy_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_AXI_read_occupancy_from_SystemVerilog( config_stats_enable_AXI_read_occupancy );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_AXI_write_occupancy_from_SystemVerilog( ref bit config_stats_enable_AXI_write_occupancy_param );
            axi_set_config_stats_enable_AXI_write_occupancy_from_SystemVerilog(config_stats_enable_AXI_write_occupancy); // DPI call to imported task
        
            axi_propagate_config_stats_enable_AXI_write_occupancy_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_AXI_write_occupancy_from_SystemVerilog( config_stats_enable_AXI_write_occupancy );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_read_data_occupancy_from_SystemVerilog( ref bit config_stats_enable_read_data_occupancy_param );
            axi_set_config_stats_enable_read_data_occupancy_from_SystemVerilog(config_stats_enable_read_data_occupancy); // DPI call to imported task
        
            axi_propagate_config_stats_enable_read_data_occupancy_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_read_data_occupancy_from_SystemVerilog( config_stats_enable_read_data_occupancy );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_write_data_occupancy_from_SystemVerilog( ref bit config_stats_enable_write_data_occupancy_param );
            axi_set_config_stats_enable_write_data_occupancy_from_SystemVerilog(config_stats_enable_write_data_occupancy); // DPI call to imported task
        
            axi_propagate_config_stats_enable_write_data_occupancy_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_write_data_occupancy_from_SystemVerilog( config_stats_enable_write_data_occupancy );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_read_latency_from_SystemVerilog( ref bit config_stats_enable_read_latency_param );
            axi_set_config_stats_enable_read_latency_from_SystemVerilog(config_stats_enable_read_latency); // DPI call to imported task
        
            axi_propagate_config_stats_enable_read_latency_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_read_latency_from_SystemVerilog( config_stats_enable_read_latency );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_write_latency_from_SystemVerilog( ref bit config_stats_enable_write_latency_param );
            axi_set_config_stats_enable_write_latency_from_SystemVerilog(config_stats_enable_write_latency); // DPI call to imported task
        
            axi_propagate_config_stats_enable_write_latency_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_write_latency_from_SystemVerilog( config_stats_enable_write_latency );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_read_address_waits_from_SystemVerilog( ref bit config_stats_enable_read_address_waits_param );
            axi_set_config_stats_enable_read_address_waits_from_SystemVerilog(config_stats_enable_read_address_waits); // DPI call to imported task
        
            axi_propagate_config_stats_enable_read_address_waits_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_read_address_waits_from_SystemVerilog( config_stats_enable_read_address_waits );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_read_data_waits_from_SystemVerilog( ref bit config_stats_enable_read_data_waits_param );
            axi_set_config_stats_enable_read_data_waits_from_SystemVerilog(config_stats_enable_read_data_waits); // DPI call to imported task
        
            axi_propagate_config_stats_enable_read_data_waits_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_read_data_waits_from_SystemVerilog( config_stats_enable_read_data_waits );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_write_address_waits_from_SystemVerilog( ref bit config_stats_enable_write_address_waits_param );
            axi_set_config_stats_enable_write_address_waits_from_SystemVerilog(config_stats_enable_write_address_waits); // DPI call to imported task
        
            axi_propagate_config_stats_enable_write_address_waits_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_write_address_waits_from_SystemVerilog( config_stats_enable_write_address_waits );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_write_data_waits_from_SystemVerilog( ref bit config_stats_enable_write_data_waits_param );
            axi_set_config_stats_enable_write_data_waits_from_SystemVerilog(config_stats_enable_write_data_waits); // DPI call to imported task
        
            axi_propagate_config_stats_enable_write_data_waits_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_write_data_waits_from_SystemVerilog( config_stats_enable_write_data_waits );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_write_response_waits_from_SystemVerilog( ref bit config_stats_enable_write_response_waits_param );
            axi_set_config_stats_enable_write_response_waits_from_SystemVerilog(config_stats_enable_write_response_waits); // DPI call to imported task
        
            axi_propagate_config_stats_enable_write_response_waits_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_write_response_waits_from_SystemVerilog( config_stats_enable_write_response_waits );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_read_bandwidth_from_SystemVerilog( ref bit config_stats_enable_read_bandwidth_param );
            axi_set_config_stats_enable_read_bandwidth_from_SystemVerilog(config_stats_enable_read_bandwidth); // DPI call to imported task
        
            axi_propagate_config_stats_enable_read_bandwidth_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_read_bandwidth_from_SystemVerilog( config_stats_enable_read_bandwidth );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_write_bandwidth_from_SystemVerilog( ref bit config_stats_enable_write_bandwidth_param );
            axi_set_config_stats_enable_write_bandwidth_from_SystemVerilog(config_stats_enable_write_bandwidth); // DPI call to imported task
        
            axi_propagate_config_stats_enable_write_bandwidth_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_write_bandwidth_from_SystemVerilog( config_stats_enable_write_bandwidth );
            end
        end
    end

    function automatic void axi_local_set_config_stats_AXI_read_occupancy_step_from_SystemVerilog( ref int config_stats_AXI_read_occupancy_step_param );
            axi_set_config_stats_AXI_read_occupancy_step_from_SystemVerilog(config_stats_AXI_read_occupancy_step); // DPI call to imported task
        
            axi_propagate_config_stats_AXI_read_occupancy_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_AXI_read_occupancy_step_from_SystemVerilog( config_stats_AXI_read_occupancy_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_AXI_read_occupancy_multiple_from_SystemVerilog( ref int config_stats_AXI_read_occupancy_multiple_param );
            axi_set_config_stats_AXI_read_occupancy_multiple_from_SystemVerilog(config_stats_AXI_read_occupancy_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_AXI_read_occupancy_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_AXI_read_occupancy_multiple_from_SystemVerilog( config_stats_AXI_read_occupancy_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_AXI_write_occupancy_step_from_SystemVerilog( ref int config_stats_AXI_write_occupancy_step_param );
            axi_set_config_stats_AXI_write_occupancy_step_from_SystemVerilog(config_stats_AXI_write_occupancy_step); // DPI call to imported task
        
            axi_propagate_config_stats_AXI_write_occupancy_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_AXI_write_occupancy_step_from_SystemVerilog( config_stats_AXI_write_occupancy_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_AXI_write_occupancy_multiple_from_SystemVerilog( ref int config_stats_AXI_write_occupancy_multiple_param );
            axi_set_config_stats_AXI_write_occupancy_multiple_from_SystemVerilog(config_stats_AXI_write_occupancy_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_AXI_write_occupancy_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_AXI_write_occupancy_multiple_from_SystemVerilog( config_stats_AXI_write_occupancy_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_data_occupancy_step_from_SystemVerilog( ref int config_stats_read_data_occupancy_step_param );
            axi_set_config_stats_read_data_occupancy_step_from_SystemVerilog(config_stats_read_data_occupancy_step); // DPI call to imported task
        
            axi_propagate_config_stats_read_data_occupancy_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_data_occupancy_step_from_SystemVerilog( config_stats_read_data_occupancy_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog( ref int config_stats_read_data_occupancy_multiple_param );
            axi_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog(config_stats_read_data_occupancy_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_read_data_occupancy_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog( config_stats_read_data_occupancy_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_data_occupancy_step_from_SystemVerilog( ref int config_stats_write_data_occupancy_step_param );
            axi_set_config_stats_write_data_occupancy_step_from_SystemVerilog(config_stats_write_data_occupancy_step); // DPI call to imported task
        
            axi_propagate_config_stats_write_data_occupancy_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_data_occupancy_step_from_SystemVerilog( config_stats_write_data_occupancy_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog( ref int config_stats_write_data_occupancy_multiple_param );
            axi_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog(config_stats_write_data_occupancy_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_write_data_occupancy_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog( config_stats_write_data_occupancy_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_bandwidth_step_from_SystemVerilog( ref int config_stats_read_bandwidth_step_param );
            axi_set_config_stats_read_bandwidth_step_from_SystemVerilog(config_stats_read_bandwidth_step); // DPI call to imported task
        
            axi_propagate_config_stats_read_bandwidth_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_bandwidth_step_from_SystemVerilog( config_stats_read_bandwidth_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_bandwidth_multiple_from_SystemVerilog( ref int config_stats_read_bandwidth_multiple_param );
            axi_set_config_stats_read_bandwidth_multiple_from_SystemVerilog(config_stats_read_bandwidth_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_read_bandwidth_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_bandwidth_multiple_from_SystemVerilog( config_stats_read_bandwidth_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_bandwidth_step_from_SystemVerilog( ref int config_stats_write_bandwidth_step_param );
            axi_set_config_stats_write_bandwidth_step_from_SystemVerilog(config_stats_write_bandwidth_step); // DPI call to imported task
        
            axi_propagate_config_stats_write_bandwidth_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_bandwidth_step_from_SystemVerilog( config_stats_write_bandwidth_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_bandwidth_multiple_from_SystemVerilog( ref int config_stats_write_bandwidth_multiple_param );
            axi_set_config_stats_write_bandwidth_multiple_from_SystemVerilog(config_stats_write_bandwidth_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_write_bandwidth_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_bandwidth_multiple_from_SystemVerilog( config_stats_write_bandwidth_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_latency_step_from_SystemVerilog( ref int config_stats_read_latency_step_param );
            axi_set_config_stats_read_latency_step_from_SystemVerilog(config_stats_read_latency_step); // DPI call to imported task
        
            axi_propagate_config_stats_read_latency_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_latency_step_from_SystemVerilog( config_stats_read_latency_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_latency_multiple_from_SystemVerilog( ref int config_stats_read_latency_multiple_param );
            axi_set_config_stats_read_latency_multiple_from_SystemVerilog(config_stats_read_latency_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_read_latency_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_latency_multiple_from_SystemVerilog( config_stats_read_latency_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_latency_step_from_SystemVerilog( ref int config_stats_write_latency_step_param );
            axi_set_config_stats_write_latency_step_from_SystemVerilog(config_stats_write_latency_step); // DPI call to imported task
        
            axi_propagate_config_stats_write_latency_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_latency_step_from_SystemVerilog( config_stats_write_latency_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_latency_multiple_from_SystemVerilog( ref int config_stats_write_latency_multiple_param );
            axi_set_config_stats_write_latency_multiple_from_SystemVerilog(config_stats_write_latency_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_write_latency_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_latency_multiple_from_SystemVerilog( config_stats_write_latency_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_address_waits_step_from_SystemVerilog( ref int config_stats_read_address_waits_step_param );
            axi_set_config_stats_read_address_waits_step_from_SystemVerilog(config_stats_read_address_waits_step); // DPI call to imported task
        
            axi_propagate_config_stats_read_address_waits_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_address_waits_step_from_SystemVerilog( config_stats_read_address_waits_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_address_waits_multiple_from_SystemVerilog( ref int config_stats_read_address_waits_multiple_param );
            axi_set_config_stats_read_address_waits_multiple_from_SystemVerilog(config_stats_read_address_waits_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_read_address_waits_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_address_waits_multiple_from_SystemVerilog( config_stats_read_address_waits_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_data_waits_step_from_SystemVerilog( ref int config_stats_read_data_waits_step_param );
            axi_set_config_stats_read_data_waits_step_from_SystemVerilog(config_stats_read_data_waits_step); // DPI call to imported task
        
            axi_propagate_config_stats_read_data_waits_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_data_waits_step_from_SystemVerilog( config_stats_read_data_waits_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_data_waits_multiple_from_SystemVerilog( ref int config_stats_read_data_waits_multiple_param );
            axi_set_config_stats_read_data_waits_multiple_from_SystemVerilog(config_stats_read_data_waits_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_read_data_waits_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_data_waits_multiple_from_SystemVerilog( config_stats_read_data_waits_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_address_waits_step_from_SystemVerilog( ref int config_stats_write_address_waits_step_param );
            axi_set_config_stats_write_address_waits_step_from_SystemVerilog(config_stats_write_address_waits_step); // DPI call to imported task
        
            axi_propagate_config_stats_write_address_waits_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_address_waits_step_from_SystemVerilog( config_stats_write_address_waits_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_address_waits_multiple_from_SystemVerilog( ref int config_stats_write_address_waits_multiple_param );
            axi_set_config_stats_write_address_waits_multiple_from_SystemVerilog(config_stats_write_address_waits_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_write_address_waits_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_address_waits_multiple_from_SystemVerilog( config_stats_write_address_waits_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_data_waits_step_from_SystemVerilog( ref int config_stats_write_data_waits_step_param );
            axi_set_config_stats_write_data_waits_step_from_SystemVerilog(config_stats_write_data_waits_step); // DPI call to imported task
        
            axi_propagate_config_stats_write_data_waits_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_data_waits_step_from_SystemVerilog( config_stats_write_data_waits_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_data_waits_multiple_from_SystemVerilog( ref int config_stats_write_data_waits_multiple_param );
            axi_set_config_stats_write_data_waits_multiple_from_SystemVerilog(config_stats_write_data_waits_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_write_data_waits_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_data_waits_multiple_from_SystemVerilog( config_stats_write_data_waits_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_response_waits_step_from_SystemVerilog( ref int config_stats_write_response_waits_step_param );
            axi_set_config_stats_write_response_waits_step_from_SystemVerilog(config_stats_write_response_waits_step); // DPI call to imported task
        
            axi_propagate_config_stats_write_response_waits_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_response_waits_step_from_SystemVerilog( config_stats_write_response_waits_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_response_waits_multiple_from_SystemVerilog( ref int config_stats_write_response_waits_multiple_param );
            axi_set_config_stats_write_response_waits_multiple_from_SystemVerilog(config_stats_write_response_waits_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_write_response_waits_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_response_waits_multiple_from_SystemVerilog( config_stats_write_response_waits_multiple );
            end
        end
    end

    //------------------------------------------------------------------------------
    // Transaction interface
    //------------------------------------------------------------------------------

    bit [((AXI_ADDRESS_WIDTH) - 1):0]  temp_static_rw_transaction_addr;
    function void axi_get_temp_static_rw_transaction_addr( input int _d1, output bit  _value );
        _value = temp_static_rw_transaction_addr[_d1];
    endfunction
    function void axi_set_temp_static_rw_transaction_addr( input int _d1, input bit  _value );
        temp_static_rw_transaction_addr[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_rw_transaction_id;
    function void axi_get_temp_static_rw_transaction_id( input int _d1, output bit  _value );
        _value = temp_static_rw_transaction_id[_d1];
    endfunction
    function void axi_set_temp_static_rw_transaction_id( input int _d1, input bit  _value );
        temp_static_rw_transaction_id[_d1] = _value;
    endfunction
    bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] temp_static_rw_transaction_data_words [];
    function void axi_get_temp_static_rw_transaction_data_words( input int _d1, input int _d2, output bit _value );
        _value = temp_static_rw_transaction_data_words[_d1][_d2];
    endfunction
    function void axi_set_temp_static_rw_transaction_data_words( input int _d1, input int _d2, input bit _value );
        temp_static_rw_transaction_data_words[_d1][_d2] = _value;
    endfunction
    bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] temp_static_rw_transaction_write_strobes [];
    function void axi_get_temp_static_rw_transaction_write_strobes( input int _d1, input int _d2, output bit _value );
        _value = temp_static_rw_transaction_write_strobes[_d1][_d2];
    endfunction
    function void axi_set_temp_static_rw_transaction_write_strobes( input int _d1, input int _d2, input bit _value );
        temp_static_rw_transaction_write_strobes[_d1][_d2] = _value;
    endfunction
    int temp_static_rw_transaction_resp[];
    function void axi_get_temp_static_rw_transaction_resp( input int _d1, output int _value );
        _value = temp_static_rw_transaction_resp[_d1];
    endfunction
    function void axi_set_temp_static_rw_transaction_resp( input int _d1, input int _value );
        temp_static_rw_transaction_resp[_d1] = _value;
    endfunction
    bit [7:0] temp_static_rw_transaction_data_user [];
    function void axi_get_temp_static_rw_transaction_data_user( input int _d1, output bit [7:0] _value  );
        _value = temp_static_rw_transaction_data_user[_d1];
    endfunction
    function void axi_set_temp_static_rw_transaction_data_user( input int _d1, input bit [7:0] _value  );
        temp_static_rw_transaction_data_user[_d1] = _value;
    endfunction
    int temp_static_rw_transaction_write_data_beats_delay[];
    function void axi_get_temp_static_rw_transaction_write_data_beats_delay( input int _d1, output int _value );
        _value = temp_static_rw_transaction_write_data_beats_delay[_d1];
    endfunction
    function void axi_set_temp_static_rw_transaction_write_data_beats_delay( input int _d1, input int _value );
        temp_static_rw_transaction_write_data_beats_delay[_d1] = _value;
    endfunction
    int temp_static_rw_transaction_data_valid_delay[];
    function void axi_get_temp_static_rw_transaction_data_valid_delay( input int _d1, output int _value );
        _value = temp_static_rw_transaction_data_valid_delay[_d1];
    endfunction
    function void axi_set_temp_static_rw_transaction_data_valid_delay( input int _d1, input int _value );
        temp_static_rw_transaction_data_valid_delay[_d1] = _value;
    endfunction
    int temp_static_rw_transaction_data_ready_delay[];
    function void axi_get_temp_static_rw_transaction_data_ready_delay( input int _d1, output int _value );
        _value = temp_static_rw_transaction_data_ready_delay[_d1];
    endfunction
    function void axi_set_temp_static_rw_transaction_data_ready_delay( input int _d1, input int _value );
        temp_static_rw_transaction_data_ready_delay[_d1] = _value;
    endfunction
    bit [((AXI_ADDRESS_WIDTH) - 1):0]  temp_static_AXI_read_addr;
    function void axi_get_temp_static_AXI_read_addr( input int _d1, output bit  _value );
        _value = temp_static_AXI_read_addr[_d1];
    endfunction
    function void axi_set_temp_static_AXI_read_addr( input int _d1, input bit  _value );
        temp_static_AXI_read_addr[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_AXI_read_id;
    function void axi_get_temp_static_AXI_read_id( input int _d1, output bit  _value );
        _value = temp_static_AXI_read_id[_d1];
    endfunction
    function void axi_set_temp_static_AXI_read_id( input int _d1, input bit  _value );
        temp_static_AXI_read_id[_d1] = _value;
    endfunction
    bit [((AXI_RDATA_WIDTH) - 1):0] temp_static_AXI_read_data_words [];
    function void axi_get_temp_static_AXI_read_data_words( input int _d1, input int _d2, output bit _value );
        _value = temp_static_AXI_read_data_words[_d1][_d2];
    endfunction
    function void axi_set_temp_static_AXI_read_data_words( input int _d1, input int _d2, input bit _value );
        temp_static_AXI_read_data_words[_d1][_d2] = _value;
    endfunction
    int temp_static_AXI_read_resp[];
    function void axi_get_temp_static_AXI_read_resp( input int _d1, output int _value );
        _value = temp_static_AXI_read_resp[_d1];
    endfunction
    function void axi_set_temp_static_AXI_read_resp( input int _d1, input int _value );
        temp_static_AXI_read_resp[_d1] = _value;
    endfunction
    bit [7:0] temp_static_AXI_read_data_user [];
    function void axi_get_temp_static_AXI_read_data_user( input int _d1, output bit [7:0] _value  );
        _value = temp_static_AXI_read_data_user[_d1];
    endfunction
    function void axi_set_temp_static_AXI_read_data_user( input int _d1, input bit [7:0] _value  );
        temp_static_AXI_read_data_user[_d1] = _value;
    endfunction
    longint temp_static_AXI_read_data_start_time[];
    function void axi_get_temp_static_AXI_read_data_start_time( input int _d1, output longint _value );
        _value = temp_static_AXI_read_data_start_time[_d1];
    endfunction
    function void axi_set_temp_static_AXI_read_data_start_time( input int _d1, input longint _value );
        temp_static_AXI_read_data_start_time[_d1] = _value;
    endfunction
    longint temp_static_AXI_read_data_end_time[];
    function void axi_get_temp_static_AXI_read_data_end_time( input int _d1, output longint _value );
        _value = temp_static_AXI_read_data_end_time[_d1];
    endfunction
    function void axi_set_temp_static_AXI_read_data_end_time( input int _d1, input longint _value );
        temp_static_AXI_read_data_end_time[_d1] = _value;
    endfunction
    bit [((AXI_ADDRESS_WIDTH) - 1):0]  temp_static_AXI_write_addr;
    function void axi_get_temp_static_AXI_write_addr( input int _d1, output bit  _value );
        _value = temp_static_AXI_write_addr[_d1];
    endfunction
    function void axi_set_temp_static_AXI_write_addr( input int _d1, input bit  _value );
        temp_static_AXI_write_addr[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_AXI_write_id;
    function void axi_get_temp_static_AXI_write_id( input int _d1, output bit  _value );
        _value = temp_static_AXI_write_id[_d1];
    endfunction
    function void axi_set_temp_static_AXI_write_id( input int _d1, input bit  _value );
        temp_static_AXI_write_id[_d1] = _value;
    endfunction
    bit [((AXI_WDATA_WIDTH) - 1):0] temp_static_AXI_write_data_words [];
    function void axi_get_temp_static_AXI_write_data_words( input int _d1, input int _d2, output bit _value );
        _value = temp_static_AXI_write_data_words[_d1][_d2];
    endfunction
    function void axi_set_temp_static_AXI_write_data_words( input int _d1, input int _d2, input bit _value );
        temp_static_AXI_write_data_words[_d1][_d2] = _value;
    endfunction
    bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] temp_static_AXI_write_write_strobes [];
    function void axi_get_temp_static_AXI_write_write_strobes( input int _d1, input int _d2, output bit _value );
        _value = temp_static_AXI_write_write_strobes[_d1][_d2];
    endfunction
    function void axi_set_temp_static_AXI_write_write_strobes( input int _d1, input int _d2, input bit _value );
        temp_static_AXI_write_write_strobes[_d1][_d2] = _value;
    endfunction
    bit [7:0] temp_static_AXI_write_data_user [];
    function void axi_get_temp_static_AXI_write_data_user( input int _d1, output bit [7:0] _value  );
        _value = temp_static_AXI_write_data_user[_d1];
    endfunction
    function void axi_set_temp_static_AXI_write_data_user( input int _d1, input bit [7:0] _value  );
        temp_static_AXI_write_data_user[_d1] = _value;
    endfunction
    int temp_static_AXI_write_write_data_beats_delay[];
    function void axi_get_temp_static_AXI_write_write_data_beats_delay( input int _d1, output int _value );
        _value = temp_static_AXI_write_write_data_beats_delay[_d1];
    endfunction
    function void axi_set_temp_static_AXI_write_write_data_beats_delay( input int _d1, input int _value );
        temp_static_AXI_write_write_data_beats_delay[_d1] = _value;
    endfunction
    longint temp_static_AXI_write_data_start_time[];
    function void axi_get_temp_static_AXI_write_data_start_time( input int _d1, output longint _value );
        _value = temp_static_AXI_write_data_start_time[_d1];
    endfunction
    function void axi_set_temp_static_AXI_write_data_start_time( input int _d1, input longint _value );
        temp_static_AXI_write_data_start_time[_d1] = _value;
    endfunction
    longint temp_static_AXI_write_data_end_time[];
    function void axi_get_temp_static_AXI_write_data_end_time( input int _d1, output longint _value );
        _value = temp_static_AXI_write_data_end_time[_d1];
    endfunction
    function void axi_set_temp_static_AXI_write_data_end_time( input int _d1, input longint _value );
        temp_static_AXI_write_data_end_time[_d1] = _value;
    endfunction
    bit [((AXI_WDATA_WIDTH) - 1):0] temp_static_data_resp_data_words [];
    function void axi_get_temp_static_data_resp_data_words( input int _d1, input int _d2, output bit _value );
        _value = temp_static_data_resp_data_words[_d1][_d2];
    endfunction
    function void axi_set_temp_static_data_resp_data_words( input int _d1, input int _d2, input bit _value );
        temp_static_data_resp_data_words[_d1][_d2] = _value;
    endfunction
    bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] temp_static_data_resp_write_strobes [];
    function void axi_get_temp_static_data_resp_write_strobes( input int _d1, input int _d2, output bit _value );
        _value = temp_static_data_resp_write_strobes[_d1][_d2];
    endfunction
    function void axi_set_temp_static_data_resp_write_strobes( input int _d1, input int _d2, input bit _value );
        temp_static_data_resp_write_strobes[_d1][_d2] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_data_resp_id;
    function void axi_get_temp_static_data_resp_id( input int _d1, output bit  _value );
        _value = temp_static_data_resp_id[_d1];
    endfunction
    function void axi_set_temp_static_data_resp_id( input int _d1, input bit  _value );
        temp_static_data_resp_id[_d1] = _value;
    endfunction
    bit [7:0] temp_static_data_resp_data_user [];
    function void axi_get_temp_static_data_resp_data_user( input int _d1, output bit [7:0] _value  );
        _value = temp_static_data_resp_data_user[_d1];
    endfunction
    function void axi_set_temp_static_data_resp_data_user( input int _d1, input bit [7:0] _value  );
        temp_static_data_resp_data_user[_d1] = _value;
    endfunction
    int temp_static_data_resp_write_data_beats_delay[];
    function void axi_get_temp_static_data_resp_write_data_beats_delay( input int _d1, output int _value );
        _value = temp_static_data_resp_write_data_beats_delay[_d1];
    endfunction
    function void axi_set_temp_static_data_resp_write_data_beats_delay( input int _d1, input int _value );
        temp_static_data_resp_write_data_beats_delay[_d1] = _value;
    endfunction
    longint temp_static_data_resp_data_beat_start_time[];
    function void axi_get_temp_static_data_resp_data_beat_start_time( input int _d1, output longint _value );
        _value = temp_static_data_resp_data_beat_start_time[_d1];
    endfunction
    function void axi_set_temp_static_data_resp_data_beat_start_time( input int _d1, input longint _value );
        temp_static_data_resp_data_beat_start_time[_d1] = _value;
    endfunction
    longint temp_static_data_resp_data_beat_end_time[];
    function void axi_get_temp_static_data_resp_data_beat_end_time( input int _d1, output longint _value );
        _value = temp_static_data_resp_data_beat_end_time[_d1];
    endfunction
    function void axi_set_temp_static_data_resp_data_beat_end_time( input int _d1, input longint _value );
        temp_static_data_resp_data_beat_end_time[_d1] = _value;
    endfunction
    bit [((AXI_RDATA_WIDTH) - 1):0] temp_static_read_data_burst_data_words [];
    function void axi_get_temp_static_read_data_burst_data_words( input int _d1, input int _d2, output bit _value );
        _value = temp_static_read_data_burst_data_words[_d1][_d2];
    endfunction
    function void axi_set_temp_static_read_data_burst_data_words( input int _d1, input int _d2, input bit _value );
        temp_static_read_data_burst_data_words[_d1][_d2] = _value;
    endfunction
    int temp_static_read_data_burst_resp[];
    function void axi_get_temp_static_read_data_burst_resp( input int _d1, output int _value );
        _value = temp_static_read_data_burst_resp[_d1];
    endfunction
    function void axi_set_temp_static_read_data_burst_resp( input int _d1, input int _value );
        temp_static_read_data_burst_resp[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_read_data_burst_id;
    function void axi_get_temp_static_read_data_burst_id( input int _d1, output bit  _value );
        _value = temp_static_read_data_burst_id[_d1];
    endfunction
    function void axi_set_temp_static_read_data_burst_id( input int _d1, input bit  _value );
        temp_static_read_data_burst_id[_d1] = _value;
    endfunction
    bit [7:0] temp_static_read_data_burst_data_user [];
    function void axi_get_temp_static_read_data_burst_data_user( input int _d1, output bit [7:0] _value  );
        _value = temp_static_read_data_burst_data_user[_d1];
    endfunction
    function void axi_set_temp_static_read_data_burst_data_user( input int _d1, input bit [7:0] _value  );
        temp_static_read_data_burst_data_user[_d1] = _value;
    endfunction
    longint temp_static_read_data_burst_data_start_time[];
    function void axi_get_temp_static_read_data_burst_data_start_time( input int _d1, output longint _value );
        _value = temp_static_read_data_burst_data_start_time[_d1];
    endfunction
    function void axi_set_temp_static_read_data_burst_data_start_time( input int _d1, input longint _value );
        temp_static_read_data_burst_data_start_time[_d1] = _value;
    endfunction
    longint temp_static_read_data_burst_data_end_time[];
    function void axi_get_temp_static_read_data_burst_data_end_time( input int _d1, output longint _value );
        _value = temp_static_read_data_burst_data_end_time[_d1];
    endfunction
    function void axi_set_temp_static_read_data_burst_data_end_time( input int _d1, input longint _value );
        temp_static_read_data_burst_data_end_time[_d1] = _value;
    endfunction
    bit [((AXI_WDATA_WIDTH) - 1):0] temp_static_write_data_burst_data_words [];
    function void axi_get_temp_static_write_data_burst_data_words( input int _d1, input int _d2, output bit _value );
        _value = temp_static_write_data_burst_data_words[_d1][_d2];
    endfunction
    function void axi_set_temp_static_write_data_burst_data_words( input int _d1, input int _d2, input bit _value );
        temp_static_write_data_burst_data_words[_d1][_d2] = _value;
    endfunction
    bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] temp_static_write_data_burst_write_strobes [];
    function void axi_get_temp_static_write_data_burst_write_strobes( input int _d1, input int _d2, output bit _value );
        _value = temp_static_write_data_burst_write_strobes[_d1][_d2];
    endfunction
    function void axi_set_temp_static_write_data_burst_write_strobes( input int _d1, input int _d2, input bit _value );
        temp_static_write_data_burst_write_strobes[_d1][_d2] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_write_data_burst_id;
    function void axi_get_temp_static_write_data_burst_id( input int _d1, output bit  _value );
        _value = temp_static_write_data_burst_id[_d1];
    endfunction
    function void axi_set_temp_static_write_data_burst_id( input int _d1, input bit  _value );
        temp_static_write_data_burst_id[_d1] = _value;
    endfunction
    bit [7:0] temp_static_write_data_burst_data_user [];
    function void axi_get_temp_static_write_data_burst_data_user( input int _d1, output bit [7:0] _value  );
        _value = temp_static_write_data_burst_data_user[_d1];
    endfunction
    function void axi_set_temp_static_write_data_burst_data_user( input int _d1, input bit [7:0] _value  );
        temp_static_write_data_burst_data_user[_d1] = _value;
    endfunction
    int temp_static_write_data_burst_write_data_beats_delay[];
    function void axi_get_temp_static_write_data_burst_write_data_beats_delay( input int _d1, output int _value );
        _value = temp_static_write_data_burst_write_data_beats_delay[_d1];
    endfunction
    function void axi_set_temp_static_write_data_burst_write_data_beats_delay( input int _d1, input int _value );
        temp_static_write_data_burst_write_data_beats_delay[_d1] = _value;
    endfunction
    longint temp_static_write_data_burst_data_start_time[];
    function void axi_get_temp_static_write_data_burst_data_start_time( input int _d1, output longint _value );
        _value = temp_static_write_data_burst_data_start_time[_d1];
    endfunction
    function void axi_set_temp_static_write_data_burst_data_start_time( input int _d1, input longint _value );
        temp_static_write_data_burst_data_start_time[_d1] = _value;
    endfunction
    longint temp_static_write_data_burst_data_end_time[];
    function void axi_get_temp_static_write_data_burst_data_end_time( input int _d1, output longint _value );
        _value = temp_static_write_data_burst_data_end_time[_d1];
    endfunction
    function void axi_set_temp_static_write_data_burst_data_end_time( input int _d1, input longint _value );
        temp_static_write_data_burst_data_end_time[_d1] = _value;
    endfunction
    bit [((AXI_ADDRESS_WIDTH) - 1):0]  temp_static_read_addr_channel_phase_addr;
    function void axi_get_temp_static_read_addr_channel_phase_addr( input int _d1, output bit  _value );
        _value = temp_static_read_addr_channel_phase_addr[_d1];
    endfunction
    function void axi_set_temp_static_read_addr_channel_phase_addr( input int _d1, input bit  _value );
        temp_static_read_addr_channel_phase_addr[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_read_addr_channel_phase_id;
    function void axi_get_temp_static_read_addr_channel_phase_id( input int _d1, output bit  _value );
        _value = temp_static_read_addr_channel_phase_id[_d1];
    endfunction
    function void axi_set_temp_static_read_addr_channel_phase_id( input int _d1, input bit  _value );
        temp_static_read_addr_channel_phase_id[_d1] = _value;
    endfunction
    bit [((AXI_RDATA_WIDTH) - 1):0]  temp_static_read_channel_phase_data;
    function void axi_get_temp_static_read_channel_phase_data( input int _d1, output bit  _value );
        _value = temp_static_read_channel_phase_data[_d1];
    endfunction
    function void axi_set_temp_static_read_channel_phase_data( input int _d1, input bit  _value );
        temp_static_read_channel_phase_data[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_read_channel_phase_id;
    function void axi_get_temp_static_read_channel_phase_id( input int _d1, output bit  _value );
        _value = temp_static_read_channel_phase_id[_d1];
    endfunction
    function void axi_set_temp_static_read_channel_phase_id( input int _d1, input bit  _value );
        temp_static_read_channel_phase_id[_d1] = _value;
    endfunction
    bit [((AXI_ADDRESS_WIDTH) - 1):0]  temp_static_write_addr_channel_phase_addr;
    function void axi_get_temp_static_write_addr_channel_phase_addr( input int _d1, output bit  _value );
        _value = temp_static_write_addr_channel_phase_addr[_d1];
    endfunction
    function void axi_set_temp_static_write_addr_channel_phase_addr( input int _d1, input bit  _value );
        temp_static_write_addr_channel_phase_addr[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_write_addr_channel_phase_id;
    function void axi_get_temp_static_write_addr_channel_phase_id( input int _d1, output bit  _value );
        _value = temp_static_write_addr_channel_phase_id[_d1];
    endfunction
    function void axi_set_temp_static_write_addr_channel_phase_id( input int _d1, input bit  _value );
        temp_static_write_addr_channel_phase_id[_d1] = _value;
    endfunction
    bit [((AXI_WDATA_WIDTH) - 1):0]  temp_static_write_channel_phase_data;
    function void axi_get_temp_static_write_channel_phase_data( input int _d1, output bit  _value );
        _value = temp_static_write_channel_phase_data[_d1];
    endfunction
    function void axi_set_temp_static_write_channel_phase_data( input int _d1, input bit  _value );
        temp_static_write_channel_phase_data[_d1] = _value;
    endfunction
    bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  temp_static_write_channel_phase_write_strobes;
    function void axi_get_temp_static_write_channel_phase_write_strobes( input int _d1, output bit  _value );
        _value = temp_static_write_channel_phase_write_strobes[_d1];
    endfunction
    function void axi_set_temp_static_write_channel_phase_write_strobes( input int _d1, input bit  _value );
        temp_static_write_channel_phase_write_strobes[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_write_channel_phase_id;
    function void axi_get_temp_static_write_channel_phase_id( input int _d1, output bit  _value );
        _value = temp_static_write_channel_phase_id[_d1];
    endfunction
    function void axi_set_temp_static_write_channel_phase_id( input int _d1, input bit  _value );
        temp_static_write_channel_phase_id[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_write_resp_channel_phase_id;
    function void axi_get_temp_static_write_resp_channel_phase_id( input int _d1, output bit  _value );
        _value = temp_static_write_resp_channel_phase_id[_d1];
    endfunction
    function void axi_set_temp_static_write_resp_channel_phase_id( input int _d1, input bit  _value );
        temp_static_write_resp_channel_phase_id[_d1] = _value;
    endfunction
    bit [((AXI_ADDRESS_WIDTH) - 1):0]  temp_static_read_addr_channel_cycle_addr;
    function void axi_get_temp_static_read_addr_channel_cycle_addr( input int _d1, output bit  _value );
        _value = temp_static_read_addr_channel_cycle_addr[_d1];
    endfunction
    function void axi_set_temp_static_read_addr_channel_cycle_addr( input int _d1, input bit  _value );
        temp_static_read_addr_channel_cycle_addr[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_read_addr_channel_cycle_id;
    function void axi_get_temp_static_read_addr_channel_cycle_id( input int _d1, output bit  _value );
        _value = temp_static_read_addr_channel_cycle_id[_d1];
    endfunction
    function void axi_set_temp_static_read_addr_channel_cycle_id( input int _d1, input bit  _value );
        temp_static_read_addr_channel_cycle_id[_d1] = _value;
    endfunction
    bit [((AXI_RDATA_WIDTH) - 1):0]  temp_static_read_channel_cycle_data;
    function void axi_get_temp_static_read_channel_cycle_data( input int _d1, output bit  _value );
        _value = temp_static_read_channel_cycle_data[_d1];
    endfunction
    function void axi_set_temp_static_read_channel_cycle_data( input int _d1, input bit  _value );
        temp_static_read_channel_cycle_data[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_read_channel_cycle_id;
    function void axi_get_temp_static_read_channel_cycle_id( input int _d1, output bit  _value );
        _value = temp_static_read_channel_cycle_id[_d1];
    endfunction
    function void axi_set_temp_static_read_channel_cycle_id( input int _d1, input bit  _value );
        temp_static_read_channel_cycle_id[_d1] = _value;
    endfunction
    bit [((AXI_ADDRESS_WIDTH) - 1):0]  temp_static_write_addr_channel_cycle_addr;
    function void axi_get_temp_static_write_addr_channel_cycle_addr( input int _d1, output bit  _value );
        _value = temp_static_write_addr_channel_cycle_addr[_d1];
    endfunction
    function void axi_set_temp_static_write_addr_channel_cycle_addr( input int _d1, input bit  _value );
        temp_static_write_addr_channel_cycle_addr[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_write_addr_channel_cycle_id;
    function void axi_get_temp_static_write_addr_channel_cycle_id( input int _d1, output bit  _value );
        _value = temp_static_write_addr_channel_cycle_id[_d1];
    endfunction
    function void axi_set_temp_static_write_addr_channel_cycle_id( input int _d1, input bit  _value );
        temp_static_write_addr_channel_cycle_id[_d1] = _value;
    endfunction
    bit [((AXI_WDATA_WIDTH) - 1):0]  temp_static_write_channel_cycle_data;
    function void axi_get_temp_static_write_channel_cycle_data( input int _d1, output bit  _value );
        _value = temp_static_write_channel_cycle_data[_d1];
    endfunction
    function void axi_set_temp_static_write_channel_cycle_data( input int _d1, input bit  _value );
        temp_static_write_channel_cycle_data[_d1] = _value;
    endfunction
    bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  temp_static_write_channel_cycle_strb;
    function void axi_get_temp_static_write_channel_cycle_strb( input int _d1, output bit  _value );
        _value = temp_static_write_channel_cycle_strb[_d1];
    endfunction
    function void axi_set_temp_static_write_channel_cycle_strb( input int _d1, input bit  _value );
        temp_static_write_channel_cycle_strb[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_write_channel_cycle_id;
    function void axi_get_temp_static_write_channel_cycle_id( input int _d1, output bit  _value );
        _value = temp_static_write_channel_cycle_id[_d1];
    endfunction
    function void axi_set_temp_static_write_channel_cycle_id( input int _d1, input bit  _value );
        temp_static_write_channel_cycle_id[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_write_resp_channel_cycle_id;
    function void axi_get_temp_static_write_resp_channel_cycle_id( input int _d1, output bit  _value );
        _value = temp_static_write_resp_channel_cycle_id[_d1];
    endfunction
    function void axi_set_temp_static_write_resp_channel_cycle_id( input int _d1, input bit  _value );
        temp_static_write_resp_channel_cycle_id[_d1] = _value;
    endfunction
    task automatic do_dvc_activate_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi_size_e size,
        ref axi_burst_e burst,
        ref axi_lock_e lock,
        ref axi_cache_e cache,
        ref axi_prot_e prot,
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [3:0] burst_length,
        ref bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref axi_response_e resp[],
        ref bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        ref bit [7:0] resp_user,
        ref axi_rw_e read_or_write,
        ref int address_to_data_latency,
        ref int data_to_response_latency,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        ref int address_valid_delay,
        ref int data_valid_delay[],
        ref int write_response_valid_delay,
        ref int address_ready_delay,
        ref int data_ready_delay[],
        ref int write_response_ready_delay,
        ref bit write_data_with_address,
        input int _unit_id = 0
    );
        begin
            int _trans_id;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;
            int tmp_resp[];
            int tmp_read_or_write;
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );
            tmp_prot = int'( prot );
            begin
            tmp_resp = new [resp.size()];
            for (int _i_1= 0; _i_1 < ( resp.size() ); _i_1++)
            begin
            tmp_resp[_i_1] = int'( resp[_i_1] );
            
            end
            end/* 1 */ 
            tmp_read_or_write = int'( read_or_write );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int resp_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_valid_delay_DIMS0;
                automatic int data_ready_delay_DIMS0;
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_rw_transaction_addr = addr;
                temp_static_rw_transaction_id = id;
                data_words_DIMS0 = data_words.size();
                temp_static_rw_transaction_data_words = data_words;
                write_strobes_DIMS0 = write_strobes.size();
                temp_static_rw_transaction_write_strobes = write_strobes;
                resp_DIMS0 = resp.size();
                temp_static_rw_transaction_resp = tmp_resp;
                data_user_DIMS0 = data_user.size();
                temp_static_rw_transaction_data_user = data_user;
                write_data_beats_delay_DIMS0 = write_data_beats_delay.size();
                temp_static_rw_transaction_write_data_beats_delay = write_data_beats_delay;
                data_valid_delay_DIMS0 = data_valid_delay.size();
                temp_static_rw_transaction_data_valid_delay = data_valid_delay;
                data_ready_delay_DIMS0 = data_ready_delay.size();
                temp_static_rw_transaction_data_ready_delay = data_ready_delay;
                // Call function to provide sized params and ingoing unsized params sizes.
                // In addition gets back updated sizes of unsized params.
                axi_rw_transaction_ActivatesActivatingActivate_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, burst_length, data_words_DIMS0, write_strobes_DIMS0, resp_DIMS0, addr_user, data_user_DIMS0, resp_user, tmp_read_or_write, address_to_data_latency, data_to_response_latency, write_address_to_data_delay, write_data_to_address_delay, write_data_beats_delay_DIMS0, address_valid_delay, data_valid_delay_DIMS0, write_response_valid_delay, address_ready_delay, data_ready_delay_DIMS0, write_response_ready_delay, write_data_with_address, _unit_id); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_write_strobes.delete();
                end
                if (resp_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_resp = new [resp_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_resp.delete();
                end
                if (data_user_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_user = new [data_user_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_user.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_write_data_beats_delay.delete();
                end
                if (data_valid_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_valid_delay = new [data_valid_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_valid_delay.delete();
                end
                if (data_ready_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_ready_delay = new [data_ready_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_ready_delay.delete();
                end
                // Call function to get the sized params
                axi_rw_transaction_ActivatesActivatingActivate_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, burst_length, addr_user, resp_user, tmp_read_or_write, address_to_data_latency, data_to_response_latency, write_address_to_data_delay, write_data_to_address_delay, address_valid_delay, write_response_valid_delay, address_ready_delay, write_response_ready_delay, write_data_with_address, _unit_id); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_rw_transaction_addr;
                id = temp_static_rw_transaction_id;
                data_words = temp_static_rw_transaction_data_words;
                temp_static_rw_transaction_data_words.delete();
                write_strobes = temp_static_rw_transaction_write_strobes;
                temp_static_rw_transaction_write_strobes.delete();
                tmp_resp = temp_static_rw_transaction_resp;
                temp_static_rw_transaction_resp.delete();
                data_user = temp_static_rw_transaction_data_user;
                temp_static_rw_transaction_data_user.delete();
                write_data_beats_delay = temp_static_rw_transaction_write_data_beats_delay;
                temp_static_rw_transaction_write_data_beats_delay.delete();
                data_valid_delay = temp_static_rw_transaction_data_valid_delay;
                temp_static_rw_transaction_data_valid_delay.delete();
                data_ready_delay = temp_static_rw_transaction_data_ready_delay;
                temp_static_rw_transaction_data_ready_delay.delete();
            end // Block to create unsized data arrays
            size = axi_size_e'( tmp_size );
            burst = axi_burst_e'( tmp_burst );
            lock = axi_lock_e'( tmp_lock );
            cache = axi_cache_e'( tmp_cache );
            prot = axi_prot_e'( tmp_prot );
            begin
            resp = new [tmp_resp.size()];
            for (int _i_1= 0; _i_1 < ( tmp_resp.size() ); _i_1++)
            begin
            resp[_i_1] = axi_response_e'( tmp_resp[_i_1] );
            
            end
            end/* 1 */ 
            read_or_write = axi_rw_e'( tmp_read_or_write );
        end
    endtask

    task automatic do_dvc_get_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        ref bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref axi_response_e resp[],
        output bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output axi_rw_e read_or_write,
        output int address_to_data_latency,
        output int data_to_response_latency,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        output int address_valid_delay,
        ref int data_valid_delay[],
        output int write_response_valid_delay,
        output int address_ready_delay,
        ref int data_ready_delay[],
        output int write_response_ready_delay,
        output bit write_data_with_address,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;
            int tmp_resp[];
            int tmp_read_or_write;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int resp_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_valid_delay_DIMS0;
                automatic int data_ready_delay_DIMS0;
                // Call function to get unsized params sizes.
                axi_rw_transaction_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, write_strobes_DIMS0, resp_DIMS0, data_user_DIMS0, write_data_beats_delay_DIMS0, data_valid_delay_DIMS0, data_ready_delay_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_write_strobes.delete();
                end
                if (resp_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_resp = new [resp_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_resp.delete();
                end
                if (data_user_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_user = new [data_user_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_user.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_write_data_beats_delay.delete();
                end
                if (data_valid_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_valid_delay = new [data_valid_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_valid_delay.delete();
                end
                if (data_ready_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_ready_delay = new [data_ready_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_ready_delay.delete();
                end
                // Call function to get the sized params
                axi_rw_transaction_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, burst_length, addr_user, resp_user, tmp_read_or_write, address_to_data_latency, data_to_response_latency, write_address_to_data_delay, write_data_to_address_delay, address_valid_delay, write_response_valid_delay, address_ready_delay, write_response_ready_delay, write_data_with_address, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_rw_transaction_addr;
                id = temp_static_rw_transaction_id;
                data_words = temp_static_rw_transaction_data_words;
                temp_static_rw_transaction_data_words.delete();
                write_strobes = temp_static_rw_transaction_write_strobes;
                temp_static_rw_transaction_write_strobes.delete();
                tmp_resp = temp_static_rw_transaction_resp;
                temp_static_rw_transaction_resp.delete();
                data_user = temp_static_rw_transaction_data_user;
                temp_static_rw_transaction_data_user.delete();
                write_data_beats_delay = temp_static_rw_transaction_write_data_beats_delay;
                temp_static_rw_transaction_write_data_beats_delay.delete();
                data_valid_delay = temp_static_rw_transaction_data_valid_delay;
                temp_static_rw_transaction_data_valid_delay.delete();
                data_ready_delay = temp_static_rw_transaction_data_ready_delay;
                temp_static_rw_transaction_data_ready_delay.delete();
            end // Block to create unsized data arrays
            size = axi_size_e'( tmp_size );
            burst = axi_burst_e'( tmp_burst );
            lock = axi_lock_e'( tmp_lock );
            cache = axi_cache_e'( tmp_cache );
            prot = axi_prot_e'( tmp_prot );
            begin
            resp = new [tmp_resp.size()];
            for (int _i_1= 0; _i_1 < ( tmp_resp.size() ); _i_1++)
            begin
            resp[_i_1] = axi_response_e'( tmp_resp[_i_1] );
            
            end
            end/* 1 */ 
            read_or_write = axi_rw_e'( tmp_read_or_write );
        end
    endtask

    task automatic do_dvc_activate_AXI_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi_size_e size,
        ref axi_burst_e burst,
        ref axi_lock_e lock,
        ref axi_cache_e cache,
        ref axi_prot_e prot,
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        ref bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        ref int address_to_data_latency,
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int address_valid_delay,
        input int _unit_id = 0
    );
        begin
            int _trans_id;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;
            int tmp_resp[];
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );
            tmp_prot = int'( prot );
            begin
            tmp_resp = new [resp.size()];
            for (int _i_1= 0; _i_1 < ( resp.size() ); _i_1++)
            begin
            tmp_resp[_i_1] = int'( resp[_i_1] );
            
            end
            end/* 1 */ 

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int resp_DIMS0;
                automatic int data_user_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_AXI_read_addr = addr;
                temp_static_AXI_read_id = id;
                data_words_DIMS0 = data_words.size();
                temp_static_AXI_read_data_words = data_words;
                resp_DIMS0 = resp.size();
                temp_static_AXI_read_resp = tmp_resp;
                data_user_DIMS0 = data_user.size();
                temp_static_AXI_read_data_user = data_user;
                data_start_time_DIMS0 = data_start_time.size();
                temp_static_AXI_read_data_start_time = data_start_time;
                data_end_time_DIMS0 = data_end_time.size();
                temp_static_AXI_read_data_end_time = data_end_time;
                // Call function to provide sized params and ingoing unsized params sizes.
                // In addition gets back updated sizes of unsized params.
                axi_AXI_read_ActivatesActivatingActivate_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, burst_length, data_words_DIMS0, resp_DIMS0, addr_user, data_user_DIMS0, address_to_data_latency, addr_start_time, addr_end_time, data_start_time_DIMS0, data_end_time_DIMS0, address_valid_delay, _unit_id); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_AXI_read_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_AXI_read_data_words.delete();
                end
                if (resp_DIMS0 != 0)
                begin
                    temp_static_AXI_read_resp = new [resp_DIMS0];
                end
                else
                begin
                    temp_static_AXI_read_resp.delete();
                end
                if (data_user_DIMS0 != 0)
                begin
                    temp_static_AXI_read_data_user = new [data_user_DIMS0];
                end
                else
                begin
                    temp_static_AXI_read_data_user.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_AXI_read_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_AXI_read_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_AXI_read_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_AXI_read_data_end_time.delete();
                end
                // Call function to get the sized params
                axi_AXI_read_ActivatesActivatingActivate_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, burst_length, addr_user, address_to_data_latency, addr_start_time, addr_end_time, address_valid_delay, _unit_id); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_AXI_read_addr;
                id = temp_static_AXI_read_id;
                data_words = temp_static_AXI_read_data_words;
                temp_static_AXI_read_data_words.delete();
                tmp_resp = temp_static_AXI_read_resp;
                temp_static_AXI_read_resp.delete();
                data_user = temp_static_AXI_read_data_user;
                temp_static_AXI_read_data_user.delete();
                data_start_time = temp_static_AXI_read_data_start_time;
                temp_static_AXI_read_data_start_time.delete();
                data_end_time = temp_static_AXI_read_data_end_time;
                temp_static_AXI_read_data_end_time.delete();
            end // Block to create unsized data arrays
            size = axi_size_e'( tmp_size );
            burst = axi_burst_e'( tmp_burst );
            lock = axi_lock_e'( tmp_lock );
            cache = axi_cache_e'( tmp_cache );
            prot = axi_prot_e'( tmp_prot );
            begin
            resp = new [tmp_resp.size()];
            for (int _i_1= 0; _i_1 < ( tmp_resp.size() ); _i_1++)
            begin
            resp[_i_1] = axi_response_e'( tmp_resp[_i_1] );
            
            end
            end/* 1 */ 
        end
    endtask

    task automatic do_dvc_get_AXI_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        output bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        output int address_to_data_latency,
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output int address_valid_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;
            int tmp_resp[];

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int resp_DIMS0;
                automatic int data_user_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Call function to get unsized params sizes.
                axi_AXI_read_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, resp_DIMS0, data_user_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_AXI_read_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_AXI_read_data_words.delete();
                end
                if (resp_DIMS0 != 0)
                begin
                    temp_static_AXI_read_resp = new [resp_DIMS0];
                end
                else
                begin
                    temp_static_AXI_read_resp.delete();
                end
                if (data_user_DIMS0 != 0)
                begin
                    temp_static_AXI_read_data_user = new [data_user_DIMS0];
                end
                else
                begin
                    temp_static_AXI_read_data_user.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_AXI_read_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_AXI_read_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_AXI_read_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_AXI_read_data_end_time.delete();
                end
                // Call function to get the sized params
                axi_AXI_read_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, burst_length, addr_user, address_to_data_latency, addr_start_time, addr_end_time, address_valid_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_AXI_read_addr;
                id = temp_static_AXI_read_id;
                data_words = temp_static_AXI_read_data_words;
                temp_static_AXI_read_data_words.delete();
                tmp_resp = temp_static_AXI_read_resp;
                temp_static_AXI_read_resp.delete();
                data_user = temp_static_AXI_read_data_user;
                temp_static_AXI_read_data_user.delete();
                data_start_time = temp_static_AXI_read_data_start_time;
                temp_static_AXI_read_data_start_time.delete();
                data_end_time = temp_static_AXI_read_data_end_time;
                temp_static_AXI_read_data_end_time.delete();
            end // Block to create unsized data arrays
            size = axi_size_e'( tmp_size );
            burst = axi_burst_e'( tmp_burst );
            lock = axi_lock_e'( tmp_lock );
            cache = axi_cache_e'( tmp_cache );
            prot = axi_prot_e'( tmp_prot );
            begin
            resp = new [tmp_resp.size()];
            for (int _i_1= 0; _i_1 < ( tmp_resp.size() ); _i_1++)
            begin
            resp[_i_1] = axi_response_e'( tmp_resp[_i_1] );
            
            end
            end/* 1 */ 
        end
    endtask

    task automatic do_dvc_activate_AXI_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi_size_e size,
        ref axi_burst_e burst,
        ref axi_lock_e lock,
        ref axi_cache_e cache,
        ref axi_prot_e prot,
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [3:0] burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref axi_response_e resp,
        ref bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        ref bit [7:0] resp_user,
        ref int address_to_data_latency,
        ref int data_to_response_latency,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref longint wr_resp_start_time,
        ref longint wr_resp_end_time,
        ref int address_valid_delay,
        input int _unit_id = 0
    );
        begin
            int _trans_id;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;
            int tmp_resp;
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );
            tmp_prot = int'( prot );
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_AXI_write_addr = addr;
                temp_static_AXI_write_id = id;
                data_words_DIMS0 = data_words.size();
                temp_static_AXI_write_data_words = data_words;
                write_strobes_DIMS0 = write_strobes.size();
                temp_static_AXI_write_write_strobes = write_strobes;
                data_user_DIMS0 = data_user.size();
                temp_static_AXI_write_data_user = data_user;
                write_data_beats_delay_DIMS0 = write_data_beats_delay.size();
                temp_static_AXI_write_write_data_beats_delay = write_data_beats_delay;
                data_start_time_DIMS0 = data_start_time.size();
                temp_static_AXI_write_data_start_time = data_start_time;
                data_end_time_DIMS0 = data_end_time.size();
                temp_static_AXI_write_data_end_time = data_end_time;
                // Call function to provide sized params and ingoing unsized params sizes.
                // In addition gets back updated sizes of unsized params.
                axi_AXI_write_ActivatesActivatingActivate_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, burst_length, data_words_DIMS0, write_strobes_DIMS0, tmp_resp, addr_user, data_user_DIMS0, resp_user, address_to_data_latency, data_to_response_latency, write_address_to_data_delay, write_data_to_address_delay, write_data_beats_delay_DIMS0, addr_start_time, addr_end_time, data_start_time_DIMS0, data_end_time_DIMS0, wr_resp_start_time, wr_resp_end_time, address_valid_delay, _unit_id); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_AXI_write_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_AXI_write_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_write_strobes.delete();
                end
                if (data_user_DIMS0 != 0)
                begin
                    temp_static_AXI_write_data_user = new [data_user_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_data_user.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_AXI_write_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_write_data_beats_delay.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_AXI_write_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_AXI_write_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_data_end_time.delete();
                end
                // Call function to get the sized params
                axi_AXI_write_ActivatesActivatingActivate_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, burst_length, tmp_resp, addr_user, resp_user, address_to_data_latency, data_to_response_latency, write_address_to_data_delay, write_data_to_address_delay, addr_start_time, addr_end_time, wr_resp_start_time, wr_resp_end_time, address_valid_delay, _unit_id); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_AXI_write_addr;
                id = temp_static_AXI_write_id;
                data_words = temp_static_AXI_write_data_words;
                temp_static_AXI_write_data_words.delete();
                write_strobes = temp_static_AXI_write_write_strobes;
                temp_static_AXI_write_write_strobes.delete();
                data_user = temp_static_AXI_write_data_user;
                temp_static_AXI_write_data_user.delete();
                write_data_beats_delay = temp_static_AXI_write_write_data_beats_delay;
                temp_static_AXI_write_write_data_beats_delay.delete();
                data_start_time = temp_static_AXI_write_data_start_time;
                temp_static_AXI_write_data_start_time.delete();
                data_end_time = temp_static_AXI_write_data_end_time;
                temp_static_AXI_write_data_end_time.delete();
            end // Block to create unsized data arrays
            size = axi_size_e'( tmp_size );
            burst = axi_burst_e'( tmp_burst );
            lock = axi_lock_e'( tmp_lock );
            cache = axi_cache_e'( tmp_cache );
            prot = axi_prot_e'( tmp_prot );
            resp = axi_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_get_AXI_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output axi_response_e resp,
        output bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output int address_to_data_latency,
        output int data_to_response_latency,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output longint wr_resp_start_time,
        output longint wr_resp_end_time,
        output int address_valid_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Call function to get unsized params sizes.
                axi_AXI_write_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, write_strobes_DIMS0, data_user_DIMS0, write_data_beats_delay_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_AXI_write_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_AXI_write_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_write_strobes.delete();
                end
                if (data_user_DIMS0 != 0)
                begin
                    temp_static_AXI_write_data_user = new [data_user_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_data_user.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_AXI_write_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_write_data_beats_delay.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_AXI_write_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_AXI_write_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_data_end_time.delete();
                end
                // Call function to get the sized params
                axi_AXI_write_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, burst_length, tmp_resp, addr_user, resp_user, address_to_data_latency, data_to_response_latency, write_address_to_data_delay, write_data_to_address_delay, addr_start_time, addr_end_time, wr_resp_start_time, wr_resp_end_time, address_valid_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_AXI_write_addr;
                id = temp_static_AXI_write_id;
                data_words = temp_static_AXI_write_data_words;
                temp_static_AXI_write_data_words.delete();
                write_strobes = temp_static_AXI_write_write_strobes;
                temp_static_AXI_write_write_strobes.delete();
                data_user = temp_static_AXI_write_data_user;
                temp_static_AXI_write_data_user.delete();
                write_data_beats_delay = temp_static_AXI_write_write_data_beats_delay;
                temp_static_AXI_write_write_data_beats_delay.delete();
                data_start_time = temp_static_AXI_write_data_start_time;
                temp_static_AXI_write_data_start_time.delete();
                data_end_time = temp_static_AXI_write_data_end_time;
                temp_static_AXI_write_data_end_time.delete();
            end // Block to create unsized data arrays
            size = axi_size_e'( tmp_size );
            burst = axi_burst_e'( tmp_burst );
            lock = axi_lock_e'( tmp_lock );
            cache = axi_cache_e'( tmp_cache );
            prot = axi_prot_e'( tmp_prot );
            resp = axi_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_activate_data_resp
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref axi_response_e resp,
        ref bit [7:0] data_user [],
        ref bit [7:0] resp_user,
        ref longint data_start,
        ref longint data_end,
        ref longint response_start,
        ref int write_data_beats_delay[],
        ref longint data_beat_start_time[],
        ref longint data_beat_end_time[],
        ref longint response_end_time,
        input int _unit_id = 0
    );
        begin
            int _trans_id;
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_beat_start_time_DIMS0;
                automatic int data_beat_end_time_DIMS0;
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                data_words_DIMS0 = data_words.size();
                temp_static_data_resp_data_words = data_words;
                write_strobes_DIMS0 = write_strobes.size();
                temp_static_data_resp_write_strobes = write_strobes;
                temp_static_data_resp_id = id;
                data_user_DIMS0 = data_user.size();
                temp_static_data_resp_data_user = data_user;
                write_data_beats_delay_DIMS0 = write_data_beats_delay.size();
                temp_static_data_resp_write_data_beats_delay = write_data_beats_delay;
                data_beat_start_time_DIMS0 = data_beat_start_time.size();
                temp_static_data_resp_data_beat_start_time = data_beat_start_time;
                data_beat_end_time_DIMS0 = data_beat_end_time.size();
                temp_static_data_resp_data_beat_end_time = data_beat_end_time;
                // Call function to provide sized params and ingoing unsized params sizes.
                // In addition gets back updated sizes of unsized params.
                axi_data_resp_ActivatesActivatingActivate_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, data_words_DIMS0, write_strobes_DIMS0, tmp_resp, data_user_DIMS0, resp_user, data_start, data_end, response_start, write_data_beats_delay_DIMS0, data_beat_start_time_DIMS0, data_beat_end_time_DIMS0, response_end_time, _unit_id); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_data_resp_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_data_resp_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_write_strobes.delete();
                end
                if (data_user_DIMS0 != 0)
                begin
                    temp_static_data_resp_data_user = new [data_user_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_data_user.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_data_resp_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_write_data_beats_delay.delete();
                end
                if (data_beat_start_time_DIMS0 != 0)
                begin
                    temp_static_data_resp_data_beat_start_time = new [data_beat_start_time_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_data_beat_start_time.delete();
                end
                if (data_beat_end_time_DIMS0 != 0)
                begin
                    temp_static_data_resp_data_beat_end_time = new [data_beat_end_time_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_data_beat_end_time.delete();
                end
                // Call function to get the sized params
                axi_data_resp_ActivatesActivatingActivate_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, tmp_resp, resp_user, data_start, data_end, response_start, response_end_time, _unit_id); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data_words = temp_static_data_resp_data_words;
                temp_static_data_resp_data_words.delete();
                write_strobes = temp_static_data_resp_write_strobes;
                temp_static_data_resp_write_strobes.delete();
                id = temp_static_data_resp_id;
                data_user = temp_static_data_resp_data_user;
                temp_static_data_resp_data_user.delete();
                write_data_beats_delay = temp_static_data_resp_write_data_beats_delay;
                temp_static_data_resp_write_data_beats_delay.delete();
                data_beat_start_time = temp_static_data_resp_data_beat_start_time;
                temp_static_data_resp_data_beat_start_time.delete();
                data_beat_end_time = temp_static_data_resp_data_beat_end_time;
                temp_static_data_resp_data_beat_end_time.delete();
            end // Block to create unsized data arrays
            resp = axi_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_get_data_resp
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output axi_response_e resp,
        ref bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output longint data_start,
        output longint data_end,
        output longint response_start,
        ref int write_data_beats_delay[],
        ref longint data_beat_start_time[],
        ref longint data_beat_end_time[],
        output longint response_end_time,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_beat_start_time_DIMS0;
                automatic int data_beat_end_time_DIMS0;
                // Call function to get unsized params sizes.
                axi_data_resp_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, write_strobes_DIMS0, data_user_DIMS0, write_data_beats_delay_DIMS0, data_beat_start_time_DIMS0, data_beat_end_time_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_data_resp_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_data_resp_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_write_strobes.delete();
                end
                if (data_user_DIMS0 != 0)
                begin
                    temp_static_data_resp_data_user = new [data_user_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_data_user.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_data_resp_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_write_data_beats_delay.delete();
                end
                if (data_beat_start_time_DIMS0 != 0)
                begin
                    temp_static_data_resp_data_beat_start_time = new [data_beat_start_time_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_data_beat_start_time.delete();
                end
                if (data_beat_end_time_DIMS0 != 0)
                begin
                    temp_static_data_resp_data_beat_end_time = new [data_beat_end_time_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_data_beat_end_time.delete();
                end
                // Call function to get the sized params
                axi_data_resp_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, tmp_resp, resp_user, data_start, data_end, response_start, response_end_time, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data_words = temp_static_data_resp_data_words;
                temp_static_data_resp_data_words.delete();
                write_strobes = temp_static_data_resp_write_strobes;
                temp_static_data_resp_write_strobes.delete();
                id = temp_static_data_resp_id;
                data_user = temp_static_data_resp_data_user;
                temp_static_data_resp_data_user.delete();
                write_data_beats_delay = temp_static_data_resp_write_data_beats_delay;
                temp_static_data_resp_write_data_beats_delay.delete();
                data_beat_start_time = temp_static_data_resp_data_beat_start_time;
                temp_static_data_resp_data_beat_start_time.delete();
                data_beat_end_time = temp_static_data_resp_data_beat_end_time;
                temp_static_data_resp_data_beat_end_time.delete();
            end // Block to create unsized data arrays
            resp = axi_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0
    );
        begin
            int tmp_resp[];
            begin
            tmp_resp = new [resp.size()];
            for (int _i_1= 0; _i_1 < ( resp.size() ); _i_1++)
            begin
            tmp_resp[_i_1] = int'( resp[_i_1] );
            
            end
            end/* 1 */ 

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int resp_DIMS0;
                automatic int data_user_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                data_words_DIMS0 = data_words.size();
                temp_static_read_data_burst_data_words = data_words;
                resp_DIMS0 = resp.size();
                temp_static_read_data_burst_resp = tmp_resp;
                temp_static_read_data_burst_id = id;
                data_user_DIMS0 = data_user.size();
                temp_static_read_data_burst_data_user = data_user;
                data_start_time_DIMS0 = data_start_time.size();
                temp_static_read_data_burst_data_start_time = data_start_time;
                data_end_time_DIMS0 = data_end_time.size();
                temp_static_read_data_burst_data_end_time = data_end_time;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_read_data_burst_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, burst_length, data_words_DIMS0, resp_DIMS0, data_user_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
                temp_static_read_data_burst_data_words.delete();
                temp_static_read_data_burst_resp.delete();
                temp_static_read_data_burst_data_user.delete();
                temp_static_read_data_burst_data_start_time.delete();
                temp_static_read_data_burst_data_end_time.delete();
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp[];

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int resp_DIMS0;
                automatic int data_user_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Call function to get unsized params sizes.
                axi_read_data_burst_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, resp_DIMS0, data_user_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_read_data_burst_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_read_data_burst_data_words.delete();
                end
                if (resp_DIMS0 != 0)
                begin
                    temp_static_read_data_burst_resp = new [resp_DIMS0];
                end
                else
                begin
                    temp_static_read_data_burst_resp.delete();
                end
                if (data_user_DIMS0 != 0)
                begin
                    temp_static_read_data_burst_data_user = new [data_user_DIMS0];
                end
                else
                begin
                    temp_static_read_data_burst_data_user.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_read_data_burst_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_read_data_burst_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_read_data_burst_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_read_data_burst_data_end_time.delete();
                end
                // Call function to get the sized params
                axi_read_data_burst_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data_words = temp_static_read_data_burst_data_words;
                temp_static_read_data_burst_data_words.delete();
                tmp_resp = temp_static_read_data_burst_resp;
                temp_static_read_data_burst_resp.delete();
                id = temp_static_read_data_burst_id;
                data_user = temp_static_read_data_burst_data_user;
                temp_static_read_data_burst_data_user.delete();
                data_start_time = temp_static_read_data_burst_data_start_time;
                temp_static_read_data_burst_data_start_time.delete();
                data_end_time = temp_static_read_data_burst_data_end_time;
                temp_static_read_data_burst_data_end_time.delete();
            end // Block to create unsized data arrays
            begin
            resp = new [tmp_resp.size()];
            for (int _i_1= 0; _i_1 < ( tmp_resp.size() ); _i_1++)
            begin
            resp[_i_1] = axi_response_e'( tmp_resp[_i_1] );
            
            end
            end/* 1 */ 
        end
    endtask

    task automatic do_dvc_put_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref int write_data_beats_delay[],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                data_words_DIMS0 = data_words.size();
                temp_static_write_data_burst_data_words = data_words;
                write_strobes_DIMS0 = write_strobes.size();
                temp_static_write_data_burst_write_strobes = write_strobes;
                temp_static_write_data_burst_id = id;
                data_user_DIMS0 = data_user.size();
                temp_static_write_data_burst_data_user = data_user;
                write_data_beats_delay_DIMS0 = write_data_beats_delay.size();
                temp_static_write_data_burst_write_data_beats_delay = write_data_beats_delay;
                data_start_time_DIMS0 = data_start_time.size();
                temp_static_write_data_burst_data_start_time = data_start_time;
                data_end_time_DIMS0 = data_end_time.size();
                temp_static_write_data_burst_data_end_time = data_end_time;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_write_data_burst_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, burst_length, data_words_DIMS0, write_strobes_DIMS0, data_user_DIMS0, write_data_beats_delay_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
                temp_static_write_data_burst_data_words.delete();
                temp_static_write_data_burst_write_strobes.delete();
                temp_static_write_data_burst_data_user.delete();
                temp_static_write_data_burst_write_data_beats_delay.delete();
                temp_static_write_data_burst_data_start_time.delete();
                temp_static_write_data_burst_data_end_time.delete();
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref int write_data_beats_delay[],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Call function to get unsized params sizes.
                axi_write_data_burst_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, write_strobes_DIMS0, data_user_DIMS0, write_data_beats_delay_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_write_strobes.delete();
                end
                if (data_user_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_data_user = new [data_user_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_data_user.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_write_data_beats_delay.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_data_end_time.delete();
                end
                // Call function to get the sized params
                axi_write_data_burst_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data_words = temp_static_write_data_burst_data_words;
                temp_static_write_data_burst_data_words.delete();
                write_strobes = temp_static_write_data_burst_write_strobes;
                temp_static_write_data_burst_write_strobes.delete();
                id = temp_static_write_data_burst_id;
                data_user = temp_static_write_data_burst_data_user;
                temp_static_write_data_burst_data_user.delete();
                write_data_beats_delay = temp_static_write_data_burst_write_data_beats_delay;
                temp_static_write_data_burst_write_data_beats_delay.delete();
                data_start_time = temp_static_write_data_burst_data_start_time;
                temp_static_write_data_burst_data_start_time.delete();
                data_end_time = temp_static_write_data_burst_data_end_time;
                temp_static_write_data_burst_data_end_time.delete();
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_put_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
        begin
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );
            tmp_prot = int'( prot );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_read_addr_channel_phase_addr = addr;
                temp_static_read_addr_channel_phase_id = id;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_read_addr_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, addr_user, address_valid_delay, address_ready_delay, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi_read_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi_read_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, addr_user, address_valid_delay, address_ready_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_read_addr_channel_phase_addr;
                id = temp_static_read_addr_channel_phase_id;
            end // Block to create unsized data arrays
            size = axi_size_e'( tmp_size );
            burst = axi_burst_e'( tmp_burst );
            lock = axi_lock_e'( tmp_lock );
            cache = axi_cache_e'( tmp_cache );
            prot = axi_prot_e'( tmp_prot );
        end
    endtask

    task automatic do_dvc_put_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int data_ready_delay,
        input int _unit_id = 0
    );
        begin
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_read_channel_phase_data = data;
                temp_static_read_channel_phase_id = id;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_read_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, last, tmp_resp, data_user, data_ready_delay, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi_read_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi_read_channel_phase_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, last, tmp_resp, data_user, data_ready_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data = temp_static_read_channel_phase_data;
                id = temp_static_read_channel_phase_id;
            end // Block to create unsized data arrays
            resp = axi_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
        begin
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );
            tmp_prot = int'( prot );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_addr_channel_phase_addr = addr;
                temp_static_write_addr_channel_phase_id = id;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_write_addr_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, addr_user, address_valid_delay, address_ready_delay, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi_write_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi_write_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, addr_user, address_valid_delay, address_ready_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_write_addr_channel_phase_addr;
                id = temp_static_write_addr_channel_phase_id;
            end // Block to create unsized data arrays
            size = axi_size_e'( tmp_size );
            burst = axi_burst_e'( tmp_burst );
            lock = axi_lock_e'( tmp_lock );
            cache = axi_cache_e'( tmp_cache );
            prot = axi_prot_e'( tmp_prot );
        end
    endtask

    task automatic do_dvc_put_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int data_ready_delay,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_channel_phase_data = data;
                temp_static_write_channel_phase_write_strobes = write_strobes;
                temp_static_write_channel_phase_id = id;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_write_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, last, data_user, data_ready_delay, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi_write_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi_write_channel_phase_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, last, data_user, data_ready_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data = temp_static_write_channel_phase_data;
                write_strobes = temp_static_write_channel_phase_write_strobes;
                id = temp_static_write_channel_phase_id;
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_put_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] resp_user,
        input int write_response_ready_delay,
        input int _unit_id = 0
    );
        begin
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_resp_channel_phase_id = id;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_write_resp_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, tmp_resp, resp_user, write_response_ready_delay, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] resp_user,
        output int write_response_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi_write_resp_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi_write_resp_channel_phase_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_resp, resp_user, write_response_ready_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                id = temp_static_write_resp_channel_phase_id;
            end // Block to create unsized data arrays
            resp = axi_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int _unit_id = 0
    );
        begin
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );
            tmp_prot = int'( prot );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_read_addr_channel_cycle_addr = addr;
                temp_static_read_addr_channel_cycle_id = id;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_read_addr_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, addr_user, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi_read_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi_read_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, addr_user, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_read_addr_channel_cycle_addr;
                id = temp_static_read_addr_channel_cycle_id;
            end // Block to create unsized data arrays
            size = axi_size_e'( tmp_size );
            burst = axi_burst_e'( tmp_burst );
            lock = axi_lock_e'( tmp_lock );
            cache = axi_cache_e'( tmp_cache );
            prot = axi_prot_e'( tmp_prot );
        end
    endtask

    task automatic do_dvc_put_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_read_addr_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_read_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_put_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int _unit_id = 0
    );
        begin
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_read_channel_cycle_data = data;
                temp_static_read_channel_cycle_id = id;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_read_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, last, tmp_resp, data_user, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi_read_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi_read_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, last, tmp_resp, data_user, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data = temp_static_read_channel_cycle_data;
                id = temp_static_read_channel_cycle_id;
            end // Block to create unsized data arrays
            resp = axi_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_read_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_read_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_put_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int _unit_id = 0
    );
        begin
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );
            tmp_prot = int'( prot );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_addr_channel_cycle_addr = addr;
                temp_static_write_addr_channel_cycle_id = id;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_write_addr_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, addr_user, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi_write_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi_write_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, addr_user, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_write_addr_channel_cycle_addr;
                id = temp_static_write_addr_channel_cycle_id;
            end // Block to create unsized data arrays
            size = axi_size_e'( tmp_size );
            burst = axi_burst_e'( tmp_burst );
            lock = axi_lock_e'( tmp_lock );
            cache = axi_cache_e'( tmp_cache );
            prot = axi_prot_e'( tmp_prot );
        end
    endtask

    task automatic do_dvc_put_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_addr_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_put_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  strb,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_channel_cycle_data = data;
                temp_static_write_channel_cycle_strb = strb;
                temp_static_write_channel_cycle_id = id;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_write_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, last, data_user, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  strb,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi_write_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi_write_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, last, data_user, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data = temp_static_write_channel_cycle_data;
                strb = temp_static_write_channel_cycle_strb;
                id = temp_static_write_channel_cycle_id;
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_put_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_put_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] resp_user,
        input int _unit_id = 0
    );
        begin
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_resp_channel_cycle_id = id;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_write_resp_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, tmp_resp, resp_user, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] resp_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi_write_resp_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi_write_resp_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_resp, resp_user, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                id = temp_static_write_resp_channel_cycle_id;
            end // Block to create unsized data arrays
            resp = axi_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_resp_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_resp_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    //-------------------------------------------------------------------------------------
    // Task which blocks and outputs an error if the interface has not initialized properly
    //-------------------------------------------------------------------------------------

    task _initialized();
        if (_interface_ref == 0)
        begin
            $display("Error: %m - Questa Verification IP failed to initialise. Please check questa_mvc.log for details");
            wait(_interface_ref!=0);
        end
    endtask

    //-------------------------------------------------------------------------------------
    // Function to get interface handle (internal use only)
    //-------------------------------------------------------------------------------------

    function longint _get_interface_handle();
        _get_interface_handle = axi_get_interface_handle();
    endfunction

//------------------------------------------------------------------------------
//
// Class which implements interface defined by axi_interface_class
//
//------------------------------------------------------------------------------
class axi_implementation_class #(int AXI_ADDRESS_WIDTH = 64, int AXI_RDATA_WIDTH = 1024, int AXI_WDATA_WIDTH = 1024, int AXI_ID_WIDTH = 18)
    extends axi_interface_class #(AXI_ADDRESS_WIDTH, AXI_RDATA_WIDTH, AXI_WDATA_WIDTH, AXI_ID_WIDTH);

    //------------------------------------------------------------------------------
    // Tasks to wait for a number of specified edges on a wire
    //------------------------------------------------------------------------------
    task automatic wait_for_ACLK( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ACLK( which_edge, count );
    endtask

    task automatic wait_for_ARESETn( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARESETn( which_edge, count );
    endtask

    task automatic wait_for_AWVALID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWVALID( which_edge, count );
    endtask

    task automatic wait_for_AWADDR( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWADDR( which_edge, count );
    endtask

    task automatic wait_for_AWADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWADDR_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWLEN( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWLEN( which_edge, count );
    endtask

    task automatic wait_for_AWLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWLEN_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWSIZE( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWSIZE( which_edge, count );
    endtask

    task automatic wait_for_AWSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWSIZE_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWBURST( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWBURST( which_edge, count );
    endtask

    task automatic wait_for_AWBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWBURST_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWLOCK( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWLOCK( which_edge, count );
    endtask

    task automatic wait_for_AWLOCK_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWLOCK_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWCACHE( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWCACHE( which_edge, count );
    endtask

    task automatic wait_for_AWCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWCACHE_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWPROT( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWPROT( which_edge, count );
    endtask

    task automatic wait_for_AWPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWPROT_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWID( which_edge, count );
    endtask

    task automatic wait_for_AWID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWID_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWREADY( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWREADY( which_edge, count );
    endtask

    task automatic wait_for_AWUSER( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWUSER( which_edge, count );
    endtask

    task automatic wait_for_AWUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWUSER_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARVALID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARVALID( which_edge, count );
    endtask

    task automatic wait_for_ARADDR( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARADDR( which_edge, count );
    endtask

    task automatic wait_for_ARADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARADDR_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARLEN( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARLEN( which_edge, count );
    endtask

    task automatic wait_for_ARLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARLEN_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARSIZE( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARSIZE( which_edge, count );
    endtask

    task automatic wait_for_ARSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARSIZE_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARBURST( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARBURST( which_edge, count );
    endtask

    task automatic wait_for_ARBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARBURST_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARLOCK( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARLOCK( which_edge, count );
    endtask

    task automatic wait_for_ARLOCK_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARLOCK_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARCACHE( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARCACHE( which_edge, count );
    endtask

    task automatic wait_for_ARCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARCACHE_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARPROT( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARPROT( which_edge, count );
    endtask

    task automatic wait_for_ARPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARPROT_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARID( which_edge, count );
    endtask

    task automatic wait_for_ARID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARID_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARREADY( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARREADY( which_edge, count );
    endtask

    task automatic wait_for_ARUSER( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARUSER( which_edge, count );
    endtask

    task automatic wait_for_ARUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARUSER_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_RVALID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RVALID( which_edge, count );
    endtask

    task automatic wait_for_RLAST( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RLAST( which_edge, count );
    endtask

    task automatic wait_for_RDATA( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RDATA( which_edge, count );
    endtask

    task automatic wait_for_RDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RDATA_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_RRESP( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RRESP( which_edge, count );
    endtask

    task automatic wait_for_RRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RRESP_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_RID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RID( which_edge, count );
    endtask

    task automatic wait_for_RID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RID_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_RREADY( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RREADY( which_edge, count );
    endtask

    task automatic wait_for_RUSER( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RUSER( which_edge, count );
    endtask

    task automatic wait_for_RUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RUSER_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_WVALID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WVALID( which_edge, count );
    endtask

    task automatic wait_for_WLAST( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WLAST( which_edge, count );
    endtask

    task automatic wait_for_WDATA( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WDATA( which_edge, count );
    endtask

    task automatic wait_for_WDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WDATA_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_WSTRB( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WSTRB( which_edge, count );
    endtask

    task automatic wait_for_WSTRB_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WSTRB_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_WID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WID( which_edge, count );
    endtask

    task automatic wait_for_WID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WID_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_WREADY( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WREADY( which_edge, count );
    endtask

    task automatic wait_for_WUSER( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WUSER( which_edge, count );
    endtask

    task automatic wait_for_WUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WUSER_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_BVALID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BVALID( which_edge, count );
    endtask

    task automatic wait_for_BRESP( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BRESP( which_edge, count );
    endtask

    task automatic wait_for_BRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BRESP_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_BID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BID( which_edge, count );
    endtask

    task automatic wait_for_BID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BID_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_BREADY( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BREADY( which_edge, count );
    endtask

    task automatic wait_for_BUSER( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BUSER( which_edge, count );
    endtask

    task automatic wait_for_BUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BUSER_index1( _this_dot_1, which_edge, count );
    endtask


    //------------------------------------------------------------------------------
    // Tasks/functions to set/get wires
    //------------------------------------------------------------------------------
    task automatic set_ACLK( logic ACLK_param = 'z, bit non_blocking = 1'b0 );
        do_set_ACLK( ACLK_param, non_blocking );
    endtask

    function automatic logic get_ACLK(  );
        return do_get_ACLK(  );
    endfunction


    task automatic set_ARESETn( logic ARESETn_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARESETn( ARESETn_param, non_blocking );
    endtask

    function automatic logic get_ARESETn(  );
        return do_get_ARESETn(  );
    endfunction


    task automatic set_AWVALID( logic AWVALID_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWVALID( AWVALID_param, non_blocking );
    endtask

    function automatic logic get_AWVALID(  );
        return do_get_AWVALID(  );
    endfunction


    task automatic set_AWADDR( logic [((AXI_ADDRESS_WIDTH) - 1):0]  AWADDR_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWADDR( AWADDR_param, non_blocking );
    endtask

    task automatic set_AWADDR_index1( int _this_dot_1, logic  AWADDR_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWADDR_index1( _this_dot_1, AWADDR_param, non_blocking );
    endtask

    function automatic logic [((AXI_ADDRESS_WIDTH) - 1):0]   get_AWADDR(  );
        return do_get_AWADDR(  );
    endfunction

    function automatic logic   get_AWADDR_index1( int _this_dot_1 );
        return do_get_AWADDR_index1( _this_dot_1 );
    endfunction


    task automatic set_AWLEN( logic [3:0] AWLEN_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWLEN( AWLEN_param, non_blocking );
    endtask

    task automatic set_AWLEN_index1( int _this_dot_1, logic  AWLEN_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWLEN_index1( _this_dot_1, AWLEN_param, non_blocking );
    endtask

    function automatic logic [3:0]  get_AWLEN(  );
        return do_get_AWLEN(  );
    endfunction

    function automatic logic   get_AWLEN_index1( int _this_dot_1 );
        return do_get_AWLEN_index1( _this_dot_1 );
    endfunction


    task automatic set_AWSIZE( logic [2:0] AWSIZE_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWSIZE( AWSIZE_param, non_blocking );
    endtask

    task automatic set_AWSIZE_index1( int _this_dot_1, logic  AWSIZE_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWSIZE_index1( _this_dot_1, AWSIZE_param, non_blocking );
    endtask

    function automatic logic [2:0]  get_AWSIZE(  );
        return do_get_AWSIZE(  );
    endfunction

    function automatic logic   get_AWSIZE_index1( int _this_dot_1 );
        return do_get_AWSIZE_index1( _this_dot_1 );
    endfunction


    task automatic set_AWBURST( logic [1:0] AWBURST_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWBURST( AWBURST_param, non_blocking );
    endtask

    task automatic set_AWBURST_index1( int _this_dot_1, logic  AWBURST_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWBURST_index1( _this_dot_1, AWBURST_param, non_blocking );
    endtask

    function automatic logic [1:0]  get_AWBURST(  );
        return do_get_AWBURST(  );
    endfunction

    function automatic logic   get_AWBURST_index1( int _this_dot_1 );
        return do_get_AWBURST_index1( _this_dot_1 );
    endfunction


    task automatic set_AWLOCK( logic [1:0] AWLOCK_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWLOCK( AWLOCK_param, non_blocking );
    endtask

    task automatic set_AWLOCK_index1( int _this_dot_1, logic  AWLOCK_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWLOCK_index1( _this_dot_1, AWLOCK_param, non_blocking );
    endtask

    function automatic logic [1:0]  get_AWLOCK(  );
        return do_get_AWLOCK(  );
    endfunction

    function automatic logic   get_AWLOCK_index1( int _this_dot_1 );
        return do_get_AWLOCK_index1( _this_dot_1 );
    endfunction


    task automatic set_AWCACHE( logic [3:0] AWCACHE_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWCACHE( AWCACHE_param, non_blocking );
    endtask

    task automatic set_AWCACHE_index1( int _this_dot_1, logic  AWCACHE_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWCACHE_index1( _this_dot_1, AWCACHE_param, non_blocking );
    endtask

    function automatic logic [3:0]  get_AWCACHE(  );
        return do_get_AWCACHE(  );
    endfunction

    function automatic logic   get_AWCACHE_index1( int _this_dot_1 );
        return do_get_AWCACHE_index1( _this_dot_1 );
    endfunction


    task automatic set_AWPROT( logic [2:0] AWPROT_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWPROT( AWPROT_param, non_blocking );
    endtask

    task automatic set_AWPROT_index1( int _this_dot_1, logic  AWPROT_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWPROT_index1( _this_dot_1, AWPROT_param, non_blocking );
    endtask

    function automatic logic [2:0]  get_AWPROT(  );
        return do_get_AWPROT(  );
    endfunction

    function automatic logic   get_AWPROT_index1( int _this_dot_1 );
        return do_get_AWPROT_index1( _this_dot_1 );
    endfunction


    task automatic set_AWID( logic [((AXI_ID_WIDTH) - 1):0]  AWID_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWID( AWID_param, non_blocking );
    endtask

    task automatic set_AWID_index1( int _this_dot_1, logic  AWID_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWID_index1( _this_dot_1, AWID_param, non_blocking );
    endtask

    function automatic logic [((AXI_ID_WIDTH) - 1):0]   get_AWID(  );
        return do_get_AWID(  );
    endfunction

    function automatic logic   get_AWID_index1( int _this_dot_1 );
        return do_get_AWID_index1( _this_dot_1 );
    endfunction


    task automatic set_AWREADY( logic AWREADY_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWREADY( AWREADY_param, non_blocking );
    endtask

    function automatic logic get_AWREADY(  );
        return do_get_AWREADY(  );
    endfunction


    task automatic set_AWUSER( logic [7:0] AWUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWUSER( AWUSER_param, non_blocking );
    endtask

    task automatic set_AWUSER_index1( int _this_dot_1, logic  AWUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWUSER_index1( _this_dot_1, AWUSER_param, non_blocking );
    endtask

    function automatic logic [7:0]  get_AWUSER(  );
        return do_get_AWUSER(  );
    endfunction

    function automatic logic   get_AWUSER_index1( int _this_dot_1 );
        return do_get_AWUSER_index1( _this_dot_1 );
    endfunction


    task automatic set_ARVALID( logic ARVALID_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARVALID( ARVALID_param, non_blocking );
    endtask

    function automatic logic get_ARVALID(  );
        return do_get_ARVALID(  );
    endfunction


    task automatic set_ARADDR( logic [((AXI_ADDRESS_WIDTH) - 1):0]  ARADDR_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARADDR( ARADDR_param, non_blocking );
    endtask

    task automatic set_ARADDR_index1( int _this_dot_1, logic  ARADDR_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARADDR_index1( _this_dot_1, ARADDR_param, non_blocking );
    endtask

    function automatic logic [((AXI_ADDRESS_WIDTH) - 1):0]   get_ARADDR(  );
        return do_get_ARADDR(  );
    endfunction

    function automatic logic   get_ARADDR_index1( int _this_dot_1 );
        return do_get_ARADDR_index1( _this_dot_1 );
    endfunction


    task automatic set_ARLEN( logic [3:0] ARLEN_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARLEN( ARLEN_param, non_blocking );
    endtask

    task automatic set_ARLEN_index1( int _this_dot_1, logic  ARLEN_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARLEN_index1( _this_dot_1, ARLEN_param, non_blocking );
    endtask

    function automatic logic [3:0]  get_ARLEN(  );
        return do_get_ARLEN(  );
    endfunction

    function automatic logic   get_ARLEN_index1( int _this_dot_1 );
        return do_get_ARLEN_index1( _this_dot_1 );
    endfunction


    task automatic set_ARSIZE( logic [2:0] ARSIZE_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARSIZE( ARSIZE_param, non_blocking );
    endtask

    task automatic set_ARSIZE_index1( int _this_dot_1, logic  ARSIZE_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARSIZE_index1( _this_dot_1, ARSIZE_param, non_blocking );
    endtask

    function automatic logic [2:0]  get_ARSIZE(  );
        return do_get_ARSIZE(  );
    endfunction

    function automatic logic   get_ARSIZE_index1( int _this_dot_1 );
        return do_get_ARSIZE_index1( _this_dot_1 );
    endfunction


    task automatic set_ARBURST( logic [1:0] ARBURST_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARBURST( ARBURST_param, non_blocking );
    endtask

    task automatic set_ARBURST_index1( int _this_dot_1, logic  ARBURST_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARBURST_index1( _this_dot_1, ARBURST_param, non_blocking );
    endtask

    function automatic logic [1:0]  get_ARBURST(  );
        return do_get_ARBURST(  );
    endfunction

    function automatic logic   get_ARBURST_index1( int _this_dot_1 );
        return do_get_ARBURST_index1( _this_dot_1 );
    endfunction


    task automatic set_ARLOCK( logic [1:0] ARLOCK_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARLOCK( ARLOCK_param, non_blocking );
    endtask

    task automatic set_ARLOCK_index1( int _this_dot_1, logic  ARLOCK_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARLOCK_index1( _this_dot_1, ARLOCK_param, non_blocking );
    endtask

    function automatic logic [1:0]  get_ARLOCK(  );
        return do_get_ARLOCK(  );
    endfunction

    function automatic logic   get_ARLOCK_index1( int _this_dot_1 );
        return do_get_ARLOCK_index1( _this_dot_1 );
    endfunction


    task automatic set_ARCACHE( logic [3:0] ARCACHE_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARCACHE( ARCACHE_param, non_blocking );
    endtask

    task automatic set_ARCACHE_index1( int _this_dot_1, logic  ARCACHE_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARCACHE_index1( _this_dot_1, ARCACHE_param, non_blocking );
    endtask

    function automatic logic [3:0]  get_ARCACHE(  );
        return do_get_ARCACHE(  );
    endfunction

    function automatic logic   get_ARCACHE_index1( int _this_dot_1 );
        return do_get_ARCACHE_index1( _this_dot_1 );
    endfunction


    task automatic set_ARPROT( logic [2:0] ARPROT_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARPROT( ARPROT_param, non_blocking );
    endtask

    task automatic set_ARPROT_index1( int _this_dot_1, logic  ARPROT_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARPROT_index1( _this_dot_1, ARPROT_param, non_blocking );
    endtask

    function automatic logic [2:0]  get_ARPROT(  );
        return do_get_ARPROT(  );
    endfunction

    function automatic logic   get_ARPROT_index1( int _this_dot_1 );
        return do_get_ARPROT_index1( _this_dot_1 );
    endfunction


    task automatic set_ARID( logic [((AXI_ID_WIDTH) - 1):0]  ARID_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARID( ARID_param, non_blocking );
    endtask

    task automatic set_ARID_index1( int _this_dot_1, logic  ARID_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARID_index1( _this_dot_1, ARID_param, non_blocking );
    endtask

    function automatic logic [((AXI_ID_WIDTH) - 1):0]   get_ARID(  );
        return do_get_ARID(  );
    endfunction

    function automatic logic   get_ARID_index1( int _this_dot_1 );
        return do_get_ARID_index1( _this_dot_1 );
    endfunction


    task automatic set_ARREADY( logic ARREADY_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARREADY( ARREADY_param, non_blocking );
    endtask

    function automatic logic get_ARREADY(  );
        return do_get_ARREADY(  );
    endfunction


    task automatic set_ARUSER( logic [7:0] ARUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARUSER( ARUSER_param, non_blocking );
    endtask

    task automatic set_ARUSER_index1( int _this_dot_1, logic  ARUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARUSER_index1( _this_dot_1, ARUSER_param, non_blocking );
    endtask

    function automatic logic [7:0]  get_ARUSER(  );
        return do_get_ARUSER(  );
    endfunction

    function automatic logic   get_ARUSER_index1( int _this_dot_1 );
        return do_get_ARUSER_index1( _this_dot_1 );
    endfunction


    task automatic set_RVALID( logic RVALID_param = 'z, bit non_blocking = 1'b0 );
        do_set_RVALID( RVALID_param, non_blocking );
    endtask

    function automatic logic get_RVALID(  );
        return do_get_RVALID(  );
    endfunction


    task automatic set_RLAST( logic RLAST_param = 'z, bit non_blocking = 1'b0 );
        do_set_RLAST( RLAST_param, non_blocking );
    endtask

    function automatic logic get_RLAST(  );
        return do_get_RLAST(  );
    endfunction


    task automatic set_RDATA( logic [((AXI_RDATA_WIDTH) - 1):0]  RDATA_param = 'z, bit non_blocking = 1'b0 );
        do_set_RDATA( RDATA_param, non_blocking );
    endtask

    task automatic set_RDATA_index1( int _this_dot_1, logic  RDATA_param = 'z, bit non_blocking = 1'b0 );
        do_set_RDATA_index1( _this_dot_1, RDATA_param, non_blocking );
    endtask

    function automatic logic [((AXI_RDATA_WIDTH) - 1):0]   get_RDATA(  );
        return do_get_RDATA(  );
    endfunction

    function automatic logic   get_RDATA_index1( int _this_dot_1 );
        return do_get_RDATA_index1( _this_dot_1 );
    endfunction


    task automatic set_RRESP( logic [1:0] RRESP_param = 'z, bit non_blocking = 1'b0 );
        do_set_RRESP( RRESP_param, non_blocking );
    endtask

    task automatic set_RRESP_index1( int _this_dot_1, logic  RRESP_param = 'z, bit non_blocking = 1'b0 );
        do_set_RRESP_index1( _this_dot_1, RRESP_param, non_blocking );
    endtask

    function automatic logic [1:0]  get_RRESP(  );
        return do_get_RRESP(  );
    endfunction

    function automatic logic   get_RRESP_index1( int _this_dot_1 );
        return do_get_RRESP_index1( _this_dot_1 );
    endfunction


    task automatic set_RID( logic [((AXI_ID_WIDTH) - 1):0]  RID_param = 'z, bit non_blocking = 1'b0 );
        do_set_RID( RID_param, non_blocking );
    endtask

    task automatic set_RID_index1( int _this_dot_1, logic  RID_param = 'z, bit non_blocking = 1'b0 );
        do_set_RID_index1( _this_dot_1, RID_param, non_blocking );
    endtask

    function automatic logic [((AXI_ID_WIDTH) - 1):0]   get_RID(  );
        return do_get_RID(  );
    endfunction

    function automatic logic   get_RID_index1( int _this_dot_1 );
        return do_get_RID_index1( _this_dot_1 );
    endfunction


    task automatic set_RREADY( logic RREADY_param = 'z, bit non_blocking = 1'b0 );
        do_set_RREADY( RREADY_param, non_blocking );
    endtask

    function automatic logic get_RREADY(  );
        return do_get_RREADY(  );
    endfunction


    task automatic set_RUSER( logic [7:0] RUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_RUSER( RUSER_param, non_blocking );
    endtask

    task automatic set_RUSER_index1( int _this_dot_1, logic  RUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_RUSER_index1( _this_dot_1, RUSER_param, non_blocking );
    endtask

    function automatic logic [7:0]  get_RUSER(  );
        return do_get_RUSER(  );
    endfunction

    function automatic logic   get_RUSER_index1( int _this_dot_1 );
        return do_get_RUSER_index1( _this_dot_1 );
    endfunction


    task automatic set_WVALID( logic WVALID_param = 'z, bit non_blocking = 1'b0 );
        do_set_WVALID( WVALID_param, non_blocking );
    endtask

    function automatic logic get_WVALID(  );
        return do_get_WVALID(  );
    endfunction


    task automatic set_WLAST( logic WLAST_param = 'z, bit non_blocking = 1'b0 );
        do_set_WLAST( WLAST_param, non_blocking );
    endtask

    function automatic logic get_WLAST(  );
        return do_get_WLAST(  );
    endfunction


    task automatic set_WDATA( logic [((AXI_WDATA_WIDTH) - 1):0]  WDATA_param = 'z, bit non_blocking = 1'b0 );
        do_set_WDATA( WDATA_param, non_blocking );
    endtask

    task automatic set_WDATA_index1( int _this_dot_1, logic  WDATA_param = 'z, bit non_blocking = 1'b0 );
        do_set_WDATA_index1( _this_dot_1, WDATA_param, non_blocking );
    endtask

    function automatic logic [((AXI_WDATA_WIDTH) - 1):0]   get_WDATA(  );
        return do_get_WDATA(  );
    endfunction

    function automatic logic   get_WDATA_index1( int _this_dot_1 );
        return do_get_WDATA_index1( _this_dot_1 );
    endfunction


    task automatic set_WSTRB( logic [(((AXI_WDATA_WIDTH / 8)) - 1):0]  WSTRB_param = 'z, bit non_blocking = 1'b0 );
        do_set_WSTRB( WSTRB_param, non_blocking );
    endtask

    task automatic set_WSTRB_index1( int _this_dot_1, logic  WSTRB_param = 'z, bit non_blocking = 1'b0 );
        do_set_WSTRB_index1( _this_dot_1, WSTRB_param, non_blocking );
    endtask

    function automatic logic [(((AXI_WDATA_WIDTH / 8)) - 1):0]   get_WSTRB(  );
        return do_get_WSTRB(  );
    endfunction

    function automatic logic   get_WSTRB_index1( int _this_dot_1 );
        return do_get_WSTRB_index1( _this_dot_1 );
    endfunction


    task automatic set_WID( logic [((AXI_ID_WIDTH) - 1):0]  WID_param = 'z, bit non_blocking = 1'b0 );
        do_set_WID( WID_param, non_blocking );
    endtask

    task automatic set_WID_index1( int _this_dot_1, logic  WID_param = 'z, bit non_blocking = 1'b0 );
        do_set_WID_index1( _this_dot_1, WID_param, non_blocking );
    endtask

    function automatic logic [((AXI_ID_WIDTH) - 1):0]   get_WID(  );
        return do_get_WID(  );
    endfunction

    function automatic logic   get_WID_index1( int _this_dot_1 );
        return do_get_WID_index1( _this_dot_1 );
    endfunction


    task automatic set_WREADY( logic WREADY_param = 'z, bit non_blocking = 1'b0 );
        do_set_WREADY( WREADY_param, non_blocking );
    endtask

    function automatic logic get_WREADY(  );
        return do_get_WREADY(  );
    endfunction


    task automatic set_WUSER( logic [7:0] WUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_WUSER( WUSER_param, non_blocking );
    endtask

    task automatic set_WUSER_index1( int _this_dot_1, logic  WUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_WUSER_index1( _this_dot_1, WUSER_param, non_blocking );
    endtask

    function automatic logic [7:0]  get_WUSER(  );
        return do_get_WUSER(  );
    endfunction

    function automatic logic   get_WUSER_index1( int _this_dot_1 );
        return do_get_WUSER_index1( _this_dot_1 );
    endfunction


    task automatic set_BVALID( logic BVALID_param = 'z, bit non_blocking = 1'b0 );
        do_set_BVALID( BVALID_param, non_blocking );
    endtask

    function automatic logic get_BVALID(  );
        return do_get_BVALID(  );
    endfunction


    task automatic set_BRESP( logic [1:0] BRESP_param = 'z, bit non_blocking = 1'b0 );
        do_set_BRESP( BRESP_param, non_blocking );
    endtask

    task automatic set_BRESP_index1( int _this_dot_1, logic  BRESP_param = 'z, bit non_blocking = 1'b0 );
        do_set_BRESP_index1( _this_dot_1, BRESP_param, non_blocking );
    endtask

    function automatic logic [1:0]  get_BRESP(  );
        return do_get_BRESP(  );
    endfunction

    function automatic logic   get_BRESP_index1( int _this_dot_1 );
        return do_get_BRESP_index1( _this_dot_1 );
    endfunction


    task automatic set_BID( logic [((AXI_ID_WIDTH) - 1):0]  BID_param = 'z, bit non_blocking = 1'b0 );
        do_set_BID( BID_param, non_blocking );
    endtask

    task automatic set_BID_index1( int _this_dot_1, logic  BID_param = 'z, bit non_blocking = 1'b0 );
        do_set_BID_index1( _this_dot_1, BID_param, non_blocking );
    endtask

    function automatic logic [((AXI_ID_WIDTH) - 1):0]   get_BID(  );
        return do_get_BID(  );
    endfunction

    function automatic logic   get_BID_index1( int _this_dot_1 );
        return do_get_BID_index1( _this_dot_1 );
    endfunction


    task automatic set_BREADY( logic BREADY_param = 'z, bit non_blocking = 1'b0 );
        do_set_BREADY( BREADY_param, non_blocking );
    endtask

    function automatic logic get_BREADY(  );
        return do_get_BREADY(  );
    endfunction


    task automatic set_BUSER( logic [7:0] BUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_BUSER( BUSER_param, non_blocking );
    endtask

    task automatic set_BUSER_index1( int _this_dot_1, logic  BUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_BUSER_index1( _this_dot_1, BUSER_param, non_blocking );
    endtask

    function automatic logic [7:0]  get_BUSER(  );
        return do_get_BUSER(  );
    endfunction

    function automatic logic   get_BUSER_index1( int _this_dot_1 );
        return do_get_BUSER_index1( _this_dot_1 );
    endfunction



    //------------------------------------------------------------------------------
    // Tasks to wait for a change to a global variable with read access
    //------------------------------------------------------------------------------
    task automatic wait_for_config_clk_init_value(  );
        do_wait_for_config_clk_init_value(  );
    endtask

    task automatic wait_for_config_clk_phase_shift(  );
        do_wait_for_config_clk_phase_shift(  );
    endtask

    task automatic wait_for_config_clk_1st_time(  );
        do_wait_for_config_clk_1st_time(  );
    endtask

    task automatic wait_for_config_clk_2nd_time(  );
        do_wait_for_config_clk_2nd_time(  );
    endtask

    task automatic wait_for_config_setup_time(  );
        do_wait_for_config_setup_time(  );
    endtask

    task automatic wait_for_config_hold_time(  );
        do_wait_for_config_hold_time(  );
    endtask

    task automatic wait_for_config_max_transaction_time_factor(  );
        do_wait_for_config_max_transaction_time_factor(  );
    endtask

    task automatic wait_for_config_timeout_max_data_transfer(  );
        do_wait_for_config_timeout_max_data_transfer(  );
    endtask

    task automatic wait_for_config_burst_timeout_factor(  );
        do_wait_for_config_burst_timeout_factor(  );
    endtask

    task automatic wait_for_config_max_latency_AWVALID_assertion_to_AWREADY(  );
        do_wait_for_config_max_latency_AWVALID_assertion_to_AWREADY(  );
    endtask

    task automatic wait_for_config_max_latency_ARVALID_assertion_to_ARREADY(  );
        do_wait_for_config_max_latency_ARVALID_assertion_to_ARREADY(  );
    endtask

    task automatic wait_for_config_max_latency_RVALID_assertion_to_RREADY(  );
        do_wait_for_config_max_latency_RVALID_assertion_to_RREADY(  );
    endtask

    task automatic wait_for_config_max_latency_BVALID_assertion_to_BREADY(  );
        do_wait_for_config_max_latency_BVALID_assertion_to_BREADY(  );
    endtask

    task automatic wait_for_config_max_latency_WVALID_assertion_to_WREADY(  );
        do_wait_for_config_max_latency_WVALID_assertion_to_WREADY(  );
    endtask

    task automatic wait_for_config_write_ctrl_first_ratio(  );
        do_wait_for_config_write_ctrl_first_ratio(  );
    endtask

    task automatic wait_for_config_write_data_first_ratio(  );
        do_wait_for_config_write_data_first_ratio(  );
    endtask

    task automatic wait_for_config_write_ctrl_to_data_mintime(  );
        do_wait_for_config_write_ctrl_to_data_mintime(  );
    endtask

    task automatic wait_for_config_write_data_to_ctrl_mintime(  );
        do_wait_for_config_write_data_to_ctrl_mintime(  );
    endtask

    task automatic wait_for_config_master_write_delay(  );
        do_wait_for_config_master_write_delay(  );
    endtask

    task automatic wait_for_config_reset_low_clocks(  );
        do_wait_for_config_reset_low_clocks(  );
    endtask

    task automatic wait_for_config_reset_hold_time(  );
        do_wait_for_config_reset_hold_time(  );
    endtask

    task automatic wait_for_config_protect_ready(  );
        do_wait_for_config_protect_ready(  );
    endtask

    task automatic wait_for_config_enable_user_sideband(  );
        do_wait_for_config_enable_user_sideband(  );
    endtask

    task automatic wait_for_config_extended_length_enable(  );
        do_wait_for_config_extended_length_enable(  );
    endtask

    task automatic wait_for_config_enable_burst_reserved_value(  );
        do_wait_for_config_enable_burst_reserved_value(  );
    endtask

    task automatic wait_for_config_enable_lock_reserved_value(  );
        do_wait_for_config_enable_lock_reserved_value(  );
    endtask

    task automatic wait_for_config_enable_cache_reserved_value(  );
        do_wait_for_config_enable_cache_reserved_value(  );
    endtask

    task automatic wait_for_config_enable_all_assertions(  );
        do_wait_for_config_enable_all_assertions(  );
    endtask

    task automatic wait_for_config_enable_assertion(  );
        do_wait_for_config_enable_assertion(  );
    endtask

    task automatic wait_for_config_enable_assertion_index1( input int _this_dot_1 );
        do_wait_for_config_enable_assertion_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_enable_error(  );
        do_wait_for_config_enable_error(  );
    endtask

    task automatic wait_for_config_enable_error_index1( input int _this_dot_1 );
        do_wait_for_config_enable_error_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_enable_errors(  );
        do_wait_for_config_enable_errors(  );
    endtask

    task automatic wait_for_config_enable_all_assertion_errors(  );
        do_wait_for_config_enable_all_assertion_errors(  );
    endtask

    task automatic wait_for_config_abstraction_level(  );
        do_wait_for_config_abstraction_level(  );
    endtask

    task automatic wait_for_config_slave_start_addr(  );
        do_wait_for_config_slave_start_addr(  );
    endtask

    task automatic wait_for_config_slave_start_addr_index1( input int _this_dot_1 );
        do_wait_for_config_slave_start_addr_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_slave_end_addr(  );
        do_wait_for_config_slave_end_addr(  );
    endtask

    task automatic wait_for_config_slave_end_addr_index1( input int _this_dot_1 );
        do_wait_for_config_slave_end_addr_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_enable_slave_addr_range_in_bfm(  );
        do_wait_for_config_enable_slave_addr_range_in_bfm(  );
    endtask

    task automatic wait_for_config_read_data_reordering_depth(  );
        do_wait_for_config_read_data_reordering_depth(  );
    endtask

    task automatic wait_for_config_enable_read_data_reordering_depth_in_bfm(  );
        do_wait_for_config_enable_read_data_reordering_depth_in_bfm(  );
    endtask

    task automatic wait_for_config_awid_wid_mismatch(  );
        do_wait_for_config_awid_wid_mismatch(  );
    endtask

    task automatic wait_for_config_length_last_mismatch_error(  );
        do_wait_for_config_length_last_mismatch_error(  );
    endtask

    task automatic wait_for_config_master_error_position(  );
        do_wait_for_config_master_error_position(  );
    endtask

    task automatic wait_for_dummy_var(  );
        do_wait_for_dummy_var(  );
    endtask

    task automatic wait_for_config_wlast_length(  );
        do_wait_for_config_wlast_length(  );
    endtask

    task automatic wait_for_config_wid_for_awid_not_matching(  );
        do_wait_for_config_wid_for_awid_not_matching(  );
    endtask

    task automatic wait_for_config_wid_for_awid_not_matching_index1( input int _this_dot_1 );
        do_wait_for_config_wid_for_awid_not_matching_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_support_exclusive_access(  );
        do_wait_for_config_support_exclusive_access(  );
    endtask

    task automatic wait_for_config_write_data_interleaving_depth(  );
        do_wait_for_config_write_data_interleaving_depth(  );
    endtask

    task automatic wait_for_status_master_error(  );
        do_wait_for_status_master_error(  );
    endtask

    task automatic wait_for_status_master_error_index1( input int _this_dot_1 );
        do_wait_for_status_master_error_index1( _this_dot_1 );
    endtask

    task automatic wait_for_status_num_reads_waiting_for_resp(  );
        do_wait_for_status_num_reads_waiting_for_resp(  );
    endtask

    task automatic wait_for_status_num_writes_waiting_for_response(  );
        do_wait_for_status_num_writes_waiting_for_response(  );
    endtask

    task automatic wait_for_check_total_num_wdata_outstanding(  );
        do_wait_for_check_total_num_wdata_outstanding(  );
    endtask

    task automatic wait_for_total_num_wdata_outstanding(  );
        do_wait_for_total_num_wdata_outstanding(  );
    endtask

    task automatic wait_for_check_max_num_wdata_outstanding_per_id(  );
        do_wait_for_check_max_num_wdata_outstanding_per_id(  );
    endtask

    task automatic wait_for_max_num_wdata_outstanding_per_id(  );
        do_wait_for_max_num_wdata_outstanding_per_id(  );
    endtask

    task automatic wait_for_check_max_num_waddr_outstanding_per_id(  );
        do_wait_for_check_max_num_waddr_outstanding_per_id(  );
    endtask

    task automatic wait_for_max_num_waddr_outstanding_per_id(  );
        do_wait_for_max_num_waddr_outstanding_per_id(  );
    endtask

    task automatic wait_for_check_total_num_waddr_outstanding(  );
        do_wait_for_check_total_num_waddr_outstanding(  );
    endtask

    task automatic wait_for_total_num_waddr_outstanding(  );
        do_wait_for_total_num_waddr_outstanding(  );
    endtask

    task automatic wait_for_status_outstanding_num_for_waddr(  );
        do_wait_for_status_outstanding_num_for_waddr(  );
    endtask

    task automatic wait_for_start_finding_outstanding_waddr(  );
        do_wait_for_start_finding_outstanding_waddr(  );
    endtask

    task automatic wait_for_status_outstanding_num_for_wdata(  );
        do_wait_for_status_outstanding_num_for_wdata(  );
    endtask

    task automatic wait_for_start_finding_outstanding_wdata(  );
        do_wait_for_start_finding_outstanding_wdata(  );
    endtask

    task automatic wait_for_find_waddr_outstanding_for_wid(  );
        do_wait_for_find_waddr_outstanding_for_wid(  );
    endtask

    task automatic wait_for_find_waddr_outstanding_for_wid_index1( input int _this_dot_1 );
        do_wait_for_find_waddr_outstanding_for_wid_index1( _this_dot_1 );
    endtask

    task automatic wait_for_find_wdata_outstanding_for_wid(  );
        do_wait_for_find_wdata_outstanding_for_wid(  );
    endtask

    task automatic wait_for_find_wdata_outstanding_for_wid_index1( input int _this_dot_1 );
        do_wait_for_find_wdata_outstanding_for_wid_index1( _this_dot_1 );
    endtask

    task automatic wait_for_change_in_wdata_outstanding_per_id(  );
        do_wait_for_change_in_wdata_outstanding_per_id(  );
    endtask

    task automatic wait_for_start_finding_change_in_wdata(  );
        do_wait_for_start_finding_change_in_wdata(  );
    endtask

    task automatic wait_for_find_change_in_wdata_outstanding_for_wid(  );
        do_wait_for_find_change_in_wdata_outstanding_for_wid(  );
    endtask

    task automatic wait_for_find_change_in_wdata_outstanding_for_wid_index1( input int _this_dot_1 );
        do_wait_for_find_change_in_wdata_outstanding_for_wid_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_max_outstanding_wr(  );
        do_wait_for_config_max_outstanding_wr(  );
    endtask

    task automatic wait_for_config_max_outstanding_rd(  );
        do_wait_for_config_max_outstanding_rd(  );
    endtask

    task automatic wait_for_config_error_on_deleted_valid_cycles(  );
        do_wait_for_config_error_on_deleted_valid_cycles(  );
    endtask

    task automatic wait_for_config_stats_enable(  );
        do_wait_for_config_stats_enable(  );
    endtask

    task automatic wait_for_config_stats_enable_AXI_read_occupancy(  );
        do_wait_for_config_stats_enable_AXI_read_occupancy(  );
    endtask

    task automatic wait_for_config_stats_enable_AXI_write_occupancy(  );
        do_wait_for_config_stats_enable_AXI_write_occupancy(  );
    endtask

    task automatic wait_for_config_stats_enable_read_data_occupancy(  );
        do_wait_for_config_stats_enable_read_data_occupancy(  );
    endtask

    task automatic wait_for_config_stats_enable_write_data_occupancy(  );
        do_wait_for_config_stats_enable_write_data_occupancy(  );
    endtask

    task automatic wait_for_config_stats_enable_read_latency(  );
        do_wait_for_config_stats_enable_read_latency(  );
    endtask

    task automatic wait_for_config_stats_enable_write_latency(  );
        do_wait_for_config_stats_enable_write_latency(  );
    endtask

    task automatic wait_for_config_stats_enable_read_address_waits(  );
        do_wait_for_config_stats_enable_read_address_waits(  );
    endtask

    task automatic wait_for_config_stats_enable_read_data_waits(  );
        do_wait_for_config_stats_enable_read_data_waits(  );
    endtask

    task automatic wait_for_config_stats_enable_write_address_waits(  );
        do_wait_for_config_stats_enable_write_address_waits(  );
    endtask

    task automatic wait_for_config_stats_enable_write_data_waits(  );
        do_wait_for_config_stats_enable_write_data_waits(  );
    endtask

    task automatic wait_for_config_stats_enable_write_response_waits(  );
        do_wait_for_config_stats_enable_write_response_waits(  );
    endtask

    task automatic wait_for_config_stats_enable_read_bandwidth(  );
        do_wait_for_config_stats_enable_read_bandwidth(  );
    endtask

    task automatic wait_for_config_stats_enable_write_bandwidth(  );
        do_wait_for_config_stats_enable_write_bandwidth(  );
    endtask

    task automatic wait_for_config_stats_AXI_read_occupancy_step(  );
        do_wait_for_config_stats_AXI_read_occupancy_step(  );
    endtask

    task automatic wait_for_config_stats_AXI_read_occupancy_multiple(  );
        do_wait_for_config_stats_AXI_read_occupancy_multiple(  );
    endtask

    task automatic wait_for_stats_AXI_read_active(  );
        do_wait_for_stats_AXI_read_active(  );
    endtask

    task automatic wait_for_stats_AXI_read_occupancy_sw(  );
        do_wait_for_stats_AXI_read_occupancy_sw(  );
    endtask

    task automatic wait_for_stats_AXI_read_occupancy_sw_updated(  );
        do_wait_for_stats_AXI_read_occupancy_sw_updated(  );
    endtask

    task automatic wait_for_stats_AXI_read_idle_sw(  );
        do_wait_for_stats_AXI_read_idle_sw(  );
    endtask

    task automatic wait_for_stats_AXI_read_occupancy_min(  );
        do_wait_for_stats_AXI_read_occupancy_min(  );
    endtask

    task automatic wait_for_stats_AXI_read_idle_min(  );
        do_wait_for_stats_AXI_read_idle_min(  );
    endtask

    task automatic wait_for_stats_AXI_read_occupancy_max(  );
        do_wait_for_stats_AXI_read_occupancy_max(  );
    endtask

    task automatic wait_for_stats_AXI_read_idle_max(  );
        do_wait_for_stats_AXI_read_idle_max(  );
    endtask

    task automatic wait_for_stats_AXI_read_occupancy_mean(  );
        do_wait_for_stats_AXI_read_occupancy_mean(  );
    endtask

    task automatic wait_for_stats_AXI_read_idle_mean(  );
        do_wait_for_stats_AXI_read_idle_mean(  );
    endtask

    task automatic wait_for_config_stats_AXI_write_occupancy_step(  );
        do_wait_for_config_stats_AXI_write_occupancy_step(  );
    endtask

    task automatic wait_for_config_stats_AXI_write_occupancy_multiple(  );
        do_wait_for_config_stats_AXI_write_occupancy_multiple(  );
    endtask

    task automatic wait_for_stats_AXI_write_active(  );
        do_wait_for_stats_AXI_write_active(  );
    endtask

    task automatic wait_for_stats_AXI_write_occupancy_sw(  );
        do_wait_for_stats_AXI_write_occupancy_sw(  );
    endtask

    task automatic wait_for_stats_AXI_write_occupancy_sw_updated(  );
        do_wait_for_stats_AXI_write_occupancy_sw_updated(  );
    endtask

    task automatic wait_for_stats_AXI_write_idle_sw(  );
        do_wait_for_stats_AXI_write_idle_sw(  );
    endtask

    task automatic wait_for_stats_AXI_write_occupancy_min(  );
        do_wait_for_stats_AXI_write_occupancy_min(  );
    endtask

    task automatic wait_for_stats_AXI_write_idle_min(  );
        do_wait_for_stats_AXI_write_idle_min(  );
    endtask

    task automatic wait_for_stats_AXI_write_occupancy_max(  );
        do_wait_for_stats_AXI_write_occupancy_max(  );
    endtask

    task automatic wait_for_stats_AXI_write_idle_max(  );
        do_wait_for_stats_AXI_write_idle_max(  );
    endtask

    task automatic wait_for_stats_AXI_write_occupancy_mean(  );
        do_wait_for_stats_AXI_write_occupancy_mean(  );
    endtask

    task automatic wait_for_stats_AXI_write_idle_mean(  );
        do_wait_for_stats_AXI_write_idle_mean(  );
    endtask

    task automatic wait_for_config_stats_read_data_occupancy_step(  );
        do_wait_for_config_stats_read_data_occupancy_step(  );
    endtask

    task automatic wait_for_config_stats_read_data_occupancy_multiple(  );
        do_wait_for_config_stats_read_data_occupancy_multiple(  );
    endtask

    task automatic wait_for_stats_read_data_occupancy_sw(  );
        do_wait_for_stats_read_data_occupancy_sw(  );
    endtask

    task automatic wait_for_stats_read_data_occupancy_sw_updated(  );
        do_wait_for_stats_read_data_occupancy_sw_updated(  );
    endtask

    task automatic wait_for_stats_read_data_idle_sw(  );
        do_wait_for_stats_read_data_idle_sw(  );
    endtask

    task automatic wait_for_stats_read_data_occupancy_min(  );
        do_wait_for_stats_read_data_occupancy_min(  );
    endtask

    task automatic wait_for_stats_read_data_idle_min(  );
        do_wait_for_stats_read_data_idle_min(  );
    endtask

    task automatic wait_for_stats_read_data_occupancy_max(  );
        do_wait_for_stats_read_data_occupancy_max(  );
    endtask

    task automatic wait_for_stats_read_data_idle_max(  );
        do_wait_for_stats_read_data_idle_max(  );
    endtask

    task automatic wait_for_stats_read_data_occupancy_mean(  );
        do_wait_for_stats_read_data_occupancy_mean(  );
    endtask

    task automatic wait_for_stats_read_data_idle_mean(  );
        do_wait_for_stats_read_data_idle_mean(  );
    endtask

    task automatic wait_for_config_stats_write_data_occupancy_step(  );
        do_wait_for_config_stats_write_data_occupancy_step(  );
    endtask

    task automatic wait_for_config_stats_write_data_occupancy_multiple(  );
        do_wait_for_config_stats_write_data_occupancy_multiple(  );
    endtask

    task automatic wait_for_stats_write_data_occupancy_sw(  );
        do_wait_for_stats_write_data_occupancy_sw(  );
    endtask

    task automatic wait_for_stats_write_data_occupancy_sw_updated(  );
        do_wait_for_stats_write_data_occupancy_sw_updated(  );
    endtask

    task automatic wait_for_stats_write_data_idle_sw(  );
        do_wait_for_stats_write_data_idle_sw(  );
    endtask

    task automatic wait_for_stats_write_data_occupancy_min(  );
        do_wait_for_stats_write_data_occupancy_min(  );
    endtask

    task automatic wait_for_stats_write_data_idle_min(  );
        do_wait_for_stats_write_data_idle_min(  );
    endtask

    task automatic wait_for_stats_write_data_occupancy_max(  );
        do_wait_for_stats_write_data_occupancy_max(  );
    endtask

    task automatic wait_for_stats_write_data_idle_max(  );
        do_wait_for_stats_write_data_idle_max(  );
    endtask

    task automatic wait_for_stats_write_data_occupancy_mean(  );
        do_wait_for_stats_write_data_occupancy_mean(  );
    endtask

    task automatic wait_for_stats_write_data_idle_mean(  );
        do_wait_for_stats_write_data_idle_mean(  );
    endtask

    task automatic wait_for_config_stats_read_bandwidth_step(  );
        do_wait_for_config_stats_read_bandwidth_step(  );
    endtask

    task automatic wait_for_config_stats_read_bandwidth_multiple(  );
        do_wait_for_config_stats_read_bandwidth_multiple(  );
    endtask

    task automatic wait_for_stats_read_bandwidth_sw(  );
        do_wait_for_stats_read_bandwidth_sw(  );
    endtask

    task automatic wait_for_stats_read_bandwidth_sw_updated(  );
        do_wait_for_stats_read_bandwidth_sw_updated(  );
    endtask

    task automatic wait_for_stats_read_bandwidth_min(  );
        do_wait_for_stats_read_bandwidth_min(  );
    endtask

    task automatic wait_for_stats_read_bandwidth_max(  );
        do_wait_for_stats_read_bandwidth_max(  );
    endtask

    task automatic wait_for_stats_read_bandwidth_mean(  );
        do_wait_for_stats_read_bandwidth_mean(  );
    endtask

    task automatic wait_for_config_stats_write_bandwidth_step(  );
        do_wait_for_config_stats_write_bandwidth_step(  );
    endtask

    task automatic wait_for_config_stats_write_bandwidth_multiple(  );
        do_wait_for_config_stats_write_bandwidth_multiple(  );
    endtask

    task automatic wait_for_stats_write_bandwidth_sw(  );
        do_wait_for_stats_write_bandwidth_sw(  );
    endtask

    task automatic wait_for_stats_write_bandwidth_sw_updated(  );
        do_wait_for_stats_write_bandwidth_sw_updated(  );
    endtask

    task automatic wait_for_stats_write_bandwidth_min(  );
        do_wait_for_stats_write_bandwidth_min(  );
    endtask

    task automatic wait_for_stats_write_bandwidth_max(  );
        do_wait_for_stats_write_bandwidth_max(  );
    endtask

    task automatic wait_for_stats_write_bandwidth_mean(  );
        do_wait_for_stats_write_bandwidth_mean(  );
    endtask

    task automatic wait_for_config_stats_read_latency_step(  );
        do_wait_for_config_stats_read_latency_step(  );
    endtask

    task automatic wait_for_config_stats_read_latency_multiple(  );
        do_wait_for_config_stats_read_latency_multiple(  );
    endtask

    task automatic wait_for_stats_read_latency_sw_updated(  );
        do_wait_for_stats_read_latency_sw_updated(  );
    endtask

    task automatic wait_for_stats_read_address_data_latency_inst(  );
        do_wait_for_stats_read_address_data_latency_inst(  );
    endtask

    task automatic wait_for_stats_read_address_data_latency_sw(  );
        do_wait_for_stats_read_address_data_latency_sw(  );
    endtask

    task automatic wait_for_stats_read_address_data_latency_min(  );
        do_wait_for_stats_read_address_data_latency_min(  );
    endtask

    task automatic wait_for_stats_read_address_data_latency_max(  );
        do_wait_for_stats_read_address_data_latency_max(  );
    endtask

    task automatic wait_for_stats_read_address_data_latency_mean(  );
        do_wait_for_stats_read_address_data_latency_mean(  );
    endtask

    task automatic wait_for_stats_read_address_address_latency_inst(  );
        do_wait_for_stats_read_address_address_latency_inst(  );
    endtask

    task automatic wait_for_stats_read_address_address_latency_sw(  );
        do_wait_for_stats_read_address_address_latency_sw(  );
    endtask

    task automatic wait_for_stats_read_address_address_latency_min(  );
        do_wait_for_stats_read_address_address_latency_min(  );
    endtask

    task automatic wait_for_stats_read_address_address_latency_max(  );
        do_wait_for_stats_read_address_address_latency_max(  );
    endtask

    task automatic wait_for_stats_read_address_address_latency_mean(  );
        do_wait_for_stats_read_address_address_latency_mean(  );
    endtask

    task automatic wait_for_config_stats_write_latency_step(  );
        do_wait_for_config_stats_write_latency_step(  );
    endtask

    task automatic wait_for_config_stats_write_latency_multiple(  );
        do_wait_for_config_stats_write_latency_multiple(  );
    endtask

    task automatic wait_for_stats_write_latency_sw_updated(  );
        do_wait_for_stats_write_latency_sw_updated(  );
    endtask

    task automatic wait_for_stats_write_address_data_latency_inst(  );
        do_wait_for_stats_write_address_data_latency_inst(  );
    endtask

    task automatic wait_for_stats_write_address_data_latency_sw(  );
        do_wait_for_stats_write_address_data_latency_sw(  );
    endtask

    task automatic wait_for_stats_write_address_data_latency_min(  );
        do_wait_for_stats_write_address_data_latency_min(  );
    endtask

    task automatic wait_for_stats_write_address_data_latency_max(  );
        do_wait_for_stats_write_address_data_latency_max(  );
    endtask

    task automatic wait_for_stats_write_address_data_latency_mean(  );
        do_wait_for_stats_write_address_data_latency_mean(  );
    endtask

    task automatic wait_for_stats_write_data_response_latency_inst(  );
        do_wait_for_stats_write_data_response_latency_inst(  );
    endtask

    task automatic wait_for_stats_write_data_response_latency_sw(  );
        do_wait_for_stats_write_data_response_latency_sw(  );
    endtask

    task automatic wait_for_stats_write_data_response_latency_min(  );
        do_wait_for_stats_write_data_response_latency_min(  );
    endtask

    task automatic wait_for_stats_write_data_response_latency_max(  );
        do_wait_for_stats_write_data_response_latency_max(  );
    endtask

    task automatic wait_for_stats_write_data_response_latency_mean(  );
        do_wait_for_stats_write_data_response_latency_mean(  );
    endtask

    task automatic wait_for_stats_write_address_address_latency_inst(  );
        do_wait_for_stats_write_address_address_latency_inst(  );
    endtask

    task automatic wait_for_stats_write_address_address_latency_sw(  );
        do_wait_for_stats_write_address_address_latency_sw(  );
    endtask

    task automatic wait_for_stats_write_address_address_latency_min(  );
        do_wait_for_stats_write_address_address_latency_min(  );
    endtask

    task automatic wait_for_stats_write_address_address_latency_max(  );
        do_wait_for_stats_write_address_address_latency_max(  );
    endtask

    task automatic wait_for_stats_write_address_address_latency_mean(  );
        do_wait_for_stats_write_address_address_latency_mean(  );
    endtask

    task automatic wait_for_config_stats_read_address_waits_step(  );
        do_wait_for_config_stats_read_address_waits_step(  );
    endtask

    task automatic wait_for_config_stats_read_address_waits_multiple(  );
        do_wait_for_config_stats_read_address_waits_multiple(  );
    endtask

    task automatic wait_for_stats_read_address_waits_inst(  );
        do_wait_for_stats_read_address_waits_inst(  );
    endtask

    task automatic wait_for_stats_read_address_waits_sw(  );
        do_wait_for_stats_read_address_waits_sw(  );
    endtask

    task automatic wait_for_stats_read_address_waits_sw_updated(  );
        do_wait_for_stats_read_address_waits_sw_updated(  );
    endtask

    task automatic wait_for_stats_read_address_waits_min(  );
        do_wait_for_stats_read_address_waits_min(  );
    endtask

    task automatic wait_for_stats_read_address_waits_max(  );
        do_wait_for_stats_read_address_waits_max(  );
    endtask

    task automatic wait_for_stats_read_address_waits_mean(  );
        do_wait_for_stats_read_address_waits_mean(  );
    endtask

    task automatic wait_for_config_stats_read_data_waits_step(  );
        do_wait_for_config_stats_read_data_waits_step(  );
    endtask

    task automatic wait_for_config_stats_read_data_waits_multiple(  );
        do_wait_for_config_stats_read_data_waits_multiple(  );
    endtask

    task automatic wait_for_stats_read_data_waits_inst(  );
        do_wait_for_stats_read_data_waits_inst(  );
    endtask

    task automatic wait_for_stats_read_data_waits_sw(  );
        do_wait_for_stats_read_data_waits_sw(  );
    endtask

    task automatic wait_for_stats_read_data_waits_sw_updated(  );
        do_wait_for_stats_read_data_waits_sw_updated(  );
    endtask

    task automatic wait_for_stats_read_data_waits_min(  );
        do_wait_for_stats_read_data_waits_min(  );
    endtask

    task automatic wait_for_stats_read_data_waits_max(  );
        do_wait_for_stats_read_data_waits_max(  );
    endtask

    task automatic wait_for_stats_read_data_waits_mean(  );
        do_wait_for_stats_read_data_waits_mean(  );
    endtask

    task automatic wait_for_config_stats_write_address_waits_step(  );
        do_wait_for_config_stats_write_address_waits_step(  );
    endtask

    task automatic wait_for_config_stats_write_address_waits_multiple(  );
        do_wait_for_config_stats_write_address_waits_multiple(  );
    endtask

    task automatic wait_for_stats_write_address_waits_inst(  );
        do_wait_for_stats_write_address_waits_inst(  );
    endtask

    task automatic wait_for_stats_write_address_waits_sw(  );
        do_wait_for_stats_write_address_waits_sw(  );
    endtask

    task automatic wait_for_stats_write_address_waits_sw_updated(  );
        do_wait_for_stats_write_address_waits_sw_updated(  );
    endtask

    task automatic wait_for_stats_write_address_waits_min(  );
        do_wait_for_stats_write_address_waits_min(  );
    endtask

    task automatic wait_for_stats_write_address_waits_max(  );
        do_wait_for_stats_write_address_waits_max(  );
    endtask

    task automatic wait_for_stats_write_address_waits_mean(  );
        do_wait_for_stats_write_address_waits_mean(  );
    endtask

    task automatic wait_for_config_stats_write_data_waits_step(  );
        do_wait_for_config_stats_write_data_waits_step(  );
    endtask

    task automatic wait_for_config_stats_write_data_waits_multiple(  );
        do_wait_for_config_stats_write_data_waits_multiple(  );
    endtask

    task automatic wait_for_stats_write_data_waits_inst(  );
        do_wait_for_stats_write_data_waits_inst(  );
    endtask

    task automatic wait_for_stats_write_data_waits_sw(  );
        do_wait_for_stats_write_data_waits_sw(  );
    endtask

    task automatic wait_for_stats_write_data_waits_sw_updated(  );
        do_wait_for_stats_write_data_waits_sw_updated(  );
    endtask

    task automatic wait_for_stats_write_data_waits_min(  );
        do_wait_for_stats_write_data_waits_min(  );
    endtask

    task automatic wait_for_stats_write_data_waits_max(  );
        do_wait_for_stats_write_data_waits_max(  );
    endtask

    task automatic wait_for_stats_write_data_waits_mean(  );
        do_wait_for_stats_write_data_waits_mean(  );
    endtask

    task automatic wait_for_config_stats_write_response_waits_step(  );
        do_wait_for_config_stats_write_response_waits_step(  );
    endtask

    task automatic wait_for_config_stats_write_response_waits_multiple(  );
        do_wait_for_config_stats_write_response_waits_multiple(  );
    endtask

    task automatic wait_for_stats_write_response_waits_inst(  );
        do_wait_for_stats_write_response_waits_inst(  );
    endtask

    task automatic wait_for_stats_write_response_waits_sw(  );
        do_wait_for_stats_write_response_waits_sw(  );
    endtask

    task automatic wait_for_stats_write_response_waits_sw_updated(  );
        do_wait_for_stats_write_response_waits_sw_updated(  );
    endtask

    task automatic wait_for_stats_write_response_waits_min(  );
        do_wait_for_stats_write_response_waits_min(  );
    endtask

    task automatic wait_for_stats_write_response_waits_max(  );
        do_wait_for_stats_write_response_waits_max(  );
    endtask

    task automatic wait_for_stats_write_response_waits_mean(  );
        do_wait_for_stats_write_response_waits_mean(  );
    endtask

    task automatic wait_for_stats_rw_transaction_last_duration(  );
        do_wait_for_stats_rw_transaction_last_duration(  );
    endtask

    task automatic wait_for_stats_AXI_read_last_duration(  );
        do_wait_for_stats_AXI_read_last_duration(  );
    endtask

    task automatic wait_for_stats_AXI_write_last_duration(  );
        do_wait_for_stats_AXI_write_last_duration(  );
    endtask

    task automatic wait_for_stats_read_addr_channel_phase_last_duration(  );
        do_wait_for_stats_read_addr_channel_phase_last_duration(  );
    endtask

    task automatic wait_for_stats_read_data_burst_last_duration(  );
        do_wait_for_stats_read_data_burst_last_duration(  );
    endtask

    task automatic wait_for_stats_read_channel_phase_last_duration(  );
        do_wait_for_stats_read_channel_phase_last_duration(  );
    endtask

    task automatic wait_for_stats_write_addr_channel_phase_last_duration(  );
        do_wait_for_stats_write_addr_channel_phase_last_duration(  );
    endtask

    task automatic wait_for_stats_write_data_burst_last_duration(  );
        do_wait_for_stats_write_data_burst_last_duration(  );
    endtask

    task automatic wait_for_stats_write_channel_phase_last_duration(  );
        do_wait_for_stats_write_channel_phase_last_duration(  );
    endtask

    task automatic wait_for_stats_write_resp_channel_phase_last_duration(  );
        do_wait_for_stats_write_resp_channel_phase_last_duration(  );
    endtask


    //------------------------------------------------------------------------------
    // Functions to set global variables with write access
    //------------------------------------------------------------------------------
    function automatic void set_config_clk_init_value( bit config_clk_init_value_param );
        do_set_config_clk_init_value( config_clk_init_value_param );
    endfunction

    function automatic void set_config_clk_phase_shift( int config_clk_phase_shift_param );
        do_set_config_clk_phase_shift( config_clk_phase_shift_param );
    endfunction

    function automatic void set_config_clk_1st_time( int config_clk_1st_time_param );
        do_set_config_clk_1st_time( config_clk_1st_time_param );
    endfunction

    function automatic void set_config_clk_2nd_time( int config_clk_2nd_time_param );
        do_set_config_clk_2nd_time( config_clk_2nd_time_param );
    endfunction

    function automatic void set_config_setup_time( int config_setup_time_param );
        do_set_config_setup_time( config_setup_time_param );
    endfunction

    function automatic void set_config_hold_time( int config_hold_time_param );
        do_set_config_hold_time( config_hold_time_param );
    endfunction

    function automatic void set_config_max_transaction_time_factor( int unsigned config_max_transaction_time_factor_param );
        do_set_config_max_transaction_time_factor( config_max_transaction_time_factor_param );
    endfunction

    function automatic void set_config_timeout_max_data_transfer( int config_timeout_max_data_transfer_param );
        do_set_config_timeout_max_data_transfer( config_timeout_max_data_transfer_param );
    endfunction

    function automatic void set_config_burst_timeout_factor( int unsigned config_burst_timeout_factor_param );
        do_set_config_burst_timeout_factor( config_burst_timeout_factor_param );
    endfunction

    function automatic void set_config_max_latency_AWVALID_assertion_to_AWREADY( int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
        do_set_config_max_latency_AWVALID_assertion_to_AWREADY( config_max_latency_AWVALID_assertion_to_AWREADY_param );
    endfunction

    function automatic void set_config_max_latency_ARVALID_assertion_to_ARREADY( int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
        do_set_config_max_latency_ARVALID_assertion_to_ARREADY( config_max_latency_ARVALID_assertion_to_ARREADY_param );
    endfunction

    function automatic void set_config_max_latency_RVALID_assertion_to_RREADY( int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
        do_set_config_max_latency_RVALID_assertion_to_RREADY( config_max_latency_RVALID_assertion_to_RREADY_param );
    endfunction

    function automatic void set_config_max_latency_BVALID_assertion_to_BREADY( int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
        do_set_config_max_latency_BVALID_assertion_to_BREADY( config_max_latency_BVALID_assertion_to_BREADY_param );
    endfunction

    function automatic void set_config_max_latency_WVALID_assertion_to_WREADY( int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
        do_set_config_max_latency_WVALID_assertion_to_WREADY( config_max_latency_WVALID_assertion_to_WREADY_param );
    endfunction

    function automatic void set_config_write_ctrl_first_ratio( int config_write_ctrl_first_ratio_param );
        do_set_config_write_ctrl_first_ratio( config_write_ctrl_first_ratio_param );
    endfunction

    function automatic void set_config_write_data_first_ratio( int config_write_data_first_ratio_param );
        do_set_config_write_data_first_ratio( config_write_data_first_ratio_param );
    endfunction

    function automatic void set_config_write_ctrl_to_data_mintime( int unsigned config_write_ctrl_to_data_mintime_param );
        do_set_config_write_ctrl_to_data_mintime( config_write_ctrl_to_data_mintime_param );
    endfunction

    function automatic void set_config_write_data_to_ctrl_mintime( int unsigned config_write_data_to_ctrl_mintime_param );
        do_set_config_write_data_to_ctrl_mintime( config_write_data_to_ctrl_mintime_param );
    endfunction

    function automatic void set_config_master_write_delay( bit config_master_write_delay_param );
        do_set_config_master_write_delay( config_master_write_delay_param );
    endfunction

    function automatic void set_config_reset_low_clocks( int config_reset_low_clocks_param );
        do_set_config_reset_low_clocks( config_reset_low_clocks_param );
    endfunction

    function automatic void set_config_reset_hold_time( int config_reset_hold_time_param );
        do_set_config_reset_hold_time( config_reset_hold_time_param );
    endfunction

    function automatic void set_config_protect_ready( bit config_protect_ready_param );
        do_set_config_protect_ready( config_protect_ready_param );
    endfunction

    function automatic void set_config_enable_user_sideband( bit config_enable_user_sideband_param );
        do_set_config_enable_user_sideband( config_enable_user_sideband_param );
    endfunction

    function automatic void set_config_extended_length_enable( bit config_extended_length_enable_param );
        do_set_config_extended_length_enable( config_extended_length_enable_param );
    endfunction

    function automatic void set_config_enable_burst_reserved_value( bit config_enable_burst_reserved_value_param );
        do_set_config_enable_burst_reserved_value( config_enable_burst_reserved_value_param );
    endfunction

    function automatic void set_config_enable_lock_reserved_value( bit config_enable_lock_reserved_value_param );
        do_set_config_enable_lock_reserved_value( config_enable_lock_reserved_value_param );
    endfunction

    function automatic void set_config_enable_cache_reserved_value( bit config_enable_cache_reserved_value_param );
        do_set_config_enable_cache_reserved_value( config_enable_cache_reserved_value_param );
    endfunction

    function automatic void set_config_enable_all_assertions( bit config_enable_all_assertions_param );
        do_set_config_enable_all_assertions( config_enable_all_assertions_param );
    endfunction

    function automatic void set_config_enable_assertion( bit [255:0] config_enable_assertion_param );
        do_set_config_enable_assertion( config_enable_assertion_param );
    endfunction

    function automatic void set_config_enable_assertion_index1( int _this_dot_1, bit  config_enable_assertion_param );
        do_set_config_enable_assertion_index1( _this_dot_1, config_enable_assertion_param );
    endfunction

    function automatic void set_config_enable_error( bit [255:0] config_enable_error_param );
        do_set_config_enable_error( config_enable_error_param );
    endfunction

    function automatic void set_config_enable_error_index1( int _this_dot_1, bit  config_enable_error_param );
        do_set_config_enable_error_index1( _this_dot_1, config_enable_error_param );
    endfunction

    function automatic void set_config_enable_errors( bit config_enable_errors_param );
        do_set_config_enable_errors( config_enable_errors_param );
    endfunction

    function automatic void set_config_enable_all_assertion_errors( bit config_enable_all_assertion_errors_param );
        do_set_config_enable_all_assertion_errors( config_enable_all_assertion_errors_param );
    endfunction

    function automatic void set_config_abstraction_level( axi_abstraction_level_e config_abstraction_level_param );
        do_set_config_abstraction_level( config_abstraction_level_param );
    endfunction

    function automatic void set_config_slave_start_addr( bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param );
        do_set_config_slave_start_addr( config_slave_start_addr_param );
    endfunction

    function automatic void set_config_slave_start_addr_index1( int _this_dot_1, bit  config_slave_start_addr_param );
        do_set_config_slave_start_addr_index1( _this_dot_1, config_slave_start_addr_param );
    endfunction

    function automatic void set_config_slave_end_addr( bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param );
        do_set_config_slave_end_addr( config_slave_end_addr_param );
    endfunction

    function automatic void set_config_slave_end_addr_index1( int _this_dot_1, bit  config_slave_end_addr_param );
        do_set_config_slave_end_addr_index1( _this_dot_1, config_slave_end_addr_param );
    endfunction

    function automatic void set_config_enable_slave_addr_range_in_bfm( bit config_enable_slave_addr_range_in_bfm_param );
        do_set_config_enable_slave_addr_range_in_bfm( config_enable_slave_addr_range_in_bfm_param );
    endfunction

    function automatic void set_config_read_data_reordering_depth( int unsigned config_read_data_reordering_depth_param );
        do_set_config_read_data_reordering_depth( config_read_data_reordering_depth_param );
    endfunction

    function automatic void set_config_enable_read_data_reordering_depth_in_bfm( bit config_enable_read_data_reordering_depth_in_bfm_param );
        do_set_config_enable_read_data_reordering_depth_in_bfm( config_enable_read_data_reordering_depth_in_bfm_param );
    endfunction

    function automatic void set_config_awid_wid_mismatch( bit config_awid_wid_mismatch_param );
        do_set_config_awid_wid_mismatch( config_awid_wid_mismatch_param );
    endfunction

    function automatic void set_config_length_last_mismatch_error( bit config_length_last_mismatch_error_param );
        do_set_config_length_last_mismatch_error( config_length_last_mismatch_error_param );
    endfunction

    function automatic void set_config_master_error_position( axi_error_e config_master_error_position_param );
        do_set_config_master_error_position( config_master_error_position_param );
    endfunction

    function automatic void set_dummy_var( axi_assertion_type_e dummy_var_param );
        do_set_dummy_var( dummy_var_param );
    endfunction

    function automatic void set_config_wlast_length( int config_wlast_length_param );
        do_set_config_wlast_length( config_wlast_length_param );
    endfunction

    function automatic void set_config_wid_for_awid_not_matching( bit [((AXI_ID_WIDTH) - 1):0]  config_wid_for_awid_not_matching_param );
        do_set_config_wid_for_awid_not_matching( config_wid_for_awid_not_matching_param );
    endfunction

    function automatic void set_config_wid_for_awid_not_matching_index1( int _this_dot_1, bit  config_wid_for_awid_not_matching_param );
        do_set_config_wid_for_awid_not_matching_index1( _this_dot_1, config_wid_for_awid_not_matching_param );
    endfunction

    function automatic void set_config_support_exclusive_access( bit config_support_exclusive_access_param );
        do_set_config_support_exclusive_access( config_support_exclusive_access_param );
    endfunction

    function automatic void set_config_write_data_interleaving_depth( int config_write_data_interleaving_depth_param );
        do_set_config_write_data_interleaving_depth( config_write_data_interleaving_depth_param );
    endfunction

    function automatic void set_status_master_error( bit [15:0] status_master_error_param );
        do_set_status_master_error( status_master_error_param );
    endfunction

    function automatic void set_status_master_error_index1( int _this_dot_1, bit  status_master_error_param );
        do_set_status_master_error_index1( _this_dot_1, status_master_error_param );
    endfunction

    function automatic void set_check_total_num_wdata_outstanding( bit check_total_num_wdata_outstanding_param );
        do_set_check_total_num_wdata_outstanding( check_total_num_wdata_outstanding_param );
    endfunction

    function automatic void set_total_num_wdata_outstanding( int total_num_wdata_outstanding_param );
        do_set_total_num_wdata_outstanding( total_num_wdata_outstanding_param );
    endfunction

    function automatic void set_check_max_num_wdata_outstanding_per_id( bit check_max_num_wdata_outstanding_per_id_param );
        do_set_check_max_num_wdata_outstanding_per_id( check_max_num_wdata_outstanding_per_id_param );
    endfunction

    function automatic void set_max_num_wdata_outstanding_per_id( int max_num_wdata_outstanding_per_id_param );
        do_set_max_num_wdata_outstanding_per_id( max_num_wdata_outstanding_per_id_param );
    endfunction

    function automatic void set_check_max_num_waddr_outstanding_per_id( bit check_max_num_waddr_outstanding_per_id_param );
        do_set_check_max_num_waddr_outstanding_per_id( check_max_num_waddr_outstanding_per_id_param );
    endfunction

    function automatic void set_max_num_waddr_outstanding_per_id( int max_num_waddr_outstanding_per_id_param );
        do_set_max_num_waddr_outstanding_per_id( max_num_waddr_outstanding_per_id_param );
    endfunction

    function automatic void set_check_total_num_waddr_outstanding( bit check_total_num_waddr_outstanding_param );
        do_set_check_total_num_waddr_outstanding( check_total_num_waddr_outstanding_param );
    endfunction

    function automatic void set_total_num_waddr_outstanding( int total_num_waddr_outstanding_param );
        do_set_total_num_waddr_outstanding( total_num_waddr_outstanding_param );
    endfunction

    function automatic void set_status_outstanding_num_for_waddr( int status_outstanding_num_for_waddr_param );
        do_set_status_outstanding_num_for_waddr( status_outstanding_num_for_waddr_param );
    endfunction

    function automatic void set_start_finding_outstanding_waddr( bit start_finding_outstanding_waddr_param );
        do_set_start_finding_outstanding_waddr( start_finding_outstanding_waddr_param );
    endfunction

    function automatic void set_status_outstanding_num_for_wdata( int status_outstanding_num_for_wdata_param );
        do_set_status_outstanding_num_for_wdata( status_outstanding_num_for_wdata_param );
    endfunction

    function automatic void set_start_finding_outstanding_wdata( bit start_finding_outstanding_wdata_param );
        do_set_start_finding_outstanding_wdata( start_finding_outstanding_wdata_param );
    endfunction

    function automatic void set_find_waddr_outstanding_for_wid( bit [((AXI_ID_WIDTH) - 1):0]  find_waddr_outstanding_for_wid_param );
        do_set_find_waddr_outstanding_for_wid( find_waddr_outstanding_for_wid_param );
    endfunction

    function automatic void set_find_waddr_outstanding_for_wid_index1( int _this_dot_1, bit  find_waddr_outstanding_for_wid_param );
        do_set_find_waddr_outstanding_for_wid_index1( _this_dot_1, find_waddr_outstanding_for_wid_param );
    endfunction

    function automatic void set_find_wdata_outstanding_for_wid( bit [((AXI_ID_WIDTH) - 1):0]  find_wdata_outstanding_for_wid_param );
        do_set_find_wdata_outstanding_for_wid( find_wdata_outstanding_for_wid_param );
    endfunction

    function automatic void set_find_wdata_outstanding_for_wid_index1( int _this_dot_1, bit  find_wdata_outstanding_for_wid_param );
        do_set_find_wdata_outstanding_for_wid_index1( _this_dot_1, find_wdata_outstanding_for_wid_param );
    endfunction

    function automatic void set_change_in_wdata_outstanding_per_id( bit change_in_wdata_outstanding_per_id_param );
        do_set_change_in_wdata_outstanding_per_id( change_in_wdata_outstanding_per_id_param );
    endfunction

    function automatic void set_start_finding_change_in_wdata( bit start_finding_change_in_wdata_param );
        do_set_start_finding_change_in_wdata( start_finding_change_in_wdata_param );
    endfunction

    function automatic void set_find_change_in_wdata_outstanding_for_wid( bit [((AXI_ID_WIDTH) - 1):0]  find_change_in_wdata_outstanding_for_wid_param );
        do_set_find_change_in_wdata_outstanding_for_wid( find_change_in_wdata_outstanding_for_wid_param );
    endfunction

    function automatic void set_find_change_in_wdata_outstanding_for_wid_index1( int _this_dot_1, bit  find_change_in_wdata_outstanding_for_wid_param );
        do_set_find_change_in_wdata_outstanding_for_wid_index1( _this_dot_1, find_change_in_wdata_outstanding_for_wid_param );
    endfunction

    function automatic void set_config_max_outstanding_wr( int config_max_outstanding_wr_param );
        do_set_config_max_outstanding_wr( config_max_outstanding_wr_param );
    endfunction

    function automatic void set_config_max_outstanding_rd( int config_max_outstanding_rd_param );
        do_set_config_max_outstanding_rd( config_max_outstanding_rd_param );
    endfunction

    function automatic void set_config_error_on_deleted_valid_cycles( bit config_error_on_deleted_valid_cycles_param );
        do_set_config_error_on_deleted_valid_cycles( config_error_on_deleted_valid_cycles_param );
    endfunction

    function automatic void set_config_stats_enable( bit config_stats_enable_param );
        do_set_config_stats_enable( config_stats_enable_param );
    endfunction

    function automatic void set_config_stats_enable_AXI_read_occupancy( bit config_stats_enable_AXI_read_occupancy_param );
        do_set_config_stats_enable_AXI_read_occupancy( config_stats_enable_AXI_read_occupancy_param );
    endfunction

    function automatic void set_config_stats_enable_AXI_write_occupancy( bit config_stats_enable_AXI_write_occupancy_param );
        do_set_config_stats_enable_AXI_write_occupancy( config_stats_enable_AXI_write_occupancy_param );
    endfunction

    function automatic void set_config_stats_enable_read_data_occupancy( bit config_stats_enable_read_data_occupancy_param );
        do_set_config_stats_enable_read_data_occupancy( config_stats_enable_read_data_occupancy_param );
    endfunction

    function automatic void set_config_stats_enable_write_data_occupancy( bit config_stats_enable_write_data_occupancy_param );
        do_set_config_stats_enable_write_data_occupancy( config_stats_enable_write_data_occupancy_param );
    endfunction

    function automatic void set_config_stats_enable_read_latency( bit config_stats_enable_read_latency_param );
        do_set_config_stats_enable_read_latency( config_stats_enable_read_latency_param );
    endfunction

    function automatic void set_config_stats_enable_write_latency( bit config_stats_enable_write_latency_param );
        do_set_config_stats_enable_write_latency( config_stats_enable_write_latency_param );
    endfunction

    function automatic void set_config_stats_enable_read_address_waits( bit config_stats_enable_read_address_waits_param );
        do_set_config_stats_enable_read_address_waits( config_stats_enable_read_address_waits_param );
    endfunction

    function automatic void set_config_stats_enable_read_data_waits( bit config_stats_enable_read_data_waits_param );
        do_set_config_stats_enable_read_data_waits( config_stats_enable_read_data_waits_param );
    endfunction

    function automatic void set_config_stats_enable_write_address_waits( bit config_stats_enable_write_address_waits_param );
        do_set_config_stats_enable_write_address_waits( config_stats_enable_write_address_waits_param );
    endfunction

    function automatic void set_config_stats_enable_write_data_waits( bit config_stats_enable_write_data_waits_param );
        do_set_config_stats_enable_write_data_waits( config_stats_enable_write_data_waits_param );
    endfunction

    function automatic void set_config_stats_enable_write_response_waits( bit config_stats_enable_write_response_waits_param );
        do_set_config_stats_enable_write_response_waits( config_stats_enable_write_response_waits_param );
    endfunction

    function automatic void set_config_stats_enable_read_bandwidth( bit config_stats_enable_read_bandwidth_param );
        do_set_config_stats_enable_read_bandwidth( config_stats_enable_read_bandwidth_param );
    endfunction

    function automatic void set_config_stats_enable_write_bandwidth( bit config_stats_enable_write_bandwidth_param );
        do_set_config_stats_enable_write_bandwidth( config_stats_enable_write_bandwidth_param );
    endfunction

    function automatic void set_config_stats_AXI_read_occupancy_step( int config_stats_AXI_read_occupancy_step_param );
        do_set_config_stats_AXI_read_occupancy_step( config_stats_AXI_read_occupancy_step_param );
    endfunction

    function automatic void set_config_stats_AXI_read_occupancy_multiple( int config_stats_AXI_read_occupancy_multiple_param );
        do_set_config_stats_AXI_read_occupancy_multiple( config_stats_AXI_read_occupancy_multiple_param );
    endfunction

    function automatic void set_config_stats_AXI_write_occupancy_step( int config_stats_AXI_write_occupancy_step_param );
        do_set_config_stats_AXI_write_occupancy_step( config_stats_AXI_write_occupancy_step_param );
    endfunction

    function automatic void set_config_stats_AXI_write_occupancy_multiple( int config_stats_AXI_write_occupancy_multiple_param );
        do_set_config_stats_AXI_write_occupancy_multiple( config_stats_AXI_write_occupancy_multiple_param );
    endfunction

    function automatic void set_config_stats_read_data_occupancy_step( int config_stats_read_data_occupancy_step_param );
        do_set_config_stats_read_data_occupancy_step( config_stats_read_data_occupancy_step_param );
    endfunction

    function automatic void set_config_stats_read_data_occupancy_multiple( int config_stats_read_data_occupancy_multiple_param );
        do_set_config_stats_read_data_occupancy_multiple( config_stats_read_data_occupancy_multiple_param );
    endfunction

    function automatic void set_config_stats_write_data_occupancy_step( int config_stats_write_data_occupancy_step_param );
        do_set_config_stats_write_data_occupancy_step( config_stats_write_data_occupancy_step_param );
    endfunction

    function automatic void set_config_stats_write_data_occupancy_multiple( int config_stats_write_data_occupancy_multiple_param );
        do_set_config_stats_write_data_occupancy_multiple( config_stats_write_data_occupancy_multiple_param );
    endfunction

    function automatic void set_config_stats_read_bandwidth_step( int config_stats_read_bandwidth_step_param );
        do_set_config_stats_read_bandwidth_step( config_stats_read_bandwidth_step_param );
    endfunction

    function automatic void set_config_stats_read_bandwidth_multiple( int config_stats_read_bandwidth_multiple_param );
        do_set_config_stats_read_bandwidth_multiple( config_stats_read_bandwidth_multiple_param );
    endfunction

    function automatic void set_config_stats_write_bandwidth_step( int config_stats_write_bandwidth_step_param );
        do_set_config_stats_write_bandwidth_step( config_stats_write_bandwidth_step_param );
    endfunction

    function automatic void set_config_stats_write_bandwidth_multiple( int config_stats_write_bandwidth_multiple_param );
        do_set_config_stats_write_bandwidth_multiple( config_stats_write_bandwidth_multiple_param );
    endfunction

    function automatic void set_config_stats_read_latency_step( int config_stats_read_latency_step_param );
        do_set_config_stats_read_latency_step( config_stats_read_latency_step_param );
    endfunction

    function automatic void set_config_stats_read_latency_multiple( int config_stats_read_latency_multiple_param );
        do_set_config_stats_read_latency_multiple( config_stats_read_latency_multiple_param );
    endfunction

    function automatic void set_config_stats_write_latency_step( int config_stats_write_latency_step_param );
        do_set_config_stats_write_latency_step( config_stats_write_latency_step_param );
    endfunction

    function automatic void set_config_stats_write_latency_multiple( int config_stats_write_latency_multiple_param );
        do_set_config_stats_write_latency_multiple( config_stats_write_latency_multiple_param );
    endfunction

    function automatic void set_config_stats_read_address_waits_step( int config_stats_read_address_waits_step_param );
        do_set_config_stats_read_address_waits_step( config_stats_read_address_waits_step_param );
    endfunction

    function automatic void set_config_stats_read_address_waits_multiple( int config_stats_read_address_waits_multiple_param );
        do_set_config_stats_read_address_waits_multiple( config_stats_read_address_waits_multiple_param );
    endfunction

    function automatic void set_config_stats_read_data_waits_step( int config_stats_read_data_waits_step_param );
        do_set_config_stats_read_data_waits_step( config_stats_read_data_waits_step_param );
    endfunction

    function automatic void set_config_stats_read_data_waits_multiple( int config_stats_read_data_waits_multiple_param );
        do_set_config_stats_read_data_waits_multiple( config_stats_read_data_waits_multiple_param );
    endfunction

    function automatic void set_config_stats_write_address_waits_step( int config_stats_write_address_waits_step_param );
        do_set_config_stats_write_address_waits_step( config_stats_write_address_waits_step_param );
    endfunction

    function automatic void set_config_stats_write_address_waits_multiple( int config_stats_write_address_waits_multiple_param );
        do_set_config_stats_write_address_waits_multiple( config_stats_write_address_waits_multiple_param );
    endfunction

    function automatic void set_config_stats_write_data_waits_step( int config_stats_write_data_waits_step_param );
        do_set_config_stats_write_data_waits_step( config_stats_write_data_waits_step_param );
    endfunction

    function automatic void set_config_stats_write_data_waits_multiple( int config_stats_write_data_waits_multiple_param );
        do_set_config_stats_write_data_waits_multiple( config_stats_write_data_waits_multiple_param );
    endfunction

    function automatic void set_config_stats_write_response_waits_step( int config_stats_write_response_waits_step_param );
        do_set_config_stats_write_response_waits_step( config_stats_write_response_waits_step_param );
    endfunction

    function automatic void set_config_stats_write_response_waits_multiple( int config_stats_write_response_waits_multiple_param );
        do_set_config_stats_write_response_waits_multiple( config_stats_write_response_waits_multiple_param );
    endfunction


    //------------------------------------------------------------------------------
    // Functions to get global variables with read access
    //------------------------------------------------------------------------------
    function automatic bit get_config_clk_init_value(  );
        return do_get_config_clk_init_value(  );
    endfunction

    function automatic int get_config_clk_phase_shift(  );
        return do_get_config_clk_phase_shift(  );
    endfunction

    function automatic int get_config_clk_1st_time(  );
        return do_get_config_clk_1st_time(  );
    endfunction

    function automatic int get_config_clk_2nd_time(  );
        return do_get_config_clk_2nd_time(  );
    endfunction

    function automatic int get_config_setup_time(  );
        return do_get_config_setup_time(  );
    endfunction

    function automatic int get_config_hold_time(  );
        return do_get_config_hold_time(  );
    endfunction

    function automatic int unsigned get_config_max_transaction_time_factor(  );
        return do_get_config_max_transaction_time_factor(  );
    endfunction

    function automatic int get_config_timeout_max_data_transfer(  );
        return do_get_config_timeout_max_data_transfer(  );
    endfunction

    function automatic int unsigned get_config_burst_timeout_factor(  );
        return do_get_config_burst_timeout_factor(  );
    endfunction

    function automatic int unsigned get_config_max_latency_AWVALID_assertion_to_AWREADY(  );
        return do_get_config_max_latency_AWVALID_assertion_to_AWREADY(  );
    endfunction

    function automatic int unsigned get_config_max_latency_ARVALID_assertion_to_ARREADY(  );
        return do_get_config_max_latency_ARVALID_assertion_to_ARREADY(  );
    endfunction

    function automatic int unsigned get_config_max_latency_RVALID_assertion_to_RREADY(  );
        return do_get_config_max_latency_RVALID_assertion_to_RREADY(  );
    endfunction

    function automatic int unsigned get_config_max_latency_BVALID_assertion_to_BREADY(  );
        return do_get_config_max_latency_BVALID_assertion_to_BREADY(  );
    endfunction

    function automatic int unsigned get_config_max_latency_WVALID_assertion_to_WREADY(  );
        return do_get_config_max_latency_WVALID_assertion_to_WREADY(  );
    endfunction

    function automatic int get_config_write_ctrl_first_ratio(  );
        return do_get_config_write_ctrl_first_ratio(  );
    endfunction

    function automatic int get_config_write_data_first_ratio(  );
        return do_get_config_write_data_first_ratio(  );
    endfunction

    function automatic int unsigned get_config_write_ctrl_to_data_mintime(  );
        return do_get_config_write_ctrl_to_data_mintime(  );
    endfunction

    function automatic int unsigned get_config_write_data_to_ctrl_mintime(  );
        return do_get_config_write_data_to_ctrl_mintime(  );
    endfunction

    function automatic bit get_config_master_write_delay(  );
        return do_get_config_master_write_delay(  );
    endfunction

    function automatic int get_config_reset_low_clocks(  );
        return do_get_config_reset_low_clocks(  );
    endfunction

    function automatic int get_config_reset_hold_time(  );
        return do_get_config_reset_hold_time(  );
    endfunction

    function automatic bit get_config_protect_ready(  );
        return do_get_config_protect_ready(  );
    endfunction

    function automatic bit get_config_enable_user_sideband(  );
        return do_get_config_enable_user_sideband(  );
    endfunction

    function automatic bit get_config_extended_length_enable(  );
        return do_get_config_extended_length_enable(  );
    endfunction

    function automatic bit get_config_enable_burst_reserved_value(  );
        return do_get_config_enable_burst_reserved_value(  );
    endfunction

    function automatic bit get_config_enable_lock_reserved_value(  );
        return do_get_config_enable_lock_reserved_value(  );
    endfunction

    function automatic bit get_config_enable_cache_reserved_value(  );
        return do_get_config_enable_cache_reserved_value(  );
    endfunction

    function automatic bit get_config_enable_all_assertions(  );
        return do_get_config_enable_all_assertions(  );
    endfunction

    function automatic bit [255:0]  get_config_enable_assertion(  );
        return do_get_config_enable_assertion(  );
    endfunction

    function automatic bit   get_config_enable_assertion_index1( int _this_dot_1 );
        return do_get_config_enable_assertion_index1( _this_dot_1 );
    endfunction

    function automatic bit [255:0]  get_config_enable_error(  );
        return do_get_config_enable_error(  );
    endfunction

    function automatic bit   get_config_enable_error_index1( int _this_dot_1 );
        return do_get_config_enable_error_index1( _this_dot_1 );
    endfunction

    function automatic bit get_config_enable_errors(  );
        return do_get_config_enable_errors(  );
    endfunction

    function automatic bit get_config_enable_all_assertion_errors(  );
        return do_get_config_enable_all_assertion_errors(  );
    endfunction

    function automatic axi_abstraction_level_e get_config_abstraction_level(  );
        return do_get_config_abstraction_level(  );
    endfunction

    function automatic bit [((AXI_ADDRESS_WIDTH) - 1):0]   get_config_slave_start_addr(  );
        return do_get_config_slave_start_addr(  );
    endfunction

    function automatic bit   get_config_slave_start_addr_index1( int _this_dot_1 );
        return do_get_config_slave_start_addr_index1( _this_dot_1 );
    endfunction

    function automatic bit [((AXI_ADDRESS_WIDTH) - 1):0]   get_config_slave_end_addr(  );
        return do_get_config_slave_end_addr(  );
    endfunction

    function automatic bit   get_config_slave_end_addr_index1( int _this_dot_1 );
        return do_get_config_slave_end_addr_index1( _this_dot_1 );
    endfunction

    function automatic bit get_config_enable_slave_addr_range_in_bfm(  );
        return do_get_config_enable_slave_addr_range_in_bfm(  );
    endfunction

    function automatic int unsigned get_config_read_data_reordering_depth(  );
        return do_get_config_read_data_reordering_depth(  );
    endfunction

    function automatic bit get_config_enable_read_data_reordering_depth_in_bfm(  );
        return do_get_config_enable_read_data_reordering_depth_in_bfm(  );
    endfunction

    function automatic bit get_config_awid_wid_mismatch(  );
        return do_get_config_awid_wid_mismatch(  );
    endfunction

    function automatic bit get_config_length_last_mismatch_error(  );
        return do_get_config_length_last_mismatch_error(  );
    endfunction

    function automatic axi_error_e get_config_master_error_position(  );
        return do_get_config_master_error_position(  );
    endfunction

    function automatic axi_assertion_type_e get_dummy_var(  );
        return do_get_dummy_var(  );
    endfunction

    function automatic int get_config_wlast_length(  );
        return do_get_config_wlast_length(  );
    endfunction

    function automatic bit [((AXI_ID_WIDTH) - 1):0]   get_config_wid_for_awid_not_matching(  );
        return do_get_config_wid_for_awid_not_matching(  );
    endfunction

    function automatic bit   get_config_wid_for_awid_not_matching_index1( int _this_dot_1 );
        return do_get_config_wid_for_awid_not_matching_index1( _this_dot_1 );
    endfunction

    function automatic bit get_config_support_exclusive_access(  );
        return do_get_config_support_exclusive_access(  );
    endfunction

    function automatic int get_config_write_data_interleaving_depth(  );
        return do_get_config_write_data_interleaving_depth(  );
    endfunction

    function automatic bit [15:0]  get_status_master_error(  );
        return do_get_status_master_error(  );
    endfunction

    function automatic bit   get_status_master_error_index1( int _this_dot_1 );
        return do_get_status_master_error_index1( _this_dot_1 );
    endfunction

    function automatic int get_status_num_reads_waiting_for_resp(  );
        return do_get_status_num_reads_waiting_for_resp(  );
    endfunction

    function automatic int get_status_num_writes_waiting_for_response(  );
        return do_get_status_num_writes_waiting_for_response(  );
    endfunction

    function automatic bit get_check_total_num_wdata_outstanding(  );
        return do_get_check_total_num_wdata_outstanding(  );
    endfunction

    function automatic int get_total_num_wdata_outstanding(  );
        return do_get_total_num_wdata_outstanding(  );
    endfunction

    function automatic bit get_check_max_num_wdata_outstanding_per_id(  );
        return do_get_check_max_num_wdata_outstanding_per_id(  );
    endfunction

    function automatic int get_max_num_wdata_outstanding_per_id(  );
        return do_get_max_num_wdata_outstanding_per_id(  );
    endfunction

    function automatic bit get_check_max_num_waddr_outstanding_per_id(  );
        return do_get_check_max_num_waddr_outstanding_per_id(  );
    endfunction

    function automatic int get_max_num_waddr_outstanding_per_id(  );
        return do_get_max_num_waddr_outstanding_per_id(  );
    endfunction

    function automatic bit get_check_total_num_waddr_outstanding(  );
        return do_get_check_total_num_waddr_outstanding(  );
    endfunction

    function automatic int get_total_num_waddr_outstanding(  );
        return do_get_total_num_waddr_outstanding(  );
    endfunction

    function automatic int get_status_outstanding_num_for_waddr(  );
        return do_get_status_outstanding_num_for_waddr(  );
    endfunction

    function automatic bit get_start_finding_outstanding_waddr(  );
        return do_get_start_finding_outstanding_waddr(  );
    endfunction

    function automatic int get_status_outstanding_num_for_wdata(  );
        return do_get_status_outstanding_num_for_wdata(  );
    endfunction

    function automatic bit get_start_finding_outstanding_wdata(  );
        return do_get_start_finding_outstanding_wdata(  );
    endfunction

    function automatic bit [((AXI_ID_WIDTH) - 1):0]   get_find_waddr_outstanding_for_wid(  );
        return do_get_find_waddr_outstanding_for_wid(  );
    endfunction

    function automatic bit   get_find_waddr_outstanding_for_wid_index1( int _this_dot_1 );
        return do_get_find_waddr_outstanding_for_wid_index1( _this_dot_1 );
    endfunction

    function automatic bit [((AXI_ID_WIDTH) - 1):0]   get_find_wdata_outstanding_for_wid(  );
        return do_get_find_wdata_outstanding_for_wid(  );
    endfunction

    function automatic bit   get_find_wdata_outstanding_for_wid_index1( int _this_dot_1 );
        return do_get_find_wdata_outstanding_for_wid_index1( _this_dot_1 );
    endfunction

    function automatic bit get_change_in_wdata_outstanding_per_id(  );
        return do_get_change_in_wdata_outstanding_per_id(  );
    endfunction

    function automatic bit get_start_finding_change_in_wdata(  );
        return do_get_start_finding_change_in_wdata(  );
    endfunction

    function automatic bit [((AXI_ID_WIDTH) - 1):0]   get_find_change_in_wdata_outstanding_for_wid(  );
        return do_get_find_change_in_wdata_outstanding_for_wid(  );
    endfunction

    function automatic bit   get_find_change_in_wdata_outstanding_for_wid_index1( int _this_dot_1 );
        return do_get_find_change_in_wdata_outstanding_for_wid_index1( _this_dot_1 );
    endfunction

    function automatic int get_config_max_outstanding_wr(  );
        return do_get_config_max_outstanding_wr(  );
    endfunction

    function automatic int get_config_max_outstanding_rd(  );
        return do_get_config_max_outstanding_rd(  );
    endfunction

    function automatic bit get_config_error_on_deleted_valid_cycles(  );
        return do_get_config_error_on_deleted_valid_cycles(  );
    endfunction

    function automatic bit get_config_stats_enable(  );
        return do_get_config_stats_enable(  );
    endfunction

    function automatic bit get_config_stats_enable_AXI_read_occupancy(  );
        return do_get_config_stats_enable_AXI_read_occupancy(  );
    endfunction

    function automatic bit get_config_stats_enable_AXI_write_occupancy(  );
        return do_get_config_stats_enable_AXI_write_occupancy(  );
    endfunction

    function automatic bit get_config_stats_enable_read_data_occupancy(  );
        return do_get_config_stats_enable_read_data_occupancy(  );
    endfunction

    function automatic bit get_config_stats_enable_write_data_occupancy(  );
        return do_get_config_stats_enable_write_data_occupancy(  );
    endfunction

    function automatic bit get_config_stats_enable_read_latency(  );
        return do_get_config_stats_enable_read_latency(  );
    endfunction

    function automatic bit get_config_stats_enable_write_latency(  );
        return do_get_config_stats_enable_write_latency(  );
    endfunction

    function automatic bit get_config_stats_enable_read_address_waits(  );
        return do_get_config_stats_enable_read_address_waits(  );
    endfunction

    function automatic bit get_config_stats_enable_read_data_waits(  );
        return do_get_config_stats_enable_read_data_waits(  );
    endfunction

    function automatic bit get_config_stats_enable_write_address_waits(  );
        return do_get_config_stats_enable_write_address_waits(  );
    endfunction

    function automatic bit get_config_stats_enable_write_data_waits(  );
        return do_get_config_stats_enable_write_data_waits(  );
    endfunction

    function automatic bit get_config_stats_enable_write_response_waits(  );
        return do_get_config_stats_enable_write_response_waits(  );
    endfunction

    function automatic bit get_config_stats_enable_read_bandwidth(  );
        return do_get_config_stats_enable_read_bandwidth(  );
    endfunction

    function automatic bit get_config_stats_enable_write_bandwidth(  );
        return do_get_config_stats_enable_write_bandwidth(  );
    endfunction

    function automatic int get_config_stats_AXI_read_occupancy_step(  );
        return do_get_config_stats_AXI_read_occupancy_step(  );
    endfunction

    function automatic int get_config_stats_AXI_read_occupancy_multiple(  );
        return do_get_config_stats_AXI_read_occupancy_multiple(  );
    endfunction

    function automatic bit get_stats_AXI_read_active(  );
        return do_get_stats_AXI_read_active(  );
    endfunction

    function automatic int get_stats_AXI_read_occupancy_sw(  );
        return do_get_stats_AXI_read_occupancy_sw(  );
    endfunction

    function automatic int get_stats_AXI_read_occupancy_sw_updated(  );
        return do_get_stats_AXI_read_occupancy_sw_updated(  );
    endfunction

    function automatic int get_stats_AXI_read_idle_sw(  );
        return do_get_stats_AXI_read_idle_sw(  );
    endfunction

    function automatic int get_stats_AXI_read_occupancy_min(  );
        return do_get_stats_AXI_read_occupancy_min(  );
    endfunction

    function automatic int get_stats_AXI_read_idle_min(  );
        return do_get_stats_AXI_read_idle_min(  );
    endfunction

    function automatic int get_stats_AXI_read_occupancy_max(  );
        return do_get_stats_AXI_read_occupancy_max(  );
    endfunction

    function automatic int get_stats_AXI_read_idle_max(  );
        return do_get_stats_AXI_read_idle_max(  );
    endfunction

    function automatic int get_stats_AXI_read_occupancy_mean(  );
        return do_get_stats_AXI_read_occupancy_mean(  );
    endfunction

    function automatic int get_stats_AXI_read_idle_mean(  );
        return do_get_stats_AXI_read_idle_mean(  );
    endfunction

    function automatic int get_config_stats_AXI_write_occupancy_step(  );
        return do_get_config_stats_AXI_write_occupancy_step(  );
    endfunction

    function automatic int get_config_stats_AXI_write_occupancy_multiple(  );
        return do_get_config_stats_AXI_write_occupancy_multiple(  );
    endfunction

    function automatic bit get_stats_AXI_write_active(  );
        return do_get_stats_AXI_write_active(  );
    endfunction

    function automatic int get_stats_AXI_write_occupancy_sw(  );
        return do_get_stats_AXI_write_occupancy_sw(  );
    endfunction

    function automatic int get_stats_AXI_write_occupancy_sw_updated(  );
        return do_get_stats_AXI_write_occupancy_sw_updated(  );
    endfunction

    function automatic int get_stats_AXI_write_idle_sw(  );
        return do_get_stats_AXI_write_idle_sw(  );
    endfunction

    function automatic int get_stats_AXI_write_occupancy_min(  );
        return do_get_stats_AXI_write_occupancy_min(  );
    endfunction

    function automatic int get_stats_AXI_write_idle_min(  );
        return do_get_stats_AXI_write_idle_min(  );
    endfunction

    function automatic int get_stats_AXI_write_occupancy_max(  );
        return do_get_stats_AXI_write_occupancy_max(  );
    endfunction

    function automatic int get_stats_AXI_write_idle_max(  );
        return do_get_stats_AXI_write_idle_max(  );
    endfunction

    function automatic int get_stats_AXI_write_occupancy_mean(  );
        return do_get_stats_AXI_write_occupancy_mean(  );
    endfunction

    function automatic int get_stats_AXI_write_idle_mean(  );
        return do_get_stats_AXI_write_idle_mean(  );
    endfunction

    function automatic int get_config_stats_read_data_occupancy_step(  );
        return do_get_config_stats_read_data_occupancy_step(  );
    endfunction

    function automatic int get_config_stats_read_data_occupancy_multiple(  );
        return do_get_config_stats_read_data_occupancy_multiple(  );
    endfunction

    function automatic int get_stats_read_data_occupancy_sw(  );
        return do_get_stats_read_data_occupancy_sw(  );
    endfunction

    function automatic int get_stats_read_data_occupancy_sw_updated(  );
        return do_get_stats_read_data_occupancy_sw_updated(  );
    endfunction

    function automatic int get_stats_read_data_idle_sw(  );
        return do_get_stats_read_data_idle_sw(  );
    endfunction

    function automatic int get_stats_read_data_occupancy_min(  );
        return do_get_stats_read_data_occupancy_min(  );
    endfunction

    function automatic int get_stats_read_data_idle_min(  );
        return do_get_stats_read_data_idle_min(  );
    endfunction

    function automatic int get_stats_read_data_occupancy_max(  );
        return do_get_stats_read_data_occupancy_max(  );
    endfunction

    function automatic int get_stats_read_data_idle_max(  );
        return do_get_stats_read_data_idle_max(  );
    endfunction

    function automatic int get_stats_read_data_occupancy_mean(  );
        return do_get_stats_read_data_occupancy_mean(  );
    endfunction

    function automatic int get_stats_read_data_idle_mean(  );
        return do_get_stats_read_data_idle_mean(  );
    endfunction

    function automatic int get_config_stats_write_data_occupancy_step(  );
        return do_get_config_stats_write_data_occupancy_step(  );
    endfunction

    function automatic int get_config_stats_write_data_occupancy_multiple(  );
        return do_get_config_stats_write_data_occupancy_multiple(  );
    endfunction

    function automatic int get_stats_write_data_occupancy_sw(  );
        return do_get_stats_write_data_occupancy_sw(  );
    endfunction

    function automatic int get_stats_write_data_occupancy_sw_updated(  );
        return do_get_stats_write_data_occupancy_sw_updated(  );
    endfunction

    function automatic int get_stats_write_data_idle_sw(  );
        return do_get_stats_write_data_idle_sw(  );
    endfunction

    function automatic int get_stats_write_data_occupancy_min(  );
        return do_get_stats_write_data_occupancy_min(  );
    endfunction

    function automatic int get_stats_write_data_idle_min(  );
        return do_get_stats_write_data_idle_min(  );
    endfunction

    function automatic int get_stats_write_data_occupancy_max(  );
        return do_get_stats_write_data_occupancy_max(  );
    endfunction

    function automatic int get_stats_write_data_idle_max(  );
        return do_get_stats_write_data_idle_max(  );
    endfunction

    function automatic int get_stats_write_data_occupancy_mean(  );
        return do_get_stats_write_data_occupancy_mean(  );
    endfunction

    function automatic int get_stats_write_data_idle_mean(  );
        return do_get_stats_write_data_idle_mean(  );
    endfunction

    function automatic int get_config_stats_read_bandwidth_step(  );
        return do_get_config_stats_read_bandwidth_step(  );
    endfunction

    function automatic int get_config_stats_read_bandwidth_multiple(  );
        return do_get_config_stats_read_bandwidth_multiple(  );
    endfunction

    function automatic int get_stats_read_bandwidth_sw(  );
        return do_get_stats_read_bandwidth_sw(  );
    endfunction

    function automatic int get_stats_read_bandwidth_sw_updated(  );
        return do_get_stats_read_bandwidth_sw_updated(  );
    endfunction

    function automatic int get_stats_read_bandwidth_min(  );
        return do_get_stats_read_bandwidth_min(  );
    endfunction

    function automatic int get_stats_read_bandwidth_max(  );
        return do_get_stats_read_bandwidth_max(  );
    endfunction

    function automatic int get_stats_read_bandwidth_mean(  );
        return do_get_stats_read_bandwidth_mean(  );
    endfunction

    function automatic int get_config_stats_write_bandwidth_step(  );
        return do_get_config_stats_write_bandwidth_step(  );
    endfunction

    function automatic int get_config_stats_write_bandwidth_multiple(  );
        return do_get_config_stats_write_bandwidth_multiple(  );
    endfunction

    function automatic int get_stats_write_bandwidth_sw(  );
        return do_get_stats_write_bandwidth_sw(  );
    endfunction

    function automatic int get_stats_write_bandwidth_sw_updated(  );
        return do_get_stats_write_bandwidth_sw_updated(  );
    endfunction

    function automatic int get_stats_write_bandwidth_min(  );
        return do_get_stats_write_bandwidth_min(  );
    endfunction

    function automatic int get_stats_write_bandwidth_max(  );
        return do_get_stats_write_bandwidth_max(  );
    endfunction

    function automatic int get_stats_write_bandwidth_mean(  );
        return do_get_stats_write_bandwidth_mean(  );
    endfunction

    function automatic int get_config_stats_read_latency_step(  );
        return do_get_config_stats_read_latency_step(  );
    endfunction

    function automatic int get_config_stats_read_latency_multiple(  );
        return do_get_config_stats_read_latency_multiple(  );
    endfunction

    function automatic int get_stats_read_latency_sw_updated(  );
        return do_get_stats_read_latency_sw_updated(  );
    endfunction

    function automatic int get_stats_read_address_data_latency_inst(  );
        return do_get_stats_read_address_data_latency_inst(  );
    endfunction

    function automatic int get_stats_read_address_data_latency_sw(  );
        return do_get_stats_read_address_data_latency_sw(  );
    endfunction

    function automatic int get_stats_read_address_data_latency_min(  );
        return do_get_stats_read_address_data_latency_min(  );
    endfunction

    function automatic int get_stats_read_address_data_latency_max(  );
        return do_get_stats_read_address_data_latency_max(  );
    endfunction

    function automatic int get_stats_read_address_data_latency_mean(  );
        return do_get_stats_read_address_data_latency_mean(  );
    endfunction

    function automatic int get_stats_read_address_address_latency_inst(  );
        return do_get_stats_read_address_address_latency_inst(  );
    endfunction

    function automatic int get_stats_read_address_address_latency_sw(  );
        return do_get_stats_read_address_address_latency_sw(  );
    endfunction

    function automatic int get_stats_read_address_address_latency_min(  );
        return do_get_stats_read_address_address_latency_min(  );
    endfunction

    function automatic int get_stats_read_address_address_latency_max(  );
        return do_get_stats_read_address_address_latency_max(  );
    endfunction

    function automatic int get_stats_read_address_address_latency_mean(  );
        return do_get_stats_read_address_address_latency_mean(  );
    endfunction

    function automatic int get_config_stats_write_latency_step(  );
        return do_get_config_stats_write_latency_step(  );
    endfunction

    function automatic int get_config_stats_write_latency_multiple(  );
        return do_get_config_stats_write_latency_multiple(  );
    endfunction

    function automatic int get_stats_write_latency_sw_updated(  );
        return do_get_stats_write_latency_sw_updated(  );
    endfunction

    function automatic int get_stats_write_address_data_latency_inst(  );
        return do_get_stats_write_address_data_latency_inst(  );
    endfunction

    function automatic int get_stats_write_address_data_latency_sw(  );
        return do_get_stats_write_address_data_latency_sw(  );
    endfunction

    function automatic int get_stats_write_address_data_latency_min(  );
        return do_get_stats_write_address_data_latency_min(  );
    endfunction

    function automatic int get_stats_write_address_data_latency_max(  );
        return do_get_stats_write_address_data_latency_max(  );
    endfunction

    function automatic int get_stats_write_address_data_latency_mean(  );
        return do_get_stats_write_address_data_latency_mean(  );
    endfunction

    function automatic int get_stats_write_data_response_latency_inst(  );
        return do_get_stats_write_data_response_latency_inst(  );
    endfunction

    function automatic int get_stats_write_data_response_latency_sw(  );
        return do_get_stats_write_data_response_latency_sw(  );
    endfunction

    function automatic int get_stats_write_data_response_latency_min(  );
        return do_get_stats_write_data_response_latency_min(  );
    endfunction

    function automatic int get_stats_write_data_response_latency_max(  );
        return do_get_stats_write_data_response_latency_max(  );
    endfunction

    function automatic int get_stats_write_data_response_latency_mean(  );
        return do_get_stats_write_data_response_latency_mean(  );
    endfunction

    function automatic int get_stats_write_address_address_latency_inst(  );
        return do_get_stats_write_address_address_latency_inst(  );
    endfunction

    function automatic int get_stats_write_address_address_latency_sw(  );
        return do_get_stats_write_address_address_latency_sw(  );
    endfunction

    function automatic int get_stats_write_address_address_latency_min(  );
        return do_get_stats_write_address_address_latency_min(  );
    endfunction

    function automatic int get_stats_write_address_address_latency_max(  );
        return do_get_stats_write_address_address_latency_max(  );
    endfunction

    function automatic int get_stats_write_address_address_latency_mean(  );
        return do_get_stats_write_address_address_latency_mean(  );
    endfunction

    function automatic int get_config_stats_read_address_waits_step(  );
        return do_get_config_stats_read_address_waits_step(  );
    endfunction

    function automatic int get_config_stats_read_address_waits_multiple(  );
        return do_get_config_stats_read_address_waits_multiple(  );
    endfunction

    function automatic int get_stats_read_address_waits_inst(  );
        return do_get_stats_read_address_waits_inst(  );
    endfunction

    function automatic int get_stats_read_address_waits_sw(  );
        return do_get_stats_read_address_waits_sw(  );
    endfunction

    function automatic int get_stats_read_address_waits_sw_updated(  );
        return do_get_stats_read_address_waits_sw_updated(  );
    endfunction

    function automatic int get_stats_read_address_waits_min(  );
        return do_get_stats_read_address_waits_min(  );
    endfunction

    function automatic int get_stats_read_address_waits_max(  );
        return do_get_stats_read_address_waits_max(  );
    endfunction

    function automatic int get_stats_read_address_waits_mean(  );
        return do_get_stats_read_address_waits_mean(  );
    endfunction

    function automatic int get_config_stats_read_data_waits_step(  );
        return do_get_config_stats_read_data_waits_step(  );
    endfunction

    function automatic int get_config_stats_read_data_waits_multiple(  );
        return do_get_config_stats_read_data_waits_multiple(  );
    endfunction

    function automatic int get_stats_read_data_waits_inst(  );
        return do_get_stats_read_data_waits_inst(  );
    endfunction

    function automatic int get_stats_read_data_waits_sw(  );
        return do_get_stats_read_data_waits_sw(  );
    endfunction

    function automatic int get_stats_read_data_waits_sw_updated(  );
        return do_get_stats_read_data_waits_sw_updated(  );
    endfunction

    function automatic int get_stats_read_data_waits_min(  );
        return do_get_stats_read_data_waits_min(  );
    endfunction

    function automatic int get_stats_read_data_waits_max(  );
        return do_get_stats_read_data_waits_max(  );
    endfunction

    function automatic int get_stats_read_data_waits_mean(  );
        return do_get_stats_read_data_waits_mean(  );
    endfunction

    function automatic int get_config_stats_write_address_waits_step(  );
        return do_get_config_stats_write_address_waits_step(  );
    endfunction

    function automatic int get_config_stats_write_address_waits_multiple(  );
        return do_get_config_stats_write_address_waits_multiple(  );
    endfunction

    function automatic int get_stats_write_address_waits_inst(  );
        return do_get_stats_write_address_waits_inst(  );
    endfunction

    function automatic int get_stats_write_address_waits_sw(  );
        return do_get_stats_write_address_waits_sw(  );
    endfunction

    function automatic int get_stats_write_address_waits_sw_updated(  );
        return do_get_stats_write_address_waits_sw_updated(  );
    endfunction

    function automatic int get_stats_write_address_waits_min(  );
        return do_get_stats_write_address_waits_min(  );
    endfunction

    function automatic int get_stats_write_address_waits_max(  );
        return do_get_stats_write_address_waits_max(  );
    endfunction

    function automatic int get_stats_write_address_waits_mean(  );
        return do_get_stats_write_address_waits_mean(  );
    endfunction

    function automatic int get_config_stats_write_data_waits_step(  );
        return do_get_config_stats_write_data_waits_step(  );
    endfunction

    function automatic int get_config_stats_write_data_waits_multiple(  );
        return do_get_config_stats_write_data_waits_multiple(  );
    endfunction

    function automatic int get_stats_write_data_waits_inst(  );
        return do_get_stats_write_data_waits_inst(  );
    endfunction

    function automatic int get_stats_write_data_waits_sw(  );
        return do_get_stats_write_data_waits_sw(  );
    endfunction

    function automatic int get_stats_write_data_waits_sw_updated(  );
        return do_get_stats_write_data_waits_sw_updated(  );
    endfunction

    function automatic int get_stats_write_data_waits_min(  );
        return do_get_stats_write_data_waits_min(  );
    endfunction

    function automatic int get_stats_write_data_waits_max(  );
        return do_get_stats_write_data_waits_max(  );
    endfunction

    function automatic int get_stats_write_data_waits_mean(  );
        return do_get_stats_write_data_waits_mean(  );
    endfunction

    function automatic int get_config_stats_write_response_waits_step(  );
        return do_get_config_stats_write_response_waits_step(  );
    endfunction

    function automatic int get_config_stats_write_response_waits_multiple(  );
        return do_get_config_stats_write_response_waits_multiple(  );
    endfunction

    function automatic int get_stats_write_response_waits_inst(  );
        return do_get_stats_write_response_waits_inst(  );
    endfunction

    function automatic int get_stats_write_response_waits_sw(  );
        return do_get_stats_write_response_waits_sw(  );
    endfunction

    function automatic int get_stats_write_response_waits_sw_updated(  );
        return do_get_stats_write_response_waits_sw_updated(  );
    endfunction

    function automatic int get_stats_write_response_waits_min(  );
        return do_get_stats_write_response_waits_min(  );
    endfunction

    function automatic int get_stats_write_response_waits_max(  );
        return do_get_stats_write_response_waits_max(  );
    endfunction

    function automatic int get_stats_write_response_waits_mean(  );
        return do_get_stats_write_response_waits_mean(  );
    endfunction

    function automatic int get_stats_rw_transaction_last_duration(  );
        return do_get_stats_rw_transaction_last_duration(  );
    endfunction

    function automatic int get_stats_AXI_read_last_duration(  );
        return do_get_stats_AXI_read_last_duration(  );
    endfunction

    function automatic int get_stats_AXI_write_last_duration(  );
        return do_get_stats_AXI_write_last_duration(  );
    endfunction

    function automatic int get_stats_read_addr_channel_phase_last_duration(  );
        return do_get_stats_read_addr_channel_phase_last_duration(  );
    endfunction

    function automatic int get_stats_read_data_burst_last_duration(  );
        return do_get_stats_read_data_burst_last_duration(  );
    endfunction

    function automatic int get_stats_read_channel_phase_last_duration(  );
        return do_get_stats_read_channel_phase_last_duration(  );
    endfunction

    function automatic int get_stats_write_addr_channel_phase_last_duration(  );
        return do_get_stats_write_addr_channel_phase_last_duration(  );
    endfunction

    function automatic int get_stats_write_data_burst_last_duration(  );
        return do_get_stats_write_data_burst_last_duration(  );
    endfunction

    function automatic int get_stats_write_channel_phase_last_duration(  );
        return do_get_stats_write_channel_phase_last_duration(  );
    endfunction

    function automatic int get_stats_write_resp_channel_phase_last_duration(  );
        return do_get_stats_write_resp_channel_phase_last_duration(  );
    endfunction


    //------------------------------------------------------------------------------
    // Function to get last database handle
    //------------------------------------------------------------------------------

    function longint get_last_handle();
        return do_get_last_handle();
    endfunction

    //------------------------------------------------------------------------------
    // Function to get last start time
    //------------------------------------------------------------------------------

    function longint get_last_start_time();
        return do_get_last_start_time();
    endfunction

    //------------------------------------------------------------------------------
    // Function to get last end time
    //------------------------------------------------------------------------------

    function longint get_last_end_time();
        return do_get_last_end_time();
    endfunction


    //------------------------------------------------------------------------------
    // Functions to set/get generic interface configuration
    //------------------------------------------------------------------------------

    function void set_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0,
        input int arg10 = 0
    );
        do_set_interface( what, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10 );
    endfunction

    function int get_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0
    );
        return do_get_interface( what, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 );
    endfunction

    //------------------------------------------------------------------------------
    // Functions to get the hierarchic name of this interface
    //------------------------------------------------------------------------------
    function string get_full_name();
        return do_get_full_name();
    endfunction

    //------------------------------------------------------------------------------
    // Functions to set/get the abstraction levels of interface ends
    //------------------------------------------------------------------------------
    function void axi_set_master_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        do_axi_set_master_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi_get_master_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        do_axi_get_master_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi_set_slave_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        do_axi_set_slave_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi_get_slave_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        do_axi_get_slave_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi_set_clock_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        do_axi_set_clock_source_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi_get_clock_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        do_axi_get_clock_source_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi_set_reset_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        do_axi_set_reset_source_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi_get_reset_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        do_axi_get_reset_source_abstraction_level( wire_level, TLM_level );
    endfunction


    //------------------------------------------------------------------------------
    // Interface end access functions
    //------------------------------------------------------------------------------

    function longint get_axi_master_end();
        return do_get_axi_master_end();
    endfunction

    function longint get_axi_slave_end();
        return do_get_axi_slave_end();
    endfunction

    function longint get_axi_clock_source_end();
        return do_get_axi_clock_source_end();
    endfunction

    function longint get_axi_reset_source_end();
        return do_get_axi_reset_source_end();
    endfunction

    function longint get_axi__monitor_end();
        return do_get_axi__monitor_end();
    endfunction


    //------------------------------------------------------------------------------
    // Transaction interface
    //------------------------------------------------------------------------------
    task automatic dvc_activate_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi_size_e size,
        ref axi_burst_e burst,
        ref axi_lock_e lock,
        ref axi_cache_e cache,
        ref axi_prot_e prot,
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [3:0] burst_length,
        ref bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref axi_response_e resp[],
        ref bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        ref bit [7:0] resp_user,
        ref axi_rw_e read_or_write,
        ref int address_to_data_latency,
        ref int data_to_response_latency,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        ref int address_valid_delay,
        ref int data_valid_delay[],
        ref int write_response_valid_delay,
        ref int address_ready_delay,
        ref int data_ready_delay[],
        ref int write_response_ready_delay,
        ref bit write_data_with_address,
        input int _unit_id = 0
    );
        do_dvc_activate_rw_transaction(_comms_semantic, _as_end,addr,size,burst,lock,cache,prot,id,burst_length,data_words,write_strobes,resp,addr_user,data_user,resp_user,read_or_write,address_to_data_latency,data_to_response_latency,write_address_to_data_delay,write_data_to_address_delay,write_data_beats_delay,address_valid_delay,data_valid_delay,write_response_valid_delay,address_ready_delay,data_ready_delay,write_response_ready_delay,write_data_with_address,_unit_id);
    endtask

    task automatic dvc_get_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        ref bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref axi_response_e resp[],
        output bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output axi_rw_e read_or_write,
        output int address_to_data_latency,
        output int data_to_response_latency,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        output int address_valid_delay,
        ref int data_valid_delay[],
        output int write_response_valid_delay,
        output int address_ready_delay,
        ref int data_ready_delay[],
        output int write_response_ready_delay,
        output bit write_data_with_address,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_rw_transaction(_comms_semantic, _as_end,addr,size,burst,lock,cache,prot,id,burst_length,data_words,write_strobes,resp,addr_user,data_user,resp_user,read_or_write,address_to_data_latency,data_to_response_latency,write_address_to_data_delay,write_data_to_address_delay,write_data_beats_delay,address_valid_delay,data_valid_delay,write_response_valid_delay,address_ready_delay,data_ready_delay,write_response_ready_delay,write_data_with_address,_unit_id,_using);
    endtask

    task automatic dvc_activate_AXI_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi_size_e size,
        ref axi_burst_e burst,
        ref axi_lock_e lock,
        ref axi_cache_e cache,
        ref axi_prot_e prot,
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        ref bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        ref int address_to_data_latency,
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int address_valid_delay,
        input int _unit_id = 0
    );
        do_dvc_activate_AXI_read(_comms_semantic, _as_end,addr,size,burst,lock,cache,prot,id,burst_length,data_words,resp,addr_user,data_user,address_to_data_latency,addr_start_time,addr_end_time,data_start_time,data_end_time,address_valid_delay,_unit_id);
    endtask

    task automatic dvc_get_AXI_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        output bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        output int address_to_data_latency,
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output int address_valid_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_AXI_read(_comms_semantic, _as_end,addr,size,burst,lock,cache,prot,id,burst_length,data_words,resp,addr_user,data_user,address_to_data_latency,addr_start_time,addr_end_time,data_start_time,data_end_time,address_valid_delay,_unit_id,_using);
    endtask

    task automatic dvc_activate_AXI_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi_size_e size,
        ref axi_burst_e burst,
        ref axi_lock_e lock,
        ref axi_cache_e cache,
        ref axi_prot_e prot,
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [3:0] burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref axi_response_e resp,
        ref bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        ref bit [7:0] resp_user,
        ref int address_to_data_latency,
        ref int data_to_response_latency,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref longint wr_resp_start_time,
        ref longint wr_resp_end_time,
        ref int address_valid_delay,
        input int _unit_id = 0
    );
        do_dvc_activate_AXI_write(_comms_semantic, _as_end,addr,size,burst,lock,cache,prot,id,burst_length,data_words,write_strobes,resp,addr_user,data_user,resp_user,address_to_data_latency,data_to_response_latency,write_address_to_data_delay,write_data_to_address_delay,write_data_beats_delay,addr_start_time,addr_end_time,data_start_time,data_end_time,wr_resp_start_time,wr_resp_end_time,address_valid_delay,_unit_id);
    endtask

    task automatic dvc_get_AXI_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output axi_response_e resp,
        output bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output int address_to_data_latency,
        output int data_to_response_latency,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output longint wr_resp_start_time,
        output longint wr_resp_end_time,
        output int address_valid_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_AXI_write(_comms_semantic, _as_end,addr,size,burst,lock,cache,prot,id,burst_length,data_words,write_strobes,resp,addr_user,data_user,resp_user,address_to_data_latency,data_to_response_latency,write_address_to_data_delay,write_data_to_address_delay,write_data_beats_delay,addr_start_time,addr_end_time,data_start_time,data_end_time,wr_resp_start_time,wr_resp_end_time,address_valid_delay,_unit_id,_using);
    endtask

    task automatic dvc_activate_data_resp
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref axi_response_e resp,
        ref bit [7:0] data_user [],
        ref bit [7:0] resp_user,
        ref longint data_start,
        ref longint data_end,
        ref longint response_start,
        ref int write_data_beats_delay[],
        ref longint data_beat_start_time[],
        ref longint data_beat_end_time[],
        ref longint response_end_time,
        input int _unit_id = 0
    );
        do_dvc_activate_data_resp(_comms_semantic, _as_end,burst_length,data_words,write_strobes,id,resp,data_user,resp_user,data_start,data_end,response_start,write_data_beats_delay,data_beat_start_time,data_beat_end_time,response_end_time,_unit_id);
    endtask

    task automatic dvc_get_data_resp
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output axi_response_e resp,
        ref bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output longint data_start,
        output longint data_end,
        output longint response_start,
        ref int write_data_beats_delay[],
        ref longint data_beat_start_time[],
        ref longint data_beat_end_time[],
        output longint response_end_time,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_data_resp(_comms_semantic, _as_end,burst_length,data_words,write_strobes,id,resp,data_user,resp_user,data_start,data_end,response_start,write_data_beats_delay,data_beat_start_time,data_beat_end_time,response_end_time,_unit_id,_using);
    endtask

    task automatic dvc_put_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0
    );
        do_dvc_put_read_data_burst(_comms_semantic, _as_end,burst_length,data_words,resp,id,data_user,data_start_time,data_end_time,_unit_id);
    endtask

    task automatic dvc_get_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_data_burst(_comms_semantic, _as_end,burst_length,data_words,resp,id,data_user,data_start_time,data_end_time,_unit_id,_using);
    endtask

    task automatic dvc_put_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref int write_data_beats_delay[],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0
    );
        do_dvc_put_write_data_burst(_comms_semantic, _as_end,burst_length,data_words,write_strobes,id,data_user,write_data_beats_delay,data_start_time,data_end_time,_unit_id);
    endtask

    task automatic dvc_get_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref int write_data_beats_delay[],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_data_burst(_comms_semantic, _as_end,burst_length,data_words,write_strobes,id,data_user,write_data_beats_delay,data_start_time,data_end_time,_unit_id,_using);
    endtask

    task automatic dvc_put_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
        do_dvc_put_read_addr_channel_phase(_comms_semantic, _as_end,addr,burst_length,size,burst,lock,cache,prot,id,addr_user,address_valid_delay,address_ready_delay,_unit_id);
    endtask

    task automatic dvc_get_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_addr_channel_phase(_comms_semantic, _as_end,addr,burst_length,size,burst,lock,cache,prot,id,addr_user,address_valid_delay,address_ready_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int data_ready_delay,
        input int _unit_id = 0
    );
        do_dvc_put_read_channel_phase(_comms_semantic, _as_end,last,data,resp,id,data_user,data_ready_delay,_unit_id);
    endtask

    task automatic dvc_get_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_channel_phase(_comms_semantic, _as_end,last,data,resp,id,data_user,data_ready_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
        do_dvc_put_write_addr_channel_phase(_comms_semantic, _as_end,addr,burst_length,size,burst,lock,cache,prot,id,addr_user,address_valid_delay,address_ready_delay,_unit_id);
    endtask

    task automatic dvc_get_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_addr_channel_phase(_comms_semantic, _as_end,addr,burst_length,size,burst,lock,cache,prot,id,addr_user,address_valid_delay,address_ready_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int data_ready_delay,
        input int _unit_id = 0
    );
        do_dvc_put_write_channel_phase(_comms_semantic, _as_end,last,data,write_strobes,id,data_user,data_ready_delay,_unit_id);
    endtask

    task automatic dvc_get_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_channel_phase(_comms_semantic, _as_end,last,data,write_strobes,id,data_user,data_ready_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] resp_user,
        input int write_response_ready_delay,
        input int _unit_id = 0
    );
        do_dvc_put_write_resp_channel_phase(_comms_semantic, _as_end,resp,id,resp_user,write_response_ready_delay,_unit_id);
    endtask

    task automatic dvc_get_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] resp_user,
        output int write_response_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_resp_channel_phase(_comms_semantic, _as_end,resp,id,resp_user,write_response_ready_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int _unit_id = 0
    );
        do_dvc_put_read_addr_channel_cycle(_comms_semantic, _as_end,addr,burst_length,size,burst,lock,cache,prot,id,addr_user,_unit_id);
    endtask

    task automatic dvc_get_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_addr_channel_cycle(_comms_semantic, _as_end,addr,burst_length,size,burst,lock,cache,prot,id,addr_user,_unit_id,_using);
    endtask

    task automatic dvc_put_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        do_dvc_put_read_addr_channel_ready(_comms_semantic, _as_end,ready,_unit_id);
    endtask

    task automatic dvc_get_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_addr_channel_ready(_comms_semantic, _as_end,ready,_unit_id,_using);
    endtask

    task automatic dvc_put_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int _unit_id = 0
    );
        do_dvc_put_read_channel_cycle(_comms_semantic, _as_end,last,data,resp,id,data_user,_unit_id);
    endtask

    task automatic dvc_get_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_channel_cycle(_comms_semantic, _as_end,last,data,resp,id,data_user,_unit_id,_using);
    endtask

    task automatic dvc_put_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        do_dvc_put_read_channel_ready(_comms_semantic, _as_end,ready,_unit_id);
    endtask

    task automatic dvc_get_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_channel_ready(_comms_semantic, _as_end,ready,_unit_id,_using);
    endtask

    task automatic dvc_put_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int _unit_id = 0
    );
        do_dvc_put_write_addr_channel_cycle(_comms_semantic, _as_end,addr,burst_length,size,burst,lock,cache,prot,id,addr_user,_unit_id);
    endtask

    task automatic dvc_get_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_addr_channel_cycle(_comms_semantic, _as_end,addr,burst_length,size,burst,lock,cache,prot,id,addr_user,_unit_id,_using);
    endtask

    task automatic dvc_put_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        do_dvc_put_write_addr_channel_ready(_comms_semantic, _as_end,ready,_unit_id);
    endtask

    task automatic dvc_get_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_addr_channel_ready(_comms_semantic, _as_end,ready,_unit_id,_using);
    endtask

    task automatic dvc_put_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  strb,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int _unit_id = 0
    );
        do_dvc_put_write_channel_cycle(_comms_semantic, _as_end,last,data,strb,id,data_user,_unit_id);
    endtask

    task automatic dvc_get_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  strb,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_channel_cycle(_comms_semantic, _as_end,last,data,strb,id,data_user,_unit_id,_using);
    endtask

    task automatic dvc_put_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        do_dvc_put_write_channel_ready(_comms_semantic, _as_end,ready,_unit_id);
    endtask

    task automatic dvc_get_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_channel_ready(_comms_semantic, _as_end,ready,_unit_id,_using);
    endtask

    task automatic dvc_put_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] resp_user,
        input int _unit_id = 0
    );
        do_dvc_put_write_resp_channel_cycle(_comms_semantic, _as_end,resp,id,resp_user,_unit_id);
    endtask

    task automatic dvc_get_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] resp_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_resp_channel_cycle(_comms_semantic, _as_end,resp,id,resp_user,_unit_id,_using);
    endtask

    task automatic dvc_put_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        do_dvc_put_write_resp_channel_ready(_comms_semantic, _as_end,ready,_unit_id);
    endtask

    task automatic dvc_get_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_resp_channel_ready(_comms_semantic, _as_end,ready,_unit_id,_using);
    endtask

    //------------------------------------------------------------------------------
    // Functions to register reports for the interface and interface-ends.
    //------------------------------------------------------------------------------
    //------------------------------------------------------------------------------
    // Tasks for registering reports
    //------------------------------------------------------------------------------
    function void register_interface_reporter( input questa_mvc_reporter _rep = null );
        register_end_point( _interface_ref, _rep );
    endfunction

    function void register_master_reporter
    (
        input questa_mvc_reporter rep = null
    );
        do_register_master_reporter( rep );
    endfunction

    function void register_slave_reporter
    (
        input questa_mvc_reporter rep = null
    );
        do_register_slave_reporter( rep );
    endfunction

    function void register_clock_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
        do_register_clock_source_reporter( rep );
    endfunction

    function void register_reset_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
        do_register_reset_source_reporter( rep );
    endfunction

endclass

    (* elab_init *) axi_implementation_class #(AXI_ADDRESS_WIDTH, AXI_RDATA_WIDTH, AXI_WDATA_WIDTH, AXI_ID_WIDTH) this_interface_class = new();

    //------------------------------------------------------------------------------
    //
    // FUNCTION: get_interface_class
    //     Return a handle to the <axi_interface_class> API for this interface
    //
    //------------------------------------------------------------------------------
    function axi_interface_class #(AXI_ADDRESS_WIDTH, AXI_RDATA_WIDTH, AXI_WDATA_WIDTH, AXI_ID_WIDTH) get_interface_class();
        return this_interface_class;
    endfunction

endinterface

`endif // INCA
`ifdef VCS
// *****************************************************************************
//
// Copyright 2007-2013 Mentor Graphics Corporation
// All Rights Reserved.
//
// THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION WHICH IS THE PROPERTY OF
// MENTOR GRAPHICS CORPORATION OR ITS LICENSORS AND IS SUBJECT TO LICENSE TERMS.
//
// *****************************************************************************
// SystemVerilog           Version: 20130911_Questa_10.2c
// *****************************************************************************

// Title: axi
//

import QUESTA_MVC::questa_mvc_reporter;
import QUESTA_MVC::questa_mvc_item_comms_semantic;
import QUESTA_MVC::questa_mvc_edge;
import QUESTA_MVC::QUESTA_MVC_POSEDGE;
import QUESTA_MVC::QUESTA_MVC_NEGEDGE;
import QUESTA_MVC::QUESTA_MVC_ANYEDGE;
import QUESTA_MVC::QUESTA_MVC_0_TO_1_EDGE;
import QUESTA_MVC::QUESTA_MVC_1_TO_0_EDGE;

//------------------------------------------------------------------------------
//
// Interface:- axi
//
//------------------------------------------------------------------------------
//  This interface contains all the wires and BFM configuration variables.
// 
// For all Configuration variables set/get/wait functions are available in the
// interface.
// 
// For e.g.
// 
// bit config_master_write_delay:
// 
// >   function void set_config_master_write_delay( bit arg1 )
// >
// >   function bit get_config_master_write_delay()
// >
// >   task wait_for_config_master_write_delay()
// 
// bit [255:0] config_enable_assertion:
// 
// >     task wait_for_config_enable_assertion()
// >     
// >     task wait_for_config_enable_assertion_index1( input int _this_dot_1 )
// >     
// >     function void set_config_enable_assertion( bit [255:0] arg2 )
// >     
// >     function set_config_enable_assertion_index1( int _this_dot_1, bit  arg3 )
// >     
// >     function bit [255:0]  get_config_enable_assertion()
// >     
// >     function bit get_config_enable_assertion_index1( int _this_dot_1 ) 
// >
// 
//------------------------------------------------------------------------------
(* cy_so="libaxi_IN_SystemVerilog_MTI_full" *)
(* on_lib_load="axi_IN_SystemVerilog_load" *)
interface mgc_common_axi
    #(int AXI_ADDRESS_WIDTH = 64, int AXI_RDATA_WIDTH = 1024, int AXI_WDATA_WIDTH = 1024, int AXI_ID_WIDTH = 18)
    (input wire iACLK, input wire iARESETn);
    // Constant: AXI_ADDRESS_WIDTH
    //
    // The width of the AWADDR and ARADDR signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2).
    //

    // Constant: AXI_RDATA_WIDTH
    //
    // The width of the RDATA signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6).
    //

    // Constant: AXI_WDATA_WIDTH
    //
    // The width of the WDATA signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.3).
    //

    // Constant: AXI_ID_WIDTH
    //
    // The width of the AWID, ARID, WID, RID and BID signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2).
    //

    //------------------------------------------------------------------------------
    //
    // Wires for interface: axi
    //
    //------------------------------------------------------------------------------

    // Wire: ACLK
    //
    //------------------------------------------------------------------------------
    // 
    //       Global Clock Signal
    //     
    //------------------------------------------------------------------------------
    wire ACLK;

    // Wire: ARESETn
    //
    //------------------------------------------------------------------------------
    // 
    //       Global Reset Signal. This signal is Active Low.
    //     
    //------------------------------------------------------------------------------
    wire ARESETn;

    // Wire: AWVALID
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Address Valid. 
    // 
    //       The source of this signal is Master and this signal indicates 
    //       that valid write address and control information are available.
    //     
    //------------------------------------------------------------------------------
    wire AWVALID;

    // Wire: AWADDR
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Address Signal.
    // 
    //       The source of this signal is Master.
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_ADDRESS_WIDTH) - 1):0]  AWADDR;

    // Wire: AWLEN
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Burst Length Signal.
    // 
    //       The source of this signal is Master.
    //       The width of this signal is set to 10 by default. If the signal width of 4 is required, a wrapper can be made over the dut to do so.
    //     
    //------------------------------------------------------------------------------
    wire [3:0] AWLEN;

    // Wire: AWSIZE
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Burst Size Signal.
    // 
    //       The source of this signal is Master.
    //     
    //------------------------------------------------------------------------------
    wire [2:0] AWSIZE;

    // Wire: AWBURST
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Burst Type Signal.
    // 
    //       The source of this signal is Master.
    //     
    //------------------------------------------------------------------------------
    wire [1:0] AWBURST;

    // Wire: AWLOCK
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Lock Type Signal. 
    // 
    //       The source of this signal is Master and this signal provides the 
    //       atomic characteristics of the transfer.
    //     
    //------------------------------------------------------------------------------
    wire [1:0] AWLOCK;

    // Wire: AWCACHE
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Cache type Signal. 
    // 
    //       The source of this signal is Master and this signal indicates the 
    //       bufferable, cacheable, write-through, write-back, and allocate 
    //       attributes of the transaction.
    //     
    //------------------------------------------------------------------------------
    wire [3:0] AWCACHE;

    // Wire: AWPROT
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Protection Type Signal. 
    // 
    //       The source of this signal is Master and this signal indicates the 
    //       normal, privileged, or secure protection level of the transaction 
    //       and whether it is a data access or instruction access.
    //     
    //------------------------------------------------------------------------------
    wire [2:0] AWPROT;

    // Wire: AWID
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Address ID.
    // 
    //       The source of this signal is Master and this signal is the 
    //       identification tag for the write address group of signals.
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_ID_WIDTH) - 1):0]  AWID;

    // Wire: AWREADY
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Address Ready Signal.
    // 
    //       The source of this signal is Slave and this signal indicates that 
    //       the valid write address and control information are available.
    //     
    //------------------------------------------------------------------------------
    wire AWREADY;

    // Wire: AWUSER
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Address User Signal.
    //     
    //------------------------------------------------------------------------------
    wire [7:0] AWUSER;

    // Wire: ARVALID
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Address Valid. 
    // 
    //       The source of this signal is Master and this signal indicates that 
    //       valid write address and control information are available.
    //     
    //------------------------------------------------------------------------------
    wire ARVALID;

    // Wire: ARADDR
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Address Signal.
    // 
    //       The source of this signal is Master.
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_ADDRESS_WIDTH) - 1):0]  ARADDR;

    // Wire: ARLEN
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Burst Length Signal.
    // 
    //       The source of this signal is Master.
    //       The width of this signal is set to 10 by default. If the signal width of 4 is required, a wrapper can be made over the dut to do so.
    //     
    //------------------------------------------------------------------------------
    wire [3:0] ARLEN;

    // Wire: ARSIZE
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Burst Size Signal.
    // 
    //       The source of this signal is Master.
    //     
    //------------------------------------------------------------------------------
    wire [2:0] ARSIZE;

    // Wire: ARBURST
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Burst Type Signal.
    // 
    //       The source of this signal is Master.
    //     
    //------------------------------------------------------------------------------
    wire [1:0] ARBURST;

    // Wire: ARLOCK
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Lock Type Signal. 
    // 
    //       The source of this signal is Master and this signal provides the 
    //       atomic characteristics of the transfer.
    //     
    //------------------------------------------------------------------------------
    wire [1:0] ARLOCK;

    // Wire: ARCACHE
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Cache type Signal. 
    // 
    //       The source of this signal is Master and this signal indicates the 
    //       bufferable, cacheable, write-through, write-back, and allocate 
    //       attributes of the transaction.
    //     
    //------------------------------------------------------------------------------
    wire [3:0] ARCACHE;

    // Wire: ARPROT
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Protection Type Signal. 
    // 
    //       The source of this signal is Master and this signal indicates the 
    //       normal, privileged, or secure protection level of the transaction 
    //       and whether it is a data access or instruction access.
    //     
    //------------------------------------------------------------------------------
    wire [2:0] ARPROT;

    // Wire: ARID
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Address ID.
    // 
    //       The source of this signal is Master and this signal is the 
    //       identification tag for the write address group of signals.
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_ID_WIDTH) - 1):0]  ARID;

    // Wire: ARREADY
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Address Ready Signal.
    // 
    //       The source of this signal is Slave and this signal indicates that 
    //       the valid write address and control information are available.
    //     
    //------------------------------------------------------------------------------
    wire ARREADY;

    // Wire: ARUSER
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Address User Signal.
    //     
    //------------------------------------------------------------------------------
    wire [7:0] ARUSER;

    // Wire: RVALID
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Valid Signal.
    // 
    //       The source of this signal is Slave and this signal indicates that 
    //       the read data is available and read transfer can complete.
    //     
    //------------------------------------------------------------------------------
    wire RVALID;

    // Wire: RLAST
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Last Signal.
    // 
    //       The source of this signal is Slave and this signal indicates 
    //       the last transfer in the read burst.
    //     
    //------------------------------------------------------------------------------
    wire RLAST;

    // Wire: RDATA
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Data Signal.
    // 
    //       The source of this signal is Slave and the read data bus can be 
    //       8, 16, 24, 32, 64, 128, 256, 512 or 1024 bits wide. 
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_RDATA_WIDTH) - 1):0]  RDATA;

    // Wire: RRESP
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Response Signal.
    // 
    //       The source of this signal is Slave and it indicates the status of read transfer.
    //       The allowable responses are OKAY, EXOKAY, SLVERR and DECERR. 
    //     
    //------------------------------------------------------------------------------
    wire [1:0] RRESP;

    // Wire: RID
    //
    //------------------------------------------------------------------------------
    // 
    //       Read ID Tag Signal.
    // 
    //       The source of this signal is Slave and it is the ID tag of the read data 
    //       group of signals.
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_ID_WIDTH) - 1):0]  RID;

    // Wire: RREADY
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Ready Signal.
    // 
    //       The source of this signal is Master and it indicates that the Master can
    //       accept the read data and response information.
    //     
    //------------------------------------------------------------------------------
    wire RREADY;

    // Wire: RUSER
    //
    //------------------------------------------------------------------------------
    // 
    //       Read Data User Signal.
    //     
    //------------------------------------------------------------------------------
    wire [7:0] RUSER;

    // Wire: WVALID
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Valid Signal.
    // 
    //       The source of this signal is Master and this signal indicates that 
    //       the read data is available and read transfer can complete.
    //     
    //------------------------------------------------------------------------------
    wire WVALID;

    // Wire: WLAST
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Last Signal.
    // 
    //       The source of this signal is Master and this signal indicates 
    //       the last transfer in the read burst.
    //     
    //------------------------------------------------------------------------------
    wire WLAST;

    // Wire: WDATA
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Data Signal.
    // 
    //       The source of this signal is Master and the read data bus can be 
    //       8, 16, 24, 32, 64, 128, 256, 512 or 1024 bits wide. 
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_WDATA_WIDTH) - 1):0]  WDATA;

    // Wire: WSTRB
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Strobes Signal.
    // 
    //       The source of this signal is Master and this signal indicates which 
    //       byte lanes to update in the memory.
    //     
    //------------------------------------------------------------------------------
    wire [(((AXI_WDATA_WIDTH / 8)) - 1):0]  WSTRB;

    // Wire: WID
    //
    //------------------------------------------------------------------------------
    // 
    //       Write ID Tag Signal.
    // 
    //       The source of this signal is Master and it is the ID tag of the write 
    //       data transfer.
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_ID_WIDTH) - 1):0]  WID;

    // Wire: WREADY
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Ready Signal.
    // 
    //       The source of this signal is Slave and it indicates that the Slave can
    //       accept the write data.
    //     
    //------------------------------------------------------------------------------
    wire WREADY;

    // Wire: WUSER
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Data User Signal.
    //     
    //------------------------------------------------------------------------------
    wire [7:0] WUSER;

    // Wire: BVALID
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Response Valid Signal.
    // 
    //       The source of this signal is Slave and it indicates that a valid write
    //       response is available.
    //     
    //------------------------------------------------------------------------------
    wire BVALID;

    // Wire: BRESP
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Response Signal.
    // 
    //       The source of this signal is Slave and it indicates the status of the 
    //       write transaction. The allowable responses are OKAY, EXOKAY, SLVERR 
    //       and DECERR.
    //     
    //------------------------------------------------------------------------------
    wire [1:0] BRESP;

    // Wire: BID
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Response ID Signal.
    // 
    //       The source of this signal is Slave and it indicates the identifciation 
    //       tag of a write response.
    //     
    //------------------------------------------------------------------------------
    wire [((AXI_ID_WIDTH) - 1):0]  BID;

    // Wire: BREADY
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Response Ready Signal.
    // 
    //       The source of this signal is Master and it indicates that the master 
    //       can accept the response information.
    //     
    //------------------------------------------------------------------------------
    wire BREADY;

    // Wire: BUSER
    //
    //------------------------------------------------------------------------------
    // 
    //       Write Response User Signal.
    //     
    //------------------------------------------------------------------------------
    wire [7:0] BUSER;

    // Propagate global signals onto interface wires
    assign ACLK = iACLK;
    assign ARESETn = iARESETn;

    //------------------------------------------------------------------------------
    // Global Variables - config
    //------------------------------------------------------------------------------

    // Variable:- config_clk_init_value
    //
    // 
    //     Initial value of the clock signal generated by the AXI MVC built-in clock generator.
    //   
    //
    bit config_clk_init_value;

    // Variable:- config_clk_phase_shift
    //
    // 
    //     Number of time units to hold the initial value of the clock signal generated by the AXI
    //     MVC built-in clock generator. 
    //   
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    int config_clk_phase_shift;

    // Variable:- config_clk_1st_time
    //
    // 
    //     Number of time units for the first phase of the clock signal generated by the AXI MVC
    //     built-in clock generator.
    //   
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    int config_clk_1st_time;

    // Variable:- config_clk_2nd_time
    //
    // 
    //     Number of time units for the second phase of the clock signal generated by the AXI MVC
    //     built-in clock generator.
    //   
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    int config_clk_2nd_time;

    // Variable:- config_setup_time
    //
    // 
    //     Number of time units for the setup time to the active clock edge of ACLK.
    //   
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    int config_setup_time;

    // Variable:- config_hold_time
    //
    // 
    //     Number of time units for the hold time to the active clock edge of ACLK.
    //   
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    int config_hold_time;

    // Variable:- config_max_transaction_time_factor
    //
    //  This timeout "config_max_transaction_time_factor" is the timeout that sets the maximum timeout within which any read/write transaction is 
    //        expected to occur (and in turn all individual phases as well) of the AXI interface. 
    //        This timeout should be set as the maximum duration of read/write. 
    //        In short it indicates the maximum duration of a read/write transaction (From start of transaction to end of it).
    //        Its default value is 100000 clock cycles
    //     
    //
    int unsigned config_max_transaction_time_factor;

    // Variable:- config_timeout_max_data_transfer
    //
    //  This timeout "config_timeout_max_data_transfer" is actually a configuration which tells about the maximum number of write data beats that the AXI interface
    //       can generate as part of write data burst of write transfer. 
    //       It is actually not a timeout value and is the maximum number of beats of Write data that are expected. 
    //
    int config_timeout_max_data_transfer;

    // Variable:- config_burst_timeout_factor
    //
    // This timeout "config_burst_timeout_factor" represents the maximum delay between the individual phases of the AXI transactions.
    //      For example between read address phase and read data phase, write address and Write data phases. 
    //      If this delay exceeds between the phases then transaction will be  timed out.
    //      Its default value is 10000 clock cycles
    //     
    //
    int unsigned config_burst_timeout_factor;

    // Variable:- config_max_latency_AWVALID_assertion_to_AWREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <AWVALID> to the assertion of <AWREADY> (default 10000).
    // 
    // The error message <AXI_AWREADY_NOT_ASSERTED_AFTER_AWVALID> will be issued if this period elapses from the assertion of <AWVALID>.
    // 
    //
    int unsigned config_max_latency_AWVALID_assertion_to_AWREADY;

    // Variable:- config_max_latency_ARVALID_assertion_to_ARREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <ARVALID> to the assertion of <ARREADY> (default 10000).
    // 
    // The error message <AXI_ARREADY_NOT_ASSERTED_AFTER_ARVALID> will be issued if this period elapses from the assertion of <ARVALID>.
    // 
    //
    int unsigned config_max_latency_ARVALID_assertion_to_ARREADY;

    // Variable:- config_max_latency_RVALID_assertion_to_RREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <RVALID> to the assertion of <RREADY> (default 10000).
    // 
    // The error message <AXI_RREADY_NOT_ASSERTED_AFTER_RVALID> will be issued if this period elapses from the assertion of <RVALID>.
    // 
    //
    int unsigned config_max_latency_RVALID_assertion_to_RREADY;

    // Variable:- config_max_latency_BVALID_assertion_to_BREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <BVALID> to the assertion of <BREADY> (default 10000).
    // 
    // The error message <AXI_BREADY_NOT_ASSERTED_AFTER_BVALID> will be issued if this period elapses from the assertion of <BVALID>.
    // 
    //
    int unsigned config_max_latency_BVALID_assertion_to_BREADY;

    // Variable:- config_max_latency_WVALID_assertion_to_WREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <WVALID> to the assertion of <WREADY> (default 10000).
    // 
    // The error message <AXI_WREADY_NOT_ASSERTED_AFTER_WVALID> will be issued if this period elapses from the assertion of <WVALID>.
    // 
    //
    int unsigned config_max_latency_WVALID_assertion_to_WREADY;

    // Variable:- config_write_ctrl_first_ratio
    //
    // Data starts at same time as or after control phase.  Response follows data.
    //
    int config_write_ctrl_first_ratio;

    // Variable:- config_write_data_first_ratio
    //
    // control phase starts at same time as or after data phase.  Response follows data.
    //
    int config_write_data_first_ratio;

    // Variable:- config_write_ctrl_to_data_mintime
    //
    // Number of clocks from the start of control to the start of data in a write. This configuration parameter has been deprecated and maintained for backward compatibility. Instead use write_address_to_data_delay variable to control delay between write address phase and write data phase.
    //
    int unsigned config_write_ctrl_to_data_mintime;

    // Variable:- config_write_data_to_ctrl_mintime
    //
    // Number of clocks from the start of data to the start of control in a write
    //
    int unsigned config_write_data_to_ctrl_mintime;

    // Variable:- config_master_write_delay
    //
    // To configure the write sequence item delays to be inserted.
    //
    bit config_master_write_delay;

    // Variable:- config_reset_low_clocks
    //
    // 
    //     Number of clock cycles to hold the reset signal generated by the AXI MVC built-in reset
    //     generator at the start of an OVM test.
    //   
    //
    int config_reset_low_clocks;

    // Variable:- config_reset_hold_time
    //
    // 
    //     Number of time units to delay changing the reset signal generated by the AXI MVC
    //     built-in reset generator after a clock edge.
    //   
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    int config_reset_hold_time;

    // Variable:- config_protect_ready
    //
    // 
    //     Boolean to set ready stripes as protected (so don't recognize) 
    //   
    //
    bit config_protect_ready;

    // Variable:- config_enable_user_sideband
    //
    // 
    //     To enable the user sideband.
    //   
    //
    bit config_enable_user_sideband;

    // Variable:- config_extended_length_enable
    //
    // 
    //     To enable the extended burst length feature.
    //   
    //
    bit config_extended_length_enable;

    // Variable:- config_enable_burst_reserved_value
    //
    //  A configuration parameter to control the generation (within the QVIP) and coverage collection of the <axi_burst_e> reserved value AXI_BURST_RSVD
    //   when it is allowed as a legal value for the 'burst' parameter of <axi_master_AXI_write>/<axi_master_AXI_read>.
    // 
    //   1'b0 - randomized generation by the master and coverage collection by <axi_functional_coverage> is not performed for the <axi_burst_e> reserved value AXI_BURST_RSVD (default).
    //   1'b1 - randomized generation by the master and coverage collection by <axi_functional_coverage> is performed for the <axi_burst_e> reserved value AXI_BURST_RSVD.
    //   
    //
    bit config_enable_burst_reserved_value;

    // Variable:- config_enable_lock_reserved_value
    //
    //  A configuration parameter to control the coverage collection of the <axi_lock_e> reserved value AXI_LOCK_RSVD when it is allowed as a legal value for the 'lock'
    //   parameter of <axi_master_AXI_write>/<axi_master_AXI_read>.
    // 
    //   1'b0 - randomized generation by the master and coverage collection by <axi_functional_coverage> is not performed for the <axi_lock_e> reserved value AXI_LOCK_RSVD (default).
    //   1'b1 - randomized generation by the master and coverage collection by <axi_functional_coverage> is performed for the <axi_lock_e> reserved value AXI_LOCK_RSVD.
    //   
    //
    bit config_enable_lock_reserved_value;

    // Variable:- config_enable_cache_reserved_value
    //
    //  A configuration parameter to control the coverage collection of the <axi_cache_e> reserved values AXI_CACHE_RSVD0, AXI_CACHE_RSVD1
    //   AXI_CACHE_RSVD2 AXI_CACHE_RSVD3, AXI_CACHE_RSVD4, AXI_CACHE_RSVD5 when they are allowed as legal values for the 'cache'
    //   parameter of <axi_master_AXI_write>/<axi_master_AXI_read>.
    // 
    //   1'b0 - randomized generation by the master and coverage collection by <axi_functional_coverage> is not performed for the <axi_cache_e> reserved values(default).
    //   1'b1 - randomized generation by the master and coverage collection by <axi_functional_coverage> is performed for the <axi_cache_e> reserved values(default).
    //   
    //
    bit config_enable_cache_reserved_value;

    // Variable:- config_enable_all_assertions
    //
    // 
    //   Configuration parameter controlling whether the error messages(Assertions) issued from the QVIP are Enabled or Disabled.  
    //   By default, it is enabled.
    // 
    //
    bit config_enable_all_assertions;

    // Variable:- config_enable_assertion
    //
    // 
    //   An array of configuration parameters controlling whether specific error messages(Assertion) (of type <axi_assertion_type_e>)
    //   can be issued by the QVIP. By default, all errors are enabled. To suppress a particular error, set the corresponding bit to 0.
    //   e.g. config.m_bfm.set_config_enable_error_index1(AXI_RESET_SIGNAL_Z, 0);
    // 
    //
    bit [255:0] config_enable_assertion;

    // Variable:- config_enable_error
    //
    //  
    //   This configuration parameter has been deprecated and maintained for backward compatibility
    // 
    //
    bit [255:0] config_enable_error;

    // Variable:- config_enable_errors
    //
    //  
    //   This configuration parameter has been deprecated and maintained for backward compatibility
    // 
    //
    bit config_enable_errors;

    // Variable:- config_enable_all_assertion_errors
    //
    //  This configuration parameter has been deprecated and maintained for backward compatibility
    // 
    //
    bit config_enable_all_assertion_errors;

    // Variable:- config_abstraction_level
    //
    // 
    //     To set the Abstraction Level. 
    //   
    //
    axi_abstraction_level_e config_abstraction_level;

    // Variable:- config_slave_start_addr
    //
    // 
    //    A configuration parameter indicating start address for slave.
    //   
    //
    bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr;

    // Variable:- config_slave_end_addr
    //
    // 
    //    A configuration parameter indicating end address for slave.
    //   
    //
    bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr;

    // Variable:- config_enable_slave_addr_range_in_bfm
    //
    // 
    //    A configuration parameter indicating whether slave start and end address provided in bfm is valid or not.
    //    If set to 1 then slave start and end address provided in bfm will be considered valid.
    //   
    //
    bit config_enable_slave_addr_range_in_bfm;

    // Variable:- config_read_data_reordering_depth
    //
    // 
    //    A configuration parameter defining the read reordering depth of the slave end of the interface (SPEC3(A5.3.1)).
    // 
    //    Responses from the first <config_read_data_reordering_depth> outstanding read transactions, each with address <ARID> values different from any
    //    earlier outstanding read transaction(as seen by the slave) are expected, interleaved at random. A violation causes a <AXI_READ_REORDERING_VIOLATION> error.
    // 
    //    The default value of <config_read_data_reordering_depth> is (1 << AXI_ID_WIDTH), so that the slave is expected to process all transactions in any order (up to uniqueness of <ARID>).
    // 
    //    For a given <AXI_ID_WIDTH> parameter value, the maximum possible value of <config_read_data_reordering_depth> is 2**AXI_ID_WIDTH. The <AXI_PARAM_READ_REORDERING_DEPTH_EXCEEDS_MAX_ID>
    //    error report will be issued if <config_read_data_reordering_depth> exceeds this value.
    // 
    //    If the user-supplied value is 0, the <AXI4_PARAM_READ_REORDERING_DEPTH_EQUALS_ZERO> error will be issued, and the value will be set to 1.
    //   
    //
    int unsigned config_read_data_reordering_depth;

    // Variable:- config_enable_read_data_reordering_depth_in_bfm
    //
    // 
    //    A configuration parameter indicating whether read data reordering depth provided in bfm is valid or not.
    //    If set to 1 then read data reordering depth in bfm will be considered valid.
    //   
    //
    bit config_enable_read_data_reordering_depth_in_bfm;

    // Variable:- config_awid_wid_mismatch
    //
    // 
    //     Configuration to set a AWID WID mismatch error.
    //   
    //
    bit config_awid_wid_mismatch;

    // Variable:- config_length_last_mismatch_error
    //
    // 
    //     Configuration to set a AWLEN last mismatch error.
    //   
    //
    bit config_length_last_mismatch_error;

    // Variable:- config_master_error_position
    //
    // 
    //     To confgure the type of Master Error.
    //   
    //
    axi_error_e config_master_error_position;

    // Variable:- dummy_var
    //
    // 
    //     To configure the assertion type.
    //   
    //
    axi_assertion_type_e dummy_var;

    // Variable:- config_wlast_length
    //
    // 
    //     This configures the length of data phase after which wlast should be asserted.
    //     This has effect only when m_length_last_mismatch_error is set to 1.
    //   
    //
    int config_wlast_length;

    // Variable:- config_wid_for_awid_not_matching
    //
    // 
    //     This configures the value of WID when m_awid_wid_mismatch is set to 1.
    //   
    //
    bit [((AXI_ID_WIDTH) - 1):0]  config_wid_for_awid_not_matching;

    // Variable:- config_support_exclusive_access
    //
    // 
    //     This configures the support for exclusive slave.
    //     If set, it enables the exclusive support in slave.
    //     If cleared, it disables the exclusive support and every exclusive read/write will return OKAY response and 
    //     exclusive write will update the memory.  
    //   
    //
    bit config_support_exclusive_access;

    // Variable:- config_write_data_interleaving_depth
    //
    // 
    //     This configures the maximum number of different write transaction addresses for which write data can be supplied
    //     to the slave.
    //   
    //
    int config_write_data_interleaving_depth;

    // Variable:- status_master_error
    //
    // 
    //     This shows the Status of Master Error.
    //   
    //
    bit [15:0] status_master_error;

    // Variable:- check_total_num_wdata_outstanding
    //
    // 
    //    This variable is set to true and then BFM updates <total_num_wdata_outstanding> and set this variable to false to
    //    notify that required variable has been updated.
    //   
    //
    bit check_total_num_wdata_outstanding;

    // Variable:- total_num_wdata_outstanding
    //
    // 
    //    This represents the total number of outstanding write data bursts. This could be received by setting
    //    <check_total_num_wdata_outstanding> to true and then waiting for same variable to become false.
    //   
    //
    int total_num_wdata_outstanding;

    // Variable:- check_max_num_wdata_outstanding_per_id
    //
    // 
    //    This variable is set to true and then BFM updates <max_num_wdata_outstanding_per_id> and set this variable to false to
    //    notify that required variable has been updated.
    //   
    //
    bit check_max_num_wdata_outstanding_per_id;

    // Variable:- max_num_wdata_outstanding_per_id
    //
    // 
    //    This represents the maximum number of outstanding write data bursts for any id. This could be received by setting
    //    <check_max_num_wdata_outstanding_per_id> to true and then waiting for same variable to become false.
    //   
    //
    int max_num_wdata_outstanding_per_id;

    // Variable:- check_max_num_waddr_outstanding_per_id
    //
    // 
    //    This variable is set to true and then BFM updates <max_num_waddr_outstanding_per_id> and set this variable to false to
    //    notify that required variable has been updated.
    //   
    //
    bit check_max_num_waddr_outstanding_per_id;

    // Variable:- max_num_waddr_outstanding_per_id
    //
    // 
    //    This represents the maximum number of outstanding write address bursts for any id. This could be received by setting
    //    <check_max_num_waddr_outstanding_per_id> to true and then waiting for same variable to become false.
    //   
    //
    int max_num_waddr_outstanding_per_id;

    // Variable:- check_total_num_waddr_outstanding
    //
    // 
    //    This variable is set to true and then BFM updates <total_num_waddr_outstanding> and set this variable to false to
    //    notify that required variable has been updated.
    //   
    //
    bit check_total_num_waddr_outstanding;

    // Variable:- total_num_waddr_outstanding
    //
    // 
    //    This represents the total number of outstanding write address bursts. This could be received by setting
    //    <check_total_num_waddr_outstanding> to true and then waiting for same variable to become false.
    //   
    //
    int total_num_waddr_outstanding;

    // Variable:- status_outstanding_num_for_waddr
    //
    // 
    //     This gives the number of write address phases outstanding with WID of <find_waddr_outstanding_for_wid>
    //     when start_finding_outstanding_waddr is set to 1.
    //   
    //
    int status_outstanding_num_for_waddr;

    // Variable:- start_finding_outstanding_waddr
    //
    //  If set to 1, this variable starts the updation of the variable status_outstanding_num_for_waddr 
    //      with the number of outstanding write address bursts of WID = find_waddr_outstanding_for_wid
    //    
    //
    bit start_finding_outstanding_waddr;

    // Variable:- status_outstanding_num_for_wdata
    //
    // 
    //     This gives the number of write data phases outstanding with WID of <find_wdata_outstanding_for_wid>
    //     when start_finding_outstanding_wdata is set to 1.
    //   
    //
    int status_outstanding_num_for_wdata;

    // Variable:- start_finding_outstanding_wdata
    //
    //  If set to 1, this variable starts the updation of the variable status_outstanding_num_for_wdata 
    //      with the number of outstanding write data bursts of WID = find_wdata_outstanding_for_wid
    //    
    //
    bit start_finding_outstanding_wdata;

    // Variable:- find_waddr_outstanding_for_wid
    //
    //  
    //     This variable is the input WID, for which the number of outstanding write addr phases is
    //     required. If start_finding_outstanding_waddr is set to 1, the variable status_outstanding_num_for_waddr
    //     is updated with the number of outstanding write addr phases with a WID of find_waddr_outstanding_for_wid
    //   
    //
    bit [((AXI_ID_WIDTH) - 1):0]  find_waddr_outstanding_for_wid;

    // Variable:- find_wdata_outstanding_for_wid
    //
    //  
    //     This variable is the input WID, for which the number of outstanding write data phases is
    //     required. If start_finding_outstanding_wdata is set to 1, the variable status_outstanding_num_for_wdata
    //     is updated with the number of outstanding write data phases with a WID of find_wdata_outstanding_for_wid
    //   
    //
    bit [((AXI_ID_WIDTH) - 1):0]  find_wdata_outstanding_for_wid;

    // Variable:- change_in_wdata_outstanding_per_id
    //
    // 
    //     This variable helps to wait for a change in number of outstanding write data phases per id.
    //   
    //
    bit change_in_wdata_outstanding_per_id;

    // Variable:- start_finding_change_in_wdata
    //
    //  This variable keeps a track of a change in the number of outstanding
    //      write data phases for WID find_change_in_wdata_outstanding_for_wid
    //    
    //
    bit start_finding_change_in_wdata;

    // Variable:- find_change_in_wdata_outstanding_for_wid
    //
    //  
    //     This variable is the input WID, for which the change in number of outstanding write data phases is
    //     required. If start_finding_change_in_wdata is set to 1, the variable start_finding_outstanding_wdata
    //     is cleared again when the number of outstanding write data phases with a WID of find_change_in_wdata_outstanding_for_wid
    //     modifies
    //   
    //
    bit [((AXI_ID_WIDTH) - 1):0]  find_change_in_wdata_outstanding_for_wid;

    // Variable:- config_max_outstanding_wr
    //
    int config_max_outstanding_wr;

    // Variable:- config_max_outstanding_rd
    //
    int config_max_outstanding_rd;

    // Variable:- config_error_on_deleted_valid_cycles
    //
    bit config_error_on_deleted_valid_cycles;

    // Variable:- config_stats_enable
    //
    //  A flag to globally enable/disable performance attributes calculation
    // 
    // Flag settings are:
    // - disabled = 1'b0 (default)
    // - enabled  = 1'b1
    // 
    //
    bit config_stats_enable;

    // Variable:- config_stats_enable_AXI_read_occupancy
    //
    //  A configuration flag to enable/disable the read channel occupancy statistics gathering.
    // 
    // The read channel occupancy is calculated as a percentage of time the read channel (or part of it) is occupied
    // and is measured from the first rising clock that an appropriate *VALID signal is asserted.
    // The read channel is deemed to be occupied if there is a read transaction active.
    // An active read transaction does not necessarily relate to activity on any of the read channel buses
    // as there may be gaps of time between the read transaction phases.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_AXI_read_occupancy;

    // Variable:- config_stats_enable_AXI_write_occupancy
    //
    //  A configuration flag to enable/disable the write channel occupancy statistics gathering.
    // 
    // The write channel occupancy is calculated as a percentage of time the write channel (or part of it) is occupied
    // and is measured from the first rising clock that an appropriate *VALID signal is asserted.
    // The write channel is deemed to be occupied if there is a write transaction active.
    // An active write transaction does not necessarily relate to activity on any of the write channel buses
    // as there may be gaps of time between the write transaction phases.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_AXI_write_occupancy;

    // Variable:- config_stats_enable_read_data_occupancy
    //
    //  A configuration flag to enable/disable the read data occupancy statistics gathering.
    // 
    // The read data occupancy is calculated as a percentage of time the read data channel (or part of it) is occupied
    // and is measured from the first rising clock that an appropriate *VALID signal is asserted.
    // The read data channel is deemed to be occupied if there is a read data phase active and is measured
    // at the phase level, giving a true indication of activity.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_read_data_occupancy;

    // Variable:- config_stats_enable_write_data_occupancy
    //
    //  A configuration flag to enable/disable the write data occupancy statistics gathering.
    // 
    // The write data occupancy is calculated as a percentage of time the write data channel (or part of it) is occupied
    // and is measured from the first rising clock that an appropriate *VALID signal is asserted.
    // The write data channel is deemed to be occupied if there is a write data phase active and is measured
    // at the phase level, giving a true indication of activity.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_write_data_occupancy;

    // Variable:- config_stats_enable_read_latency
    //
    //  A configuration flag to enable/disable the read latency statistics gathering.
    // 
    // The read latency is calculated as the number of clock cycles between the read channel phases.
    // It is measured from the clock edge when the first phase ends (*VALID and *READY are high)
    // to when the next phase starts (*VALID is high).
    // 
    // The latencies measured are:
    // -       read address (end) to read data (start). The calculation is updated at the end of the transaction.
    // -       read address (end) to the next read address (start). The calculation is updated when the latter of the two address phases occurs.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_read_latency;

    // Variable:- config_stats_enable_write_latency
    //
    //  A configuration flag to enable/disable the write latency statistics gathering.
    // 
    // The write latency is calculated as the number of clock cycles between the write channel phases.
    // It is measured from the clock edge when the first phase ends (*VALID and *READY are high)
    // to when the next phase starts (*VALID is high).
    // 
    // The latencies measured are:
    // -       write address (end) to write data (start) The calculation is updated at the end of the transaction.
    // -       write data (end) to write response (start). The calculation is updated at the end of the transaction.
    // -       write address (end) to the next write address (start). The calculation is updated when the latter of the two address phases occurs.
    // 
    // Note that the write address/write data latency calculation may result in negative value as the address and data can happen in either order, or in parallel.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_write_latency;

    // Variable:- config_stats_enable_read_address_waits
    //
    //  A configuration flag to enable/disable the read address wait states statistics gathering.
    // 
    // The read address wait is calculated as the length of time a particular address phase is active for, in clock cycles.
    // This is determined by the number of clock cycles between its *VALID and *READY handshake signals.
    // If an address phase lasts a single clock (*VALID and *READY are both high) then the wait is zero.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_read_address_waits;

    // Variable:- config_stats_enable_read_data_waits
    //
    //  A configuration flag to enable/disable the read data wait states statistics gathering.
    // 
    // The read data wait is calculated as the length of time a particular data phase is active for, in clock cycles.
    // This is determined by the number of clock cycles between its *VALID and *READY handshake signals.
    // If a data phase lasts a single clock (*VALID and *READY are both high) then the wait is zero.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_read_data_waits;

    // Variable:- config_stats_enable_write_address_waits
    //
    //  A configuration flag to enable/disable the write address wait states statistics gathering.
    // 
    // The write address wait is calculated as the length of time a particular address phase is active for, in clock cycles.
    // This is determined by the number of clock cycles between its *VALID and *READY handshake signals.
    // If an address phase lasts a single clock (*VALID and *READY are both high) then the wait is zero.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_write_address_waits;

    // Variable:- config_stats_enable_write_data_waits
    //
    //  A configuration flag to enable/disable the write data wait states statistics gathering.
    // 
    // The write data wait is calculated as the length of time a particular data phase is active for, in clock cycles.
    // This is determined by the number of clock cycles between its *VALID and *READY handshake signals.
    // If a data phase lasts a single clock (*VALID and *READY are both high) then the wait is zero.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_write_data_waits;

    // Variable:- config_stats_enable_write_response_waits
    //
    //  A configuration flag to enable/disable the write response wait states statistics gathering.
    // 
    // The write response wait is calculated as the length of time a particular response phase is active for, in clock cycles.
    // This is determined by the number of clock cycles between its *VALID and *READY handshake signals.
    // If a response phase lasts a single clock (*VALID and *READY are both high) then the wait is zero.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_write_response_waits;

    // Variable:- config_stats_enable_read_bandwidth
    //
    //  A configuration flag to enable/disable the read bandwidth statistics gathering.
    // 
    // The read bandwidth is calculated as the amount of data transferred within a sliding window,
    // taking into account the read transfer size parameter.
    // The contribution from any specific read transaction is measured at the end of the transaction.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_read_bandwidth;

    // Variable:- config_stats_enable_write_bandwidth
    //
    //  A configuration flag to enable/disable the write bandwidth statistics gathering.
    // 
    // The write bandwidth is calculated as the amount of data transferred within a sliding window,
    // taking into account the write transfer size parameter.
    // The contribution from any specific write transaction is measured at the end of the transaction.
    // 
    // Flag settings are:
    // - disabled = 1'b0
    // - enabled  = 1'b1 (default)
    // 
    //
    bit config_stats_enable_write_bandwidth;

    // Variable:- config_stats_AXI_read_occupancy_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_AXI_read_occupancy> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_AXI_read_occupancy_step;

    // Variable:- config_stats_AXI_read_occupancy_multiple
    //
    //  A configuration variable for setting the read occupancy multiple of the <config_stats_enable_AXI_read_occupancy> sliding window.
    // 
    // The read occupancy multiple is the number of <config_stats_AXI_read_occupancy_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_AXI_read_occupancy_multiple;

    // Variable:- config_stats_AXI_write_occupancy_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_AXI_write_occupancy> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_AXI_write_occupancy_step;

    // Variable:- config_stats_AXI_write_occupancy_multiple
    //
    //  A configuration variable for setting the write occupancy multiple of the <config_stats_enable_AXI_write_occupancy> sliding window.
    // 
    // The read occupancy multiple is the number of <config_stats_AXI_write_occupancy_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_AXI_write_occupancy_multiple;

    // Variable:- config_stats_read_data_occupancy_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_read_data_occupancy_step;

    // Variable:- config_stats_read_data_occupancy_multiple
    //
    //  A configuration variable for setting the read data occupancy multiple of the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    // The read data occupancy multiple is the number of <config_stats_read_data_occupancy_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_read_data_occupancy_multiple;

    // Variable:- config_stats_write_data_occupancy_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_write_data_occupancy_step;

    // Variable:- config_stats_write_data_occupancy_multiple
    //
    //  A configuration variable for setting the write data occupancy multiple of the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    // The write data occupancy multiple is the number of <config_stats_write_data_occupancy_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_write_data_occupancy_multiple;

    // Variable:- config_stats_read_bandwidth_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_read_bandwidth> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_read_bandwidth_step;

    // Variable:- config_stats_read_bandwidth_multiple
    //
    //  A configuration variable for setting the read bandwidth multiple of the <config_stats_enable_read_bandwidth> sliding window.
    // 
    // The read bandwidth multiple is the number of <config_stats_read_bandwidth_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_read_bandwidth_multiple;

    // Variable:- config_stats_write_bandwidth_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_write_bandwidth> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_write_bandwidth_step;

    // Variable:- config_stats_write_bandwidth_multiple
    //
    //  A configuration variable for setting the write bandwidth multiple of the <config_stats_enable_write_bandwidth> sliding window.
    // 
    // The write bandwidth multiple is the number of <config_stats_write_bandwidth_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_write_bandwidth_multiple;

    // Variable:- config_stats_read_latency_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_read_latency> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_read_latency_step;

    // Variable:- config_stats_read_latency_multiple
    //
    //  A configuration variable for setting the read latency multiple of the <config_stats_enable_read_latency> sliding window.
    // 
    // The read latency multiple is the number of <config_stats_read_latency_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_read_latency_multiple;

    // Variable:- config_stats_write_latency_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_write_latency> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_write_latency_step;

    // Variable:- config_stats_write_latency_multiple
    //
    //  A configuration variable for setting the write latency multiple of the <config_stats_enable_write_latency> sliding window.
    // 
    // The write latency multiple is the number of <config_stats_write_latency_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_write_latency_multiple;

    // Variable:- config_stats_read_address_waits_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_read_address_waits> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_read_address_waits_step;

    // Variable:- config_stats_read_address_waits_multiple
    //
    //  A configuration variable for setting the read address wait states multiple of the <config_stats_enable_read_address_waits> sliding window.
    // 
    // The read address wait states multiple is the number of <config_stats_read_address_waits_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_read_address_waits_multiple;

    // Variable:- config_stats_read_data_waits_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_read_data_waits> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_read_data_waits_step;

    // Variable:- config_stats_read_data_waits_multiple
    //
    //  A configuration variable for setting the read data wait states multiple of the <config_stats_enable_read_data_waits> sliding window.
    // 
    // The read data wait states multiple is the number of <config_stats_read_data_waits_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_read_data_waits_multiple;

    // Variable:- config_stats_write_address_waits_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_write_address_waits> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_write_address_waits_step;

    // Variable:- config_stats_write_address_waits_multiple
    //
    //  A configuration variable for setting the write address wait states multiple of the <config_stats_enable_write_address_waits> sliding window.
    // 
    // The write address wait states multiple is the number of <config_stats_write_address_waits_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_write_address_waits_multiple;

    // Variable:- config_stats_write_data_waits_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_write_data_waits> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_write_data_waits_step;

    // Variable:- config_stats_write_data_waits_multiple
    //
    //  A configuration variable for setting the write data wait states multiple of the <config_stats_enable_write_data_waits> sliding window.
    // 
    // The write data wait states multiple is the number of <config_stats_write_data_waits_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_write_data_waits_multiple;

    // Variable:- config_stats_write_response_waits_step
    //
    //  A configuration variable for setting the step size of the <config_stats_enable_write_response_waits> sliding window.
    // 
    // The step size within the sliding window is measured in clock cycles and defaults to 100.
    // 
    //
    int config_stats_write_response_waits_step;

    // Variable:- config_stats_write_response_waits_multiple
    //
    //  A configuration variable for setting the write response wait states multiple of the <config_stats_enable_write_response_waits> sliding window.
    // 
    // The write response wait states multiple is the number of <config_stats_write_response_waits_step> within the sliding window and defaults to 5.
    // The minimum value can be 1 and the maximum 10.
    // 
    //
    int config_stats_write_response_waits_multiple;

    //------------------------------------------------------------------------------
    // Global Variables - status
    //------------------------------------------------------------------------------

    // Variable:- status_num_reads_waiting_for_resp
    //
    // 
    //     This shows the number of outstanding read transactions
    //   
    //
    int status_num_reads_waiting_for_resp;

    // Variable:- status_num_writes_waiting_for_response
    //
    // 
    //     This shows the number of outstanding write transactions that have not received a response
    //   
    //
    int status_num_writes_waiting_for_response;

    // Variable:- stats_AXI_read_active
    //
    //  A flag for indicating that there is one or more active read transactions.
    // 
    //
    bit stats_AXI_read_active;

    // Variable:- stats_AXI_read_occupancy_sw
    //
    //  A variable for holding the calculation of the read occupancy <config_stats_enable_AXI_read_occupancy> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_AXI_read_occupancy_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_AXI_read_occupancy_sw;

    // Variable:- stats_AXI_read_occupancy_sw_updated
    //
    //  A variable for holding the number of times the <stats_AXI_read_occupancy_sw> and <stats_AXI_read_idle_sw> sliding window statistics
    // have been updated, plus their respective min, max and mean values.
    // The value is incremented after every <config_stats_AXI_read_occupancy_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest value of the following statistics.
    // - <stats_AXI_read_occupancy_sw>
    // - <stats_AXI_read_occupancy_min>
    // - <stats_AXI_read_occupancy_max>
    // - <stats_AXI_read_occupancy_mean>
    // - <stats_AXI_read_idle_sw>
    // - <stats_AXI_read_idle_min>
    // - <stats_AXI_read_idle_max>
    // - <stats_AXI_read_idle_mean>
    // 
    //
    int stats_AXI_read_occupancy_sw_updated;

    // Variable:- stats_AXI_read_idle_sw
    //
    //  A variable for holding the calculation of the read idle <config_stats_enable_AXI_read_occupancy> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_AXI_read_idle_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_AXI_read_idle_sw;

    // Variable:- stats_AXI_read_occupancy_min
    //
    //  A variable for holding the minimum read occupancy metric within the <config_stats_enable_AXI_read_occupancy> sliding window.
    // 
    //
    int stats_AXI_read_occupancy_min;

    // Variable:- stats_AXI_read_idle_min
    //
    //  A variable for holding the minimum read idle metric within the <config_stats_enable_AXI_read_occupancy> sliding window.
    // 
    //
    int stats_AXI_read_idle_min;

    // Variable:- stats_AXI_read_occupancy_max
    //
    //  A variable for holding the maximum read occupancy metric within the <config_stats_enable_AXI_read_occupancy> sliding window.
    // 
    //
    int stats_AXI_read_occupancy_max;

    // Variable:- stats_AXI_read_idle_max
    //
    //  A variable for holding the maximum read idle metric within <config_stats_enable_AXI_read_occupancy> the sliding window.
    // 
    //
    int stats_AXI_read_idle_max;

    // Variable:- stats_AXI_read_occupancy_mean
    //
    //  A variable for holding the mean read occupancy metric within the <config_stats_enable_AXI_read_occupancy> sliding window.
    // 
    //
    int stats_AXI_read_occupancy_mean;

    // Variable:- stats_AXI_read_idle_mean
    //
    //  A variable for holding the mean read idle metric within the <config_stats_enable_AXI_read_occupancy> sliding window.
    // 
    //
    int stats_AXI_read_idle_mean;

    // Variable:- stats_AXI_write_active
    //
    //  A flag for indicating that there is one or more active write transactions.
    // 
    //
    bit stats_AXI_write_active;

    // Variable:- stats_AXI_write_occupancy_sw
    //
    //  A variable for holding the calculation of the write occupancy sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_AXI_write_occupancy_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_AXI_write_occupancy_sw;

    // Variable:- stats_AXI_write_occupancy_sw_updated
    //
    //  A variable for holding the number of times the <stats_AXI_write_occupancy_sw> and <stats_AXI_write_idle_sw> sliding window statistics
    // have been updated, plus their respective min, max and mean values.
    // The value is incremented after every <config_stats_AXI_write_occupancy_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest values of the following statistics.
    // - <stats_AXI_write_occupancy_sw>
    // - <stats_AXI_write_occupancy_min>
    // - <stats_AXI_write_occupancy_max>
    // - <stats_AXI_write_occupancy_mean>
    // - <stats_AXI_write_idle_sw>
    // - <stats_AXI_write_idle_min>
    // - <stats_AXI_write_idle_max>
    // - <stats_AXI_write_idle_mean>
    // 
    //
    int stats_AXI_write_occupancy_sw_updated;

    // Variable:- stats_AXI_write_idle_sw
    //
    //  A variable for holding the calculation of the write idle sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_AXI_write_idle_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_AXI_write_idle_sw;

    // Variable:- stats_AXI_write_occupancy_min
    //
    //  A variable for holding the minimum write occupancy metric within the <config_stats_enable_AXI_write_occupancy> sliding window.
    // 
    //
    int stats_AXI_write_occupancy_min;

    // Variable:- stats_AXI_write_idle_min
    //
    //  A variable for holding the minimum write idle metric within the <config_stats_enable_AXI_write_occupancy> sliding window.
    // 
    //
    int stats_AXI_write_idle_min;

    // Variable:- stats_AXI_write_occupancy_max
    //
    //  A variable for holding the maximum write occupancy metric within the <config_stats_enable_AXI_write_occupancy> sliding window.
    // 
    //
    int stats_AXI_write_occupancy_max;

    // Variable:- stats_AXI_write_idle_max
    //
    //  A variable for holding the maximum write idle metric within <config_stats_enable_AXI_write_occupancy> the sliding window.
    // 
    //
    int stats_AXI_write_idle_max;

    // Variable:- stats_AXI_write_occupancy_mean
    //
    //  A variable for holding the mean write occupancy metric within the <config_stats_enable_AXI_write_occupancy> sliding window.
    // 
    //
    int stats_AXI_write_occupancy_mean;

    // Variable:- stats_AXI_write_idle_mean
    //
    //  A variable for holding the mean write idle metric within the <config_stats_enable_AXI_write_occupancy> sliding window.
    // 
    //
    int stats_AXI_write_idle_mean;

    // Variable:- stats_read_data_occupancy_sw
    //
    //  A variable for holding the calculation of the read data occupancy <config_stats_enable_read_data_occupancy> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <config_stats_enable_read_data_occupancy> statistic is calculated based on all of the segments.
    // 
    //
    int stats_read_data_occupancy_sw;

    // Variable:- stats_read_data_occupancy_sw_updated
    //
    //  A variable for holding the number of times the <stats_read_data_occupancy_sw> and <stats_read_data_idle_sw> sliding window statistics have been updated,
    //  plus their respective min, max and mean values.
    // The value is incremented after every <config_stats_read_data_occupancy_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest values of the following statistics
    // - <stats_read_data_occupancy_sw>
    // - <stats_read_data_occupancy_min>
    // - <stats_read_data_occupancy_max>
    // - <stats_read_data_occupancy_mean>
    // - <stats_read_data_idle_sw>
    // - <stats_read_data_idle_min>
    // - <stats_read_data_idle_max>
    // - <stats_read_data_idle_mean>
    // 
    //
    int stats_read_data_occupancy_sw_updated;

    // Variable:- stats_read_data_idle_sw
    //
    //  A variable for holding the calculation of the read data idle <config_stats_enable_read_data_occupancy> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_read_data_idle_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_read_data_idle_sw;

    // Variable:- stats_read_data_occupancy_min
    //
    //  A variable for holding the minimum read data occupancy metric within the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    //
    int stats_read_data_occupancy_min;

    // Variable:- stats_read_data_idle_min
    //
    //  A variable for holding the minimum read data idle metric within the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    //
    int stats_read_data_idle_min;

    // Variable:- stats_read_data_occupancy_max
    //
    //  A variable for holding the maximum read data metric within the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    //
    int stats_read_data_occupancy_max;

    // Variable:- stats_read_data_idle_max
    //
    //  A variable for holding the maximum read data idle metric within the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    //
    int stats_read_data_idle_max;

    // Variable:- stats_read_data_occupancy_mean
    //
    //  A variable for holding the mean read data occupancy metric within the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    //
    int stats_read_data_occupancy_mean;

    // Variable:- stats_read_data_idle_mean
    //
    //  A variable for holding the mean read data idle occupancy metric within the <config_stats_enable_read_data_occupancy> sliding window.
    // 
    //
    int stats_read_data_idle_mean;

    // Variable:- stats_write_data_occupancy_sw
    //
    //  A variable for holding the calculation of the write data occupancy <config_stats_enable_write_data_occupancy> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_data_occupancy_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_data_occupancy_sw;

    // Variable:- stats_write_data_occupancy_sw_updated
    //
    //  A variable for holding the number of times the <stats_write_data_occupancy_sw> and <stats_write_data_idle_sw>sliding window statistics have been updated,
    //  plus their respective min, max and mean values.
    // The value is incremented after every <config_stats_write_data_occupancy_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest values of the following statistics.
    // - <stats_write_data_occupancy_sw>
    // - <stats_write_data_occupancy_min>
    // - <stats_write_data_occupancy_max>
    // - <stats_write_data_occupancy_min>
    // - <stats_write_data_idle_sw>
    // - <stats_write_data_idle_min>
    // - <stats_write_data_idle_max>
    // - <stats_write_data_idle_mean>
    // 
    //
    int stats_write_data_occupancy_sw_updated;

    // Variable:- stats_write_data_idle_sw
    //
    //  A variable for holding the calculation of the write data idle <config_stats_enable_write_data_occupancy> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_data_idle_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_data_idle_sw;

    // Variable:- stats_write_data_occupancy_min
    //
    //  A variable for holding the minimum write data occupancy metric within the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    //
    int stats_write_data_occupancy_min;

    // Variable:- stats_write_data_idle_min
    //
    //  A variable for holding the mean write data idle occupancy metric within the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    //
    int stats_write_data_idle_min;

    // Variable:- stats_write_data_occupancy_max
    //
    //  A variable for holding the maximum write data metric within the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    //
    int stats_write_data_occupancy_max;

    // Variable:- stats_write_data_idle_max
    //
    //  A variable for holding the maximum write data idle metric within the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    //
    int stats_write_data_idle_max;

    // Variable:- stats_write_data_occupancy_mean
    //
    //  A variable for holding the mean write data occupancy metric within the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    //
    int stats_write_data_occupancy_mean;

    // Variable:- stats_write_data_idle_mean
    //
    //  A variable for holding the mean write data idle occupancy metric within the <config_stats_enable_write_data_occupancy> sliding window.
    // 
    //
    int stats_write_data_idle_mean;

    // Variable:- stats_read_bandwidth_sw
    //
    //  A variable for holding the calculation of the read bandwidth <config_stats_enable_read_bandwidth> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_read_bandwidth_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_read_bandwidth_sw;

    // Variable:- stats_read_bandwidth_sw_updated
    //
    //  A variable for holding the number of times the <stats_read_bandwidth_sw> sliding window statistic has been updated.
    // The value is incremented after every <config_stats_read_bandwidth_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest values of the following statistics.
    // - <stats_read_bandwidth_sw>
    // - <stats_read_bandwidth_min>
    // - <stats_read_bandwidth_max>
    // - <stats_read_bandwidth_mean>
    // 
    //
    int stats_read_bandwidth_sw_updated;

    // Variable:- stats_read_bandwidth_min
    //
    //  A variable for holding the minimum read bandwidth metric within the <config_stats_enable_read_bandwidth> sliding window.
    // 
    //
    int stats_read_bandwidth_min;

    // Variable:- stats_read_bandwidth_max
    //
    //  A variable for holding the maximum read bandwidth metric within the <config_stats_enable_read_bandwidth> sliding window.
    // 
    //
    int stats_read_bandwidth_max;

    // Variable:- stats_read_bandwidth_mean
    //
    //  A variable for holding the mean read bandwidth metric within the <config_stats_enable_read_bandwidth> sliding window.
    // 
    //
    int stats_read_bandwidth_mean;

    // Variable:- stats_write_bandwidth_sw
    //
    //  A variable for holding the calculation of the write bandwidth <config_stats_enable_write_bandwidth> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_bandwidth_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_bandwidth_sw;

    // Variable:- stats_write_bandwidth_sw_updated
    //
    //  A variable for holding the number of times the <stats_write_bandwidth_sw> sliding window statistic has been updated.
    // The value is incremented after every <config_stats_write_bandwidth_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest values of the following staistics
    // - <stats_write_bandwidth_sw>
    // - <stats_write_bandwidth_min>
    // - <stats_write_bandwidth_max>
    // - <stats_write_bandwidth_mean>
    // 
    //
    int stats_write_bandwidth_sw_updated;

    // Variable:- stats_write_bandwidth_min
    //
    //  A variable for holding the minimum write bandwidth metric within the <config_stats_enable_write_bandwidth> sliding window.
    // 
    //
    int stats_write_bandwidth_min;

    // Variable:- stats_write_bandwidth_max
    //
    //  A variable for holding the maximum write bandwidth metric within the <config_stats_enable_write_bandwidth> sliding window.
    // 
    //
    int stats_write_bandwidth_max;

    // Variable:- stats_write_bandwidth_mean
    //
    //  A variable for holding the mean write bandwidth metric within the <config_stats_enable_write_bandwidth> sliding window.
    // 
    //
    int stats_write_bandwidth_mean;

    // Variable:- stats_read_latency_sw_updated
    //
    //  A variable for holding the number of times the <stats_read_address_data_latency_sw> sliding window statistic has been updated.
    // The value is incremented after every <config_stats_read_latency_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest values of the following statistics.
    // - <stats_read_address_data_latency_sw>
    // - <stats_read_address_data_latency_min>
    // - <stats_read_address_data_latency_max>
    // - <stats_read_address_data_latency_mean>
    // 
    //
    int stats_read_latency_sw_updated;

    // Variable:- stats_read_address_data_latency_inst
    //
    //  A variable for holding the instantaneous read address to read data latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_data_latency_inst;

    // Variable:- stats_read_address_data_latency_sw
    //
    //  A variable for holding the calculation of the read address to read data latency <config_stats_enable_read_latency> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_read_address_data_latency_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_read_address_data_latency_sw;

    // Variable:- stats_read_address_data_latency_min
    //
    //  A variable for holding the minimum read address to read data latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_data_latency_min;

    // Variable:- stats_read_address_data_latency_max
    //
    //  A variable for holding the maximum read address to read data latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_data_latency_max;

    // Variable:- stats_read_address_data_latency_mean
    //
    //  A variable for holding the mean read address to read data latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_data_latency_mean;

    // Variable:- stats_read_address_address_latency_inst
    //
    //  A variable for holding the instantaneous read address to read address latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_address_latency_inst;

    // Variable:- stats_read_address_address_latency_sw
    //
    //  A variable for holding the calculation of the read address to read address latency <config_stats_enable_read_latency> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_read_address_address_latency_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_read_address_address_latency_sw;

    // Variable:- stats_read_address_address_latency_min
    //
    //  A variable for holding the minimum read address to read address latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_address_latency_min;

    // Variable:- stats_read_address_address_latency_max
    //
    //  A variable for holding the maximum read address to read address latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_address_latency_max;

    // Variable:- stats_read_address_address_latency_mean
    //
    //  A variable for holding the mean read address to read address latency metric within the <config_stats_enable_read_latency> sliding window.
    // 
    //
    int stats_read_address_address_latency_mean;

    // Variable:- stats_write_latency_sw_updated
    //
    //  A variable for holding the number of times the <stats_write_address_data_latency_sw> sliding window statistic has been updated.
    // The value is incremented after every <config_stats_write_latency_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest value of the following statistics
    // - <stats_write_address_data_latency_sw>
    // - <stats_write_address_data_latency_min>
    // - <stats_write_address_data_latency_max>
    // - <stats_write_address_data_latency_mean>
    // 
    //
    int stats_write_latency_sw_updated;

    // Variable:- stats_write_address_data_latency_inst
    //
    //  A variable for holding the instantaneous write address to write data latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_data_latency_inst;

    // Variable:- stats_write_address_data_latency_sw
    //
    //  A variable for holding the calculation of the write address to write data latency <config_stats_enable_write_latency> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_address_data_latency_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_address_data_latency_sw;

    // Variable:- stats_write_address_data_latency_min
    //
    //  A variable for holding the minimum write address to write data latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_data_latency_min;

    // Variable:- stats_write_address_data_latency_max
    //
    //  A variable for holding the maximum write address to write data latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_data_latency_max;

    // Variable:- stats_write_address_data_latency_mean
    //
    //  A variable for holding the mean write address to write data latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_data_latency_mean;

    // Variable:- stats_write_data_response_latency_inst
    //
    //  A variable for holding the instantaneous write data to write response latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_data_response_latency_inst;

    // Variable:- stats_write_data_response_latency_sw
    //
    //  A variable for holding the calculation of the write data to write response latency <config_stats_enable_write_latency> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_data_response_latency_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_data_response_latency_sw;

    // Variable:- stats_write_data_response_latency_min
    //
    //  A variable for holding the minimum write data to write response latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_data_response_latency_min;

    // Variable:- stats_write_data_response_latency_max
    //
    //  A variable for holding the maximum write data to write response latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_data_response_latency_max;

    // Variable:- stats_write_data_response_latency_mean
    //
    //  A variable for holding the mean write data to write response latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_data_response_latency_mean;

    // Variable:- stats_write_address_address_latency_inst
    //
    //  A variable for holding the instantaneous write address to write address latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_address_latency_inst;

    // Variable:- stats_write_address_address_latency_sw
    //
    //  A variable for holding the calculation of the write address to write address latency <config_stats_enable_write_latency> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_address_address_latency_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_address_address_latency_sw;

    // Variable:- stats_write_address_address_latency_min
    //
    //  A variable for holding the minimum write address to write address latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_address_latency_min;

    // Variable:- stats_write_address_address_latency_max
    //
    //  A variable for holding the maximum write address to write address latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_address_latency_max;

    // Variable:- stats_write_address_address_latency_mean
    //
    //  A variable for holding the mean write address to write address latency metric within the <config_stats_enable_write_latency> sliding window.
    // 
    //
    int stats_write_address_address_latency_mean;

    // Variable:- stats_read_address_waits_inst
    //
    //  A variable for holding the instantaneous read address wait states metric within the <config_stats_enable_read_address_waits> sliding window.
    // 
    //
    int stats_read_address_waits_inst;

    // Variable:- stats_read_address_waits_sw
    //
    //  A variable for holding the calculation of the read address wait states <config_stats_enable_read_address_waits> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_read_address_waits_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_read_address_waits_sw;

    // Variable:- stats_read_address_waits_sw_updated
    //
    //  A variable for holding the number of times the <stats_read_address_waits_sw> sliding window statistic has been updated.
    // It is incremented after every <config_stats_read_address_waits_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest value of the following statistics
    // - <stats_read_address_waits_sw>
    // - <stats_read_address_waits_min>
    // - <stats_read_address_waits_max>
    // - <stats_read_address_waits_mean>
    // 
    //
    int stats_read_address_waits_sw_updated;

    // Variable:- stats_read_address_waits_min
    //
    //  A variable for holding the minimum read address wait states metric within the <config_stats_enable_read_address_waits> sliding window.
    // 
    //
    int stats_read_address_waits_min;

    // Variable:- stats_read_address_waits_max
    //
    //  A variable for holding the maximum read address wait states metric within the <config_stats_enable_read_address_waits> sliding window.
    // 
    //
    int stats_read_address_waits_max;

    // Variable:- stats_read_address_waits_mean
    //
    //  A variable for holding the mean read address wait states metric within the <config_stats_enable_read_address_waits> sliding window.
    // 
    //
    int stats_read_address_waits_mean;

    // Variable:- stats_read_data_waits_inst
    //
    //  A variable for holding the instantaneous read data wait states metric within the <config_stats_enable_read_data_waits> sliding window.
    // 
    //
    int stats_read_data_waits_inst;

    // Variable:- stats_read_data_waits_sw
    //
    //  A variable for holding the calculation of the read data wait states <config_stats_enable_read_data_waits> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_read_data_waits_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_read_data_waits_sw;

    // Variable:- stats_read_data_waits_sw_updated
    //
    //  A variable for holding the number of times the <stats_read_data_waits_sw> sliding window statistic has been updated.
    // It is incremented after every <config_stats_read_data_waits_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest value of the following statistics
    // - <stats_read_data_waits_sw>
    // - <stats_read_data_waits_min>
    // - <stats_read_data_waits_max>
    // - <stats_read_data_waits_mean>
    // 
    //
    int stats_read_data_waits_sw_updated;

    // Variable:- stats_read_data_waits_min
    //
    //  A variable for holding the minimum read data wait states metric within the <config_stats_enable_read_data_waits> sliding window.
    // 
    //
    int stats_read_data_waits_min;

    // Variable:- stats_read_data_waits_max
    //
    //  A variable for holding the maximum read data wait states metric within the <config_stats_enable_read_data_waits> sliding window.
    // 
    //
    int stats_read_data_waits_max;

    // Variable:- stats_read_data_waits_mean
    //
    //  A variable for holding the mean read data wait states metric within the <config_stats_enable_read_data_waits> sliding window.
    // 
    //
    int stats_read_data_waits_mean;

    // Variable:- stats_write_address_waits_inst
    //
    //  A variable for holding the instantaneous write address wait states metric within the <config_stats_enable_write_address_waits> sliding window.
    // 
    //
    int stats_write_address_waits_inst;

    // Variable:- stats_write_address_waits_sw
    //
    //  A variable for holding the calculation of the write address wait states <config_stats_enable_write_address_waits> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_address_waits_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_address_waits_sw;

    // Variable:- stats_write_address_waits_sw_updated
    //
    //  A variable for holding the number of times the <stats_write_address_waits_sw> sliding window statistic has been updated.
    // It is incremented after every <config_stats_write_address_waits_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest value of the following statistics
    // - <stats_write_address_waits_sw>
    // - <stats_write_address_waits_min>
    // - <stats_write_address_waits_max>
    // - <stats_write_address_waits_mean>
    // 
    //
    int stats_write_address_waits_sw_updated;

    // Variable:- stats_write_address_waits_min
    //
    //  A variable for holding the minimum write address wait states metric within the <config_stats_enable_write_address_waits> sliding window.
    // 
    //
    int stats_write_address_waits_min;

    // Variable:- stats_write_address_waits_max
    //
    //  A variable for holding the maximum write address wait states metric within the <config_stats_enable_write_address_waits> sliding window.
    // 
    //
    int stats_write_address_waits_max;

    // Variable:- stats_write_address_waits_mean
    //
    //  A variable for holding the mean write address wait states metric within the <config_stats_enable_write_address_waits> sliding window.
    // 
    //
    int stats_write_address_waits_mean;

    // Variable:- stats_write_data_waits_inst
    //
    //  A variable for holding the instantaneous write data wait states metric within the <config_stats_enable_write_data_waits> sliding window.
    // 
    //
    int stats_write_data_waits_inst;

    // Variable:- stats_write_data_waits_sw
    //
    //  A variable for holding the calculation of the write data wait states <config_stats_enable_write_data_waits> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_data_waits_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_data_waits_sw;

    // Variable:- stats_write_data_waits_sw_updated
    //
    //  A variable for holding the number of times the <stats_write_data_waits_sw> sliding window statistic has been updated.
    // It is incremented after every <config_stats_write_data_waits_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest value of the following statistics.
    // - <stats_write_data_waits_sw>
    // - <stats_write_data_waits_min>
    // - <stats_write_data_waits_max>
    // - <stats_write_data_waits_mean>
    // 
    //
    int stats_write_data_waits_sw_updated;

    // Variable:- stats_write_data_waits_min
    //
    //  A variable for holding the minimum write data wait states metric within the <config_stats_enable_write_data_waits> sliding window.
    // 
    //
    int stats_write_data_waits_min;

    // Variable:- stats_write_data_waits_max
    //
    //  A variable for holding the maximum write data wait states metric within the <config_stats_enable_write_data_waits> sliding window.
    // 
    //
    int stats_write_data_waits_max;

    // Variable:- stats_write_data_waits_mean
    //
    //  A variable for holding the mean write data wait states metric within the <config_stats_enable_write_data_waits> sliding window.
    // 
    //
    int stats_write_data_waits_mean;

    // Variable:- stats_write_response_waits_inst
    //
    //  A variable for holding the instantaneous write response wait states metric within the <config_stats_enable_write_response_waits> sliding window.
    // 
    //
    int stats_write_response_waits_inst;

    // Variable:- stats_write_response_waits_sw
    //
    //  A variable for holding the calculation of the write response wait states <config_stats_enable_write_response_waits> sliding window statistic.
    // Statistics are gathered for each of the sliding window segments individually and then the actual
    // <stats_write_response_waits_sw> statistic is calculated based on all of the segments.
    // 
    //
    int stats_write_response_waits_sw;

    // Variable:- stats_write_response_waits_sw_updated
    //
    //  A variable for holding the number of times the <stats_write_response_waits_sw> sliding window statistic has been updated.
    // It is incremented after every <config_stats_write_response_waits_step> * AXI_CLK period and can
    // be used as a sampling point to get the latest value of the following statistics.
    // - <stats_write_response_waits_sw>
    // - <stats_write_response_waits_min>
    // - <stats_write_response_waits_max>
    // - <stats_write_response_waits_mean>
    // 
    //
    int stats_write_response_waits_sw_updated;

    // Variable:- stats_write_response_waits_min
    //
    //  A variable for holding the minimum write response wait states metric within the <config_stats_enable_write_response_waits> sliding window.
    // 
    //
    int stats_write_response_waits_min;

    // Variable:- stats_write_response_waits_max
    //
    //  A variable for holding the maximum write response wait states metric within the <config_stats_enable_write_response_waits> sliding window.
    // 
    //
    int stats_write_response_waits_max;

    // Variable:- stats_write_response_waits_mean
    //
    //  A variable for holding the mean write response wait states metric within the <config_stats_enable_write_response_waits> sliding window.
    // 
    //
    int stats_write_response_waits_mean;

    // Variable:- stats_rw_transaction_last_duration
    //
    //  A variable for holding the duration of the last read or write transaction.
    // 
    //
    int stats_rw_transaction_last_duration;

    // Variable:- stats_AXI_read_last_duration
    //
    //  A variable for holding the duration of the last read transaction.
    // 
    //
    int stats_AXI_read_last_duration;

    // Variable:- stats_AXI_write_last_duration
    //
    //  A variable for holding the duration of the last write transaction.
    // 
    //
    int stats_AXI_write_last_duration;

    // Variable:- stats_read_addr_channel_phase_last_duration
    //
    //  A variable for holding the duration of the last read address phase.
    // 
    //
    int stats_read_addr_channel_phase_last_duration;

    // Variable:- stats_read_data_burst_last_duration
    //
    //  A variable for holding the duration of the last read data burst.
    // 
    //
    int stats_read_data_burst_last_duration;

    // Variable:- stats_read_channel_phase_last_duration
    //
    //  A variable for holding the duration of the last read channel phase.
    // 
    //
    int stats_read_channel_phase_last_duration;

    // Variable:- stats_write_addr_channel_phase_last_duration
    //
    //  A variable for holding the duration of the last write address channel phase.
    // 
    //
    int stats_write_addr_channel_phase_last_duration;

    // Variable:- stats_write_data_burst_last_duration
    //
    //  A variable for holding the duration of the last write data burst.
    // 
    //
    int stats_write_data_burst_last_duration;

    // Variable:- stats_write_channel_phase_last_duration
    //
    //  A variable for holding the duration of the last write channel phase.
    // 
    //
    int stats_write_channel_phase_last_duration;

    // Variable:- stats_write_resp_channel_phase_last_duration
    //
    //  A variable for holding the duration of the last write response channel phase.
    // 
    //
    int stats_write_resp_channel_phase_last_duration;


    //------------------------------------------------------------------------------
    // Assertions
    //------------------------------------------------------------------------------
    // Documentation for assertions has been moved to <axi_assertions.svh>.

    import "DPI-C" context axi_get_axi_master_end = function longint axi_get_axi_master_end();
    import "DPI-C" context axi_get_axi_slave_end = function longint axi_get_axi_slave_end();
    import "DPI-C" context axi_get_axi_clock_source_end = function longint axi_get_axi_clock_source_end();
    import "DPI-C" context axi_get_axi_reset_source_end = function longint axi_get_axi_reset_source_end();
    import "DPI-C" context axi_get_axi__monitor_end = function longint axi_get_axi__monitor_end();
    // Declare user visible wires variables, for non-continuous assignments.
    logic m_ACLK = 'z;
    logic m_ARESETn = 'z;
    logic m_AWVALID = 'z;
    logic [((AXI_ADDRESS_WIDTH) - 1):0]  m_AWADDR = 'z;
    logic [3:0] m_AWLEN = 'z;
    logic [2:0] m_AWSIZE = 'z;
    logic [1:0] m_AWBURST = 'z;
    logic [1:0] m_AWLOCK = 'z;
    logic [3:0] m_AWCACHE = 'z;
    logic [2:0] m_AWPROT = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  m_AWID = 'z;
    logic m_AWREADY = 'z;
    logic [7:0] m_AWUSER = 'z;
    logic m_ARVALID = 'z;
    logic [((AXI_ADDRESS_WIDTH) - 1):0]  m_ARADDR = 'z;
    logic [3:0] m_ARLEN = 'z;
    logic [2:0] m_ARSIZE = 'z;
    logic [1:0] m_ARBURST = 'z;
    logic [1:0] m_ARLOCK = 'z;
    logic [3:0] m_ARCACHE = 'z;
    logic [2:0] m_ARPROT = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  m_ARID = 'z;
    logic m_ARREADY = 'z;
    logic [7:0] m_ARUSER = 'z;
    logic m_RVALID = 'z;
    logic m_RLAST = 'z;
    logic [((AXI_RDATA_WIDTH) - 1):0]  m_RDATA = 'z;
    logic [1:0] m_RRESP = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  m_RID = 'z;
    logic m_RREADY = 'z;
    logic [7:0] m_RUSER = 'z;
    logic m_WVALID = 'z;
    logic m_WLAST = 'z;
    logic [((AXI_WDATA_WIDTH) - 1):0]  m_WDATA = 'z;
    logic [(((AXI_WDATA_WIDTH / 8)) - 1):0]  m_WSTRB = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  m_WID = 'z;
    logic m_WREADY = 'z;
    logic [7:0] m_WUSER = 'z;
    logic m_BVALID = 'z;
    logic [1:0] m_BRESP = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  m_BID = 'z;
    logic m_BREADY = 'z;
    logic [7:0] m_BUSER = 'z;

    // Forces a sweep through the wire change checkers at time 0 to get around process kick-off order unknowns
    bit _check_t0_values;
    always_comb _check_t0_values = 1;


    //------------------------------------------------------------------------------
    // Generic Interface Configuration Support
    //------------------------------------------------------------------------------

    import "DPI-C" context axi_set_interface = function void axi_set_interface
    (
        input int what,
        input int arg1,
        input int arg2,
        input int arg3,
        input int arg4,
        input int arg5,
        input int arg6,
        input int arg7,
        input int arg8,
        input int arg9,
        input int arg10
    );
    import "DPI-C" context axi_get_interface = function int axi_get_interface
    (
        input int what,
        input int arg1,
        input int arg2,
        input int arg3,
        input int arg4,
        input int arg5,
        input int arg6,
        input int arg7,
        input int arg8,
        input int arg9
    );
    //------------------------------------------------------------------------------
    // Functions to get the hierarchic name of this interface
    //------------------------------------------------------------------------------
    import "DPI-C" context axi_get_full_name = function string axi_get_full_name();

    //------------------------------------------------------------------------------
    // Abstraction level Support
    //------------------------------------------------------------------------------

    import "DPI-C" context axi_set_master_end_abstraction_level = function void axi_set_master_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi_get_master_end_abstraction_level = function void axi_get_master_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    import "DPI-C" context axi_set_slave_end_abstraction_level = function void axi_set_slave_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi_get_slave_end_abstraction_level = function void axi_get_slave_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    import "DPI-C" context axi_set_clock_source_end_abstraction_level = function void axi_set_clock_source_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi_get_clock_source_end_abstraction_level = function void axi_get_clock_source_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    import "DPI-C" context axi_set_reset_source_end_abstraction_level = function void axi_set_reset_source_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi_get_reset_source_end_abstraction_level = function void axi_get_reset_source_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );

    //------------------------------------------------------------------------------
    // Wire Level Interface Support
    //------------------------------------------------------------------------------
    logic internal_ACLK = 'z;
    logic internal_ARESETn = 'z;
    logic internal_AWVALID = 'z;
    logic [((AXI_ADDRESS_WIDTH) - 1):0]  internal_AWADDR = 'z;
    logic [3:0] internal_AWLEN = 'z;
    logic [2:0] internal_AWSIZE = 'z;
    logic [1:0] internal_AWBURST = 'z;
    logic [1:0] internal_AWLOCK = 'z;
    logic [3:0] internal_AWCACHE = 'z;
    logic [2:0] internal_AWPROT = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  internal_AWID = 'z;
    logic internal_AWREADY = 'z;
    logic [7:0] internal_AWUSER = 'z;
    logic internal_ARVALID = 'z;
    logic [((AXI_ADDRESS_WIDTH) - 1):0]  internal_ARADDR = 'z;
    logic [3:0] internal_ARLEN = 'z;
    logic [2:0] internal_ARSIZE = 'z;
    logic [1:0] internal_ARBURST = 'z;
    logic [1:0] internal_ARLOCK = 'z;
    logic [3:0] internal_ARCACHE = 'z;
    logic [2:0] internal_ARPROT = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  internal_ARID = 'z;
    logic internal_ARREADY = 'z;
    logic [7:0] internal_ARUSER = 'z;
    logic internal_RVALID = 'z;
    logic internal_RLAST = 'z;
    logic [((AXI_RDATA_WIDTH) - 1):0]  internal_RDATA = 'z;
    logic [1:0] internal_RRESP = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  internal_RID = 'z;
    logic internal_RREADY = 'z;
    logic [7:0] internal_RUSER = 'z;
    logic internal_WVALID = 'z;
    logic internal_WLAST = 'z;
    logic [((AXI_WDATA_WIDTH) - 1):0]  internal_WDATA = 'z;
    logic [(((AXI_WDATA_WIDTH / 8)) - 1):0]  internal_WSTRB = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  internal_WID = 'z;
    logic internal_WREADY = 'z;
    logic [7:0] internal_WUSER = 'z;
    logic internal_BVALID = 'z;
    logic [1:0] internal_BRESP = 'z;
    logic [((AXI_ID_WIDTH) - 1):0]  internal_BID = 'z;
    logic internal_BREADY = 'z;
    logic [7:0] internal_BUSER = 'z;

    import "DPI-C" context function longint axi_initialise_SystemVerilog
    (
        int usage_code,
        input int AXI_ADDRESS_WIDTH,
        input int AXI_RDATA_WIDTH,
        input int AXI_WDATA_WIDTH,
        input int AXI_ID_WIDTH
    );

    // Handle to the linkage
    (* elab_init *) longint _interface_ref =
                                axi_initialise_SystemVerilog
                                (
                                    18102076,
                                    AXI_ADDRESS_WIDTH,
                                    AXI_RDATA_WIDTH,
                                    AXI_WDATA_WIDTH,
                                    AXI_ID_WIDTH
                                ); // DPI call to create transactor (called at elaboration time as initialiser)


    import "DPI-C" context function void axi_set_ACLK_from_SystemVerilog
    (
        input bit ACLK_param
    );
    import "DPI-C" context function void axi_propagate_ACLK_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ACLK_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ACLK_from_CY;
    export "DPI-C" function axi_initialise_ACLK_from_CY;

    import "DPI-C" context function void axi_set_ARESETn_from_SystemVerilog
    (
        input logic ARESETn_param
    );
    import "DPI-C" context function void axi_propagate_ARESETn_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARESETn_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARESETn_from_CY;
    export "DPI-C" function axi_initialise_ARESETn_from_CY;

    import "DPI-C" context function void axi_set_AWVALID_from_SystemVerilog
    (
        input logic AWVALID_param
    );
    import "DPI-C" context function void axi_propagate_AWVALID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWVALID_from_CY;
    export "DPI-C" function axi_initialise_AWVALID_from_CY;

    import "DPI-C" context function void axi_set_AWADDR_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  AWADDR_param
    );
    import "DPI-C" context function void axi_propagate_AWADDR_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWADDR_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWADDR_from_CY_index1;
    export "DPI-C" function axi_initialise_AWADDR_from_CY;

    import "DPI-C" context function void axi_set_AWLEN_from_SystemVerilog
    (
        input logic [3:0] AWLEN_param
    );
    import "DPI-C" context function void axi_propagate_AWLEN_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWLEN_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWLEN_from_CY;
    export "DPI-C" function axi_initialise_AWLEN_from_CY;

    import "DPI-C" context function void axi_set_AWSIZE_from_SystemVerilog
    (
        input logic [2:0] AWSIZE_param
    );
    import "DPI-C" context function void axi_propagate_AWSIZE_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWSIZE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWSIZE_from_CY;
    export "DPI-C" function axi_initialise_AWSIZE_from_CY;

    import "DPI-C" context function void axi_set_AWBURST_from_SystemVerilog
    (
        input logic [1:0] AWBURST_param
    );
    import "DPI-C" context function void axi_propagate_AWBURST_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWBURST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWBURST_from_CY;
    export "DPI-C" function axi_initialise_AWBURST_from_CY;

    import "DPI-C" context function void axi_set_AWLOCK_from_SystemVerilog
    (
        input logic [1:0] AWLOCK_param
    );
    import "DPI-C" context function void axi_propagate_AWLOCK_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWLOCK_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWLOCK_from_CY;
    export "DPI-C" function axi_initialise_AWLOCK_from_CY;

    import "DPI-C" context function void axi_set_AWCACHE_from_SystemVerilog
    (
        input logic [3:0] AWCACHE_param
    );
    import "DPI-C" context function void axi_propagate_AWCACHE_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWCACHE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWCACHE_from_CY;
    export "DPI-C" function axi_initialise_AWCACHE_from_CY;

    import "DPI-C" context function void axi_set_AWPROT_from_SystemVerilog
    (
        input logic [2:0] AWPROT_param
    );
    import "DPI-C" context function void axi_propagate_AWPROT_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWPROT_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWPROT_from_CY;
    export "DPI-C" function axi_initialise_AWPROT_from_CY;

    import "DPI-C" context function void axi_set_AWID_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  AWID_param
    );
    import "DPI-C" context function void axi_propagate_AWID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWID_from_CY_index1;
    export "DPI-C" function axi_initialise_AWID_from_CY;

    import "DPI-C" context function void axi_set_AWREADY_from_SystemVerilog
    (
        input logic AWREADY_param
    );
    import "DPI-C" context function void axi_propagate_AWREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWREADY_from_CY;
    export "DPI-C" function axi_initialise_AWREADY_from_CY;

    import "DPI-C" context function void axi_set_AWUSER_from_SystemVerilog
    (
        input logic [7:0] AWUSER_param
    );
    import "DPI-C" context function void axi_propagate_AWUSER_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_AWUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_AWUSER_from_CY;
    export "DPI-C" function axi_initialise_AWUSER_from_CY;

    import "DPI-C" context function void axi_set_ARVALID_from_SystemVerilog
    (
        input logic ARVALID_param
    );
    import "DPI-C" context function void axi_propagate_ARVALID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARVALID_from_CY;
    export "DPI-C" function axi_initialise_ARVALID_from_CY;

    import "DPI-C" context function void axi_set_ARADDR_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  ARADDR_param
    );
    import "DPI-C" context function void axi_propagate_ARADDR_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARADDR_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARADDR_from_CY_index1;
    export "DPI-C" function axi_initialise_ARADDR_from_CY;

    import "DPI-C" context function void axi_set_ARLEN_from_SystemVerilog
    (
        input logic [3:0] ARLEN_param
    );
    import "DPI-C" context function void axi_propagate_ARLEN_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARLEN_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARLEN_from_CY;
    export "DPI-C" function axi_initialise_ARLEN_from_CY;

    import "DPI-C" context function void axi_set_ARSIZE_from_SystemVerilog
    (
        input logic [2:0] ARSIZE_param
    );
    import "DPI-C" context function void axi_propagate_ARSIZE_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARSIZE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARSIZE_from_CY;
    export "DPI-C" function axi_initialise_ARSIZE_from_CY;

    import "DPI-C" context function void axi_set_ARBURST_from_SystemVerilog
    (
        input logic [1:0] ARBURST_param
    );
    import "DPI-C" context function void axi_propagate_ARBURST_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARBURST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARBURST_from_CY;
    export "DPI-C" function axi_initialise_ARBURST_from_CY;

    import "DPI-C" context function void axi_set_ARLOCK_from_SystemVerilog
    (
        input logic [1:0] ARLOCK_param
    );
    import "DPI-C" context function void axi_propagate_ARLOCK_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARLOCK_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARLOCK_from_CY;
    export "DPI-C" function axi_initialise_ARLOCK_from_CY;

    import "DPI-C" context function void axi_set_ARCACHE_from_SystemVerilog
    (
        input logic [3:0] ARCACHE_param
    );
    import "DPI-C" context function void axi_propagate_ARCACHE_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARCACHE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARCACHE_from_CY;
    export "DPI-C" function axi_initialise_ARCACHE_from_CY;

    import "DPI-C" context function void axi_set_ARPROT_from_SystemVerilog
    (
        input logic [2:0] ARPROT_param
    );
    import "DPI-C" context function void axi_propagate_ARPROT_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARPROT_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARPROT_from_CY;
    export "DPI-C" function axi_initialise_ARPROT_from_CY;

    import "DPI-C" context function void axi_set_ARID_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  ARID_param
    );
    import "DPI-C" context function void axi_propagate_ARID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARID_from_CY_index1;
    export "DPI-C" function axi_initialise_ARID_from_CY;

    import "DPI-C" context function void axi_set_ARREADY_from_SystemVerilog
    (
        input logic ARREADY_param
    );
    import "DPI-C" context function void axi_propagate_ARREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARREADY_from_CY;
    export "DPI-C" function axi_initialise_ARREADY_from_CY;

    import "DPI-C" context function void axi_set_ARUSER_from_SystemVerilog
    (
        input logic [7:0] ARUSER_param
    );
    import "DPI-C" context function void axi_propagate_ARUSER_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_ARUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_ARUSER_from_CY;
    export "DPI-C" function axi_initialise_ARUSER_from_CY;

    import "DPI-C" context function void axi_set_RVALID_from_SystemVerilog
    (
        input logic RVALID_param
    );
    import "DPI-C" context function void axi_propagate_RVALID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_RVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_RVALID_from_CY;
    export "DPI-C" function axi_initialise_RVALID_from_CY;

    import "DPI-C" context function void axi_set_RLAST_from_SystemVerilog
    (
        input logic RLAST_param
    );
    import "DPI-C" context function void axi_propagate_RLAST_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_RLAST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_RLAST_from_CY;
    export "DPI-C" function axi_initialise_RLAST_from_CY;

    import "DPI-C" context function void axi_set_RDATA_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  RDATA_param
    );
    import "DPI-C" context function void axi_propagate_RDATA_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_RDATA_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_RDATA_from_CY_index1;
    export "DPI-C" function axi_initialise_RDATA_from_CY;

    import "DPI-C" context function void axi_set_RRESP_from_SystemVerilog
    (
        input logic [1:0] RRESP_param
    );
    import "DPI-C" context function void axi_propagate_RRESP_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_RRESP_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_RRESP_from_CY;
    export "DPI-C" function axi_initialise_RRESP_from_CY;

    import "DPI-C" context function void axi_set_RID_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  RID_param
    );
    import "DPI-C" context function void axi_propagate_RID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_RID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_RID_from_CY_index1;
    export "DPI-C" function axi_initialise_RID_from_CY;

    import "DPI-C" context function void axi_set_RREADY_from_SystemVerilog
    (
        input logic RREADY_param
    );
    import "DPI-C" context function void axi_propagate_RREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_RREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_RREADY_from_CY;
    export "DPI-C" function axi_initialise_RREADY_from_CY;

    import "DPI-C" context function void axi_set_RUSER_from_SystemVerilog
    (
        input logic [7:0] RUSER_param
    );
    import "DPI-C" context function void axi_propagate_RUSER_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_RUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_RUSER_from_CY;
    export "DPI-C" function axi_initialise_RUSER_from_CY;

    import "DPI-C" context function void axi_set_WVALID_from_SystemVerilog
    (
        input logic WVALID_param
    );
    import "DPI-C" context function void axi_propagate_WVALID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_WVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_WVALID_from_CY;
    export "DPI-C" function axi_initialise_WVALID_from_CY;

    import "DPI-C" context function void axi_set_WLAST_from_SystemVerilog
    (
        input logic WLAST_param
    );
    import "DPI-C" context function void axi_propagate_WLAST_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_WLAST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_WLAST_from_CY;
    export "DPI-C" function axi_initialise_WLAST_from_CY;

    import "DPI-C" context function void axi_set_WDATA_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  WDATA_param
    );
    import "DPI-C" context function void axi_propagate_WDATA_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_WDATA_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_WDATA_from_CY_index1;
    export "DPI-C" function axi_initialise_WDATA_from_CY;

    import "DPI-C" context function void axi_set_WSTRB_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  WSTRB_param
    );
    import "DPI-C" context function void axi_propagate_WSTRB_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_WSTRB_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_WSTRB_from_CY_index1;
    export "DPI-C" function axi_initialise_WSTRB_from_CY;

    import "DPI-C" context function void axi_set_WID_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  WID_param
    );
    import "DPI-C" context function void axi_propagate_WID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_WID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_WID_from_CY_index1;
    export "DPI-C" function axi_initialise_WID_from_CY;

    import "DPI-C" context function void axi_set_WREADY_from_SystemVerilog
    (
        input logic WREADY_param
    );
    import "DPI-C" context function void axi_propagate_WREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_WREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_WREADY_from_CY;
    export "DPI-C" function axi_initialise_WREADY_from_CY;

    import "DPI-C" context function void axi_set_WUSER_from_SystemVerilog
    (
        input logic [7:0] WUSER_param
    );
    import "DPI-C" context function void axi_propagate_WUSER_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_WUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_WUSER_from_CY;
    export "DPI-C" function axi_initialise_WUSER_from_CY;

    import "DPI-C" context function void axi_set_BVALID_from_SystemVerilog
    (
        input logic BVALID_param
    );
    import "DPI-C" context function void axi_propagate_BVALID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_BVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_BVALID_from_CY;
    export "DPI-C" function axi_initialise_BVALID_from_CY;

    import "DPI-C" context function void axi_set_BRESP_from_SystemVerilog
    (
        input logic [1:0] BRESP_param
    );
    import "DPI-C" context function void axi_propagate_BRESP_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_BRESP_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_BRESP_from_CY;
    export "DPI-C" function axi_initialise_BRESP_from_CY;

    import "DPI-C" context function void axi_set_BID_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  BID_param
    );
    import "DPI-C" context function void axi_propagate_BID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_BID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_BID_from_CY_index1;
    export "DPI-C" function axi_initialise_BID_from_CY;

    import "DPI-C" context function void axi_set_BREADY_from_SystemVerilog
    (
        input logic BREADY_param
    );
    import "DPI-C" context function void axi_propagate_BREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_BREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_BREADY_from_CY;
    export "DPI-C" function axi_initialise_BREADY_from_CY;

    import "DPI-C" context function void axi_set_BUSER_from_SystemVerilog
    (
        input logic [7:0] BUSER_param
    );
    import "DPI-C" context function void axi_propagate_BUSER_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_BUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_BUSER_from_CY;
    export "DPI-C" function axi_initialise_BUSER_from_CY;

    import "DPI-C" context function void axi_set_config_clk_init_value_from_SystemVerilog
    (
        input bit config_clk_init_value_param
    );
    import "DPI-C" context function void axi_propagate_config_clk_init_value_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_clk_init_value_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_clk_init_value_from_CY;

    import "DPI-C" context function void axi_set_config_clk_phase_shift_from_SystemVerilog
    (
        input int config_clk_phase_shift_param
    );
    import "DPI-C" context function void axi_propagate_config_clk_phase_shift_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_clk_phase_shift_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_clk_phase_shift_from_CY;

    import "DPI-C" context function void axi_set_config_clk_1st_time_from_SystemVerilog
    (
        input int config_clk_1st_time_param
    );
    import "DPI-C" context function void axi_propagate_config_clk_1st_time_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_clk_1st_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_clk_1st_time_from_CY;

    import "DPI-C" context function void axi_set_config_clk_2nd_time_from_SystemVerilog
    (
        input int config_clk_2nd_time_param
    );
    import "DPI-C" context function void axi_propagate_config_clk_2nd_time_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_clk_2nd_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_clk_2nd_time_from_CY;

    import "DPI-C" context function void axi_set_config_setup_time_from_SystemVerilog
    (
        input int config_setup_time_param
    );
    import "DPI-C" context function void axi_propagate_config_setup_time_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_setup_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_setup_time_from_CY;

    import "DPI-C" context function void axi_set_config_hold_time_from_SystemVerilog
    (
        input int config_hold_time_param
    );
    import "DPI-C" context function void axi_propagate_config_hold_time_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_hold_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_hold_time_from_CY;

    import "DPI-C" context function void axi_set_config_max_transaction_time_factor_from_SystemVerilog
    (
        input int unsigned config_max_transaction_time_factor_param
    );
    import "DPI-C" context function void axi_propagate_config_max_transaction_time_factor_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_max_transaction_time_factor_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_transaction_time_factor_from_CY;

    import "DPI-C" context function void axi_set_config_timeout_max_data_transfer_from_SystemVerilog
    (
        input int config_timeout_max_data_transfer_param
    );
    import "DPI-C" context function void axi_propagate_config_timeout_max_data_transfer_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_timeout_max_data_transfer_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_timeout_max_data_transfer_from_CY;

    import "DPI-C" context function void axi_set_config_burst_timeout_factor_from_SystemVerilog
    (
        input int unsigned config_burst_timeout_factor_param
    );
    import "DPI-C" context function void axi_propagate_config_burst_timeout_factor_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_burst_timeout_factor_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_burst_timeout_factor_from_CY;

    import "DPI-C" context function void axi_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param
    );
    import "DPI-C" context function void axi_propagate_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_max_latency_AWVALID_assertion_to_AWREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_CY;

    import "DPI-C" context function void axi_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param
    );
    import "DPI-C" context function void axi_propagate_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_max_latency_ARVALID_assertion_to_ARREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_CY;

    import "DPI-C" context function void axi_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_RVALID_assertion_to_RREADY_param
    );
    import "DPI-C" context function void axi_propagate_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_max_latency_RVALID_assertion_to_RREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_latency_RVALID_assertion_to_RREADY_from_CY;

    import "DPI-C" context function void axi_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_BVALID_assertion_to_BREADY_param
    );
    import "DPI-C" context function void axi_propagate_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_max_latency_BVALID_assertion_to_BREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_latency_BVALID_assertion_to_BREADY_from_CY;

    import "DPI-C" context function void axi_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_WVALID_assertion_to_WREADY_param
    );
    import "DPI-C" context function void axi_propagate_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_max_latency_WVALID_assertion_to_WREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_latency_WVALID_assertion_to_WREADY_from_CY;

    import "DPI-C" context function void axi_set_config_write_ctrl_first_ratio_from_SystemVerilog
    (
        input int config_write_ctrl_first_ratio_param
    );
    import "DPI-C" context function void axi_propagate_config_write_ctrl_first_ratio_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_write_ctrl_first_ratio_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_write_ctrl_first_ratio_from_CY;

    import "DPI-C" context function void axi_set_config_write_data_first_ratio_from_SystemVerilog
    (
        input int config_write_data_first_ratio_param
    );
    import "DPI-C" context function void axi_propagate_config_write_data_first_ratio_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_write_data_first_ratio_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_write_data_first_ratio_from_CY;

    import "DPI-C" context function void axi_set_config_write_ctrl_to_data_mintime_from_SystemVerilog
    (
        input int unsigned config_write_ctrl_to_data_mintime_param
    );
    import "DPI-C" context function void axi_propagate_config_write_ctrl_to_data_mintime_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_write_ctrl_to_data_mintime_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_write_ctrl_to_data_mintime_from_CY;

    import "DPI-C" context function void axi_set_config_write_data_to_ctrl_mintime_from_SystemVerilog
    (
        input int unsigned config_write_data_to_ctrl_mintime_param
    );
    import "DPI-C" context function void axi_propagate_config_write_data_to_ctrl_mintime_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_write_data_to_ctrl_mintime_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_write_data_to_ctrl_mintime_from_CY;

    import "DPI-C" context function void axi_set_config_master_write_delay_from_SystemVerilog
    (
        input bit config_master_write_delay_param
    );
    import "DPI-C" context function void axi_propagate_config_master_write_delay_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_master_write_delay_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_master_write_delay_from_CY;

    import "DPI-C" context function void axi_set_config_reset_low_clocks_from_SystemVerilog
    (
        input int config_reset_low_clocks_param
    );
    import "DPI-C" context function void axi_propagate_config_reset_low_clocks_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_reset_low_clocks_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_reset_low_clocks_from_CY;

    import "DPI-C" context function void axi_set_config_reset_hold_time_from_SystemVerilog
    (
        input int config_reset_hold_time_param
    );
    import "DPI-C" context function void axi_propagate_config_reset_hold_time_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_reset_hold_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_reset_hold_time_from_CY;

    import "DPI-C" context function void axi_set_config_protect_ready_from_SystemVerilog
    (
        input bit config_protect_ready_param
    );
    import "DPI-C" context function void axi_propagate_config_protect_ready_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_protect_ready_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_protect_ready_from_CY;

    import "DPI-C" context function void axi_set_config_enable_user_sideband_from_SystemVerilog
    (
        input bit config_enable_user_sideband_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_user_sideband_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_user_sideband_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_user_sideband_from_CY;

    import "DPI-C" context function void axi_set_config_extended_length_enable_from_SystemVerilog
    (
        input bit config_extended_length_enable_param
    );
    import "DPI-C" context function void axi_propagate_config_extended_length_enable_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_extended_length_enable_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_extended_length_enable_from_CY;

    import "DPI-C" context function void axi_set_config_enable_burst_reserved_value_from_SystemVerilog
    (
        input bit config_enable_burst_reserved_value_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_burst_reserved_value_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_burst_reserved_value_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_burst_reserved_value_from_CY;

    import "DPI-C" context function void axi_set_config_enable_lock_reserved_value_from_SystemVerilog
    (
        input bit config_enable_lock_reserved_value_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_lock_reserved_value_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_lock_reserved_value_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_lock_reserved_value_from_CY;

    import "DPI-C" context function void axi_set_config_enable_cache_reserved_value_from_SystemVerilog
    (
        input bit config_enable_cache_reserved_value_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_cache_reserved_value_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_cache_reserved_value_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_cache_reserved_value_from_CY;

    import "DPI-C" context function void axi_set_config_enable_all_assertions_from_SystemVerilog
    (
        input bit config_enable_all_assertions_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_all_assertions_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_all_assertions_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_all_assertions_from_CY;

    import "DPI-C" context function void axi_set_config_enable_assertion_from_SystemVerilog
    (
        input bit [255:0] config_enable_assertion_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_assertion_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_assertion_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_assertion_from_CY;

    import "DPI-C" context function void axi_set_config_enable_error_from_SystemVerilog
    (
        input bit [255:0] config_enable_error_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_error_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_error_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_error_from_CY;

    import "DPI-C" context function void axi_set_config_enable_errors_from_SystemVerilog
    (
        input bit config_enable_errors_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_errors_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_errors_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_errors_from_CY;

    import "DPI-C" context function void axi_set_config_enable_all_assertion_errors_from_SystemVerilog
    (
        input bit config_enable_all_assertion_errors_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_all_assertion_errors_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_all_assertion_errors_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_all_assertion_errors_from_CY;

    import "DPI-C" context function void axi_set_config_abstraction_level_from_SystemVerilog
    (
        input int config_abstraction_level_param
    );
    import "DPI-C" context function void axi_propagate_config_abstraction_level_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_abstraction_level_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_abstraction_level_from_CY;

    import "DPI-C" context function void axi_set_config_slave_start_addr_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input bit  config_slave_start_addr_param
    );
    import "DPI-C" context function void axi_propagate_config_slave_start_addr_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_slave_start_addr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_slave_start_addr_from_CY_index1;

    import "DPI-C" context function void axi_set_config_slave_end_addr_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input bit  config_slave_end_addr_param
    );
    import "DPI-C" context function void axi_propagate_config_slave_end_addr_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_slave_end_addr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_slave_end_addr_from_CY_index1;

    import "DPI-C" context function void axi_set_config_enable_slave_addr_range_in_bfm_from_SystemVerilog
    (
        input bit config_enable_slave_addr_range_in_bfm_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_slave_addr_range_in_bfm_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_slave_addr_range_in_bfm_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_slave_addr_range_in_bfm_from_CY;

    import "DPI-C" context function void axi_set_config_read_data_reordering_depth_from_SystemVerilog
    (
        input int unsigned config_read_data_reordering_depth_param
    );
    import "DPI-C" context function void axi_propagate_config_read_data_reordering_depth_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_read_data_reordering_depth_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_read_data_reordering_depth_from_CY;

    import "DPI-C" context function void axi_set_config_enable_read_data_reordering_depth_in_bfm_from_SystemVerilog
    (
        input bit config_enable_read_data_reordering_depth_in_bfm_param
    );
    import "DPI-C" context function void axi_propagate_config_enable_read_data_reordering_depth_in_bfm_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_enable_read_data_reordering_depth_in_bfm_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_enable_read_data_reordering_depth_in_bfm_from_CY;

    import "DPI-C" context function void axi_set_config_awid_wid_mismatch_from_SystemVerilog
    (
        input bit config_awid_wid_mismatch_param
    );
    import "DPI-C" context function void axi_propagate_config_awid_wid_mismatch_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_awid_wid_mismatch_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_awid_wid_mismatch_from_CY;

    import "DPI-C" context function void axi_set_config_length_last_mismatch_error_from_SystemVerilog
    (
        input bit config_length_last_mismatch_error_param
    );
    import "DPI-C" context function void axi_propagate_config_length_last_mismatch_error_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_length_last_mismatch_error_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_length_last_mismatch_error_from_CY;

    import "DPI-C" context function void axi_set_config_master_error_position_from_SystemVerilog
    (
        input int config_master_error_position_param
    );
    import "DPI-C" context function void axi_propagate_config_master_error_position_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_master_error_position_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_master_error_position_from_CY;

    import "DPI-C" context function void axi_set_dummy_var_from_SystemVerilog
    (
        input int dummy_var_param
    );
    import "DPI-C" context function void axi_propagate_dummy_var_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_dummy_var_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_dummy_var_from_CY;

    import "DPI-C" context function void axi_set_config_wlast_length_from_SystemVerilog
    (
        input int config_wlast_length_param
    );
    import "DPI-C" context function void axi_propagate_config_wlast_length_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_wlast_length_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_wlast_length_from_CY;

    import "DPI-C" context function void axi_set_config_wid_for_awid_not_matching_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input bit  config_wid_for_awid_not_matching_param
    );
    import "DPI-C" context function void axi_propagate_config_wid_for_awid_not_matching_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_wid_for_awid_not_matching_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_wid_for_awid_not_matching_from_CY_index1;

    import "DPI-C" context function void axi_set_config_support_exclusive_access_from_SystemVerilog
    (
        input bit config_support_exclusive_access_param
    );
    import "DPI-C" context function void axi_propagate_config_support_exclusive_access_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_support_exclusive_access_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_support_exclusive_access_from_CY;

    import "DPI-C" context function void axi_set_config_write_data_interleaving_depth_from_SystemVerilog
    (
        input int config_write_data_interleaving_depth_param
    );
    import "DPI-C" context function void axi_propagate_config_write_data_interleaving_depth_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_write_data_interleaving_depth_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_write_data_interleaving_depth_from_CY;

    import "DPI-C" context function void axi_set_status_master_error_from_SystemVerilog
    (
        input bit [15:0] status_master_error_param
    );
    import "DPI-C" context function void axi_propagate_status_master_error_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_status_master_error_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_status_master_error_from_CY;

    import "DPI-C" context function void axi_get_status_num_reads_waiting_for_resp_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_status_num_reads_waiting_for_resp_from_CY;

    import "DPI-C" context function void axi_get_status_num_writes_waiting_for_response_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_status_num_writes_waiting_for_response_from_CY;

    import "DPI-C" context function void axi_set_check_total_num_wdata_outstanding_from_SystemVerilog
    (
        input bit check_total_num_wdata_outstanding_param
    );
    import "DPI-C" context function void axi_propagate_check_total_num_wdata_outstanding_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_check_total_num_wdata_outstanding_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_check_total_num_wdata_outstanding_from_CY;

    import "DPI-C" context function void axi_set_total_num_wdata_outstanding_from_SystemVerilog
    (
        input int total_num_wdata_outstanding_param
    );
    import "DPI-C" context function void axi_propagate_total_num_wdata_outstanding_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_total_num_wdata_outstanding_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_total_num_wdata_outstanding_from_CY;

    import "DPI-C" context function void axi_set_check_max_num_wdata_outstanding_per_id_from_SystemVerilog
    (
        input bit check_max_num_wdata_outstanding_per_id_param
    );
    import "DPI-C" context function void axi_propagate_check_max_num_wdata_outstanding_per_id_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_check_max_num_wdata_outstanding_per_id_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_check_max_num_wdata_outstanding_per_id_from_CY;

    import "DPI-C" context function void axi_set_max_num_wdata_outstanding_per_id_from_SystemVerilog
    (
        input int max_num_wdata_outstanding_per_id_param
    );
    import "DPI-C" context function void axi_propagate_max_num_wdata_outstanding_per_id_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_max_num_wdata_outstanding_per_id_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_max_num_wdata_outstanding_per_id_from_CY;

    import "DPI-C" context function void axi_set_check_max_num_waddr_outstanding_per_id_from_SystemVerilog
    (
        input bit check_max_num_waddr_outstanding_per_id_param
    );
    import "DPI-C" context function void axi_propagate_check_max_num_waddr_outstanding_per_id_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_check_max_num_waddr_outstanding_per_id_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_check_max_num_waddr_outstanding_per_id_from_CY;

    import "DPI-C" context function void axi_set_max_num_waddr_outstanding_per_id_from_SystemVerilog
    (
        input int max_num_waddr_outstanding_per_id_param
    );
    import "DPI-C" context function void axi_propagate_max_num_waddr_outstanding_per_id_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_max_num_waddr_outstanding_per_id_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_max_num_waddr_outstanding_per_id_from_CY;

    import "DPI-C" context function void axi_set_check_total_num_waddr_outstanding_from_SystemVerilog
    (
        input bit check_total_num_waddr_outstanding_param
    );
    import "DPI-C" context function void axi_propagate_check_total_num_waddr_outstanding_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_check_total_num_waddr_outstanding_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_check_total_num_waddr_outstanding_from_CY;

    import "DPI-C" context function void axi_set_total_num_waddr_outstanding_from_SystemVerilog
    (
        input int total_num_waddr_outstanding_param
    );
    import "DPI-C" context function void axi_propagate_total_num_waddr_outstanding_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_total_num_waddr_outstanding_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_total_num_waddr_outstanding_from_CY;

    import "DPI-C" context function void axi_set_status_outstanding_num_for_waddr_from_SystemVerilog
    (
        input int status_outstanding_num_for_waddr_param
    );
    import "DPI-C" context function void axi_propagate_status_outstanding_num_for_waddr_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_status_outstanding_num_for_waddr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_status_outstanding_num_for_waddr_from_CY;

    import "DPI-C" context function void axi_set_start_finding_outstanding_waddr_from_SystemVerilog
    (
        input bit start_finding_outstanding_waddr_param
    );
    import "DPI-C" context function void axi_propagate_start_finding_outstanding_waddr_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_start_finding_outstanding_waddr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_start_finding_outstanding_waddr_from_CY;

    import "DPI-C" context function void axi_set_status_outstanding_num_for_wdata_from_SystemVerilog
    (
        input int status_outstanding_num_for_wdata_param
    );
    import "DPI-C" context function void axi_propagate_status_outstanding_num_for_wdata_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_status_outstanding_num_for_wdata_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_status_outstanding_num_for_wdata_from_CY;

    import "DPI-C" context function void axi_set_start_finding_outstanding_wdata_from_SystemVerilog
    (
        input bit start_finding_outstanding_wdata_param
    );
    import "DPI-C" context function void axi_propagate_start_finding_outstanding_wdata_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_start_finding_outstanding_wdata_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_start_finding_outstanding_wdata_from_CY;

    import "DPI-C" context function void axi_set_find_waddr_outstanding_for_wid_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input bit  find_waddr_outstanding_for_wid_param
    );
    import "DPI-C" context function void axi_propagate_find_waddr_outstanding_for_wid_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_find_waddr_outstanding_for_wid_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_find_waddr_outstanding_for_wid_from_CY_index1;

    import "DPI-C" context function void axi_set_find_wdata_outstanding_for_wid_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input bit  find_wdata_outstanding_for_wid_param
    );
    import "DPI-C" context function void axi_propagate_find_wdata_outstanding_for_wid_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_find_wdata_outstanding_for_wid_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_find_wdata_outstanding_for_wid_from_CY_index1;

    import "DPI-C" context function void axi_set_change_in_wdata_outstanding_per_id_from_SystemVerilog
    (
        input bit change_in_wdata_outstanding_per_id_param
    );
    import "DPI-C" context function void axi_propagate_change_in_wdata_outstanding_per_id_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_change_in_wdata_outstanding_per_id_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_change_in_wdata_outstanding_per_id_from_CY;

    import "DPI-C" context function void axi_set_start_finding_change_in_wdata_from_SystemVerilog
    (
        input bit start_finding_change_in_wdata_param
    );
    import "DPI-C" context function void axi_propagate_start_finding_change_in_wdata_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_start_finding_change_in_wdata_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_start_finding_change_in_wdata_from_CY;

    import "DPI-C" context function void axi_set_find_change_in_wdata_outstanding_for_wid_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input bit  find_change_in_wdata_outstanding_for_wid_param
    );
    import "DPI-C" context function void axi_propagate_find_change_in_wdata_outstanding_for_wid_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_find_change_in_wdata_outstanding_for_wid_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_find_change_in_wdata_outstanding_for_wid_from_CY_index1;

    import "DPI-C" context function void axi_set_config_max_outstanding_wr_from_SystemVerilog
    (
        input int config_max_outstanding_wr_param
    );
    import "DPI-C" context function void axi_propagate_config_max_outstanding_wr_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_max_outstanding_wr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_outstanding_wr_from_CY;

    import "DPI-C" context function void axi_set_config_max_outstanding_rd_from_SystemVerilog
    (
        input int config_max_outstanding_rd_param
    );
    import "DPI-C" context function void axi_propagate_config_max_outstanding_rd_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_max_outstanding_rd_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_max_outstanding_rd_from_CY;

    import "DPI-C" context function void axi_set_config_error_on_deleted_valid_cycles_from_SystemVerilog
    (
        input bit config_error_on_deleted_valid_cycles_param
    );
    import "DPI-C" context function void axi_propagate_config_error_on_deleted_valid_cycles_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_error_on_deleted_valid_cycles_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_error_on_deleted_valid_cycles_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_from_SystemVerilog
    (
        input bit config_stats_enable_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_AXI_read_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_AXI_read_occupancy_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_AXI_read_occupancy_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_AXI_read_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_AXI_read_occupancy_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_AXI_write_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_AXI_write_occupancy_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_AXI_write_occupancy_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_AXI_write_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_AXI_write_occupancy_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_read_data_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_read_data_occupancy_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_read_data_occupancy_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_read_data_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_read_data_occupancy_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_write_data_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_write_data_occupancy_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_write_data_occupancy_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_write_data_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_write_data_occupancy_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_read_latency_from_SystemVerilog
    (
        input bit config_stats_enable_read_latency_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_read_latency_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_read_latency_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_read_latency_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_write_latency_from_SystemVerilog
    (
        input bit config_stats_enable_write_latency_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_write_latency_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_write_latency_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_write_latency_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_read_address_waits_from_SystemVerilog
    (
        input bit config_stats_enable_read_address_waits_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_read_address_waits_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_read_address_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_read_address_waits_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_read_data_waits_from_SystemVerilog
    (
        input bit config_stats_enable_read_data_waits_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_read_data_waits_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_read_data_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_read_data_waits_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_write_address_waits_from_SystemVerilog
    (
        input bit config_stats_enable_write_address_waits_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_write_address_waits_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_write_address_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_write_address_waits_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_write_data_waits_from_SystemVerilog
    (
        input bit config_stats_enable_write_data_waits_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_write_data_waits_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_write_data_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_write_data_waits_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_write_response_waits_from_SystemVerilog
    (
        input bit config_stats_enable_write_response_waits_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_write_response_waits_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_write_response_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_write_response_waits_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_read_bandwidth_from_SystemVerilog
    (
        input bit config_stats_enable_read_bandwidth_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_read_bandwidth_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_read_bandwidth_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_read_bandwidth_from_CY;

    import "DPI-C" context function void axi_set_config_stats_enable_write_bandwidth_from_SystemVerilog
    (
        input bit config_stats_enable_write_bandwidth_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_enable_write_bandwidth_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_enable_write_bandwidth_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_enable_write_bandwidth_from_CY;

    import "DPI-C" context function void axi_set_config_stats_AXI_read_occupancy_step_from_SystemVerilog
    (
        input int config_stats_AXI_read_occupancy_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_AXI_read_occupancy_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_AXI_read_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_AXI_read_occupancy_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_AXI_read_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_AXI_read_occupancy_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_AXI_read_occupancy_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_AXI_read_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_AXI_read_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_active_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_active_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_occupancy_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_occupancy_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_occupancy_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_idle_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_occupancy_min_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_idle_min_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_occupancy_max_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_idle_max_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_occupancy_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_idle_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_AXI_write_occupancy_step_from_SystemVerilog
    (
        input int config_stats_AXI_write_occupancy_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_AXI_write_occupancy_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_AXI_write_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_AXI_write_occupancy_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_AXI_write_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_AXI_write_occupancy_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_AXI_write_occupancy_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_AXI_write_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_AXI_write_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_active_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_active_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_occupancy_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_occupancy_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_occupancy_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_idle_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_occupancy_min_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_idle_min_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_occupancy_max_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_idle_max_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_occupancy_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_idle_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_data_occupancy_step_from_SystemVerilog
    (
        input int config_stats_read_data_occupancy_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_read_data_occupancy_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_read_data_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_data_occupancy_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_read_data_occupancy_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_read_data_occupancy_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_read_data_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_data_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_occupancy_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_occupancy_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_occupancy_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_idle_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_occupancy_min_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_idle_min_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_occupancy_max_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_idle_max_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_occupancy_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_idle_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_data_occupancy_step_from_SystemVerilog
    (
        input int config_stats_write_data_occupancy_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_data_occupancy_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_data_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_data_occupancy_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_write_data_occupancy_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_data_occupancy_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_data_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_data_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_occupancy_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_occupancy_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_occupancy_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_idle_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_occupancy_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_idle_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_occupancy_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_idle_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_occupancy_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_idle_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_bandwidth_step_from_SystemVerilog
    (
        input int config_stats_read_bandwidth_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_read_bandwidth_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_read_bandwidth_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_bandwidth_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_bandwidth_multiple_from_SystemVerilog
    (
        input int config_stats_read_bandwidth_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_read_bandwidth_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_read_bandwidth_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_bandwidth_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_read_bandwidth_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_bandwidth_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_read_bandwidth_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_bandwidth_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_read_bandwidth_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_bandwidth_min_from_CY;

    import "DPI-C" context function void axi_get_stats_read_bandwidth_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_bandwidth_max_from_CY;

    import "DPI-C" context function void axi_get_stats_read_bandwidth_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_bandwidth_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_bandwidth_step_from_SystemVerilog
    (
        input int config_stats_write_bandwidth_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_bandwidth_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_bandwidth_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_bandwidth_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_bandwidth_multiple_from_SystemVerilog
    (
        input int config_stats_write_bandwidth_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_bandwidth_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_bandwidth_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_bandwidth_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_write_bandwidth_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_bandwidth_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_bandwidth_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_bandwidth_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_write_bandwidth_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_bandwidth_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_bandwidth_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_bandwidth_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_bandwidth_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_bandwidth_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_latency_step_from_SystemVerilog
    (
        input int config_stats_read_latency_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_read_latency_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_read_latency_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_latency_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_latency_multiple_from_SystemVerilog
    (
        input int config_stats_read_latency_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_read_latency_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_read_latency_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_latency_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_read_latency_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_latency_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_data_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_data_latency_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_data_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_data_latency_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_data_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_data_latency_min_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_data_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_data_latency_max_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_data_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_data_latency_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_address_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_address_latency_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_address_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_address_latency_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_address_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_address_latency_min_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_address_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_address_latency_max_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_address_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_address_latency_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_latency_step_from_SystemVerilog
    (
        input int config_stats_write_latency_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_latency_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_latency_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_latency_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_latency_multiple_from_SystemVerilog
    (
        input int config_stats_write_latency_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_latency_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_latency_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_latency_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_write_latency_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_latency_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_data_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_data_latency_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_data_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_data_latency_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_data_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_data_latency_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_data_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_data_latency_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_data_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_data_latency_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_response_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_response_latency_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_response_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_response_latency_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_response_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_response_latency_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_response_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_response_latency_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_response_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_response_latency_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_address_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_address_latency_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_address_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_address_latency_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_address_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_address_latency_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_address_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_address_latency_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_address_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_address_latency_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_address_waits_step_from_SystemVerilog
    (
        input int config_stats_read_address_waits_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_read_address_waits_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_read_address_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_address_waits_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_address_waits_multiple_from_SystemVerilog
    (
        input int config_stats_read_address_waits_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_read_address_waits_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_read_address_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_address_waits_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_waits_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_waits_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_waits_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_waits_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_waits_min_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_waits_max_from_CY;

    import "DPI-C" context function void axi_get_stats_read_address_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_address_waits_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_data_waits_step_from_SystemVerilog
    (
        input int config_stats_read_data_waits_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_read_data_waits_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_read_data_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_data_waits_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_read_data_waits_multiple_from_SystemVerilog
    (
        input int config_stats_read_data_waits_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_read_data_waits_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_read_data_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_read_data_waits_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_waits_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_waits_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_waits_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_waits_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_waits_min_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_waits_max_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_waits_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_address_waits_step_from_SystemVerilog
    (
        input int config_stats_write_address_waits_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_address_waits_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_address_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_address_waits_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_address_waits_multiple_from_SystemVerilog
    (
        input int config_stats_write_address_waits_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_address_waits_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_address_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_address_waits_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_waits_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_waits_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_waits_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_waits_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_waits_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_waits_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_address_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_address_waits_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_data_waits_step_from_SystemVerilog
    (
        input int config_stats_write_data_waits_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_data_waits_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_data_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_data_waits_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_data_waits_multiple_from_SystemVerilog
    (
        input int config_stats_write_data_waits_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_data_waits_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_data_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_data_waits_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_waits_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_waits_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_waits_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_waits_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_waits_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_waits_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_waits_mean_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_response_waits_step_from_SystemVerilog
    (
        input int config_stats_write_response_waits_step_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_response_waits_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_response_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_response_waits_step_from_CY;

    import "DPI-C" context function void axi_set_config_stats_write_response_waits_multiple_from_SystemVerilog
    (
        input int config_stats_write_response_waits_multiple_param
    );
    import "DPI-C" context function void axi_propagate_config_stats_write_response_waits_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi_get_config_stats_write_response_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_config_stats_write_response_waits_multiple_from_CY;

    import "DPI-C" context function void axi_get_stats_write_response_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_response_waits_inst_from_CY;

    import "DPI-C" context function void axi_get_stats_write_response_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_response_waits_sw_from_CY;

    import "DPI-C" context function void axi_get_stats_write_response_waits_sw_updated_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_response_waits_sw_updated_from_CY;

    import "DPI-C" context function void axi_get_stats_write_response_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_response_waits_min_from_CY;

    import "DPI-C" context function void axi_get_stats_write_response_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_response_waits_max_from_CY;

    import "DPI-C" context function void axi_get_stats_write_response_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_response_waits_mean_from_CY;

    import "DPI-C" context function void axi_get_stats_rw_transaction_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_rw_transaction_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_read_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_read_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_AXI_write_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_AXI_write_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_read_addr_channel_phase_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_addr_channel_phase_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_read_data_burst_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_data_burst_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_read_channel_phase_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_read_channel_phase_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_write_addr_channel_phase_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_addr_channel_phase_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_write_data_burst_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_data_burst_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_write_channel_phase_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_channel_phase_last_duration_from_CY;

    import "DPI-C" context function void axi_get_stats_write_resp_channel_phase_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi_set_stats_write_resp_channel_phase_last_duration_from_CY;

    function void axi_set_ACLK_from_CY( bit ACLK_param );
        internal_ACLK = ACLK_param;
    endfunction

    function void axi_initialise_ACLK_from_CY();
        internal_ACLK = 'z;
        m_ACLK = 'z;
    endfunction

    function void axi_set_ARESETn_from_CY( logic ARESETn_param );
        internal_ARESETn = ARESETn_param;
    endfunction

    function void axi_initialise_ARESETn_from_CY();
        internal_ARESETn = 'z;
        m_ARESETn = 'z;
    endfunction

    function void axi_set_AWVALID_from_CY( logic AWVALID_param );
        internal_AWVALID = AWVALID_param;
    endfunction

    function void axi_initialise_AWVALID_from_CY();
        internal_AWVALID = 'z;
        m_AWVALID = 'z;
    endfunction

    function void axi_set_AWADDR_from_CY_index1( int _this_dot_1, logic  AWADDR_param );
        internal_AWADDR[_this_dot_1] = AWADDR_param;
    endfunction

    function void axi_initialise_AWADDR_from_CY();
        internal_AWADDR = 'z;
        m_AWADDR = 'z;
    endfunction

    function void axi_set_AWLEN_from_CY( logic [3:0] AWLEN_param );
        internal_AWLEN = AWLEN_param;
    endfunction

    function void axi_initialise_AWLEN_from_CY();
        internal_AWLEN = 'z;
        m_AWLEN = 'z;
    endfunction

    function void axi_set_AWSIZE_from_CY( logic [2:0] AWSIZE_param );
        internal_AWSIZE = AWSIZE_param;
    endfunction

    function void axi_initialise_AWSIZE_from_CY();
        internal_AWSIZE = 'z;
        m_AWSIZE = 'z;
    endfunction

    function void axi_set_AWBURST_from_CY( logic [1:0] AWBURST_param );
        internal_AWBURST = AWBURST_param;
    endfunction

    function void axi_initialise_AWBURST_from_CY();
        internal_AWBURST = 'z;
        m_AWBURST = 'z;
    endfunction

    function void axi_set_AWLOCK_from_CY( logic [1:0] AWLOCK_param );
        internal_AWLOCK = AWLOCK_param;
    endfunction

    function void axi_initialise_AWLOCK_from_CY();
        internal_AWLOCK = 'z;
        m_AWLOCK = 'z;
    endfunction

    function void axi_set_AWCACHE_from_CY( logic [3:0] AWCACHE_param );
        internal_AWCACHE = AWCACHE_param;
    endfunction

    function void axi_initialise_AWCACHE_from_CY();
        internal_AWCACHE = 'z;
        m_AWCACHE = 'z;
    endfunction

    function void axi_set_AWPROT_from_CY( logic [2:0] AWPROT_param );
        internal_AWPROT = AWPROT_param;
    endfunction

    function void axi_initialise_AWPROT_from_CY();
        internal_AWPROT = 'z;
        m_AWPROT = 'z;
    endfunction

    function void axi_set_AWID_from_CY_index1( int _this_dot_1, logic  AWID_param );
        internal_AWID[_this_dot_1] = AWID_param;
    endfunction

    function void axi_initialise_AWID_from_CY();
        internal_AWID = 'z;
        m_AWID = 'z;
    endfunction

    function void axi_set_AWREADY_from_CY( logic AWREADY_param );
        internal_AWREADY = AWREADY_param;
    endfunction

    function void axi_initialise_AWREADY_from_CY();
        internal_AWREADY = 'z;
        m_AWREADY = 'z;
    endfunction

    function void axi_set_AWUSER_from_CY( logic [7:0] AWUSER_param );
        internal_AWUSER = AWUSER_param;
    endfunction

    function void axi_initialise_AWUSER_from_CY();
        internal_AWUSER = 'z;
        m_AWUSER = 'z;
    endfunction

    function void axi_set_ARVALID_from_CY( logic ARVALID_param );
        internal_ARVALID = ARVALID_param;
    endfunction

    function void axi_initialise_ARVALID_from_CY();
        internal_ARVALID = 'z;
        m_ARVALID = 'z;
    endfunction

    function void axi_set_ARADDR_from_CY_index1( int _this_dot_1, logic  ARADDR_param );
        internal_ARADDR[_this_dot_1] = ARADDR_param;
    endfunction

    function void axi_initialise_ARADDR_from_CY();
        internal_ARADDR = 'z;
        m_ARADDR = 'z;
    endfunction

    function void axi_set_ARLEN_from_CY( logic [3:0] ARLEN_param );
        internal_ARLEN = ARLEN_param;
    endfunction

    function void axi_initialise_ARLEN_from_CY();
        internal_ARLEN = 'z;
        m_ARLEN = 'z;
    endfunction

    function void axi_set_ARSIZE_from_CY( logic [2:0] ARSIZE_param );
        internal_ARSIZE = ARSIZE_param;
    endfunction

    function void axi_initialise_ARSIZE_from_CY();
        internal_ARSIZE = 'z;
        m_ARSIZE = 'z;
    endfunction

    function void axi_set_ARBURST_from_CY( logic [1:0] ARBURST_param );
        internal_ARBURST = ARBURST_param;
    endfunction

    function void axi_initialise_ARBURST_from_CY();
        internal_ARBURST = 'z;
        m_ARBURST = 'z;
    endfunction

    function void axi_set_ARLOCK_from_CY( logic [1:0] ARLOCK_param );
        internal_ARLOCK = ARLOCK_param;
    endfunction

    function void axi_initialise_ARLOCK_from_CY();
        internal_ARLOCK = 'z;
        m_ARLOCK = 'z;
    endfunction

    function void axi_set_ARCACHE_from_CY( logic [3:0] ARCACHE_param );
        internal_ARCACHE = ARCACHE_param;
    endfunction

    function void axi_initialise_ARCACHE_from_CY();
        internal_ARCACHE = 'z;
        m_ARCACHE = 'z;
    endfunction

    function void axi_set_ARPROT_from_CY( logic [2:0] ARPROT_param );
        internal_ARPROT = ARPROT_param;
    endfunction

    function void axi_initialise_ARPROT_from_CY();
        internal_ARPROT = 'z;
        m_ARPROT = 'z;
    endfunction

    function void axi_set_ARID_from_CY_index1( int _this_dot_1, logic  ARID_param );
        internal_ARID[_this_dot_1] = ARID_param;
    endfunction

    function void axi_initialise_ARID_from_CY();
        internal_ARID = 'z;
        m_ARID = 'z;
    endfunction

    function void axi_set_ARREADY_from_CY( logic ARREADY_param );
        internal_ARREADY = ARREADY_param;
    endfunction

    function void axi_initialise_ARREADY_from_CY();
        internal_ARREADY = 'z;
        m_ARREADY = 'z;
    endfunction

    function void axi_set_ARUSER_from_CY( logic [7:0] ARUSER_param );
        internal_ARUSER = ARUSER_param;
    endfunction

    function void axi_initialise_ARUSER_from_CY();
        internal_ARUSER = 'z;
        m_ARUSER = 'z;
    endfunction

    function void axi_set_RVALID_from_CY( logic RVALID_param );
        internal_RVALID = RVALID_param;
    endfunction

    function void axi_initialise_RVALID_from_CY();
        internal_RVALID = 'z;
        m_RVALID = 'z;
    endfunction

    function void axi_set_RLAST_from_CY( logic RLAST_param );
        internal_RLAST = RLAST_param;
    endfunction

    function void axi_initialise_RLAST_from_CY();
        internal_RLAST = 'z;
        m_RLAST = 'z;
    endfunction

    function void axi_set_RDATA_from_CY_index1( int _this_dot_1, logic  RDATA_param );
        internal_RDATA[_this_dot_1] = RDATA_param;
    endfunction

    function void axi_initialise_RDATA_from_CY();
        internal_RDATA = 'z;
        m_RDATA = 'z;
    endfunction

    function void axi_set_RRESP_from_CY( logic [1:0] RRESP_param );
        internal_RRESP = RRESP_param;
    endfunction

    function void axi_initialise_RRESP_from_CY();
        internal_RRESP = 'z;
        m_RRESP = 'z;
    endfunction

    function void axi_set_RID_from_CY_index1( int _this_dot_1, logic  RID_param );
        internal_RID[_this_dot_1] = RID_param;
    endfunction

    function void axi_initialise_RID_from_CY();
        internal_RID = 'z;
        m_RID = 'z;
    endfunction

    function void axi_set_RREADY_from_CY( logic RREADY_param );
        internal_RREADY = RREADY_param;
    endfunction

    function void axi_initialise_RREADY_from_CY();
        internal_RREADY = 'z;
        m_RREADY = 'z;
    endfunction

    function void axi_set_RUSER_from_CY( logic [7:0] RUSER_param );
        internal_RUSER = RUSER_param;
    endfunction

    function void axi_initialise_RUSER_from_CY();
        internal_RUSER = 'z;
        m_RUSER = 'z;
    endfunction

    function void axi_set_WVALID_from_CY( logic WVALID_param );
        internal_WVALID = WVALID_param;
    endfunction

    function void axi_initialise_WVALID_from_CY();
        internal_WVALID = 'z;
        m_WVALID = 'z;
    endfunction

    function void axi_set_WLAST_from_CY( logic WLAST_param );
        internal_WLAST = WLAST_param;
    endfunction

    function void axi_initialise_WLAST_from_CY();
        internal_WLAST = 'z;
        m_WLAST = 'z;
    endfunction

    function void axi_set_WDATA_from_CY_index1( int _this_dot_1, logic  WDATA_param );
        internal_WDATA[_this_dot_1] = WDATA_param;
    endfunction

    function void axi_initialise_WDATA_from_CY();
        internal_WDATA = 'z;
        m_WDATA = 'z;
    endfunction

    function void axi_set_WSTRB_from_CY_index1( int _this_dot_1, logic  WSTRB_param );
        internal_WSTRB[_this_dot_1] = WSTRB_param;
    endfunction

    function void axi_initialise_WSTRB_from_CY();
        internal_WSTRB = 'z;
        m_WSTRB = 'z;
    endfunction

    function void axi_set_WID_from_CY_index1( int _this_dot_1, logic  WID_param );
        internal_WID[_this_dot_1] = WID_param;
    endfunction

    function void axi_initialise_WID_from_CY();
        internal_WID = 'z;
        m_WID = 'z;
    endfunction

    function void axi_set_WREADY_from_CY( logic WREADY_param );
        internal_WREADY = WREADY_param;
    endfunction

    function void axi_initialise_WREADY_from_CY();
        internal_WREADY = 'z;
        m_WREADY = 'z;
    endfunction

    function void axi_set_WUSER_from_CY( logic [7:0] WUSER_param );
        internal_WUSER = WUSER_param;
    endfunction

    function void axi_initialise_WUSER_from_CY();
        internal_WUSER = 'z;
        m_WUSER = 'z;
    endfunction

    function void axi_set_BVALID_from_CY( logic BVALID_param );
        internal_BVALID = BVALID_param;
    endfunction

    function void axi_initialise_BVALID_from_CY();
        internal_BVALID = 'z;
        m_BVALID = 'z;
    endfunction

    function void axi_set_BRESP_from_CY( logic [1:0] BRESP_param );
        internal_BRESP = BRESP_param;
    endfunction

    function void axi_initialise_BRESP_from_CY();
        internal_BRESP = 'z;
        m_BRESP = 'z;
    endfunction

    function void axi_set_BID_from_CY_index1( int _this_dot_1, logic  BID_param );
        internal_BID[_this_dot_1] = BID_param;
    endfunction

    function void axi_initialise_BID_from_CY();
        internal_BID = 'z;
        m_BID = 'z;
    endfunction

    function void axi_set_BREADY_from_CY( logic BREADY_param );
        internal_BREADY = BREADY_param;
    endfunction

    function void axi_initialise_BREADY_from_CY();
        internal_BREADY = 'z;
        m_BREADY = 'z;
    endfunction

    function void axi_set_BUSER_from_CY( logic [7:0] BUSER_param );
        internal_BUSER = BUSER_param;
    endfunction

    function void axi_initialise_BUSER_from_CY();
        internal_BUSER = 'z;
        m_BUSER = 'z;
    endfunction

    function void axi_set_config_clk_init_value_from_CY( bit config_clk_init_value_param );
        config_clk_init_value = config_clk_init_value_param;
    endfunction

    function void axi_set_config_clk_phase_shift_from_CY( int config_clk_phase_shift_param );
        config_clk_phase_shift = config_clk_phase_shift_param;
    endfunction

    function void axi_set_config_clk_1st_time_from_CY( int config_clk_1st_time_param );
        config_clk_1st_time = config_clk_1st_time_param;
    endfunction

    function void axi_set_config_clk_2nd_time_from_CY( int config_clk_2nd_time_param );
        config_clk_2nd_time = config_clk_2nd_time_param;
    endfunction

    function void axi_set_config_setup_time_from_CY( int config_setup_time_param );
        config_setup_time = config_setup_time_param;
    endfunction

    function void axi_set_config_hold_time_from_CY( int config_hold_time_param );
        config_hold_time = config_hold_time_param;
    endfunction

    function void axi_set_config_max_transaction_time_factor_from_CY( int unsigned config_max_transaction_time_factor_param );
        config_max_transaction_time_factor = config_max_transaction_time_factor_param;
    endfunction

    function void axi_set_config_timeout_max_data_transfer_from_CY( int config_timeout_max_data_transfer_param );
        config_timeout_max_data_transfer = config_timeout_max_data_transfer_param;
    endfunction

    function void axi_set_config_burst_timeout_factor_from_CY( int unsigned config_burst_timeout_factor_param );
        config_burst_timeout_factor = config_burst_timeout_factor_param;
    endfunction

    function void axi_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_CY( int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
        config_max_latency_AWVALID_assertion_to_AWREADY = config_max_latency_AWVALID_assertion_to_AWREADY_param;
    endfunction

    function void axi_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_CY( int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
        config_max_latency_ARVALID_assertion_to_ARREADY = config_max_latency_ARVALID_assertion_to_ARREADY_param;
    endfunction

    function void axi_set_config_max_latency_RVALID_assertion_to_RREADY_from_CY( int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
        config_max_latency_RVALID_assertion_to_RREADY = config_max_latency_RVALID_assertion_to_RREADY_param;
    endfunction

    function void axi_set_config_max_latency_BVALID_assertion_to_BREADY_from_CY( int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
        config_max_latency_BVALID_assertion_to_BREADY = config_max_latency_BVALID_assertion_to_BREADY_param;
    endfunction

    function void axi_set_config_max_latency_WVALID_assertion_to_WREADY_from_CY( int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
        config_max_latency_WVALID_assertion_to_WREADY = config_max_latency_WVALID_assertion_to_WREADY_param;
    endfunction

    function void axi_set_config_write_ctrl_first_ratio_from_CY( int config_write_ctrl_first_ratio_param );
        config_write_ctrl_first_ratio = config_write_ctrl_first_ratio_param;
    endfunction

    function void axi_set_config_write_data_first_ratio_from_CY( int config_write_data_first_ratio_param );
        config_write_data_first_ratio = config_write_data_first_ratio_param;
    endfunction

    function void axi_set_config_write_ctrl_to_data_mintime_from_CY( int unsigned config_write_ctrl_to_data_mintime_param );
        config_write_ctrl_to_data_mintime = config_write_ctrl_to_data_mintime_param;
    endfunction

    function void axi_set_config_write_data_to_ctrl_mintime_from_CY( int unsigned config_write_data_to_ctrl_mintime_param );
        config_write_data_to_ctrl_mintime = config_write_data_to_ctrl_mintime_param;
    endfunction

    function void axi_set_config_master_write_delay_from_CY( bit config_master_write_delay_param );
        config_master_write_delay = config_master_write_delay_param;
    endfunction

    function void axi_set_config_reset_low_clocks_from_CY( int config_reset_low_clocks_param );
        config_reset_low_clocks = config_reset_low_clocks_param;
    endfunction

    function void axi_set_config_reset_hold_time_from_CY( int config_reset_hold_time_param );
        config_reset_hold_time = config_reset_hold_time_param;
    endfunction

    function void axi_set_config_protect_ready_from_CY( bit config_protect_ready_param );
        config_protect_ready = config_protect_ready_param;
    endfunction

    function void axi_set_config_enable_user_sideband_from_CY( bit config_enable_user_sideband_param );
        config_enable_user_sideband = config_enable_user_sideband_param;
    endfunction

    function void axi_set_config_extended_length_enable_from_CY( bit config_extended_length_enable_param );
        config_extended_length_enable = config_extended_length_enable_param;
    endfunction

    function void axi_set_config_enable_burst_reserved_value_from_CY( bit config_enable_burst_reserved_value_param );
        config_enable_burst_reserved_value = config_enable_burst_reserved_value_param;
    endfunction

    function void axi_set_config_enable_lock_reserved_value_from_CY( bit config_enable_lock_reserved_value_param );
        config_enable_lock_reserved_value = config_enable_lock_reserved_value_param;
    endfunction

    function void axi_set_config_enable_cache_reserved_value_from_CY( bit config_enable_cache_reserved_value_param );
        config_enable_cache_reserved_value = config_enable_cache_reserved_value_param;
    endfunction

    function void axi_set_config_enable_all_assertions_from_CY( bit config_enable_all_assertions_param );
        config_enable_all_assertions = config_enable_all_assertions_param;
    endfunction

    function void axi_set_config_enable_assertion_from_CY( bit [255:0] config_enable_assertion_param );
        config_enable_assertion = config_enable_assertion_param;
    endfunction

    function void axi_set_config_enable_error_from_CY( bit [255:0] config_enable_error_param );
        config_enable_error = config_enable_error_param;
    endfunction

    function void axi_set_config_enable_errors_from_CY( bit config_enable_errors_param );
        config_enable_errors = config_enable_errors_param;
    endfunction

    function void axi_set_config_enable_all_assertion_errors_from_CY( bit config_enable_all_assertion_errors_param );
        config_enable_all_assertion_errors = config_enable_all_assertion_errors_param;
    endfunction

    function void axi_set_config_abstraction_level_from_CY(     int config_abstraction_level_param);
        config_abstraction_level = axi_abstraction_level_e'( config_abstraction_level_param );
    endfunction

    function void axi_set_config_slave_start_addr_from_CY_index1( int _this_dot_1, bit  config_slave_start_addr_param );
        config_slave_start_addr[_this_dot_1] = config_slave_start_addr_param;
    endfunction

    function void axi_set_config_slave_end_addr_from_CY_index1( int _this_dot_1, bit  config_slave_end_addr_param );
        config_slave_end_addr[_this_dot_1] = config_slave_end_addr_param;
    endfunction

    function void axi_set_config_enable_slave_addr_range_in_bfm_from_CY( bit config_enable_slave_addr_range_in_bfm_param );
        config_enable_slave_addr_range_in_bfm = config_enable_slave_addr_range_in_bfm_param;
    endfunction

    function void axi_set_config_read_data_reordering_depth_from_CY( int unsigned config_read_data_reordering_depth_param );
        config_read_data_reordering_depth = config_read_data_reordering_depth_param;
    endfunction

    function void axi_set_config_enable_read_data_reordering_depth_in_bfm_from_CY( bit config_enable_read_data_reordering_depth_in_bfm_param );
        config_enable_read_data_reordering_depth_in_bfm = config_enable_read_data_reordering_depth_in_bfm_param;
    endfunction

    function void axi_set_config_awid_wid_mismatch_from_CY( bit config_awid_wid_mismatch_param );
        config_awid_wid_mismatch = config_awid_wid_mismatch_param;
    endfunction

    function void axi_set_config_length_last_mismatch_error_from_CY( bit config_length_last_mismatch_error_param );
        config_length_last_mismatch_error = config_length_last_mismatch_error_param;
    endfunction

    function void axi_set_config_master_error_position_from_CY(     int config_master_error_position_param);
        config_master_error_position = axi_error_e'( config_master_error_position_param );
    endfunction

    function void axi_set_dummy_var_from_CY(     int dummy_var_param);
        dummy_var = axi_assertion_type_e'( dummy_var_param );
    endfunction

    function void axi_set_config_wlast_length_from_CY( int config_wlast_length_param );
        config_wlast_length = config_wlast_length_param;
    endfunction

    function void axi_set_config_wid_for_awid_not_matching_from_CY_index1( int _this_dot_1, bit  config_wid_for_awid_not_matching_param );
        config_wid_for_awid_not_matching[_this_dot_1] = config_wid_for_awid_not_matching_param;
    endfunction

    function void axi_set_config_support_exclusive_access_from_CY( bit config_support_exclusive_access_param );
        config_support_exclusive_access = config_support_exclusive_access_param;
    endfunction

    function void axi_set_config_write_data_interleaving_depth_from_CY( int config_write_data_interleaving_depth_param );
        config_write_data_interleaving_depth = config_write_data_interleaving_depth_param;
    endfunction

    function void axi_set_status_master_error_from_CY( bit [15:0] status_master_error_param );
        status_master_error = status_master_error_param;
    endfunction

    function void axi_set_status_num_reads_waiting_for_resp_from_CY( int status_num_reads_waiting_for_resp_param );
        status_num_reads_waiting_for_resp = status_num_reads_waiting_for_resp_param;
    endfunction

    function void axi_set_status_num_writes_waiting_for_response_from_CY( int status_num_writes_waiting_for_response_param );
        status_num_writes_waiting_for_response = status_num_writes_waiting_for_response_param;
    endfunction

    function void axi_set_check_total_num_wdata_outstanding_from_CY( bit check_total_num_wdata_outstanding_param );
        check_total_num_wdata_outstanding = check_total_num_wdata_outstanding_param;
    endfunction

    function void axi_set_total_num_wdata_outstanding_from_CY( int total_num_wdata_outstanding_param );
        total_num_wdata_outstanding = total_num_wdata_outstanding_param;
    endfunction

    function void axi_set_check_max_num_wdata_outstanding_per_id_from_CY( bit check_max_num_wdata_outstanding_per_id_param );
        check_max_num_wdata_outstanding_per_id = check_max_num_wdata_outstanding_per_id_param;
    endfunction

    function void axi_set_max_num_wdata_outstanding_per_id_from_CY( int max_num_wdata_outstanding_per_id_param );
        max_num_wdata_outstanding_per_id = max_num_wdata_outstanding_per_id_param;
    endfunction

    function void axi_set_check_max_num_waddr_outstanding_per_id_from_CY( bit check_max_num_waddr_outstanding_per_id_param );
        check_max_num_waddr_outstanding_per_id = check_max_num_waddr_outstanding_per_id_param;
    endfunction

    function void axi_set_max_num_waddr_outstanding_per_id_from_CY( int max_num_waddr_outstanding_per_id_param );
        max_num_waddr_outstanding_per_id = max_num_waddr_outstanding_per_id_param;
    endfunction

    function void axi_set_check_total_num_waddr_outstanding_from_CY( bit check_total_num_waddr_outstanding_param );
        check_total_num_waddr_outstanding = check_total_num_waddr_outstanding_param;
    endfunction

    function void axi_set_total_num_waddr_outstanding_from_CY( int total_num_waddr_outstanding_param );
        total_num_waddr_outstanding = total_num_waddr_outstanding_param;
    endfunction

    function void axi_set_status_outstanding_num_for_waddr_from_CY( int status_outstanding_num_for_waddr_param );
        status_outstanding_num_for_waddr = status_outstanding_num_for_waddr_param;
    endfunction

    function void axi_set_start_finding_outstanding_waddr_from_CY( bit start_finding_outstanding_waddr_param );
        start_finding_outstanding_waddr = start_finding_outstanding_waddr_param;
    endfunction

    function void axi_set_status_outstanding_num_for_wdata_from_CY( int status_outstanding_num_for_wdata_param );
        status_outstanding_num_for_wdata = status_outstanding_num_for_wdata_param;
    endfunction

    function void axi_set_start_finding_outstanding_wdata_from_CY( bit start_finding_outstanding_wdata_param );
        start_finding_outstanding_wdata = start_finding_outstanding_wdata_param;
    endfunction

    function void axi_set_find_waddr_outstanding_for_wid_from_CY_index1( int _this_dot_1, bit  find_waddr_outstanding_for_wid_param );
        find_waddr_outstanding_for_wid[_this_dot_1] = find_waddr_outstanding_for_wid_param;
    endfunction

    function void axi_set_find_wdata_outstanding_for_wid_from_CY_index1( int _this_dot_1, bit  find_wdata_outstanding_for_wid_param );
        find_wdata_outstanding_for_wid[_this_dot_1] = find_wdata_outstanding_for_wid_param;
    endfunction

    function void axi_set_change_in_wdata_outstanding_per_id_from_CY( bit change_in_wdata_outstanding_per_id_param );
        change_in_wdata_outstanding_per_id = change_in_wdata_outstanding_per_id_param;
    endfunction

    function void axi_set_start_finding_change_in_wdata_from_CY( bit start_finding_change_in_wdata_param );
        start_finding_change_in_wdata = start_finding_change_in_wdata_param;
    endfunction

    function void axi_set_find_change_in_wdata_outstanding_for_wid_from_CY_index1( int _this_dot_1, bit  find_change_in_wdata_outstanding_for_wid_param );
        find_change_in_wdata_outstanding_for_wid[_this_dot_1] = find_change_in_wdata_outstanding_for_wid_param;
    endfunction

    function void axi_set_config_max_outstanding_wr_from_CY( int config_max_outstanding_wr_param );
        config_max_outstanding_wr = config_max_outstanding_wr_param;
    endfunction

    function void axi_set_config_max_outstanding_rd_from_CY( int config_max_outstanding_rd_param );
        config_max_outstanding_rd = config_max_outstanding_rd_param;
    endfunction

    function void axi_set_config_error_on_deleted_valid_cycles_from_CY( bit config_error_on_deleted_valid_cycles_param );
        config_error_on_deleted_valid_cycles = config_error_on_deleted_valid_cycles_param;
    endfunction

    function void axi_set_config_stats_enable_from_CY( bit config_stats_enable_param );
        config_stats_enable = config_stats_enable_param;
    endfunction

    function void axi_set_config_stats_enable_AXI_read_occupancy_from_CY( bit config_stats_enable_AXI_read_occupancy_param );
        config_stats_enable_AXI_read_occupancy = config_stats_enable_AXI_read_occupancy_param;
    endfunction

    function void axi_set_config_stats_enable_AXI_write_occupancy_from_CY( bit config_stats_enable_AXI_write_occupancy_param );
        config_stats_enable_AXI_write_occupancy = config_stats_enable_AXI_write_occupancy_param;
    endfunction

    function void axi_set_config_stats_enable_read_data_occupancy_from_CY( bit config_stats_enable_read_data_occupancy_param );
        config_stats_enable_read_data_occupancy = config_stats_enable_read_data_occupancy_param;
    endfunction

    function void axi_set_config_stats_enable_write_data_occupancy_from_CY( bit config_stats_enable_write_data_occupancy_param );
        config_stats_enable_write_data_occupancy = config_stats_enable_write_data_occupancy_param;
    endfunction

    function void axi_set_config_stats_enable_read_latency_from_CY( bit config_stats_enable_read_latency_param );
        config_stats_enable_read_latency = config_stats_enable_read_latency_param;
    endfunction

    function void axi_set_config_stats_enable_write_latency_from_CY( bit config_stats_enable_write_latency_param );
        config_stats_enable_write_latency = config_stats_enable_write_latency_param;
    endfunction

    function void axi_set_config_stats_enable_read_address_waits_from_CY( bit config_stats_enable_read_address_waits_param );
        config_stats_enable_read_address_waits = config_stats_enable_read_address_waits_param;
    endfunction

    function void axi_set_config_stats_enable_read_data_waits_from_CY( bit config_stats_enable_read_data_waits_param );
        config_stats_enable_read_data_waits = config_stats_enable_read_data_waits_param;
    endfunction

    function void axi_set_config_stats_enable_write_address_waits_from_CY( bit config_stats_enable_write_address_waits_param );
        config_stats_enable_write_address_waits = config_stats_enable_write_address_waits_param;
    endfunction

    function void axi_set_config_stats_enable_write_data_waits_from_CY( bit config_stats_enable_write_data_waits_param );
        config_stats_enable_write_data_waits = config_stats_enable_write_data_waits_param;
    endfunction

    function void axi_set_config_stats_enable_write_response_waits_from_CY( bit config_stats_enable_write_response_waits_param );
        config_stats_enable_write_response_waits = config_stats_enable_write_response_waits_param;
    endfunction

    function void axi_set_config_stats_enable_read_bandwidth_from_CY( bit config_stats_enable_read_bandwidth_param );
        config_stats_enable_read_bandwidth = config_stats_enable_read_bandwidth_param;
    endfunction

    function void axi_set_config_stats_enable_write_bandwidth_from_CY( bit config_stats_enable_write_bandwidth_param );
        config_stats_enable_write_bandwidth = config_stats_enable_write_bandwidth_param;
    endfunction

    function void axi_set_config_stats_AXI_read_occupancy_step_from_CY( int config_stats_AXI_read_occupancy_step_param );
        config_stats_AXI_read_occupancy_step = config_stats_AXI_read_occupancy_step_param;
    endfunction

    function void axi_set_config_stats_AXI_read_occupancy_multiple_from_CY( int config_stats_AXI_read_occupancy_multiple_param );
        config_stats_AXI_read_occupancy_multiple = config_stats_AXI_read_occupancy_multiple_param;
    endfunction

    function void axi_set_stats_AXI_read_active_from_CY( bit stats_AXI_read_active_param );
        stats_AXI_read_active = stats_AXI_read_active_param;
    endfunction

    function void axi_set_stats_AXI_read_occupancy_sw_from_CY( int stats_AXI_read_occupancy_sw_param );
        stats_AXI_read_occupancy_sw = stats_AXI_read_occupancy_sw_param;
    endfunction

    function void axi_set_stats_AXI_read_occupancy_sw_updated_from_CY( int stats_AXI_read_occupancy_sw_updated_param );
        stats_AXI_read_occupancy_sw_updated = stats_AXI_read_occupancy_sw_updated_param;
    endfunction

    function void axi_set_stats_AXI_read_idle_sw_from_CY( int stats_AXI_read_idle_sw_param );
        stats_AXI_read_idle_sw = stats_AXI_read_idle_sw_param;
    endfunction

    function void axi_set_stats_AXI_read_occupancy_min_from_CY( int stats_AXI_read_occupancy_min_param );
        stats_AXI_read_occupancy_min = stats_AXI_read_occupancy_min_param;
    endfunction

    function void axi_set_stats_AXI_read_idle_min_from_CY( int stats_AXI_read_idle_min_param );
        stats_AXI_read_idle_min = stats_AXI_read_idle_min_param;
    endfunction

    function void axi_set_stats_AXI_read_occupancy_max_from_CY( int stats_AXI_read_occupancy_max_param );
        stats_AXI_read_occupancy_max = stats_AXI_read_occupancy_max_param;
    endfunction

    function void axi_set_stats_AXI_read_idle_max_from_CY( int stats_AXI_read_idle_max_param );
        stats_AXI_read_idle_max = stats_AXI_read_idle_max_param;
    endfunction

    function void axi_set_stats_AXI_read_occupancy_mean_from_CY( int stats_AXI_read_occupancy_mean_param );
        stats_AXI_read_occupancy_mean = stats_AXI_read_occupancy_mean_param;
    endfunction

    function void axi_set_stats_AXI_read_idle_mean_from_CY( int stats_AXI_read_idle_mean_param );
        stats_AXI_read_idle_mean = stats_AXI_read_idle_mean_param;
    endfunction

    function void axi_set_config_stats_AXI_write_occupancy_step_from_CY( int config_stats_AXI_write_occupancy_step_param );
        config_stats_AXI_write_occupancy_step = config_stats_AXI_write_occupancy_step_param;
    endfunction

    function void axi_set_config_stats_AXI_write_occupancy_multiple_from_CY( int config_stats_AXI_write_occupancy_multiple_param );
        config_stats_AXI_write_occupancy_multiple = config_stats_AXI_write_occupancy_multiple_param;
    endfunction

    function void axi_set_stats_AXI_write_active_from_CY( bit stats_AXI_write_active_param );
        stats_AXI_write_active = stats_AXI_write_active_param;
    endfunction

    function void axi_set_stats_AXI_write_occupancy_sw_from_CY( int stats_AXI_write_occupancy_sw_param );
        stats_AXI_write_occupancy_sw = stats_AXI_write_occupancy_sw_param;
    endfunction

    function void axi_set_stats_AXI_write_occupancy_sw_updated_from_CY( int stats_AXI_write_occupancy_sw_updated_param );
        stats_AXI_write_occupancy_sw_updated = stats_AXI_write_occupancy_sw_updated_param;
    endfunction

    function void axi_set_stats_AXI_write_idle_sw_from_CY( int stats_AXI_write_idle_sw_param );
        stats_AXI_write_idle_sw = stats_AXI_write_idle_sw_param;
    endfunction

    function void axi_set_stats_AXI_write_occupancy_min_from_CY( int stats_AXI_write_occupancy_min_param );
        stats_AXI_write_occupancy_min = stats_AXI_write_occupancy_min_param;
    endfunction

    function void axi_set_stats_AXI_write_idle_min_from_CY( int stats_AXI_write_idle_min_param );
        stats_AXI_write_idle_min = stats_AXI_write_idle_min_param;
    endfunction

    function void axi_set_stats_AXI_write_occupancy_max_from_CY( int stats_AXI_write_occupancy_max_param );
        stats_AXI_write_occupancy_max = stats_AXI_write_occupancy_max_param;
    endfunction

    function void axi_set_stats_AXI_write_idle_max_from_CY( int stats_AXI_write_idle_max_param );
        stats_AXI_write_idle_max = stats_AXI_write_idle_max_param;
    endfunction

    function void axi_set_stats_AXI_write_occupancy_mean_from_CY( int stats_AXI_write_occupancy_mean_param );
        stats_AXI_write_occupancy_mean = stats_AXI_write_occupancy_mean_param;
    endfunction

    function void axi_set_stats_AXI_write_idle_mean_from_CY( int stats_AXI_write_idle_mean_param );
        stats_AXI_write_idle_mean = stats_AXI_write_idle_mean_param;
    endfunction

    function void axi_set_config_stats_read_data_occupancy_step_from_CY( int config_stats_read_data_occupancy_step_param );
        config_stats_read_data_occupancy_step = config_stats_read_data_occupancy_step_param;
    endfunction

    function void axi_set_config_stats_read_data_occupancy_multiple_from_CY( int config_stats_read_data_occupancy_multiple_param );
        config_stats_read_data_occupancy_multiple = config_stats_read_data_occupancy_multiple_param;
    endfunction

    function void axi_set_stats_read_data_occupancy_sw_from_CY( int stats_read_data_occupancy_sw_param );
        stats_read_data_occupancy_sw = stats_read_data_occupancy_sw_param;
    endfunction

    function void axi_set_stats_read_data_occupancy_sw_updated_from_CY( int stats_read_data_occupancy_sw_updated_param );
        stats_read_data_occupancy_sw_updated = stats_read_data_occupancy_sw_updated_param;
    endfunction

    function void axi_set_stats_read_data_idle_sw_from_CY( int stats_read_data_idle_sw_param );
        stats_read_data_idle_sw = stats_read_data_idle_sw_param;
    endfunction

    function void axi_set_stats_read_data_occupancy_min_from_CY( int stats_read_data_occupancy_min_param );
        stats_read_data_occupancy_min = stats_read_data_occupancy_min_param;
    endfunction

    function void axi_set_stats_read_data_idle_min_from_CY( int stats_read_data_idle_min_param );
        stats_read_data_idle_min = stats_read_data_idle_min_param;
    endfunction

    function void axi_set_stats_read_data_occupancy_max_from_CY( int stats_read_data_occupancy_max_param );
        stats_read_data_occupancy_max = stats_read_data_occupancy_max_param;
    endfunction

    function void axi_set_stats_read_data_idle_max_from_CY( int stats_read_data_idle_max_param );
        stats_read_data_idle_max = stats_read_data_idle_max_param;
    endfunction

    function void axi_set_stats_read_data_occupancy_mean_from_CY( int stats_read_data_occupancy_mean_param );
        stats_read_data_occupancy_mean = stats_read_data_occupancy_mean_param;
    endfunction

    function void axi_set_stats_read_data_idle_mean_from_CY( int stats_read_data_idle_mean_param );
        stats_read_data_idle_mean = stats_read_data_idle_mean_param;
    endfunction

    function void axi_set_config_stats_write_data_occupancy_step_from_CY( int config_stats_write_data_occupancy_step_param );
        config_stats_write_data_occupancy_step = config_stats_write_data_occupancy_step_param;
    endfunction

    function void axi_set_config_stats_write_data_occupancy_multiple_from_CY( int config_stats_write_data_occupancy_multiple_param );
        config_stats_write_data_occupancy_multiple = config_stats_write_data_occupancy_multiple_param;
    endfunction

    function void axi_set_stats_write_data_occupancy_sw_from_CY( int stats_write_data_occupancy_sw_param );
        stats_write_data_occupancy_sw = stats_write_data_occupancy_sw_param;
    endfunction

    function void axi_set_stats_write_data_occupancy_sw_updated_from_CY( int stats_write_data_occupancy_sw_updated_param );
        stats_write_data_occupancy_sw_updated = stats_write_data_occupancy_sw_updated_param;
    endfunction

    function void axi_set_stats_write_data_idle_sw_from_CY( int stats_write_data_idle_sw_param );
        stats_write_data_idle_sw = stats_write_data_idle_sw_param;
    endfunction

    function void axi_set_stats_write_data_occupancy_min_from_CY( int stats_write_data_occupancy_min_param );
        stats_write_data_occupancy_min = stats_write_data_occupancy_min_param;
    endfunction

    function void axi_set_stats_write_data_idle_min_from_CY( int stats_write_data_idle_min_param );
        stats_write_data_idle_min = stats_write_data_idle_min_param;
    endfunction

    function void axi_set_stats_write_data_occupancy_max_from_CY( int stats_write_data_occupancy_max_param );
        stats_write_data_occupancy_max = stats_write_data_occupancy_max_param;
    endfunction

    function void axi_set_stats_write_data_idle_max_from_CY( int stats_write_data_idle_max_param );
        stats_write_data_idle_max = stats_write_data_idle_max_param;
    endfunction

    function void axi_set_stats_write_data_occupancy_mean_from_CY( int stats_write_data_occupancy_mean_param );
        stats_write_data_occupancy_mean = stats_write_data_occupancy_mean_param;
    endfunction

    function void axi_set_stats_write_data_idle_mean_from_CY( int stats_write_data_idle_mean_param );
        stats_write_data_idle_mean = stats_write_data_idle_mean_param;
    endfunction

    function void axi_set_config_stats_read_bandwidth_step_from_CY( int config_stats_read_bandwidth_step_param );
        config_stats_read_bandwidth_step = config_stats_read_bandwidth_step_param;
    endfunction

    function void axi_set_config_stats_read_bandwidth_multiple_from_CY( int config_stats_read_bandwidth_multiple_param );
        config_stats_read_bandwidth_multiple = config_stats_read_bandwidth_multiple_param;
    endfunction

    function void axi_set_stats_read_bandwidth_sw_from_CY( int stats_read_bandwidth_sw_param );
        stats_read_bandwidth_sw = stats_read_bandwidth_sw_param;
    endfunction

    function void axi_set_stats_read_bandwidth_sw_updated_from_CY( int stats_read_bandwidth_sw_updated_param );
        stats_read_bandwidth_sw_updated = stats_read_bandwidth_sw_updated_param;
    endfunction

    function void axi_set_stats_read_bandwidth_min_from_CY( int stats_read_bandwidth_min_param );
        stats_read_bandwidth_min = stats_read_bandwidth_min_param;
    endfunction

    function void axi_set_stats_read_bandwidth_max_from_CY( int stats_read_bandwidth_max_param );
        stats_read_bandwidth_max = stats_read_bandwidth_max_param;
    endfunction

    function void axi_set_stats_read_bandwidth_mean_from_CY( int stats_read_bandwidth_mean_param );
        stats_read_bandwidth_mean = stats_read_bandwidth_mean_param;
    endfunction

    function void axi_set_config_stats_write_bandwidth_step_from_CY( int config_stats_write_bandwidth_step_param );
        config_stats_write_bandwidth_step = config_stats_write_bandwidth_step_param;
    endfunction

    function void axi_set_config_stats_write_bandwidth_multiple_from_CY( int config_stats_write_bandwidth_multiple_param );
        config_stats_write_bandwidth_multiple = config_stats_write_bandwidth_multiple_param;
    endfunction

    function void axi_set_stats_write_bandwidth_sw_from_CY( int stats_write_bandwidth_sw_param );
        stats_write_bandwidth_sw = stats_write_bandwidth_sw_param;
    endfunction

    function void axi_set_stats_write_bandwidth_sw_updated_from_CY( int stats_write_bandwidth_sw_updated_param );
        stats_write_bandwidth_sw_updated = stats_write_bandwidth_sw_updated_param;
    endfunction

    function void axi_set_stats_write_bandwidth_min_from_CY( int stats_write_bandwidth_min_param );
        stats_write_bandwidth_min = stats_write_bandwidth_min_param;
    endfunction

    function void axi_set_stats_write_bandwidth_max_from_CY( int stats_write_bandwidth_max_param );
        stats_write_bandwidth_max = stats_write_bandwidth_max_param;
    endfunction

    function void axi_set_stats_write_bandwidth_mean_from_CY( int stats_write_bandwidth_mean_param );
        stats_write_bandwidth_mean = stats_write_bandwidth_mean_param;
    endfunction

    function void axi_set_config_stats_read_latency_step_from_CY( int config_stats_read_latency_step_param );
        config_stats_read_latency_step = config_stats_read_latency_step_param;
    endfunction

    function void axi_set_config_stats_read_latency_multiple_from_CY( int config_stats_read_latency_multiple_param );
        config_stats_read_latency_multiple = config_stats_read_latency_multiple_param;
    endfunction

    function void axi_set_stats_read_latency_sw_updated_from_CY( int stats_read_latency_sw_updated_param );
        stats_read_latency_sw_updated = stats_read_latency_sw_updated_param;
    endfunction

    function void axi_set_stats_read_address_data_latency_inst_from_CY( int stats_read_address_data_latency_inst_param );
        stats_read_address_data_latency_inst = stats_read_address_data_latency_inst_param;
    endfunction

    function void axi_set_stats_read_address_data_latency_sw_from_CY( int stats_read_address_data_latency_sw_param );
        stats_read_address_data_latency_sw = stats_read_address_data_latency_sw_param;
    endfunction

    function void axi_set_stats_read_address_data_latency_min_from_CY( int stats_read_address_data_latency_min_param );
        stats_read_address_data_latency_min = stats_read_address_data_latency_min_param;
    endfunction

    function void axi_set_stats_read_address_data_latency_max_from_CY( int stats_read_address_data_latency_max_param );
        stats_read_address_data_latency_max = stats_read_address_data_latency_max_param;
    endfunction

    function void axi_set_stats_read_address_data_latency_mean_from_CY( int stats_read_address_data_latency_mean_param );
        stats_read_address_data_latency_mean = stats_read_address_data_latency_mean_param;
    endfunction

    function void axi_set_stats_read_address_address_latency_inst_from_CY( int stats_read_address_address_latency_inst_param );
        stats_read_address_address_latency_inst = stats_read_address_address_latency_inst_param;
    endfunction

    function void axi_set_stats_read_address_address_latency_sw_from_CY( int stats_read_address_address_latency_sw_param );
        stats_read_address_address_latency_sw = stats_read_address_address_latency_sw_param;
    endfunction

    function void axi_set_stats_read_address_address_latency_min_from_CY( int stats_read_address_address_latency_min_param );
        stats_read_address_address_latency_min = stats_read_address_address_latency_min_param;
    endfunction

    function void axi_set_stats_read_address_address_latency_max_from_CY( int stats_read_address_address_latency_max_param );
        stats_read_address_address_latency_max = stats_read_address_address_latency_max_param;
    endfunction

    function void axi_set_stats_read_address_address_latency_mean_from_CY( int stats_read_address_address_latency_mean_param );
        stats_read_address_address_latency_mean = stats_read_address_address_latency_mean_param;
    endfunction

    function void axi_set_config_stats_write_latency_step_from_CY( int config_stats_write_latency_step_param );
        config_stats_write_latency_step = config_stats_write_latency_step_param;
    endfunction

    function void axi_set_config_stats_write_latency_multiple_from_CY( int config_stats_write_latency_multiple_param );
        config_stats_write_latency_multiple = config_stats_write_latency_multiple_param;
    endfunction

    function void axi_set_stats_write_latency_sw_updated_from_CY( int stats_write_latency_sw_updated_param );
        stats_write_latency_sw_updated = stats_write_latency_sw_updated_param;
    endfunction

    function void axi_set_stats_write_address_data_latency_inst_from_CY( int stats_write_address_data_latency_inst_param );
        stats_write_address_data_latency_inst = stats_write_address_data_latency_inst_param;
    endfunction

    function void axi_set_stats_write_address_data_latency_sw_from_CY( int stats_write_address_data_latency_sw_param );
        stats_write_address_data_latency_sw = stats_write_address_data_latency_sw_param;
    endfunction

    function void axi_set_stats_write_address_data_latency_min_from_CY( int stats_write_address_data_latency_min_param );
        stats_write_address_data_latency_min = stats_write_address_data_latency_min_param;
    endfunction

    function void axi_set_stats_write_address_data_latency_max_from_CY( int stats_write_address_data_latency_max_param );
        stats_write_address_data_latency_max = stats_write_address_data_latency_max_param;
    endfunction

    function void axi_set_stats_write_address_data_latency_mean_from_CY( int stats_write_address_data_latency_mean_param );
        stats_write_address_data_latency_mean = stats_write_address_data_latency_mean_param;
    endfunction

    function void axi_set_stats_write_data_response_latency_inst_from_CY( int stats_write_data_response_latency_inst_param );
        stats_write_data_response_latency_inst = stats_write_data_response_latency_inst_param;
    endfunction

    function void axi_set_stats_write_data_response_latency_sw_from_CY( int stats_write_data_response_latency_sw_param );
        stats_write_data_response_latency_sw = stats_write_data_response_latency_sw_param;
    endfunction

    function void axi_set_stats_write_data_response_latency_min_from_CY( int stats_write_data_response_latency_min_param );
        stats_write_data_response_latency_min = stats_write_data_response_latency_min_param;
    endfunction

    function void axi_set_stats_write_data_response_latency_max_from_CY( int stats_write_data_response_latency_max_param );
        stats_write_data_response_latency_max = stats_write_data_response_latency_max_param;
    endfunction

    function void axi_set_stats_write_data_response_latency_mean_from_CY( int stats_write_data_response_latency_mean_param );
        stats_write_data_response_latency_mean = stats_write_data_response_latency_mean_param;
    endfunction

    function void axi_set_stats_write_address_address_latency_inst_from_CY( int stats_write_address_address_latency_inst_param );
        stats_write_address_address_latency_inst = stats_write_address_address_latency_inst_param;
    endfunction

    function void axi_set_stats_write_address_address_latency_sw_from_CY( int stats_write_address_address_latency_sw_param );
        stats_write_address_address_latency_sw = stats_write_address_address_latency_sw_param;
    endfunction

    function void axi_set_stats_write_address_address_latency_min_from_CY( int stats_write_address_address_latency_min_param );
        stats_write_address_address_latency_min = stats_write_address_address_latency_min_param;
    endfunction

    function void axi_set_stats_write_address_address_latency_max_from_CY( int stats_write_address_address_latency_max_param );
        stats_write_address_address_latency_max = stats_write_address_address_latency_max_param;
    endfunction

    function void axi_set_stats_write_address_address_latency_mean_from_CY( int stats_write_address_address_latency_mean_param );
        stats_write_address_address_latency_mean = stats_write_address_address_latency_mean_param;
    endfunction

    function void axi_set_config_stats_read_address_waits_step_from_CY( int config_stats_read_address_waits_step_param );
        config_stats_read_address_waits_step = config_stats_read_address_waits_step_param;
    endfunction

    function void axi_set_config_stats_read_address_waits_multiple_from_CY( int config_stats_read_address_waits_multiple_param );
        config_stats_read_address_waits_multiple = config_stats_read_address_waits_multiple_param;
    endfunction

    function void axi_set_stats_read_address_waits_inst_from_CY( int stats_read_address_waits_inst_param );
        stats_read_address_waits_inst = stats_read_address_waits_inst_param;
    endfunction

    function void axi_set_stats_read_address_waits_sw_from_CY( int stats_read_address_waits_sw_param );
        stats_read_address_waits_sw = stats_read_address_waits_sw_param;
    endfunction

    function void axi_set_stats_read_address_waits_sw_updated_from_CY( int stats_read_address_waits_sw_updated_param );
        stats_read_address_waits_sw_updated = stats_read_address_waits_sw_updated_param;
    endfunction

    function void axi_set_stats_read_address_waits_min_from_CY( int stats_read_address_waits_min_param );
        stats_read_address_waits_min = stats_read_address_waits_min_param;
    endfunction

    function void axi_set_stats_read_address_waits_max_from_CY( int stats_read_address_waits_max_param );
        stats_read_address_waits_max = stats_read_address_waits_max_param;
    endfunction

    function void axi_set_stats_read_address_waits_mean_from_CY( int stats_read_address_waits_mean_param );
        stats_read_address_waits_mean = stats_read_address_waits_mean_param;
    endfunction

    function void axi_set_config_stats_read_data_waits_step_from_CY( int config_stats_read_data_waits_step_param );
        config_stats_read_data_waits_step = config_stats_read_data_waits_step_param;
    endfunction

    function void axi_set_config_stats_read_data_waits_multiple_from_CY( int config_stats_read_data_waits_multiple_param );
        config_stats_read_data_waits_multiple = config_stats_read_data_waits_multiple_param;
    endfunction

    function void axi_set_stats_read_data_waits_inst_from_CY( int stats_read_data_waits_inst_param );
        stats_read_data_waits_inst = stats_read_data_waits_inst_param;
    endfunction

    function void axi_set_stats_read_data_waits_sw_from_CY( int stats_read_data_waits_sw_param );
        stats_read_data_waits_sw = stats_read_data_waits_sw_param;
    endfunction

    function void axi_set_stats_read_data_waits_sw_updated_from_CY( int stats_read_data_waits_sw_updated_param );
        stats_read_data_waits_sw_updated = stats_read_data_waits_sw_updated_param;
    endfunction

    function void axi_set_stats_read_data_waits_min_from_CY( int stats_read_data_waits_min_param );
        stats_read_data_waits_min = stats_read_data_waits_min_param;
    endfunction

    function void axi_set_stats_read_data_waits_max_from_CY( int stats_read_data_waits_max_param );
        stats_read_data_waits_max = stats_read_data_waits_max_param;
    endfunction

    function void axi_set_stats_read_data_waits_mean_from_CY( int stats_read_data_waits_mean_param );
        stats_read_data_waits_mean = stats_read_data_waits_mean_param;
    endfunction

    function void axi_set_config_stats_write_address_waits_step_from_CY( int config_stats_write_address_waits_step_param );
        config_stats_write_address_waits_step = config_stats_write_address_waits_step_param;
    endfunction

    function void axi_set_config_stats_write_address_waits_multiple_from_CY( int config_stats_write_address_waits_multiple_param );
        config_stats_write_address_waits_multiple = config_stats_write_address_waits_multiple_param;
    endfunction

    function void axi_set_stats_write_address_waits_inst_from_CY( int stats_write_address_waits_inst_param );
        stats_write_address_waits_inst = stats_write_address_waits_inst_param;
    endfunction

    function void axi_set_stats_write_address_waits_sw_from_CY( int stats_write_address_waits_sw_param );
        stats_write_address_waits_sw = stats_write_address_waits_sw_param;
    endfunction

    function void axi_set_stats_write_address_waits_sw_updated_from_CY( int stats_write_address_waits_sw_updated_param );
        stats_write_address_waits_sw_updated = stats_write_address_waits_sw_updated_param;
    endfunction

    function void axi_set_stats_write_address_waits_min_from_CY( int stats_write_address_waits_min_param );
        stats_write_address_waits_min = stats_write_address_waits_min_param;
    endfunction

    function void axi_set_stats_write_address_waits_max_from_CY( int stats_write_address_waits_max_param );
        stats_write_address_waits_max = stats_write_address_waits_max_param;
    endfunction

    function void axi_set_stats_write_address_waits_mean_from_CY( int stats_write_address_waits_mean_param );
        stats_write_address_waits_mean = stats_write_address_waits_mean_param;
    endfunction

    function void axi_set_config_stats_write_data_waits_step_from_CY( int config_stats_write_data_waits_step_param );
        config_stats_write_data_waits_step = config_stats_write_data_waits_step_param;
    endfunction

    function void axi_set_config_stats_write_data_waits_multiple_from_CY( int config_stats_write_data_waits_multiple_param );
        config_stats_write_data_waits_multiple = config_stats_write_data_waits_multiple_param;
    endfunction

    function void axi_set_stats_write_data_waits_inst_from_CY( int stats_write_data_waits_inst_param );
        stats_write_data_waits_inst = stats_write_data_waits_inst_param;
    endfunction

    function void axi_set_stats_write_data_waits_sw_from_CY( int stats_write_data_waits_sw_param );
        stats_write_data_waits_sw = stats_write_data_waits_sw_param;
    endfunction

    function void axi_set_stats_write_data_waits_sw_updated_from_CY( int stats_write_data_waits_sw_updated_param );
        stats_write_data_waits_sw_updated = stats_write_data_waits_sw_updated_param;
    endfunction

    function void axi_set_stats_write_data_waits_min_from_CY( int stats_write_data_waits_min_param );
        stats_write_data_waits_min = stats_write_data_waits_min_param;
    endfunction

    function void axi_set_stats_write_data_waits_max_from_CY( int stats_write_data_waits_max_param );
        stats_write_data_waits_max = stats_write_data_waits_max_param;
    endfunction

    function void axi_set_stats_write_data_waits_mean_from_CY( int stats_write_data_waits_mean_param );
        stats_write_data_waits_mean = stats_write_data_waits_mean_param;
    endfunction

    function void axi_set_config_stats_write_response_waits_step_from_CY( int config_stats_write_response_waits_step_param );
        config_stats_write_response_waits_step = config_stats_write_response_waits_step_param;
    endfunction

    function void axi_set_config_stats_write_response_waits_multiple_from_CY( int config_stats_write_response_waits_multiple_param );
        config_stats_write_response_waits_multiple = config_stats_write_response_waits_multiple_param;
    endfunction

    function void axi_set_stats_write_response_waits_inst_from_CY( int stats_write_response_waits_inst_param );
        stats_write_response_waits_inst = stats_write_response_waits_inst_param;
    endfunction

    function void axi_set_stats_write_response_waits_sw_from_CY( int stats_write_response_waits_sw_param );
        stats_write_response_waits_sw = stats_write_response_waits_sw_param;
    endfunction

    function void axi_set_stats_write_response_waits_sw_updated_from_CY( int stats_write_response_waits_sw_updated_param );
        stats_write_response_waits_sw_updated = stats_write_response_waits_sw_updated_param;
    endfunction

    function void axi_set_stats_write_response_waits_min_from_CY( int stats_write_response_waits_min_param );
        stats_write_response_waits_min = stats_write_response_waits_min_param;
    endfunction

    function void axi_set_stats_write_response_waits_max_from_CY( int stats_write_response_waits_max_param );
        stats_write_response_waits_max = stats_write_response_waits_max_param;
    endfunction

    function void axi_set_stats_write_response_waits_mean_from_CY( int stats_write_response_waits_mean_param );
        stats_write_response_waits_mean = stats_write_response_waits_mean_param;
    endfunction

    function void axi_set_stats_rw_transaction_last_duration_from_CY( int stats_rw_transaction_last_duration_param );
        stats_rw_transaction_last_duration = stats_rw_transaction_last_duration_param;
    endfunction

    function void axi_set_stats_AXI_read_last_duration_from_CY( int stats_AXI_read_last_duration_param );
        stats_AXI_read_last_duration = stats_AXI_read_last_duration_param;
    endfunction

    function void axi_set_stats_AXI_write_last_duration_from_CY( int stats_AXI_write_last_duration_param );
        stats_AXI_write_last_duration = stats_AXI_write_last_duration_param;
    endfunction

    function void axi_set_stats_read_addr_channel_phase_last_duration_from_CY( int stats_read_addr_channel_phase_last_duration_param );
        stats_read_addr_channel_phase_last_duration = stats_read_addr_channel_phase_last_duration_param;
    endfunction

    function void axi_set_stats_read_data_burst_last_duration_from_CY( int stats_read_data_burst_last_duration_param );
        stats_read_data_burst_last_duration = stats_read_data_burst_last_duration_param;
    endfunction

    function void axi_set_stats_read_channel_phase_last_duration_from_CY( int stats_read_channel_phase_last_duration_param );
        stats_read_channel_phase_last_duration = stats_read_channel_phase_last_duration_param;
    endfunction

    function void axi_set_stats_write_addr_channel_phase_last_duration_from_CY( int stats_write_addr_channel_phase_last_duration_param );
        stats_write_addr_channel_phase_last_duration = stats_write_addr_channel_phase_last_duration_param;
    endfunction

    function void axi_set_stats_write_data_burst_last_duration_from_CY( int stats_write_data_burst_last_duration_param );
        stats_write_data_burst_last_duration = stats_write_data_burst_last_duration_param;
    endfunction

    function void axi_set_stats_write_channel_phase_last_duration_from_CY( int stats_write_channel_phase_last_duration_param );
        stats_write_channel_phase_last_duration = stats_write_channel_phase_last_duration_param;
    endfunction

    function void axi_set_stats_write_resp_channel_phase_last_duration_from_CY( int stats_write_resp_channel_phase_last_duration_param );
        stats_write_resp_channel_phase_last_duration = stats_write_resp_channel_phase_last_duration_param;
    endfunction

    //------------------------------------------------------------------------------
    // TLM Interface Support
    //------------------------------------------------------------------------------

    export "DPI-C" axi_get_temp_static_rw_transaction_addr = function axi_get_temp_static_rw_transaction_addr;
    export "DPI-C" axi_set_temp_static_rw_transaction_addr = function axi_set_temp_static_rw_transaction_addr;
    export "DPI-C" axi_get_temp_static_rw_transaction_id = function axi_get_temp_static_rw_transaction_id;
    export "DPI-C" axi_set_temp_static_rw_transaction_id = function axi_set_temp_static_rw_transaction_id;
    export "DPI-C" axi_get_temp_static_rw_transaction_data_words = function axi_get_temp_static_rw_transaction_data_words;
    export "DPI-C" axi_set_temp_static_rw_transaction_data_words = function axi_set_temp_static_rw_transaction_data_words;
    export "DPI-C" axi_get_temp_static_rw_transaction_write_strobes = function axi_get_temp_static_rw_transaction_write_strobes;
    export "DPI-C" axi_set_temp_static_rw_transaction_write_strobes = function axi_set_temp_static_rw_transaction_write_strobes;
    export "DPI-C" axi_get_temp_static_rw_transaction_resp = function axi_get_temp_static_rw_transaction_resp;
    export "DPI-C" axi_set_temp_static_rw_transaction_resp = function axi_set_temp_static_rw_transaction_resp;
    export "DPI-C" axi_get_temp_static_rw_transaction_data_user = function axi_get_temp_static_rw_transaction_data_user;
    export "DPI-C" axi_set_temp_static_rw_transaction_data_user = function axi_set_temp_static_rw_transaction_data_user;
    export "DPI-C" axi_get_temp_static_rw_transaction_write_data_beats_delay = function axi_get_temp_static_rw_transaction_write_data_beats_delay;
    export "DPI-C" axi_set_temp_static_rw_transaction_write_data_beats_delay = function axi_set_temp_static_rw_transaction_write_data_beats_delay;
    export "DPI-C" axi_get_temp_static_rw_transaction_data_valid_delay = function axi_get_temp_static_rw_transaction_data_valid_delay;
    export "DPI-C" axi_set_temp_static_rw_transaction_data_valid_delay = function axi_set_temp_static_rw_transaction_data_valid_delay;
    export "DPI-C" axi_get_temp_static_rw_transaction_data_ready_delay = function axi_get_temp_static_rw_transaction_data_ready_delay;
    export "DPI-C" axi_set_temp_static_rw_transaction_data_ready_delay = function axi_set_temp_static_rw_transaction_data_ready_delay;
    import "DPI-C" context axi_rw_transaction_ActivatesActivatingActivate_SystemVerilog =
    task axi_rw_transaction_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout int prot,
        inout bit [3:0] burst_length,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout bit [7:0] addr_user,
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout bit [7:0] resp_user,
        inout int read_or_write,
        inout int address_to_data_latency,
        inout int data_to_response_latency,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int address_valid_delay,
        inout int data_valid_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_response_valid_delay,
        inout int address_ready_delay,
        inout int data_ready_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_response_ready_delay,
        inout bit write_data_with_address,
        input int _unit_id
    );
    import "DPI-C" context axi_rw_transaction_ActivatesActivatingActivate_open_SystemVerilog =
    task axi_rw_transaction_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout int prot,
        inout bit [((4) - 1):0] burst_length,
        inout bit [((8) - 1):0] addr_user,
        inout bit [((8) - 1):0] resp_user,
        inout int read_or_write,
        inout int address_to_data_latency,
        inout int data_to_response_latency,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int address_valid_delay,
        inout int write_response_valid_delay,
        inout int address_ready_delay,
        inout int write_response_ready_delay,
        inout bit write_data_with_address,
        input int _unit_id
    );
    import "DPI-C" context axi_rw_transaction_ReceivedReceivingReceive_SystemVerilog =
    task axi_rw_transaction_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_valid_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_ready_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_rw_transaction_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_rw_transaction_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output int prot,
        output bit [((4) - 1):0] burst_length,
        output bit [((8) - 1):0] addr_user,
        output bit [((8) - 1):0] resp_user,
        output int read_or_write,
        output int address_to_data_latency,
        output int data_to_response_latency,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        output int address_valid_delay,
        output int write_response_valid_delay,
        output int address_ready_delay,
        output int write_response_ready_delay,
        output bit write_data_with_address,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_AXI_read_addr = function axi_get_temp_static_AXI_read_addr;
    export "DPI-C" axi_set_temp_static_AXI_read_addr = function axi_set_temp_static_AXI_read_addr;
    export "DPI-C" axi_get_temp_static_AXI_read_id = function axi_get_temp_static_AXI_read_id;
    export "DPI-C" axi_set_temp_static_AXI_read_id = function axi_set_temp_static_AXI_read_id;
    export "DPI-C" axi_get_temp_static_AXI_read_data_words = function axi_get_temp_static_AXI_read_data_words;
    export "DPI-C" axi_set_temp_static_AXI_read_data_words = function axi_set_temp_static_AXI_read_data_words;
    export "DPI-C" axi_get_temp_static_AXI_read_resp = function axi_get_temp_static_AXI_read_resp;
    export "DPI-C" axi_set_temp_static_AXI_read_resp = function axi_set_temp_static_AXI_read_resp;
    export "DPI-C" axi_get_temp_static_AXI_read_data_user = function axi_get_temp_static_AXI_read_data_user;
    export "DPI-C" axi_set_temp_static_AXI_read_data_user = function axi_set_temp_static_AXI_read_data_user;
    export "DPI-C" axi_get_temp_static_AXI_read_data_start_time = function axi_get_temp_static_AXI_read_data_start_time;
    export "DPI-C" axi_set_temp_static_AXI_read_data_start_time = function axi_set_temp_static_AXI_read_data_start_time;
    export "DPI-C" axi_get_temp_static_AXI_read_data_end_time = function axi_get_temp_static_AXI_read_data_end_time;
    export "DPI-C" axi_set_temp_static_AXI_read_data_end_time = function axi_set_temp_static_AXI_read_data_end_time;
    import "DPI-C" context axi_AXI_read_ActivatesActivatingActivate_SystemVerilog =
    task axi_AXI_read_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout int prot,
        inout bit [3:0] burst_length,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout bit [7:0] addr_user,
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int address_to_data_latency,
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_read_ActivatesActivatingActivate_open_SystemVerilog =
    task axi_AXI_read_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout int prot,
        inout bit [((4) - 1):0] burst_length,
        inout bit [((8) - 1):0] addr_user,
        inout int address_to_data_latency,
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_read_ReceivedReceivingReceive_SystemVerilog =
    task axi_AXI_read_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_AXI_read_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_AXI_read_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output int prot,
        output bit [((4) - 1):0] burst_length,
        output bit [((8) - 1):0] addr_user,
        output int address_to_data_latency,
        output longint addr_start_time,
        output longint addr_end_time,
        output int address_valid_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_AXI_write_addr = function axi_get_temp_static_AXI_write_addr;
    export "DPI-C" axi_set_temp_static_AXI_write_addr = function axi_set_temp_static_AXI_write_addr;
    export "DPI-C" axi_get_temp_static_AXI_write_id = function axi_get_temp_static_AXI_write_id;
    export "DPI-C" axi_set_temp_static_AXI_write_id = function axi_set_temp_static_AXI_write_id;
    export "DPI-C" axi_get_temp_static_AXI_write_data_words = function axi_get_temp_static_AXI_write_data_words;
    export "DPI-C" axi_set_temp_static_AXI_write_data_words = function axi_set_temp_static_AXI_write_data_words;
    export "DPI-C" axi_get_temp_static_AXI_write_write_strobes = function axi_get_temp_static_AXI_write_write_strobes;
    export "DPI-C" axi_set_temp_static_AXI_write_write_strobes = function axi_set_temp_static_AXI_write_write_strobes;
    export "DPI-C" axi_get_temp_static_AXI_write_data_user = function axi_get_temp_static_AXI_write_data_user;
    export "DPI-C" axi_set_temp_static_AXI_write_data_user = function axi_set_temp_static_AXI_write_data_user;
    export "DPI-C" axi_get_temp_static_AXI_write_write_data_beats_delay = function axi_get_temp_static_AXI_write_write_data_beats_delay;
    export "DPI-C" axi_set_temp_static_AXI_write_write_data_beats_delay = function axi_set_temp_static_AXI_write_write_data_beats_delay;
    export "DPI-C" axi_get_temp_static_AXI_write_data_start_time = function axi_get_temp_static_AXI_write_data_start_time;
    export "DPI-C" axi_set_temp_static_AXI_write_data_start_time = function axi_set_temp_static_AXI_write_data_start_time;
    export "DPI-C" axi_get_temp_static_AXI_write_data_end_time = function axi_get_temp_static_AXI_write_data_end_time;
    export "DPI-C" axi_set_temp_static_AXI_write_data_end_time = function axi_set_temp_static_AXI_write_data_end_time;
    import "DPI-C" context axi_AXI_write_ActivatesActivatingActivate_SystemVerilog =
    task axi_AXI_write_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout int prot,
        inout bit [3:0] burst_length,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp,
        inout bit [7:0] addr_user,
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout bit [7:0] resp_user,
        inout int address_to_data_latency,
        inout int data_to_response_latency,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout longint wr_resp_start_time,
        inout longint wr_resp_end_time,
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_write_ActivatesActivatingActivate_open_SystemVerilog =
    task axi_AXI_write_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout int prot,
        inout bit [((4) - 1):0] burst_length,
        inout int resp,
        inout bit [((8) - 1):0] addr_user,
        inout bit [((8) - 1):0] resp_user,
        inout int address_to_data_latency,
        inout int data_to_response_latency,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout longint wr_resp_start_time,
        inout longint wr_resp_end_time,
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_AXI_write_ReceivedReceivingReceive_SystemVerilog =
    task axi_AXI_write_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_AXI_write_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_AXI_write_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output int prot,
        output bit [((4) - 1):0] burst_length,
        output int resp,
        output bit [((8) - 1):0] addr_user,
        output bit [((8) - 1):0] resp_user,
        output int address_to_data_latency,
        output int data_to_response_latency,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        output longint addr_start_time,
        output longint addr_end_time,
        output longint wr_resp_start_time,
        output longint wr_resp_end_time,
        output int address_valid_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_data_resp_data_words = function axi_get_temp_static_data_resp_data_words;
    export "DPI-C" axi_set_temp_static_data_resp_data_words = function axi_set_temp_static_data_resp_data_words;
    export "DPI-C" axi_get_temp_static_data_resp_write_strobes = function axi_get_temp_static_data_resp_write_strobes;
    export "DPI-C" axi_set_temp_static_data_resp_write_strobes = function axi_set_temp_static_data_resp_write_strobes;
    export "DPI-C" axi_get_temp_static_data_resp_id = function axi_get_temp_static_data_resp_id;
    export "DPI-C" axi_set_temp_static_data_resp_id = function axi_set_temp_static_data_resp_id;
    export "DPI-C" axi_get_temp_static_data_resp_data_user = function axi_get_temp_static_data_resp_data_user;
    export "DPI-C" axi_set_temp_static_data_resp_data_user = function axi_set_temp_static_data_resp_data_user;
    export "DPI-C" axi_get_temp_static_data_resp_write_data_beats_delay = function axi_get_temp_static_data_resp_write_data_beats_delay;
    export "DPI-C" axi_set_temp_static_data_resp_write_data_beats_delay = function axi_set_temp_static_data_resp_write_data_beats_delay;
    export "DPI-C" axi_get_temp_static_data_resp_data_beat_start_time = function axi_get_temp_static_data_resp_data_beat_start_time;
    export "DPI-C" axi_set_temp_static_data_resp_data_beat_start_time = function axi_set_temp_static_data_resp_data_beat_start_time;
    export "DPI-C" axi_get_temp_static_data_resp_data_beat_end_time = function axi_get_temp_static_data_resp_data_beat_end_time;
    export "DPI-C" axi_set_temp_static_data_resp_data_beat_end_time = function axi_set_temp_static_data_resp_data_beat_end_time;
    import "DPI-C" context axi_data_resp_ActivatesActivatingActivate_SystemVerilog =
    task axi_data_resp_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int burst_length,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp,
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout bit [7:0] resp_user,
        inout longint data_start,
        inout longint data_end,
        inout longint response_start,
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_beat_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_beat_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout longint response_end_time,
        input int _unit_id
    );
    import "DPI-C" context axi_data_resp_ActivatesActivatingActivate_open_SystemVerilog =
    task axi_data_resp_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int burst_length,
        inout int resp,
        inout bit [((8) - 1):0] resp_user,
        inout longint data_start,
        inout longint data_end,
        inout longint response_start,
        inout longint response_end_time,
        input int _unit_id
    );
    import "DPI-C" context axi_data_resp_ReceivedReceivingReceive_SystemVerilog =
    task axi_data_resp_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_beat_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_beat_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_data_resp_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_data_resp_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int burst_length,
        output int resp,
        output bit [((8) - 1):0] resp_user,
        output longint data_start,
        output longint data_end,
        output longint response_start,
        output longint response_end_time,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_read_data_burst_data_words = function axi_get_temp_static_read_data_burst_data_words;
    export "DPI-C" axi_set_temp_static_read_data_burst_data_words = function axi_set_temp_static_read_data_burst_data_words;
    export "DPI-C" axi_get_temp_static_read_data_burst_resp = function axi_get_temp_static_read_data_burst_resp;
    export "DPI-C" axi_set_temp_static_read_data_burst_resp = function axi_set_temp_static_read_data_burst_resp;
    export "DPI-C" axi_get_temp_static_read_data_burst_id = function axi_get_temp_static_read_data_burst_id;
    export "DPI-C" axi_set_temp_static_read_data_burst_id = function axi_set_temp_static_read_data_burst_id;
    export "DPI-C" axi_get_temp_static_read_data_burst_data_user = function axi_get_temp_static_read_data_burst_data_user;
    export "DPI-C" axi_set_temp_static_read_data_burst_data_user = function axi_set_temp_static_read_data_burst_data_user;
    export "DPI-C" axi_get_temp_static_read_data_burst_data_start_time = function axi_get_temp_static_read_data_burst_data_start_time;
    export "DPI-C" axi_set_temp_static_read_data_burst_data_start_time = function axi_set_temp_static_read_data_burst_data_start_time;
    export "DPI-C" axi_get_temp_static_read_data_burst_data_end_time = function axi_get_temp_static_read_data_burst_data_end_time;
    export "DPI-C" axi_set_temp_static_read_data_burst_data_end_time = function axi_set_temp_static_read_data_burst_data_end_time;
    import "DPI-C" context axi_read_data_burst_SendSendingSent_SystemVerilog =
    task axi_read_data_burst_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [3:0] burst_length,
        input int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi_read_data_burst_ReceivedReceivingReceive_SystemVerilog =
    task axi_read_data_burst_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_data_burst_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_read_data_burst_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((4) - 1):0] burst_length,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_write_data_burst_data_words = function axi_get_temp_static_write_data_burst_data_words;
    export "DPI-C" axi_set_temp_static_write_data_burst_data_words = function axi_set_temp_static_write_data_burst_data_words;
    export "DPI-C" axi_get_temp_static_write_data_burst_write_strobes = function axi_get_temp_static_write_data_burst_write_strobes;
    export "DPI-C" axi_set_temp_static_write_data_burst_write_strobes = function axi_set_temp_static_write_data_burst_write_strobes;
    export "DPI-C" axi_get_temp_static_write_data_burst_id = function axi_get_temp_static_write_data_burst_id;
    export "DPI-C" axi_set_temp_static_write_data_burst_id = function axi_set_temp_static_write_data_burst_id;
    export "DPI-C" axi_get_temp_static_write_data_burst_data_user = function axi_get_temp_static_write_data_burst_data_user;
    export "DPI-C" axi_set_temp_static_write_data_burst_data_user = function axi_set_temp_static_write_data_burst_data_user;
    export "DPI-C" axi_get_temp_static_write_data_burst_write_data_beats_delay = function axi_get_temp_static_write_data_burst_write_data_beats_delay;
    export "DPI-C" axi_set_temp_static_write_data_burst_write_data_beats_delay = function axi_set_temp_static_write_data_burst_write_data_beats_delay;
    export "DPI-C" axi_get_temp_static_write_data_burst_data_start_time = function axi_get_temp_static_write_data_burst_data_start_time;
    export "DPI-C" axi_set_temp_static_write_data_burst_data_start_time = function axi_set_temp_static_write_data_burst_data_start_time;
    export "DPI-C" axi_get_temp_static_write_data_burst_data_end_time = function axi_get_temp_static_write_data_burst_data_end_time;
    export "DPI-C" axi_set_temp_static_write_data_burst_data_end_time = function axi_set_temp_static_write_data_burst_data_end_time;
    import "DPI-C" context axi_write_data_burst_SendSendingSent_SystemVerilog =
    task axi_write_data_burst_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int burst_length,
        input int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi_write_data_burst_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_data_burst_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_user_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_data_burst_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_write_data_burst_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int burst_length,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_read_addr_channel_phase_addr = function axi_get_temp_static_read_addr_channel_phase_addr;
    export "DPI-C" axi_set_temp_static_read_addr_channel_phase_addr = function axi_set_temp_static_read_addr_channel_phase_addr;
    export "DPI-C" axi_get_temp_static_read_addr_channel_phase_id = function axi_get_temp_static_read_addr_channel_phase_id;
    export "DPI-C" axi_set_temp_static_read_addr_channel_phase_id = function axi_set_temp_static_read_addr_channel_phase_id;
    import "DPI-C" context axi_read_addr_channel_phase_SendSendingSent_SystemVerilog =
    task axi_read_addr_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [3:0] burst_length,
        input int size,
        input int burst,
        input int lock,
        input int cache,
        input int prot,
        input bit [7:0] addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_read_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi_read_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_read_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((4) - 1):0] burst_length,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output int prot,
        output bit [((8) - 1):0] addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_read_channel_phase_data = function axi_get_temp_static_read_channel_phase_data;
    export "DPI-C" axi_set_temp_static_read_channel_phase_data = function axi_set_temp_static_read_channel_phase_data;
    export "DPI-C" axi_get_temp_static_read_channel_phase_id = function axi_get_temp_static_read_channel_phase_id;
    export "DPI-C" axi_set_temp_static_read_channel_phase_id = function axi_set_temp_static_read_channel_phase_id;
    import "DPI-C" context axi_read_channel_phase_SendSendingSent_SystemVerilog =
    task axi_read_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit last,
        input int resp,
        input bit [7:0] data_user,
        input int data_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_read_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi_read_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_channel_phase_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_read_channel_phase_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit last,
        output int resp,
        output bit [((8) - 1):0] data_user,
        output int data_ready_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_write_addr_channel_phase_addr = function axi_get_temp_static_write_addr_channel_phase_addr;
    export "DPI-C" axi_set_temp_static_write_addr_channel_phase_addr = function axi_set_temp_static_write_addr_channel_phase_addr;
    export "DPI-C" axi_get_temp_static_write_addr_channel_phase_id = function axi_get_temp_static_write_addr_channel_phase_id;
    export "DPI-C" axi_set_temp_static_write_addr_channel_phase_id = function axi_set_temp_static_write_addr_channel_phase_id;
    import "DPI-C" context axi_write_addr_channel_phase_SendSendingSent_SystemVerilog =
    task axi_write_addr_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [3:0] burst_length,
        input int size,
        input int burst,
        input int lock,
        input int cache,
        input int prot,
        input bit [7:0] addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_write_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_write_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((4) - 1):0] burst_length,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output int prot,
        output bit [((8) - 1):0] addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_write_channel_phase_data = function axi_get_temp_static_write_channel_phase_data;
    export "DPI-C" axi_set_temp_static_write_channel_phase_data = function axi_set_temp_static_write_channel_phase_data;
    export "DPI-C" axi_get_temp_static_write_channel_phase_write_strobes = function axi_get_temp_static_write_channel_phase_write_strobes;
    export "DPI-C" axi_set_temp_static_write_channel_phase_write_strobes = function axi_set_temp_static_write_channel_phase_write_strobes;
    export "DPI-C" axi_get_temp_static_write_channel_phase_id = function axi_get_temp_static_write_channel_phase_id;
    export "DPI-C" axi_set_temp_static_write_channel_phase_id = function axi_set_temp_static_write_channel_phase_id;
    import "DPI-C" context axi_write_channel_phase_SendSendingSent_SystemVerilog =
    task axi_write_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [7:0] data_user,
        input int data_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_write_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_channel_phase_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_write_channel_phase_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit last,
        output bit [((8) - 1):0] data_user,
        output int data_ready_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_write_resp_channel_phase_id = function axi_get_temp_static_write_resp_channel_phase_id;
    export "DPI-C" axi_set_temp_static_write_resp_channel_phase_id = function axi_set_temp_static_write_resp_channel_phase_id;
    import "DPI-C" context axi_write_resp_channel_phase_SendSendingSent_SystemVerilog =
    task axi_write_resp_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int resp,
        input bit [7:0] resp_user,
        input int write_response_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi_write_resp_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_resp_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_resp_channel_phase_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_write_resp_channel_phase_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int resp,
        output bit [((8) - 1):0] resp_user,
        output int write_response_ready_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_read_addr_channel_cycle_addr = function axi_get_temp_static_read_addr_channel_cycle_addr;
    export "DPI-C" axi_set_temp_static_read_addr_channel_cycle_addr = function axi_set_temp_static_read_addr_channel_cycle_addr;
    export "DPI-C" axi_get_temp_static_read_addr_channel_cycle_id = function axi_get_temp_static_read_addr_channel_cycle_id;
    export "DPI-C" axi_set_temp_static_read_addr_channel_cycle_id = function axi_set_temp_static_read_addr_channel_cycle_id;
    import "DPI-C" context axi_read_addr_channel_cycle_SendSendingSent_SystemVerilog =
    task axi_read_addr_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [3:0] burst_length,
        input int size,
        input int burst,
        input int lock,
        input int cache,
        input int prot,
        input bit [7:0] addr_user,
        input int _unit_id
    );
    import "DPI-C" context axi_read_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi_read_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_read_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((4) - 1):0] burst_length,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output int prot,
        output bit [((8) - 1):0] addr_user,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_addr_channel_ready_SendSendingSent_SystemVerilog =
    task axi_read_addr_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_read_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi_read_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_read_channel_cycle_data = function axi_get_temp_static_read_channel_cycle_data;
    export "DPI-C" axi_set_temp_static_read_channel_cycle_data = function axi_set_temp_static_read_channel_cycle_data;
    export "DPI-C" axi_get_temp_static_read_channel_cycle_id = function axi_get_temp_static_read_channel_cycle_id;
    export "DPI-C" axi_set_temp_static_read_channel_cycle_id = function axi_set_temp_static_read_channel_cycle_id;
    import "DPI-C" context axi_read_channel_cycle_SendSendingSent_SystemVerilog =
    task axi_read_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit last,
        input int resp,
        input bit [7:0] data_user,
        input int _unit_id
    );
    import "DPI-C" context axi_read_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi_read_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_read_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit last,
        output int resp,
        output bit [((8) - 1):0] data_user,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_read_channel_ready_SendSendingSent_SystemVerilog =
    task axi_read_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_read_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi_read_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_write_addr_channel_cycle_addr = function axi_get_temp_static_write_addr_channel_cycle_addr;
    export "DPI-C" axi_set_temp_static_write_addr_channel_cycle_addr = function axi_set_temp_static_write_addr_channel_cycle_addr;
    export "DPI-C" axi_get_temp_static_write_addr_channel_cycle_id = function axi_get_temp_static_write_addr_channel_cycle_id;
    export "DPI-C" axi_set_temp_static_write_addr_channel_cycle_id = function axi_set_temp_static_write_addr_channel_cycle_id;
    import "DPI-C" context axi_write_addr_channel_cycle_SendSendingSent_SystemVerilog =
    task axi_write_addr_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [3:0] burst_length,
        input int size,
        input int burst,
        input int lock,
        input int cache,
        input int prot,
        input bit [7:0] addr_user,
        input int _unit_id
    );
    import "DPI-C" context axi_write_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_write_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((4) - 1):0] burst_length,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output int prot,
        output bit [((8) - 1):0] addr_user,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_addr_channel_ready_SendSendingSent_SystemVerilog =
    task axi_write_addr_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_write_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_write_channel_cycle_data = function axi_get_temp_static_write_channel_cycle_data;
    export "DPI-C" axi_set_temp_static_write_channel_cycle_data = function axi_set_temp_static_write_channel_cycle_data;
    export "DPI-C" axi_get_temp_static_write_channel_cycle_strb = function axi_get_temp_static_write_channel_cycle_strb;
    export "DPI-C" axi_set_temp_static_write_channel_cycle_strb = function axi_set_temp_static_write_channel_cycle_strb;
    export "DPI-C" axi_get_temp_static_write_channel_cycle_id = function axi_get_temp_static_write_channel_cycle_id;
    export "DPI-C" axi_set_temp_static_write_channel_cycle_id = function axi_set_temp_static_write_channel_cycle_id;
    import "DPI-C" context axi_write_channel_cycle_SendSendingSent_SystemVerilog =
    task axi_write_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [7:0] data_user,
        input int _unit_id
    );
    import "DPI-C" context axi_write_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_write_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit last,
        output bit [((8) - 1):0] data_user,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_channel_ready_SendSendingSent_SystemVerilog =
    task axi_write_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_write_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi_get_temp_static_write_resp_channel_cycle_id = function axi_get_temp_static_write_resp_channel_cycle_id;
    export "DPI-C" axi_set_temp_static_write_resp_channel_cycle_id = function axi_set_temp_static_write_resp_channel_cycle_id;
    import "DPI-C" context axi_write_resp_channel_cycle_SendSendingSent_SystemVerilog =
    task axi_write_resp_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int resp,
        input bit [7:0] resp_user,
        input int _unit_id
    );
    import "DPI-C" context axi_write_resp_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_resp_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_resp_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog =
    task axi_write_resp_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int resp,
        output bit [((8) - 1):0] resp_user,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_write_resp_channel_ready_SendSendingSent_SystemVerilog =
    task axi_write_resp_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi_write_resp_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi_write_resp_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi_end_of_timestep_VPI_SystemVerilog =
    task axi_end_of_timestep_VPI_SystemVerilog();
    import "DPI-C" context function longint axi_get_interface_handle();

    // Waiter task and control
    reg wait_for_control = 0;

    always @(posedge wait_for_control)
    begin
        disable wait_for;
        wait_for_control = 0;
    end

    export "DPI-C" axi_wait_for = task wait_for;

    task wait_for();
        begin
            wait(0 == 1);
        end
    endtask

    // handle control
    longint last_handle = 0;

    longint last_start_time = 0;

    longint last_end_time = 0;

    export "DPI-C" axi_set_last_handle_and_times = function set_last_handle_and_times;

    function void set_last_handle_and_times(longint _handle, longint _start, longint _end);
        last_handle = _handle;
        last_start_time = _start;
        last_end_time = _end;
    endfunction

    // Drive wires (from Cohesive) 
    assign ACLK = internal_ACLK;
    assign ARESETn = internal_ARESETn;
    assign AWVALID = internal_AWVALID;
    assign AWADDR = internal_AWADDR;
    assign AWLEN = internal_AWLEN;
    assign AWSIZE = internal_AWSIZE;
    assign AWBURST = internal_AWBURST;
    assign AWLOCK = internal_AWLOCK;
    assign AWCACHE = internal_AWCACHE;
    assign AWPROT = internal_AWPROT;
    assign AWID = internal_AWID;
    assign AWREADY = internal_AWREADY;
    assign AWUSER = internal_AWUSER;
    assign ARVALID = internal_ARVALID;
    assign ARADDR = internal_ARADDR;
    assign ARLEN = internal_ARLEN;
    assign ARSIZE = internal_ARSIZE;
    assign ARBURST = internal_ARBURST;
    assign ARLOCK = internal_ARLOCK;
    assign ARCACHE = internal_ARCACHE;
    assign ARPROT = internal_ARPROT;
    assign ARID = internal_ARID;
    assign ARREADY = internal_ARREADY;
    assign ARUSER = internal_ARUSER;
    assign RVALID = internal_RVALID;
    assign RLAST = internal_RLAST;
    assign RDATA = internal_RDATA;
    assign RRESP = internal_RRESP;
    assign RID = internal_RID;
    assign RREADY = internal_RREADY;
    assign RUSER = internal_RUSER;
    assign WVALID = internal_WVALID;
    assign WLAST = internal_WLAST;
    assign WDATA = internal_WDATA;
    assign WSTRB = internal_WSTRB;
    assign WID = internal_WID;
    assign WREADY = internal_WREADY;
    assign WUSER = internal_WUSER;
    assign BVALID = internal_BVALID;
    assign BRESP = internal_BRESP;
    assign BID = internal_BID;
    assign BREADY = internal_BREADY;
    assign BUSER = internal_BUSER;
    // Drive wires (from User) 
    assign ACLK = m_ACLK;
    assign ARESETn = m_ARESETn;
    assign AWVALID = m_AWVALID;
    assign AWADDR = m_AWADDR;
    assign AWLEN = m_AWLEN;
    assign AWSIZE = m_AWSIZE;
    assign AWBURST = m_AWBURST;
    assign AWLOCK = m_AWLOCK;
    assign AWCACHE = m_AWCACHE;
    assign AWPROT = m_AWPROT;
    assign AWID = m_AWID;
    assign AWREADY = m_AWREADY;
    assign AWUSER = m_AWUSER;
    assign ARVALID = m_ARVALID;
    assign ARADDR = m_ARADDR;
    assign ARLEN = m_ARLEN;
    assign ARSIZE = m_ARSIZE;
    assign ARBURST = m_ARBURST;
    assign ARLOCK = m_ARLOCK;
    assign ARCACHE = m_ARCACHE;
    assign ARPROT = m_ARPROT;
    assign ARID = m_ARID;
    assign ARREADY = m_ARREADY;
    assign ARUSER = m_ARUSER;
    assign RVALID = m_RVALID;
    assign RLAST = m_RLAST;
    assign RDATA = m_RDATA;
    assign RRESP = m_RRESP;
    assign RID = m_RID;
    assign RREADY = m_RREADY;
    assign RUSER = m_RUSER;
    assign WVALID = m_WVALID;
    assign WLAST = m_WLAST;
    assign WDATA = m_WDATA;
    assign WSTRB = m_WSTRB;
    assign WID = m_WID;
    assign WREADY = m_WREADY;
    assign WUSER = m_WUSER;
    assign BVALID = m_BVALID;
    assign BRESP = m_BRESP;
    assign BID = m_BID;
    assign BREADY = m_BREADY;
    assign BUSER = m_BUSER;

    reg ACLK_changed = 0;
    reg ARESETn_changed = 0;
    reg AWVALID_changed = 0;
    reg AWADDR_changed = 0;
    reg AWLEN_changed = 0;
    reg AWSIZE_changed = 0;
    reg AWBURST_changed = 0;
    reg AWLOCK_changed = 0;
    reg AWCACHE_changed = 0;
    reg AWPROT_changed = 0;
    reg AWID_changed = 0;
    reg AWREADY_changed = 0;
    reg AWUSER_changed = 0;
    reg ARVALID_changed = 0;
    reg ARADDR_changed = 0;
    reg ARLEN_changed = 0;
    reg ARSIZE_changed = 0;
    reg ARBURST_changed = 0;
    reg ARLOCK_changed = 0;
    reg ARCACHE_changed = 0;
    reg ARPROT_changed = 0;
    reg ARID_changed = 0;
    reg ARREADY_changed = 0;
    reg ARUSER_changed = 0;
    reg RVALID_changed = 0;
    reg RLAST_changed = 0;
    reg RDATA_changed = 0;
    reg RRESP_changed = 0;
    reg RID_changed = 0;
    reg RREADY_changed = 0;
    reg RUSER_changed = 0;
    reg WVALID_changed = 0;
    reg WLAST_changed = 0;
    reg WDATA_changed = 0;
    reg WSTRB_changed = 0;
    reg WID_changed = 0;
    reg WREADY_changed = 0;
    reg WUSER_changed = 0;
    reg BVALID_changed = 0;
    reg BRESP_changed = 0;
    reg BID_changed = 0;
    reg BREADY_changed = 0;
    reg BUSER_changed = 0;
    reg config_clk_init_value_changed = 0;
    reg config_clk_phase_shift_changed = 0;
    reg config_clk_1st_time_changed = 0;
    reg config_clk_2nd_time_changed = 0;
    reg config_setup_time_changed = 0;
    reg config_hold_time_changed = 0;
    reg config_max_transaction_time_factor_changed = 0;
    reg config_timeout_max_data_transfer_changed = 0;
    reg config_burst_timeout_factor_changed = 0;
    reg config_max_latency_AWVALID_assertion_to_AWREADY_changed = 0;
    reg config_max_latency_ARVALID_assertion_to_ARREADY_changed = 0;
    reg config_max_latency_RVALID_assertion_to_RREADY_changed = 0;
    reg config_max_latency_BVALID_assertion_to_BREADY_changed = 0;
    reg config_max_latency_WVALID_assertion_to_WREADY_changed = 0;
    reg config_write_ctrl_first_ratio_changed = 0;
    reg config_write_data_first_ratio_changed = 0;
    reg config_write_ctrl_to_data_mintime_changed = 0;
    reg config_write_data_to_ctrl_mintime_changed = 0;
    reg config_master_write_delay_changed = 0;
    reg config_reset_low_clocks_changed = 0;
    reg config_reset_hold_time_changed = 0;
    reg config_protect_ready_changed = 0;
    reg config_enable_user_sideband_changed = 0;
    reg config_extended_length_enable_changed = 0;
    reg config_enable_burst_reserved_value_changed = 0;
    reg config_enable_lock_reserved_value_changed = 0;
    reg config_enable_cache_reserved_value_changed = 0;
    reg config_enable_all_assertions_changed = 0;
    reg config_enable_assertion_changed = 0;
    reg config_enable_error_changed = 0;
    reg config_enable_errors_changed = 0;
    reg config_enable_all_assertion_errors_changed = 0;
    reg config_abstraction_level_changed = 0;
    reg config_slave_start_addr_changed = 0;
    reg config_slave_end_addr_changed = 0;
    reg config_enable_slave_addr_range_in_bfm_changed = 0;
    reg config_read_data_reordering_depth_changed = 0;
    reg config_enable_read_data_reordering_depth_in_bfm_changed = 0;
    reg config_awid_wid_mismatch_changed = 0;
    reg config_length_last_mismatch_error_changed = 0;
    reg config_master_error_position_changed = 0;
    reg dummy_var_changed = 0;
    reg config_wlast_length_changed = 0;
    reg config_wid_for_awid_not_matching_changed = 0;
    reg config_support_exclusive_access_changed = 0;
    reg config_write_data_interleaving_depth_changed = 0;
    reg status_master_error_changed = 0;
    reg status_num_reads_waiting_for_resp_changed = 0;
    reg status_num_writes_waiting_for_response_changed = 0;
    reg check_total_num_wdata_outstanding_changed = 0;
    reg total_num_wdata_outstanding_changed = 0;
    reg check_max_num_wdata_outstanding_per_id_changed = 0;
    reg max_num_wdata_outstanding_per_id_changed = 0;
    reg check_max_num_waddr_outstanding_per_id_changed = 0;
    reg max_num_waddr_outstanding_per_id_changed = 0;
    reg check_total_num_waddr_outstanding_changed = 0;
    reg total_num_waddr_outstanding_changed = 0;
    reg status_outstanding_num_for_waddr_changed = 0;
    reg start_finding_outstanding_waddr_changed = 0;
    reg status_outstanding_num_for_wdata_changed = 0;
    reg start_finding_outstanding_wdata_changed = 0;
    reg find_waddr_outstanding_for_wid_changed = 0;
    reg find_wdata_outstanding_for_wid_changed = 0;
    reg change_in_wdata_outstanding_per_id_changed = 0;
    reg start_finding_change_in_wdata_changed = 0;
    reg find_change_in_wdata_outstanding_for_wid_changed = 0;
    reg config_max_outstanding_wr_changed = 0;
    reg config_max_outstanding_rd_changed = 0;
    reg config_error_on_deleted_valid_cycles_changed = 0;
    reg config_stats_enable_changed = 0;
    reg config_stats_enable_AXI_read_occupancy_changed = 0;
    reg config_stats_enable_AXI_write_occupancy_changed = 0;
    reg config_stats_enable_read_data_occupancy_changed = 0;
    reg config_stats_enable_write_data_occupancy_changed = 0;
    reg config_stats_enable_read_latency_changed = 0;
    reg config_stats_enable_write_latency_changed = 0;
    reg config_stats_enable_read_address_waits_changed = 0;
    reg config_stats_enable_read_data_waits_changed = 0;
    reg config_stats_enable_write_address_waits_changed = 0;
    reg config_stats_enable_write_data_waits_changed = 0;
    reg config_stats_enable_write_response_waits_changed = 0;
    reg config_stats_enable_read_bandwidth_changed = 0;
    reg config_stats_enable_write_bandwidth_changed = 0;
    reg config_stats_AXI_read_occupancy_step_changed = 0;
    reg config_stats_AXI_read_occupancy_multiple_changed = 0;
    reg stats_AXI_read_active_changed = 0;
    reg stats_AXI_read_occupancy_sw_changed = 0;
    reg stats_AXI_read_occupancy_sw_updated_changed = 0;
    reg stats_AXI_read_idle_sw_changed = 0;
    reg stats_AXI_read_occupancy_min_changed = 0;
    reg stats_AXI_read_idle_min_changed = 0;
    reg stats_AXI_read_occupancy_max_changed = 0;
    reg stats_AXI_read_idle_max_changed = 0;
    reg stats_AXI_read_occupancy_mean_changed = 0;
    reg stats_AXI_read_idle_mean_changed = 0;
    reg config_stats_AXI_write_occupancy_step_changed = 0;
    reg config_stats_AXI_write_occupancy_multiple_changed = 0;
    reg stats_AXI_write_active_changed = 0;
    reg stats_AXI_write_occupancy_sw_changed = 0;
    reg stats_AXI_write_occupancy_sw_updated_changed = 0;
    reg stats_AXI_write_idle_sw_changed = 0;
    reg stats_AXI_write_occupancy_min_changed = 0;
    reg stats_AXI_write_idle_min_changed = 0;
    reg stats_AXI_write_occupancy_max_changed = 0;
    reg stats_AXI_write_idle_max_changed = 0;
    reg stats_AXI_write_occupancy_mean_changed = 0;
    reg stats_AXI_write_idle_mean_changed = 0;
    reg config_stats_read_data_occupancy_step_changed = 0;
    reg config_stats_read_data_occupancy_multiple_changed = 0;
    reg stats_read_data_occupancy_sw_changed = 0;
    reg stats_read_data_occupancy_sw_updated_changed = 0;
    reg stats_read_data_idle_sw_changed = 0;
    reg stats_read_data_occupancy_min_changed = 0;
    reg stats_read_data_idle_min_changed = 0;
    reg stats_read_data_occupancy_max_changed = 0;
    reg stats_read_data_idle_max_changed = 0;
    reg stats_read_data_occupancy_mean_changed = 0;
    reg stats_read_data_idle_mean_changed = 0;
    reg config_stats_write_data_occupancy_step_changed = 0;
    reg config_stats_write_data_occupancy_multiple_changed = 0;
    reg stats_write_data_occupancy_sw_changed = 0;
    reg stats_write_data_occupancy_sw_updated_changed = 0;
    reg stats_write_data_idle_sw_changed = 0;
    reg stats_write_data_occupancy_min_changed = 0;
    reg stats_write_data_idle_min_changed = 0;
    reg stats_write_data_occupancy_max_changed = 0;
    reg stats_write_data_idle_max_changed = 0;
    reg stats_write_data_occupancy_mean_changed = 0;
    reg stats_write_data_idle_mean_changed = 0;
    reg config_stats_read_bandwidth_step_changed = 0;
    reg config_stats_read_bandwidth_multiple_changed = 0;
    reg stats_read_bandwidth_sw_changed = 0;
    reg stats_read_bandwidth_sw_updated_changed = 0;
    reg stats_read_bandwidth_min_changed = 0;
    reg stats_read_bandwidth_max_changed = 0;
    reg stats_read_bandwidth_mean_changed = 0;
    reg config_stats_write_bandwidth_step_changed = 0;
    reg config_stats_write_bandwidth_multiple_changed = 0;
    reg stats_write_bandwidth_sw_changed = 0;
    reg stats_write_bandwidth_sw_updated_changed = 0;
    reg stats_write_bandwidth_min_changed = 0;
    reg stats_write_bandwidth_max_changed = 0;
    reg stats_write_bandwidth_mean_changed = 0;
    reg config_stats_read_latency_step_changed = 0;
    reg config_stats_read_latency_multiple_changed = 0;
    reg stats_read_latency_sw_updated_changed = 0;
    reg stats_read_address_data_latency_inst_changed = 0;
    reg stats_read_address_data_latency_sw_changed = 0;
    reg stats_read_address_data_latency_min_changed = 0;
    reg stats_read_address_data_latency_max_changed = 0;
    reg stats_read_address_data_latency_mean_changed = 0;
    reg stats_read_address_address_latency_inst_changed = 0;
    reg stats_read_address_address_latency_sw_changed = 0;
    reg stats_read_address_address_latency_min_changed = 0;
    reg stats_read_address_address_latency_max_changed = 0;
    reg stats_read_address_address_latency_mean_changed = 0;
    reg config_stats_write_latency_step_changed = 0;
    reg config_stats_write_latency_multiple_changed = 0;
    reg stats_write_latency_sw_updated_changed = 0;
    reg stats_write_address_data_latency_inst_changed = 0;
    reg stats_write_address_data_latency_sw_changed = 0;
    reg stats_write_address_data_latency_min_changed = 0;
    reg stats_write_address_data_latency_max_changed = 0;
    reg stats_write_address_data_latency_mean_changed = 0;
    reg stats_write_data_response_latency_inst_changed = 0;
    reg stats_write_data_response_latency_sw_changed = 0;
    reg stats_write_data_response_latency_min_changed = 0;
    reg stats_write_data_response_latency_max_changed = 0;
    reg stats_write_data_response_latency_mean_changed = 0;
    reg stats_write_address_address_latency_inst_changed = 0;
    reg stats_write_address_address_latency_sw_changed = 0;
    reg stats_write_address_address_latency_min_changed = 0;
    reg stats_write_address_address_latency_max_changed = 0;
    reg stats_write_address_address_latency_mean_changed = 0;
    reg config_stats_read_address_waits_step_changed = 0;
    reg config_stats_read_address_waits_multiple_changed = 0;
    reg stats_read_address_waits_inst_changed = 0;
    reg stats_read_address_waits_sw_changed = 0;
    reg stats_read_address_waits_sw_updated_changed = 0;
    reg stats_read_address_waits_min_changed = 0;
    reg stats_read_address_waits_max_changed = 0;
    reg stats_read_address_waits_mean_changed = 0;
    reg config_stats_read_data_waits_step_changed = 0;
    reg config_stats_read_data_waits_multiple_changed = 0;
    reg stats_read_data_waits_inst_changed = 0;
    reg stats_read_data_waits_sw_changed = 0;
    reg stats_read_data_waits_sw_updated_changed = 0;
    reg stats_read_data_waits_min_changed = 0;
    reg stats_read_data_waits_max_changed = 0;
    reg stats_read_data_waits_mean_changed = 0;
    reg config_stats_write_address_waits_step_changed = 0;
    reg config_stats_write_address_waits_multiple_changed = 0;
    reg stats_write_address_waits_inst_changed = 0;
    reg stats_write_address_waits_sw_changed = 0;
    reg stats_write_address_waits_sw_updated_changed = 0;
    reg stats_write_address_waits_min_changed = 0;
    reg stats_write_address_waits_max_changed = 0;
    reg stats_write_address_waits_mean_changed = 0;
    reg config_stats_write_data_waits_step_changed = 0;
    reg config_stats_write_data_waits_multiple_changed = 0;
    reg stats_write_data_waits_inst_changed = 0;
    reg stats_write_data_waits_sw_changed = 0;
    reg stats_write_data_waits_sw_updated_changed = 0;
    reg stats_write_data_waits_min_changed = 0;
    reg stats_write_data_waits_max_changed = 0;
    reg stats_write_data_waits_mean_changed = 0;
    reg config_stats_write_response_waits_step_changed = 0;
    reg config_stats_write_response_waits_multiple_changed = 0;
    reg stats_write_response_waits_inst_changed = 0;
    reg stats_write_response_waits_sw_changed = 0;
    reg stats_write_response_waits_sw_updated_changed = 0;
    reg stats_write_response_waits_min_changed = 0;
    reg stats_write_response_waits_max_changed = 0;
    reg stats_write_response_waits_mean_changed = 0;
    reg stats_rw_transaction_last_duration_changed = 0;
    reg stats_AXI_read_last_duration_changed = 0;
    reg stats_AXI_write_last_duration_changed = 0;
    reg stats_read_addr_channel_phase_last_duration_changed = 0;
    reg stats_read_data_burst_last_duration_changed = 0;
    reg stats_read_channel_phase_last_duration_changed = 0;
    reg stats_write_addr_channel_phase_last_duration_changed = 0;
    reg stats_write_data_burst_last_duration_changed = 0;
    reg stats_write_channel_phase_last_duration_changed = 0;
    reg stats_write_resp_channel_phase_last_duration_changed = 0;

    reg end_of_timestep_control = 0;


    // SV wire change monitors

    function automatic void axi_local_set_ACLK_from_SystemVerilog(  );
            axi_set_ACLK_from_SystemVerilog(ACLK); // DPI call to imported task
        
        axi_propagate_ACLK_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ACLK or posedge _check_t0_values )
    begin
        axi_local_set_ACLK_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARESETn_from_SystemVerilog(  );
            axi_set_ARESETn_from_SystemVerilog(ARESETn); // DPI call to imported task
        
        axi_propagate_ARESETn_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARESETn or posedge _check_t0_values )
    begin
        axi_local_set_ARESETn_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWVALID_from_SystemVerilog(  );
            axi_set_AWVALID_from_SystemVerilog(AWVALID); // DPI call to imported task
        
        axi_propagate_AWVALID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWVALID or posedge _check_t0_values )
    begin
        axi_local_set_AWVALID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWADDR_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ADDRESS_WIDTH ); _this_dot_1++)
        begin
            axi_set_AWADDR_from_SystemVerilog_index1(_this_dot_1,AWADDR[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi_propagate_AWADDR_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWADDR or posedge _check_t0_values )
    begin
        axi_local_set_AWADDR_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWLEN_from_SystemVerilog(  );
            axi_set_AWLEN_from_SystemVerilog(AWLEN); // DPI call to imported task
        
        axi_propagate_AWLEN_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWLEN or posedge _check_t0_values )
    begin
        axi_local_set_AWLEN_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWSIZE_from_SystemVerilog(  );
            axi_set_AWSIZE_from_SystemVerilog(AWSIZE); // DPI call to imported task
        
        axi_propagate_AWSIZE_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWSIZE or posedge _check_t0_values )
    begin
        axi_local_set_AWSIZE_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWBURST_from_SystemVerilog(  );
            axi_set_AWBURST_from_SystemVerilog(AWBURST); // DPI call to imported task
        
        axi_propagate_AWBURST_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWBURST or posedge _check_t0_values )
    begin
        axi_local_set_AWBURST_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWLOCK_from_SystemVerilog(  );
            axi_set_AWLOCK_from_SystemVerilog(AWLOCK); // DPI call to imported task
        
        axi_propagate_AWLOCK_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWLOCK or posedge _check_t0_values )
    begin
        axi_local_set_AWLOCK_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWCACHE_from_SystemVerilog(  );
            axi_set_AWCACHE_from_SystemVerilog(AWCACHE); // DPI call to imported task
        
        axi_propagate_AWCACHE_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWCACHE or posedge _check_t0_values )
    begin
        axi_local_set_AWCACHE_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWPROT_from_SystemVerilog(  );
            axi_set_AWPROT_from_SystemVerilog(AWPROT); // DPI call to imported task
        
        axi_propagate_AWPROT_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWPROT or posedge _check_t0_values )
    begin
        axi_local_set_AWPROT_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWID_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ID_WIDTH ); _this_dot_1++)
        begin
            axi_set_AWID_from_SystemVerilog_index1(_this_dot_1,AWID[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi_propagate_AWID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWID or posedge _check_t0_values )
    begin
        axi_local_set_AWID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWREADY_from_SystemVerilog(  );
            axi_set_AWREADY_from_SystemVerilog(AWREADY); // DPI call to imported task
        
        axi_propagate_AWREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWREADY or posedge _check_t0_values )
    begin
        axi_local_set_AWREADY_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_AWUSER_from_SystemVerilog(  );
            axi_set_AWUSER_from_SystemVerilog(AWUSER); // DPI call to imported task
        
        axi_propagate_AWUSER_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWUSER or posedge _check_t0_values )
    begin
        axi_local_set_AWUSER_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARVALID_from_SystemVerilog(  );
            axi_set_ARVALID_from_SystemVerilog(ARVALID); // DPI call to imported task
        
        axi_propagate_ARVALID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARVALID or posedge _check_t0_values )
    begin
        axi_local_set_ARVALID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARADDR_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ADDRESS_WIDTH ); _this_dot_1++)
        begin
            axi_set_ARADDR_from_SystemVerilog_index1(_this_dot_1,ARADDR[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi_propagate_ARADDR_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARADDR or posedge _check_t0_values )
    begin
        axi_local_set_ARADDR_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARLEN_from_SystemVerilog(  );
            axi_set_ARLEN_from_SystemVerilog(ARLEN); // DPI call to imported task
        
        axi_propagate_ARLEN_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARLEN or posedge _check_t0_values )
    begin
        axi_local_set_ARLEN_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARSIZE_from_SystemVerilog(  );
            axi_set_ARSIZE_from_SystemVerilog(ARSIZE); // DPI call to imported task
        
        axi_propagate_ARSIZE_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARSIZE or posedge _check_t0_values )
    begin
        axi_local_set_ARSIZE_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARBURST_from_SystemVerilog(  );
            axi_set_ARBURST_from_SystemVerilog(ARBURST); // DPI call to imported task
        
        axi_propagate_ARBURST_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARBURST or posedge _check_t0_values )
    begin
        axi_local_set_ARBURST_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARLOCK_from_SystemVerilog(  );
            axi_set_ARLOCK_from_SystemVerilog(ARLOCK); // DPI call to imported task
        
        axi_propagate_ARLOCK_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARLOCK or posedge _check_t0_values )
    begin
        axi_local_set_ARLOCK_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARCACHE_from_SystemVerilog(  );
            axi_set_ARCACHE_from_SystemVerilog(ARCACHE); // DPI call to imported task
        
        axi_propagate_ARCACHE_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARCACHE or posedge _check_t0_values )
    begin
        axi_local_set_ARCACHE_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARPROT_from_SystemVerilog(  );
            axi_set_ARPROT_from_SystemVerilog(ARPROT); // DPI call to imported task
        
        axi_propagate_ARPROT_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARPROT or posedge _check_t0_values )
    begin
        axi_local_set_ARPROT_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARID_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ID_WIDTH ); _this_dot_1++)
        begin
            axi_set_ARID_from_SystemVerilog_index1(_this_dot_1,ARID[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi_propagate_ARID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARID or posedge _check_t0_values )
    begin
        axi_local_set_ARID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARREADY_from_SystemVerilog(  );
            axi_set_ARREADY_from_SystemVerilog(ARREADY); // DPI call to imported task
        
        axi_propagate_ARREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARREADY or posedge _check_t0_values )
    begin
        axi_local_set_ARREADY_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_ARUSER_from_SystemVerilog(  );
            axi_set_ARUSER_from_SystemVerilog(ARUSER); // DPI call to imported task
        
        axi_propagate_ARUSER_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARUSER or posedge _check_t0_values )
    begin
        axi_local_set_ARUSER_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_RVALID_from_SystemVerilog(  );
            axi_set_RVALID_from_SystemVerilog(RVALID); // DPI call to imported task
        
        axi_propagate_RVALID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RVALID or posedge _check_t0_values )
    begin
        axi_local_set_RVALID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_RLAST_from_SystemVerilog(  );
            axi_set_RLAST_from_SystemVerilog(RLAST); // DPI call to imported task
        
        axi_propagate_RLAST_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RLAST or posedge _check_t0_values )
    begin
        axi_local_set_RLAST_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_RDATA_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_RDATA_WIDTH ); _this_dot_1++)
        begin
            axi_set_RDATA_from_SystemVerilog_index1(_this_dot_1,RDATA[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi_propagate_RDATA_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RDATA or posedge _check_t0_values )
    begin
        axi_local_set_RDATA_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_RRESP_from_SystemVerilog(  );
            axi_set_RRESP_from_SystemVerilog(RRESP); // DPI call to imported task
        
        axi_propagate_RRESP_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RRESP or posedge _check_t0_values )
    begin
        axi_local_set_RRESP_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_RID_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ID_WIDTH ); _this_dot_1++)
        begin
            axi_set_RID_from_SystemVerilog_index1(_this_dot_1,RID[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi_propagate_RID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RID or posedge _check_t0_values )
    begin
        axi_local_set_RID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_RREADY_from_SystemVerilog(  );
            axi_set_RREADY_from_SystemVerilog(RREADY); // DPI call to imported task
        
        axi_propagate_RREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RREADY or posedge _check_t0_values )
    begin
        axi_local_set_RREADY_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_RUSER_from_SystemVerilog(  );
            axi_set_RUSER_from_SystemVerilog(RUSER); // DPI call to imported task
        
        axi_propagate_RUSER_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RUSER or posedge _check_t0_values )
    begin
        axi_local_set_RUSER_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_WVALID_from_SystemVerilog(  );
            axi_set_WVALID_from_SystemVerilog(WVALID); // DPI call to imported task
        
        axi_propagate_WVALID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WVALID or posedge _check_t0_values )
    begin
        axi_local_set_WVALID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_WLAST_from_SystemVerilog(  );
            axi_set_WLAST_from_SystemVerilog(WLAST); // DPI call to imported task
        
        axi_propagate_WLAST_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WLAST or posedge _check_t0_values )
    begin
        axi_local_set_WLAST_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_WDATA_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_WDATA_WIDTH ); _this_dot_1++)
        begin
            axi_set_WDATA_from_SystemVerilog_index1(_this_dot_1,WDATA[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi_propagate_WDATA_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WDATA or posedge _check_t0_values )
    begin
        axi_local_set_WDATA_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_WSTRB_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( (AXI_WDATA_WIDTH / 8) ); _this_dot_1++)
        begin
            axi_set_WSTRB_from_SystemVerilog_index1(_this_dot_1,WSTRB[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi_propagate_WSTRB_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WSTRB or posedge _check_t0_values )
    begin
        axi_local_set_WSTRB_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_WID_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ID_WIDTH ); _this_dot_1++)
        begin
            axi_set_WID_from_SystemVerilog_index1(_this_dot_1,WID[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi_propagate_WID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WID or posedge _check_t0_values )
    begin
        axi_local_set_WID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_WREADY_from_SystemVerilog(  );
            axi_set_WREADY_from_SystemVerilog(WREADY); // DPI call to imported task
        
        axi_propagate_WREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WREADY or posedge _check_t0_values )
    begin
        axi_local_set_WREADY_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_WUSER_from_SystemVerilog(  );
            axi_set_WUSER_from_SystemVerilog(WUSER); // DPI call to imported task
        
        axi_propagate_WUSER_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WUSER or posedge _check_t0_values )
    begin
        axi_local_set_WUSER_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_BVALID_from_SystemVerilog(  );
            axi_set_BVALID_from_SystemVerilog(BVALID); // DPI call to imported task
        
        axi_propagate_BVALID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( BVALID or posedge _check_t0_values )
    begin
        axi_local_set_BVALID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_BRESP_from_SystemVerilog(  );
            axi_set_BRESP_from_SystemVerilog(BRESP); // DPI call to imported task
        
        axi_propagate_BRESP_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( BRESP or posedge _check_t0_values )
    begin
        axi_local_set_BRESP_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_BID_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ID_WIDTH ); _this_dot_1++)
        begin
            axi_set_BID_from_SystemVerilog_index1(_this_dot_1,BID[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi_propagate_BID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( BID or posedge _check_t0_values )
    begin
        axi_local_set_BID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_BREADY_from_SystemVerilog(  );
            axi_set_BREADY_from_SystemVerilog(BREADY); // DPI call to imported task
        
        axi_propagate_BREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( BREADY or posedge _check_t0_values )
    begin
        axi_local_set_BREADY_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi_local_set_BUSER_from_SystemVerilog(  );
            axi_set_BUSER_from_SystemVerilog(BUSER); // DPI call to imported task
        
        axi_propagate_BUSER_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( BUSER or posedge _check_t0_values )
    begin
        axi_local_set_BUSER_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end


    // CY wire and variable changed flag monitors

    always @(posedge ACLK_changed or posedge _check_t0_values )
    begin
        while (ACLK_changed == 1'b1)
        begin
            axi_get_ACLK_into_SystemVerilog(  ); // DPI call to imported task
            ACLK_changed = 1'b0;
            #0  #0 if ( ACLK !== internal_ACLK )
            begin
                axi_local_set_ACLK_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARESETn_changed or posedge _check_t0_values )
    begin
        while (ARESETn_changed == 1'b1)
        begin
            axi_get_ARESETn_into_SystemVerilog(  ); // DPI call to imported task
            ARESETn_changed = 1'b0;
            #0  #0 if ( ARESETn !== internal_ARESETn )
            begin
                axi_local_set_ARESETn_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWVALID_changed or posedge _check_t0_values )
    begin
        while (AWVALID_changed == 1'b1)
        begin
            axi_get_AWVALID_into_SystemVerilog(  ); // DPI call to imported task
            AWVALID_changed = 1'b0;
            #0  #0 if ( AWVALID !== internal_AWVALID )
            begin
                axi_local_set_AWVALID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWADDR_changed or posedge _check_t0_values )
    begin
        while (AWADDR_changed == 1'b1)
        begin
            axi_get_AWADDR_into_SystemVerilog(  ); // DPI call to imported task
            AWADDR_changed = 1'b0;
            #0  #0 if ( AWADDR !== internal_AWADDR )
            begin
                axi_local_set_AWADDR_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWLEN_changed or posedge _check_t0_values )
    begin
        while (AWLEN_changed == 1'b1)
        begin
            axi_get_AWLEN_into_SystemVerilog(  ); // DPI call to imported task
            AWLEN_changed = 1'b0;
            #0  #0 if ( AWLEN !== internal_AWLEN )
            begin
                axi_local_set_AWLEN_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWSIZE_changed or posedge _check_t0_values )
    begin
        while (AWSIZE_changed == 1'b1)
        begin
            axi_get_AWSIZE_into_SystemVerilog(  ); // DPI call to imported task
            AWSIZE_changed = 1'b0;
            #0  #0 if ( AWSIZE !== internal_AWSIZE )
            begin
                axi_local_set_AWSIZE_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWBURST_changed or posedge _check_t0_values )
    begin
        while (AWBURST_changed == 1'b1)
        begin
            axi_get_AWBURST_into_SystemVerilog(  ); // DPI call to imported task
            AWBURST_changed = 1'b0;
            #0  #0 if ( AWBURST !== internal_AWBURST )
            begin
                axi_local_set_AWBURST_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWLOCK_changed or posedge _check_t0_values )
    begin
        while (AWLOCK_changed == 1'b1)
        begin
            axi_get_AWLOCK_into_SystemVerilog(  ); // DPI call to imported task
            AWLOCK_changed = 1'b0;
            #0  #0 if ( AWLOCK !== internal_AWLOCK )
            begin
                axi_local_set_AWLOCK_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWCACHE_changed or posedge _check_t0_values )
    begin
        while (AWCACHE_changed == 1'b1)
        begin
            axi_get_AWCACHE_into_SystemVerilog(  ); // DPI call to imported task
            AWCACHE_changed = 1'b0;
            #0  #0 if ( AWCACHE !== internal_AWCACHE )
            begin
                axi_local_set_AWCACHE_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWPROT_changed or posedge _check_t0_values )
    begin
        while (AWPROT_changed == 1'b1)
        begin
            axi_get_AWPROT_into_SystemVerilog(  ); // DPI call to imported task
            AWPROT_changed = 1'b0;
            #0  #0 if ( AWPROT !== internal_AWPROT )
            begin
                axi_local_set_AWPROT_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWID_changed or posedge _check_t0_values )
    begin
        while (AWID_changed == 1'b1)
        begin
            axi_get_AWID_into_SystemVerilog(  ); // DPI call to imported task
            AWID_changed = 1'b0;
            #0  #0 if ( AWID !== internal_AWID )
            begin
                axi_local_set_AWID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWREADY_changed or posedge _check_t0_values )
    begin
        while (AWREADY_changed == 1'b1)
        begin
            axi_get_AWREADY_into_SystemVerilog(  ); // DPI call to imported task
            AWREADY_changed = 1'b0;
            #0  #0 if ( AWREADY !== internal_AWREADY )
            begin
                axi_local_set_AWREADY_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWUSER_changed or posedge _check_t0_values )
    begin
        while (AWUSER_changed == 1'b1)
        begin
            axi_get_AWUSER_into_SystemVerilog(  ); // DPI call to imported task
            AWUSER_changed = 1'b0;
            #0  #0 if ( AWUSER !== internal_AWUSER )
            begin
                axi_local_set_AWUSER_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARVALID_changed or posedge _check_t0_values )
    begin
        while (ARVALID_changed == 1'b1)
        begin
            axi_get_ARVALID_into_SystemVerilog(  ); // DPI call to imported task
            ARVALID_changed = 1'b0;
            #0  #0 if ( ARVALID !== internal_ARVALID )
            begin
                axi_local_set_ARVALID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARADDR_changed or posedge _check_t0_values )
    begin
        while (ARADDR_changed == 1'b1)
        begin
            axi_get_ARADDR_into_SystemVerilog(  ); // DPI call to imported task
            ARADDR_changed = 1'b0;
            #0  #0 if ( ARADDR !== internal_ARADDR )
            begin
                axi_local_set_ARADDR_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARLEN_changed or posedge _check_t0_values )
    begin
        while (ARLEN_changed == 1'b1)
        begin
            axi_get_ARLEN_into_SystemVerilog(  ); // DPI call to imported task
            ARLEN_changed = 1'b0;
            #0  #0 if ( ARLEN !== internal_ARLEN )
            begin
                axi_local_set_ARLEN_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARSIZE_changed or posedge _check_t0_values )
    begin
        while (ARSIZE_changed == 1'b1)
        begin
            axi_get_ARSIZE_into_SystemVerilog(  ); // DPI call to imported task
            ARSIZE_changed = 1'b0;
            #0  #0 if ( ARSIZE !== internal_ARSIZE )
            begin
                axi_local_set_ARSIZE_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARBURST_changed or posedge _check_t0_values )
    begin
        while (ARBURST_changed == 1'b1)
        begin
            axi_get_ARBURST_into_SystemVerilog(  ); // DPI call to imported task
            ARBURST_changed = 1'b0;
            #0  #0 if ( ARBURST !== internal_ARBURST )
            begin
                axi_local_set_ARBURST_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARLOCK_changed or posedge _check_t0_values )
    begin
        while (ARLOCK_changed == 1'b1)
        begin
            axi_get_ARLOCK_into_SystemVerilog(  ); // DPI call to imported task
            ARLOCK_changed = 1'b0;
            #0  #0 if ( ARLOCK !== internal_ARLOCK )
            begin
                axi_local_set_ARLOCK_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARCACHE_changed or posedge _check_t0_values )
    begin
        while (ARCACHE_changed == 1'b1)
        begin
            axi_get_ARCACHE_into_SystemVerilog(  ); // DPI call to imported task
            ARCACHE_changed = 1'b0;
            #0  #0 if ( ARCACHE !== internal_ARCACHE )
            begin
                axi_local_set_ARCACHE_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARPROT_changed or posedge _check_t0_values )
    begin
        while (ARPROT_changed == 1'b1)
        begin
            axi_get_ARPROT_into_SystemVerilog(  ); // DPI call to imported task
            ARPROT_changed = 1'b0;
            #0  #0 if ( ARPROT !== internal_ARPROT )
            begin
                axi_local_set_ARPROT_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARID_changed or posedge _check_t0_values )
    begin
        while (ARID_changed == 1'b1)
        begin
            axi_get_ARID_into_SystemVerilog(  ); // DPI call to imported task
            ARID_changed = 1'b0;
            #0  #0 if ( ARID !== internal_ARID )
            begin
                axi_local_set_ARID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARREADY_changed or posedge _check_t0_values )
    begin
        while (ARREADY_changed == 1'b1)
        begin
            axi_get_ARREADY_into_SystemVerilog(  ); // DPI call to imported task
            ARREADY_changed = 1'b0;
            #0  #0 if ( ARREADY !== internal_ARREADY )
            begin
                axi_local_set_ARREADY_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARUSER_changed or posedge _check_t0_values )
    begin
        while (ARUSER_changed == 1'b1)
        begin
            axi_get_ARUSER_into_SystemVerilog(  ); // DPI call to imported task
            ARUSER_changed = 1'b0;
            #0  #0 if ( ARUSER !== internal_ARUSER )
            begin
                axi_local_set_ARUSER_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RVALID_changed or posedge _check_t0_values )
    begin
        while (RVALID_changed == 1'b1)
        begin
            axi_get_RVALID_into_SystemVerilog(  ); // DPI call to imported task
            RVALID_changed = 1'b0;
            #0  #0 if ( RVALID !== internal_RVALID )
            begin
                axi_local_set_RVALID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RLAST_changed or posedge _check_t0_values )
    begin
        while (RLAST_changed == 1'b1)
        begin
            axi_get_RLAST_into_SystemVerilog(  ); // DPI call to imported task
            RLAST_changed = 1'b0;
            #0  #0 if ( RLAST !== internal_RLAST )
            begin
                axi_local_set_RLAST_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RDATA_changed or posedge _check_t0_values )
    begin
        while (RDATA_changed == 1'b1)
        begin
            axi_get_RDATA_into_SystemVerilog(  ); // DPI call to imported task
            RDATA_changed = 1'b0;
            #0  #0 if ( RDATA !== internal_RDATA )
            begin
                axi_local_set_RDATA_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RRESP_changed or posedge _check_t0_values )
    begin
        while (RRESP_changed == 1'b1)
        begin
            axi_get_RRESP_into_SystemVerilog(  ); // DPI call to imported task
            RRESP_changed = 1'b0;
            #0  #0 if ( RRESP !== internal_RRESP )
            begin
                axi_local_set_RRESP_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RID_changed or posedge _check_t0_values )
    begin
        while (RID_changed == 1'b1)
        begin
            axi_get_RID_into_SystemVerilog(  ); // DPI call to imported task
            RID_changed = 1'b0;
            #0  #0 if ( RID !== internal_RID )
            begin
                axi_local_set_RID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RREADY_changed or posedge _check_t0_values )
    begin
        while (RREADY_changed == 1'b1)
        begin
            axi_get_RREADY_into_SystemVerilog(  ); // DPI call to imported task
            RREADY_changed = 1'b0;
            #0  #0 if ( RREADY !== internal_RREADY )
            begin
                axi_local_set_RREADY_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RUSER_changed or posedge _check_t0_values )
    begin
        while (RUSER_changed == 1'b1)
        begin
            axi_get_RUSER_into_SystemVerilog(  ); // DPI call to imported task
            RUSER_changed = 1'b0;
            #0  #0 if ( RUSER !== internal_RUSER )
            begin
                axi_local_set_RUSER_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WVALID_changed or posedge _check_t0_values )
    begin
        while (WVALID_changed == 1'b1)
        begin
            axi_get_WVALID_into_SystemVerilog(  ); // DPI call to imported task
            WVALID_changed = 1'b0;
            #0  #0 if ( WVALID !== internal_WVALID )
            begin
                axi_local_set_WVALID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WLAST_changed or posedge _check_t0_values )
    begin
        while (WLAST_changed == 1'b1)
        begin
            axi_get_WLAST_into_SystemVerilog(  ); // DPI call to imported task
            WLAST_changed = 1'b0;
            #0  #0 if ( WLAST !== internal_WLAST )
            begin
                axi_local_set_WLAST_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WDATA_changed or posedge _check_t0_values )
    begin
        while (WDATA_changed == 1'b1)
        begin
            axi_get_WDATA_into_SystemVerilog(  ); // DPI call to imported task
            WDATA_changed = 1'b0;
            #0  #0 if ( WDATA !== internal_WDATA )
            begin
                axi_local_set_WDATA_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WSTRB_changed or posedge _check_t0_values )
    begin
        while (WSTRB_changed == 1'b1)
        begin
            axi_get_WSTRB_into_SystemVerilog(  ); // DPI call to imported task
            WSTRB_changed = 1'b0;
            #0  #0 if ( WSTRB !== internal_WSTRB )
            begin
                axi_local_set_WSTRB_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WID_changed or posedge _check_t0_values )
    begin
        while (WID_changed == 1'b1)
        begin
            axi_get_WID_into_SystemVerilog(  ); // DPI call to imported task
            WID_changed = 1'b0;
            #0  #0 if ( WID !== internal_WID )
            begin
                axi_local_set_WID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WREADY_changed or posedge _check_t0_values )
    begin
        while (WREADY_changed == 1'b1)
        begin
            axi_get_WREADY_into_SystemVerilog(  ); // DPI call to imported task
            WREADY_changed = 1'b0;
            #0  #0 if ( WREADY !== internal_WREADY )
            begin
                axi_local_set_WREADY_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WUSER_changed or posedge _check_t0_values )
    begin
        while (WUSER_changed == 1'b1)
        begin
            axi_get_WUSER_into_SystemVerilog(  ); // DPI call to imported task
            WUSER_changed = 1'b0;
            #0  #0 if ( WUSER !== internal_WUSER )
            begin
                axi_local_set_WUSER_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge BVALID_changed or posedge _check_t0_values )
    begin
        while (BVALID_changed == 1'b1)
        begin
            axi_get_BVALID_into_SystemVerilog(  ); // DPI call to imported task
            BVALID_changed = 1'b0;
            #0  #0 if ( BVALID !== internal_BVALID )
            begin
                axi_local_set_BVALID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge BRESP_changed or posedge _check_t0_values )
    begin
        while (BRESP_changed == 1'b1)
        begin
            axi_get_BRESP_into_SystemVerilog(  ); // DPI call to imported task
            BRESP_changed = 1'b0;
            #0  #0 if ( BRESP !== internal_BRESP )
            begin
                axi_local_set_BRESP_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge BID_changed or posedge _check_t0_values )
    begin
        while (BID_changed == 1'b1)
        begin
            axi_get_BID_into_SystemVerilog(  ); // DPI call to imported task
            BID_changed = 1'b0;
            #0  #0 if ( BID !== internal_BID )
            begin
                axi_local_set_BID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge BREADY_changed or posedge _check_t0_values )
    begin
        while (BREADY_changed == 1'b1)
        begin
            axi_get_BREADY_into_SystemVerilog(  ); // DPI call to imported task
            BREADY_changed = 1'b0;
            #0  #0 if ( BREADY !== internal_BREADY )
            begin
                axi_local_set_BREADY_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge BUSER_changed or posedge _check_t0_values )
    begin
        while (BUSER_changed == 1'b1)
        begin
            axi_get_BUSER_into_SystemVerilog(  ); // DPI call to imported task
            BUSER_changed = 1'b0;
            #0  #0 if ( BUSER !== internal_BUSER )
            begin
                axi_local_set_BUSER_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge config_clk_init_value_changed or posedge _check_t0_values )
    begin
        if (config_clk_init_value_changed == 1'b1)
        begin
            axi_get_config_clk_init_value_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_init_value_changed = 1'b0;
        end
    end

    always @(posedge config_clk_phase_shift_changed or posedge _check_t0_values )
    begin
        if (config_clk_phase_shift_changed == 1'b1)
        begin
            axi_get_config_clk_phase_shift_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_phase_shift_changed = 1'b0;
        end
    end

    always @(posedge config_clk_1st_time_changed or posedge _check_t0_values )
    begin
        if (config_clk_1st_time_changed == 1'b1)
        begin
            axi_get_config_clk_1st_time_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_1st_time_changed = 1'b0;
        end
    end

    always @(posedge config_clk_2nd_time_changed or posedge _check_t0_values )
    begin
        if (config_clk_2nd_time_changed == 1'b1)
        begin
            axi_get_config_clk_2nd_time_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_2nd_time_changed = 1'b0;
        end
    end

    always @(posedge config_setup_time_changed or posedge _check_t0_values )
    begin
        if (config_setup_time_changed == 1'b1)
        begin
            axi_get_config_setup_time_into_SystemVerilog(  ); // DPI call to imported task
            config_setup_time_changed = 1'b0;
        end
    end

    always @(posedge config_hold_time_changed or posedge _check_t0_values )
    begin
        if (config_hold_time_changed == 1'b1)
        begin
            axi_get_config_hold_time_into_SystemVerilog(  ); // DPI call to imported task
            config_hold_time_changed = 1'b0;
        end
    end

    always @(posedge config_max_transaction_time_factor_changed or posedge _check_t0_values )
    begin
        if (config_max_transaction_time_factor_changed == 1'b1)
        begin
            axi_get_config_max_transaction_time_factor_into_SystemVerilog(  ); // DPI call to imported task
            config_max_transaction_time_factor_changed = 1'b0;
        end
    end

    always @(posedge config_timeout_max_data_transfer_changed or posedge _check_t0_values )
    begin
        if (config_timeout_max_data_transfer_changed == 1'b1)
        begin
            axi_get_config_timeout_max_data_transfer_into_SystemVerilog(  ); // DPI call to imported task
            config_timeout_max_data_transfer_changed = 1'b0;
        end
    end

    always @(posedge config_burst_timeout_factor_changed or posedge _check_t0_values )
    begin
        if (config_burst_timeout_factor_changed == 1'b1)
        begin
            axi_get_config_burst_timeout_factor_into_SystemVerilog(  ); // DPI call to imported task
            config_burst_timeout_factor_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_AWVALID_assertion_to_AWREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_AWVALID_assertion_to_AWREADY_changed == 1'b1)
        begin
            axi_get_config_max_latency_AWVALID_assertion_to_AWREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_AWVALID_assertion_to_AWREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_ARVALID_assertion_to_ARREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_ARVALID_assertion_to_ARREADY_changed == 1'b1)
        begin
            axi_get_config_max_latency_ARVALID_assertion_to_ARREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_ARVALID_assertion_to_ARREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_RVALID_assertion_to_RREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_RVALID_assertion_to_RREADY_changed == 1'b1)
        begin
            axi_get_config_max_latency_RVALID_assertion_to_RREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_RVALID_assertion_to_RREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_BVALID_assertion_to_BREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_BVALID_assertion_to_BREADY_changed == 1'b1)
        begin
            axi_get_config_max_latency_BVALID_assertion_to_BREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_BVALID_assertion_to_BREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_WVALID_assertion_to_WREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_WVALID_assertion_to_WREADY_changed == 1'b1)
        begin
            axi_get_config_max_latency_WVALID_assertion_to_WREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_WVALID_assertion_to_WREADY_changed = 1'b0;
        end
    end

    always @(posedge config_write_ctrl_first_ratio_changed or posedge _check_t0_values )
    begin
        if (config_write_ctrl_first_ratio_changed == 1'b1)
        begin
            axi_get_config_write_ctrl_first_ratio_into_SystemVerilog(  ); // DPI call to imported task
            config_write_ctrl_first_ratio_changed = 1'b0;
        end
    end

    always @(posedge config_write_data_first_ratio_changed or posedge _check_t0_values )
    begin
        if (config_write_data_first_ratio_changed == 1'b1)
        begin
            axi_get_config_write_data_first_ratio_into_SystemVerilog(  ); // DPI call to imported task
            config_write_data_first_ratio_changed = 1'b0;
        end
    end

    always @(posedge config_write_ctrl_to_data_mintime_changed or posedge _check_t0_values )
    begin
        if (config_write_ctrl_to_data_mintime_changed == 1'b1)
        begin
            axi_get_config_write_ctrl_to_data_mintime_into_SystemVerilog(  ); // DPI call to imported task
            config_write_ctrl_to_data_mintime_changed = 1'b0;
        end
    end

    always @(posedge config_write_data_to_ctrl_mintime_changed or posedge _check_t0_values )
    begin
        if (config_write_data_to_ctrl_mintime_changed == 1'b1)
        begin
            axi_get_config_write_data_to_ctrl_mintime_into_SystemVerilog(  ); // DPI call to imported task
            config_write_data_to_ctrl_mintime_changed = 1'b0;
        end
    end

    always @(posedge config_master_write_delay_changed or posedge _check_t0_values )
    begin
        if (config_master_write_delay_changed == 1'b1)
        begin
            axi_get_config_master_write_delay_into_SystemVerilog(  ); // DPI call to imported task
            config_master_write_delay_changed = 1'b0;
        end
    end

    always @(posedge config_reset_low_clocks_changed or posedge _check_t0_values )
    begin
        if (config_reset_low_clocks_changed == 1'b1)
        begin
            axi_get_config_reset_low_clocks_into_SystemVerilog(  ); // DPI call to imported task
            config_reset_low_clocks_changed = 1'b0;
        end
    end

    always @(posedge config_reset_hold_time_changed or posedge _check_t0_values )
    begin
        if (config_reset_hold_time_changed == 1'b1)
        begin
            axi_get_config_reset_hold_time_into_SystemVerilog(  ); // DPI call to imported task
            config_reset_hold_time_changed = 1'b0;
        end
    end

    always @(posedge config_protect_ready_changed or posedge _check_t0_values )
    begin
        if (config_protect_ready_changed == 1'b1)
        begin
            axi_get_config_protect_ready_into_SystemVerilog(  ); // DPI call to imported task
            config_protect_ready_changed = 1'b0;
        end
    end

    always @(posedge config_enable_user_sideband_changed or posedge _check_t0_values )
    begin
        if (config_enable_user_sideband_changed == 1'b1)
        begin
            axi_get_config_enable_user_sideband_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_user_sideband_changed = 1'b0;
        end
    end

    always @(posedge config_extended_length_enable_changed or posedge _check_t0_values )
    begin
        if (config_extended_length_enable_changed == 1'b1)
        begin
            axi_get_config_extended_length_enable_into_SystemVerilog(  ); // DPI call to imported task
            config_extended_length_enable_changed = 1'b0;
        end
    end

    always @(posedge config_enable_burst_reserved_value_changed or posedge _check_t0_values )
    begin
        if (config_enable_burst_reserved_value_changed == 1'b1)
        begin
            axi_get_config_enable_burst_reserved_value_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_burst_reserved_value_changed = 1'b0;
        end
    end

    always @(posedge config_enable_lock_reserved_value_changed or posedge _check_t0_values )
    begin
        if (config_enable_lock_reserved_value_changed == 1'b1)
        begin
            axi_get_config_enable_lock_reserved_value_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_lock_reserved_value_changed = 1'b0;
        end
    end

    always @(posedge config_enable_cache_reserved_value_changed or posedge _check_t0_values )
    begin
        if (config_enable_cache_reserved_value_changed == 1'b1)
        begin
            axi_get_config_enable_cache_reserved_value_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_cache_reserved_value_changed = 1'b0;
        end
    end

    always @(posedge config_enable_all_assertions_changed or posedge _check_t0_values )
    begin
        if (config_enable_all_assertions_changed == 1'b1)
        begin
            axi_get_config_enable_all_assertions_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_all_assertions_changed = 1'b0;
        end
    end

    always @(posedge config_enable_assertion_changed or posedge _check_t0_values )
    begin
        if (config_enable_assertion_changed == 1'b1)
        begin
            axi_get_config_enable_assertion_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_assertion_changed = 1'b0;
        end
    end

    always @(posedge config_enable_error_changed or posedge _check_t0_values )
    begin
        if (config_enable_error_changed == 1'b1)
        begin
            axi_get_config_enable_error_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_error_changed = 1'b0;
        end
    end

    always @(posedge config_enable_errors_changed or posedge _check_t0_values )
    begin
        if (config_enable_errors_changed == 1'b1)
        begin
            axi_get_config_enable_errors_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_errors_changed = 1'b0;
        end
    end

    always @(posedge config_enable_all_assertion_errors_changed or posedge _check_t0_values )
    begin
        if (config_enable_all_assertion_errors_changed == 1'b1)
        begin
            axi_get_config_enable_all_assertion_errors_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_all_assertion_errors_changed = 1'b0;
        end
    end

    always @(posedge config_abstraction_level_changed or posedge _check_t0_values )
    begin
        if (config_abstraction_level_changed == 1'b1)
        begin
            axi_get_config_abstraction_level_into_SystemVerilog(  ); // DPI call to imported task
            config_abstraction_level_changed = 1'b0;
        end
    end

    always @(posedge config_slave_start_addr_changed or posedge _check_t0_values )
    begin
        if (config_slave_start_addr_changed == 1'b1)
        begin
            axi_get_config_slave_start_addr_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_start_addr_changed = 1'b0;
        end
    end

    always @(posedge config_slave_end_addr_changed or posedge _check_t0_values )
    begin
        if (config_slave_end_addr_changed == 1'b1)
        begin
            axi_get_config_slave_end_addr_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_end_addr_changed = 1'b0;
        end
    end

    always @(posedge config_enable_slave_addr_range_in_bfm_changed or posedge _check_t0_values )
    begin
        if (config_enable_slave_addr_range_in_bfm_changed == 1'b1)
        begin
            axi_get_config_enable_slave_addr_range_in_bfm_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_slave_addr_range_in_bfm_changed = 1'b0;
        end
    end

    always @(posedge config_read_data_reordering_depth_changed or posedge _check_t0_values )
    begin
        if (config_read_data_reordering_depth_changed == 1'b1)
        begin
            axi_get_config_read_data_reordering_depth_into_SystemVerilog(  ); // DPI call to imported task
            config_read_data_reordering_depth_changed = 1'b0;
        end
    end

    always @(posedge config_enable_read_data_reordering_depth_in_bfm_changed or posedge _check_t0_values )
    begin
        if (config_enable_read_data_reordering_depth_in_bfm_changed == 1'b1)
        begin
            axi_get_config_enable_read_data_reordering_depth_in_bfm_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_read_data_reordering_depth_in_bfm_changed = 1'b0;
        end
    end

    always @(posedge config_awid_wid_mismatch_changed or posedge _check_t0_values )
    begin
        if (config_awid_wid_mismatch_changed == 1'b1)
        begin
            axi_get_config_awid_wid_mismatch_into_SystemVerilog(  ); // DPI call to imported task
            config_awid_wid_mismatch_changed = 1'b0;
        end
    end

    always @(posedge config_length_last_mismatch_error_changed or posedge _check_t0_values )
    begin
        if (config_length_last_mismatch_error_changed == 1'b1)
        begin
            axi_get_config_length_last_mismatch_error_into_SystemVerilog(  ); // DPI call to imported task
            config_length_last_mismatch_error_changed = 1'b0;
        end
    end

    always @(posedge config_master_error_position_changed or posedge _check_t0_values )
    begin
        if (config_master_error_position_changed == 1'b1)
        begin
            axi_get_config_master_error_position_into_SystemVerilog(  ); // DPI call to imported task
            config_master_error_position_changed = 1'b0;
        end
    end

    always @(posedge dummy_var_changed or posedge _check_t0_values )
    begin
        if (dummy_var_changed == 1'b1)
        begin
            axi_get_dummy_var_into_SystemVerilog(  ); // DPI call to imported task
            dummy_var_changed = 1'b0;
        end
    end

    always @(posedge config_wlast_length_changed or posedge _check_t0_values )
    begin
        if (config_wlast_length_changed == 1'b1)
        begin
            axi_get_config_wlast_length_into_SystemVerilog(  ); // DPI call to imported task
            config_wlast_length_changed = 1'b0;
        end
    end

    always @(posedge config_wid_for_awid_not_matching_changed or posedge _check_t0_values )
    begin
        if (config_wid_for_awid_not_matching_changed == 1'b1)
        begin
            axi_get_config_wid_for_awid_not_matching_into_SystemVerilog(  ); // DPI call to imported task
            config_wid_for_awid_not_matching_changed = 1'b0;
        end
    end

    always @(posedge config_support_exclusive_access_changed or posedge _check_t0_values )
    begin
        if (config_support_exclusive_access_changed == 1'b1)
        begin
            axi_get_config_support_exclusive_access_into_SystemVerilog(  ); // DPI call to imported task
            config_support_exclusive_access_changed = 1'b0;
        end
    end

    always @(posedge config_write_data_interleaving_depth_changed or posedge _check_t0_values )
    begin
        if (config_write_data_interleaving_depth_changed == 1'b1)
        begin
            axi_get_config_write_data_interleaving_depth_into_SystemVerilog(  ); // DPI call to imported task
            config_write_data_interleaving_depth_changed = 1'b0;
        end
    end

    always @(posedge status_master_error_changed or posedge _check_t0_values )
    begin
        if (status_master_error_changed == 1'b1)
        begin
            axi_get_status_master_error_into_SystemVerilog(  ); // DPI call to imported task
            status_master_error_changed = 1'b0;
        end
    end

    always @(posedge status_num_reads_waiting_for_resp_changed or posedge _check_t0_values )
    begin
        if (status_num_reads_waiting_for_resp_changed == 1'b1)
        begin
            axi_get_status_num_reads_waiting_for_resp_into_SystemVerilog(  ); // DPI call to imported task
            status_num_reads_waiting_for_resp_changed = 1'b0;
        end
    end

    always @(posedge status_num_writes_waiting_for_response_changed or posedge _check_t0_values )
    begin
        if (status_num_writes_waiting_for_response_changed == 1'b1)
        begin
            axi_get_status_num_writes_waiting_for_response_into_SystemVerilog(  ); // DPI call to imported task
            status_num_writes_waiting_for_response_changed = 1'b0;
        end
    end

    always @(posedge check_total_num_wdata_outstanding_changed or posedge _check_t0_values )
    begin
        if (check_total_num_wdata_outstanding_changed == 1'b1)
        begin
            axi_get_check_total_num_wdata_outstanding_into_SystemVerilog(  ); // DPI call to imported task
            check_total_num_wdata_outstanding_changed = 1'b0;
        end
    end

    always @(posedge total_num_wdata_outstanding_changed or posedge _check_t0_values )
    begin
        if (total_num_wdata_outstanding_changed == 1'b1)
        begin
            axi_get_total_num_wdata_outstanding_into_SystemVerilog(  ); // DPI call to imported task
            total_num_wdata_outstanding_changed = 1'b0;
        end
    end

    always @(posedge check_max_num_wdata_outstanding_per_id_changed or posedge _check_t0_values )
    begin
        if (check_max_num_wdata_outstanding_per_id_changed == 1'b1)
        begin
            axi_get_check_max_num_wdata_outstanding_per_id_into_SystemVerilog(  ); // DPI call to imported task
            check_max_num_wdata_outstanding_per_id_changed = 1'b0;
        end
    end

    always @(posedge max_num_wdata_outstanding_per_id_changed or posedge _check_t0_values )
    begin
        if (max_num_wdata_outstanding_per_id_changed == 1'b1)
        begin
            axi_get_max_num_wdata_outstanding_per_id_into_SystemVerilog(  ); // DPI call to imported task
            max_num_wdata_outstanding_per_id_changed = 1'b0;
        end
    end

    always @(posedge check_max_num_waddr_outstanding_per_id_changed or posedge _check_t0_values )
    begin
        if (check_max_num_waddr_outstanding_per_id_changed == 1'b1)
        begin
            axi_get_check_max_num_waddr_outstanding_per_id_into_SystemVerilog(  ); // DPI call to imported task
            check_max_num_waddr_outstanding_per_id_changed = 1'b0;
        end
    end

    always @(posedge max_num_waddr_outstanding_per_id_changed or posedge _check_t0_values )
    begin
        if (max_num_waddr_outstanding_per_id_changed == 1'b1)
        begin
            axi_get_max_num_waddr_outstanding_per_id_into_SystemVerilog(  ); // DPI call to imported task
            max_num_waddr_outstanding_per_id_changed = 1'b0;
        end
    end

    always @(posedge check_total_num_waddr_outstanding_changed or posedge _check_t0_values )
    begin
        if (check_total_num_waddr_outstanding_changed == 1'b1)
        begin
            axi_get_check_total_num_waddr_outstanding_into_SystemVerilog(  ); // DPI call to imported task
            check_total_num_waddr_outstanding_changed = 1'b0;
        end
    end

    always @(posedge total_num_waddr_outstanding_changed or posedge _check_t0_values )
    begin
        if (total_num_waddr_outstanding_changed == 1'b1)
        begin
            axi_get_total_num_waddr_outstanding_into_SystemVerilog(  ); // DPI call to imported task
            total_num_waddr_outstanding_changed = 1'b0;
        end
    end

    always @(posedge status_outstanding_num_for_waddr_changed or posedge _check_t0_values )
    begin
        if (status_outstanding_num_for_waddr_changed == 1'b1)
        begin
            axi_get_status_outstanding_num_for_waddr_into_SystemVerilog(  ); // DPI call to imported task
            status_outstanding_num_for_waddr_changed = 1'b0;
        end
    end

    always @(posedge start_finding_outstanding_waddr_changed or posedge _check_t0_values )
    begin
        if (start_finding_outstanding_waddr_changed == 1'b1)
        begin
            axi_get_start_finding_outstanding_waddr_into_SystemVerilog(  ); // DPI call to imported task
            start_finding_outstanding_waddr_changed = 1'b0;
        end
    end

    always @(posedge status_outstanding_num_for_wdata_changed or posedge _check_t0_values )
    begin
        if (status_outstanding_num_for_wdata_changed == 1'b1)
        begin
            axi_get_status_outstanding_num_for_wdata_into_SystemVerilog(  ); // DPI call to imported task
            status_outstanding_num_for_wdata_changed = 1'b0;
        end
    end

    always @(posedge start_finding_outstanding_wdata_changed or posedge _check_t0_values )
    begin
        if (start_finding_outstanding_wdata_changed == 1'b1)
        begin
            axi_get_start_finding_outstanding_wdata_into_SystemVerilog(  ); // DPI call to imported task
            start_finding_outstanding_wdata_changed = 1'b0;
        end
    end

    always @(posedge find_waddr_outstanding_for_wid_changed or posedge _check_t0_values )
    begin
        if (find_waddr_outstanding_for_wid_changed == 1'b1)
        begin
            axi_get_find_waddr_outstanding_for_wid_into_SystemVerilog(  ); // DPI call to imported task
            find_waddr_outstanding_for_wid_changed = 1'b0;
        end
    end

    always @(posedge find_wdata_outstanding_for_wid_changed or posedge _check_t0_values )
    begin
        if (find_wdata_outstanding_for_wid_changed == 1'b1)
        begin
            axi_get_find_wdata_outstanding_for_wid_into_SystemVerilog(  ); // DPI call to imported task
            find_wdata_outstanding_for_wid_changed = 1'b0;
        end
    end

    always @(posedge change_in_wdata_outstanding_per_id_changed or posedge _check_t0_values )
    begin
        if (change_in_wdata_outstanding_per_id_changed == 1'b1)
        begin
            axi_get_change_in_wdata_outstanding_per_id_into_SystemVerilog(  ); // DPI call to imported task
            change_in_wdata_outstanding_per_id_changed = 1'b0;
        end
    end

    always @(posedge start_finding_change_in_wdata_changed or posedge _check_t0_values )
    begin
        if (start_finding_change_in_wdata_changed == 1'b1)
        begin
            axi_get_start_finding_change_in_wdata_into_SystemVerilog(  ); // DPI call to imported task
            start_finding_change_in_wdata_changed = 1'b0;
        end
    end

    always @(posedge find_change_in_wdata_outstanding_for_wid_changed or posedge _check_t0_values )
    begin
        if (find_change_in_wdata_outstanding_for_wid_changed == 1'b1)
        begin
            axi_get_find_change_in_wdata_outstanding_for_wid_into_SystemVerilog(  ); // DPI call to imported task
            find_change_in_wdata_outstanding_for_wid_changed = 1'b0;
        end
    end

    always @(posedge config_max_outstanding_wr_changed or posedge _check_t0_values )
    begin
        if (config_max_outstanding_wr_changed == 1'b1)
        begin
            axi_get_config_max_outstanding_wr_into_SystemVerilog(  ); // DPI call to imported task
            config_max_outstanding_wr_changed = 1'b0;
        end
    end

    always @(posedge config_max_outstanding_rd_changed or posedge _check_t0_values )
    begin
        if (config_max_outstanding_rd_changed == 1'b1)
        begin
            axi_get_config_max_outstanding_rd_into_SystemVerilog(  ); // DPI call to imported task
            config_max_outstanding_rd_changed = 1'b0;
        end
    end

    always @(posedge config_error_on_deleted_valid_cycles_changed or posedge _check_t0_values )
    begin
        if (config_error_on_deleted_valid_cycles_changed == 1'b1)
        begin
            axi_get_config_error_on_deleted_valid_cycles_into_SystemVerilog(  ); // DPI call to imported task
            config_error_on_deleted_valid_cycles_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_changed == 1'b1)
        begin
            axi_get_config_stats_enable_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_AXI_read_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_AXI_read_occupancy_changed == 1'b1)
        begin
            axi_get_config_stats_enable_AXI_read_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_AXI_read_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_AXI_write_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_AXI_write_occupancy_changed == 1'b1)
        begin
            axi_get_config_stats_enable_AXI_write_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_AXI_write_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_data_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_data_occupancy_changed == 1'b1)
        begin
            axi_get_config_stats_enable_read_data_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_data_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_data_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_data_occupancy_changed == 1'b1)
        begin
            axi_get_config_stats_enable_write_data_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_data_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_latency_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_latency_changed == 1'b1)
        begin
            axi_get_config_stats_enable_read_latency_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_latency_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_latency_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_latency_changed == 1'b1)
        begin
            axi_get_config_stats_enable_write_latency_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_latency_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_address_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_address_waits_changed == 1'b1)
        begin
            axi_get_config_stats_enable_read_address_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_address_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_data_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_data_waits_changed == 1'b1)
        begin
            axi_get_config_stats_enable_read_data_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_data_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_address_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_address_waits_changed == 1'b1)
        begin
            axi_get_config_stats_enable_write_address_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_address_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_data_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_data_waits_changed == 1'b1)
        begin
            axi_get_config_stats_enable_write_data_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_data_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_response_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_response_waits_changed == 1'b1)
        begin
            axi_get_config_stats_enable_write_response_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_response_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_bandwidth_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_bandwidth_changed == 1'b1)
        begin
            axi_get_config_stats_enable_read_bandwidth_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_bandwidth_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_bandwidth_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_bandwidth_changed == 1'b1)
        begin
            axi_get_config_stats_enable_write_bandwidth_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_bandwidth_changed = 1'b0;
        end
    end

    always @(posedge config_stats_AXI_read_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_AXI_read_occupancy_step_changed == 1'b1)
        begin
            axi_get_config_stats_AXI_read_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_AXI_read_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_AXI_read_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_AXI_read_occupancy_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_AXI_read_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_AXI_read_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_active_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_active_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_active_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_active_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_occupancy_sw_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_occupancy_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_occupancy_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_occupancy_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_occupancy_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_idle_sw_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_occupancy_min_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_idle_min_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_occupancy_max_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_idle_max_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_occupancy_mean_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_idle_mean_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_AXI_write_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_AXI_write_occupancy_step_changed == 1'b1)
        begin
            axi_get_config_stats_AXI_write_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_AXI_write_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_AXI_write_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_AXI_write_occupancy_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_AXI_write_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_AXI_write_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_active_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_active_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_active_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_active_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_occupancy_sw_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_occupancy_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_occupancy_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_occupancy_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_occupancy_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_idle_sw_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_occupancy_min_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_idle_min_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_occupancy_max_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_idle_max_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_occupancy_mean_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_idle_mean_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_occupancy_step_changed == 1'b1)
        begin
            axi_get_config_stats_read_data_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_occupancy_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_read_data_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_sw_changed == 1'b1)
        begin
            axi_get_stats_read_data_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_read_data_occupancy_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_sw_changed == 1'b1)
        begin
            axi_get_stats_read_data_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_min_changed == 1'b1)
        begin
            axi_get_stats_read_data_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_min_changed == 1'b1)
        begin
            axi_get_stats_read_data_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_max_changed == 1'b1)
        begin
            axi_get_stats_read_data_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_max_changed == 1'b1)
        begin
            axi_get_stats_read_data_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_mean_changed == 1'b1)
        begin
            axi_get_stats_read_data_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_mean_changed == 1'b1)
        begin
            axi_get_stats_read_data_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_occupancy_step_changed == 1'b1)
        begin
            axi_get_config_stats_write_data_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_occupancy_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_write_data_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_sw_changed == 1'b1)
        begin
            axi_get_stats_write_data_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_write_data_occupancy_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_sw_changed == 1'b1)
        begin
            axi_get_stats_write_data_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_min_changed == 1'b1)
        begin
            axi_get_stats_write_data_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_min_changed == 1'b1)
        begin
            axi_get_stats_write_data_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_max_changed == 1'b1)
        begin
            axi_get_stats_write_data_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_max_changed == 1'b1)
        begin
            axi_get_stats_write_data_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_mean_changed == 1'b1)
        begin
            axi_get_stats_write_data_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_mean_changed == 1'b1)
        begin
            axi_get_stats_write_data_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_bandwidth_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_bandwidth_step_changed == 1'b1)
        begin
            axi_get_config_stats_read_bandwidth_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_bandwidth_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_bandwidth_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_bandwidth_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_read_bandwidth_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_bandwidth_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_sw_changed == 1'b1)
        begin
            axi_get_stats_read_bandwidth_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_read_bandwidth_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_min_changed == 1'b1)
        begin
            axi_get_stats_read_bandwidth_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_max_changed == 1'b1)
        begin
            axi_get_stats_read_bandwidth_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_mean_changed == 1'b1)
        begin
            axi_get_stats_read_bandwidth_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_bandwidth_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_bandwidth_step_changed == 1'b1)
        begin
            axi_get_config_stats_write_bandwidth_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_bandwidth_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_bandwidth_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_bandwidth_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_write_bandwidth_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_bandwidth_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_sw_changed == 1'b1)
        begin
            axi_get_stats_write_bandwidth_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_write_bandwidth_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_min_changed == 1'b1)
        begin
            axi_get_stats_write_bandwidth_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_max_changed == 1'b1)
        begin
            axi_get_stats_write_bandwidth_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_mean_changed == 1'b1)
        begin
            axi_get_stats_write_bandwidth_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_latency_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_latency_step_changed == 1'b1)
        begin
            axi_get_config_stats_read_latency_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_latency_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_latency_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_latency_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_read_latency_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_latency_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_latency_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_read_latency_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_read_latency_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_latency_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_inst_changed == 1'b1)
        begin
            axi_get_stats_read_address_data_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_sw_changed == 1'b1)
        begin
            axi_get_stats_read_address_data_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_min_changed == 1'b1)
        begin
            axi_get_stats_read_address_data_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_max_changed == 1'b1)
        begin
            axi_get_stats_read_address_data_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_mean_changed == 1'b1)
        begin
            axi_get_stats_read_address_data_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_inst_changed == 1'b1)
        begin
            axi_get_stats_read_address_address_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_sw_changed == 1'b1)
        begin
            axi_get_stats_read_address_address_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_min_changed == 1'b1)
        begin
            axi_get_stats_read_address_address_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_max_changed == 1'b1)
        begin
            axi_get_stats_read_address_address_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_mean_changed == 1'b1)
        begin
            axi_get_stats_read_address_address_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_latency_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_latency_step_changed == 1'b1)
        begin
            axi_get_config_stats_write_latency_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_latency_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_latency_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_latency_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_write_latency_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_latency_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_latency_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_write_latency_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_write_latency_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_latency_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_data_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_data_latency_inst_changed == 1'b1)
        begin
            axi_get_stats_write_address_data_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_data_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_data_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_data_latency_sw_changed == 1'b1)
        begin
            axi_get_stats_write_address_data_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_data_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_data_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_data_latency_min_changed == 1'b1)
        begin
            axi_get_stats_write_address_data_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_data_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_data_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_data_latency_max_changed == 1'b1)
        begin
            axi_get_stats_write_address_data_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_data_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_data_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_data_latency_mean_changed == 1'b1)
        begin
            axi_get_stats_write_address_data_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_data_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_response_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_response_latency_inst_changed == 1'b1)
        begin
            axi_get_stats_write_data_response_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_response_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_response_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_response_latency_sw_changed == 1'b1)
        begin
            axi_get_stats_write_data_response_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_response_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_response_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_response_latency_min_changed == 1'b1)
        begin
            axi_get_stats_write_data_response_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_response_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_response_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_response_latency_max_changed == 1'b1)
        begin
            axi_get_stats_write_data_response_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_response_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_response_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_response_latency_mean_changed == 1'b1)
        begin
            axi_get_stats_write_data_response_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_response_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_inst_changed == 1'b1)
        begin
            axi_get_stats_write_address_address_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_sw_changed == 1'b1)
        begin
            axi_get_stats_write_address_address_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_min_changed == 1'b1)
        begin
            axi_get_stats_write_address_address_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_max_changed == 1'b1)
        begin
            axi_get_stats_write_address_address_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_mean_changed == 1'b1)
        begin
            axi_get_stats_write_address_address_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_address_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_address_waits_step_changed == 1'b1)
        begin
            axi_get_config_stats_read_address_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_address_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_address_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_address_waits_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_read_address_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_address_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_inst_changed == 1'b1)
        begin
            axi_get_stats_read_address_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_sw_changed == 1'b1)
        begin
            axi_get_stats_read_address_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_read_address_waits_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_min_changed == 1'b1)
        begin
            axi_get_stats_read_address_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_max_changed == 1'b1)
        begin
            axi_get_stats_read_address_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_mean_changed == 1'b1)
        begin
            axi_get_stats_read_address_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_waits_step_changed == 1'b1)
        begin
            axi_get_config_stats_read_data_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_waits_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_read_data_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_inst_changed == 1'b1)
        begin
            axi_get_stats_read_data_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_sw_changed == 1'b1)
        begin
            axi_get_stats_read_data_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_read_data_waits_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_min_changed == 1'b1)
        begin
            axi_get_stats_read_data_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_max_changed == 1'b1)
        begin
            axi_get_stats_read_data_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_mean_changed == 1'b1)
        begin
            axi_get_stats_read_data_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_address_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_address_waits_step_changed == 1'b1)
        begin
            axi_get_config_stats_write_address_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_address_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_address_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_address_waits_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_write_address_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_address_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_inst_changed == 1'b1)
        begin
            axi_get_stats_write_address_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_sw_changed == 1'b1)
        begin
            axi_get_stats_write_address_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_write_address_waits_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_min_changed == 1'b1)
        begin
            axi_get_stats_write_address_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_max_changed == 1'b1)
        begin
            axi_get_stats_write_address_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_mean_changed == 1'b1)
        begin
            axi_get_stats_write_address_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_waits_step_changed == 1'b1)
        begin
            axi_get_config_stats_write_data_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_waits_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_write_data_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_inst_changed == 1'b1)
        begin
            axi_get_stats_write_data_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_sw_changed == 1'b1)
        begin
            axi_get_stats_write_data_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_write_data_waits_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_min_changed == 1'b1)
        begin
            axi_get_stats_write_data_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_max_changed == 1'b1)
        begin
            axi_get_stats_write_data_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_mean_changed == 1'b1)
        begin
            axi_get_stats_write_data_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_response_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_response_waits_step_changed == 1'b1)
        begin
            axi_get_config_stats_write_response_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_response_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_response_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_response_waits_multiple_changed == 1'b1)
        begin
            axi_get_config_stats_write_response_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_response_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_inst_changed == 1'b1)
        begin
            axi_get_stats_write_response_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_sw_changed == 1'b1)
        begin
            axi_get_stats_write_response_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_sw_updated_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_sw_updated_changed == 1'b1)
        begin
            axi_get_stats_write_response_waits_sw_updated_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_sw_updated_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_min_changed == 1'b1)
        begin
            axi_get_stats_write_response_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_max_changed == 1'b1)
        begin
            axi_get_stats_write_response_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_mean_changed == 1'b1)
        begin
            axi_get_stats_write_response_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_rw_transaction_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_rw_transaction_last_duration_changed == 1'b1)
        begin
            axi_get_stats_rw_transaction_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_rw_transaction_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_read_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_read_last_duration_changed == 1'b1)
        begin
            axi_get_stats_AXI_read_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_read_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_AXI_write_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_AXI_write_last_duration_changed == 1'b1)
        begin
            axi_get_stats_AXI_write_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_AXI_write_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_read_addr_channel_phase_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_read_addr_channel_phase_last_duration_changed == 1'b1)
        begin
            axi_get_stats_read_addr_channel_phase_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_addr_channel_phase_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_burst_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_burst_last_duration_changed == 1'b1)
        begin
            axi_get_stats_read_data_burst_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_burst_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_read_channel_phase_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_read_channel_phase_last_duration_changed == 1'b1)
        begin
            axi_get_stats_read_channel_phase_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_channel_phase_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_write_addr_channel_phase_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_write_addr_channel_phase_last_duration_changed == 1'b1)
        begin
            axi_get_stats_write_addr_channel_phase_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_addr_channel_phase_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_burst_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_burst_last_duration_changed == 1'b1)
        begin
            axi_get_stats_write_data_burst_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_burst_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_write_channel_phase_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_write_channel_phase_last_duration_changed == 1'b1)
        begin
            axi_get_stats_write_channel_phase_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_channel_phase_last_duration_changed = 1'b0;
        end
    end

    always @(posedge stats_write_resp_channel_phase_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_write_resp_channel_phase_last_duration_changed == 1'b1)
        begin
            axi_get_stats_write_resp_channel_phase_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_resp_channel_phase_last_duration_changed = 1'b0;
        end
    end


    function longint do_get_last_handle();
        return last_handle;
    endfunction


    function longint do_get_last_start_time();
        return last_start_time;
    endfunction


    function longint do_get_last_end_time();
        return last_end_time;
    endfunction


        bit report_available;

        // Function for getting a message from QUESTA_MVC. Returns 1 if a message was returned, 0 otherwise.
        import "DPI-C" questa_mvc_sv_get_report =  function bit get_report( input longint recipient,
                                     output string category,     output string objectName,
                                     output string instanceName, output string error_no,
                                     output string typ,          output string mess );
        questa_mvc_reporter endPoint[longint];
        initial report_available = 0;

        always @report_available
        begin
            longint recipient;
            string category;
            string objectName;
            string instanceName;
            string severity;
            string mess;
            string error_no;

            if ( endPoint.first( recipient ) )
              begin
                do
                  begin
                      while ( get_report( recipient, category, objectName, instanceName, error_no, severity, mess ) )
                        begin
                          endPoint[recipient].report_message( category, "axi", 0, objectName, instanceName, error_no, severity, mess );
                        end
                  end
                while (endPoint.next(recipient));
              end
            report_available = 0;
        end

        import "DPI-C" context questa_mvc_register_end_point = function void questa_mvc_register_end_point( input longint as_end, input string name );

        // A function for registering a reporter to capture any reports coming from as_end
        function automatic void register_end_point( input longint as_end, input questa_mvc_reporter rep = null );
            if ( rep != null )
              begin
                if ( ( rep.name == "" ) || ( rep.name == "NULL" ) )
                  begin
                    $display("Error: %m: Reporter passed to register_end_point has a reserved name. Neither an empty string nor the string 'NULL' can be used.");
                  end
                else
                  begin
                    questa_mvc_register_end_point( as_end, rep.name );
                    endPoint[as_end] = rep;
                  end
              end
            else
              begin
                questa_mvc_register_end_point( as_end, "NULL" );
                endPoint.delete( as_end );
              end
        endfunction

    //------------------------------------------------------------------------------
    // Tasks for registering reports
    //------------------------------------------------------------------------------
    function void do_register_interface_reporter( input questa_mvc_reporter _rep = null );
        register_end_point( _interface_ref, _rep );
    endfunction

    function void do_register_master_reporter
    (
        input questa_mvc_reporter rep = null
    );
        register_end_point( axi_get_axi_master_end(), rep );
    endfunction

    function void do_register_slave_reporter
    (
        input questa_mvc_reporter rep = null
    );
        register_end_point( axi_get_axi_slave_end(), rep );
    endfunction

    function void do_register_clock_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
        register_end_point( axi_get_axi_clock_source_end(), rep );
    endfunction

    function void do_register_reset_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
        register_end_point( axi_get_axi_reset_source_end(), rep );
    endfunction


    // Start end_of_timestep timer
    initial
    forever
    begin
        wait_end_of_timestep();
    end


    bit non_blocking_end_of_timestep_control = 0;

    export "DPI-C" axi_wait_end_of_timestep = task wait_end_of_timestep;

    task wait_end_of_timestep();
        begin
            wait(non_blocking_end_of_timestep_control == 1);
            axi_end_of_timestep_VPI_SystemVerilog();
            non_blocking_end_of_timestep_control = 0;
        end
    endtask

    always @( posedge end_of_timestep_control or posedge _check_t0_values )
    begin
        if ( end_of_timestep_control == 1 )
        begin
            non_blocking_end_of_timestep_control <= 1;
            end_of_timestep_control = 0;
        end
    end

    //------------------------------------------------------------------------------
    // Tasks to wait for a number of specified edges on a wire
    //------------------------------------------------------------------------------

    task automatic do_wait_for_ACLK( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ACLK);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ACLK);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ACLK);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ACLK === 0 );
                    @( ACLK );
                end
                while ( ACLK !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ACLK === 1 );
                    @( ACLK );
                end
                while ( ACLK !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARESETn( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARESETn);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARESETn);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARESETn);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARESETn === 0 );
                    @( ARESETn );
                end
                while ( ARESETn !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARESETn === 1 );
                    @( ARESETn );
                end
                while ( ARESETn !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWVALID === 0 );
                    @( AWVALID );
                end
                while ( AWVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWVALID === 1 );
                    @( AWVALID );
                end
                while ( AWVALID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWADDR( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWADDR);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWADDR);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWADDR);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWADDR === 0 );
                    @( AWADDR );
                end
                while ( AWADDR !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWADDR === 1 );
                    @( AWADDR );
                end
                while ( AWADDR !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWADDR[_this_dot_1] === 0 );
                    @( AWADDR[_this_dot_1] );
                end
                while ( AWADDR[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWADDR[_this_dot_1] === 1 );
                    @( AWADDR[_this_dot_1] );
                end
                while ( AWADDR[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWLEN( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWLEN);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWLEN);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWLEN);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWLEN === 0 );
                    @( AWLEN );
                end
                while ( AWLEN !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWLEN === 1 );
                    @( AWLEN );
                end
                while ( AWLEN !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWLEN[_this_dot_1] === 0 );
                    @( AWLEN[_this_dot_1] );
                end
                while ( AWLEN[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWLEN[_this_dot_1] === 1 );
                    @( AWLEN[_this_dot_1] );
                end
                while ( AWLEN[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWSIZE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWSIZE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWSIZE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWSIZE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWSIZE === 0 );
                    @( AWSIZE );
                end
                while ( AWSIZE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWSIZE === 1 );
                    @( AWSIZE );
                end
                while ( AWSIZE !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWSIZE[_this_dot_1] === 0 );
                    @( AWSIZE[_this_dot_1] );
                end
                while ( AWSIZE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWSIZE[_this_dot_1] === 1 );
                    @( AWSIZE[_this_dot_1] );
                end
                while ( AWSIZE[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWBURST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWBURST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWBURST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWBURST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWBURST === 0 );
                    @( AWBURST );
                end
                while ( AWBURST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWBURST === 1 );
                    @( AWBURST );
                end
                while ( AWBURST !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWBURST[_this_dot_1] === 0 );
                    @( AWBURST[_this_dot_1] );
                end
                while ( AWBURST[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWBURST[_this_dot_1] === 1 );
                    @( AWBURST[_this_dot_1] );
                end
                while ( AWBURST[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWLOCK( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWLOCK);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWLOCK);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWLOCK);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWLOCK === 0 );
                    @( AWLOCK );
                end
                while ( AWLOCK !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWLOCK === 1 );
                    @( AWLOCK );
                end
                while ( AWLOCK !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWLOCK_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWLOCK[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWLOCK[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWLOCK[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWLOCK[_this_dot_1] === 0 );
                    @( AWLOCK[_this_dot_1] );
                end
                while ( AWLOCK[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWLOCK[_this_dot_1] === 1 );
                    @( AWLOCK[_this_dot_1] );
                end
                while ( AWLOCK[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWCACHE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWCACHE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWCACHE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWCACHE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWCACHE === 0 );
                    @( AWCACHE );
                end
                while ( AWCACHE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWCACHE === 1 );
                    @( AWCACHE );
                end
                while ( AWCACHE !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWCACHE[_this_dot_1] === 0 );
                    @( AWCACHE[_this_dot_1] );
                end
                while ( AWCACHE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWCACHE[_this_dot_1] === 1 );
                    @( AWCACHE[_this_dot_1] );
                end
                while ( AWCACHE[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWPROT( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWPROT);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWPROT);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWPROT);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWPROT === 0 );
                    @( AWPROT );
                end
                while ( AWPROT !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWPROT === 1 );
                    @( AWPROT );
                end
                while ( AWPROT !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWPROT[_this_dot_1] === 0 );
                    @( AWPROT[_this_dot_1] );
                end
                while ( AWPROT[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWPROT[_this_dot_1] === 1 );
                    @( AWPROT[_this_dot_1] );
                end
                while ( AWPROT[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWID === 0 );
                    @( AWID );
                end
                while ( AWID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWID === 1 );
                    @( AWID );
                end
                while ( AWID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWID[_this_dot_1] === 0 );
                    @( AWID[_this_dot_1] );
                end
                while ( AWID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWID[_this_dot_1] === 1 );
                    @( AWID[_this_dot_1] );
                end
                while ( AWID[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWREADY === 0 );
                    @( AWREADY );
                end
                while ( AWREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWREADY === 1 );
                    @( AWREADY );
                end
                while ( AWREADY !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWUSER === 0 );
                    @( AWUSER );
                end
                while ( AWUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWUSER === 1 );
                    @( AWUSER );
                end
                while ( AWUSER !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWUSER[_this_dot_1] === 0 );
                    @( AWUSER[_this_dot_1] );
                end
                while ( AWUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWUSER[_this_dot_1] === 1 );
                    @( AWUSER[_this_dot_1] );
                end
                while ( AWUSER[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARVALID === 0 );
                    @( ARVALID );
                end
                while ( ARVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARVALID === 1 );
                    @( ARVALID );
                end
                while ( ARVALID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARADDR( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARADDR);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARADDR);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARADDR);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARADDR === 0 );
                    @( ARADDR );
                end
                while ( ARADDR !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARADDR === 1 );
                    @( ARADDR );
                end
                while ( ARADDR !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARADDR[_this_dot_1] === 0 );
                    @( ARADDR[_this_dot_1] );
                end
                while ( ARADDR[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARADDR[_this_dot_1] === 1 );
                    @( ARADDR[_this_dot_1] );
                end
                while ( ARADDR[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARLEN( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARLEN);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARLEN);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARLEN);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARLEN === 0 );
                    @( ARLEN );
                end
                while ( ARLEN !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARLEN === 1 );
                    @( ARLEN );
                end
                while ( ARLEN !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARLEN[_this_dot_1] === 0 );
                    @( ARLEN[_this_dot_1] );
                end
                while ( ARLEN[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARLEN[_this_dot_1] === 1 );
                    @( ARLEN[_this_dot_1] );
                end
                while ( ARLEN[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARSIZE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARSIZE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARSIZE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARSIZE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARSIZE === 0 );
                    @( ARSIZE );
                end
                while ( ARSIZE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARSIZE === 1 );
                    @( ARSIZE );
                end
                while ( ARSIZE !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARSIZE[_this_dot_1] === 0 );
                    @( ARSIZE[_this_dot_1] );
                end
                while ( ARSIZE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARSIZE[_this_dot_1] === 1 );
                    @( ARSIZE[_this_dot_1] );
                end
                while ( ARSIZE[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARBURST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARBURST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARBURST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARBURST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARBURST === 0 );
                    @( ARBURST );
                end
                while ( ARBURST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARBURST === 1 );
                    @( ARBURST );
                end
                while ( ARBURST !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARBURST[_this_dot_1] === 0 );
                    @( ARBURST[_this_dot_1] );
                end
                while ( ARBURST[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARBURST[_this_dot_1] === 1 );
                    @( ARBURST[_this_dot_1] );
                end
                while ( ARBURST[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARLOCK( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARLOCK);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARLOCK);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARLOCK);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARLOCK === 0 );
                    @( ARLOCK );
                end
                while ( ARLOCK !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARLOCK === 1 );
                    @( ARLOCK );
                end
                while ( ARLOCK !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARLOCK_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARLOCK[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARLOCK[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARLOCK[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARLOCK[_this_dot_1] === 0 );
                    @( ARLOCK[_this_dot_1] );
                end
                while ( ARLOCK[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARLOCK[_this_dot_1] === 1 );
                    @( ARLOCK[_this_dot_1] );
                end
                while ( ARLOCK[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARCACHE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARCACHE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARCACHE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARCACHE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARCACHE === 0 );
                    @( ARCACHE );
                end
                while ( ARCACHE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARCACHE === 1 );
                    @( ARCACHE );
                end
                while ( ARCACHE !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARCACHE[_this_dot_1] === 0 );
                    @( ARCACHE[_this_dot_1] );
                end
                while ( ARCACHE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARCACHE[_this_dot_1] === 1 );
                    @( ARCACHE[_this_dot_1] );
                end
                while ( ARCACHE[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARPROT( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARPROT);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARPROT);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARPROT);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARPROT === 0 );
                    @( ARPROT );
                end
                while ( ARPROT !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARPROT === 1 );
                    @( ARPROT );
                end
                while ( ARPROT !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARPROT[_this_dot_1] === 0 );
                    @( ARPROT[_this_dot_1] );
                end
                while ( ARPROT[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARPROT[_this_dot_1] === 1 );
                    @( ARPROT[_this_dot_1] );
                end
                while ( ARPROT[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARID === 0 );
                    @( ARID );
                end
                while ( ARID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARID === 1 );
                    @( ARID );
                end
                while ( ARID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARID[_this_dot_1] === 0 );
                    @( ARID[_this_dot_1] );
                end
                while ( ARID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARID[_this_dot_1] === 1 );
                    @( ARID[_this_dot_1] );
                end
                while ( ARID[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARREADY === 0 );
                    @( ARREADY );
                end
                while ( ARREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARREADY === 1 );
                    @( ARREADY );
                end
                while ( ARREADY !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARUSER === 0 );
                    @( ARUSER );
                end
                while ( ARUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARUSER === 1 );
                    @( ARUSER );
                end
                while ( ARUSER !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARUSER[_this_dot_1] === 0 );
                    @( ARUSER[_this_dot_1] );
                end
                while ( ARUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARUSER[_this_dot_1] === 1 );
                    @( ARUSER[_this_dot_1] );
                end
                while ( ARUSER[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RVALID === 0 );
                    @( RVALID );
                end
                while ( RVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RVALID === 1 );
                    @( RVALID );
                end
                while ( RVALID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RLAST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RLAST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RLAST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RLAST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RLAST === 0 );
                    @( RLAST );
                end
                while ( RLAST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RLAST === 1 );
                    @( RLAST );
                end
                while ( RLAST !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RDATA( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RDATA);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RDATA);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RDATA);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RDATA === 0 );
                    @( RDATA );
                end
                while ( RDATA !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RDATA === 1 );
                    @( RDATA );
                end
                while ( RDATA !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RDATA[_this_dot_1] === 0 );
                    @( RDATA[_this_dot_1] );
                end
                while ( RDATA[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RDATA[_this_dot_1] === 1 );
                    @( RDATA[_this_dot_1] );
                end
                while ( RDATA[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RRESP( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RRESP);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RRESP);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RRESP);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RRESP === 0 );
                    @( RRESP );
                end
                while ( RRESP !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RRESP === 1 );
                    @( RRESP );
                end
                while ( RRESP !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RRESP[_this_dot_1] === 0 );
                    @( RRESP[_this_dot_1] );
                end
                while ( RRESP[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RRESP[_this_dot_1] === 1 );
                    @( RRESP[_this_dot_1] );
                end
                while ( RRESP[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RID === 0 );
                    @( RID );
                end
                while ( RID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RID === 1 );
                    @( RID );
                end
                while ( RID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RID[_this_dot_1] === 0 );
                    @( RID[_this_dot_1] );
                end
                while ( RID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RID[_this_dot_1] === 1 );
                    @( RID[_this_dot_1] );
                end
                while ( RID[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RREADY === 0 );
                    @( RREADY );
                end
                while ( RREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RREADY === 1 );
                    @( RREADY );
                end
                while ( RREADY !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RUSER === 0 );
                    @( RUSER );
                end
                while ( RUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RUSER === 1 );
                    @( RUSER );
                end
                while ( RUSER !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RUSER[_this_dot_1] === 0 );
                    @( RUSER[_this_dot_1] );
                end
                while ( RUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RUSER[_this_dot_1] === 1 );
                    @( RUSER[_this_dot_1] );
                end
                while ( RUSER[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WVALID === 0 );
                    @( WVALID );
                end
                while ( WVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WVALID === 1 );
                    @( WVALID );
                end
                while ( WVALID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WLAST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WLAST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WLAST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WLAST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WLAST === 0 );
                    @( WLAST );
                end
                while ( WLAST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WLAST === 1 );
                    @( WLAST );
                end
                while ( WLAST !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WDATA( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WDATA);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WDATA);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WDATA);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WDATA === 0 );
                    @( WDATA );
                end
                while ( WDATA !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WDATA === 1 );
                    @( WDATA );
                end
                while ( WDATA !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WDATA[_this_dot_1] === 0 );
                    @( WDATA[_this_dot_1] );
                end
                while ( WDATA[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WDATA[_this_dot_1] === 1 );
                    @( WDATA[_this_dot_1] );
                end
                while ( WDATA[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WSTRB( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WSTRB);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WSTRB);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WSTRB);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WSTRB === 0 );
                    @( WSTRB );
                end
                while ( WSTRB !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WSTRB === 1 );
                    @( WSTRB );
                end
                while ( WSTRB !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WSTRB_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WSTRB[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WSTRB[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WSTRB[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WSTRB[_this_dot_1] === 0 );
                    @( WSTRB[_this_dot_1] );
                end
                while ( WSTRB[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WSTRB[_this_dot_1] === 1 );
                    @( WSTRB[_this_dot_1] );
                end
                while ( WSTRB[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WID === 0 );
                    @( WID );
                end
                while ( WID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WID === 1 );
                    @( WID );
                end
                while ( WID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WID[_this_dot_1] === 0 );
                    @( WID[_this_dot_1] );
                end
                while ( WID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WID[_this_dot_1] === 1 );
                    @( WID[_this_dot_1] );
                end
                while ( WID[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WREADY === 0 );
                    @( WREADY );
                end
                while ( WREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WREADY === 1 );
                    @( WREADY );
                end
                while ( WREADY !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WUSER === 0 );
                    @( WUSER );
                end
                while ( WUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WUSER === 1 );
                    @( WUSER );
                end
                while ( WUSER !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WUSER[_this_dot_1] === 0 );
                    @( WUSER[_this_dot_1] );
                end
                while ( WUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WUSER[_this_dot_1] === 1 );
                    @( WUSER[_this_dot_1] );
                end
                while ( WUSER[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BVALID === 0 );
                    @( BVALID );
                end
                while ( BVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BVALID === 1 );
                    @( BVALID );
                end
                while ( BVALID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BRESP( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BRESP);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BRESP);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BRESP);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BRESP === 0 );
                    @( BRESP );
                end
                while ( BRESP !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BRESP === 1 );
                    @( BRESP );
                end
                while ( BRESP !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BRESP[_this_dot_1] === 0 );
                    @( BRESP[_this_dot_1] );
                end
                while ( BRESP[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BRESP[_this_dot_1] === 1 );
                    @( BRESP[_this_dot_1] );
                end
                while ( BRESP[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BID === 0 );
                    @( BID );
                end
                while ( BID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BID === 1 );
                    @( BID );
                end
                while ( BID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BID[_this_dot_1] === 0 );
                    @( BID[_this_dot_1] );
                end
                while ( BID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BID[_this_dot_1] === 1 );
                    @( BID[_this_dot_1] );
                end
                while ( BID[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BREADY === 0 );
                    @( BREADY );
                end
                while ( BREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BREADY === 1 );
                    @( BREADY );
                end
                while ( BREADY !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BUSER === 0 );
                    @( BUSER );
                end
                while ( BUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BUSER === 1 );
                    @( BUSER );
                end
                while ( BUSER !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BUSER[_this_dot_1] === 0 );
                    @( BUSER[_this_dot_1] );
                end
                while ( BUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BUSER[_this_dot_1] === 1 );
                    @( BUSER[_this_dot_1] );
                end
                while ( BUSER[_this_dot_1] !== 0 );
            end
        end
    endtask

    //------------------------------------------------------------------------------
    // Tasks/functions to set/get wires
    //------------------------------------------------------------------------------

    task automatic do_set_ACLK( logic ACLK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ACLK = ACLK_param;
        else
            m_ACLK <= ACLK_param;
    endtask

    function automatic logic do_get_ACLK(  );
        return ACLK;
    endfunction

    task automatic do_set_ARESETn( logic ARESETn_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARESETn = ARESETn_param;
        else
            m_ARESETn <= ARESETn_param;
    endtask

    function automatic logic do_get_ARESETn(  );
        return ARESETn;
    endfunction

    task automatic do_set_AWVALID( logic AWVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWVALID = AWVALID_param;
        else
            m_AWVALID <= AWVALID_param;
    endtask

    function automatic logic do_get_AWVALID(  );
        return AWVALID;
    endfunction

    task automatic do_set_AWADDR( logic [((AXI_ADDRESS_WIDTH) - 1):0]  AWADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWADDR = AWADDR_param;
        else
            m_AWADDR <= AWADDR_param;
    endtask

    task automatic do_set_AWADDR_index1( int _this_dot_1, logic  AWADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWADDR[_this_dot_1] = AWADDR_param;
        else
            m_AWADDR[_this_dot_1] <= AWADDR_param;
    endtask

    function automatic logic [((AXI_ADDRESS_WIDTH) - 1):0]   do_get_AWADDR(  );
        return AWADDR;
    endfunction

    function automatic logic   do_get_AWADDR_index1( int _this_dot_1 );
        return AWADDR[_this_dot_1];
    endfunction

    task automatic do_set_AWLEN( logic [3:0] AWLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWLEN = AWLEN_param;
        else
            m_AWLEN <= AWLEN_param;
    endtask

    task automatic do_set_AWLEN_index1( int _this_dot_1, logic  AWLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWLEN[_this_dot_1] = AWLEN_param;
        else
            m_AWLEN[_this_dot_1] <= AWLEN_param;
    endtask

    function automatic logic [3:0]  do_get_AWLEN(  );
        return AWLEN;
    endfunction

    function automatic logic   do_get_AWLEN_index1( int _this_dot_1 );
        return AWLEN[_this_dot_1];
    endfunction

    task automatic do_set_AWSIZE( logic [2:0] AWSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWSIZE = AWSIZE_param;
        else
            m_AWSIZE <= AWSIZE_param;
    endtask

    task automatic do_set_AWSIZE_index1( int _this_dot_1, logic  AWSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWSIZE[_this_dot_1] = AWSIZE_param;
        else
            m_AWSIZE[_this_dot_1] <= AWSIZE_param;
    endtask

    function automatic logic [2:0]  do_get_AWSIZE(  );
        return AWSIZE;
    endfunction

    function automatic logic   do_get_AWSIZE_index1( int _this_dot_1 );
        return AWSIZE[_this_dot_1];
    endfunction

    task automatic do_set_AWBURST( logic [1:0] AWBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWBURST = AWBURST_param;
        else
            m_AWBURST <= AWBURST_param;
    endtask

    task automatic do_set_AWBURST_index1( int _this_dot_1, logic  AWBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWBURST[_this_dot_1] = AWBURST_param;
        else
            m_AWBURST[_this_dot_1] <= AWBURST_param;
    endtask

    function automatic logic [1:0]  do_get_AWBURST(  );
        return AWBURST;
    endfunction

    function automatic logic   do_get_AWBURST_index1( int _this_dot_1 );
        return AWBURST[_this_dot_1];
    endfunction

    task automatic do_set_AWLOCK( logic [1:0] AWLOCK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWLOCK = AWLOCK_param;
        else
            m_AWLOCK <= AWLOCK_param;
    endtask

    task automatic do_set_AWLOCK_index1( int _this_dot_1, logic  AWLOCK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWLOCK[_this_dot_1] = AWLOCK_param;
        else
            m_AWLOCK[_this_dot_1] <= AWLOCK_param;
    endtask

    function automatic logic [1:0]  do_get_AWLOCK(  );
        return AWLOCK;
    endfunction

    function automatic logic   do_get_AWLOCK_index1( int _this_dot_1 );
        return AWLOCK[_this_dot_1];
    endfunction

    task automatic do_set_AWCACHE( logic [3:0] AWCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWCACHE = AWCACHE_param;
        else
            m_AWCACHE <= AWCACHE_param;
    endtask

    task automatic do_set_AWCACHE_index1( int _this_dot_1, logic  AWCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWCACHE[_this_dot_1] = AWCACHE_param;
        else
            m_AWCACHE[_this_dot_1] <= AWCACHE_param;
    endtask

    function automatic logic [3:0]  do_get_AWCACHE(  );
        return AWCACHE;
    endfunction

    function automatic logic   do_get_AWCACHE_index1( int _this_dot_1 );
        return AWCACHE[_this_dot_1];
    endfunction

    task automatic do_set_AWPROT( logic [2:0] AWPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWPROT = AWPROT_param;
        else
            m_AWPROT <= AWPROT_param;
    endtask

    task automatic do_set_AWPROT_index1( int _this_dot_1, logic  AWPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWPROT[_this_dot_1] = AWPROT_param;
        else
            m_AWPROT[_this_dot_1] <= AWPROT_param;
    endtask

    function automatic logic [2:0]  do_get_AWPROT(  );
        return AWPROT;
    endfunction

    function automatic logic   do_get_AWPROT_index1( int _this_dot_1 );
        return AWPROT[_this_dot_1];
    endfunction

    task automatic do_set_AWID( logic [((AXI_ID_WIDTH) - 1):0]  AWID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWID = AWID_param;
        else
            m_AWID <= AWID_param;
    endtask

    task automatic do_set_AWID_index1( int _this_dot_1, logic  AWID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWID[_this_dot_1] = AWID_param;
        else
            m_AWID[_this_dot_1] <= AWID_param;
    endtask

    function automatic logic [((AXI_ID_WIDTH) - 1):0]   do_get_AWID(  );
        return AWID;
    endfunction

    function automatic logic   do_get_AWID_index1( int _this_dot_1 );
        return AWID[_this_dot_1];
    endfunction

    task automatic do_set_AWREADY( logic AWREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWREADY = AWREADY_param;
        else
            m_AWREADY <= AWREADY_param;
    endtask

    function automatic logic do_get_AWREADY(  );
        return AWREADY;
    endfunction

    task automatic do_set_AWUSER( logic [7:0] AWUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWUSER = AWUSER_param;
        else
            m_AWUSER <= AWUSER_param;
    endtask

    task automatic do_set_AWUSER_index1( int _this_dot_1, logic  AWUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWUSER[_this_dot_1] = AWUSER_param;
        else
            m_AWUSER[_this_dot_1] <= AWUSER_param;
    endtask

    function automatic logic [7:0]  do_get_AWUSER(  );
        return AWUSER;
    endfunction

    function automatic logic   do_get_AWUSER_index1( int _this_dot_1 );
        return AWUSER[_this_dot_1];
    endfunction

    task automatic do_set_ARVALID( logic ARVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARVALID = ARVALID_param;
        else
            m_ARVALID <= ARVALID_param;
    endtask

    function automatic logic do_get_ARVALID(  );
        return ARVALID;
    endfunction

    task automatic do_set_ARADDR( logic [((AXI_ADDRESS_WIDTH) - 1):0]  ARADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARADDR = ARADDR_param;
        else
            m_ARADDR <= ARADDR_param;
    endtask

    task automatic do_set_ARADDR_index1( int _this_dot_1, logic  ARADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARADDR[_this_dot_1] = ARADDR_param;
        else
            m_ARADDR[_this_dot_1] <= ARADDR_param;
    endtask

    function automatic logic [((AXI_ADDRESS_WIDTH) - 1):0]   do_get_ARADDR(  );
        return ARADDR;
    endfunction

    function automatic logic   do_get_ARADDR_index1( int _this_dot_1 );
        return ARADDR[_this_dot_1];
    endfunction

    task automatic do_set_ARLEN( logic [3:0] ARLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARLEN = ARLEN_param;
        else
            m_ARLEN <= ARLEN_param;
    endtask

    task automatic do_set_ARLEN_index1( int _this_dot_1, logic  ARLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARLEN[_this_dot_1] = ARLEN_param;
        else
            m_ARLEN[_this_dot_1] <= ARLEN_param;
    endtask

    function automatic logic [3:0]  do_get_ARLEN(  );
        return ARLEN;
    endfunction

    function automatic logic   do_get_ARLEN_index1( int _this_dot_1 );
        return ARLEN[_this_dot_1];
    endfunction

    task automatic do_set_ARSIZE( logic [2:0] ARSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARSIZE = ARSIZE_param;
        else
            m_ARSIZE <= ARSIZE_param;
    endtask

    task automatic do_set_ARSIZE_index1( int _this_dot_1, logic  ARSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARSIZE[_this_dot_1] = ARSIZE_param;
        else
            m_ARSIZE[_this_dot_1] <= ARSIZE_param;
    endtask

    function automatic logic [2:0]  do_get_ARSIZE(  );
        return ARSIZE;
    endfunction

    function automatic logic   do_get_ARSIZE_index1( int _this_dot_1 );
        return ARSIZE[_this_dot_1];
    endfunction

    task automatic do_set_ARBURST( logic [1:0] ARBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARBURST = ARBURST_param;
        else
            m_ARBURST <= ARBURST_param;
    endtask

    task automatic do_set_ARBURST_index1( int _this_dot_1, logic  ARBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARBURST[_this_dot_1] = ARBURST_param;
        else
            m_ARBURST[_this_dot_1] <= ARBURST_param;
    endtask

    function automatic logic [1:0]  do_get_ARBURST(  );
        return ARBURST;
    endfunction

    function automatic logic   do_get_ARBURST_index1( int _this_dot_1 );
        return ARBURST[_this_dot_1];
    endfunction

    task automatic do_set_ARLOCK( logic [1:0] ARLOCK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARLOCK = ARLOCK_param;
        else
            m_ARLOCK <= ARLOCK_param;
    endtask

    task automatic do_set_ARLOCK_index1( int _this_dot_1, logic  ARLOCK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARLOCK[_this_dot_1] = ARLOCK_param;
        else
            m_ARLOCK[_this_dot_1] <= ARLOCK_param;
    endtask

    function automatic logic [1:0]  do_get_ARLOCK(  );
        return ARLOCK;
    endfunction

    function automatic logic   do_get_ARLOCK_index1( int _this_dot_1 );
        return ARLOCK[_this_dot_1];
    endfunction

    task automatic do_set_ARCACHE( logic [3:0] ARCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARCACHE = ARCACHE_param;
        else
            m_ARCACHE <= ARCACHE_param;
    endtask

    task automatic do_set_ARCACHE_index1( int _this_dot_1, logic  ARCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARCACHE[_this_dot_1] = ARCACHE_param;
        else
            m_ARCACHE[_this_dot_1] <= ARCACHE_param;
    endtask

    function automatic logic [3:0]  do_get_ARCACHE(  );
        return ARCACHE;
    endfunction

    function automatic logic   do_get_ARCACHE_index1( int _this_dot_1 );
        return ARCACHE[_this_dot_1];
    endfunction

    task automatic do_set_ARPROT( logic [2:0] ARPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARPROT = ARPROT_param;
        else
            m_ARPROT <= ARPROT_param;
    endtask

    task automatic do_set_ARPROT_index1( int _this_dot_1, logic  ARPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARPROT[_this_dot_1] = ARPROT_param;
        else
            m_ARPROT[_this_dot_1] <= ARPROT_param;
    endtask

    function automatic logic [2:0]  do_get_ARPROT(  );
        return ARPROT;
    endfunction

    function automatic logic   do_get_ARPROT_index1( int _this_dot_1 );
        return ARPROT[_this_dot_1];
    endfunction

    task automatic do_set_ARID( logic [((AXI_ID_WIDTH) - 1):0]  ARID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARID = ARID_param;
        else
            m_ARID <= ARID_param;
    endtask

    task automatic do_set_ARID_index1( int _this_dot_1, logic  ARID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARID[_this_dot_1] = ARID_param;
        else
            m_ARID[_this_dot_1] <= ARID_param;
    endtask

    function automatic logic [((AXI_ID_WIDTH) - 1):0]   do_get_ARID(  );
        return ARID;
    endfunction

    function automatic logic   do_get_ARID_index1( int _this_dot_1 );
        return ARID[_this_dot_1];
    endfunction

    task automatic do_set_ARREADY( logic ARREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARREADY = ARREADY_param;
        else
            m_ARREADY <= ARREADY_param;
    endtask

    function automatic logic do_get_ARREADY(  );
        return ARREADY;
    endfunction

    task automatic do_set_ARUSER( logic [7:0] ARUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARUSER = ARUSER_param;
        else
            m_ARUSER <= ARUSER_param;
    endtask

    task automatic do_set_ARUSER_index1( int _this_dot_1, logic  ARUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARUSER[_this_dot_1] = ARUSER_param;
        else
            m_ARUSER[_this_dot_1] <= ARUSER_param;
    endtask

    function automatic logic [7:0]  do_get_ARUSER(  );
        return ARUSER;
    endfunction

    function automatic logic   do_get_ARUSER_index1( int _this_dot_1 );
        return ARUSER[_this_dot_1];
    endfunction

    task automatic do_set_RVALID( logic RVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RVALID = RVALID_param;
        else
            m_RVALID <= RVALID_param;
    endtask

    function automatic logic do_get_RVALID(  );
        return RVALID;
    endfunction

    task automatic do_set_RLAST( logic RLAST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RLAST = RLAST_param;
        else
            m_RLAST <= RLAST_param;
    endtask

    function automatic logic do_get_RLAST(  );
        return RLAST;
    endfunction

    task automatic do_set_RDATA( logic [((AXI_RDATA_WIDTH) - 1):0]  RDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RDATA = RDATA_param;
        else
            m_RDATA <= RDATA_param;
    endtask

    task automatic do_set_RDATA_index1( int _this_dot_1, logic  RDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RDATA[_this_dot_1] = RDATA_param;
        else
            m_RDATA[_this_dot_1] <= RDATA_param;
    endtask

    function automatic logic [((AXI_RDATA_WIDTH) - 1):0]   do_get_RDATA(  );
        return RDATA;
    endfunction

    function automatic logic   do_get_RDATA_index1( int _this_dot_1 );
        return RDATA[_this_dot_1];
    endfunction

    task automatic do_set_RRESP( logic [1:0] RRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RRESP = RRESP_param;
        else
            m_RRESP <= RRESP_param;
    endtask

    task automatic do_set_RRESP_index1( int _this_dot_1, logic  RRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RRESP[_this_dot_1] = RRESP_param;
        else
            m_RRESP[_this_dot_1] <= RRESP_param;
    endtask

    function automatic logic [1:0]  do_get_RRESP(  );
        return RRESP;
    endfunction

    function automatic logic   do_get_RRESP_index1( int _this_dot_1 );
        return RRESP[_this_dot_1];
    endfunction

    task automatic do_set_RID( logic [((AXI_ID_WIDTH) - 1):0]  RID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RID = RID_param;
        else
            m_RID <= RID_param;
    endtask

    task automatic do_set_RID_index1( int _this_dot_1, logic  RID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RID[_this_dot_1] = RID_param;
        else
            m_RID[_this_dot_1] <= RID_param;
    endtask

    function automatic logic [((AXI_ID_WIDTH) - 1):0]   do_get_RID(  );
        return RID;
    endfunction

    function automatic logic   do_get_RID_index1( int _this_dot_1 );
        return RID[_this_dot_1];
    endfunction

    task automatic do_set_RREADY( logic RREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RREADY = RREADY_param;
        else
            m_RREADY <= RREADY_param;
    endtask

    function automatic logic do_get_RREADY(  );
        return RREADY;
    endfunction

    task automatic do_set_RUSER( logic [7:0] RUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RUSER = RUSER_param;
        else
            m_RUSER <= RUSER_param;
    endtask

    task automatic do_set_RUSER_index1( int _this_dot_1, logic  RUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RUSER[_this_dot_1] = RUSER_param;
        else
            m_RUSER[_this_dot_1] <= RUSER_param;
    endtask

    function automatic logic [7:0]  do_get_RUSER(  );
        return RUSER;
    endfunction

    function automatic logic   do_get_RUSER_index1( int _this_dot_1 );
        return RUSER[_this_dot_1];
    endfunction

    task automatic do_set_WVALID( logic WVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WVALID = WVALID_param;
        else
            m_WVALID <= WVALID_param;
    endtask

    function automatic logic do_get_WVALID(  );
        return WVALID;
    endfunction

    task automatic do_set_WLAST( logic WLAST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WLAST = WLAST_param;
        else
            m_WLAST <= WLAST_param;
    endtask

    function automatic logic do_get_WLAST(  );
        return WLAST;
    endfunction

    task automatic do_set_WDATA( logic [((AXI_WDATA_WIDTH) - 1):0]  WDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WDATA = WDATA_param;
        else
            m_WDATA <= WDATA_param;
    endtask

    task automatic do_set_WDATA_index1( int _this_dot_1, logic  WDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WDATA[_this_dot_1] = WDATA_param;
        else
            m_WDATA[_this_dot_1] <= WDATA_param;
    endtask

    function automatic logic [((AXI_WDATA_WIDTH) - 1):0]   do_get_WDATA(  );
        return WDATA;
    endfunction

    function automatic logic   do_get_WDATA_index1( int _this_dot_1 );
        return WDATA[_this_dot_1];
    endfunction

    task automatic do_set_WSTRB( logic [(((AXI_WDATA_WIDTH / 8)) - 1):0]  WSTRB_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WSTRB = WSTRB_param;
        else
            m_WSTRB <= WSTRB_param;
    endtask

    task automatic do_set_WSTRB_index1( int _this_dot_1, logic  WSTRB_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WSTRB[_this_dot_1] = WSTRB_param;
        else
            m_WSTRB[_this_dot_1] <= WSTRB_param;
    endtask

    function automatic logic [(((AXI_WDATA_WIDTH / 8)) - 1):0]   do_get_WSTRB(  );
        return WSTRB;
    endfunction

    function automatic logic   do_get_WSTRB_index1( int _this_dot_1 );
        return WSTRB[_this_dot_1];
    endfunction

    task automatic do_set_WID( logic [((AXI_ID_WIDTH) - 1):0]  WID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WID = WID_param;
        else
            m_WID <= WID_param;
    endtask

    task automatic do_set_WID_index1( int _this_dot_1, logic  WID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WID[_this_dot_1] = WID_param;
        else
            m_WID[_this_dot_1] <= WID_param;
    endtask

    function automatic logic [((AXI_ID_WIDTH) - 1):0]   do_get_WID(  );
        return WID;
    endfunction

    function automatic logic   do_get_WID_index1( int _this_dot_1 );
        return WID[_this_dot_1];
    endfunction

    task automatic do_set_WREADY( logic WREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WREADY = WREADY_param;
        else
            m_WREADY <= WREADY_param;
    endtask

    function automatic logic do_get_WREADY(  );
        return WREADY;
    endfunction

    task automatic do_set_WUSER( logic [7:0] WUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WUSER = WUSER_param;
        else
            m_WUSER <= WUSER_param;
    endtask

    task automatic do_set_WUSER_index1( int _this_dot_1, logic  WUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WUSER[_this_dot_1] = WUSER_param;
        else
            m_WUSER[_this_dot_1] <= WUSER_param;
    endtask

    function automatic logic [7:0]  do_get_WUSER(  );
        return WUSER;
    endfunction

    function automatic logic   do_get_WUSER_index1( int _this_dot_1 );
        return WUSER[_this_dot_1];
    endfunction

    task automatic do_set_BVALID( logic BVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BVALID = BVALID_param;
        else
            m_BVALID <= BVALID_param;
    endtask

    function automatic logic do_get_BVALID(  );
        return BVALID;
    endfunction

    task automatic do_set_BRESP( logic [1:0] BRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BRESP = BRESP_param;
        else
            m_BRESP <= BRESP_param;
    endtask

    task automatic do_set_BRESP_index1( int _this_dot_1, logic  BRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BRESP[_this_dot_1] = BRESP_param;
        else
            m_BRESP[_this_dot_1] <= BRESP_param;
    endtask

    function automatic logic [1:0]  do_get_BRESP(  );
        return BRESP;
    endfunction

    function automatic logic   do_get_BRESP_index1( int _this_dot_1 );
        return BRESP[_this_dot_1];
    endfunction

    task automatic do_set_BID( logic [((AXI_ID_WIDTH) - 1):0]  BID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BID = BID_param;
        else
            m_BID <= BID_param;
    endtask

    task automatic do_set_BID_index1( int _this_dot_1, logic  BID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BID[_this_dot_1] = BID_param;
        else
            m_BID[_this_dot_1] <= BID_param;
    endtask

    function automatic logic [((AXI_ID_WIDTH) - 1):0]   do_get_BID(  );
        return BID;
    endfunction

    function automatic logic   do_get_BID_index1( int _this_dot_1 );
        return BID[_this_dot_1];
    endfunction

    task automatic do_set_BREADY( logic BREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BREADY = BREADY_param;
        else
            m_BREADY <= BREADY_param;
    endtask

    function automatic logic do_get_BREADY(  );
        return BREADY;
    endfunction

    task automatic do_set_BUSER( logic [7:0] BUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BUSER = BUSER_param;
        else
            m_BUSER <= BUSER_param;
    endtask

    task automatic do_set_BUSER_index1( int _this_dot_1, logic  BUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BUSER[_this_dot_1] = BUSER_param;
        else
            m_BUSER[_this_dot_1] <= BUSER_param;
    endtask

    function automatic logic [7:0]  do_get_BUSER(  );
        return BUSER;
    endfunction

    function automatic logic   do_get_BUSER_index1( int _this_dot_1 );
        return BUSER[_this_dot_1];
    endfunction

    //------------------------------------------------------------------------------
    // Tasks to wait for a change to a global variable with read access
    //------------------------------------------------------------------------------

    task automatic do_wait_for_config_clk_init_value(  );
        begin
            bit _temp_config_clk_init_value;
            _temp_config_clk_init_value = config_clk_init_value;
            wait( _temp_config_clk_init_value != config_clk_init_value );
        end
    endtask

    task automatic do_wait_for_config_clk_phase_shift(  );
        begin
            int _temp_config_clk_phase_shift;
            _temp_config_clk_phase_shift = config_clk_phase_shift;
            wait( _temp_config_clk_phase_shift != config_clk_phase_shift );
        end
    endtask

    task automatic do_wait_for_config_clk_1st_time(  );
        begin
            int _temp_config_clk_1st_time;
            _temp_config_clk_1st_time = config_clk_1st_time;
            wait( _temp_config_clk_1st_time != config_clk_1st_time );
        end
    endtask

    task automatic do_wait_for_config_clk_2nd_time(  );
        begin
            int _temp_config_clk_2nd_time;
            _temp_config_clk_2nd_time = config_clk_2nd_time;
            wait( _temp_config_clk_2nd_time != config_clk_2nd_time );
        end
    endtask

    task automatic do_wait_for_config_setup_time(  );
        begin
            int _temp_config_setup_time;
            _temp_config_setup_time = config_setup_time;
            wait( _temp_config_setup_time != config_setup_time );
        end
    endtask

    task automatic do_wait_for_config_hold_time(  );
        begin
            int _temp_config_hold_time;
            _temp_config_hold_time = config_hold_time;
            wait( _temp_config_hold_time != config_hold_time );
        end
    endtask

    task automatic do_wait_for_config_max_transaction_time_factor(  );
        begin
            int unsigned _temp_config_max_transaction_time_factor;
            _temp_config_max_transaction_time_factor = config_max_transaction_time_factor;
            wait( _temp_config_max_transaction_time_factor != config_max_transaction_time_factor );
        end
    endtask

    task automatic do_wait_for_config_timeout_max_data_transfer(  );
        begin
            int _temp_config_timeout_max_data_transfer;
            _temp_config_timeout_max_data_transfer = config_timeout_max_data_transfer;
            wait( _temp_config_timeout_max_data_transfer != config_timeout_max_data_transfer );
        end
    endtask

    task automatic do_wait_for_config_burst_timeout_factor(  );
        begin
            int unsigned _temp_config_burst_timeout_factor;
            _temp_config_burst_timeout_factor = config_burst_timeout_factor;
            wait( _temp_config_burst_timeout_factor != config_burst_timeout_factor );
        end
    endtask

    task automatic do_wait_for_config_max_latency_AWVALID_assertion_to_AWREADY(  );
        begin
            int unsigned _temp_config_max_latency_AWVALID_assertion_to_AWREADY;
            _temp_config_max_latency_AWVALID_assertion_to_AWREADY = config_max_latency_AWVALID_assertion_to_AWREADY;
            wait( _temp_config_max_latency_AWVALID_assertion_to_AWREADY != config_max_latency_AWVALID_assertion_to_AWREADY );
        end
    endtask

    task automatic do_wait_for_config_max_latency_ARVALID_assertion_to_ARREADY(  );
        begin
            int unsigned _temp_config_max_latency_ARVALID_assertion_to_ARREADY;
            _temp_config_max_latency_ARVALID_assertion_to_ARREADY = config_max_latency_ARVALID_assertion_to_ARREADY;
            wait( _temp_config_max_latency_ARVALID_assertion_to_ARREADY != config_max_latency_ARVALID_assertion_to_ARREADY );
        end
    endtask

    task automatic do_wait_for_config_max_latency_RVALID_assertion_to_RREADY(  );
        begin
            int unsigned _temp_config_max_latency_RVALID_assertion_to_RREADY;
            _temp_config_max_latency_RVALID_assertion_to_RREADY = config_max_latency_RVALID_assertion_to_RREADY;
            wait( _temp_config_max_latency_RVALID_assertion_to_RREADY != config_max_latency_RVALID_assertion_to_RREADY );
        end
    endtask

    task automatic do_wait_for_config_max_latency_BVALID_assertion_to_BREADY(  );
        begin
            int unsigned _temp_config_max_latency_BVALID_assertion_to_BREADY;
            _temp_config_max_latency_BVALID_assertion_to_BREADY = config_max_latency_BVALID_assertion_to_BREADY;
            wait( _temp_config_max_latency_BVALID_assertion_to_BREADY != config_max_latency_BVALID_assertion_to_BREADY );
        end
    endtask

    task automatic do_wait_for_config_max_latency_WVALID_assertion_to_WREADY(  );
        begin
            int unsigned _temp_config_max_latency_WVALID_assertion_to_WREADY;
            _temp_config_max_latency_WVALID_assertion_to_WREADY = config_max_latency_WVALID_assertion_to_WREADY;
            wait( _temp_config_max_latency_WVALID_assertion_to_WREADY != config_max_latency_WVALID_assertion_to_WREADY );
        end
    endtask

    task automatic do_wait_for_config_write_ctrl_first_ratio(  );
        begin
            int _temp_config_write_ctrl_first_ratio;
            _temp_config_write_ctrl_first_ratio = config_write_ctrl_first_ratio;
            wait( _temp_config_write_ctrl_first_ratio != config_write_ctrl_first_ratio );
        end
    endtask

    task automatic do_wait_for_config_write_data_first_ratio(  );
        begin
            int _temp_config_write_data_first_ratio;
            _temp_config_write_data_first_ratio = config_write_data_first_ratio;
            wait( _temp_config_write_data_first_ratio != config_write_data_first_ratio );
        end
    endtask

    task automatic do_wait_for_config_write_ctrl_to_data_mintime(  );
        begin
            int unsigned _temp_config_write_ctrl_to_data_mintime;
            _temp_config_write_ctrl_to_data_mintime = config_write_ctrl_to_data_mintime;
            wait( _temp_config_write_ctrl_to_data_mintime != config_write_ctrl_to_data_mintime );
        end
    endtask

    task automatic do_wait_for_config_write_data_to_ctrl_mintime(  );
        begin
            int unsigned _temp_config_write_data_to_ctrl_mintime;
            _temp_config_write_data_to_ctrl_mintime = config_write_data_to_ctrl_mintime;
            wait( _temp_config_write_data_to_ctrl_mintime != config_write_data_to_ctrl_mintime );
        end
    endtask

    task automatic do_wait_for_config_master_write_delay(  );
        begin
            bit _temp_config_master_write_delay;
            _temp_config_master_write_delay = config_master_write_delay;
            wait( _temp_config_master_write_delay != config_master_write_delay );
        end
    endtask

    task automatic do_wait_for_config_reset_low_clocks(  );
        begin
            int _temp_config_reset_low_clocks;
            _temp_config_reset_low_clocks = config_reset_low_clocks;
            wait( _temp_config_reset_low_clocks != config_reset_low_clocks );
        end
    endtask

    task automatic do_wait_for_config_reset_hold_time(  );
        begin
            int _temp_config_reset_hold_time;
            _temp_config_reset_hold_time = config_reset_hold_time;
            wait( _temp_config_reset_hold_time != config_reset_hold_time );
        end
    endtask

    task automatic do_wait_for_config_protect_ready(  );
        begin
            bit _temp_config_protect_ready;
            _temp_config_protect_ready = config_protect_ready;
            wait( _temp_config_protect_ready != config_protect_ready );
        end
    endtask

    task automatic do_wait_for_config_enable_user_sideband(  );
        begin
            bit _temp_config_enable_user_sideband;
            _temp_config_enable_user_sideband = config_enable_user_sideband;
            wait( _temp_config_enable_user_sideband != config_enable_user_sideband );
        end
    endtask

    task automatic do_wait_for_config_extended_length_enable(  );
        begin
            bit _temp_config_extended_length_enable;
            _temp_config_extended_length_enable = config_extended_length_enable;
            wait( _temp_config_extended_length_enable != config_extended_length_enable );
        end
    endtask

    task automatic do_wait_for_config_enable_burst_reserved_value(  );
        begin
            bit _temp_config_enable_burst_reserved_value;
            _temp_config_enable_burst_reserved_value = config_enable_burst_reserved_value;
            wait( _temp_config_enable_burst_reserved_value != config_enable_burst_reserved_value );
        end
    endtask

    task automatic do_wait_for_config_enable_lock_reserved_value(  );
        begin
            bit _temp_config_enable_lock_reserved_value;
            _temp_config_enable_lock_reserved_value = config_enable_lock_reserved_value;
            wait( _temp_config_enable_lock_reserved_value != config_enable_lock_reserved_value );
        end
    endtask

    task automatic do_wait_for_config_enable_cache_reserved_value(  );
        begin
            bit _temp_config_enable_cache_reserved_value;
            _temp_config_enable_cache_reserved_value = config_enable_cache_reserved_value;
            wait( _temp_config_enable_cache_reserved_value != config_enable_cache_reserved_value );
        end
    endtask

    task automatic do_wait_for_config_enable_all_assertions(  );
        begin
            bit _temp_config_enable_all_assertions;
            _temp_config_enable_all_assertions = config_enable_all_assertions;
            wait( _temp_config_enable_all_assertions != config_enable_all_assertions );
        end
    endtask

    task automatic do_wait_for_config_enable_assertion(  );
        begin
            bit [255:0] _temp_config_enable_assertion;
            _temp_config_enable_assertion = config_enable_assertion;
            wait( _temp_config_enable_assertion != config_enable_assertion );
        end
    endtask

    task automatic do_wait_for_config_enable_assertion_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_enable_assertion;
            _temp_config_enable_assertion = config_enable_assertion[_this_dot_1];
            wait( _temp_config_enable_assertion != config_enable_assertion[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_enable_error(  );
        begin
            bit [255:0] _temp_config_enable_error;
            _temp_config_enable_error = config_enable_error;
            wait( _temp_config_enable_error != config_enable_error );
        end
    endtask

    task automatic do_wait_for_config_enable_error_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_enable_error;
            _temp_config_enable_error = config_enable_error[_this_dot_1];
            wait( _temp_config_enable_error != config_enable_error[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_enable_errors(  );
        begin
            bit _temp_config_enable_errors;
            _temp_config_enable_errors = config_enable_errors;
            wait( _temp_config_enable_errors != config_enable_errors );
        end
    endtask

    task automatic do_wait_for_config_enable_all_assertion_errors(  );
        begin
            bit _temp_config_enable_all_assertion_errors;
            _temp_config_enable_all_assertion_errors = config_enable_all_assertion_errors;
            wait( _temp_config_enable_all_assertion_errors != config_enable_all_assertion_errors );
        end
    endtask

    task automatic do_wait_for_config_abstraction_level(  );
        begin
            axi_abstraction_level_e _temp_config_abstraction_level;
            _temp_config_abstraction_level = config_abstraction_level;
            wait( _temp_config_abstraction_level != config_abstraction_level );
        end
    endtask

    task automatic do_wait_for_config_slave_start_addr(  );
        begin
            bit [((AXI_ADDRESS_WIDTH) - 1):0]  _temp_config_slave_start_addr;
            _temp_config_slave_start_addr = config_slave_start_addr;
            wait( _temp_config_slave_start_addr != config_slave_start_addr );
        end
    endtask

    task automatic do_wait_for_config_slave_start_addr_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_slave_start_addr;
            _temp_config_slave_start_addr = config_slave_start_addr[_this_dot_1];
            wait( _temp_config_slave_start_addr != config_slave_start_addr[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_slave_end_addr(  );
        begin
            bit [((AXI_ADDRESS_WIDTH) - 1):0]  _temp_config_slave_end_addr;
            _temp_config_slave_end_addr = config_slave_end_addr;
            wait( _temp_config_slave_end_addr != config_slave_end_addr );
        end
    endtask

    task automatic do_wait_for_config_slave_end_addr_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_slave_end_addr;
            _temp_config_slave_end_addr = config_slave_end_addr[_this_dot_1];
            wait( _temp_config_slave_end_addr != config_slave_end_addr[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_enable_slave_addr_range_in_bfm(  );
        begin
            bit _temp_config_enable_slave_addr_range_in_bfm;
            _temp_config_enable_slave_addr_range_in_bfm = config_enable_slave_addr_range_in_bfm;
            wait( _temp_config_enable_slave_addr_range_in_bfm != config_enable_slave_addr_range_in_bfm );
        end
    endtask

    task automatic do_wait_for_config_read_data_reordering_depth(  );
        begin
            int unsigned _temp_config_read_data_reordering_depth;
            _temp_config_read_data_reordering_depth = config_read_data_reordering_depth;
            wait( _temp_config_read_data_reordering_depth != config_read_data_reordering_depth );
        end
    endtask

    task automatic do_wait_for_config_enable_read_data_reordering_depth_in_bfm(  );
        begin
            bit _temp_config_enable_read_data_reordering_depth_in_bfm;
            _temp_config_enable_read_data_reordering_depth_in_bfm = config_enable_read_data_reordering_depth_in_bfm;
            wait( _temp_config_enable_read_data_reordering_depth_in_bfm != config_enable_read_data_reordering_depth_in_bfm );
        end
    endtask

    task automatic do_wait_for_config_awid_wid_mismatch(  );
        begin
            bit _temp_config_awid_wid_mismatch;
            _temp_config_awid_wid_mismatch = config_awid_wid_mismatch;
            wait( _temp_config_awid_wid_mismatch != config_awid_wid_mismatch );
        end
    endtask

    task automatic do_wait_for_config_length_last_mismatch_error(  );
        begin
            bit _temp_config_length_last_mismatch_error;
            _temp_config_length_last_mismatch_error = config_length_last_mismatch_error;
            wait( _temp_config_length_last_mismatch_error != config_length_last_mismatch_error );
        end
    endtask

    task automatic do_wait_for_config_master_error_position(  );
        begin
            axi_error_e _temp_config_master_error_position;
            _temp_config_master_error_position = config_master_error_position;
            wait( _temp_config_master_error_position != config_master_error_position );
        end
    endtask

    task automatic do_wait_for_dummy_var(  );
        begin
            axi_assertion_type_e _temp_dummy_var;
            _temp_dummy_var = dummy_var;
            wait( _temp_dummy_var != dummy_var );
        end
    endtask

    task automatic do_wait_for_config_wlast_length(  );
        begin
            int _temp_config_wlast_length;
            _temp_config_wlast_length = config_wlast_length;
            wait( _temp_config_wlast_length != config_wlast_length );
        end
    endtask

    task automatic do_wait_for_config_wid_for_awid_not_matching(  );
        begin
            bit [((AXI_ID_WIDTH) - 1):0]  _temp_config_wid_for_awid_not_matching;
            _temp_config_wid_for_awid_not_matching = config_wid_for_awid_not_matching;
            wait( _temp_config_wid_for_awid_not_matching != config_wid_for_awid_not_matching );
        end
    endtask

    task automatic do_wait_for_config_wid_for_awid_not_matching_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_wid_for_awid_not_matching;
            _temp_config_wid_for_awid_not_matching = config_wid_for_awid_not_matching[_this_dot_1];
            wait( _temp_config_wid_for_awid_not_matching != config_wid_for_awid_not_matching[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_support_exclusive_access(  );
        begin
            bit _temp_config_support_exclusive_access;
            _temp_config_support_exclusive_access = config_support_exclusive_access;
            wait( _temp_config_support_exclusive_access != config_support_exclusive_access );
        end
    endtask

    task automatic do_wait_for_config_write_data_interleaving_depth(  );
        begin
            int _temp_config_write_data_interleaving_depth;
            _temp_config_write_data_interleaving_depth = config_write_data_interleaving_depth;
            wait( _temp_config_write_data_interleaving_depth != config_write_data_interleaving_depth );
        end
    endtask

    task automatic do_wait_for_status_master_error(  );
        begin
            bit [15:0] _temp_status_master_error;
            _temp_status_master_error = status_master_error;
            wait( _temp_status_master_error != status_master_error );
        end
    endtask

    task automatic do_wait_for_status_master_error_index1( input int _this_dot_1 );
        begin
            bit  _temp_status_master_error;
            _temp_status_master_error = status_master_error[_this_dot_1];
            wait( _temp_status_master_error != status_master_error[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_status_num_reads_waiting_for_resp(  );
        begin
            int _temp_status_num_reads_waiting_for_resp;
            _temp_status_num_reads_waiting_for_resp = status_num_reads_waiting_for_resp;
            wait( _temp_status_num_reads_waiting_for_resp != status_num_reads_waiting_for_resp );
        end
    endtask

    task automatic do_wait_for_status_num_writes_waiting_for_response(  );
        begin
            int _temp_status_num_writes_waiting_for_response;
            _temp_status_num_writes_waiting_for_response = status_num_writes_waiting_for_response;
            wait( _temp_status_num_writes_waiting_for_response != status_num_writes_waiting_for_response );
        end
    endtask

    task automatic do_wait_for_check_total_num_wdata_outstanding(  );
        begin
            bit _temp_check_total_num_wdata_outstanding;
            _temp_check_total_num_wdata_outstanding = check_total_num_wdata_outstanding;
            wait( _temp_check_total_num_wdata_outstanding != check_total_num_wdata_outstanding );
        end
    endtask

    task automatic do_wait_for_total_num_wdata_outstanding(  );
        begin
            int _temp_total_num_wdata_outstanding;
            _temp_total_num_wdata_outstanding = total_num_wdata_outstanding;
            wait( _temp_total_num_wdata_outstanding != total_num_wdata_outstanding );
        end
    endtask

    task automatic do_wait_for_check_max_num_wdata_outstanding_per_id(  );
        begin
            bit _temp_check_max_num_wdata_outstanding_per_id;
            _temp_check_max_num_wdata_outstanding_per_id = check_max_num_wdata_outstanding_per_id;
            wait( _temp_check_max_num_wdata_outstanding_per_id != check_max_num_wdata_outstanding_per_id );
        end
    endtask

    task automatic do_wait_for_max_num_wdata_outstanding_per_id(  );
        begin
            int _temp_max_num_wdata_outstanding_per_id;
            _temp_max_num_wdata_outstanding_per_id = max_num_wdata_outstanding_per_id;
            wait( _temp_max_num_wdata_outstanding_per_id != max_num_wdata_outstanding_per_id );
        end
    endtask

    task automatic do_wait_for_check_max_num_waddr_outstanding_per_id(  );
        begin
            bit _temp_check_max_num_waddr_outstanding_per_id;
            _temp_check_max_num_waddr_outstanding_per_id = check_max_num_waddr_outstanding_per_id;
            wait( _temp_check_max_num_waddr_outstanding_per_id != check_max_num_waddr_outstanding_per_id );
        end
    endtask

    task automatic do_wait_for_max_num_waddr_outstanding_per_id(  );
        begin
            int _temp_max_num_waddr_outstanding_per_id;
            _temp_max_num_waddr_outstanding_per_id = max_num_waddr_outstanding_per_id;
            wait( _temp_max_num_waddr_outstanding_per_id != max_num_waddr_outstanding_per_id );
        end
    endtask

    task automatic do_wait_for_check_total_num_waddr_outstanding(  );
        begin
            bit _temp_check_total_num_waddr_outstanding;
            _temp_check_total_num_waddr_outstanding = check_total_num_waddr_outstanding;
            wait( _temp_check_total_num_waddr_outstanding != check_total_num_waddr_outstanding );
        end
    endtask

    task automatic do_wait_for_total_num_waddr_outstanding(  );
        begin
            int _temp_total_num_waddr_outstanding;
            _temp_total_num_waddr_outstanding = total_num_waddr_outstanding;
            wait( _temp_total_num_waddr_outstanding != total_num_waddr_outstanding );
        end
    endtask

    task automatic do_wait_for_status_outstanding_num_for_waddr(  );
        begin
            int _temp_status_outstanding_num_for_waddr;
            _temp_status_outstanding_num_for_waddr = status_outstanding_num_for_waddr;
            wait( _temp_status_outstanding_num_for_waddr != status_outstanding_num_for_waddr );
        end
    endtask

    task automatic do_wait_for_start_finding_outstanding_waddr(  );
        begin
            bit _temp_start_finding_outstanding_waddr;
            _temp_start_finding_outstanding_waddr = start_finding_outstanding_waddr;
            wait( _temp_start_finding_outstanding_waddr != start_finding_outstanding_waddr );
        end
    endtask

    task automatic do_wait_for_status_outstanding_num_for_wdata(  );
        begin
            int _temp_status_outstanding_num_for_wdata;
            _temp_status_outstanding_num_for_wdata = status_outstanding_num_for_wdata;
            wait( _temp_status_outstanding_num_for_wdata != status_outstanding_num_for_wdata );
        end
    endtask

    task automatic do_wait_for_start_finding_outstanding_wdata(  );
        begin
            bit _temp_start_finding_outstanding_wdata;
            _temp_start_finding_outstanding_wdata = start_finding_outstanding_wdata;
            wait( _temp_start_finding_outstanding_wdata != start_finding_outstanding_wdata );
        end
    endtask

    task automatic do_wait_for_find_waddr_outstanding_for_wid(  );
        begin
            bit [((AXI_ID_WIDTH) - 1):0]  _temp_find_waddr_outstanding_for_wid;
            _temp_find_waddr_outstanding_for_wid = find_waddr_outstanding_for_wid;
            wait( _temp_find_waddr_outstanding_for_wid != find_waddr_outstanding_for_wid );
        end
    endtask

    task automatic do_wait_for_find_waddr_outstanding_for_wid_index1( input int _this_dot_1 );
        begin
            bit  _temp_find_waddr_outstanding_for_wid;
            _temp_find_waddr_outstanding_for_wid = find_waddr_outstanding_for_wid[_this_dot_1];
            wait( _temp_find_waddr_outstanding_for_wid != find_waddr_outstanding_for_wid[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_find_wdata_outstanding_for_wid(  );
        begin
            bit [((AXI_ID_WIDTH) - 1):0]  _temp_find_wdata_outstanding_for_wid;
            _temp_find_wdata_outstanding_for_wid = find_wdata_outstanding_for_wid;
            wait( _temp_find_wdata_outstanding_for_wid != find_wdata_outstanding_for_wid );
        end
    endtask

    task automatic do_wait_for_find_wdata_outstanding_for_wid_index1( input int _this_dot_1 );
        begin
            bit  _temp_find_wdata_outstanding_for_wid;
            _temp_find_wdata_outstanding_for_wid = find_wdata_outstanding_for_wid[_this_dot_1];
            wait( _temp_find_wdata_outstanding_for_wid != find_wdata_outstanding_for_wid[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_change_in_wdata_outstanding_per_id(  );
        begin
            bit _temp_change_in_wdata_outstanding_per_id;
            _temp_change_in_wdata_outstanding_per_id = change_in_wdata_outstanding_per_id;
            wait( _temp_change_in_wdata_outstanding_per_id != change_in_wdata_outstanding_per_id );
        end
    endtask

    task automatic do_wait_for_start_finding_change_in_wdata(  );
        begin
            bit _temp_start_finding_change_in_wdata;
            _temp_start_finding_change_in_wdata = start_finding_change_in_wdata;
            wait( _temp_start_finding_change_in_wdata != start_finding_change_in_wdata );
        end
    endtask

    task automatic do_wait_for_find_change_in_wdata_outstanding_for_wid(  );
        begin
            bit [((AXI_ID_WIDTH) - 1):0]  _temp_find_change_in_wdata_outstanding_for_wid;
            _temp_find_change_in_wdata_outstanding_for_wid = find_change_in_wdata_outstanding_for_wid;
            wait( _temp_find_change_in_wdata_outstanding_for_wid != find_change_in_wdata_outstanding_for_wid );
        end
    endtask

    task automatic do_wait_for_find_change_in_wdata_outstanding_for_wid_index1( input int _this_dot_1 );
        begin
            bit  _temp_find_change_in_wdata_outstanding_for_wid;
            _temp_find_change_in_wdata_outstanding_for_wid = find_change_in_wdata_outstanding_for_wid[_this_dot_1];
            wait( _temp_find_change_in_wdata_outstanding_for_wid != find_change_in_wdata_outstanding_for_wid[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_max_outstanding_wr(  );
        begin
            int _temp_config_max_outstanding_wr;
            _temp_config_max_outstanding_wr = config_max_outstanding_wr;
            wait( _temp_config_max_outstanding_wr != config_max_outstanding_wr );
        end
    endtask

    task automatic do_wait_for_config_max_outstanding_rd(  );
        begin
            int _temp_config_max_outstanding_rd;
            _temp_config_max_outstanding_rd = config_max_outstanding_rd;
            wait( _temp_config_max_outstanding_rd != config_max_outstanding_rd );
        end
    endtask

    task automatic do_wait_for_config_error_on_deleted_valid_cycles(  );
        begin
            bit _temp_config_error_on_deleted_valid_cycles;
            _temp_config_error_on_deleted_valid_cycles = config_error_on_deleted_valid_cycles;
            wait( _temp_config_error_on_deleted_valid_cycles != config_error_on_deleted_valid_cycles );
        end
    endtask

    task automatic do_wait_for_config_stats_enable(  );
        begin
            bit _temp_config_stats_enable;
            _temp_config_stats_enable = config_stats_enable;
            wait( _temp_config_stats_enable != config_stats_enable );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_AXI_read_occupancy(  );
        begin
            bit _temp_config_stats_enable_AXI_read_occupancy;
            _temp_config_stats_enable_AXI_read_occupancy = config_stats_enable_AXI_read_occupancy;
            wait( _temp_config_stats_enable_AXI_read_occupancy != config_stats_enable_AXI_read_occupancy );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_AXI_write_occupancy(  );
        begin
            bit _temp_config_stats_enable_AXI_write_occupancy;
            _temp_config_stats_enable_AXI_write_occupancy = config_stats_enable_AXI_write_occupancy;
            wait( _temp_config_stats_enable_AXI_write_occupancy != config_stats_enable_AXI_write_occupancy );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_data_occupancy(  );
        begin
            bit _temp_config_stats_enable_read_data_occupancy;
            _temp_config_stats_enable_read_data_occupancy = config_stats_enable_read_data_occupancy;
            wait( _temp_config_stats_enable_read_data_occupancy != config_stats_enable_read_data_occupancy );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_data_occupancy(  );
        begin
            bit _temp_config_stats_enable_write_data_occupancy;
            _temp_config_stats_enable_write_data_occupancy = config_stats_enable_write_data_occupancy;
            wait( _temp_config_stats_enable_write_data_occupancy != config_stats_enable_write_data_occupancy );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_latency(  );
        begin
            bit _temp_config_stats_enable_read_latency;
            _temp_config_stats_enable_read_latency = config_stats_enable_read_latency;
            wait( _temp_config_stats_enable_read_latency != config_stats_enable_read_latency );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_latency(  );
        begin
            bit _temp_config_stats_enable_write_latency;
            _temp_config_stats_enable_write_latency = config_stats_enable_write_latency;
            wait( _temp_config_stats_enable_write_latency != config_stats_enable_write_latency );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_address_waits(  );
        begin
            bit _temp_config_stats_enable_read_address_waits;
            _temp_config_stats_enable_read_address_waits = config_stats_enable_read_address_waits;
            wait( _temp_config_stats_enable_read_address_waits != config_stats_enable_read_address_waits );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_data_waits(  );
        begin
            bit _temp_config_stats_enable_read_data_waits;
            _temp_config_stats_enable_read_data_waits = config_stats_enable_read_data_waits;
            wait( _temp_config_stats_enable_read_data_waits != config_stats_enable_read_data_waits );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_address_waits(  );
        begin
            bit _temp_config_stats_enable_write_address_waits;
            _temp_config_stats_enable_write_address_waits = config_stats_enable_write_address_waits;
            wait( _temp_config_stats_enable_write_address_waits != config_stats_enable_write_address_waits );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_data_waits(  );
        begin
            bit _temp_config_stats_enable_write_data_waits;
            _temp_config_stats_enable_write_data_waits = config_stats_enable_write_data_waits;
            wait( _temp_config_stats_enable_write_data_waits != config_stats_enable_write_data_waits );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_response_waits(  );
        begin
            bit _temp_config_stats_enable_write_response_waits;
            _temp_config_stats_enable_write_response_waits = config_stats_enable_write_response_waits;
            wait( _temp_config_stats_enable_write_response_waits != config_stats_enable_write_response_waits );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_bandwidth(  );
        begin
            bit _temp_config_stats_enable_read_bandwidth;
            _temp_config_stats_enable_read_bandwidth = config_stats_enable_read_bandwidth;
            wait( _temp_config_stats_enable_read_bandwidth != config_stats_enable_read_bandwidth );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_bandwidth(  );
        begin
            bit _temp_config_stats_enable_write_bandwidth;
            _temp_config_stats_enable_write_bandwidth = config_stats_enable_write_bandwidth;
            wait( _temp_config_stats_enable_write_bandwidth != config_stats_enable_write_bandwidth );
        end
    endtask

    task automatic do_wait_for_config_stats_AXI_read_occupancy_step(  );
        begin
            int _temp_config_stats_AXI_read_occupancy_step;
            _temp_config_stats_AXI_read_occupancy_step = config_stats_AXI_read_occupancy_step;
            wait( _temp_config_stats_AXI_read_occupancy_step != config_stats_AXI_read_occupancy_step );
        end
    endtask

    task automatic do_wait_for_config_stats_AXI_read_occupancy_multiple(  );
        begin
            int _temp_config_stats_AXI_read_occupancy_multiple;
            _temp_config_stats_AXI_read_occupancy_multiple = config_stats_AXI_read_occupancy_multiple;
            wait( _temp_config_stats_AXI_read_occupancy_multiple != config_stats_AXI_read_occupancy_multiple );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_active(  );
        begin
            bit _temp_stats_AXI_read_active;
            _temp_stats_AXI_read_active = stats_AXI_read_active;
            wait( _temp_stats_AXI_read_active != stats_AXI_read_active );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_occupancy_sw(  );
        begin
            int _temp_stats_AXI_read_occupancy_sw;
            _temp_stats_AXI_read_occupancy_sw = stats_AXI_read_occupancy_sw;
            wait( _temp_stats_AXI_read_occupancy_sw != stats_AXI_read_occupancy_sw );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_occupancy_sw_updated(  );
        begin
            int _temp_stats_AXI_read_occupancy_sw_updated;
            _temp_stats_AXI_read_occupancy_sw_updated = stats_AXI_read_occupancy_sw_updated;
            wait( _temp_stats_AXI_read_occupancy_sw_updated != stats_AXI_read_occupancy_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_idle_sw(  );
        begin
            int _temp_stats_AXI_read_idle_sw;
            _temp_stats_AXI_read_idle_sw = stats_AXI_read_idle_sw;
            wait( _temp_stats_AXI_read_idle_sw != stats_AXI_read_idle_sw );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_occupancy_min(  );
        begin
            int _temp_stats_AXI_read_occupancy_min;
            _temp_stats_AXI_read_occupancy_min = stats_AXI_read_occupancy_min;
            wait( _temp_stats_AXI_read_occupancy_min != stats_AXI_read_occupancy_min );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_idle_min(  );
        begin
            int _temp_stats_AXI_read_idle_min;
            _temp_stats_AXI_read_idle_min = stats_AXI_read_idle_min;
            wait( _temp_stats_AXI_read_idle_min != stats_AXI_read_idle_min );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_occupancy_max(  );
        begin
            int _temp_stats_AXI_read_occupancy_max;
            _temp_stats_AXI_read_occupancy_max = stats_AXI_read_occupancy_max;
            wait( _temp_stats_AXI_read_occupancy_max != stats_AXI_read_occupancy_max );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_idle_max(  );
        begin
            int _temp_stats_AXI_read_idle_max;
            _temp_stats_AXI_read_idle_max = stats_AXI_read_idle_max;
            wait( _temp_stats_AXI_read_idle_max != stats_AXI_read_idle_max );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_occupancy_mean(  );
        begin
            int _temp_stats_AXI_read_occupancy_mean;
            _temp_stats_AXI_read_occupancy_mean = stats_AXI_read_occupancy_mean;
            wait( _temp_stats_AXI_read_occupancy_mean != stats_AXI_read_occupancy_mean );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_idle_mean(  );
        begin
            int _temp_stats_AXI_read_idle_mean;
            _temp_stats_AXI_read_idle_mean = stats_AXI_read_idle_mean;
            wait( _temp_stats_AXI_read_idle_mean != stats_AXI_read_idle_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_AXI_write_occupancy_step(  );
        begin
            int _temp_config_stats_AXI_write_occupancy_step;
            _temp_config_stats_AXI_write_occupancy_step = config_stats_AXI_write_occupancy_step;
            wait( _temp_config_stats_AXI_write_occupancy_step != config_stats_AXI_write_occupancy_step );
        end
    endtask

    task automatic do_wait_for_config_stats_AXI_write_occupancy_multiple(  );
        begin
            int _temp_config_stats_AXI_write_occupancy_multiple;
            _temp_config_stats_AXI_write_occupancy_multiple = config_stats_AXI_write_occupancy_multiple;
            wait( _temp_config_stats_AXI_write_occupancy_multiple != config_stats_AXI_write_occupancy_multiple );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_active(  );
        begin
            bit _temp_stats_AXI_write_active;
            _temp_stats_AXI_write_active = stats_AXI_write_active;
            wait( _temp_stats_AXI_write_active != stats_AXI_write_active );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_occupancy_sw(  );
        begin
            int _temp_stats_AXI_write_occupancy_sw;
            _temp_stats_AXI_write_occupancy_sw = stats_AXI_write_occupancy_sw;
            wait( _temp_stats_AXI_write_occupancy_sw != stats_AXI_write_occupancy_sw );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_occupancy_sw_updated(  );
        begin
            int _temp_stats_AXI_write_occupancy_sw_updated;
            _temp_stats_AXI_write_occupancy_sw_updated = stats_AXI_write_occupancy_sw_updated;
            wait( _temp_stats_AXI_write_occupancy_sw_updated != stats_AXI_write_occupancy_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_idle_sw(  );
        begin
            int _temp_stats_AXI_write_idle_sw;
            _temp_stats_AXI_write_idle_sw = stats_AXI_write_idle_sw;
            wait( _temp_stats_AXI_write_idle_sw != stats_AXI_write_idle_sw );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_occupancy_min(  );
        begin
            int _temp_stats_AXI_write_occupancy_min;
            _temp_stats_AXI_write_occupancy_min = stats_AXI_write_occupancy_min;
            wait( _temp_stats_AXI_write_occupancy_min != stats_AXI_write_occupancy_min );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_idle_min(  );
        begin
            int _temp_stats_AXI_write_idle_min;
            _temp_stats_AXI_write_idle_min = stats_AXI_write_idle_min;
            wait( _temp_stats_AXI_write_idle_min != stats_AXI_write_idle_min );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_occupancy_max(  );
        begin
            int _temp_stats_AXI_write_occupancy_max;
            _temp_stats_AXI_write_occupancy_max = stats_AXI_write_occupancy_max;
            wait( _temp_stats_AXI_write_occupancy_max != stats_AXI_write_occupancy_max );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_idle_max(  );
        begin
            int _temp_stats_AXI_write_idle_max;
            _temp_stats_AXI_write_idle_max = stats_AXI_write_idle_max;
            wait( _temp_stats_AXI_write_idle_max != stats_AXI_write_idle_max );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_occupancy_mean(  );
        begin
            int _temp_stats_AXI_write_occupancy_mean;
            _temp_stats_AXI_write_occupancy_mean = stats_AXI_write_occupancy_mean;
            wait( _temp_stats_AXI_write_occupancy_mean != stats_AXI_write_occupancy_mean );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_idle_mean(  );
        begin
            int _temp_stats_AXI_write_idle_mean;
            _temp_stats_AXI_write_idle_mean = stats_AXI_write_idle_mean;
            wait( _temp_stats_AXI_write_idle_mean != stats_AXI_write_idle_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_read_data_occupancy_step(  );
        begin
            int _temp_config_stats_read_data_occupancy_step;
            _temp_config_stats_read_data_occupancy_step = config_stats_read_data_occupancy_step;
            wait( _temp_config_stats_read_data_occupancy_step != config_stats_read_data_occupancy_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_data_occupancy_multiple(  );
        begin
            int _temp_config_stats_read_data_occupancy_multiple;
            _temp_config_stats_read_data_occupancy_multiple = config_stats_read_data_occupancy_multiple;
            wait( _temp_config_stats_read_data_occupancy_multiple != config_stats_read_data_occupancy_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_data_occupancy_sw(  );
        begin
            int _temp_stats_read_data_occupancy_sw;
            _temp_stats_read_data_occupancy_sw = stats_read_data_occupancy_sw;
            wait( _temp_stats_read_data_occupancy_sw != stats_read_data_occupancy_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_data_occupancy_sw_updated(  );
        begin
            int _temp_stats_read_data_occupancy_sw_updated;
            _temp_stats_read_data_occupancy_sw_updated = stats_read_data_occupancy_sw_updated;
            wait( _temp_stats_read_data_occupancy_sw_updated != stats_read_data_occupancy_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_read_data_idle_sw(  );
        begin
            int _temp_stats_read_data_idle_sw;
            _temp_stats_read_data_idle_sw = stats_read_data_idle_sw;
            wait( _temp_stats_read_data_idle_sw != stats_read_data_idle_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_data_occupancy_min(  );
        begin
            int _temp_stats_read_data_occupancy_min;
            _temp_stats_read_data_occupancy_min = stats_read_data_occupancy_min;
            wait( _temp_stats_read_data_occupancy_min != stats_read_data_occupancy_min );
        end
    endtask

    task automatic do_wait_for_stats_read_data_idle_min(  );
        begin
            int _temp_stats_read_data_idle_min;
            _temp_stats_read_data_idle_min = stats_read_data_idle_min;
            wait( _temp_stats_read_data_idle_min != stats_read_data_idle_min );
        end
    endtask

    task automatic do_wait_for_stats_read_data_occupancy_max(  );
        begin
            int _temp_stats_read_data_occupancy_max;
            _temp_stats_read_data_occupancy_max = stats_read_data_occupancy_max;
            wait( _temp_stats_read_data_occupancy_max != stats_read_data_occupancy_max );
        end
    endtask

    task automatic do_wait_for_stats_read_data_idle_max(  );
        begin
            int _temp_stats_read_data_idle_max;
            _temp_stats_read_data_idle_max = stats_read_data_idle_max;
            wait( _temp_stats_read_data_idle_max != stats_read_data_idle_max );
        end
    endtask

    task automatic do_wait_for_stats_read_data_occupancy_mean(  );
        begin
            int _temp_stats_read_data_occupancy_mean;
            _temp_stats_read_data_occupancy_mean = stats_read_data_occupancy_mean;
            wait( _temp_stats_read_data_occupancy_mean != stats_read_data_occupancy_mean );
        end
    endtask

    task automatic do_wait_for_stats_read_data_idle_mean(  );
        begin
            int _temp_stats_read_data_idle_mean;
            _temp_stats_read_data_idle_mean = stats_read_data_idle_mean;
            wait( _temp_stats_read_data_idle_mean != stats_read_data_idle_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_data_occupancy_step(  );
        begin
            int _temp_config_stats_write_data_occupancy_step;
            _temp_config_stats_write_data_occupancy_step = config_stats_write_data_occupancy_step;
            wait( _temp_config_stats_write_data_occupancy_step != config_stats_write_data_occupancy_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_data_occupancy_multiple(  );
        begin
            int _temp_config_stats_write_data_occupancy_multiple;
            _temp_config_stats_write_data_occupancy_multiple = config_stats_write_data_occupancy_multiple;
            wait( _temp_config_stats_write_data_occupancy_multiple != config_stats_write_data_occupancy_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_data_occupancy_sw(  );
        begin
            int _temp_stats_write_data_occupancy_sw;
            _temp_stats_write_data_occupancy_sw = stats_write_data_occupancy_sw;
            wait( _temp_stats_write_data_occupancy_sw != stats_write_data_occupancy_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_data_occupancy_sw_updated(  );
        begin
            int _temp_stats_write_data_occupancy_sw_updated;
            _temp_stats_write_data_occupancy_sw_updated = stats_write_data_occupancy_sw_updated;
            wait( _temp_stats_write_data_occupancy_sw_updated != stats_write_data_occupancy_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_write_data_idle_sw(  );
        begin
            int _temp_stats_write_data_idle_sw;
            _temp_stats_write_data_idle_sw = stats_write_data_idle_sw;
            wait( _temp_stats_write_data_idle_sw != stats_write_data_idle_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_data_occupancy_min(  );
        begin
            int _temp_stats_write_data_occupancy_min;
            _temp_stats_write_data_occupancy_min = stats_write_data_occupancy_min;
            wait( _temp_stats_write_data_occupancy_min != stats_write_data_occupancy_min );
        end
    endtask

    task automatic do_wait_for_stats_write_data_idle_min(  );
        begin
            int _temp_stats_write_data_idle_min;
            _temp_stats_write_data_idle_min = stats_write_data_idle_min;
            wait( _temp_stats_write_data_idle_min != stats_write_data_idle_min );
        end
    endtask

    task automatic do_wait_for_stats_write_data_occupancy_max(  );
        begin
            int _temp_stats_write_data_occupancy_max;
            _temp_stats_write_data_occupancy_max = stats_write_data_occupancy_max;
            wait( _temp_stats_write_data_occupancy_max != stats_write_data_occupancy_max );
        end
    endtask

    task automatic do_wait_for_stats_write_data_idle_max(  );
        begin
            int _temp_stats_write_data_idle_max;
            _temp_stats_write_data_idle_max = stats_write_data_idle_max;
            wait( _temp_stats_write_data_idle_max != stats_write_data_idle_max );
        end
    endtask

    task automatic do_wait_for_stats_write_data_occupancy_mean(  );
        begin
            int _temp_stats_write_data_occupancy_mean;
            _temp_stats_write_data_occupancy_mean = stats_write_data_occupancy_mean;
            wait( _temp_stats_write_data_occupancy_mean != stats_write_data_occupancy_mean );
        end
    endtask

    task automatic do_wait_for_stats_write_data_idle_mean(  );
        begin
            int _temp_stats_write_data_idle_mean;
            _temp_stats_write_data_idle_mean = stats_write_data_idle_mean;
            wait( _temp_stats_write_data_idle_mean != stats_write_data_idle_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_read_bandwidth_step(  );
        begin
            int _temp_config_stats_read_bandwidth_step;
            _temp_config_stats_read_bandwidth_step = config_stats_read_bandwidth_step;
            wait( _temp_config_stats_read_bandwidth_step != config_stats_read_bandwidth_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_bandwidth_multiple(  );
        begin
            int _temp_config_stats_read_bandwidth_multiple;
            _temp_config_stats_read_bandwidth_multiple = config_stats_read_bandwidth_multiple;
            wait( _temp_config_stats_read_bandwidth_multiple != config_stats_read_bandwidth_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_bandwidth_sw(  );
        begin
            int _temp_stats_read_bandwidth_sw;
            _temp_stats_read_bandwidth_sw = stats_read_bandwidth_sw;
            wait( _temp_stats_read_bandwidth_sw != stats_read_bandwidth_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_bandwidth_sw_updated(  );
        begin
            int _temp_stats_read_bandwidth_sw_updated;
            _temp_stats_read_bandwidth_sw_updated = stats_read_bandwidth_sw_updated;
            wait( _temp_stats_read_bandwidth_sw_updated != stats_read_bandwidth_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_read_bandwidth_min(  );
        begin
            int _temp_stats_read_bandwidth_min;
            _temp_stats_read_bandwidth_min = stats_read_bandwidth_min;
            wait( _temp_stats_read_bandwidth_min != stats_read_bandwidth_min );
        end
    endtask

    task automatic do_wait_for_stats_read_bandwidth_max(  );
        begin
            int _temp_stats_read_bandwidth_max;
            _temp_stats_read_bandwidth_max = stats_read_bandwidth_max;
            wait( _temp_stats_read_bandwidth_max != stats_read_bandwidth_max );
        end
    endtask

    task automatic do_wait_for_stats_read_bandwidth_mean(  );
        begin
            int _temp_stats_read_bandwidth_mean;
            _temp_stats_read_bandwidth_mean = stats_read_bandwidth_mean;
            wait( _temp_stats_read_bandwidth_mean != stats_read_bandwidth_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_bandwidth_step(  );
        begin
            int _temp_config_stats_write_bandwidth_step;
            _temp_config_stats_write_bandwidth_step = config_stats_write_bandwidth_step;
            wait( _temp_config_stats_write_bandwidth_step != config_stats_write_bandwidth_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_bandwidth_multiple(  );
        begin
            int _temp_config_stats_write_bandwidth_multiple;
            _temp_config_stats_write_bandwidth_multiple = config_stats_write_bandwidth_multiple;
            wait( _temp_config_stats_write_bandwidth_multiple != config_stats_write_bandwidth_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_bandwidth_sw(  );
        begin
            int _temp_stats_write_bandwidth_sw;
            _temp_stats_write_bandwidth_sw = stats_write_bandwidth_sw;
            wait( _temp_stats_write_bandwidth_sw != stats_write_bandwidth_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_bandwidth_sw_updated(  );
        begin
            int _temp_stats_write_bandwidth_sw_updated;
            _temp_stats_write_bandwidth_sw_updated = stats_write_bandwidth_sw_updated;
            wait( _temp_stats_write_bandwidth_sw_updated != stats_write_bandwidth_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_write_bandwidth_min(  );
        begin
            int _temp_stats_write_bandwidth_min;
            _temp_stats_write_bandwidth_min = stats_write_bandwidth_min;
            wait( _temp_stats_write_bandwidth_min != stats_write_bandwidth_min );
        end
    endtask

    task automatic do_wait_for_stats_write_bandwidth_max(  );
        begin
            int _temp_stats_write_bandwidth_max;
            _temp_stats_write_bandwidth_max = stats_write_bandwidth_max;
            wait( _temp_stats_write_bandwidth_max != stats_write_bandwidth_max );
        end
    endtask

    task automatic do_wait_for_stats_write_bandwidth_mean(  );
        begin
            int _temp_stats_write_bandwidth_mean;
            _temp_stats_write_bandwidth_mean = stats_write_bandwidth_mean;
            wait( _temp_stats_write_bandwidth_mean != stats_write_bandwidth_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_read_latency_step(  );
        begin
            int _temp_config_stats_read_latency_step;
            _temp_config_stats_read_latency_step = config_stats_read_latency_step;
            wait( _temp_config_stats_read_latency_step != config_stats_read_latency_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_latency_multiple(  );
        begin
            int _temp_config_stats_read_latency_multiple;
            _temp_config_stats_read_latency_multiple = config_stats_read_latency_multiple;
            wait( _temp_config_stats_read_latency_multiple != config_stats_read_latency_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_latency_sw_updated(  );
        begin
            int _temp_stats_read_latency_sw_updated;
            _temp_stats_read_latency_sw_updated = stats_read_latency_sw_updated;
            wait( _temp_stats_read_latency_sw_updated != stats_read_latency_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_read_address_data_latency_inst(  );
        begin
            int _temp_stats_read_address_data_latency_inst;
            _temp_stats_read_address_data_latency_inst = stats_read_address_data_latency_inst;
            wait( _temp_stats_read_address_data_latency_inst != stats_read_address_data_latency_inst );
        end
    endtask

    task automatic do_wait_for_stats_read_address_data_latency_sw(  );
        begin
            int _temp_stats_read_address_data_latency_sw;
            _temp_stats_read_address_data_latency_sw = stats_read_address_data_latency_sw;
            wait( _temp_stats_read_address_data_latency_sw != stats_read_address_data_latency_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_address_data_latency_min(  );
        begin
            int _temp_stats_read_address_data_latency_min;
            _temp_stats_read_address_data_latency_min = stats_read_address_data_latency_min;
            wait( _temp_stats_read_address_data_latency_min != stats_read_address_data_latency_min );
        end
    endtask

    task automatic do_wait_for_stats_read_address_data_latency_max(  );
        begin
            int _temp_stats_read_address_data_latency_max;
            _temp_stats_read_address_data_latency_max = stats_read_address_data_latency_max;
            wait( _temp_stats_read_address_data_latency_max != stats_read_address_data_latency_max );
        end
    endtask

    task automatic do_wait_for_stats_read_address_data_latency_mean(  );
        begin
            int _temp_stats_read_address_data_latency_mean;
            _temp_stats_read_address_data_latency_mean = stats_read_address_data_latency_mean;
            wait( _temp_stats_read_address_data_latency_mean != stats_read_address_data_latency_mean );
        end
    endtask

    task automatic do_wait_for_stats_read_address_address_latency_inst(  );
        begin
            int _temp_stats_read_address_address_latency_inst;
            _temp_stats_read_address_address_latency_inst = stats_read_address_address_latency_inst;
            wait( _temp_stats_read_address_address_latency_inst != stats_read_address_address_latency_inst );
        end
    endtask

    task automatic do_wait_for_stats_read_address_address_latency_sw(  );
        begin
            int _temp_stats_read_address_address_latency_sw;
            _temp_stats_read_address_address_latency_sw = stats_read_address_address_latency_sw;
            wait( _temp_stats_read_address_address_latency_sw != stats_read_address_address_latency_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_address_address_latency_min(  );
        begin
            int _temp_stats_read_address_address_latency_min;
            _temp_stats_read_address_address_latency_min = stats_read_address_address_latency_min;
            wait( _temp_stats_read_address_address_latency_min != stats_read_address_address_latency_min );
        end
    endtask

    task automatic do_wait_for_stats_read_address_address_latency_max(  );
        begin
            int _temp_stats_read_address_address_latency_max;
            _temp_stats_read_address_address_latency_max = stats_read_address_address_latency_max;
            wait( _temp_stats_read_address_address_latency_max != stats_read_address_address_latency_max );
        end
    endtask

    task automatic do_wait_for_stats_read_address_address_latency_mean(  );
        begin
            int _temp_stats_read_address_address_latency_mean;
            _temp_stats_read_address_address_latency_mean = stats_read_address_address_latency_mean;
            wait( _temp_stats_read_address_address_latency_mean != stats_read_address_address_latency_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_latency_step(  );
        begin
            int _temp_config_stats_write_latency_step;
            _temp_config_stats_write_latency_step = config_stats_write_latency_step;
            wait( _temp_config_stats_write_latency_step != config_stats_write_latency_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_latency_multiple(  );
        begin
            int _temp_config_stats_write_latency_multiple;
            _temp_config_stats_write_latency_multiple = config_stats_write_latency_multiple;
            wait( _temp_config_stats_write_latency_multiple != config_stats_write_latency_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_latency_sw_updated(  );
        begin
            int _temp_stats_write_latency_sw_updated;
            _temp_stats_write_latency_sw_updated = stats_write_latency_sw_updated;
            wait( _temp_stats_write_latency_sw_updated != stats_write_latency_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_write_address_data_latency_inst(  );
        begin
            int _temp_stats_write_address_data_latency_inst;
            _temp_stats_write_address_data_latency_inst = stats_write_address_data_latency_inst;
            wait( _temp_stats_write_address_data_latency_inst != stats_write_address_data_latency_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_address_data_latency_sw(  );
        begin
            int _temp_stats_write_address_data_latency_sw;
            _temp_stats_write_address_data_latency_sw = stats_write_address_data_latency_sw;
            wait( _temp_stats_write_address_data_latency_sw != stats_write_address_data_latency_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_address_data_latency_min(  );
        begin
            int _temp_stats_write_address_data_latency_min;
            _temp_stats_write_address_data_latency_min = stats_write_address_data_latency_min;
            wait( _temp_stats_write_address_data_latency_min != stats_write_address_data_latency_min );
        end
    endtask

    task automatic do_wait_for_stats_write_address_data_latency_max(  );
        begin
            int _temp_stats_write_address_data_latency_max;
            _temp_stats_write_address_data_latency_max = stats_write_address_data_latency_max;
            wait( _temp_stats_write_address_data_latency_max != stats_write_address_data_latency_max );
        end
    endtask

    task automatic do_wait_for_stats_write_address_data_latency_mean(  );
        begin
            int _temp_stats_write_address_data_latency_mean;
            _temp_stats_write_address_data_latency_mean = stats_write_address_data_latency_mean;
            wait( _temp_stats_write_address_data_latency_mean != stats_write_address_data_latency_mean );
        end
    endtask

    task automatic do_wait_for_stats_write_data_response_latency_inst(  );
        begin
            int _temp_stats_write_data_response_latency_inst;
            _temp_stats_write_data_response_latency_inst = stats_write_data_response_latency_inst;
            wait( _temp_stats_write_data_response_latency_inst != stats_write_data_response_latency_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_data_response_latency_sw(  );
        begin
            int _temp_stats_write_data_response_latency_sw;
            _temp_stats_write_data_response_latency_sw = stats_write_data_response_latency_sw;
            wait( _temp_stats_write_data_response_latency_sw != stats_write_data_response_latency_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_data_response_latency_min(  );
        begin
            int _temp_stats_write_data_response_latency_min;
            _temp_stats_write_data_response_latency_min = stats_write_data_response_latency_min;
            wait( _temp_stats_write_data_response_latency_min != stats_write_data_response_latency_min );
        end
    endtask

    task automatic do_wait_for_stats_write_data_response_latency_max(  );
        begin
            int _temp_stats_write_data_response_latency_max;
            _temp_stats_write_data_response_latency_max = stats_write_data_response_latency_max;
            wait( _temp_stats_write_data_response_latency_max != stats_write_data_response_latency_max );
        end
    endtask

    task automatic do_wait_for_stats_write_data_response_latency_mean(  );
        begin
            int _temp_stats_write_data_response_latency_mean;
            _temp_stats_write_data_response_latency_mean = stats_write_data_response_latency_mean;
            wait( _temp_stats_write_data_response_latency_mean != stats_write_data_response_latency_mean );
        end
    endtask

    task automatic do_wait_for_stats_write_address_address_latency_inst(  );
        begin
            int _temp_stats_write_address_address_latency_inst;
            _temp_stats_write_address_address_latency_inst = stats_write_address_address_latency_inst;
            wait( _temp_stats_write_address_address_latency_inst != stats_write_address_address_latency_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_address_address_latency_sw(  );
        begin
            int _temp_stats_write_address_address_latency_sw;
            _temp_stats_write_address_address_latency_sw = stats_write_address_address_latency_sw;
            wait( _temp_stats_write_address_address_latency_sw != stats_write_address_address_latency_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_address_address_latency_min(  );
        begin
            int _temp_stats_write_address_address_latency_min;
            _temp_stats_write_address_address_latency_min = stats_write_address_address_latency_min;
            wait( _temp_stats_write_address_address_latency_min != stats_write_address_address_latency_min );
        end
    endtask

    task automatic do_wait_for_stats_write_address_address_latency_max(  );
        begin
            int _temp_stats_write_address_address_latency_max;
            _temp_stats_write_address_address_latency_max = stats_write_address_address_latency_max;
            wait( _temp_stats_write_address_address_latency_max != stats_write_address_address_latency_max );
        end
    endtask

    task automatic do_wait_for_stats_write_address_address_latency_mean(  );
        begin
            int _temp_stats_write_address_address_latency_mean;
            _temp_stats_write_address_address_latency_mean = stats_write_address_address_latency_mean;
            wait( _temp_stats_write_address_address_latency_mean != stats_write_address_address_latency_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_read_address_waits_step(  );
        begin
            int _temp_config_stats_read_address_waits_step;
            _temp_config_stats_read_address_waits_step = config_stats_read_address_waits_step;
            wait( _temp_config_stats_read_address_waits_step != config_stats_read_address_waits_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_address_waits_multiple(  );
        begin
            int _temp_config_stats_read_address_waits_multiple;
            _temp_config_stats_read_address_waits_multiple = config_stats_read_address_waits_multiple;
            wait( _temp_config_stats_read_address_waits_multiple != config_stats_read_address_waits_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_inst(  );
        begin
            int _temp_stats_read_address_waits_inst;
            _temp_stats_read_address_waits_inst = stats_read_address_waits_inst;
            wait( _temp_stats_read_address_waits_inst != stats_read_address_waits_inst );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_sw(  );
        begin
            int _temp_stats_read_address_waits_sw;
            _temp_stats_read_address_waits_sw = stats_read_address_waits_sw;
            wait( _temp_stats_read_address_waits_sw != stats_read_address_waits_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_sw_updated(  );
        begin
            int _temp_stats_read_address_waits_sw_updated;
            _temp_stats_read_address_waits_sw_updated = stats_read_address_waits_sw_updated;
            wait( _temp_stats_read_address_waits_sw_updated != stats_read_address_waits_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_min(  );
        begin
            int _temp_stats_read_address_waits_min;
            _temp_stats_read_address_waits_min = stats_read_address_waits_min;
            wait( _temp_stats_read_address_waits_min != stats_read_address_waits_min );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_max(  );
        begin
            int _temp_stats_read_address_waits_max;
            _temp_stats_read_address_waits_max = stats_read_address_waits_max;
            wait( _temp_stats_read_address_waits_max != stats_read_address_waits_max );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_mean(  );
        begin
            int _temp_stats_read_address_waits_mean;
            _temp_stats_read_address_waits_mean = stats_read_address_waits_mean;
            wait( _temp_stats_read_address_waits_mean != stats_read_address_waits_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_read_data_waits_step(  );
        begin
            int _temp_config_stats_read_data_waits_step;
            _temp_config_stats_read_data_waits_step = config_stats_read_data_waits_step;
            wait( _temp_config_stats_read_data_waits_step != config_stats_read_data_waits_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_data_waits_multiple(  );
        begin
            int _temp_config_stats_read_data_waits_multiple;
            _temp_config_stats_read_data_waits_multiple = config_stats_read_data_waits_multiple;
            wait( _temp_config_stats_read_data_waits_multiple != config_stats_read_data_waits_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_inst(  );
        begin
            int _temp_stats_read_data_waits_inst;
            _temp_stats_read_data_waits_inst = stats_read_data_waits_inst;
            wait( _temp_stats_read_data_waits_inst != stats_read_data_waits_inst );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_sw(  );
        begin
            int _temp_stats_read_data_waits_sw;
            _temp_stats_read_data_waits_sw = stats_read_data_waits_sw;
            wait( _temp_stats_read_data_waits_sw != stats_read_data_waits_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_sw_updated(  );
        begin
            int _temp_stats_read_data_waits_sw_updated;
            _temp_stats_read_data_waits_sw_updated = stats_read_data_waits_sw_updated;
            wait( _temp_stats_read_data_waits_sw_updated != stats_read_data_waits_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_min(  );
        begin
            int _temp_stats_read_data_waits_min;
            _temp_stats_read_data_waits_min = stats_read_data_waits_min;
            wait( _temp_stats_read_data_waits_min != stats_read_data_waits_min );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_max(  );
        begin
            int _temp_stats_read_data_waits_max;
            _temp_stats_read_data_waits_max = stats_read_data_waits_max;
            wait( _temp_stats_read_data_waits_max != stats_read_data_waits_max );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_mean(  );
        begin
            int _temp_stats_read_data_waits_mean;
            _temp_stats_read_data_waits_mean = stats_read_data_waits_mean;
            wait( _temp_stats_read_data_waits_mean != stats_read_data_waits_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_address_waits_step(  );
        begin
            int _temp_config_stats_write_address_waits_step;
            _temp_config_stats_write_address_waits_step = config_stats_write_address_waits_step;
            wait( _temp_config_stats_write_address_waits_step != config_stats_write_address_waits_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_address_waits_multiple(  );
        begin
            int _temp_config_stats_write_address_waits_multiple;
            _temp_config_stats_write_address_waits_multiple = config_stats_write_address_waits_multiple;
            wait( _temp_config_stats_write_address_waits_multiple != config_stats_write_address_waits_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_inst(  );
        begin
            int _temp_stats_write_address_waits_inst;
            _temp_stats_write_address_waits_inst = stats_write_address_waits_inst;
            wait( _temp_stats_write_address_waits_inst != stats_write_address_waits_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_sw(  );
        begin
            int _temp_stats_write_address_waits_sw;
            _temp_stats_write_address_waits_sw = stats_write_address_waits_sw;
            wait( _temp_stats_write_address_waits_sw != stats_write_address_waits_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_sw_updated(  );
        begin
            int _temp_stats_write_address_waits_sw_updated;
            _temp_stats_write_address_waits_sw_updated = stats_write_address_waits_sw_updated;
            wait( _temp_stats_write_address_waits_sw_updated != stats_write_address_waits_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_min(  );
        begin
            int _temp_stats_write_address_waits_min;
            _temp_stats_write_address_waits_min = stats_write_address_waits_min;
            wait( _temp_stats_write_address_waits_min != stats_write_address_waits_min );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_max(  );
        begin
            int _temp_stats_write_address_waits_max;
            _temp_stats_write_address_waits_max = stats_write_address_waits_max;
            wait( _temp_stats_write_address_waits_max != stats_write_address_waits_max );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_mean(  );
        begin
            int _temp_stats_write_address_waits_mean;
            _temp_stats_write_address_waits_mean = stats_write_address_waits_mean;
            wait( _temp_stats_write_address_waits_mean != stats_write_address_waits_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_data_waits_step(  );
        begin
            int _temp_config_stats_write_data_waits_step;
            _temp_config_stats_write_data_waits_step = config_stats_write_data_waits_step;
            wait( _temp_config_stats_write_data_waits_step != config_stats_write_data_waits_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_data_waits_multiple(  );
        begin
            int _temp_config_stats_write_data_waits_multiple;
            _temp_config_stats_write_data_waits_multiple = config_stats_write_data_waits_multiple;
            wait( _temp_config_stats_write_data_waits_multiple != config_stats_write_data_waits_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_inst(  );
        begin
            int _temp_stats_write_data_waits_inst;
            _temp_stats_write_data_waits_inst = stats_write_data_waits_inst;
            wait( _temp_stats_write_data_waits_inst != stats_write_data_waits_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_sw(  );
        begin
            int _temp_stats_write_data_waits_sw;
            _temp_stats_write_data_waits_sw = stats_write_data_waits_sw;
            wait( _temp_stats_write_data_waits_sw != stats_write_data_waits_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_sw_updated(  );
        begin
            int _temp_stats_write_data_waits_sw_updated;
            _temp_stats_write_data_waits_sw_updated = stats_write_data_waits_sw_updated;
            wait( _temp_stats_write_data_waits_sw_updated != stats_write_data_waits_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_min(  );
        begin
            int _temp_stats_write_data_waits_min;
            _temp_stats_write_data_waits_min = stats_write_data_waits_min;
            wait( _temp_stats_write_data_waits_min != stats_write_data_waits_min );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_max(  );
        begin
            int _temp_stats_write_data_waits_max;
            _temp_stats_write_data_waits_max = stats_write_data_waits_max;
            wait( _temp_stats_write_data_waits_max != stats_write_data_waits_max );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_mean(  );
        begin
            int _temp_stats_write_data_waits_mean;
            _temp_stats_write_data_waits_mean = stats_write_data_waits_mean;
            wait( _temp_stats_write_data_waits_mean != stats_write_data_waits_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_response_waits_step(  );
        begin
            int _temp_config_stats_write_response_waits_step;
            _temp_config_stats_write_response_waits_step = config_stats_write_response_waits_step;
            wait( _temp_config_stats_write_response_waits_step != config_stats_write_response_waits_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_response_waits_multiple(  );
        begin
            int _temp_config_stats_write_response_waits_multiple;
            _temp_config_stats_write_response_waits_multiple = config_stats_write_response_waits_multiple;
            wait( _temp_config_stats_write_response_waits_multiple != config_stats_write_response_waits_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_inst(  );
        begin
            int _temp_stats_write_response_waits_inst;
            _temp_stats_write_response_waits_inst = stats_write_response_waits_inst;
            wait( _temp_stats_write_response_waits_inst != stats_write_response_waits_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_sw(  );
        begin
            int _temp_stats_write_response_waits_sw;
            _temp_stats_write_response_waits_sw = stats_write_response_waits_sw;
            wait( _temp_stats_write_response_waits_sw != stats_write_response_waits_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_sw_updated(  );
        begin
            int _temp_stats_write_response_waits_sw_updated;
            _temp_stats_write_response_waits_sw_updated = stats_write_response_waits_sw_updated;
            wait( _temp_stats_write_response_waits_sw_updated != stats_write_response_waits_sw_updated );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_min(  );
        begin
            int _temp_stats_write_response_waits_min;
            _temp_stats_write_response_waits_min = stats_write_response_waits_min;
            wait( _temp_stats_write_response_waits_min != stats_write_response_waits_min );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_max(  );
        begin
            int _temp_stats_write_response_waits_max;
            _temp_stats_write_response_waits_max = stats_write_response_waits_max;
            wait( _temp_stats_write_response_waits_max != stats_write_response_waits_max );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_mean(  );
        begin
            int _temp_stats_write_response_waits_mean;
            _temp_stats_write_response_waits_mean = stats_write_response_waits_mean;
            wait( _temp_stats_write_response_waits_mean != stats_write_response_waits_mean );
        end
    endtask

    task automatic do_wait_for_stats_rw_transaction_last_duration(  );
        begin
            int _temp_stats_rw_transaction_last_duration;
            _temp_stats_rw_transaction_last_duration = stats_rw_transaction_last_duration;
            wait( _temp_stats_rw_transaction_last_duration != stats_rw_transaction_last_duration );
        end
    endtask

    task automatic do_wait_for_stats_AXI_read_last_duration(  );
        begin
            int _temp_stats_AXI_read_last_duration;
            _temp_stats_AXI_read_last_duration = stats_AXI_read_last_duration;
            wait( _temp_stats_AXI_read_last_duration != stats_AXI_read_last_duration );
        end
    endtask

    task automatic do_wait_for_stats_AXI_write_last_duration(  );
        begin
            int _temp_stats_AXI_write_last_duration;
            _temp_stats_AXI_write_last_duration = stats_AXI_write_last_duration;
            wait( _temp_stats_AXI_write_last_duration != stats_AXI_write_last_duration );
        end
    endtask

    task automatic do_wait_for_stats_read_addr_channel_phase_last_duration(  );
        begin
            int _temp_stats_read_addr_channel_phase_last_duration;
            _temp_stats_read_addr_channel_phase_last_duration = stats_read_addr_channel_phase_last_duration;
            wait( _temp_stats_read_addr_channel_phase_last_duration != stats_read_addr_channel_phase_last_duration );
        end
    endtask

    task automatic do_wait_for_stats_read_data_burst_last_duration(  );
        begin
            int _temp_stats_read_data_burst_last_duration;
            _temp_stats_read_data_burst_last_duration = stats_read_data_burst_last_duration;
            wait( _temp_stats_read_data_burst_last_duration != stats_read_data_burst_last_duration );
        end
    endtask

    task automatic do_wait_for_stats_read_channel_phase_last_duration(  );
        begin
            int _temp_stats_read_channel_phase_last_duration;
            _temp_stats_read_channel_phase_last_duration = stats_read_channel_phase_last_duration;
            wait( _temp_stats_read_channel_phase_last_duration != stats_read_channel_phase_last_duration );
        end
    endtask

    task automatic do_wait_for_stats_write_addr_channel_phase_last_duration(  );
        begin
            int _temp_stats_write_addr_channel_phase_last_duration;
            _temp_stats_write_addr_channel_phase_last_duration = stats_write_addr_channel_phase_last_duration;
            wait( _temp_stats_write_addr_channel_phase_last_duration != stats_write_addr_channel_phase_last_duration );
        end
    endtask

    task automatic do_wait_for_stats_write_data_burst_last_duration(  );
        begin
            int _temp_stats_write_data_burst_last_duration;
            _temp_stats_write_data_burst_last_duration = stats_write_data_burst_last_duration;
            wait( _temp_stats_write_data_burst_last_duration != stats_write_data_burst_last_duration );
        end
    endtask

    task automatic do_wait_for_stats_write_channel_phase_last_duration(  );
        begin
            int _temp_stats_write_channel_phase_last_duration;
            _temp_stats_write_channel_phase_last_duration = stats_write_channel_phase_last_duration;
            wait( _temp_stats_write_channel_phase_last_duration != stats_write_channel_phase_last_duration );
        end
    endtask

    task automatic do_wait_for_stats_write_resp_channel_phase_last_duration(  );
        begin
            int _temp_stats_write_resp_channel_phase_last_duration;
            _temp_stats_write_resp_channel_phase_last_duration = stats_write_resp_channel_phase_last_duration;
            wait( _temp_stats_write_resp_channel_phase_last_duration != stats_write_resp_channel_phase_last_duration );
        end
    endtask


    //------------------------------------------------------------------------------
    // Functions to set global variables with write access
    //------------------------------------------------------------------------------

    function automatic void do_set_config_clk_init_value( bit config_clk_init_value_param );
        config_clk_init_value = config_clk_init_value_param;
    endfunction

    function automatic void do_set_config_clk_phase_shift( int config_clk_phase_shift_param );
        config_clk_phase_shift = config_clk_phase_shift_param;
    endfunction

    function automatic void do_set_config_clk_1st_time( int config_clk_1st_time_param );
        config_clk_1st_time = config_clk_1st_time_param;
    endfunction

    function automatic void do_set_config_clk_2nd_time( int config_clk_2nd_time_param );
        config_clk_2nd_time = config_clk_2nd_time_param;
    endfunction

    function automatic void do_set_config_setup_time( int config_setup_time_param );
        config_setup_time = config_setup_time_param;
    endfunction

    function automatic void do_set_config_hold_time( int config_hold_time_param );
        config_hold_time = config_hold_time_param;
    endfunction

    function automatic void do_set_config_max_transaction_time_factor( int unsigned config_max_transaction_time_factor_param );
        config_max_transaction_time_factor = config_max_transaction_time_factor_param;
    endfunction

    function automatic void do_set_config_timeout_max_data_transfer( int config_timeout_max_data_transfer_param );
        config_timeout_max_data_transfer = config_timeout_max_data_transfer_param;
    endfunction

    function automatic void do_set_config_burst_timeout_factor( int unsigned config_burst_timeout_factor_param );
        config_burst_timeout_factor = config_burst_timeout_factor_param;
    endfunction

    function automatic void do_set_config_max_latency_AWVALID_assertion_to_AWREADY( int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
        config_max_latency_AWVALID_assertion_to_AWREADY = config_max_latency_AWVALID_assertion_to_AWREADY_param;
    endfunction

    function automatic void do_set_config_max_latency_ARVALID_assertion_to_ARREADY( int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
        config_max_latency_ARVALID_assertion_to_ARREADY = config_max_latency_ARVALID_assertion_to_ARREADY_param;
    endfunction

    function automatic void do_set_config_max_latency_RVALID_assertion_to_RREADY( int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
        config_max_latency_RVALID_assertion_to_RREADY = config_max_latency_RVALID_assertion_to_RREADY_param;
    endfunction

    function automatic void do_set_config_max_latency_BVALID_assertion_to_BREADY( int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
        config_max_latency_BVALID_assertion_to_BREADY = config_max_latency_BVALID_assertion_to_BREADY_param;
    endfunction

    function automatic void do_set_config_max_latency_WVALID_assertion_to_WREADY( int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
        config_max_latency_WVALID_assertion_to_WREADY = config_max_latency_WVALID_assertion_to_WREADY_param;
    endfunction

    function automatic void do_set_config_write_ctrl_first_ratio( int config_write_ctrl_first_ratio_param );
        config_write_ctrl_first_ratio = config_write_ctrl_first_ratio_param;
    endfunction

    function automatic void do_set_config_write_data_first_ratio( int config_write_data_first_ratio_param );
        config_write_data_first_ratio = config_write_data_first_ratio_param;
    endfunction

    function automatic void do_set_config_write_ctrl_to_data_mintime( int unsigned config_write_ctrl_to_data_mintime_param );
        config_write_ctrl_to_data_mintime = config_write_ctrl_to_data_mintime_param;
    endfunction

    function automatic void do_set_config_write_data_to_ctrl_mintime( int unsigned config_write_data_to_ctrl_mintime_param );
        config_write_data_to_ctrl_mintime = config_write_data_to_ctrl_mintime_param;
    endfunction

    function automatic void do_set_config_master_write_delay( bit config_master_write_delay_param );
        config_master_write_delay = config_master_write_delay_param;
    endfunction

    function automatic void do_set_config_reset_low_clocks( int config_reset_low_clocks_param );
        config_reset_low_clocks = config_reset_low_clocks_param;
    endfunction

    function automatic void do_set_config_reset_hold_time( int config_reset_hold_time_param );
        config_reset_hold_time = config_reset_hold_time_param;
    endfunction

    function automatic void do_set_config_protect_ready( bit config_protect_ready_param );
        config_protect_ready = config_protect_ready_param;
    endfunction

    function automatic void do_set_config_enable_user_sideband( bit config_enable_user_sideband_param );
        config_enable_user_sideband = config_enable_user_sideband_param;
    endfunction

    function automatic void do_set_config_extended_length_enable( bit config_extended_length_enable_param );
        config_extended_length_enable = config_extended_length_enable_param;
    endfunction

    function automatic void do_set_config_enable_burst_reserved_value( bit config_enable_burst_reserved_value_param );
        config_enable_burst_reserved_value = config_enable_burst_reserved_value_param;
    endfunction

    function automatic void do_set_config_enable_lock_reserved_value( bit config_enable_lock_reserved_value_param );
        config_enable_lock_reserved_value = config_enable_lock_reserved_value_param;
    endfunction

    function automatic void do_set_config_enable_cache_reserved_value( bit config_enable_cache_reserved_value_param );
        config_enable_cache_reserved_value = config_enable_cache_reserved_value_param;
    endfunction

    function automatic void do_set_config_enable_all_assertions( bit config_enable_all_assertions_param );
        config_enable_all_assertions = config_enable_all_assertions_param;
    endfunction

    function automatic void do_set_config_enable_assertion( bit [255:0] config_enable_assertion_param );
        config_enable_assertion = config_enable_assertion_param;
    endfunction

    function automatic void do_set_config_enable_assertion_index1( int _this_dot_1, bit  config_enable_assertion_param );
        config_enable_assertion[_this_dot_1] = config_enable_assertion_param;
    endfunction

    function automatic void do_set_config_enable_error( bit [255:0] config_enable_error_param );
        config_enable_error = config_enable_error_param;
    endfunction

    function automatic void do_set_config_enable_error_index1( int _this_dot_1, bit  config_enable_error_param );
        config_enable_error[_this_dot_1] = config_enable_error_param;
    endfunction

    function automatic void do_set_config_enable_errors( bit config_enable_errors_param );
        config_enable_errors = config_enable_errors_param;
    endfunction

    function automatic void do_set_config_enable_all_assertion_errors( bit config_enable_all_assertion_errors_param );
        config_enable_all_assertion_errors = config_enable_all_assertion_errors_param;
    endfunction

    function automatic void do_set_config_abstraction_level( axi_abstraction_level_e config_abstraction_level_param );
        config_abstraction_level = config_abstraction_level_param;
    endfunction

    function automatic void do_set_config_slave_start_addr( bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param );
        config_slave_start_addr = config_slave_start_addr_param;
    endfunction

    function automatic void do_set_config_slave_start_addr_index1( int _this_dot_1, bit  config_slave_start_addr_param );
        config_slave_start_addr[_this_dot_1] = config_slave_start_addr_param;
    endfunction

    function automatic void do_set_config_slave_end_addr( bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param );
        config_slave_end_addr = config_slave_end_addr_param;
    endfunction

    function automatic void do_set_config_slave_end_addr_index1( int _this_dot_1, bit  config_slave_end_addr_param );
        config_slave_end_addr[_this_dot_1] = config_slave_end_addr_param;
    endfunction

    function automatic void do_set_config_enable_slave_addr_range_in_bfm( bit config_enable_slave_addr_range_in_bfm_param );
        config_enable_slave_addr_range_in_bfm = config_enable_slave_addr_range_in_bfm_param;
    endfunction

    function automatic void do_set_config_read_data_reordering_depth( int unsigned config_read_data_reordering_depth_param );
        config_read_data_reordering_depth = config_read_data_reordering_depth_param;
    endfunction

    function automatic void do_set_config_enable_read_data_reordering_depth_in_bfm( bit config_enable_read_data_reordering_depth_in_bfm_param );
        config_enable_read_data_reordering_depth_in_bfm = config_enable_read_data_reordering_depth_in_bfm_param;
    endfunction

    function automatic void do_set_config_awid_wid_mismatch( bit config_awid_wid_mismatch_param );
        config_awid_wid_mismatch = config_awid_wid_mismatch_param;
    endfunction

    function automatic void do_set_config_length_last_mismatch_error( bit config_length_last_mismatch_error_param );
        config_length_last_mismatch_error = config_length_last_mismatch_error_param;
    endfunction

    function automatic void do_set_config_master_error_position( axi_error_e config_master_error_position_param );
        config_master_error_position = config_master_error_position_param;
    endfunction

    function automatic void do_set_dummy_var( axi_assertion_type_e dummy_var_param );
        dummy_var = dummy_var_param;
    endfunction

    function automatic void do_set_config_wlast_length( int config_wlast_length_param );
        config_wlast_length = config_wlast_length_param;
    endfunction

    function automatic void do_set_config_wid_for_awid_not_matching( bit [((AXI_ID_WIDTH) - 1):0]  config_wid_for_awid_not_matching_param );
        config_wid_for_awid_not_matching = config_wid_for_awid_not_matching_param;
    endfunction

    function automatic void do_set_config_wid_for_awid_not_matching_index1( int _this_dot_1, bit  config_wid_for_awid_not_matching_param );
        config_wid_for_awid_not_matching[_this_dot_1] = config_wid_for_awid_not_matching_param;
    endfunction

    function automatic void do_set_config_support_exclusive_access( bit config_support_exclusive_access_param );
        config_support_exclusive_access = config_support_exclusive_access_param;
    endfunction

    function automatic void do_set_config_write_data_interleaving_depth( int config_write_data_interleaving_depth_param );
        config_write_data_interleaving_depth = config_write_data_interleaving_depth_param;
    endfunction

    function automatic void do_set_status_master_error( bit [15:0] status_master_error_param );
        status_master_error = status_master_error_param;
    endfunction

    function automatic void do_set_status_master_error_index1( int _this_dot_1, bit  status_master_error_param );
        status_master_error[_this_dot_1] = status_master_error_param;
    endfunction

    function automatic void do_set_check_total_num_wdata_outstanding( bit check_total_num_wdata_outstanding_param );
        check_total_num_wdata_outstanding = check_total_num_wdata_outstanding_param;
    endfunction

    function automatic void do_set_total_num_wdata_outstanding( int total_num_wdata_outstanding_param );
        total_num_wdata_outstanding = total_num_wdata_outstanding_param;
    endfunction

    function automatic void do_set_check_max_num_wdata_outstanding_per_id( bit check_max_num_wdata_outstanding_per_id_param );
        check_max_num_wdata_outstanding_per_id = check_max_num_wdata_outstanding_per_id_param;
    endfunction

    function automatic void do_set_max_num_wdata_outstanding_per_id( int max_num_wdata_outstanding_per_id_param );
        max_num_wdata_outstanding_per_id = max_num_wdata_outstanding_per_id_param;
    endfunction

    function automatic void do_set_check_max_num_waddr_outstanding_per_id( bit check_max_num_waddr_outstanding_per_id_param );
        check_max_num_waddr_outstanding_per_id = check_max_num_waddr_outstanding_per_id_param;
    endfunction

    function automatic void do_set_max_num_waddr_outstanding_per_id( int max_num_waddr_outstanding_per_id_param );
        max_num_waddr_outstanding_per_id = max_num_waddr_outstanding_per_id_param;
    endfunction

    function automatic void do_set_check_total_num_waddr_outstanding( bit check_total_num_waddr_outstanding_param );
        check_total_num_waddr_outstanding = check_total_num_waddr_outstanding_param;
    endfunction

    function automatic void do_set_total_num_waddr_outstanding( int total_num_waddr_outstanding_param );
        total_num_waddr_outstanding = total_num_waddr_outstanding_param;
    endfunction

    function automatic void do_set_status_outstanding_num_for_waddr( int status_outstanding_num_for_waddr_param );
        status_outstanding_num_for_waddr = status_outstanding_num_for_waddr_param;
    endfunction

    function automatic void do_set_start_finding_outstanding_waddr( bit start_finding_outstanding_waddr_param );
        start_finding_outstanding_waddr = start_finding_outstanding_waddr_param;
    endfunction

    function automatic void do_set_status_outstanding_num_for_wdata( int status_outstanding_num_for_wdata_param );
        status_outstanding_num_for_wdata = status_outstanding_num_for_wdata_param;
    endfunction

    function automatic void do_set_start_finding_outstanding_wdata( bit start_finding_outstanding_wdata_param );
        start_finding_outstanding_wdata = start_finding_outstanding_wdata_param;
    endfunction

    function automatic void do_set_find_waddr_outstanding_for_wid( bit [((AXI_ID_WIDTH) - 1):0]  find_waddr_outstanding_for_wid_param );
        find_waddr_outstanding_for_wid = find_waddr_outstanding_for_wid_param;
    endfunction

    function automatic void do_set_find_waddr_outstanding_for_wid_index1( int _this_dot_1, bit  find_waddr_outstanding_for_wid_param );
        find_waddr_outstanding_for_wid[_this_dot_1] = find_waddr_outstanding_for_wid_param;
    endfunction

    function automatic void do_set_find_wdata_outstanding_for_wid( bit [((AXI_ID_WIDTH) - 1):0]  find_wdata_outstanding_for_wid_param );
        find_wdata_outstanding_for_wid = find_wdata_outstanding_for_wid_param;
    endfunction

    function automatic void do_set_find_wdata_outstanding_for_wid_index1( int _this_dot_1, bit  find_wdata_outstanding_for_wid_param );
        find_wdata_outstanding_for_wid[_this_dot_1] = find_wdata_outstanding_for_wid_param;
    endfunction

    function automatic void do_set_change_in_wdata_outstanding_per_id( bit change_in_wdata_outstanding_per_id_param );
        change_in_wdata_outstanding_per_id = change_in_wdata_outstanding_per_id_param;
    endfunction

    function automatic void do_set_start_finding_change_in_wdata( bit start_finding_change_in_wdata_param );
        start_finding_change_in_wdata = start_finding_change_in_wdata_param;
    endfunction

    function automatic void do_set_find_change_in_wdata_outstanding_for_wid( bit [((AXI_ID_WIDTH) - 1):0]  find_change_in_wdata_outstanding_for_wid_param );
        find_change_in_wdata_outstanding_for_wid = find_change_in_wdata_outstanding_for_wid_param;
    endfunction

    function automatic void do_set_find_change_in_wdata_outstanding_for_wid_index1( int _this_dot_1, bit  find_change_in_wdata_outstanding_for_wid_param );
        find_change_in_wdata_outstanding_for_wid[_this_dot_1] = find_change_in_wdata_outstanding_for_wid_param;
    endfunction

    function automatic void do_set_config_max_outstanding_wr( int config_max_outstanding_wr_param );
        config_max_outstanding_wr = config_max_outstanding_wr_param;
    endfunction

    function automatic void do_set_config_max_outstanding_rd( int config_max_outstanding_rd_param );
        config_max_outstanding_rd = config_max_outstanding_rd_param;
    endfunction

    function automatic void do_set_config_error_on_deleted_valid_cycles( bit config_error_on_deleted_valid_cycles_param );
        config_error_on_deleted_valid_cycles = config_error_on_deleted_valid_cycles_param;
    endfunction

    function automatic void do_set_config_stats_enable( bit config_stats_enable_param );
        config_stats_enable = config_stats_enable_param;
    endfunction

    function automatic void do_set_config_stats_enable_AXI_read_occupancy( bit config_stats_enable_AXI_read_occupancy_param );
        config_stats_enable_AXI_read_occupancy = config_stats_enable_AXI_read_occupancy_param;
    endfunction

    function automatic void do_set_config_stats_enable_AXI_write_occupancy( bit config_stats_enable_AXI_write_occupancy_param );
        config_stats_enable_AXI_write_occupancy = config_stats_enable_AXI_write_occupancy_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_data_occupancy( bit config_stats_enable_read_data_occupancy_param );
        config_stats_enable_read_data_occupancy = config_stats_enable_read_data_occupancy_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_data_occupancy( bit config_stats_enable_write_data_occupancy_param );
        config_stats_enable_write_data_occupancy = config_stats_enable_write_data_occupancy_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_latency( bit config_stats_enable_read_latency_param );
        config_stats_enable_read_latency = config_stats_enable_read_latency_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_latency( bit config_stats_enable_write_latency_param );
        config_stats_enable_write_latency = config_stats_enable_write_latency_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_address_waits( bit config_stats_enable_read_address_waits_param );
        config_stats_enable_read_address_waits = config_stats_enable_read_address_waits_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_data_waits( bit config_stats_enable_read_data_waits_param );
        config_stats_enable_read_data_waits = config_stats_enable_read_data_waits_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_address_waits( bit config_stats_enable_write_address_waits_param );
        config_stats_enable_write_address_waits = config_stats_enable_write_address_waits_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_data_waits( bit config_stats_enable_write_data_waits_param );
        config_stats_enable_write_data_waits = config_stats_enable_write_data_waits_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_response_waits( bit config_stats_enable_write_response_waits_param );
        config_stats_enable_write_response_waits = config_stats_enable_write_response_waits_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_bandwidth( bit config_stats_enable_read_bandwidth_param );
        config_stats_enable_read_bandwidth = config_stats_enable_read_bandwidth_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_bandwidth( bit config_stats_enable_write_bandwidth_param );
        config_stats_enable_write_bandwidth = config_stats_enable_write_bandwidth_param;
    endfunction

    function automatic void do_set_config_stats_AXI_read_occupancy_step( int config_stats_AXI_read_occupancy_step_param );
        config_stats_AXI_read_occupancy_step = config_stats_AXI_read_occupancy_step_param;
    endfunction

    function automatic void do_set_config_stats_AXI_read_occupancy_multiple( int config_stats_AXI_read_occupancy_multiple_param );
        config_stats_AXI_read_occupancy_multiple = config_stats_AXI_read_occupancy_multiple_param;
    endfunction

    function automatic void do_set_config_stats_AXI_write_occupancy_step( int config_stats_AXI_write_occupancy_step_param );
        config_stats_AXI_write_occupancy_step = config_stats_AXI_write_occupancy_step_param;
    endfunction

    function automatic void do_set_config_stats_AXI_write_occupancy_multiple( int config_stats_AXI_write_occupancy_multiple_param );
        config_stats_AXI_write_occupancy_multiple = config_stats_AXI_write_occupancy_multiple_param;
    endfunction

    function automatic void do_set_config_stats_read_data_occupancy_step( int config_stats_read_data_occupancy_step_param );
        config_stats_read_data_occupancy_step = config_stats_read_data_occupancy_step_param;
    endfunction

    function automatic void do_set_config_stats_read_data_occupancy_multiple( int config_stats_read_data_occupancy_multiple_param );
        config_stats_read_data_occupancy_multiple = config_stats_read_data_occupancy_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_data_occupancy_step( int config_stats_write_data_occupancy_step_param );
        config_stats_write_data_occupancy_step = config_stats_write_data_occupancy_step_param;
    endfunction

    function automatic void do_set_config_stats_write_data_occupancy_multiple( int config_stats_write_data_occupancy_multiple_param );
        config_stats_write_data_occupancy_multiple = config_stats_write_data_occupancy_multiple_param;
    endfunction

    function automatic void do_set_config_stats_read_bandwidth_step( int config_stats_read_bandwidth_step_param );
        config_stats_read_bandwidth_step = config_stats_read_bandwidth_step_param;
    endfunction

    function automatic void do_set_config_stats_read_bandwidth_multiple( int config_stats_read_bandwidth_multiple_param );
        config_stats_read_bandwidth_multiple = config_stats_read_bandwidth_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_bandwidth_step( int config_stats_write_bandwidth_step_param );
        config_stats_write_bandwidth_step = config_stats_write_bandwidth_step_param;
    endfunction

    function automatic void do_set_config_stats_write_bandwidth_multiple( int config_stats_write_bandwidth_multiple_param );
        config_stats_write_bandwidth_multiple = config_stats_write_bandwidth_multiple_param;
    endfunction

    function automatic void do_set_config_stats_read_latency_step( int config_stats_read_latency_step_param );
        config_stats_read_latency_step = config_stats_read_latency_step_param;
    endfunction

    function automatic void do_set_config_stats_read_latency_multiple( int config_stats_read_latency_multiple_param );
        config_stats_read_latency_multiple = config_stats_read_latency_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_latency_step( int config_stats_write_latency_step_param );
        config_stats_write_latency_step = config_stats_write_latency_step_param;
    endfunction

    function automatic void do_set_config_stats_write_latency_multiple( int config_stats_write_latency_multiple_param );
        config_stats_write_latency_multiple = config_stats_write_latency_multiple_param;
    endfunction

    function automatic void do_set_config_stats_read_address_waits_step( int config_stats_read_address_waits_step_param );
        config_stats_read_address_waits_step = config_stats_read_address_waits_step_param;
    endfunction

    function automatic void do_set_config_stats_read_address_waits_multiple( int config_stats_read_address_waits_multiple_param );
        config_stats_read_address_waits_multiple = config_stats_read_address_waits_multiple_param;
    endfunction

    function automatic void do_set_config_stats_read_data_waits_step( int config_stats_read_data_waits_step_param );
        config_stats_read_data_waits_step = config_stats_read_data_waits_step_param;
    endfunction

    function automatic void do_set_config_stats_read_data_waits_multiple( int config_stats_read_data_waits_multiple_param );
        config_stats_read_data_waits_multiple = config_stats_read_data_waits_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_address_waits_step( int config_stats_write_address_waits_step_param );
        config_stats_write_address_waits_step = config_stats_write_address_waits_step_param;
    endfunction

    function automatic void do_set_config_stats_write_address_waits_multiple( int config_stats_write_address_waits_multiple_param );
        config_stats_write_address_waits_multiple = config_stats_write_address_waits_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_data_waits_step( int config_stats_write_data_waits_step_param );
        config_stats_write_data_waits_step = config_stats_write_data_waits_step_param;
    endfunction

    function automatic void do_set_config_stats_write_data_waits_multiple( int config_stats_write_data_waits_multiple_param );
        config_stats_write_data_waits_multiple = config_stats_write_data_waits_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_response_waits_step( int config_stats_write_response_waits_step_param );
        config_stats_write_response_waits_step = config_stats_write_response_waits_step_param;
    endfunction

    function automatic void do_set_config_stats_write_response_waits_multiple( int config_stats_write_response_waits_multiple_param );
        config_stats_write_response_waits_multiple = config_stats_write_response_waits_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Functions to get global variables with read access
    //------------------------------------------------------------------------------

    function automatic bit do_get_config_clk_init_value(  );
        return config_clk_init_value;
    endfunction

    function automatic int do_get_config_clk_phase_shift(  );
        return config_clk_phase_shift;
    endfunction

    function automatic int do_get_config_clk_1st_time(  );
        return config_clk_1st_time;
    endfunction

    function automatic int do_get_config_clk_2nd_time(  );
        return config_clk_2nd_time;
    endfunction

    function automatic int do_get_config_setup_time(  );
        return config_setup_time;
    endfunction

    function automatic int do_get_config_hold_time(  );
        return config_hold_time;
    endfunction

    function automatic int unsigned do_get_config_max_transaction_time_factor(  );
        return config_max_transaction_time_factor;
    endfunction

    function automatic int do_get_config_timeout_max_data_transfer(  );
        return config_timeout_max_data_transfer;
    endfunction

    function automatic int unsigned do_get_config_burst_timeout_factor(  );
        return config_burst_timeout_factor;
    endfunction

    function automatic int unsigned do_get_config_max_latency_AWVALID_assertion_to_AWREADY(  );
        return config_max_latency_AWVALID_assertion_to_AWREADY;
    endfunction

    function automatic int unsigned do_get_config_max_latency_ARVALID_assertion_to_ARREADY(  );
        return config_max_latency_ARVALID_assertion_to_ARREADY;
    endfunction

    function automatic int unsigned do_get_config_max_latency_RVALID_assertion_to_RREADY(  );
        return config_max_latency_RVALID_assertion_to_RREADY;
    endfunction

    function automatic int unsigned do_get_config_max_latency_BVALID_assertion_to_BREADY(  );
        return config_max_latency_BVALID_assertion_to_BREADY;
    endfunction

    function automatic int unsigned do_get_config_max_latency_WVALID_assertion_to_WREADY(  );
        return config_max_latency_WVALID_assertion_to_WREADY;
    endfunction

    function automatic int do_get_config_write_ctrl_first_ratio(  );
        return config_write_ctrl_first_ratio;
    endfunction

    function automatic int do_get_config_write_data_first_ratio(  );
        return config_write_data_first_ratio;
    endfunction

    function automatic int unsigned do_get_config_write_ctrl_to_data_mintime(  );
        return config_write_ctrl_to_data_mintime;
    endfunction

    function automatic int unsigned do_get_config_write_data_to_ctrl_mintime(  );
        return config_write_data_to_ctrl_mintime;
    endfunction

    function automatic bit do_get_config_master_write_delay(  );
        return config_master_write_delay;
    endfunction

    function automatic int do_get_config_reset_low_clocks(  );
        return config_reset_low_clocks;
    endfunction

    function automatic int do_get_config_reset_hold_time(  );
        return config_reset_hold_time;
    endfunction

    function automatic bit do_get_config_protect_ready(  );
        return config_protect_ready;
    endfunction

    function automatic bit do_get_config_enable_user_sideband(  );
        return config_enable_user_sideband;
    endfunction

    function automatic bit do_get_config_extended_length_enable(  );
        return config_extended_length_enable;
    endfunction

    function automatic bit do_get_config_enable_burst_reserved_value(  );
        return config_enable_burst_reserved_value;
    endfunction

    function automatic bit do_get_config_enable_lock_reserved_value(  );
        return config_enable_lock_reserved_value;
    endfunction

    function automatic bit do_get_config_enable_cache_reserved_value(  );
        return config_enable_cache_reserved_value;
    endfunction

    function automatic bit do_get_config_enable_all_assertions(  );
        return config_enable_all_assertions;
    endfunction

    function automatic bit [255:0]  do_get_config_enable_assertion(  );
        return config_enable_assertion;
    endfunction

    function automatic bit   do_get_config_enable_assertion_index1( int _this_dot_1 );
        return config_enable_assertion[_this_dot_1];
    endfunction

    function automatic bit [255:0]  do_get_config_enable_error(  );
        return config_enable_error;
    endfunction

    function automatic bit   do_get_config_enable_error_index1( int _this_dot_1 );
        return config_enable_error[_this_dot_1];
    endfunction

    function automatic bit do_get_config_enable_errors(  );
        return config_enable_errors;
    endfunction

    function automatic bit do_get_config_enable_all_assertion_errors(  );
        return config_enable_all_assertion_errors;
    endfunction

    function automatic axi_abstraction_level_e do_get_config_abstraction_level(  );
        return config_abstraction_level;
    endfunction

    function automatic bit [((AXI_ADDRESS_WIDTH) - 1):0]   do_get_config_slave_start_addr(  );
        return config_slave_start_addr;
    endfunction

    function automatic bit   do_get_config_slave_start_addr_index1( int _this_dot_1 );
        return config_slave_start_addr[_this_dot_1];
    endfunction

    function automatic bit [((AXI_ADDRESS_WIDTH) - 1):0]   do_get_config_slave_end_addr(  );
        return config_slave_end_addr;
    endfunction

    function automatic bit   do_get_config_slave_end_addr_index1( int _this_dot_1 );
        return config_slave_end_addr[_this_dot_1];
    endfunction

    function automatic bit do_get_config_enable_slave_addr_range_in_bfm(  );
        return config_enable_slave_addr_range_in_bfm;
    endfunction

    function automatic int unsigned do_get_config_read_data_reordering_depth(  );
        return config_read_data_reordering_depth;
    endfunction

    function automatic bit do_get_config_enable_read_data_reordering_depth_in_bfm(  );
        return config_enable_read_data_reordering_depth_in_bfm;
    endfunction

    function automatic bit do_get_config_awid_wid_mismatch(  );
        return config_awid_wid_mismatch;
    endfunction

    function automatic bit do_get_config_length_last_mismatch_error(  );
        return config_length_last_mismatch_error;
    endfunction

    function automatic axi_error_e do_get_config_master_error_position(  );
        return config_master_error_position;
    endfunction

    function automatic axi_assertion_type_e do_get_dummy_var(  );
        return dummy_var;
    endfunction

    function automatic int do_get_config_wlast_length(  );
        return config_wlast_length;
    endfunction

    function automatic bit [((AXI_ID_WIDTH) - 1):0]   do_get_config_wid_for_awid_not_matching(  );
        return config_wid_for_awid_not_matching;
    endfunction

    function automatic bit   do_get_config_wid_for_awid_not_matching_index1( int _this_dot_1 );
        return config_wid_for_awid_not_matching[_this_dot_1];
    endfunction

    function automatic bit do_get_config_support_exclusive_access(  );
        return config_support_exclusive_access;
    endfunction

    function automatic int do_get_config_write_data_interleaving_depth(  );
        return config_write_data_interleaving_depth;
    endfunction

    function automatic bit [15:0]  do_get_status_master_error(  );
        return status_master_error;
    endfunction

    function automatic bit   do_get_status_master_error_index1( int _this_dot_1 );
        return status_master_error[_this_dot_1];
    endfunction

    function automatic int do_get_status_num_reads_waiting_for_resp(  );
        return status_num_reads_waiting_for_resp;
    endfunction

    function automatic int do_get_status_num_writes_waiting_for_response(  );
        return status_num_writes_waiting_for_response;
    endfunction

    function automatic bit do_get_check_total_num_wdata_outstanding(  );
        return check_total_num_wdata_outstanding;
    endfunction

    function automatic int do_get_total_num_wdata_outstanding(  );
        return total_num_wdata_outstanding;
    endfunction

    function automatic bit do_get_check_max_num_wdata_outstanding_per_id(  );
        return check_max_num_wdata_outstanding_per_id;
    endfunction

    function automatic int do_get_max_num_wdata_outstanding_per_id(  );
        return max_num_wdata_outstanding_per_id;
    endfunction

    function automatic bit do_get_check_max_num_waddr_outstanding_per_id(  );
        return check_max_num_waddr_outstanding_per_id;
    endfunction

    function automatic int do_get_max_num_waddr_outstanding_per_id(  );
        return max_num_waddr_outstanding_per_id;
    endfunction

    function automatic bit do_get_check_total_num_waddr_outstanding(  );
        return check_total_num_waddr_outstanding;
    endfunction

    function automatic int do_get_total_num_waddr_outstanding(  );
        return total_num_waddr_outstanding;
    endfunction

    function automatic int do_get_status_outstanding_num_for_waddr(  );
        return status_outstanding_num_for_waddr;
    endfunction

    function automatic bit do_get_start_finding_outstanding_waddr(  );
        return start_finding_outstanding_waddr;
    endfunction

    function automatic int do_get_status_outstanding_num_for_wdata(  );
        return status_outstanding_num_for_wdata;
    endfunction

    function automatic bit do_get_start_finding_outstanding_wdata(  );
        return start_finding_outstanding_wdata;
    endfunction

    function automatic bit [((AXI_ID_WIDTH) - 1):0]   do_get_find_waddr_outstanding_for_wid(  );
        return find_waddr_outstanding_for_wid;
    endfunction

    function automatic bit   do_get_find_waddr_outstanding_for_wid_index1( int _this_dot_1 );
        return find_waddr_outstanding_for_wid[_this_dot_1];
    endfunction

    function automatic bit [((AXI_ID_WIDTH) - 1):0]   do_get_find_wdata_outstanding_for_wid(  );
        return find_wdata_outstanding_for_wid;
    endfunction

    function automatic bit   do_get_find_wdata_outstanding_for_wid_index1( int _this_dot_1 );
        return find_wdata_outstanding_for_wid[_this_dot_1];
    endfunction

    function automatic bit do_get_change_in_wdata_outstanding_per_id(  );
        return change_in_wdata_outstanding_per_id;
    endfunction

    function automatic bit do_get_start_finding_change_in_wdata(  );
        return start_finding_change_in_wdata;
    endfunction

    function automatic bit [((AXI_ID_WIDTH) - 1):0]   do_get_find_change_in_wdata_outstanding_for_wid(  );
        return find_change_in_wdata_outstanding_for_wid;
    endfunction

    function automatic bit   do_get_find_change_in_wdata_outstanding_for_wid_index1( int _this_dot_1 );
        return find_change_in_wdata_outstanding_for_wid[_this_dot_1];
    endfunction

    function automatic int do_get_config_max_outstanding_wr(  );
        return config_max_outstanding_wr;
    endfunction

    function automatic int do_get_config_max_outstanding_rd(  );
        return config_max_outstanding_rd;
    endfunction

    function automatic bit do_get_config_error_on_deleted_valid_cycles(  );
        return config_error_on_deleted_valid_cycles;
    endfunction

    function automatic bit do_get_config_stats_enable(  );
        return config_stats_enable;
    endfunction

    function automatic bit do_get_config_stats_enable_AXI_read_occupancy(  );
        return config_stats_enable_AXI_read_occupancy;
    endfunction

    function automatic bit do_get_config_stats_enable_AXI_write_occupancy(  );
        return config_stats_enable_AXI_write_occupancy;
    endfunction

    function automatic bit do_get_config_stats_enable_read_data_occupancy(  );
        return config_stats_enable_read_data_occupancy;
    endfunction

    function automatic bit do_get_config_stats_enable_write_data_occupancy(  );
        return config_stats_enable_write_data_occupancy;
    endfunction

    function automatic bit do_get_config_stats_enable_read_latency(  );
        return config_stats_enable_read_latency;
    endfunction

    function automatic bit do_get_config_stats_enable_write_latency(  );
        return config_stats_enable_write_latency;
    endfunction

    function automatic bit do_get_config_stats_enable_read_address_waits(  );
        return config_stats_enable_read_address_waits;
    endfunction

    function automatic bit do_get_config_stats_enable_read_data_waits(  );
        return config_stats_enable_read_data_waits;
    endfunction

    function automatic bit do_get_config_stats_enable_write_address_waits(  );
        return config_stats_enable_write_address_waits;
    endfunction

    function automatic bit do_get_config_stats_enable_write_data_waits(  );
        return config_stats_enable_write_data_waits;
    endfunction

    function automatic bit do_get_config_stats_enable_write_response_waits(  );
        return config_stats_enable_write_response_waits;
    endfunction

    function automatic bit do_get_config_stats_enable_read_bandwidth(  );
        return config_stats_enable_read_bandwidth;
    endfunction

    function automatic bit do_get_config_stats_enable_write_bandwidth(  );
        return config_stats_enable_write_bandwidth;
    endfunction

    function automatic int do_get_config_stats_AXI_read_occupancy_step(  );
        return config_stats_AXI_read_occupancy_step;
    endfunction

    function automatic int do_get_config_stats_AXI_read_occupancy_multiple(  );
        return config_stats_AXI_read_occupancy_multiple;
    endfunction

    function automatic bit do_get_stats_AXI_read_active(  );
        return stats_AXI_read_active;
    endfunction

    function automatic int do_get_stats_AXI_read_occupancy_sw(  );
        return stats_AXI_read_occupancy_sw;
    endfunction

    function automatic int do_get_stats_AXI_read_occupancy_sw_updated(  );
        return stats_AXI_read_occupancy_sw_updated;
    endfunction

    function automatic int do_get_stats_AXI_read_idle_sw(  );
        return stats_AXI_read_idle_sw;
    endfunction

    function automatic int do_get_stats_AXI_read_occupancy_min(  );
        return stats_AXI_read_occupancy_min;
    endfunction

    function automatic int do_get_stats_AXI_read_idle_min(  );
        return stats_AXI_read_idle_min;
    endfunction

    function automatic int do_get_stats_AXI_read_occupancy_max(  );
        return stats_AXI_read_occupancy_max;
    endfunction

    function automatic int do_get_stats_AXI_read_idle_max(  );
        return stats_AXI_read_idle_max;
    endfunction

    function automatic int do_get_stats_AXI_read_occupancy_mean(  );
        return stats_AXI_read_occupancy_mean;
    endfunction

    function automatic int do_get_stats_AXI_read_idle_mean(  );
        return stats_AXI_read_idle_mean;
    endfunction

    function automatic int do_get_config_stats_AXI_write_occupancy_step(  );
        return config_stats_AXI_write_occupancy_step;
    endfunction

    function automatic int do_get_config_stats_AXI_write_occupancy_multiple(  );
        return config_stats_AXI_write_occupancy_multiple;
    endfunction

    function automatic bit do_get_stats_AXI_write_active(  );
        return stats_AXI_write_active;
    endfunction

    function automatic int do_get_stats_AXI_write_occupancy_sw(  );
        return stats_AXI_write_occupancy_sw;
    endfunction

    function automatic int do_get_stats_AXI_write_occupancy_sw_updated(  );
        return stats_AXI_write_occupancy_sw_updated;
    endfunction

    function automatic int do_get_stats_AXI_write_idle_sw(  );
        return stats_AXI_write_idle_sw;
    endfunction

    function automatic int do_get_stats_AXI_write_occupancy_min(  );
        return stats_AXI_write_occupancy_min;
    endfunction

    function automatic int do_get_stats_AXI_write_idle_min(  );
        return stats_AXI_write_idle_min;
    endfunction

    function automatic int do_get_stats_AXI_write_occupancy_max(  );
        return stats_AXI_write_occupancy_max;
    endfunction

    function automatic int do_get_stats_AXI_write_idle_max(  );
        return stats_AXI_write_idle_max;
    endfunction

    function automatic int do_get_stats_AXI_write_occupancy_mean(  );
        return stats_AXI_write_occupancy_mean;
    endfunction

    function automatic int do_get_stats_AXI_write_idle_mean(  );
        return stats_AXI_write_idle_mean;
    endfunction

    function automatic int do_get_config_stats_read_data_occupancy_step(  );
        return config_stats_read_data_occupancy_step;
    endfunction

    function automatic int do_get_config_stats_read_data_occupancy_multiple(  );
        return config_stats_read_data_occupancy_multiple;
    endfunction

    function automatic int do_get_stats_read_data_occupancy_sw(  );
        return stats_read_data_occupancy_sw;
    endfunction

    function automatic int do_get_stats_read_data_occupancy_sw_updated(  );
        return stats_read_data_occupancy_sw_updated;
    endfunction

    function automatic int do_get_stats_read_data_idle_sw(  );
        return stats_read_data_idle_sw;
    endfunction

    function automatic int do_get_stats_read_data_occupancy_min(  );
        return stats_read_data_occupancy_min;
    endfunction

    function automatic int do_get_stats_read_data_idle_min(  );
        return stats_read_data_idle_min;
    endfunction

    function automatic int do_get_stats_read_data_occupancy_max(  );
        return stats_read_data_occupancy_max;
    endfunction

    function automatic int do_get_stats_read_data_idle_max(  );
        return stats_read_data_idle_max;
    endfunction

    function automatic int do_get_stats_read_data_occupancy_mean(  );
        return stats_read_data_occupancy_mean;
    endfunction

    function automatic int do_get_stats_read_data_idle_mean(  );
        return stats_read_data_idle_mean;
    endfunction

    function automatic int do_get_config_stats_write_data_occupancy_step(  );
        return config_stats_write_data_occupancy_step;
    endfunction

    function automatic int do_get_config_stats_write_data_occupancy_multiple(  );
        return config_stats_write_data_occupancy_multiple;
    endfunction

    function automatic int do_get_stats_write_data_occupancy_sw(  );
        return stats_write_data_occupancy_sw;
    endfunction

    function automatic int do_get_stats_write_data_occupancy_sw_updated(  );
        return stats_write_data_occupancy_sw_updated;
    endfunction

    function automatic int do_get_stats_write_data_idle_sw(  );
        return stats_write_data_idle_sw;
    endfunction

    function automatic int do_get_stats_write_data_occupancy_min(  );
        return stats_write_data_occupancy_min;
    endfunction

    function automatic int do_get_stats_write_data_idle_min(  );
        return stats_write_data_idle_min;
    endfunction

    function automatic int do_get_stats_write_data_occupancy_max(  );
        return stats_write_data_occupancy_max;
    endfunction

    function automatic int do_get_stats_write_data_idle_max(  );
        return stats_write_data_idle_max;
    endfunction

    function automatic int do_get_stats_write_data_occupancy_mean(  );
        return stats_write_data_occupancy_mean;
    endfunction

    function automatic int do_get_stats_write_data_idle_mean(  );
        return stats_write_data_idle_mean;
    endfunction

    function automatic int do_get_config_stats_read_bandwidth_step(  );
        return config_stats_read_bandwidth_step;
    endfunction

    function automatic int do_get_config_stats_read_bandwidth_multiple(  );
        return config_stats_read_bandwidth_multiple;
    endfunction

    function automatic int do_get_stats_read_bandwidth_sw(  );
        return stats_read_bandwidth_sw;
    endfunction

    function automatic int do_get_stats_read_bandwidth_sw_updated(  );
        return stats_read_bandwidth_sw_updated;
    endfunction

    function automatic int do_get_stats_read_bandwidth_min(  );
        return stats_read_bandwidth_min;
    endfunction

    function automatic int do_get_stats_read_bandwidth_max(  );
        return stats_read_bandwidth_max;
    endfunction

    function automatic int do_get_stats_read_bandwidth_mean(  );
        return stats_read_bandwidth_mean;
    endfunction

    function automatic int do_get_config_stats_write_bandwidth_step(  );
        return config_stats_write_bandwidth_step;
    endfunction

    function automatic int do_get_config_stats_write_bandwidth_multiple(  );
        return config_stats_write_bandwidth_multiple;
    endfunction

    function automatic int do_get_stats_write_bandwidth_sw(  );
        return stats_write_bandwidth_sw;
    endfunction

    function automatic int do_get_stats_write_bandwidth_sw_updated(  );
        return stats_write_bandwidth_sw_updated;
    endfunction

    function automatic int do_get_stats_write_bandwidth_min(  );
        return stats_write_bandwidth_min;
    endfunction

    function automatic int do_get_stats_write_bandwidth_max(  );
        return stats_write_bandwidth_max;
    endfunction

    function automatic int do_get_stats_write_bandwidth_mean(  );
        return stats_write_bandwidth_mean;
    endfunction

    function automatic int do_get_config_stats_read_latency_step(  );
        return config_stats_read_latency_step;
    endfunction

    function automatic int do_get_config_stats_read_latency_multiple(  );
        return config_stats_read_latency_multiple;
    endfunction

    function automatic int do_get_stats_read_latency_sw_updated(  );
        return stats_read_latency_sw_updated;
    endfunction

    function automatic int do_get_stats_read_address_data_latency_inst(  );
        return stats_read_address_data_latency_inst;
    endfunction

    function automatic int do_get_stats_read_address_data_latency_sw(  );
        return stats_read_address_data_latency_sw;
    endfunction

    function automatic int do_get_stats_read_address_data_latency_min(  );
        return stats_read_address_data_latency_min;
    endfunction

    function automatic int do_get_stats_read_address_data_latency_max(  );
        return stats_read_address_data_latency_max;
    endfunction

    function automatic int do_get_stats_read_address_data_latency_mean(  );
        return stats_read_address_data_latency_mean;
    endfunction

    function automatic int do_get_stats_read_address_address_latency_inst(  );
        return stats_read_address_address_latency_inst;
    endfunction

    function automatic int do_get_stats_read_address_address_latency_sw(  );
        return stats_read_address_address_latency_sw;
    endfunction

    function automatic int do_get_stats_read_address_address_latency_min(  );
        return stats_read_address_address_latency_min;
    endfunction

    function automatic int do_get_stats_read_address_address_latency_max(  );
        return stats_read_address_address_latency_max;
    endfunction

    function automatic int do_get_stats_read_address_address_latency_mean(  );
        return stats_read_address_address_latency_mean;
    endfunction

    function automatic int do_get_config_stats_write_latency_step(  );
        return config_stats_write_latency_step;
    endfunction

    function automatic int do_get_config_stats_write_latency_multiple(  );
        return config_stats_write_latency_multiple;
    endfunction

    function automatic int do_get_stats_write_latency_sw_updated(  );
        return stats_write_latency_sw_updated;
    endfunction

    function automatic int do_get_stats_write_address_data_latency_inst(  );
        return stats_write_address_data_latency_inst;
    endfunction

    function automatic int do_get_stats_write_address_data_latency_sw(  );
        return stats_write_address_data_latency_sw;
    endfunction

    function automatic int do_get_stats_write_address_data_latency_min(  );
        return stats_write_address_data_latency_min;
    endfunction

    function automatic int do_get_stats_write_address_data_latency_max(  );
        return stats_write_address_data_latency_max;
    endfunction

    function automatic int do_get_stats_write_address_data_latency_mean(  );
        return stats_write_address_data_latency_mean;
    endfunction

    function automatic int do_get_stats_write_data_response_latency_inst(  );
        return stats_write_data_response_latency_inst;
    endfunction

    function automatic int do_get_stats_write_data_response_latency_sw(  );
        return stats_write_data_response_latency_sw;
    endfunction

    function automatic int do_get_stats_write_data_response_latency_min(  );
        return stats_write_data_response_latency_min;
    endfunction

    function automatic int do_get_stats_write_data_response_latency_max(  );
        return stats_write_data_response_latency_max;
    endfunction

    function automatic int do_get_stats_write_data_response_latency_mean(  );
        return stats_write_data_response_latency_mean;
    endfunction

    function automatic int do_get_stats_write_address_address_latency_inst(  );
        return stats_write_address_address_latency_inst;
    endfunction

    function automatic int do_get_stats_write_address_address_latency_sw(  );
        return stats_write_address_address_latency_sw;
    endfunction

    function automatic int do_get_stats_write_address_address_latency_min(  );
        return stats_write_address_address_latency_min;
    endfunction

    function automatic int do_get_stats_write_address_address_latency_max(  );
        return stats_write_address_address_latency_max;
    endfunction

    function automatic int do_get_stats_write_address_address_latency_mean(  );
        return stats_write_address_address_latency_mean;
    endfunction

    function automatic int do_get_config_stats_read_address_waits_step(  );
        return config_stats_read_address_waits_step;
    endfunction

    function automatic int do_get_config_stats_read_address_waits_multiple(  );
        return config_stats_read_address_waits_multiple;
    endfunction

    function automatic int do_get_stats_read_address_waits_inst(  );
        return stats_read_address_waits_inst;
    endfunction

    function automatic int do_get_stats_read_address_waits_sw(  );
        return stats_read_address_waits_sw;
    endfunction

    function automatic int do_get_stats_read_address_waits_sw_updated(  );
        return stats_read_address_waits_sw_updated;
    endfunction

    function automatic int do_get_stats_read_address_waits_min(  );
        return stats_read_address_waits_min;
    endfunction

    function automatic int do_get_stats_read_address_waits_max(  );
        return stats_read_address_waits_max;
    endfunction

    function automatic int do_get_stats_read_address_waits_mean(  );
        return stats_read_address_waits_mean;
    endfunction

    function automatic int do_get_config_stats_read_data_waits_step(  );
        return config_stats_read_data_waits_step;
    endfunction

    function automatic int do_get_config_stats_read_data_waits_multiple(  );
        return config_stats_read_data_waits_multiple;
    endfunction

    function automatic int do_get_stats_read_data_waits_inst(  );
        return stats_read_data_waits_inst;
    endfunction

    function automatic int do_get_stats_read_data_waits_sw(  );
        return stats_read_data_waits_sw;
    endfunction

    function automatic int do_get_stats_read_data_waits_sw_updated(  );
        return stats_read_data_waits_sw_updated;
    endfunction

    function automatic int do_get_stats_read_data_waits_min(  );
        return stats_read_data_waits_min;
    endfunction

    function automatic int do_get_stats_read_data_waits_max(  );
        return stats_read_data_waits_max;
    endfunction

    function automatic int do_get_stats_read_data_waits_mean(  );
        return stats_read_data_waits_mean;
    endfunction

    function automatic int do_get_config_stats_write_address_waits_step(  );
        return config_stats_write_address_waits_step;
    endfunction

    function automatic int do_get_config_stats_write_address_waits_multiple(  );
        return config_stats_write_address_waits_multiple;
    endfunction

    function automatic int do_get_stats_write_address_waits_inst(  );
        return stats_write_address_waits_inst;
    endfunction

    function automatic int do_get_stats_write_address_waits_sw(  );
        return stats_write_address_waits_sw;
    endfunction

    function automatic int do_get_stats_write_address_waits_sw_updated(  );
        return stats_write_address_waits_sw_updated;
    endfunction

    function automatic int do_get_stats_write_address_waits_min(  );
        return stats_write_address_waits_min;
    endfunction

    function automatic int do_get_stats_write_address_waits_max(  );
        return stats_write_address_waits_max;
    endfunction

    function automatic int do_get_stats_write_address_waits_mean(  );
        return stats_write_address_waits_mean;
    endfunction

    function automatic int do_get_config_stats_write_data_waits_step(  );
        return config_stats_write_data_waits_step;
    endfunction

    function automatic int do_get_config_stats_write_data_waits_multiple(  );
        return config_stats_write_data_waits_multiple;
    endfunction

    function automatic int do_get_stats_write_data_waits_inst(  );
        return stats_write_data_waits_inst;
    endfunction

    function automatic int do_get_stats_write_data_waits_sw(  );
        return stats_write_data_waits_sw;
    endfunction

    function automatic int do_get_stats_write_data_waits_sw_updated(  );
        return stats_write_data_waits_sw_updated;
    endfunction

    function automatic int do_get_stats_write_data_waits_min(  );
        return stats_write_data_waits_min;
    endfunction

    function automatic int do_get_stats_write_data_waits_max(  );
        return stats_write_data_waits_max;
    endfunction

    function automatic int do_get_stats_write_data_waits_mean(  );
        return stats_write_data_waits_mean;
    endfunction

    function automatic int do_get_config_stats_write_response_waits_step(  );
        return config_stats_write_response_waits_step;
    endfunction

    function automatic int do_get_config_stats_write_response_waits_multiple(  );
        return config_stats_write_response_waits_multiple;
    endfunction

    function automatic int do_get_stats_write_response_waits_inst(  );
        return stats_write_response_waits_inst;
    endfunction

    function automatic int do_get_stats_write_response_waits_sw(  );
        return stats_write_response_waits_sw;
    endfunction

    function automatic int do_get_stats_write_response_waits_sw_updated(  );
        return stats_write_response_waits_sw_updated;
    endfunction

    function automatic int do_get_stats_write_response_waits_min(  );
        return stats_write_response_waits_min;
    endfunction

    function automatic int do_get_stats_write_response_waits_max(  );
        return stats_write_response_waits_max;
    endfunction

    function automatic int do_get_stats_write_response_waits_mean(  );
        return stats_write_response_waits_mean;
    endfunction

    function automatic int do_get_stats_rw_transaction_last_duration(  );
        return stats_rw_transaction_last_duration;
    endfunction

    function automatic int do_get_stats_AXI_read_last_duration(  );
        return stats_AXI_read_last_duration;
    endfunction

    function automatic int do_get_stats_AXI_write_last_duration(  );
        return stats_AXI_write_last_duration;
    endfunction

    function automatic int do_get_stats_read_addr_channel_phase_last_duration(  );
        return stats_read_addr_channel_phase_last_duration;
    endfunction

    function automatic int do_get_stats_read_data_burst_last_duration(  );
        return stats_read_data_burst_last_duration;
    endfunction

    function automatic int do_get_stats_read_channel_phase_last_duration(  );
        return stats_read_channel_phase_last_duration;
    endfunction

    function automatic int do_get_stats_write_addr_channel_phase_last_duration(  );
        return stats_write_addr_channel_phase_last_duration;
    endfunction

    function automatic int do_get_stats_write_data_burst_last_duration(  );
        return stats_write_data_burst_last_duration;
    endfunction

    function automatic int do_get_stats_write_channel_phase_last_duration(  );
        return stats_write_channel_phase_last_duration;
    endfunction

    function automatic int do_get_stats_write_resp_channel_phase_last_duration(  );
        return stats_write_resp_channel_phase_last_duration;
    endfunction


    //------------------------------------------------------------------------------
    // Interface end access functions
    //------------------------------------------------------------------------------

    function longint do_get_axi_master_end();
        return axi_get_axi_master_end();
    endfunction

    function longint do_get_axi_slave_end();
        return axi_get_axi_slave_end();
    endfunction

    function longint do_get_axi_clock_source_end();
        return axi_get_axi_clock_source_end();
    endfunction

    function longint do_get_axi_reset_source_end();
        return axi_get_axi_reset_source_end();
    endfunction

    function longint do_get_axi__monitor_end();
        return axi_get_axi__monitor_end();
    endfunction

    //------------------------------------------------------------------------------
    // Functions to set/get generic interface configuration
    //------------------------------------------------------------------------------

    function void do_set_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0,
        input int arg10 = 0
    );
        axi_set_interface( what, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10 );
    endfunction

    function int do_get_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0
    );
        return axi_get_interface( what, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 );
    endfunction

    //------------------------------------------------------------------------------
    // Functions to get the hierarchic name of this interface
    //------------------------------------------------------------------------------
    function string do_get_full_name();
        return axi_get_full_name();
    endfunction

    //------------------------------------------------------------------------------
    // Functions to set/get the abstraction levels of interface ends
    //------------------------------------------------------------------------------

    function void do_axi_set_master_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi_set_master_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi_get_master_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi_get_master_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi_set_slave_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi_set_slave_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi_get_slave_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi_get_slave_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi_set_clock_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi_set_clock_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi_get_clock_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi_get_clock_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi_set_reset_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi_set_reset_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi_get_reset_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi_get_reset_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

// Variable monitors

    function automatic void axi_local_set_config_clk_init_value_from_SystemVerilog( ref bit config_clk_init_value_param );
            axi_set_config_clk_init_value_from_SystemVerilog(config_clk_init_value); // DPI call to imported task
        
            axi_propagate_config_clk_init_value_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_clk_init_value_from_SystemVerilog( config_clk_init_value );
            end
        end
    end

    function automatic void axi_local_set_config_clk_phase_shift_from_SystemVerilog( ref int config_clk_phase_shift_param );
            axi_set_config_clk_phase_shift_from_SystemVerilog(config_clk_phase_shift); // DPI call to imported task
        
            axi_propagate_config_clk_phase_shift_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_clk_phase_shift_from_SystemVerilog( config_clk_phase_shift );
            end
        end
    end

    function automatic void axi_local_set_config_clk_1st_time_from_SystemVerilog( ref int config_clk_1st_time_param );
            axi_set_config_clk_1st_time_from_SystemVerilog(config_clk_1st_time); // DPI call to imported task
        
            axi_propagate_config_clk_1st_time_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_clk_1st_time_from_SystemVerilog( config_clk_1st_time );
            end
        end
    end

    function automatic void axi_local_set_config_clk_2nd_time_from_SystemVerilog( ref int config_clk_2nd_time_param );
            axi_set_config_clk_2nd_time_from_SystemVerilog(config_clk_2nd_time); // DPI call to imported task
        
            axi_propagate_config_clk_2nd_time_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_clk_2nd_time_from_SystemVerilog( config_clk_2nd_time );
            end
        end
    end

    function automatic void axi_local_set_config_setup_time_from_SystemVerilog( ref int config_setup_time_param );
            axi_set_config_setup_time_from_SystemVerilog(config_setup_time); // DPI call to imported task
        
            axi_propagate_config_setup_time_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_setup_time_from_SystemVerilog( config_setup_time );
            end
        end
    end

    function automatic void axi_local_set_config_hold_time_from_SystemVerilog( ref int config_hold_time_param );
            axi_set_config_hold_time_from_SystemVerilog(config_hold_time); // DPI call to imported task
        
            axi_propagate_config_hold_time_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_hold_time_from_SystemVerilog( config_hold_time );
            end
        end
    end

    function automatic void axi_local_set_config_max_transaction_time_factor_from_SystemVerilog( ref int unsigned config_max_transaction_time_factor_param );
            axi_set_config_max_transaction_time_factor_from_SystemVerilog(config_max_transaction_time_factor); // DPI call to imported task
        
            axi_propagate_config_max_transaction_time_factor_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_transaction_time_factor_from_SystemVerilog( config_max_transaction_time_factor );
            end
        end
    end

    function automatic void axi_local_set_config_timeout_max_data_transfer_from_SystemVerilog( ref int config_timeout_max_data_transfer_param );
            axi_set_config_timeout_max_data_transfer_from_SystemVerilog(config_timeout_max_data_transfer); // DPI call to imported task
        
            axi_propagate_config_timeout_max_data_transfer_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_timeout_max_data_transfer_from_SystemVerilog( config_timeout_max_data_transfer );
            end
        end
    end

    function automatic void axi_local_set_config_burst_timeout_factor_from_SystemVerilog( ref int unsigned config_burst_timeout_factor_param );
            axi_set_config_burst_timeout_factor_from_SystemVerilog(config_burst_timeout_factor); // DPI call to imported task
        
            axi_propagate_config_burst_timeout_factor_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_burst_timeout_factor_from_SystemVerilog( config_burst_timeout_factor );
            end
        end
    end

    function automatic void axi_local_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog( ref int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
            axi_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog(config_max_latency_AWVALID_assertion_to_AWREADY); // DPI call to imported task
        
            axi_propagate_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog( config_max_latency_AWVALID_assertion_to_AWREADY );
            end
        end
    end

    function automatic void axi_local_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog( ref int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
            axi_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog(config_max_latency_ARVALID_assertion_to_ARREADY); // DPI call to imported task
        
            axi_propagate_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog( config_max_latency_ARVALID_assertion_to_ARREADY );
            end
        end
    end

    function automatic void axi_local_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog( ref int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
            axi_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog(config_max_latency_RVALID_assertion_to_RREADY); // DPI call to imported task
        
            axi_propagate_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog( config_max_latency_RVALID_assertion_to_RREADY );
            end
        end
    end

    function automatic void axi_local_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog( ref int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
            axi_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog(config_max_latency_BVALID_assertion_to_BREADY); // DPI call to imported task
        
            axi_propagate_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog( config_max_latency_BVALID_assertion_to_BREADY );
            end
        end
    end

    function automatic void axi_local_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog( ref int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
            axi_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog(config_max_latency_WVALID_assertion_to_WREADY); // DPI call to imported task
        
            axi_propagate_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog( config_max_latency_WVALID_assertion_to_WREADY );
            end
        end
    end

    function automatic void axi_local_set_config_write_ctrl_first_ratio_from_SystemVerilog( ref int config_write_ctrl_first_ratio_param );
            axi_set_config_write_ctrl_first_ratio_from_SystemVerilog(config_write_ctrl_first_ratio); // DPI call to imported task
        
            axi_propagate_config_write_ctrl_first_ratio_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_write_ctrl_first_ratio_from_SystemVerilog( config_write_ctrl_first_ratio );
            end
        end
    end

    function automatic void axi_local_set_config_write_data_first_ratio_from_SystemVerilog( ref int config_write_data_first_ratio_param );
            axi_set_config_write_data_first_ratio_from_SystemVerilog(config_write_data_first_ratio); // DPI call to imported task
        
            axi_propagate_config_write_data_first_ratio_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_write_data_first_ratio_from_SystemVerilog( config_write_data_first_ratio );
            end
        end
    end

    function automatic void axi_local_set_config_write_ctrl_to_data_mintime_from_SystemVerilog( ref int unsigned config_write_ctrl_to_data_mintime_param );
            axi_set_config_write_ctrl_to_data_mintime_from_SystemVerilog(config_write_ctrl_to_data_mintime); // DPI call to imported task
        
            axi_propagate_config_write_ctrl_to_data_mintime_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_write_ctrl_to_data_mintime_from_SystemVerilog( config_write_ctrl_to_data_mintime );
            end
        end
    end

    function automatic void axi_local_set_config_write_data_to_ctrl_mintime_from_SystemVerilog( ref int unsigned config_write_data_to_ctrl_mintime_param );
            axi_set_config_write_data_to_ctrl_mintime_from_SystemVerilog(config_write_data_to_ctrl_mintime); // DPI call to imported task
        
            axi_propagate_config_write_data_to_ctrl_mintime_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_write_data_to_ctrl_mintime_from_SystemVerilog( config_write_data_to_ctrl_mintime );
            end
        end
    end

    function automatic void axi_local_set_config_master_write_delay_from_SystemVerilog( ref bit config_master_write_delay_param );
            axi_set_config_master_write_delay_from_SystemVerilog(config_master_write_delay); // DPI call to imported task
        
            axi_propagate_config_master_write_delay_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_master_write_delay_from_SystemVerilog( config_master_write_delay );
            end
        end
    end

    function automatic void axi_local_set_config_reset_low_clocks_from_SystemVerilog( ref int config_reset_low_clocks_param );
            axi_set_config_reset_low_clocks_from_SystemVerilog(config_reset_low_clocks); // DPI call to imported task
        
            axi_propagate_config_reset_low_clocks_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_reset_low_clocks_from_SystemVerilog( config_reset_low_clocks );
            end
        end
    end

    function automatic void axi_local_set_config_reset_hold_time_from_SystemVerilog( ref int config_reset_hold_time_param );
            axi_set_config_reset_hold_time_from_SystemVerilog(config_reset_hold_time); // DPI call to imported task
        
            axi_propagate_config_reset_hold_time_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_reset_hold_time_from_SystemVerilog( config_reset_hold_time );
            end
        end
    end

    function automatic void axi_local_set_config_protect_ready_from_SystemVerilog( ref bit config_protect_ready_param );
            axi_set_config_protect_ready_from_SystemVerilog(config_protect_ready); // DPI call to imported task
        
            axi_propagate_config_protect_ready_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_protect_ready_from_SystemVerilog( config_protect_ready );
            end
        end
    end

    function automatic void axi_local_set_config_enable_user_sideband_from_SystemVerilog( ref bit config_enable_user_sideband_param );
            axi_set_config_enable_user_sideband_from_SystemVerilog(config_enable_user_sideband); // DPI call to imported task
        
            axi_propagate_config_enable_user_sideband_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_user_sideband_from_SystemVerilog( config_enable_user_sideband );
            end
        end
    end

    function automatic void axi_local_set_config_extended_length_enable_from_SystemVerilog( ref bit config_extended_length_enable_param );
            axi_set_config_extended_length_enable_from_SystemVerilog(config_extended_length_enable); // DPI call to imported task
        
            axi_propagate_config_extended_length_enable_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_extended_length_enable_from_SystemVerilog( config_extended_length_enable );
            end
        end
    end

    function automatic void axi_local_set_config_enable_burst_reserved_value_from_SystemVerilog( ref bit config_enable_burst_reserved_value_param );
            axi_set_config_enable_burst_reserved_value_from_SystemVerilog(config_enable_burst_reserved_value); // DPI call to imported task
        
            axi_propagate_config_enable_burst_reserved_value_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_burst_reserved_value_from_SystemVerilog( config_enable_burst_reserved_value );
            end
        end
    end

    function automatic void axi_local_set_config_enable_lock_reserved_value_from_SystemVerilog( ref bit config_enable_lock_reserved_value_param );
            axi_set_config_enable_lock_reserved_value_from_SystemVerilog(config_enable_lock_reserved_value); // DPI call to imported task
        
            axi_propagate_config_enable_lock_reserved_value_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_lock_reserved_value_from_SystemVerilog( config_enable_lock_reserved_value );
            end
        end
    end

    function automatic void axi_local_set_config_enable_cache_reserved_value_from_SystemVerilog( ref bit config_enable_cache_reserved_value_param );
            axi_set_config_enable_cache_reserved_value_from_SystemVerilog(config_enable_cache_reserved_value); // DPI call to imported task
        
            axi_propagate_config_enable_cache_reserved_value_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_cache_reserved_value_from_SystemVerilog( config_enable_cache_reserved_value );
            end
        end
    end

    function automatic void axi_local_set_config_enable_all_assertions_from_SystemVerilog( ref bit config_enable_all_assertions_param );
            axi_set_config_enable_all_assertions_from_SystemVerilog(config_enable_all_assertions); // DPI call to imported task
        
            axi_propagate_config_enable_all_assertions_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_all_assertions_from_SystemVerilog( config_enable_all_assertions );
            end
        end
    end

    function automatic void axi_local_set_config_enable_assertion_from_SystemVerilog( ref bit [255:0] config_enable_assertion_param );
            axi_set_config_enable_assertion_from_SystemVerilog(config_enable_assertion); // DPI call to imported task
        
            axi_propagate_config_enable_assertion_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_assertion_from_SystemVerilog( config_enable_assertion );
            end
        end
    end

    function automatic void axi_local_set_config_enable_error_from_SystemVerilog( ref bit [255:0] config_enable_error_param );
            axi_set_config_enable_error_from_SystemVerilog(config_enable_error); // DPI call to imported task
        
            axi_propagate_config_enable_error_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_error_from_SystemVerilog( config_enable_error );
            end
        end
    end

    function automatic void axi_local_set_config_enable_errors_from_SystemVerilog( ref bit config_enable_errors_param );
            axi_set_config_enable_errors_from_SystemVerilog(config_enable_errors); // DPI call to imported task
        
            axi_propagate_config_enable_errors_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_errors_from_SystemVerilog( config_enable_errors );
            end
        end
    end

    function automatic void axi_local_set_config_enable_all_assertion_errors_from_SystemVerilog( ref bit config_enable_all_assertion_errors_param );
            axi_set_config_enable_all_assertion_errors_from_SystemVerilog(config_enable_all_assertion_errors); // DPI call to imported task
        
            axi_propagate_config_enable_all_assertion_errors_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_all_assertion_errors_from_SystemVerilog( config_enable_all_assertion_errors );
            end
        end
    end

    function automatic void axi_local_set_config_abstraction_level_from_SystemVerilog( ref axi_abstraction_level_e config_abstraction_level_param );
        int tmp_config_abstraction_level;
        tmp_config_abstraction_level = int'( config_abstraction_level );
            axi_set_config_abstraction_level_from_SystemVerilog(
            tmp_config_abstraction_level
            ); // DPI call to imported task
        
            axi_propagate_config_abstraction_level_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_abstraction_level_from_SystemVerilog( config_abstraction_level );
            end
        end
    end

    function automatic void axi_local_set_config_slave_start_addr_from_SystemVerilog( ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ADDRESS_WIDTH ); _this_dot_1++)
        begin
            axi_set_config_slave_start_addr_from_SystemVerilog_index1(_this_dot_1,config_slave_start_addr[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
            axi_propagate_config_slave_start_addr_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_slave_start_addr_from_SystemVerilog( config_slave_start_addr );
            end
        end
    end

    function automatic void axi_local_set_config_slave_end_addr_from_SystemVerilog( ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ADDRESS_WIDTH ); _this_dot_1++)
        begin
            axi_set_config_slave_end_addr_from_SystemVerilog_index1(_this_dot_1,config_slave_end_addr[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
            axi_propagate_config_slave_end_addr_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_slave_end_addr_from_SystemVerilog( config_slave_end_addr );
            end
        end
    end

    function automatic void axi_local_set_config_enable_slave_addr_range_in_bfm_from_SystemVerilog( ref bit config_enable_slave_addr_range_in_bfm_param );
            axi_set_config_enable_slave_addr_range_in_bfm_from_SystemVerilog(config_enable_slave_addr_range_in_bfm); // DPI call to imported task
        
            axi_propagate_config_enable_slave_addr_range_in_bfm_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_slave_addr_range_in_bfm_from_SystemVerilog( config_enable_slave_addr_range_in_bfm );
            end
        end
    end

    function automatic void axi_local_set_config_read_data_reordering_depth_from_SystemVerilog( ref int unsigned config_read_data_reordering_depth_param );
            axi_set_config_read_data_reordering_depth_from_SystemVerilog(config_read_data_reordering_depth); // DPI call to imported task
        
            axi_propagate_config_read_data_reordering_depth_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_read_data_reordering_depth_from_SystemVerilog( config_read_data_reordering_depth );
            end
        end
    end

    function automatic void axi_local_set_config_enable_read_data_reordering_depth_in_bfm_from_SystemVerilog( ref bit config_enable_read_data_reordering_depth_in_bfm_param );
            axi_set_config_enable_read_data_reordering_depth_in_bfm_from_SystemVerilog(config_enable_read_data_reordering_depth_in_bfm); // DPI call to imported task
        
            axi_propagate_config_enable_read_data_reordering_depth_in_bfm_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_enable_read_data_reordering_depth_in_bfm_from_SystemVerilog( config_enable_read_data_reordering_depth_in_bfm );
            end
        end
    end

    function automatic void axi_local_set_config_awid_wid_mismatch_from_SystemVerilog( ref bit config_awid_wid_mismatch_param );
            axi_set_config_awid_wid_mismatch_from_SystemVerilog(config_awid_wid_mismatch); // DPI call to imported task
        
            axi_propagate_config_awid_wid_mismatch_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_awid_wid_mismatch_from_SystemVerilog( config_awid_wid_mismatch );
            end
        end
    end

    function automatic void axi_local_set_config_length_last_mismatch_error_from_SystemVerilog( ref bit config_length_last_mismatch_error_param );
            axi_set_config_length_last_mismatch_error_from_SystemVerilog(config_length_last_mismatch_error); // DPI call to imported task
        
            axi_propagate_config_length_last_mismatch_error_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_length_last_mismatch_error_from_SystemVerilog( config_length_last_mismatch_error );
            end
        end
    end

    function automatic void axi_local_set_config_master_error_position_from_SystemVerilog( ref axi_error_e config_master_error_position_param );
        int tmp_config_master_error_position;
        tmp_config_master_error_position = int'( config_master_error_position );
            axi_set_config_master_error_position_from_SystemVerilog(
            tmp_config_master_error_position
            ); // DPI call to imported task
        
            axi_propagate_config_master_error_position_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_master_error_position_from_SystemVerilog( config_master_error_position );
            end
        end
    end

    function automatic void axi_local_set_dummy_var_from_SystemVerilog( ref axi_assertion_type_e dummy_var_param );
        int tmp_dummy_var;
        tmp_dummy_var = int'( dummy_var );
            axi_set_dummy_var_from_SystemVerilog(
            tmp_dummy_var
            ); // DPI call to imported task
        
            axi_propagate_dummy_var_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_dummy_var_from_SystemVerilog( dummy_var );
            end
        end
    end

    function automatic void axi_local_set_config_wlast_length_from_SystemVerilog( ref int config_wlast_length_param );
            axi_set_config_wlast_length_from_SystemVerilog(config_wlast_length); // DPI call to imported task
        
            axi_propagate_config_wlast_length_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_wlast_length_from_SystemVerilog( config_wlast_length );
            end
        end
    end

    function automatic void axi_local_set_config_wid_for_awid_not_matching_from_SystemVerilog( ref bit [((AXI_ID_WIDTH) - 1):0]  config_wid_for_awid_not_matching_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ID_WIDTH ); _this_dot_1++)
        begin
            axi_set_config_wid_for_awid_not_matching_from_SystemVerilog_index1(_this_dot_1,config_wid_for_awid_not_matching[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
            axi_propagate_config_wid_for_awid_not_matching_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_wid_for_awid_not_matching_from_SystemVerilog( config_wid_for_awid_not_matching );
            end
        end
    end

    function automatic void axi_local_set_config_support_exclusive_access_from_SystemVerilog( ref bit config_support_exclusive_access_param );
            axi_set_config_support_exclusive_access_from_SystemVerilog(config_support_exclusive_access); // DPI call to imported task
        
            axi_propagate_config_support_exclusive_access_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_support_exclusive_access_from_SystemVerilog( config_support_exclusive_access );
            end
        end
    end

    function automatic void axi_local_set_config_write_data_interleaving_depth_from_SystemVerilog( ref int config_write_data_interleaving_depth_param );
            axi_set_config_write_data_interleaving_depth_from_SystemVerilog(config_write_data_interleaving_depth); // DPI call to imported task
        
            axi_propagate_config_write_data_interleaving_depth_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_write_data_interleaving_depth_from_SystemVerilog( config_write_data_interleaving_depth );
            end
        end
    end

    function automatic void axi_local_set_status_master_error_from_SystemVerilog( ref bit [15:0] status_master_error_param );
            axi_set_status_master_error_from_SystemVerilog(status_master_error); // DPI call to imported task
        
            axi_propagate_status_master_error_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_status_master_error_from_SystemVerilog( status_master_error );
            end
        end
    end

    function automatic void axi_local_set_check_total_num_wdata_outstanding_from_SystemVerilog( ref bit check_total_num_wdata_outstanding_param );
            axi_set_check_total_num_wdata_outstanding_from_SystemVerilog(check_total_num_wdata_outstanding); // DPI call to imported task
        
            axi_propagate_check_total_num_wdata_outstanding_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_check_total_num_wdata_outstanding_from_SystemVerilog( check_total_num_wdata_outstanding );
            end
        end
    end

    function automatic void axi_local_set_total_num_wdata_outstanding_from_SystemVerilog( ref int total_num_wdata_outstanding_param );
            axi_set_total_num_wdata_outstanding_from_SystemVerilog(total_num_wdata_outstanding); // DPI call to imported task
        
            axi_propagate_total_num_wdata_outstanding_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_total_num_wdata_outstanding_from_SystemVerilog( total_num_wdata_outstanding );
            end
        end
    end

    function automatic void axi_local_set_check_max_num_wdata_outstanding_per_id_from_SystemVerilog( ref bit check_max_num_wdata_outstanding_per_id_param );
            axi_set_check_max_num_wdata_outstanding_per_id_from_SystemVerilog(check_max_num_wdata_outstanding_per_id); // DPI call to imported task
        
            axi_propagate_check_max_num_wdata_outstanding_per_id_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_check_max_num_wdata_outstanding_per_id_from_SystemVerilog( check_max_num_wdata_outstanding_per_id );
            end
        end
    end

    function automatic void axi_local_set_max_num_wdata_outstanding_per_id_from_SystemVerilog( ref int max_num_wdata_outstanding_per_id_param );
            axi_set_max_num_wdata_outstanding_per_id_from_SystemVerilog(max_num_wdata_outstanding_per_id); // DPI call to imported task
        
            axi_propagate_max_num_wdata_outstanding_per_id_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_max_num_wdata_outstanding_per_id_from_SystemVerilog( max_num_wdata_outstanding_per_id );
            end
        end
    end

    function automatic void axi_local_set_check_max_num_waddr_outstanding_per_id_from_SystemVerilog( ref bit check_max_num_waddr_outstanding_per_id_param );
            axi_set_check_max_num_waddr_outstanding_per_id_from_SystemVerilog(check_max_num_waddr_outstanding_per_id); // DPI call to imported task
        
            axi_propagate_check_max_num_waddr_outstanding_per_id_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_check_max_num_waddr_outstanding_per_id_from_SystemVerilog( check_max_num_waddr_outstanding_per_id );
            end
        end
    end

    function automatic void axi_local_set_max_num_waddr_outstanding_per_id_from_SystemVerilog( ref int max_num_waddr_outstanding_per_id_param );
            axi_set_max_num_waddr_outstanding_per_id_from_SystemVerilog(max_num_waddr_outstanding_per_id); // DPI call to imported task
        
            axi_propagate_max_num_waddr_outstanding_per_id_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_max_num_waddr_outstanding_per_id_from_SystemVerilog( max_num_waddr_outstanding_per_id );
            end
        end
    end

    function automatic void axi_local_set_check_total_num_waddr_outstanding_from_SystemVerilog( ref bit check_total_num_waddr_outstanding_param );
            axi_set_check_total_num_waddr_outstanding_from_SystemVerilog(check_total_num_waddr_outstanding); // DPI call to imported task
        
            axi_propagate_check_total_num_waddr_outstanding_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_check_total_num_waddr_outstanding_from_SystemVerilog( check_total_num_waddr_outstanding );
            end
        end
    end

    function automatic void axi_local_set_total_num_waddr_outstanding_from_SystemVerilog( ref int total_num_waddr_outstanding_param );
            axi_set_total_num_waddr_outstanding_from_SystemVerilog(total_num_waddr_outstanding); // DPI call to imported task
        
            axi_propagate_total_num_waddr_outstanding_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_total_num_waddr_outstanding_from_SystemVerilog( total_num_waddr_outstanding );
            end
        end
    end

    function automatic void axi_local_set_status_outstanding_num_for_waddr_from_SystemVerilog( ref int status_outstanding_num_for_waddr_param );
            axi_set_status_outstanding_num_for_waddr_from_SystemVerilog(status_outstanding_num_for_waddr); // DPI call to imported task
        
            axi_propagate_status_outstanding_num_for_waddr_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_status_outstanding_num_for_waddr_from_SystemVerilog( status_outstanding_num_for_waddr );
            end
        end
    end

    function automatic void axi_local_set_start_finding_outstanding_waddr_from_SystemVerilog( ref bit start_finding_outstanding_waddr_param );
            axi_set_start_finding_outstanding_waddr_from_SystemVerilog(start_finding_outstanding_waddr); // DPI call to imported task
        
            axi_propagate_start_finding_outstanding_waddr_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_start_finding_outstanding_waddr_from_SystemVerilog( start_finding_outstanding_waddr );
            end
        end
    end

    function automatic void axi_local_set_status_outstanding_num_for_wdata_from_SystemVerilog( ref int status_outstanding_num_for_wdata_param );
            axi_set_status_outstanding_num_for_wdata_from_SystemVerilog(status_outstanding_num_for_wdata); // DPI call to imported task
        
            axi_propagate_status_outstanding_num_for_wdata_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_status_outstanding_num_for_wdata_from_SystemVerilog( status_outstanding_num_for_wdata );
            end
        end
    end

    function automatic void axi_local_set_start_finding_outstanding_wdata_from_SystemVerilog( ref bit start_finding_outstanding_wdata_param );
            axi_set_start_finding_outstanding_wdata_from_SystemVerilog(start_finding_outstanding_wdata); // DPI call to imported task
        
            axi_propagate_start_finding_outstanding_wdata_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_start_finding_outstanding_wdata_from_SystemVerilog( start_finding_outstanding_wdata );
            end
        end
    end

    function automatic void axi_local_set_find_waddr_outstanding_for_wid_from_SystemVerilog( ref bit [((AXI_ID_WIDTH) - 1):0]  find_waddr_outstanding_for_wid_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ID_WIDTH ); _this_dot_1++)
        begin
            axi_set_find_waddr_outstanding_for_wid_from_SystemVerilog_index1(_this_dot_1,find_waddr_outstanding_for_wid[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
            axi_propagate_find_waddr_outstanding_for_wid_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_find_waddr_outstanding_for_wid_from_SystemVerilog( find_waddr_outstanding_for_wid );
            end
        end
    end

    function automatic void axi_local_set_find_wdata_outstanding_for_wid_from_SystemVerilog( ref bit [((AXI_ID_WIDTH) - 1):0]  find_wdata_outstanding_for_wid_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ID_WIDTH ); _this_dot_1++)
        begin
            axi_set_find_wdata_outstanding_for_wid_from_SystemVerilog_index1(_this_dot_1,find_wdata_outstanding_for_wid[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
            axi_propagate_find_wdata_outstanding_for_wid_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_find_wdata_outstanding_for_wid_from_SystemVerilog( find_wdata_outstanding_for_wid );
            end
        end
    end

    function automatic void axi_local_set_change_in_wdata_outstanding_per_id_from_SystemVerilog( ref bit change_in_wdata_outstanding_per_id_param );
            axi_set_change_in_wdata_outstanding_per_id_from_SystemVerilog(change_in_wdata_outstanding_per_id); // DPI call to imported task
        
            axi_propagate_change_in_wdata_outstanding_per_id_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_change_in_wdata_outstanding_per_id_from_SystemVerilog( change_in_wdata_outstanding_per_id );
            end
        end
    end

    function automatic void axi_local_set_start_finding_change_in_wdata_from_SystemVerilog( ref bit start_finding_change_in_wdata_param );
            axi_set_start_finding_change_in_wdata_from_SystemVerilog(start_finding_change_in_wdata); // DPI call to imported task
        
            axi_propagate_start_finding_change_in_wdata_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_start_finding_change_in_wdata_from_SystemVerilog( start_finding_change_in_wdata );
            end
        end
    end

    function automatic void axi_local_set_find_change_in_wdata_outstanding_for_wid_from_SystemVerilog( ref bit [((AXI_ID_WIDTH) - 1):0]  find_change_in_wdata_outstanding_for_wid_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI_ID_WIDTH ); _this_dot_1++)
        begin
            axi_set_find_change_in_wdata_outstanding_for_wid_from_SystemVerilog_index1(_this_dot_1,find_change_in_wdata_outstanding_for_wid[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
            axi_propagate_find_change_in_wdata_outstanding_for_wid_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_find_change_in_wdata_outstanding_for_wid_from_SystemVerilog( find_change_in_wdata_outstanding_for_wid );
            end
        end
    end

    function automatic void axi_local_set_config_max_outstanding_wr_from_SystemVerilog( ref int config_max_outstanding_wr_param );
            axi_set_config_max_outstanding_wr_from_SystemVerilog(config_max_outstanding_wr); // DPI call to imported task
        
            axi_propagate_config_max_outstanding_wr_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_outstanding_wr_from_SystemVerilog( config_max_outstanding_wr );
            end
        end
    end

    function automatic void axi_local_set_config_max_outstanding_rd_from_SystemVerilog( ref int config_max_outstanding_rd_param );
            axi_set_config_max_outstanding_rd_from_SystemVerilog(config_max_outstanding_rd); // DPI call to imported task
        
            axi_propagate_config_max_outstanding_rd_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_max_outstanding_rd_from_SystemVerilog( config_max_outstanding_rd );
            end
        end
    end

    function automatic void axi_local_set_config_error_on_deleted_valid_cycles_from_SystemVerilog( ref bit config_error_on_deleted_valid_cycles_param );
            axi_set_config_error_on_deleted_valid_cycles_from_SystemVerilog(config_error_on_deleted_valid_cycles); // DPI call to imported task
        
            axi_propagate_config_error_on_deleted_valid_cycles_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_error_on_deleted_valid_cycles_from_SystemVerilog( config_error_on_deleted_valid_cycles );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_from_SystemVerilog( ref bit config_stats_enable_param );
            axi_set_config_stats_enable_from_SystemVerilog(config_stats_enable); // DPI call to imported task
        
            axi_propagate_config_stats_enable_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_from_SystemVerilog( config_stats_enable );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_AXI_read_occupancy_from_SystemVerilog( ref bit config_stats_enable_AXI_read_occupancy_param );
            axi_set_config_stats_enable_AXI_read_occupancy_from_SystemVerilog(config_stats_enable_AXI_read_occupancy); // DPI call to imported task
        
            axi_propagate_config_stats_enable_AXI_read_occupancy_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_AXI_read_occupancy_from_SystemVerilog( config_stats_enable_AXI_read_occupancy );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_AXI_write_occupancy_from_SystemVerilog( ref bit config_stats_enable_AXI_write_occupancy_param );
            axi_set_config_stats_enable_AXI_write_occupancy_from_SystemVerilog(config_stats_enable_AXI_write_occupancy); // DPI call to imported task
        
            axi_propagate_config_stats_enable_AXI_write_occupancy_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_AXI_write_occupancy_from_SystemVerilog( config_stats_enable_AXI_write_occupancy );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_read_data_occupancy_from_SystemVerilog( ref bit config_stats_enable_read_data_occupancy_param );
            axi_set_config_stats_enable_read_data_occupancy_from_SystemVerilog(config_stats_enable_read_data_occupancy); // DPI call to imported task
        
            axi_propagate_config_stats_enable_read_data_occupancy_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_read_data_occupancy_from_SystemVerilog( config_stats_enable_read_data_occupancy );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_write_data_occupancy_from_SystemVerilog( ref bit config_stats_enable_write_data_occupancy_param );
            axi_set_config_stats_enable_write_data_occupancy_from_SystemVerilog(config_stats_enable_write_data_occupancy); // DPI call to imported task
        
            axi_propagate_config_stats_enable_write_data_occupancy_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_write_data_occupancy_from_SystemVerilog( config_stats_enable_write_data_occupancy );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_read_latency_from_SystemVerilog( ref bit config_stats_enable_read_latency_param );
            axi_set_config_stats_enable_read_latency_from_SystemVerilog(config_stats_enable_read_latency); // DPI call to imported task
        
            axi_propagate_config_stats_enable_read_latency_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_read_latency_from_SystemVerilog( config_stats_enable_read_latency );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_write_latency_from_SystemVerilog( ref bit config_stats_enable_write_latency_param );
            axi_set_config_stats_enable_write_latency_from_SystemVerilog(config_stats_enable_write_latency); // DPI call to imported task
        
            axi_propagate_config_stats_enable_write_latency_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_write_latency_from_SystemVerilog( config_stats_enable_write_latency );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_read_address_waits_from_SystemVerilog( ref bit config_stats_enable_read_address_waits_param );
            axi_set_config_stats_enable_read_address_waits_from_SystemVerilog(config_stats_enable_read_address_waits); // DPI call to imported task
        
            axi_propagate_config_stats_enable_read_address_waits_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_read_address_waits_from_SystemVerilog( config_stats_enable_read_address_waits );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_read_data_waits_from_SystemVerilog( ref bit config_stats_enable_read_data_waits_param );
            axi_set_config_stats_enable_read_data_waits_from_SystemVerilog(config_stats_enable_read_data_waits); // DPI call to imported task
        
            axi_propagate_config_stats_enable_read_data_waits_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_read_data_waits_from_SystemVerilog( config_stats_enable_read_data_waits );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_write_address_waits_from_SystemVerilog( ref bit config_stats_enable_write_address_waits_param );
            axi_set_config_stats_enable_write_address_waits_from_SystemVerilog(config_stats_enable_write_address_waits); // DPI call to imported task
        
            axi_propagate_config_stats_enable_write_address_waits_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_write_address_waits_from_SystemVerilog( config_stats_enable_write_address_waits );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_write_data_waits_from_SystemVerilog( ref bit config_stats_enable_write_data_waits_param );
            axi_set_config_stats_enable_write_data_waits_from_SystemVerilog(config_stats_enable_write_data_waits); // DPI call to imported task
        
            axi_propagate_config_stats_enable_write_data_waits_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_write_data_waits_from_SystemVerilog( config_stats_enable_write_data_waits );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_write_response_waits_from_SystemVerilog( ref bit config_stats_enable_write_response_waits_param );
            axi_set_config_stats_enable_write_response_waits_from_SystemVerilog(config_stats_enable_write_response_waits); // DPI call to imported task
        
            axi_propagate_config_stats_enable_write_response_waits_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_write_response_waits_from_SystemVerilog( config_stats_enable_write_response_waits );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_read_bandwidth_from_SystemVerilog( ref bit config_stats_enable_read_bandwidth_param );
            axi_set_config_stats_enable_read_bandwidth_from_SystemVerilog(config_stats_enable_read_bandwidth); // DPI call to imported task
        
            axi_propagate_config_stats_enable_read_bandwidth_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_read_bandwidth_from_SystemVerilog( config_stats_enable_read_bandwidth );
            end
        end
    end

    function automatic void axi_local_set_config_stats_enable_write_bandwidth_from_SystemVerilog( ref bit config_stats_enable_write_bandwidth_param );
            axi_set_config_stats_enable_write_bandwidth_from_SystemVerilog(config_stats_enable_write_bandwidth); // DPI call to imported task
        
            axi_propagate_config_stats_enable_write_bandwidth_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_enable_write_bandwidth_from_SystemVerilog( config_stats_enable_write_bandwidth );
            end
        end
    end

    function automatic void axi_local_set_config_stats_AXI_read_occupancy_step_from_SystemVerilog( ref int config_stats_AXI_read_occupancy_step_param );
            axi_set_config_stats_AXI_read_occupancy_step_from_SystemVerilog(config_stats_AXI_read_occupancy_step); // DPI call to imported task
        
            axi_propagate_config_stats_AXI_read_occupancy_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_AXI_read_occupancy_step_from_SystemVerilog( config_stats_AXI_read_occupancy_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_AXI_read_occupancy_multiple_from_SystemVerilog( ref int config_stats_AXI_read_occupancy_multiple_param );
            axi_set_config_stats_AXI_read_occupancy_multiple_from_SystemVerilog(config_stats_AXI_read_occupancy_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_AXI_read_occupancy_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_AXI_read_occupancy_multiple_from_SystemVerilog( config_stats_AXI_read_occupancy_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_AXI_write_occupancy_step_from_SystemVerilog( ref int config_stats_AXI_write_occupancy_step_param );
            axi_set_config_stats_AXI_write_occupancy_step_from_SystemVerilog(config_stats_AXI_write_occupancy_step); // DPI call to imported task
        
            axi_propagate_config_stats_AXI_write_occupancy_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_AXI_write_occupancy_step_from_SystemVerilog( config_stats_AXI_write_occupancy_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_AXI_write_occupancy_multiple_from_SystemVerilog( ref int config_stats_AXI_write_occupancy_multiple_param );
            axi_set_config_stats_AXI_write_occupancy_multiple_from_SystemVerilog(config_stats_AXI_write_occupancy_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_AXI_write_occupancy_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_AXI_write_occupancy_multiple_from_SystemVerilog( config_stats_AXI_write_occupancy_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_data_occupancy_step_from_SystemVerilog( ref int config_stats_read_data_occupancy_step_param );
            axi_set_config_stats_read_data_occupancy_step_from_SystemVerilog(config_stats_read_data_occupancy_step); // DPI call to imported task
        
            axi_propagate_config_stats_read_data_occupancy_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_data_occupancy_step_from_SystemVerilog( config_stats_read_data_occupancy_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog( ref int config_stats_read_data_occupancy_multiple_param );
            axi_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog(config_stats_read_data_occupancy_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_read_data_occupancy_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog( config_stats_read_data_occupancy_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_data_occupancy_step_from_SystemVerilog( ref int config_stats_write_data_occupancy_step_param );
            axi_set_config_stats_write_data_occupancy_step_from_SystemVerilog(config_stats_write_data_occupancy_step); // DPI call to imported task
        
            axi_propagate_config_stats_write_data_occupancy_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_data_occupancy_step_from_SystemVerilog( config_stats_write_data_occupancy_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog( ref int config_stats_write_data_occupancy_multiple_param );
            axi_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog(config_stats_write_data_occupancy_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_write_data_occupancy_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog( config_stats_write_data_occupancy_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_bandwidth_step_from_SystemVerilog( ref int config_stats_read_bandwidth_step_param );
            axi_set_config_stats_read_bandwidth_step_from_SystemVerilog(config_stats_read_bandwidth_step); // DPI call to imported task
        
            axi_propagate_config_stats_read_bandwidth_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_bandwidth_step_from_SystemVerilog( config_stats_read_bandwidth_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_bandwidth_multiple_from_SystemVerilog( ref int config_stats_read_bandwidth_multiple_param );
            axi_set_config_stats_read_bandwidth_multiple_from_SystemVerilog(config_stats_read_bandwidth_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_read_bandwidth_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_bandwidth_multiple_from_SystemVerilog( config_stats_read_bandwidth_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_bandwidth_step_from_SystemVerilog( ref int config_stats_write_bandwidth_step_param );
            axi_set_config_stats_write_bandwidth_step_from_SystemVerilog(config_stats_write_bandwidth_step); // DPI call to imported task
        
            axi_propagate_config_stats_write_bandwidth_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_bandwidth_step_from_SystemVerilog( config_stats_write_bandwidth_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_bandwidth_multiple_from_SystemVerilog( ref int config_stats_write_bandwidth_multiple_param );
            axi_set_config_stats_write_bandwidth_multiple_from_SystemVerilog(config_stats_write_bandwidth_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_write_bandwidth_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_bandwidth_multiple_from_SystemVerilog( config_stats_write_bandwidth_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_latency_step_from_SystemVerilog( ref int config_stats_read_latency_step_param );
            axi_set_config_stats_read_latency_step_from_SystemVerilog(config_stats_read_latency_step); // DPI call to imported task
        
            axi_propagate_config_stats_read_latency_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_latency_step_from_SystemVerilog( config_stats_read_latency_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_latency_multiple_from_SystemVerilog( ref int config_stats_read_latency_multiple_param );
            axi_set_config_stats_read_latency_multiple_from_SystemVerilog(config_stats_read_latency_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_read_latency_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_latency_multiple_from_SystemVerilog( config_stats_read_latency_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_latency_step_from_SystemVerilog( ref int config_stats_write_latency_step_param );
            axi_set_config_stats_write_latency_step_from_SystemVerilog(config_stats_write_latency_step); // DPI call to imported task
        
            axi_propagate_config_stats_write_latency_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_latency_step_from_SystemVerilog( config_stats_write_latency_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_latency_multiple_from_SystemVerilog( ref int config_stats_write_latency_multiple_param );
            axi_set_config_stats_write_latency_multiple_from_SystemVerilog(config_stats_write_latency_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_write_latency_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_latency_multiple_from_SystemVerilog( config_stats_write_latency_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_address_waits_step_from_SystemVerilog( ref int config_stats_read_address_waits_step_param );
            axi_set_config_stats_read_address_waits_step_from_SystemVerilog(config_stats_read_address_waits_step); // DPI call to imported task
        
            axi_propagate_config_stats_read_address_waits_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_address_waits_step_from_SystemVerilog( config_stats_read_address_waits_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_address_waits_multiple_from_SystemVerilog( ref int config_stats_read_address_waits_multiple_param );
            axi_set_config_stats_read_address_waits_multiple_from_SystemVerilog(config_stats_read_address_waits_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_read_address_waits_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_address_waits_multiple_from_SystemVerilog( config_stats_read_address_waits_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_data_waits_step_from_SystemVerilog( ref int config_stats_read_data_waits_step_param );
            axi_set_config_stats_read_data_waits_step_from_SystemVerilog(config_stats_read_data_waits_step); // DPI call to imported task
        
            axi_propagate_config_stats_read_data_waits_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_data_waits_step_from_SystemVerilog( config_stats_read_data_waits_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_read_data_waits_multiple_from_SystemVerilog( ref int config_stats_read_data_waits_multiple_param );
            axi_set_config_stats_read_data_waits_multiple_from_SystemVerilog(config_stats_read_data_waits_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_read_data_waits_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_read_data_waits_multiple_from_SystemVerilog( config_stats_read_data_waits_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_address_waits_step_from_SystemVerilog( ref int config_stats_write_address_waits_step_param );
            axi_set_config_stats_write_address_waits_step_from_SystemVerilog(config_stats_write_address_waits_step); // DPI call to imported task
        
            axi_propagate_config_stats_write_address_waits_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_address_waits_step_from_SystemVerilog( config_stats_write_address_waits_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_address_waits_multiple_from_SystemVerilog( ref int config_stats_write_address_waits_multiple_param );
            axi_set_config_stats_write_address_waits_multiple_from_SystemVerilog(config_stats_write_address_waits_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_write_address_waits_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_address_waits_multiple_from_SystemVerilog( config_stats_write_address_waits_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_data_waits_step_from_SystemVerilog( ref int config_stats_write_data_waits_step_param );
            axi_set_config_stats_write_data_waits_step_from_SystemVerilog(config_stats_write_data_waits_step); // DPI call to imported task
        
            axi_propagate_config_stats_write_data_waits_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_data_waits_step_from_SystemVerilog( config_stats_write_data_waits_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_data_waits_multiple_from_SystemVerilog( ref int config_stats_write_data_waits_multiple_param );
            axi_set_config_stats_write_data_waits_multiple_from_SystemVerilog(config_stats_write_data_waits_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_write_data_waits_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_data_waits_multiple_from_SystemVerilog( config_stats_write_data_waits_multiple );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_response_waits_step_from_SystemVerilog( ref int config_stats_write_response_waits_step_param );
            axi_set_config_stats_write_response_waits_step_from_SystemVerilog(config_stats_write_response_waits_step); // DPI call to imported task
        
            axi_propagate_config_stats_write_response_waits_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_response_waits_step_from_SystemVerilog( config_stats_write_response_waits_step );
            end
        end
    end

    function automatic void axi_local_set_config_stats_write_response_waits_multiple_from_SystemVerilog( ref int config_stats_write_response_waits_multiple_param );
            axi_set_config_stats_write_response_waits_multiple_from_SystemVerilog(config_stats_write_response_waits_multiple); // DPI call to imported task
        
            axi_propagate_config_stats_write_response_waits_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi_local_set_config_stats_write_response_waits_multiple_from_SystemVerilog( config_stats_write_response_waits_multiple );
            end
        end
    end

    //------------------------------------------------------------------------------
    // Transaction interface
    //------------------------------------------------------------------------------

    bit [((AXI_ADDRESS_WIDTH) - 1):0]  temp_static_rw_transaction_addr;
    function void axi_get_temp_static_rw_transaction_addr( input int _d1, output bit  _value );
        _value = temp_static_rw_transaction_addr[_d1];
    endfunction
    function void axi_set_temp_static_rw_transaction_addr( input int _d1, input bit  _value );
        temp_static_rw_transaction_addr[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_rw_transaction_id;
    function void axi_get_temp_static_rw_transaction_id( input int _d1, output bit  _value );
        _value = temp_static_rw_transaction_id[_d1];
    endfunction
    function void axi_set_temp_static_rw_transaction_id( input int _d1, input bit  _value );
        temp_static_rw_transaction_id[_d1] = _value;
    endfunction
    bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] temp_static_rw_transaction_data_words [];
    function void axi_get_temp_static_rw_transaction_data_words( input int _d1, input int _d2, output bit _value );
        _value = temp_static_rw_transaction_data_words[_d1][_d2];
    endfunction
    function void axi_set_temp_static_rw_transaction_data_words( input int _d1, input int _d2, input bit _value );
        temp_static_rw_transaction_data_words[_d1][_d2] = _value;
    endfunction
    bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] temp_static_rw_transaction_write_strobes [];
    function void axi_get_temp_static_rw_transaction_write_strobes( input int _d1, input int _d2, output bit _value );
        _value = temp_static_rw_transaction_write_strobes[_d1][_d2];
    endfunction
    function void axi_set_temp_static_rw_transaction_write_strobes( input int _d1, input int _d2, input bit _value );
        temp_static_rw_transaction_write_strobes[_d1][_d2] = _value;
    endfunction
    int temp_static_rw_transaction_resp[];
    function void axi_get_temp_static_rw_transaction_resp( input int _d1, output int _value );
        _value = temp_static_rw_transaction_resp[_d1];
    endfunction
    function void axi_set_temp_static_rw_transaction_resp( input int _d1, input int _value );
        temp_static_rw_transaction_resp[_d1] = _value;
    endfunction
    bit [7:0] temp_static_rw_transaction_data_user [];
    function void axi_get_temp_static_rw_transaction_data_user( input int _d1, output bit [7:0] _value  );
        _value = temp_static_rw_transaction_data_user[_d1];
    endfunction
    function void axi_set_temp_static_rw_transaction_data_user( input int _d1, input bit [7:0] _value  );
        temp_static_rw_transaction_data_user[_d1] = _value;
    endfunction
    int temp_static_rw_transaction_write_data_beats_delay[];
    function void axi_get_temp_static_rw_transaction_write_data_beats_delay( input int _d1, output int _value );
        _value = temp_static_rw_transaction_write_data_beats_delay[_d1];
    endfunction
    function void axi_set_temp_static_rw_transaction_write_data_beats_delay( input int _d1, input int _value );
        temp_static_rw_transaction_write_data_beats_delay[_d1] = _value;
    endfunction
    int temp_static_rw_transaction_data_valid_delay[];
    function void axi_get_temp_static_rw_transaction_data_valid_delay( input int _d1, output int _value );
        _value = temp_static_rw_transaction_data_valid_delay[_d1];
    endfunction
    function void axi_set_temp_static_rw_transaction_data_valid_delay( input int _d1, input int _value );
        temp_static_rw_transaction_data_valid_delay[_d1] = _value;
    endfunction
    int temp_static_rw_transaction_data_ready_delay[];
    function void axi_get_temp_static_rw_transaction_data_ready_delay( input int _d1, output int _value );
        _value = temp_static_rw_transaction_data_ready_delay[_d1];
    endfunction
    function void axi_set_temp_static_rw_transaction_data_ready_delay( input int _d1, input int _value );
        temp_static_rw_transaction_data_ready_delay[_d1] = _value;
    endfunction
    bit [((AXI_ADDRESS_WIDTH) - 1):0]  temp_static_AXI_read_addr;
    function void axi_get_temp_static_AXI_read_addr( input int _d1, output bit  _value );
        _value = temp_static_AXI_read_addr[_d1];
    endfunction
    function void axi_set_temp_static_AXI_read_addr( input int _d1, input bit  _value );
        temp_static_AXI_read_addr[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_AXI_read_id;
    function void axi_get_temp_static_AXI_read_id( input int _d1, output bit  _value );
        _value = temp_static_AXI_read_id[_d1];
    endfunction
    function void axi_set_temp_static_AXI_read_id( input int _d1, input bit  _value );
        temp_static_AXI_read_id[_d1] = _value;
    endfunction
    bit [((AXI_RDATA_WIDTH) - 1):0] temp_static_AXI_read_data_words [];
    function void axi_get_temp_static_AXI_read_data_words( input int _d1, input int _d2, output bit _value );
        _value = temp_static_AXI_read_data_words[_d1][_d2];
    endfunction
    function void axi_set_temp_static_AXI_read_data_words( input int _d1, input int _d2, input bit _value );
        temp_static_AXI_read_data_words[_d1][_d2] = _value;
    endfunction
    int temp_static_AXI_read_resp[];
    function void axi_get_temp_static_AXI_read_resp( input int _d1, output int _value );
        _value = temp_static_AXI_read_resp[_d1];
    endfunction
    function void axi_set_temp_static_AXI_read_resp( input int _d1, input int _value );
        temp_static_AXI_read_resp[_d1] = _value;
    endfunction
    bit [7:0] temp_static_AXI_read_data_user [];
    function void axi_get_temp_static_AXI_read_data_user( input int _d1, output bit [7:0] _value  );
        _value = temp_static_AXI_read_data_user[_d1];
    endfunction
    function void axi_set_temp_static_AXI_read_data_user( input int _d1, input bit [7:0] _value  );
        temp_static_AXI_read_data_user[_d1] = _value;
    endfunction
    longint temp_static_AXI_read_data_start_time[];
    function void axi_get_temp_static_AXI_read_data_start_time( input int _d1, output longint _value );
        _value = temp_static_AXI_read_data_start_time[_d1];
    endfunction
    function void axi_set_temp_static_AXI_read_data_start_time( input int _d1, input longint _value );
        temp_static_AXI_read_data_start_time[_d1] = _value;
    endfunction
    longint temp_static_AXI_read_data_end_time[];
    function void axi_get_temp_static_AXI_read_data_end_time( input int _d1, output longint _value );
        _value = temp_static_AXI_read_data_end_time[_d1];
    endfunction
    function void axi_set_temp_static_AXI_read_data_end_time( input int _d1, input longint _value );
        temp_static_AXI_read_data_end_time[_d1] = _value;
    endfunction
    bit [((AXI_ADDRESS_WIDTH) - 1):0]  temp_static_AXI_write_addr;
    function void axi_get_temp_static_AXI_write_addr( input int _d1, output bit  _value );
        _value = temp_static_AXI_write_addr[_d1];
    endfunction
    function void axi_set_temp_static_AXI_write_addr( input int _d1, input bit  _value );
        temp_static_AXI_write_addr[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_AXI_write_id;
    function void axi_get_temp_static_AXI_write_id( input int _d1, output bit  _value );
        _value = temp_static_AXI_write_id[_d1];
    endfunction
    function void axi_set_temp_static_AXI_write_id( input int _d1, input bit  _value );
        temp_static_AXI_write_id[_d1] = _value;
    endfunction
    bit [((AXI_WDATA_WIDTH) - 1):0] temp_static_AXI_write_data_words [];
    function void axi_get_temp_static_AXI_write_data_words( input int _d1, input int _d2, output bit _value );
        _value = temp_static_AXI_write_data_words[_d1][_d2];
    endfunction
    function void axi_set_temp_static_AXI_write_data_words( input int _d1, input int _d2, input bit _value );
        temp_static_AXI_write_data_words[_d1][_d2] = _value;
    endfunction
    bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] temp_static_AXI_write_write_strobes [];
    function void axi_get_temp_static_AXI_write_write_strobes( input int _d1, input int _d2, output bit _value );
        _value = temp_static_AXI_write_write_strobes[_d1][_d2];
    endfunction
    function void axi_set_temp_static_AXI_write_write_strobes( input int _d1, input int _d2, input bit _value );
        temp_static_AXI_write_write_strobes[_d1][_d2] = _value;
    endfunction
    bit [7:0] temp_static_AXI_write_data_user [];
    function void axi_get_temp_static_AXI_write_data_user( input int _d1, output bit [7:0] _value  );
        _value = temp_static_AXI_write_data_user[_d1];
    endfunction
    function void axi_set_temp_static_AXI_write_data_user( input int _d1, input bit [7:0] _value  );
        temp_static_AXI_write_data_user[_d1] = _value;
    endfunction
    int temp_static_AXI_write_write_data_beats_delay[];
    function void axi_get_temp_static_AXI_write_write_data_beats_delay( input int _d1, output int _value );
        _value = temp_static_AXI_write_write_data_beats_delay[_d1];
    endfunction
    function void axi_set_temp_static_AXI_write_write_data_beats_delay( input int _d1, input int _value );
        temp_static_AXI_write_write_data_beats_delay[_d1] = _value;
    endfunction
    longint temp_static_AXI_write_data_start_time[];
    function void axi_get_temp_static_AXI_write_data_start_time( input int _d1, output longint _value );
        _value = temp_static_AXI_write_data_start_time[_d1];
    endfunction
    function void axi_set_temp_static_AXI_write_data_start_time( input int _d1, input longint _value );
        temp_static_AXI_write_data_start_time[_d1] = _value;
    endfunction
    longint temp_static_AXI_write_data_end_time[];
    function void axi_get_temp_static_AXI_write_data_end_time( input int _d1, output longint _value );
        _value = temp_static_AXI_write_data_end_time[_d1];
    endfunction
    function void axi_set_temp_static_AXI_write_data_end_time( input int _d1, input longint _value );
        temp_static_AXI_write_data_end_time[_d1] = _value;
    endfunction
    bit [((AXI_WDATA_WIDTH) - 1):0] temp_static_data_resp_data_words [];
    function void axi_get_temp_static_data_resp_data_words( input int _d1, input int _d2, output bit _value );
        _value = temp_static_data_resp_data_words[_d1][_d2];
    endfunction
    function void axi_set_temp_static_data_resp_data_words( input int _d1, input int _d2, input bit _value );
        temp_static_data_resp_data_words[_d1][_d2] = _value;
    endfunction
    bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] temp_static_data_resp_write_strobes [];
    function void axi_get_temp_static_data_resp_write_strobes( input int _d1, input int _d2, output bit _value );
        _value = temp_static_data_resp_write_strobes[_d1][_d2];
    endfunction
    function void axi_set_temp_static_data_resp_write_strobes( input int _d1, input int _d2, input bit _value );
        temp_static_data_resp_write_strobes[_d1][_d2] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_data_resp_id;
    function void axi_get_temp_static_data_resp_id( input int _d1, output bit  _value );
        _value = temp_static_data_resp_id[_d1];
    endfunction
    function void axi_set_temp_static_data_resp_id( input int _d1, input bit  _value );
        temp_static_data_resp_id[_d1] = _value;
    endfunction
    bit [7:0] temp_static_data_resp_data_user [];
    function void axi_get_temp_static_data_resp_data_user( input int _d1, output bit [7:0] _value  );
        _value = temp_static_data_resp_data_user[_d1];
    endfunction
    function void axi_set_temp_static_data_resp_data_user( input int _d1, input bit [7:0] _value  );
        temp_static_data_resp_data_user[_d1] = _value;
    endfunction
    int temp_static_data_resp_write_data_beats_delay[];
    function void axi_get_temp_static_data_resp_write_data_beats_delay( input int _d1, output int _value );
        _value = temp_static_data_resp_write_data_beats_delay[_d1];
    endfunction
    function void axi_set_temp_static_data_resp_write_data_beats_delay( input int _d1, input int _value );
        temp_static_data_resp_write_data_beats_delay[_d1] = _value;
    endfunction
    longint temp_static_data_resp_data_beat_start_time[];
    function void axi_get_temp_static_data_resp_data_beat_start_time( input int _d1, output longint _value );
        _value = temp_static_data_resp_data_beat_start_time[_d1];
    endfunction
    function void axi_set_temp_static_data_resp_data_beat_start_time( input int _d1, input longint _value );
        temp_static_data_resp_data_beat_start_time[_d1] = _value;
    endfunction
    longint temp_static_data_resp_data_beat_end_time[];
    function void axi_get_temp_static_data_resp_data_beat_end_time( input int _d1, output longint _value );
        _value = temp_static_data_resp_data_beat_end_time[_d1];
    endfunction
    function void axi_set_temp_static_data_resp_data_beat_end_time( input int _d1, input longint _value );
        temp_static_data_resp_data_beat_end_time[_d1] = _value;
    endfunction
    bit [((AXI_RDATA_WIDTH) - 1):0] temp_static_read_data_burst_data_words [];
    function void axi_get_temp_static_read_data_burst_data_words( input int _d1, input int _d2, output bit _value );
        _value = temp_static_read_data_burst_data_words[_d1][_d2];
    endfunction
    function void axi_set_temp_static_read_data_burst_data_words( input int _d1, input int _d2, input bit _value );
        temp_static_read_data_burst_data_words[_d1][_d2] = _value;
    endfunction
    int temp_static_read_data_burst_resp[];
    function void axi_get_temp_static_read_data_burst_resp( input int _d1, output int _value );
        _value = temp_static_read_data_burst_resp[_d1];
    endfunction
    function void axi_set_temp_static_read_data_burst_resp( input int _d1, input int _value );
        temp_static_read_data_burst_resp[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_read_data_burst_id;
    function void axi_get_temp_static_read_data_burst_id( input int _d1, output bit  _value );
        _value = temp_static_read_data_burst_id[_d1];
    endfunction
    function void axi_set_temp_static_read_data_burst_id( input int _d1, input bit  _value );
        temp_static_read_data_burst_id[_d1] = _value;
    endfunction
    bit [7:0] temp_static_read_data_burst_data_user [];
    function void axi_get_temp_static_read_data_burst_data_user( input int _d1, output bit [7:0] _value  );
        _value = temp_static_read_data_burst_data_user[_d1];
    endfunction
    function void axi_set_temp_static_read_data_burst_data_user( input int _d1, input bit [7:0] _value  );
        temp_static_read_data_burst_data_user[_d1] = _value;
    endfunction
    longint temp_static_read_data_burst_data_start_time[];
    function void axi_get_temp_static_read_data_burst_data_start_time( input int _d1, output longint _value );
        _value = temp_static_read_data_burst_data_start_time[_d1];
    endfunction
    function void axi_set_temp_static_read_data_burst_data_start_time( input int _d1, input longint _value );
        temp_static_read_data_burst_data_start_time[_d1] = _value;
    endfunction
    longint temp_static_read_data_burst_data_end_time[];
    function void axi_get_temp_static_read_data_burst_data_end_time( input int _d1, output longint _value );
        _value = temp_static_read_data_burst_data_end_time[_d1];
    endfunction
    function void axi_set_temp_static_read_data_burst_data_end_time( input int _d1, input longint _value );
        temp_static_read_data_burst_data_end_time[_d1] = _value;
    endfunction
    bit [((AXI_WDATA_WIDTH) - 1):0] temp_static_write_data_burst_data_words [];
    function void axi_get_temp_static_write_data_burst_data_words( input int _d1, input int _d2, output bit _value );
        _value = temp_static_write_data_burst_data_words[_d1][_d2];
    endfunction
    function void axi_set_temp_static_write_data_burst_data_words( input int _d1, input int _d2, input bit _value );
        temp_static_write_data_burst_data_words[_d1][_d2] = _value;
    endfunction
    bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] temp_static_write_data_burst_write_strobes [];
    function void axi_get_temp_static_write_data_burst_write_strobes( input int _d1, input int _d2, output bit _value );
        _value = temp_static_write_data_burst_write_strobes[_d1][_d2];
    endfunction
    function void axi_set_temp_static_write_data_burst_write_strobes( input int _d1, input int _d2, input bit _value );
        temp_static_write_data_burst_write_strobes[_d1][_d2] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_write_data_burst_id;
    function void axi_get_temp_static_write_data_burst_id( input int _d1, output bit  _value );
        _value = temp_static_write_data_burst_id[_d1];
    endfunction
    function void axi_set_temp_static_write_data_burst_id( input int _d1, input bit  _value );
        temp_static_write_data_burst_id[_d1] = _value;
    endfunction
    bit [7:0] temp_static_write_data_burst_data_user [];
    function void axi_get_temp_static_write_data_burst_data_user( input int _d1, output bit [7:0] _value  );
        _value = temp_static_write_data_burst_data_user[_d1];
    endfunction
    function void axi_set_temp_static_write_data_burst_data_user( input int _d1, input bit [7:0] _value  );
        temp_static_write_data_burst_data_user[_d1] = _value;
    endfunction
    int temp_static_write_data_burst_write_data_beats_delay[];
    function void axi_get_temp_static_write_data_burst_write_data_beats_delay( input int _d1, output int _value );
        _value = temp_static_write_data_burst_write_data_beats_delay[_d1];
    endfunction
    function void axi_set_temp_static_write_data_burst_write_data_beats_delay( input int _d1, input int _value );
        temp_static_write_data_burst_write_data_beats_delay[_d1] = _value;
    endfunction
    longint temp_static_write_data_burst_data_start_time[];
    function void axi_get_temp_static_write_data_burst_data_start_time( input int _d1, output longint _value );
        _value = temp_static_write_data_burst_data_start_time[_d1];
    endfunction
    function void axi_set_temp_static_write_data_burst_data_start_time( input int _d1, input longint _value );
        temp_static_write_data_burst_data_start_time[_d1] = _value;
    endfunction
    longint temp_static_write_data_burst_data_end_time[];
    function void axi_get_temp_static_write_data_burst_data_end_time( input int _d1, output longint _value );
        _value = temp_static_write_data_burst_data_end_time[_d1];
    endfunction
    function void axi_set_temp_static_write_data_burst_data_end_time( input int _d1, input longint _value );
        temp_static_write_data_burst_data_end_time[_d1] = _value;
    endfunction
    bit [((AXI_ADDRESS_WIDTH) - 1):0]  temp_static_read_addr_channel_phase_addr;
    function void axi_get_temp_static_read_addr_channel_phase_addr( input int _d1, output bit  _value );
        _value = temp_static_read_addr_channel_phase_addr[_d1];
    endfunction
    function void axi_set_temp_static_read_addr_channel_phase_addr( input int _d1, input bit  _value );
        temp_static_read_addr_channel_phase_addr[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_read_addr_channel_phase_id;
    function void axi_get_temp_static_read_addr_channel_phase_id( input int _d1, output bit  _value );
        _value = temp_static_read_addr_channel_phase_id[_d1];
    endfunction
    function void axi_set_temp_static_read_addr_channel_phase_id( input int _d1, input bit  _value );
        temp_static_read_addr_channel_phase_id[_d1] = _value;
    endfunction
    bit [((AXI_RDATA_WIDTH) - 1):0]  temp_static_read_channel_phase_data;
    function void axi_get_temp_static_read_channel_phase_data( input int _d1, output bit  _value );
        _value = temp_static_read_channel_phase_data[_d1];
    endfunction
    function void axi_set_temp_static_read_channel_phase_data( input int _d1, input bit  _value );
        temp_static_read_channel_phase_data[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_read_channel_phase_id;
    function void axi_get_temp_static_read_channel_phase_id( input int _d1, output bit  _value );
        _value = temp_static_read_channel_phase_id[_d1];
    endfunction
    function void axi_set_temp_static_read_channel_phase_id( input int _d1, input bit  _value );
        temp_static_read_channel_phase_id[_d1] = _value;
    endfunction
    bit [((AXI_ADDRESS_WIDTH) - 1):0]  temp_static_write_addr_channel_phase_addr;
    function void axi_get_temp_static_write_addr_channel_phase_addr( input int _d1, output bit  _value );
        _value = temp_static_write_addr_channel_phase_addr[_d1];
    endfunction
    function void axi_set_temp_static_write_addr_channel_phase_addr( input int _d1, input bit  _value );
        temp_static_write_addr_channel_phase_addr[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_write_addr_channel_phase_id;
    function void axi_get_temp_static_write_addr_channel_phase_id( input int _d1, output bit  _value );
        _value = temp_static_write_addr_channel_phase_id[_d1];
    endfunction
    function void axi_set_temp_static_write_addr_channel_phase_id( input int _d1, input bit  _value );
        temp_static_write_addr_channel_phase_id[_d1] = _value;
    endfunction
    bit [((AXI_WDATA_WIDTH) - 1):0]  temp_static_write_channel_phase_data;
    function void axi_get_temp_static_write_channel_phase_data( input int _d1, output bit  _value );
        _value = temp_static_write_channel_phase_data[_d1];
    endfunction
    function void axi_set_temp_static_write_channel_phase_data( input int _d1, input bit  _value );
        temp_static_write_channel_phase_data[_d1] = _value;
    endfunction
    bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  temp_static_write_channel_phase_write_strobes;
    function void axi_get_temp_static_write_channel_phase_write_strobes( input int _d1, output bit  _value );
        _value = temp_static_write_channel_phase_write_strobes[_d1];
    endfunction
    function void axi_set_temp_static_write_channel_phase_write_strobes( input int _d1, input bit  _value );
        temp_static_write_channel_phase_write_strobes[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_write_channel_phase_id;
    function void axi_get_temp_static_write_channel_phase_id( input int _d1, output bit  _value );
        _value = temp_static_write_channel_phase_id[_d1];
    endfunction
    function void axi_set_temp_static_write_channel_phase_id( input int _d1, input bit  _value );
        temp_static_write_channel_phase_id[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_write_resp_channel_phase_id;
    function void axi_get_temp_static_write_resp_channel_phase_id( input int _d1, output bit  _value );
        _value = temp_static_write_resp_channel_phase_id[_d1];
    endfunction
    function void axi_set_temp_static_write_resp_channel_phase_id( input int _d1, input bit  _value );
        temp_static_write_resp_channel_phase_id[_d1] = _value;
    endfunction
    bit [((AXI_ADDRESS_WIDTH) - 1):0]  temp_static_read_addr_channel_cycle_addr;
    function void axi_get_temp_static_read_addr_channel_cycle_addr( input int _d1, output bit  _value );
        _value = temp_static_read_addr_channel_cycle_addr[_d1];
    endfunction
    function void axi_set_temp_static_read_addr_channel_cycle_addr( input int _d1, input bit  _value );
        temp_static_read_addr_channel_cycle_addr[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_read_addr_channel_cycle_id;
    function void axi_get_temp_static_read_addr_channel_cycle_id( input int _d1, output bit  _value );
        _value = temp_static_read_addr_channel_cycle_id[_d1];
    endfunction
    function void axi_set_temp_static_read_addr_channel_cycle_id( input int _d1, input bit  _value );
        temp_static_read_addr_channel_cycle_id[_d1] = _value;
    endfunction
    bit [((AXI_RDATA_WIDTH) - 1):0]  temp_static_read_channel_cycle_data;
    function void axi_get_temp_static_read_channel_cycle_data( input int _d1, output bit  _value );
        _value = temp_static_read_channel_cycle_data[_d1];
    endfunction
    function void axi_set_temp_static_read_channel_cycle_data( input int _d1, input bit  _value );
        temp_static_read_channel_cycle_data[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_read_channel_cycle_id;
    function void axi_get_temp_static_read_channel_cycle_id( input int _d1, output bit  _value );
        _value = temp_static_read_channel_cycle_id[_d1];
    endfunction
    function void axi_set_temp_static_read_channel_cycle_id( input int _d1, input bit  _value );
        temp_static_read_channel_cycle_id[_d1] = _value;
    endfunction
    bit [((AXI_ADDRESS_WIDTH) - 1):0]  temp_static_write_addr_channel_cycle_addr;
    function void axi_get_temp_static_write_addr_channel_cycle_addr( input int _d1, output bit  _value );
        _value = temp_static_write_addr_channel_cycle_addr[_d1];
    endfunction
    function void axi_set_temp_static_write_addr_channel_cycle_addr( input int _d1, input bit  _value );
        temp_static_write_addr_channel_cycle_addr[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_write_addr_channel_cycle_id;
    function void axi_get_temp_static_write_addr_channel_cycle_id( input int _d1, output bit  _value );
        _value = temp_static_write_addr_channel_cycle_id[_d1];
    endfunction
    function void axi_set_temp_static_write_addr_channel_cycle_id( input int _d1, input bit  _value );
        temp_static_write_addr_channel_cycle_id[_d1] = _value;
    endfunction
    bit [((AXI_WDATA_WIDTH) - 1):0]  temp_static_write_channel_cycle_data;
    function void axi_get_temp_static_write_channel_cycle_data( input int _d1, output bit  _value );
        _value = temp_static_write_channel_cycle_data[_d1];
    endfunction
    function void axi_set_temp_static_write_channel_cycle_data( input int _d1, input bit  _value );
        temp_static_write_channel_cycle_data[_d1] = _value;
    endfunction
    bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  temp_static_write_channel_cycle_strb;
    function void axi_get_temp_static_write_channel_cycle_strb( input int _d1, output bit  _value );
        _value = temp_static_write_channel_cycle_strb[_d1];
    endfunction
    function void axi_set_temp_static_write_channel_cycle_strb( input int _d1, input bit  _value );
        temp_static_write_channel_cycle_strb[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_write_channel_cycle_id;
    function void axi_get_temp_static_write_channel_cycle_id( input int _d1, output bit  _value );
        _value = temp_static_write_channel_cycle_id[_d1];
    endfunction
    function void axi_set_temp_static_write_channel_cycle_id( input int _d1, input bit  _value );
        temp_static_write_channel_cycle_id[_d1] = _value;
    endfunction
    bit [((AXI_ID_WIDTH) - 1):0]  temp_static_write_resp_channel_cycle_id;
    function void axi_get_temp_static_write_resp_channel_cycle_id( input int _d1, output bit  _value );
        _value = temp_static_write_resp_channel_cycle_id[_d1];
    endfunction
    function void axi_set_temp_static_write_resp_channel_cycle_id( input int _d1, input bit  _value );
        temp_static_write_resp_channel_cycle_id[_d1] = _value;
    endfunction
    task automatic do_dvc_activate_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi_size_e size,
        ref axi_burst_e burst,
        ref axi_lock_e lock,
        ref axi_cache_e cache,
        ref axi_prot_e prot,
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [3:0] burst_length,
        ref bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref axi_response_e resp[],
        ref bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        ref bit [7:0] resp_user,
        ref axi_rw_e read_or_write,
        ref int address_to_data_latency,
        ref int data_to_response_latency,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        ref int address_valid_delay,
        ref int data_valid_delay[],
        ref int write_response_valid_delay,
        ref int address_ready_delay,
        ref int data_ready_delay[],
        ref int write_response_ready_delay,
        ref bit write_data_with_address,
        input int _unit_id = 0
    );
        begin
            int _trans_id;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;
            int tmp_resp[];
            int tmp_read_or_write;
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );
            tmp_prot = int'( prot );
            begin
            tmp_resp = new [resp.size()];
            for (int _i_1= 0; _i_1 < ( resp.size() ); _i_1++)
            begin
            tmp_resp[_i_1] = int'( resp[_i_1] );
            
            end
            end/* 1 */ 
            tmp_read_or_write = int'( read_or_write );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int resp_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_valid_delay_DIMS0;
                automatic int data_ready_delay_DIMS0;
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_rw_transaction_addr = addr;
                temp_static_rw_transaction_id = id;
                data_words_DIMS0 = data_words.size();
                temp_static_rw_transaction_data_words = data_words;
                write_strobes_DIMS0 = write_strobes.size();
                temp_static_rw_transaction_write_strobes = write_strobes;
                resp_DIMS0 = resp.size();
                temp_static_rw_transaction_resp = tmp_resp;
                data_user_DIMS0 = data_user.size();
                temp_static_rw_transaction_data_user = data_user;
                write_data_beats_delay_DIMS0 = write_data_beats_delay.size();
                temp_static_rw_transaction_write_data_beats_delay = write_data_beats_delay;
                data_valid_delay_DIMS0 = data_valid_delay.size();
                temp_static_rw_transaction_data_valid_delay = data_valid_delay;
                data_ready_delay_DIMS0 = data_ready_delay.size();
                temp_static_rw_transaction_data_ready_delay = data_ready_delay;
                // Call function to provide sized params and ingoing unsized params sizes.
                // In addition gets back updated sizes of unsized params.
                axi_rw_transaction_ActivatesActivatingActivate_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, burst_length, data_words_DIMS0, write_strobes_DIMS0, resp_DIMS0, addr_user, data_user_DIMS0, resp_user, tmp_read_or_write, address_to_data_latency, data_to_response_latency, write_address_to_data_delay, write_data_to_address_delay, write_data_beats_delay_DIMS0, address_valid_delay, data_valid_delay_DIMS0, write_response_valid_delay, address_ready_delay, data_ready_delay_DIMS0, write_response_ready_delay, write_data_with_address, _unit_id); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_write_strobes.delete();
                end
                if (resp_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_resp = new [resp_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_resp.delete();
                end
                if (data_user_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_user = new [data_user_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_user.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_write_data_beats_delay.delete();
                end
                if (data_valid_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_valid_delay = new [data_valid_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_valid_delay.delete();
                end
                if (data_ready_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_ready_delay = new [data_ready_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_ready_delay.delete();
                end
                // Call function to get the sized params
                axi_rw_transaction_ActivatesActivatingActivate_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, burst_length, addr_user, resp_user, tmp_read_or_write, address_to_data_latency, data_to_response_latency, write_address_to_data_delay, write_data_to_address_delay, address_valid_delay, write_response_valid_delay, address_ready_delay, write_response_ready_delay, write_data_with_address, _unit_id); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_rw_transaction_addr;
                id = temp_static_rw_transaction_id;
                data_words = temp_static_rw_transaction_data_words;
                temp_static_rw_transaction_data_words.delete();
                write_strobes = temp_static_rw_transaction_write_strobes;
                temp_static_rw_transaction_write_strobes.delete();
                tmp_resp = temp_static_rw_transaction_resp;
                temp_static_rw_transaction_resp.delete();
                data_user = temp_static_rw_transaction_data_user;
                temp_static_rw_transaction_data_user.delete();
                write_data_beats_delay = temp_static_rw_transaction_write_data_beats_delay;
                temp_static_rw_transaction_write_data_beats_delay.delete();
                data_valid_delay = temp_static_rw_transaction_data_valid_delay;
                temp_static_rw_transaction_data_valid_delay.delete();
                data_ready_delay = temp_static_rw_transaction_data_ready_delay;
                temp_static_rw_transaction_data_ready_delay.delete();
            end // Block to create unsized data arrays
            size = axi_size_e'( tmp_size );
            burst = axi_burst_e'( tmp_burst );
            lock = axi_lock_e'( tmp_lock );
            cache = axi_cache_e'( tmp_cache );
            prot = axi_prot_e'( tmp_prot );
            begin
            resp = new [tmp_resp.size()];
            for (int _i_1= 0; _i_1 < ( tmp_resp.size() ); _i_1++)
            begin
            resp[_i_1] = axi_response_e'( tmp_resp[_i_1] );
            
            end
            end/* 1 */ 
            read_or_write = axi_rw_e'( tmp_read_or_write );
        end
    endtask

    task automatic do_dvc_get_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        ref bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref axi_response_e resp[],
        output bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output axi_rw_e read_or_write,
        output int address_to_data_latency,
        output int data_to_response_latency,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        output int address_valid_delay,
        ref int data_valid_delay[],
        output int write_response_valid_delay,
        output int address_ready_delay,
        ref int data_ready_delay[],
        output int write_response_ready_delay,
        output bit write_data_with_address,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;
            int tmp_resp[];
            int tmp_read_or_write;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int resp_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_valid_delay_DIMS0;
                automatic int data_ready_delay_DIMS0;
                // Call function to get unsized params sizes.
                axi_rw_transaction_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, write_strobes_DIMS0, resp_DIMS0, data_user_DIMS0, write_data_beats_delay_DIMS0, data_valid_delay_DIMS0, data_ready_delay_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_write_strobes.delete();
                end
                if (resp_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_resp = new [resp_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_resp.delete();
                end
                if (data_user_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_user = new [data_user_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_user.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_write_data_beats_delay.delete();
                end
                if (data_valid_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_valid_delay = new [data_valid_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_valid_delay.delete();
                end
                if (data_ready_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_ready_delay = new [data_ready_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_ready_delay.delete();
                end
                // Call function to get the sized params
                axi_rw_transaction_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, burst_length, addr_user, resp_user, tmp_read_or_write, address_to_data_latency, data_to_response_latency, write_address_to_data_delay, write_data_to_address_delay, address_valid_delay, write_response_valid_delay, address_ready_delay, write_response_ready_delay, write_data_with_address, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_rw_transaction_addr;
                id = temp_static_rw_transaction_id;
                data_words = temp_static_rw_transaction_data_words;
                temp_static_rw_transaction_data_words.delete();
                write_strobes = temp_static_rw_transaction_write_strobes;
                temp_static_rw_transaction_write_strobes.delete();
                tmp_resp = temp_static_rw_transaction_resp;
                temp_static_rw_transaction_resp.delete();
                data_user = temp_static_rw_transaction_data_user;
                temp_static_rw_transaction_data_user.delete();
                write_data_beats_delay = temp_static_rw_transaction_write_data_beats_delay;
                temp_static_rw_transaction_write_data_beats_delay.delete();
                data_valid_delay = temp_static_rw_transaction_data_valid_delay;
                temp_static_rw_transaction_data_valid_delay.delete();
                data_ready_delay = temp_static_rw_transaction_data_ready_delay;
                temp_static_rw_transaction_data_ready_delay.delete();
            end // Block to create unsized data arrays
            size = axi_size_e'( tmp_size );
            burst = axi_burst_e'( tmp_burst );
            lock = axi_lock_e'( tmp_lock );
            cache = axi_cache_e'( tmp_cache );
            prot = axi_prot_e'( tmp_prot );
            begin
            resp = new [tmp_resp.size()];
            for (int _i_1= 0; _i_1 < ( tmp_resp.size() ); _i_1++)
            begin
            resp[_i_1] = axi_response_e'( tmp_resp[_i_1] );
            
            end
            end/* 1 */ 
            read_or_write = axi_rw_e'( tmp_read_or_write );
        end
    endtask

    task automatic do_dvc_activate_AXI_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi_size_e size,
        ref axi_burst_e burst,
        ref axi_lock_e lock,
        ref axi_cache_e cache,
        ref axi_prot_e prot,
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        ref bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        ref int address_to_data_latency,
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int address_valid_delay,
        input int _unit_id = 0
    );
        begin
            int _trans_id;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;
            int tmp_resp[];
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );
            tmp_prot = int'( prot );
            begin
            tmp_resp = new [resp.size()];
            for (int _i_1= 0; _i_1 < ( resp.size() ); _i_1++)
            begin
            tmp_resp[_i_1] = int'( resp[_i_1] );
            
            end
            end/* 1 */ 

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int resp_DIMS0;
                automatic int data_user_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_AXI_read_addr = addr;
                temp_static_AXI_read_id = id;
                data_words_DIMS0 = data_words.size();
                temp_static_AXI_read_data_words = data_words;
                resp_DIMS0 = resp.size();
                temp_static_AXI_read_resp = tmp_resp;
                data_user_DIMS0 = data_user.size();
                temp_static_AXI_read_data_user = data_user;
                data_start_time_DIMS0 = data_start_time.size();
                temp_static_AXI_read_data_start_time = data_start_time;
                data_end_time_DIMS0 = data_end_time.size();
                temp_static_AXI_read_data_end_time = data_end_time;
                // Call function to provide sized params and ingoing unsized params sizes.
                // In addition gets back updated sizes of unsized params.
                axi_AXI_read_ActivatesActivatingActivate_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, burst_length, data_words_DIMS0, resp_DIMS0, addr_user, data_user_DIMS0, address_to_data_latency, addr_start_time, addr_end_time, data_start_time_DIMS0, data_end_time_DIMS0, address_valid_delay, _unit_id); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_AXI_read_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_AXI_read_data_words.delete();
                end
                if (resp_DIMS0 != 0)
                begin
                    temp_static_AXI_read_resp = new [resp_DIMS0];
                end
                else
                begin
                    temp_static_AXI_read_resp.delete();
                end
                if (data_user_DIMS0 != 0)
                begin
                    temp_static_AXI_read_data_user = new [data_user_DIMS0];
                end
                else
                begin
                    temp_static_AXI_read_data_user.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_AXI_read_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_AXI_read_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_AXI_read_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_AXI_read_data_end_time.delete();
                end
                // Call function to get the sized params
                axi_AXI_read_ActivatesActivatingActivate_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, burst_length, addr_user, address_to_data_latency, addr_start_time, addr_end_time, address_valid_delay, _unit_id); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_AXI_read_addr;
                id = temp_static_AXI_read_id;
                data_words = temp_static_AXI_read_data_words;
                temp_static_AXI_read_data_words.delete();
                tmp_resp = temp_static_AXI_read_resp;
                temp_static_AXI_read_resp.delete();
                data_user = temp_static_AXI_read_data_user;
                temp_static_AXI_read_data_user.delete();
                data_start_time = temp_static_AXI_read_data_start_time;
                temp_static_AXI_read_data_start_time.delete();
                data_end_time = temp_static_AXI_read_data_end_time;
                temp_static_AXI_read_data_end_time.delete();
            end // Block to create unsized data arrays
            size = axi_size_e'( tmp_size );
            burst = axi_burst_e'( tmp_burst );
            lock = axi_lock_e'( tmp_lock );
            cache = axi_cache_e'( tmp_cache );
            prot = axi_prot_e'( tmp_prot );
            begin
            resp = new [tmp_resp.size()];
            for (int _i_1= 0; _i_1 < ( tmp_resp.size() ); _i_1++)
            begin
            resp[_i_1] = axi_response_e'( tmp_resp[_i_1] );
            
            end
            end/* 1 */ 
        end
    endtask

    task automatic do_dvc_get_AXI_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        output bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        output int address_to_data_latency,
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output int address_valid_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;
            int tmp_resp[];

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int resp_DIMS0;
                automatic int data_user_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Call function to get unsized params sizes.
                axi_AXI_read_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, resp_DIMS0, data_user_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_AXI_read_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_AXI_read_data_words.delete();
                end
                if (resp_DIMS0 != 0)
                begin
                    temp_static_AXI_read_resp = new [resp_DIMS0];
                end
                else
                begin
                    temp_static_AXI_read_resp.delete();
                end
                if (data_user_DIMS0 != 0)
                begin
                    temp_static_AXI_read_data_user = new [data_user_DIMS0];
                end
                else
                begin
                    temp_static_AXI_read_data_user.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_AXI_read_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_AXI_read_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_AXI_read_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_AXI_read_data_end_time.delete();
                end
                // Call function to get the sized params
                axi_AXI_read_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, burst_length, addr_user, address_to_data_latency, addr_start_time, addr_end_time, address_valid_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_AXI_read_addr;
                id = temp_static_AXI_read_id;
                data_words = temp_static_AXI_read_data_words;
                temp_static_AXI_read_data_words.delete();
                tmp_resp = temp_static_AXI_read_resp;
                temp_static_AXI_read_resp.delete();
                data_user = temp_static_AXI_read_data_user;
                temp_static_AXI_read_data_user.delete();
                data_start_time = temp_static_AXI_read_data_start_time;
                temp_static_AXI_read_data_start_time.delete();
                data_end_time = temp_static_AXI_read_data_end_time;
                temp_static_AXI_read_data_end_time.delete();
            end // Block to create unsized data arrays
            size = axi_size_e'( tmp_size );
            burst = axi_burst_e'( tmp_burst );
            lock = axi_lock_e'( tmp_lock );
            cache = axi_cache_e'( tmp_cache );
            prot = axi_prot_e'( tmp_prot );
            begin
            resp = new [tmp_resp.size()];
            for (int _i_1= 0; _i_1 < ( tmp_resp.size() ); _i_1++)
            begin
            resp[_i_1] = axi_response_e'( tmp_resp[_i_1] );
            
            end
            end/* 1 */ 
        end
    endtask

    task automatic do_dvc_activate_AXI_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi_size_e size,
        ref axi_burst_e burst,
        ref axi_lock_e lock,
        ref axi_cache_e cache,
        ref axi_prot_e prot,
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [3:0] burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref axi_response_e resp,
        ref bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        ref bit [7:0] resp_user,
        ref int address_to_data_latency,
        ref int data_to_response_latency,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref longint wr_resp_start_time,
        ref longint wr_resp_end_time,
        ref int address_valid_delay,
        input int _unit_id = 0
    );
        begin
            int _trans_id;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;
            int tmp_resp;
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );
            tmp_prot = int'( prot );
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_AXI_write_addr = addr;
                temp_static_AXI_write_id = id;
                data_words_DIMS0 = data_words.size();
                temp_static_AXI_write_data_words = data_words;
                write_strobes_DIMS0 = write_strobes.size();
                temp_static_AXI_write_write_strobes = write_strobes;
                data_user_DIMS0 = data_user.size();
                temp_static_AXI_write_data_user = data_user;
                write_data_beats_delay_DIMS0 = write_data_beats_delay.size();
                temp_static_AXI_write_write_data_beats_delay = write_data_beats_delay;
                data_start_time_DIMS0 = data_start_time.size();
                temp_static_AXI_write_data_start_time = data_start_time;
                data_end_time_DIMS0 = data_end_time.size();
                temp_static_AXI_write_data_end_time = data_end_time;
                // Call function to provide sized params and ingoing unsized params sizes.
                // In addition gets back updated sizes of unsized params.
                axi_AXI_write_ActivatesActivatingActivate_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, burst_length, data_words_DIMS0, write_strobes_DIMS0, tmp_resp, addr_user, data_user_DIMS0, resp_user, address_to_data_latency, data_to_response_latency, write_address_to_data_delay, write_data_to_address_delay, write_data_beats_delay_DIMS0, addr_start_time, addr_end_time, data_start_time_DIMS0, data_end_time_DIMS0, wr_resp_start_time, wr_resp_end_time, address_valid_delay, _unit_id); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_AXI_write_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_AXI_write_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_write_strobes.delete();
                end
                if (data_user_DIMS0 != 0)
                begin
                    temp_static_AXI_write_data_user = new [data_user_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_data_user.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_AXI_write_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_write_data_beats_delay.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_AXI_write_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_AXI_write_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_data_end_time.delete();
                end
                // Call function to get the sized params
                axi_AXI_write_ActivatesActivatingActivate_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, burst_length, tmp_resp, addr_user, resp_user, address_to_data_latency, data_to_response_latency, write_address_to_data_delay, write_data_to_address_delay, addr_start_time, addr_end_time, wr_resp_start_time, wr_resp_end_time, address_valid_delay, _unit_id); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_AXI_write_addr;
                id = temp_static_AXI_write_id;
                data_words = temp_static_AXI_write_data_words;
                temp_static_AXI_write_data_words.delete();
                write_strobes = temp_static_AXI_write_write_strobes;
                temp_static_AXI_write_write_strobes.delete();
                data_user = temp_static_AXI_write_data_user;
                temp_static_AXI_write_data_user.delete();
                write_data_beats_delay = temp_static_AXI_write_write_data_beats_delay;
                temp_static_AXI_write_write_data_beats_delay.delete();
                data_start_time = temp_static_AXI_write_data_start_time;
                temp_static_AXI_write_data_start_time.delete();
                data_end_time = temp_static_AXI_write_data_end_time;
                temp_static_AXI_write_data_end_time.delete();
            end // Block to create unsized data arrays
            size = axi_size_e'( tmp_size );
            burst = axi_burst_e'( tmp_burst );
            lock = axi_lock_e'( tmp_lock );
            cache = axi_cache_e'( tmp_cache );
            prot = axi_prot_e'( tmp_prot );
            resp = axi_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_get_AXI_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output axi_response_e resp,
        output bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output int address_to_data_latency,
        output int data_to_response_latency,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output longint wr_resp_start_time,
        output longint wr_resp_end_time,
        output int address_valid_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Call function to get unsized params sizes.
                axi_AXI_write_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, write_strobes_DIMS0, data_user_DIMS0, write_data_beats_delay_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_AXI_write_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_AXI_write_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_write_strobes.delete();
                end
                if (data_user_DIMS0 != 0)
                begin
                    temp_static_AXI_write_data_user = new [data_user_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_data_user.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_AXI_write_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_write_data_beats_delay.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_AXI_write_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_AXI_write_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_AXI_write_data_end_time.delete();
                end
                // Call function to get the sized params
                axi_AXI_write_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, burst_length, tmp_resp, addr_user, resp_user, address_to_data_latency, data_to_response_latency, write_address_to_data_delay, write_data_to_address_delay, addr_start_time, addr_end_time, wr_resp_start_time, wr_resp_end_time, address_valid_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_AXI_write_addr;
                id = temp_static_AXI_write_id;
                data_words = temp_static_AXI_write_data_words;
                temp_static_AXI_write_data_words.delete();
                write_strobes = temp_static_AXI_write_write_strobes;
                temp_static_AXI_write_write_strobes.delete();
                data_user = temp_static_AXI_write_data_user;
                temp_static_AXI_write_data_user.delete();
                write_data_beats_delay = temp_static_AXI_write_write_data_beats_delay;
                temp_static_AXI_write_write_data_beats_delay.delete();
                data_start_time = temp_static_AXI_write_data_start_time;
                temp_static_AXI_write_data_start_time.delete();
                data_end_time = temp_static_AXI_write_data_end_time;
                temp_static_AXI_write_data_end_time.delete();
            end // Block to create unsized data arrays
            size = axi_size_e'( tmp_size );
            burst = axi_burst_e'( tmp_burst );
            lock = axi_lock_e'( tmp_lock );
            cache = axi_cache_e'( tmp_cache );
            prot = axi_prot_e'( tmp_prot );
            resp = axi_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_activate_data_resp
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref axi_response_e resp,
        ref bit [7:0] data_user [],
        ref bit [7:0] resp_user,
        ref longint data_start,
        ref longint data_end,
        ref longint response_start,
        ref int write_data_beats_delay[],
        ref longint data_beat_start_time[],
        ref longint data_beat_end_time[],
        ref longint response_end_time,
        input int _unit_id = 0
    );
        begin
            int _trans_id;
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_beat_start_time_DIMS0;
                automatic int data_beat_end_time_DIMS0;
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                data_words_DIMS0 = data_words.size();
                temp_static_data_resp_data_words = data_words;
                write_strobes_DIMS0 = write_strobes.size();
                temp_static_data_resp_write_strobes = write_strobes;
                temp_static_data_resp_id = id;
                data_user_DIMS0 = data_user.size();
                temp_static_data_resp_data_user = data_user;
                write_data_beats_delay_DIMS0 = write_data_beats_delay.size();
                temp_static_data_resp_write_data_beats_delay = write_data_beats_delay;
                data_beat_start_time_DIMS0 = data_beat_start_time.size();
                temp_static_data_resp_data_beat_start_time = data_beat_start_time;
                data_beat_end_time_DIMS0 = data_beat_end_time.size();
                temp_static_data_resp_data_beat_end_time = data_beat_end_time;
                // Call function to provide sized params and ingoing unsized params sizes.
                // In addition gets back updated sizes of unsized params.
                axi_data_resp_ActivatesActivatingActivate_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, data_words_DIMS0, write_strobes_DIMS0, tmp_resp, data_user_DIMS0, resp_user, data_start, data_end, response_start, write_data_beats_delay_DIMS0, data_beat_start_time_DIMS0, data_beat_end_time_DIMS0, response_end_time, _unit_id); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_data_resp_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_data_resp_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_write_strobes.delete();
                end
                if (data_user_DIMS0 != 0)
                begin
                    temp_static_data_resp_data_user = new [data_user_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_data_user.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_data_resp_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_write_data_beats_delay.delete();
                end
                if (data_beat_start_time_DIMS0 != 0)
                begin
                    temp_static_data_resp_data_beat_start_time = new [data_beat_start_time_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_data_beat_start_time.delete();
                end
                if (data_beat_end_time_DIMS0 != 0)
                begin
                    temp_static_data_resp_data_beat_end_time = new [data_beat_end_time_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_data_beat_end_time.delete();
                end
                // Call function to get the sized params
                axi_data_resp_ActivatesActivatingActivate_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, tmp_resp, resp_user, data_start, data_end, response_start, response_end_time, _unit_id); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data_words = temp_static_data_resp_data_words;
                temp_static_data_resp_data_words.delete();
                write_strobes = temp_static_data_resp_write_strobes;
                temp_static_data_resp_write_strobes.delete();
                id = temp_static_data_resp_id;
                data_user = temp_static_data_resp_data_user;
                temp_static_data_resp_data_user.delete();
                write_data_beats_delay = temp_static_data_resp_write_data_beats_delay;
                temp_static_data_resp_write_data_beats_delay.delete();
                data_beat_start_time = temp_static_data_resp_data_beat_start_time;
                temp_static_data_resp_data_beat_start_time.delete();
                data_beat_end_time = temp_static_data_resp_data_beat_end_time;
                temp_static_data_resp_data_beat_end_time.delete();
            end // Block to create unsized data arrays
            resp = axi_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_get_data_resp
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output axi_response_e resp,
        ref bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output longint data_start,
        output longint data_end,
        output longint response_start,
        ref int write_data_beats_delay[],
        ref longint data_beat_start_time[],
        ref longint data_beat_end_time[],
        output longint response_end_time,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_beat_start_time_DIMS0;
                automatic int data_beat_end_time_DIMS0;
                // Call function to get unsized params sizes.
                axi_data_resp_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, write_strobes_DIMS0, data_user_DIMS0, write_data_beats_delay_DIMS0, data_beat_start_time_DIMS0, data_beat_end_time_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_data_resp_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_data_resp_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_write_strobes.delete();
                end
                if (data_user_DIMS0 != 0)
                begin
                    temp_static_data_resp_data_user = new [data_user_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_data_user.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_data_resp_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_write_data_beats_delay.delete();
                end
                if (data_beat_start_time_DIMS0 != 0)
                begin
                    temp_static_data_resp_data_beat_start_time = new [data_beat_start_time_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_data_beat_start_time.delete();
                end
                if (data_beat_end_time_DIMS0 != 0)
                begin
                    temp_static_data_resp_data_beat_end_time = new [data_beat_end_time_DIMS0];
                end
                else
                begin
                    temp_static_data_resp_data_beat_end_time.delete();
                end
                // Call function to get the sized params
                axi_data_resp_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, tmp_resp, resp_user, data_start, data_end, response_start, response_end_time, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data_words = temp_static_data_resp_data_words;
                temp_static_data_resp_data_words.delete();
                write_strobes = temp_static_data_resp_write_strobes;
                temp_static_data_resp_write_strobes.delete();
                id = temp_static_data_resp_id;
                data_user = temp_static_data_resp_data_user;
                temp_static_data_resp_data_user.delete();
                write_data_beats_delay = temp_static_data_resp_write_data_beats_delay;
                temp_static_data_resp_write_data_beats_delay.delete();
                data_beat_start_time = temp_static_data_resp_data_beat_start_time;
                temp_static_data_resp_data_beat_start_time.delete();
                data_beat_end_time = temp_static_data_resp_data_beat_end_time;
                temp_static_data_resp_data_beat_end_time.delete();
            end // Block to create unsized data arrays
            resp = axi_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0
    );
        begin
            int tmp_resp[];
            begin
            tmp_resp = new [resp.size()];
            for (int _i_1= 0; _i_1 < ( resp.size() ); _i_1++)
            begin
            tmp_resp[_i_1] = int'( resp[_i_1] );
            
            end
            end/* 1 */ 

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int resp_DIMS0;
                automatic int data_user_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                data_words_DIMS0 = data_words.size();
                temp_static_read_data_burst_data_words = data_words;
                resp_DIMS0 = resp.size();
                temp_static_read_data_burst_resp = tmp_resp;
                temp_static_read_data_burst_id = id;
                data_user_DIMS0 = data_user.size();
                temp_static_read_data_burst_data_user = data_user;
                data_start_time_DIMS0 = data_start_time.size();
                temp_static_read_data_burst_data_start_time = data_start_time;
                data_end_time_DIMS0 = data_end_time.size();
                temp_static_read_data_burst_data_end_time = data_end_time;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_read_data_burst_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, burst_length, data_words_DIMS0, resp_DIMS0, data_user_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
                temp_static_read_data_burst_data_words.delete();
                temp_static_read_data_burst_resp.delete();
                temp_static_read_data_burst_data_user.delete();
                temp_static_read_data_burst_data_start_time.delete();
                temp_static_read_data_burst_data_end_time.delete();
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp[];

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int resp_DIMS0;
                automatic int data_user_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Call function to get unsized params sizes.
                axi_read_data_burst_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, resp_DIMS0, data_user_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_read_data_burst_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_read_data_burst_data_words.delete();
                end
                if (resp_DIMS0 != 0)
                begin
                    temp_static_read_data_burst_resp = new [resp_DIMS0];
                end
                else
                begin
                    temp_static_read_data_burst_resp.delete();
                end
                if (data_user_DIMS0 != 0)
                begin
                    temp_static_read_data_burst_data_user = new [data_user_DIMS0];
                end
                else
                begin
                    temp_static_read_data_burst_data_user.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_read_data_burst_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_read_data_burst_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_read_data_burst_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_read_data_burst_data_end_time.delete();
                end
                // Call function to get the sized params
                axi_read_data_burst_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data_words = temp_static_read_data_burst_data_words;
                temp_static_read_data_burst_data_words.delete();
                tmp_resp = temp_static_read_data_burst_resp;
                temp_static_read_data_burst_resp.delete();
                id = temp_static_read_data_burst_id;
                data_user = temp_static_read_data_burst_data_user;
                temp_static_read_data_burst_data_user.delete();
                data_start_time = temp_static_read_data_burst_data_start_time;
                temp_static_read_data_burst_data_start_time.delete();
                data_end_time = temp_static_read_data_burst_data_end_time;
                temp_static_read_data_burst_data_end_time.delete();
            end // Block to create unsized data arrays
            begin
            resp = new [tmp_resp.size()];
            for (int _i_1= 0; _i_1 < ( tmp_resp.size() ); _i_1++)
            begin
            resp[_i_1] = axi_response_e'( tmp_resp[_i_1] );
            
            end
            end/* 1 */ 
        end
    endtask

    task automatic do_dvc_put_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref int write_data_beats_delay[],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                data_words_DIMS0 = data_words.size();
                temp_static_write_data_burst_data_words = data_words;
                write_strobes_DIMS0 = write_strobes.size();
                temp_static_write_data_burst_write_strobes = write_strobes;
                temp_static_write_data_burst_id = id;
                data_user_DIMS0 = data_user.size();
                temp_static_write_data_burst_data_user = data_user;
                write_data_beats_delay_DIMS0 = write_data_beats_delay.size();
                temp_static_write_data_burst_write_data_beats_delay = write_data_beats_delay;
                data_start_time_DIMS0 = data_start_time.size();
                temp_static_write_data_burst_data_start_time = data_start_time;
                data_end_time_DIMS0 = data_end_time.size();
                temp_static_write_data_burst_data_end_time = data_end_time;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_write_data_burst_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, burst_length, data_words_DIMS0, write_strobes_DIMS0, data_user_DIMS0, write_data_beats_delay_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
                temp_static_write_data_burst_data_words.delete();
                temp_static_write_data_burst_write_strobes.delete();
                temp_static_write_data_burst_data_user.delete();
                temp_static_write_data_burst_write_data_beats_delay.delete();
                temp_static_write_data_burst_data_start_time.delete();
                temp_static_write_data_burst_data_end_time.delete();
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref int write_data_beats_delay[],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int data_user_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Call function to get unsized params sizes.
                axi_write_data_burst_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, write_strobes_DIMS0, data_user_DIMS0, write_data_beats_delay_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_write_strobes.delete();
                end
                if (data_user_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_data_user = new [data_user_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_data_user.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_write_data_beats_delay.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_data_end_time.delete();
                end
                // Call function to get the sized params
                axi_write_data_burst_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data_words = temp_static_write_data_burst_data_words;
                temp_static_write_data_burst_data_words.delete();
                write_strobes = temp_static_write_data_burst_write_strobes;
                temp_static_write_data_burst_write_strobes.delete();
                id = temp_static_write_data_burst_id;
                data_user = temp_static_write_data_burst_data_user;
                temp_static_write_data_burst_data_user.delete();
                write_data_beats_delay = temp_static_write_data_burst_write_data_beats_delay;
                temp_static_write_data_burst_write_data_beats_delay.delete();
                data_start_time = temp_static_write_data_burst_data_start_time;
                temp_static_write_data_burst_data_start_time.delete();
                data_end_time = temp_static_write_data_burst_data_end_time;
                temp_static_write_data_burst_data_end_time.delete();
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_put_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
        begin
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );
            tmp_prot = int'( prot );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_read_addr_channel_phase_addr = addr;
                temp_static_read_addr_channel_phase_id = id;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_read_addr_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, addr_user, address_valid_delay, address_ready_delay, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi_read_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi_read_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, addr_user, address_valid_delay, address_ready_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_read_addr_channel_phase_addr;
                id = temp_static_read_addr_channel_phase_id;
            end // Block to create unsized data arrays
            size = axi_size_e'( tmp_size );
            burst = axi_burst_e'( tmp_burst );
            lock = axi_lock_e'( tmp_lock );
            cache = axi_cache_e'( tmp_cache );
            prot = axi_prot_e'( tmp_prot );
        end
    endtask

    task automatic do_dvc_put_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int data_ready_delay,
        input int _unit_id = 0
    );
        begin
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_read_channel_phase_data = data;
                temp_static_read_channel_phase_id = id;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_read_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, last, tmp_resp, data_user, data_ready_delay, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi_read_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi_read_channel_phase_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, last, tmp_resp, data_user, data_ready_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data = temp_static_read_channel_phase_data;
                id = temp_static_read_channel_phase_id;
            end // Block to create unsized data arrays
            resp = axi_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
        begin
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );
            tmp_prot = int'( prot );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_addr_channel_phase_addr = addr;
                temp_static_write_addr_channel_phase_id = id;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_write_addr_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, addr_user, address_valid_delay, address_ready_delay, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi_write_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi_write_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, addr_user, address_valid_delay, address_ready_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_write_addr_channel_phase_addr;
                id = temp_static_write_addr_channel_phase_id;
            end // Block to create unsized data arrays
            size = axi_size_e'( tmp_size );
            burst = axi_burst_e'( tmp_burst );
            lock = axi_lock_e'( tmp_lock );
            cache = axi_cache_e'( tmp_cache );
            prot = axi_prot_e'( tmp_prot );
        end
    endtask

    task automatic do_dvc_put_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int data_ready_delay,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_channel_phase_data = data;
                temp_static_write_channel_phase_write_strobes = write_strobes;
                temp_static_write_channel_phase_id = id;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_write_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, last, data_user, data_ready_delay, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi_write_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi_write_channel_phase_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, last, data_user, data_ready_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data = temp_static_write_channel_phase_data;
                write_strobes = temp_static_write_channel_phase_write_strobes;
                id = temp_static_write_channel_phase_id;
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_put_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] resp_user,
        input int write_response_ready_delay,
        input int _unit_id = 0
    );
        begin
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_resp_channel_phase_id = id;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_write_resp_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, tmp_resp, resp_user, write_response_ready_delay, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] resp_user,
        output int write_response_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi_write_resp_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi_write_resp_channel_phase_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_resp, resp_user, write_response_ready_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                id = temp_static_write_resp_channel_phase_id;
            end // Block to create unsized data arrays
            resp = axi_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int _unit_id = 0
    );
        begin
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );
            tmp_prot = int'( prot );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_read_addr_channel_cycle_addr = addr;
                temp_static_read_addr_channel_cycle_id = id;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_read_addr_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, addr_user, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi_read_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi_read_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, addr_user, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_read_addr_channel_cycle_addr;
                id = temp_static_read_addr_channel_cycle_id;
            end // Block to create unsized data arrays
            size = axi_size_e'( tmp_size );
            burst = axi_burst_e'( tmp_burst );
            lock = axi_lock_e'( tmp_lock );
            cache = axi_cache_e'( tmp_cache );
            prot = axi_prot_e'( tmp_prot );
        end
    endtask

    task automatic do_dvc_put_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_read_addr_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_read_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_put_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int _unit_id = 0
    );
        begin
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_read_channel_cycle_data = data;
                temp_static_read_channel_cycle_id = id;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_read_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, last, tmp_resp, data_user, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi_read_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi_read_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, last, tmp_resp, data_user, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data = temp_static_read_channel_cycle_data;
                id = temp_static_read_channel_cycle_id;
            end // Block to create unsized data arrays
            resp = axi_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_read_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_read_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_put_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int _unit_id = 0
    );
        begin
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );
            tmp_prot = int'( prot );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_addr_channel_cycle_addr = addr;
                temp_static_write_addr_channel_cycle_id = id;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_write_addr_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, addr_user, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_prot;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi_write_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi_write_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, tmp_prot, addr_user, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_write_addr_channel_cycle_addr;
                id = temp_static_write_addr_channel_cycle_id;
            end // Block to create unsized data arrays
            size = axi_size_e'( tmp_size );
            burst = axi_burst_e'( tmp_burst );
            lock = axi_lock_e'( tmp_lock );
            cache = axi_cache_e'( tmp_cache );
            prot = axi_prot_e'( tmp_prot );
        end
    endtask

    task automatic do_dvc_put_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_addr_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_put_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  strb,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_channel_cycle_data = data;
                temp_static_write_channel_cycle_strb = strb;
                temp_static_write_channel_cycle_id = id;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_write_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, last, data_user, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  strb,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi_write_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi_write_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, last, data_user, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data = temp_static_write_channel_cycle_data;
                strb = temp_static_write_channel_cycle_strb;
                id = temp_static_write_channel_cycle_id;
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_put_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_put_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] resp_user,
        input int _unit_id = 0
    );
        begin
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_resp_channel_cycle_id = id;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi_write_resp_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, tmp_resp, resp_user, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] resp_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi_write_resp_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi_write_resp_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_resp, resp_user, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                id = temp_static_write_resp_channel_cycle_id;
            end // Block to create unsized data arrays
            resp = axi_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_resp_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi_write_resp_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    //-------------------------------------------------------------------------------------
    // Task which blocks and outputs an error if the interface has not initialized properly
    //-------------------------------------------------------------------------------------

    task _initialized();
        if (_interface_ref == 0)
        begin
            $display("Error: %m - Questa Verification IP failed to initialise. Please check questa_mvc.log for details");
            wait(_interface_ref!=0);
        end
    endtask

    //-------------------------------------------------------------------------------------
    // Function to get interface handle (internal use only)
    //-------------------------------------------------------------------------------------

    function longint _get_interface_handle();
        _get_interface_handle = axi_get_interface_handle();
    endfunction

//------------------------------------------------------------------------------
//
// Class which implements interface defined by axi_interface_class
//
//------------------------------------------------------------------------------
class axi_implementation_class #(int AXI_ADDRESS_WIDTH = 64, int AXI_RDATA_WIDTH = 1024, int AXI_WDATA_WIDTH = 1024, int AXI_ID_WIDTH = 18)
    extends axi_interface_class #(AXI_ADDRESS_WIDTH, AXI_RDATA_WIDTH, AXI_WDATA_WIDTH, AXI_ID_WIDTH);

    //------------------------------------------------------------------------------
    // Tasks to wait for a number of specified edges on a wire
    //------------------------------------------------------------------------------
    task automatic wait_for_ACLK( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ACLK( which_edge, count );
    endtask

    task automatic wait_for_ARESETn( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARESETn( which_edge, count );
    endtask

    task automatic wait_for_AWVALID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWVALID( which_edge, count );
    endtask

    task automatic wait_for_AWADDR( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWADDR( which_edge, count );
    endtask

    task automatic wait_for_AWADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWADDR_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWLEN( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWLEN( which_edge, count );
    endtask

    task automatic wait_for_AWLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWLEN_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWSIZE( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWSIZE( which_edge, count );
    endtask

    task automatic wait_for_AWSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWSIZE_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWBURST( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWBURST( which_edge, count );
    endtask

    task automatic wait_for_AWBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWBURST_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWLOCK( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWLOCK( which_edge, count );
    endtask

    task automatic wait_for_AWLOCK_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWLOCK_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWCACHE( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWCACHE( which_edge, count );
    endtask

    task automatic wait_for_AWCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWCACHE_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWPROT( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWPROT( which_edge, count );
    endtask

    task automatic wait_for_AWPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWPROT_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWID( which_edge, count );
    endtask

    task automatic wait_for_AWID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWID_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWREADY( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWREADY( which_edge, count );
    endtask

    task automatic wait_for_AWUSER( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWUSER( which_edge, count );
    endtask

    task automatic wait_for_AWUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWUSER_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARVALID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARVALID( which_edge, count );
    endtask

    task automatic wait_for_ARADDR( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARADDR( which_edge, count );
    endtask

    task automatic wait_for_ARADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARADDR_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARLEN( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARLEN( which_edge, count );
    endtask

    task automatic wait_for_ARLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARLEN_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARSIZE( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARSIZE( which_edge, count );
    endtask

    task automatic wait_for_ARSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARSIZE_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARBURST( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARBURST( which_edge, count );
    endtask

    task automatic wait_for_ARBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARBURST_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARLOCK( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARLOCK( which_edge, count );
    endtask

    task automatic wait_for_ARLOCK_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARLOCK_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARCACHE( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARCACHE( which_edge, count );
    endtask

    task automatic wait_for_ARCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARCACHE_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARPROT( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARPROT( which_edge, count );
    endtask

    task automatic wait_for_ARPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARPROT_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARID( which_edge, count );
    endtask

    task automatic wait_for_ARID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARID_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARREADY( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARREADY( which_edge, count );
    endtask

    task automatic wait_for_ARUSER( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARUSER( which_edge, count );
    endtask

    task automatic wait_for_ARUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARUSER_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_RVALID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RVALID( which_edge, count );
    endtask

    task automatic wait_for_RLAST( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RLAST( which_edge, count );
    endtask

    task automatic wait_for_RDATA( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RDATA( which_edge, count );
    endtask

    task automatic wait_for_RDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RDATA_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_RRESP( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RRESP( which_edge, count );
    endtask

    task automatic wait_for_RRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RRESP_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_RID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RID( which_edge, count );
    endtask

    task automatic wait_for_RID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RID_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_RREADY( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RREADY( which_edge, count );
    endtask

    task automatic wait_for_RUSER( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RUSER( which_edge, count );
    endtask

    task automatic wait_for_RUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RUSER_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_WVALID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WVALID( which_edge, count );
    endtask

    task automatic wait_for_WLAST( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WLAST( which_edge, count );
    endtask

    task automatic wait_for_WDATA( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WDATA( which_edge, count );
    endtask

    task automatic wait_for_WDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WDATA_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_WSTRB( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WSTRB( which_edge, count );
    endtask

    task automatic wait_for_WSTRB_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WSTRB_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_WID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WID( which_edge, count );
    endtask

    task automatic wait_for_WID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WID_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_WREADY( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WREADY( which_edge, count );
    endtask

    task automatic wait_for_WUSER( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WUSER( which_edge, count );
    endtask

    task automatic wait_for_WUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WUSER_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_BVALID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BVALID( which_edge, count );
    endtask

    task automatic wait_for_BRESP( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BRESP( which_edge, count );
    endtask

    task automatic wait_for_BRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BRESP_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_BID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BID( which_edge, count );
    endtask

    task automatic wait_for_BID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BID_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_BREADY( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BREADY( which_edge, count );
    endtask

    task automatic wait_for_BUSER( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BUSER( which_edge, count );
    endtask

    task automatic wait_for_BUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BUSER_index1( _this_dot_1, which_edge, count );
    endtask


    //------------------------------------------------------------------------------
    // Tasks/functions to set/get wires
    //------------------------------------------------------------------------------
    task automatic set_ACLK( logic ACLK_param = 'z, bit non_blocking = 1'b0 );
        do_set_ACLK( ACLK_param, non_blocking );
    endtask

    function automatic logic get_ACLK(  );
        return do_get_ACLK(  );
    endfunction


    task automatic set_ARESETn( logic ARESETn_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARESETn( ARESETn_param, non_blocking );
    endtask

    function automatic logic get_ARESETn(  );
        return do_get_ARESETn(  );
    endfunction


    task automatic set_AWVALID( logic AWVALID_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWVALID( AWVALID_param, non_blocking );
    endtask

    function automatic logic get_AWVALID(  );
        return do_get_AWVALID(  );
    endfunction


    task automatic set_AWADDR( logic [((AXI_ADDRESS_WIDTH) - 1):0]  AWADDR_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWADDR( AWADDR_param, non_blocking );
    endtask

    task automatic set_AWADDR_index1( int _this_dot_1, logic  AWADDR_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWADDR_index1( _this_dot_1, AWADDR_param, non_blocking );
    endtask

    function automatic logic [((AXI_ADDRESS_WIDTH) - 1):0]   get_AWADDR(  );
        return do_get_AWADDR(  );
    endfunction

    function automatic logic   get_AWADDR_index1( int _this_dot_1 );
        return do_get_AWADDR_index1( _this_dot_1 );
    endfunction


    task automatic set_AWLEN( logic [3:0] AWLEN_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWLEN( AWLEN_param, non_blocking );
    endtask

    task automatic set_AWLEN_index1( int _this_dot_1, logic  AWLEN_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWLEN_index1( _this_dot_1, AWLEN_param, non_blocking );
    endtask

    function automatic logic [3:0]  get_AWLEN(  );
        return do_get_AWLEN(  );
    endfunction

    function automatic logic   get_AWLEN_index1( int _this_dot_1 );
        return do_get_AWLEN_index1( _this_dot_1 );
    endfunction


    task automatic set_AWSIZE( logic [2:0] AWSIZE_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWSIZE( AWSIZE_param, non_blocking );
    endtask

    task automatic set_AWSIZE_index1( int _this_dot_1, logic  AWSIZE_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWSIZE_index1( _this_dot_1, AWSIZE_param, non_blocking );
    endtask

    function automatic logic [2:0]  get_AWSIZE(  );
        return do_get_AWSIZE(  );
    endfunction

    function automatic logic   get_AWSIZE_index1( int _this_dot_1 );
        return do_get_AWSIZE_index1( _this_dot_1 );
    endfunction


    task automatic set_AWBURST( logic [1:0] AWBURST_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWBURST( AWBURST_param, non_blocking );
    endtask

    task automatic set_AWBURST_index1( int _this_dot_1, logic  AWBURST_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWBURST_index1( _this_dot_1, AWBURST_param, non_blocking );
    endtask

    function automatic logic [1:0]  get_AWBURST(  );
        return do_get_AWBURST(  );
    endfunction

    function automatic logic   get_AWBURST_index1( int _this_dot_1 );
        return do_get_AWBURST_index1( _this_dot_1 );
    endfunction


    task automatic set_AWLOCK( logic [1:0] AWLOCK_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWLOCK( AWLOCK_param, non_blocking );
    endtask

    task automatic set_AWLOCK_index1( int _this_dot_1, logic  AWLOCK_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWLOCK_index1( _this_dot_1, AWLOCK_param, non_blocking );
    endtask

    function automatic logic [1:0]  get_AWLOCK(  );
        return do_get_AWLOCK(  );
    endfunction

    function automatic logic   get_AWLOCK_index1( int _this_dot_1 );
        return do_get_AWLOCK_index1( _this_dot_1 );
    endfunction


    task automatic set_AWCACHE( logic [3:0] AWCACHE_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWCACHE( AWCACHE_param, non_blocking );
    endtask

    task automatic set_AWCACHE_index1( int _this_dot_1, logic  AWCACHE_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWCACHE_index1( _this_dot_1, AWCACHE_param, non_blocking );
    endtask

    function automatic logic [3:0]  get_AWCACHE(  );
        return do_get_AWCACHE(  );
    endfunction

    function automatic logic   get_AWCACHE_index1( int _this_dot_1 );
        return do_get_AWCACHE_index1( _this_dot_1 );
    endfunction


    task automatic set_AWPROT( logic [2:0] AWPROT_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWPROT( AWPROT_param, non_blocking );
    endtask

    task automatic set_AWPROT_index1( int _this_dot_1, logic  AWPROT_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWPROT_index1( _this_dot_1, AWPROT_param, non_blocking );
    endtask

    function automatic logic [2:0]  get_AWPROT(  );
        return do_get_AWPROT(  );
    endfunction

    function automatic logic   get_AWPROT_index1( int _this_dot_1 );
        return do_get_AWPROT_index1( _this_dot_1 );
    endfunction


    task automatic set_AWID( logic [((AXI_ID_WIDTH) - 1):0]  AWID_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWID( AWID_param, non_blocking );
    endtask

    task automatic set_AWID_index1( int _this_dot_1, logic  AWID_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWID_index1( _this_dot_1, AWID_param, non_blocking );
    endtask

    function automatic logic [((AXI_ID_WIDTH) - 1):0]   get_AWID(  );
        return do_get_AWID(  );
    endfunction

    function automatic logic   get_AWID_index1( int _this_dot_1 );
        return do_get_AWID_index1( _this_dot_1 );
    endfunction


    task automatic set_AWREADY( logic AWREADY_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWREADY( AWREADY_param, non_blocking );
    endtask

    function automatic logic get_AWREADY(  );
        return do_get_AWREADY(  );
    endfunction


    task automatic set_AWUSER( logic [7:0] AWUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWUSER( AWUSER_param, non_blocking );
    endtask

    task automatic set_AWUSER_index1( int _this_dot_1, logic  AWUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWUSER_index1( _this_dot_1, AWUSER_param, non_blocking );
    endtask

    function automatic logic [7:0]  get_AWUSER(  );
        return do_get_AWUSER(  );
    endfunction

    function automatic logic   get_AWUSER_index1( int _this_dot_1 );
        return do_get_AWUSER_index1( _this_dot_1 );
    endfunction


    task automatic set_ARVALID( logic ARVALID_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARVALID( ARVALID_param, non_blocking );
    endtask

    function automatic logic get_ARVALID(  );
        return do_get_ARVALID(  );
    endfunction


    task automatic set_ARADDR( logic [((AXI_ADDRESS_WIDTH) - 1):0]  ARADDR_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARADDR( ARADDR_param, non_blocking );
    endtask

    task automatic set_ARADDR_index1( int _this_dot_1, logic  ARADDR_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARADDR_index1( _this_dot_1, ARADDR_param, non_blocking );
    endtask

    function automatic logic [((AXI_ADDRESS_WIDTH) - 1):0]   get_ARADDR(  );
        return do_get_ARADDR(  );
    endfunction

    function automatic logic   get_ARADDR_index1( int _this_dot_1 );
        return do_get_ARADDR_index1( _this_dot_1 );
    endfunction


    task automatic set_ARLEN( logic [3:0] ARLEN_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARLEN( ARLEN_param, non_blocking );
    endtask

    task automatic set_ARLEN_index1( int _this_dot_1, logic  ARLEN_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARLEN_index1( _this_dot_1, ARLEN_param, non_blocking );
    endtask

    function automatic logic [3:0]  get_ARLEN(  );
        return do_get_ARLEN(  );
    endfunction

    function automatic logic   get_ARLEN_index1( int _this_dot_1 );
        return do_get_ARLEN_index1( _this_dot_1 );
    endfunction


    task automatic set_ARSIZE( logic [2:0] ARSIZE_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARSIZE( ARSIZE_param, non_blocking );
    endtask

    task automatic set_ARSIZE_index1( int _this_dot_1, logic  ARSIZE_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARSIZE_index1( _this_dot_1, ARSIZE_param, non_blocking );
    endtask

    function automatic logic [2:0]  get_ARSIZE(  );
        return do_get_ARSIZE(  );
    endfunction

    function automatic logic   get_ARSIZE_index1( int _this_dot_1 );
        return do_get_ARSIZE_index1( _this_dot_1 );
    endfunction


    task automatic set_ARBURST( logic [1:0] ARBURST_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARBURST( ARBURST_param, non_blocking );
    endtask

    task automatic set_ARBURST_index1( int _this_dot_1, logic  ARBURST_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARBURST_index1( _this_dot_1, ARBURST_param, non_blocking );
    endtask

    function automatic logic [1:0]  get_ARBURST(  );
        return do_get_ARBURST(  );
    endfunction

    function automatic logic   get_ARBURST_index1( int _this_dot_1 );
        return do_get_ARBURST_index1( _this_dot_1 );
    endfunction


    task automatic set_ARLOCK( logic [1:0] ARLOCK_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARLOCK( ARLOCK_param, non_blocking );
    endtask

    task automatic set_ARLOCK_index1( int _this_dot_1, logic  ARLOCK_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARLOCK_index1( _this_dot_1, ARLOCK_param, non_blocking );
    endtask

    function automatic logic [1:0]  get_ARLOCK(  );
        return do_get_ARLOCK(  );
    endfunction

    function automatic logic   get_ARLOCK_index1( int _this_dot_1 );
        return do_get_ARLOCK_index1( _this_dot_1 );
    endfunction


    task automatic set_ARCACHE( logic [3:0] ARCACHE_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARCACHE( ARCACHE_param, non_blocking );
    endtask

    task automatic set_ARCACHE_index1( int _this_dot_1, logic  ARCACHE_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARCACHE_index1( _this_dot_1, ARCACHE_param, non_blocking );
    endtask

    function automatic logic [3:0]  get_ARCACHE(  );
        return do_get_ARCACHE(  );
    endfunction

    function automatic logic   get_ARCACHE_index1( int _this_dot_1 );
        return do_get_ARCACHE_index1( _this_dot_1 );
    endfunction


    task automatic set_ARPROT( logic [2:0] ARPROT_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARPROT( ARPROT_param, non_blocking );
    endtask

    task automatic set_ARPROT_index1( int _this_dot_1, logic  ARPROT_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARPROT_index1( _this_dot_1, ARPROT_param, non_blocking );
    endtask

    function automatic logic [2:0]  get_ARPROT(  );
        return do_get_ARPROT(  );
    endfunction

    function automatic logic   get_ARPROT_index1( int _this_dot_1 );
        return do_get_ARPROT_index1( _this_dot_1 );
    endfunction


    task automatic set_ARID( logic [((AXI_ID_WIDTH) - 1):0]  ARID_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARID( ARID_param, non_blocking );
    endtask

    task automatic set_ARID_index1( int _this_dot_1, logic  ARID_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARID_index1( _this_dot_1, ARID_param, non_blocking );
    endtask

    function automatic logic [((AXI_ID_WIDTH) - 1):0]   get_ARID(  );
        return do_get_ARID(  );
    endfunction

    function automatic logic   get_ARID_index1( int _this_dot_1 );
        return do_get_ARID_index1( _this_dot_1 );
    endfunction


    task automatic set_ARREADY( logic ARREADY_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARREADY( ARREADY_param, non_blocking );
    endtask

    function automatic logic get_ARREADY(  );
        return do_get_ARREADY(  );
    endfunction


    task automatic set_ARUSER( logic [7:0] ARUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARUSER( ARUSER_param, non_blocking );
    endtask

    task automatic set_ARUSER_index1( int _this_dot_1, logic  ARUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARUSER_index1( _this_dot_1, ARUSER_param, non_blocking );
    endtask

    function automatic logic [7:0]  get_ARUSER(  );
        return do_get_ARUSER(  );
    endfunction

    function automatic logic   get_ARUSER_index1( int _this_dot_1 );
        return do_get_ARUSER_index1( _this_dot_1 );
    endfunction


    task automatic set_RVALID( logic RVALID_param = 'z, bit non_blocking = 1'b0 );
        do_set_RVALID( RVALID_param, non_blocking );
    endtask

    function automatic logic get_RVALID(  );
        return do_get_RVALID(  );
    endfunction


    task automatic set_RLAST( logic RLAST_param = 'z, bit non_blocking = 1'b0 );
        do_set_RLAST( RLAST_param, non_blocking );
    endtask

    function automatic logic get_RLAST(  );
        return do_get_RLAST(  );
    endfunction


    task automatic set_RDATA( logic [((AXI_RDATA_WIDTH) - 1):0]  RDATA_param = 'z, bit non_blocking = 1'b0 );
        do_set_RDATA( RDATA_param, non_blocking );
    endtask

    task automatic set_RDATA_index1( int _this_dot_1, logic  RDATA_param = 'z, bit non_blocking = 1'b0 );
        do_set_RDATA_index1( _this_dot_1, RDATA_param, non_blocking );
    endtask

    function automatic logic [((AXI_RDATA_WIDTH) - 1):0]   get_RDATA(  );
        return do_get_RDATA(  );
    endfunction

    function automatic logic   get_RDATA_index1( int _this_dot_1 );
        return do_get_RDATA_index1( _this_dot_1 );
    endfunction


    task automatic set_RRESP( logic [1:0] RRESP_param = 'z, bit non_blocking = 1'b0 );
        do_set_RRESP( RRESP_param, non_blocking );
    endtask

    task automatic set_RRESP_index1( int _this_dot_1, logic  RRESP_param = 'z, bit non_blocking = 1'b0 );
        do_set_RRESP_index1( _this_dot_1, RRESP_param, non_blocking );
    endtask

    function automatic logic [1:0]  get_RRESP(  );
        return do_get_RRESP(  );
    endfunction

    function automatic logic   get_RRESP_index1( int _this_dot_1 );
        return do_get_RRESP_index1( _this_dot_1 );
    endfunction


    task automatic set_RID( logic [((AXI_ID_WIDTH) - 1):0]  RID_param = 'z, bit non_blocking = 1'b0 );
        do_set_RID( RID_param, non_blocking );
    endtask

    task automatic set_RID_index1( int _this_dot_1, logic  RID_param = 'z, bit non_blocking = 1'b0 );
        do_set_RID_index1( _this_dot_1, RID_param, non_blocking );
    endtask

    function automatic logic [((AXI_ID_WIDTH) - 1):0]   get_RID(  );
        return do_get_RID(  );
    endfunction

    function automatic logic   get_RID_index1( int _this_dot_1 );
        return do_get_RID_index1( _this_dot_1 );
    endfunction


    task automatic set_RREADY( logic RREADY_param = 'z, bit non_blocking = 1'b0 );
        do_set_RREADY( RREADY_param, non_blocking );
    endtask

    function automatic logic get_RREADY(  );
        return do_get_RREADY(  );
    endfunction


    task automatic set_RUSER( logic [7:0] RUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_RUSER( RUSER_param, non_blocking );
    endtask

    task automatic set_RUSER_index1( int _this_dot_1, logic  RUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_RUSER_index1( _this_dot_1, RUSER_param, non_blocking );
    endtask

    function automatic logic [7:0]  get_RUSER(  );
        return do_get_RUSER(  );
    endfunction

    function automatic logic   get_RUSER_index1( int _this_dot_1 );
        return do_get_RUSER_index1( _this_dot_1 );
    endfunction


    task automatic set_WVALID( logic WVALID_param = 'z, bit non_blocking = 1'b0 );
        do_set_WVALID( WVALID_param, non_blocking );
    endtask

    function automatic logic get_WVALID(  );
        return do_get_WVALID(  );
    endfunction


    task automatic set_WLAST( logic WLAST_param = 'z, bit non_blocking = 1'b0 );
        do_set_WLAST( WLAST_param, non_blocking );
    endtask

    function automatic logic get_WLAST(  );
        return do_get_WLAST(  );
    endfunction


    task automatic set_WDATA( logic [((AXI_WDATA_WIDTH) - 1):0]  WDATA_param = 'z, bit non_blocking = 1'b0 );
        do_set_WDATA( WDATA_param, non_blocking );
    endtask

    task automatic set_WDATA_index1( int _this_dot_1, logic  WDATA_param = 'z, bit non_blocking = 1'b0 );
        do_set_WDATA_index1( _this_dot_1, WDATA_param, non_blocking );
    endtask

    function automatic logic [((AXI_WDATA_WIDTH) - 1):0]   get_WDATA(  );
        return do_get_WDATA(  );
    endfunction

    function automatic logic   get_WDATA_index1( int _this_dot_1 );
        return do_get_WDATA_index1( _this_dot_1 );
    endfunction


    task automatic set_WSTRB( logic [(((AXI_WDATA_WIDTH / 8)) - 1):0]  WSTRB_param = 'z, bit non_blocking = 1'b0 );
        do_set_WSTRB( WSTRB_param, non_blocking );
    endtask

    task automatic set_WSTRB_index1( int _this_dot_1, logic  WSTRB_param = 'z, bit non_blocking = 1'b0 );
        do_set_WSTRB_index1( _this_dot_1, WSTRB_param, non_blocking );
    endtask

    function automatic logic [(((AXI_WDATA_WIDTH / 8)) - 1):0]   get_WSTRB(  );
        return do_get_WSTRB(  );
    endfunction

    function automatic logic   get_WSTRB_index1( int _this_dot_1 );
        return do_get_WSTRB_index1( _this_dot_1 );
    endfunction


    task automatic set_WID( logic [((AXI_ID_WIDTH) - 1):0]  WID_param = 'z, bit non_blocking = 1'b0 );
        do_set_WID( WID_param, non_blocking );
    endtask

    task automatic set_WID_index1( int _this_dot_1, logic  WID_param = 'z, bit non_blocking = 1'b0 );
        do_set_WID_index1( _this_dot_1, WID_param, non_blocking );
    endtask

    function automatic logic [((AXI_ID_WIDTH) - 1):0]   get_WID(  );
        return do_get_WID(  );
    endfunction

    function automatic logic   get_WID_index1( int _this_dot_1 );
        return do_get_WID_index1( _this_dot_1 );
    endfunction


    task automatic set_WREADY( logic WREADY_param = 'z, bit non_blocking = 1'b0 );
        do_set_WREADY( WREADY_param, non_blocking );
    endtask

    function automatic logic get_WREADY(  );
        return do_get_WREADY(  );
    endfunction


    task automatic set_WUSER( logic [7:0] WUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_WUSER( WUSER_param, non_blocking );
    endtask

    task automatic set_WUSER_index1( int _this_dot_1, logic  WUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_WUSER_index1( _this_dot_1, WUSER_param, non_blocking );
    endtask

    function automatic logic [7:0]  get_WUSER(  );
        return do_get_WUSER(  );
    endfunction

    function automatic logic   get_WUSER_index1( int _this_dot_1 );
        return do_get_WUSER_index1( _this_dot_1 );
    endfunction


    task automatic set_BVALID( logic BVALID_param = 'z, bit non_blocking = 1'b0 );
        do_set_BVALID( BVALID_param, non_blocking );
    endtask

    function automatic logic get_BVALID(  );
        return do_get_BVALID(  );
    endfunction


    task automatic set_BRESP( logic [1:0] BRESP_param = 'z, bit non_blocking = 1'b0 );
        do_set_BRESP( BRESP_param, non_blocking );
    endtask

    task automatic set_BRESP_index1( int _this_dot_1, logic  BRESP_param = 'z, bit non_blocking = 1'b0 );
        do_set_BRESP_index1( _this_dot_1, BRESP_param, non_blocking );
    endtask

    function automatic logic [1:0]  get_BRESP(  );
        return do_get_BRESP(  );
    endfunction

    function automatic logic   get_BRESP_index1( int _this_dot_1 );
        return do_get_BRESP_index1( _this_dot_1 );
    endfunction


    task automatic set_BID( logic [((AXI_ID_WIDTH) - 1):0]  BID_param = 'z, bit non_blocking = 1'b0 );
        do_set_BID( BID_param, non_blocking );
    endtask

    task automatic set_BID_index1( int _this_dot_1, logic  BID_param = 'z, bit non_blocking = 1'b0 );
        do_set_BID_index1( _this_dot_1, BID_param, non_blocking );
    endtask

    function automatic logic [((AXI_ID_WIDTH) - 1):0]   get_BID(  );
        return do_get_BID(  );
    endfunction

    function automatic logic   get_BID_index1( int _this_dot_1 );
        return do_get_BID_index1( _this_dot_1 );
    endfunction


    task automatic set_BREADY( logic BREADY_param = 'z, bit non_blocking = 1'b0 );
        do_set_BREADY( BREADY_param, non_blocking );
    endtask

    function automatic logic get_BREADY(  );
        return do_get_BREADY(  );
    endfunction


    task automatic set_BUSER( logic [7:0] BUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_BUSER( BUSER_param, non_blocking );
    endtask

    task automatic set_BUSER_index1( int _this_dot_1, logic  BUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_BUSER_index1( _this_dot_1, BUSER_param, non_blocking );
    endtask

    function automatic logic [7:0]  get_BUSER(  );
        return do_get_BUSER(  );
    endfunction

    function automatic logic   get_BUSER_index1( int _this_dot_1 );
        return do_get_BUSER_index1( _this_dot_1 );
    endfunction



    //------------------------------------------------------------------------------
    // Tasks to wait for a change to a global variable with read access
    //------------------------------------------------------------------------------
    task automatic wait_for_config_clk_init_value(  );
        do_wait_for_config_clk_init_value(  );
    endtask

    task automatic wait_for_config_clk_phase_shift(  );
        do_wait_for_config_clk_phase_shift(  );
    endtask

    task automatic wait_for_config_clk_1st_time(  );
        do_wait_for_config_clk_1st_time(  );
    endtask

    task automatic wait_for_config_clk_2nd_time(  );
        do_wait_for_config_clk_2nd_time(  );
    endtask

    task automatic wait_for_config_setup_time(  );
        do_wait_for_config_setup_time(  );
    endtask

    task automatic wait_for_config_hold_time(  );
        do_wait_for_config_hold_time(  );
    endtask

    task automatic wait_for_config_max_transaction_time_factor(  );
        do_wait_for_config_max_transaction_time_factor(  );
    endtask

    task automatic wait_for_config_timeout_max_data_transfer(  );
        do_wait_for_config_timeout_max_data_transfer(  );
    endtask

    task automatic wait_for_config_burst_timeout_factor(  );
        do_wait_for_config_burst_timeout_factor(  );
    endtask

    task automatic wait_for_config_max_latency_AWVALID_assertion_to_AWREADY(  );
        do_wait_for_config_max_latency_AWVALID_assertion_to_AWREADY(  );
    endtask

    task automatic wait_for_config_max_latency_ARVALID_assertion_to_ARREADY(  );
        do_wait_for_config_max_latency_ARVALID_assertion_to_ARREADY(  );
    endtask

    task automatic wait_for_config_max_latency_RVALID_assertion_to_RREADY(  );
        do_wait_for_config_max_latency_RVALID_assertion_to_RREADY(  );
    endtask

    task automatic wait_for_config_max_latency_BVALID_assertion_to_BREADY(  );
        do_wait_for_config_max_latency_BVALID_assertion_to_BREADY(  );
    endtask

    task automatic wait_for_config_max_latency_WVALID_assertion_to_WREADY(  );
        do_wait_for_config_max_latency_WVALID_assertion_to_WREADY(  );
    endtask

    task automatic wait_for_config_write_ctrl_first_ratio(  );
        do_wait_for_config_write_ctrl_first_ratio(  );
    endtask

    task automatic wait_for_config_write_data_first_ratio(  );
        do_wait_for_config_write_data_first_ratio(  );
    endtask

    task automatic wait_for_config_write_ctrl_to_data_mintime(  );
        do_wait_for_config_write_ctrl_to_data_mintime(  );
    endtask

    task automatic wait_for_config_write_data_to_ctrl_mintime(  );
        do_wait_for_config_write_data_to_ctrl_mintime(  );
    endtask

    task automatic wait_for_config_master_write_delay(  );
        do_wait_for_config_master_write_delay(  );
    endtask

    task automatic wait_for_config_reset_low_clocks(  );
        do_wait_for_config_reset_low_clocks(  );
    endtask

    task automatic wait_for_config_reset_hold_time(  );
        do_wait_for_config_reset_hold_time(  );
    endtask

    task automatic wait_for_config_protect_ready(  );
        do_wait_for_config_protect_ready(  );
    endtask

    task automatic wait_for_config_enable_user_sideband(  );
        do_wait_for_config_enable_user_sideband(  );
    endtask

    task automatic wait_for_config_extended_length_enable(  );
        do_wait_for_config_extended_length_enable(  );
    endtask

    task automatic wait_for_config_enable_burst_reserved_value(  );
        do_wait_for_config_enable_burst_reserved_value(  );
    endtask

    task automatic wait_for_config_enable_lock_reserved_value(  );
        do_wait_for_config_enable_lock_reserved_value(  );
    endtask

    task automatic wait_for_config_enable_cache_reserved_value(  );
        do_wait_for_config_enable_cache_reserved_value(  );
    endtask

    task automatic wait_for_config_enable_all_assertions(  );
        do_wait_for_config_enable_all_assertions(  );
    endtask

    task automatic wait_for_config_enable_assertion(  );
        do_wait_for_config_enable_assertion(  );
    endtask

    task automatic wait_for_config_enable_assertion_index1( input int _this_dot_1 );
        do_wait_for_config_enable_assertion_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_enable_error(  );
        do_wait_for_config_enable_error(  );
    endtask

    task automatic wait_for_config_enable_error_index1( input int _this_dot_1 );
        do_wait_for_config_enable_error_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_enable_errors(  );
        do_wait_for_config_enable_errors(  );
    endtask

    task automatic wait_for_config_enable_all_assertion_errors(  );
        do_wait_for_config_enable_all_assertion_errors(  );
    endtask

    task automatic wait_for_config_abstraction_level(  );
        do_wait_for_config_abstraction_level(  );
    endtask

    task automatic wait_for_config_slave_start_addr(  );
        do_wait_for_config_slave_start_addr(  );
    endtask

    task automatic wait_for_config_slave_start_addr_index1( input int _this_dot_1 );
        do_wait_for_config_slave_start_addr_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_slave_end_addr(  );
        do_wait_for_config_slave_end_addr(  );
    endtask

    task automatic wait_for_config_slave_end_addr_index1( input int _this_dot_1 );
        do_wait_for_config_slave_end_addr_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_enable_slave_addr_range_in_bfm(  );
        do_wait_for_config_enable_slave_addr_range_in_bfm(  );
    endtask

    task automatic wait_for_config_read_data_reordering_depth(  );
        do_wait_for_config_read_data_reordering_depth(  );
    endtask

    task automatic wait_for_config_enable_read_data_reordering_depth_in_bfm(  );
        do_wait_for_config_enable_read_data_reordering_depth_in_bfm(  );
    endtask

    task automatic wait_for_config_awid_wid_mismatch(  );
        do_wait_for_config_awid_wid_mismatch(  );
    endtask

    task automatic wait_for_config_length_last_mismatch_error(  );
        do_wait_for_config_length_last_mismatch_error(  );
    endtask

    task automatic wait_for_config_master_error_position(  );
        do_wait_for_config_master_error_position(  );
    endtask

    task automatic wait_for_dummy_var(  );
        do_wait_for_dummy_var(  );
    endtask

    task automatic wait_for_config_wlast_length(  );
        do_wait_for_config_wlast_length(  );
    endtask

    task automatic wait_for_config_wid_for_awid_not_matching(  );
        do_wait_for_config_wid_for_awid_not_matching(  );
    endtask

    task automatic wait_for_config_wid_for_awid_not_matching_index1( input int _this_dot_1 );
        do_wait_for_config_wid_for_awid_not_matching_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_support_exclusive_access(  );
        do_wait_for_config_support_exclusive_access(  );
    endtask

    task automatic wait_for_config_write_data_interleaving_depth(  );
        do_wait_for_config_write_data_interleaving_depth(  );
    endtask

    task automatic wait_for_status_master_error(  );
        do_wait_for_status_master_error(  );
    endtask

    task automatic wait_for_status_master_error_index1( input int _this_dot_1 );
        do_wait_for_status_master_error_index1( _this_dot_1 );
    endtask

    task automatic wait_for_status_num_reads_waiting_for_resp(  );
        do_wait_for_status_num_reads_waiting_for_resp(  );
    endtask

    task automatic wait_for_status_num_writes_waiting_for_response(  );
        do_wait_for_status_num_writes_waiting_for_response(  );
    endtask

    task automatic wait_for_check_total_num_wdata_outstanding(  );
        do_wait_for_check_total_num_wdata_outstanding(  );
    endtask

    task automatic wait_for_total_num_wdata_outstanding(  );
        do_wait_for_total_num_wdata_outstanding(  );
    endtask

    task automatic wait_for_check_max_num_wdata_outstanding_per_id(  );
        do_wait_for_check_max_num_wdata_outstanding_per_id(  );
    endtask

    task automatic wait_for_max_num_wdata_outstanding_per_id(  );
        do_wait_for_max_num_wdata_outstanding_per_id(  );
    endtask

    task automatic wait_for_check_max_num_waddr_outstanding_per_id(  );
        do_wait_for_check_max_num_waddr_outstanding_per_id(  );
    endtask

    task automatic wait_for_max_num_waddr_outstanding_per_id(  );
        do_wait_for_max_num_waddr_outstanding_per_id(  );
    endtask

    task automatic wait_for_check_total_num_waddr_outstanding(  );
        do_wait_for_check_total_num_waddr_outstanding(  );
    endtask

    task automatic wait_for_total_num_waddr_outstanding(  );
        do_wait_for_total_num_waddr_outstanding(  );
    endtask

    task automatic wait_for_status_outstanding_num_for_waddr(  );
        do_wait_for_status_outstanding_num_for_waddr(  );
    endtask

    task automatic wait_for_start_finding_outstanding_waddr(  );
        do_wait_for_start_finding_outstanding_waddr(  );
    endtask

    task automatic wait_for_status_outstanding_num_for_wdata(  );
        do_wait_for_status_outstanding_num_for_wdata(  );
    endtask

    task automatic wait_for_start_finding_outstanding_wdata(  );
        do_wait_for_start_finding_outstanding_wdata(  );
    endtask

    task automatic wait_for_find_waddr_outstanding_for_wid(  );
        do_wait_for_find_waddr_outstanding_for_wid(  );
    endtask

    task automatic wait_for_find_waddr_outstanding_for_wid_index1( input int _this_dot_1 );
        do_wait_for_find_waddr_outstanding_for_wid_index1( _this_dot_1 );
    endtask

    task automatic wait_for_find_wdata_outstanding_for_wid(  );
        do_wait_for_find_wdata_outstanding_for_wid(  );
    endtask

    task automatic wait_for_find_wdata_outstanding_for_wid_index1( input int _this_dot_1 );
        do_wait_for_find_wdata_outstanding_for_wid_index1( _this_dot_1 );
    endtask

    task automatic wait_for_change_in_wdata_outstanding_per_id(  );
        do_wait_for_change_in_wdata_outstanding_per_id(  );
    endtask

    task automatic wait_for_start_finding_change_in_wdata(  );
        do_wait_for_start_finding_change_in_wdata(  );
    endtask

    task automatic wait_for_find_change_in_wdata_outstanding_for_wid(  );
        do_wait_for_find_change_in_wdata_outstanding_for_wid(  );
    endtask

    task automatic wait_for_find_change_in_wdata_outstanding_for_wid_index1( input int _this_dot_1 );
        do_wait_for_find_change_in_wdata_outstanding_for_wid_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_max_outstanding_wr(  );
        do_wait_for_config_max_outstanding_wr(  );
    endtask

    task automatic wait_for_config_max_outstanding_rd(  );
        do_wait_for_config_max_outstanding_rd(  );
    endtask

    task automatic wait_for_config_error_on_deleted_valid_cycles(  );
        do_wait_for_config_error_on_deleted_valid_cycles(  );
    endtask

    task automatic wait_for_config_stats_enable(  );
        do_wait_for_config_stats_enable(  );
    endtask

    task automatic wait_for_config_stats_enable_AXI_read_occupancy(  );
        do_wait_for_config_stats_enable_AXI_read_occupancy(  );
    endtask

    task automatic wait_for_config_stats_enable_AXI_write_occupancy(  );
        do_wait_for_config_stats_enable_AXI_write_occupancy(  );
    endtask

    task automatic wait_for_config_stats_enable_read_data_occupancy(  );
        do_wait_for_config_stats_enable_read_data_occupancy(  );
    endtask

    task automatic wait_for_config_stats_enable_write_data_occupancy(  );
        do_wait_for_config_stats_enable_write_data_occupancy(  );
    endtask

    task automatic wait_for_config_stats_enable_read_latency(  );
        do_wait_for_config_stats_enable_read_latency(  );
    endtask

    task automatic wait_for_config_stats_enable_write_latency(  );
        do_wait_for_config_stats_enable_write_latency(  );
    endtask

    task automatic wait_for_config_stats_enable_read_address_waits(  );
        do_wait_for_config_stats_enable_read_address_waits(  );
    endtask

    task automatic wait_for_config_stats_enable_read_data_waits(  );
        do_wait_for_config_stats_enable_read_data_waits(  );
    endtask

    task automatic wait_for_config_stats_enable_write_address_waits(  );
        do_wait_for_config_stats_enable_write_address_waits(  );
    endtask

    task automatic wait_for_config_stats_enable_write_data_waits(  );
        do_wait_for_config_stats_enable_write_data_waits(  );
    endtask

    task automatic wait_for_config_stats_enable_write_response_waits(  );
        do_wait_for_config_stats_enable_write_response_waits(  );
    endtask

    task automatic wait_for_config_stats_enable_read_bandwidth(  );
        do_wait_for_config_stats_enable_read_bandwidth(  );
    endtask

    task automatic wait_for_config_stats_enable_write_bandwidth(  );
        do_wait_for_config_stats_enable_write_bandwidth(  );
    endtask

    task automatic wait_for_config_stats_AXI_read_occupancy_step(  );
        do_wait_for_config_stats_AXI_read_occupancy_step(  );
    endtask

    task automatic wait_for_config_stats_AXI_read_occupancy_multiple(  );
        do_wait_for_config_stats_AXI_read_occupancy_multiple(  );
    endtask

    task automatic wait_for_stats_AXI_read_active(  );
        do_wait_for_stats_AXI_read_active(  );
    endtask

    task automatic wait_for_stats_AXI_read_occupancy_sw(  );
        do_wait_for_stats_AXI_read_occupancy_sw(  );
    endtask

    task automatic wait_for_stats_AXI_read_occupancy_sw_updated(  );
        do_wait_for_stats_AXI_read_occupancy_sw_updated(  );
    endtask

    task automatic wait_for_stats_AXI_read_idle_sw(  );
        do_wait_for_stats_AXI_read_idle_sw(  );
    endtask

    task automatic wait_for_stats_AXI_read_occupancy_min(  );
        do_wait_for_stats_AXI_read_occupancy_min(  );
    endtask

    task automatic wait_for_stats_AXI_read_idle_min(  );
        do_wait_for_stats_AXI_read_idle_min(  );
    endtask

    task automatic wait_for_stats_AXI_read_occupancy_max(  );
        do_wait_for_stats_AXI_read_occupancy_max(  );
    endtask

    task automatic wait_for_stats_AXI_read_idle_max(  );
        do_wait_for_stats_AXI_read_idle_max(  );
    endtask

    task automatic wait_for_stats_AXI_read_occupancy_mean(  );
        do_wait_for_stats_AXI_read_occupancy_mean(  );
    endtask

    task automatic wait_for_stats_AXI_read_idle_mean(  );
        do_wait_for_stats_AXI_read_idle_mean(  );
    endtask

    task automatic wait_for_config_stats_AXI_write_occupancy_step(  );
        do_wait_for_config_stats_AXI_write_occupancy_step(  );
    endtask

    task automatic wait_for_config_stats_AXI_write_occupancy_multiple(  );
        do_wait_for_config_stats_AXI_write_occupancy_multiple(  );
    endtask

    task automatic wait_for_stats_AXI_write_active(  );
        do_wait_for_stats_AXI_write_active(  );
    endtask

    task automatic wait_for_stats_AXI_write_occupancy_sw(  );
        do_wait_for_stats_AXI_write_occupancy_sw(  );
    endtask

    task automatic wait_for_stats_AXI_write_occupancy_sw_updated(  );
        do_wait_for_stats_AXI_write_occupancy_sw_updated(  );
    endtask

    task automatic wait_for_stats_AXI_write_idle_sw(  );
        do_wait_for_stats_AXI_write_idle_sw(  );
    endtask

    task automatic wait_for_stats_AXI_write_occupancy_min(  );
        do_wait_for_stats_AXI_write_occupancy_min(  );
    endtask

    task automatic wait_for_stats_AXI_write_idle_min(  );
        do_wait_for_stats_AXI_write_idle_min(  );
    endtask

    task automatic wait_for_stats_AXI_write_occupancy_max(  );
        do_wait_for_stats_AXI_write_occupancy_max(  );
    endtask

    task automatic wait_for_stats_AXI_write_idle_max(  );
        do_wait_for_stats_AXI_write_idle_max(  );
    endtask

    task automatic wait_for_stats_AXI_write_occupancy_mean(  );
        do_wait_for_stats_AXI_write_occupancy_mean(  );
    endtask

    task automatic wait_for_stats_AXI_write_idle_mean(  );
        do_wait_for_stats_AXI_write_idle_mean(  );
    endtask

    task automatic wait_for_config_stats_read_data_occupancy_step(  );
        do_wait_for_config_stats_read_data_occupancy_step(  );
    endtask

    task automatic wait_for_config_stats_read_data_occupancy_multiple(  );
        do_wait_for_config_stats_read_data_occupancy_multiple(  );
    endtask

    task automatic wait_for_stats_read_data_occupancy_sw(  );
        do_wait_for_stats_read_data_occupancy_sw(  );
    endtask

    task automatic wait_for_stats_read_data_occupancy_sw_updated(  );
        do_wait_for_stats_read_data_occupancy_sw_updated(  );
    endtask

    task automatic wait_for_stats_read_data_idle_sw(  );
        do_wait_for_stats_read_data_idle_sw(  );
    endtask

    task automatic wait_for_stats_read_data_occupancy_min(  );
        do_wait_for_stats_read_data_occupancy_min(  );
    endtask

    task automatic wait_for_stats_read_data_idle_min(  );
        do_wait_for_stats_read_data_idle_min(  );
    endtask

    task automatic wait_for_stats_read_data_occupancy_max(  );
        do_wait_for_stats_read_data_occupancy_max(  );
    endtask

    task automatic wait_for_stats_read_data_idle_max(  );
        do_wait_for_stats_read_data_idle_max(  );
    endtask

    task automatic wait_for_stats_read_data_occupancy_mean(  );
        do_wait_for_stats_read_data_occupancy_mean(  );
    endtask

    task automatic wait_for_stats_read_data_idle_mean(  );
        do_wait_for_stats_read_data_idle_mean(  );
    endtask

    task automatic wait_for_config_stats_write_data_occupancy_step(  );
        do_wait_for_config_stats_write_data_occupancy_step(  );
    endtask

    task automatic wait_for_config_stats_write_data_occupancy_multiple(  );
        do_wait_for_config_stats_write_data_occupancy_multiple(  );
    endtask

    task automatic wait_for_stats_write_data_occupancy_sw(  );
        do_wait_for_stats_write_data_occupancy_sw(  );
    endtask

    task automatic wait_for_stats_write_data_occupancy_sw_updated(  );
        do_wait_for_stats_write_data_occupancy_sw_updated(  );
    endtask

    task automatic wait_for_stats_write_data_idle_sw(  );
        do_wait_for_stats_write_data_idle_sw(  );
    endtask

    task automatic wait_for_stats_write_data_occupancy_min(  );
        do_wait_for_stats_write_data_occupancy_min(  );
    endtask

    task automatic wait_for_stats_write_data_idle_min(  );
        do_wait_for_stats_write_data_idle_min(  );
    endtask

    task automatic wait_for_stats_write_data_occupancy_max(  );
        do_wait_for_stats_write_data_occupancy_max(  );
    endtask

    task automatic wait_for_stats_write_data_idle_max(  );
        do_wait_for_stats_write_data_idle_max(  );
    endtask

    task automatic wait_for_stats_write_data_occupancy_mean(  );
        do_wait_for_stats_write_data_occupancy_mean(  );
    endtask

    task automatic wait_for_stats_write_data_idle_mean(  );
        do_wait_for_stats_write_data_idle_mean(  );
    endtask

    task automatic wait_for_config_stats_read_bandwidth_step(  );
        do_wait_for_config_stats_read_bandwidth_step(  );
    endtask

    task automatic wait_for_config_stats_read_bandwidth_multiple(  );
        do_wait_for_config_stats_read_bandwidth_multiple(  );
    endtask

    task automatic wait_for_stats_read_bandwidth_sw(  );
        do_wait_for_stats_read_bandwidth_sw(  );
    endtask

    task automatic wait_for_stats_read_bandwidth_sw_updated(  );
        do_wait_for_stats_read_bandwidth_sw_updated(  );
    endtask

    task automatic wait_for_stats_read_bandwidth_min(  );
        do_wait_for_stats_read_bandwidth_min(  );
    endtask

    task automatic wait_for_stats_read_bandwidth_max(  );
        do_wait_for_stats_read_bandwidth_max(  );
    endtask

    task automatic wait_for_stats_read_bandwidth_mean(  );
        do_wait_for_stats_read_bandwidth_mean(  );
    endtask

    task automatic wait_for_config_stats_write_bandwidth_step(  );
        do_wait_for_config_stats_write_bandwidth_step(  );
    endtask

    task automatic wait_for_config_stats_write_bandwidth_multiple(  );
        do_wait_for_config_stats_write_bandwidth_multiple(  );
    endtask

    task automatic wait_for_stats_write_bandwidth_sw(  );
        do_wait_for_stats_write_bandwidth_sw(  );
    endtask

    task automatic wait_for_stats_write_bandwidth_sw_updated(  );
        do_wait_for_stats_write_bandwidth_sw_updated(  );
    endtask

    task automatic wait_for_stats_write_bandwidth_min(  );
        do_wait_for_stats_write_bandwidth_min(  );
    endtask

    task automatic wait_for_stats_write_bandwidth_max(  );
        do_wait_for_stats_write_bandwidth_max(  );
    endtask

    task automatic wait_for_stats_write_bandwidth_mean(  );
        do_wait_for_stats_write_bandwidth_mean(  );
    endtask

    task automatic wait_for_config_stats_read_latency_step(  );
        do_wait_for_config_stats_read_latency_step(  );
    endtask

    task automatic wait_for_config_stats_read_latency_multiple(  );
        do_wait_for_config_stats_read_latency_multiple(  );
    endtask

    task automatic wait_for_stats_read_latency_sw_updated(  );
        do_wait_for_stats_read_latency_sw_updated(  );
    endtask

    task automatic wait_for_stats_read_address_data_latency_inst(  );
        do_wait_for_stats_read_address_data_latency_inst(  );
    endtask

    task automatic wait_for_stats_read_address_data_latency_sw(  );
        do_wait_for_stats_read_address_data_latency_sw(  );
    endtask

    task automatic wait_for_stats_read_address_data_latency_min(  );
        do_wait_for_stats_read_address_data_latency_min(  );
    endtask

    task automatic wait_for_stats_read_address_data_latency_max(  );
        do_wait_for_stats_read_address_data_latency_max(  );
    endtask

    task automatic wait_for_stats_read_address_data_latency_mean(  );
        do_wait_for_stats_read_address_data_latency_mean(  );
    endtask

    task automatic wait_for_stats_read_address_address_latency_inst(  );
        do_wait_for_stats_read_address_address_latency_inst(  );
    endtask

    task automatic wait_for_stats_read_address_address_latency_sw(  );
        do_wait_for_stats_read_address_address_latency_sw(  );
    endtask

    task automatic wait_for_stats_read_address_address_latency_min(  );
        do_wait_for_stats_read_address_address_latency_min(  );
    endtask

    task automatic wait_for_stats_read_address_address_latency_max(  );
        do_wait_for_stats_read_address_address_latency_max(  );
    endtask

    task automatic wait_for_stats_read_address_address_latency_mean(  );
        do_wait_for_stats_read_address_address_latency_mean(  );
    endtask

    task automatic wait_for_config_stats_write_latency_step(  );
        do_wait_for_config_stats_write_latency_step(  );
    endtask

    task automatic wait_for_config_stats_write_latency_multiple(  );
        do_wait_for_config_stats_write_latency_multiple(  );
    endtask

    task automatic wait_for_stats_write_latency_sw_updated(  );
        do_wait_for_stats_write_latency_sw_updated(  );
    endtask

    task automatic wait_for_stats_write_address_data_latency_inst(  );
        do_wait_for_stats_write_address_data_latency_inst(  );
    endtask

    task automatic wait_for_stats_write_address_data_latency_sw(  );
        do_wait_for_stats_write_address_data_latency_sw(  );
    endtask

    task automatic wait_for_stats_write_address_data_latency_min(  );
        do_wait_for_stats_write_address_data_latency_min(  );
    endtask

    task automatic wait_for_stats_write_address_data_latency_max(  );
        do_wait_for_stats_write_address_data_latency_max(  );
    endtask

    task automatic wait_for_stats_write_address_data_latency_mean(  );
        do_wait_for_stats_write_address_data_latency_mean(  );
    endtask

    task automatic wait_for_stats_write_data_response_latency_inst(  );
        do_wait_for_stats_write_data_response_latency_inst(  );
    endtask

    task automatic wait_for_stats_write_data_response_latency_sw(  );
        do_wait_for_stats_write_data_response_latency_sw(  );
    endtask

    task automatic wait_for_stats_write_data_response_latency_min(  );
        do_wait_for_stats_write_data_response_latency_min(  );
    endtask

    task automatic wait_for_stats_write_data_response_latency_max(  );
        do_wait_for_stats_write_data_response_latency_max(  );
    endtask

    task automatic wait_for_stats_write_data_response_latency_mean(  );
        do_wait_for_stats_write_data_response_latency_mean(  );
    endtask

    task automatic wait_for_stats_write_address_address_latency_inst(  );
        do_wait_for_stats_write_address_address_latency_inst(  );
    endtask

    task automatic wait_for_stats_write_address_address_latency_sw(  );
        do_wait_for_stats_write_address_address_latency_sw(  );
    endtask

    task automatic wait_for_stats_write_address_address_latency_min(  );
        do_wait_for_stats_write_address_address_latency_min(  );
    endtask

    task automatic wait_for_stats_write_address_address_latency_max(  );
        do_wait_for_stats_write_address_address_latency_max(  );
    endtask

    task automatic wait_for_stats_write_address_address_latency_mean(  );
        do_wait_for_stats_write_address_address_latency_mean(  );
    endtask

    task automatic wait_for_config_stats_read_address_waits_step(  );
        do_wait_for_config_stats_read_address_waits_step(  );
    endtask

    task automatic wait_for_config_stats_read_address_waits_multiple(  );
        do_wait_for_config_stats_read_address_waits_multiple(  );
    endtask

    task automatic wait_for_stats_read_address_waits_inst(  );
        do_wait_for_stats_read_address_waits_inst(  );
    endtask

    task automatic wait_for_stats_read_address_waits_sw(  );
        do_wait_for_stats_read_address_waits_sw(  );
    endtask

    task automatic wait_for_stats_read_address_waits_sw_updated(  );
        do_wait_for_stats_read_address_waits_sw_updated(  );
    endtask

    task automatic wait_for_stats_read_address_waits_min(  );
        do_wait_for_stats_read_address_waits_min(  );
    endtask

    task automatic wait_for_stats_read_address_waits_max(  );
        do_wait_for_stats_read_address_waits_max(  );
    endtask

    task automatic wait_for_stats_read_address_waits_mean(  );
        do_wait_for_stats_read_address_waits_mean(  );
    endtask

    task automatic wait_for_config_stats_read_data_waits_step(  );
        do_wait_for_config_stats_read_data_waits_step(  );
    endtask

    task automatic wait_for_config_stats_read_data_waits_multiple(  );
        do_wait_for_config_stats_read_data_waits_multiple(  );
    endtask

    task automatic wait_for_stats_read_data_waits_inst(  );
        do_wait_for_stats_read_data_waits_inst(  );
    endtask

    task automatic wait_for_stats_read_data_waits_sw(  );
        do_wait_for_stats_read_data_waits_sw(  );
    endtask

    task automatic wait_for_stats_read_data_waits_sw_updated(  );
        do_wait_for_stats_read_data_waits_sw_updated(  );
    endtask

    task automatic wait_for_stats_read_data_waits_min(  );
        do_wait_for_stats_read_data_waits_min(  );
    endtask

    task automatic wait_for_stats_read_data_waits_max(  );
        do_wait_for_stats_read_data_waits_max(  );
    endtask

    task automatic wait_for_stats_read_data_waits_mean(  );
        do_wait_for_stats_read_data_waits_mean(  );
    endtask

    task automatic wait_for_config_stats_write_address_waits_step(  );
        do_wait_for_config_stats_write_address_waits_step(  );
    endtask

    task automatic wait_for_config_stats_write_address_waits_multiple(  );
        do_wait_for_config_stats_write_address_waits_multiple(  );
    endtask

    task automatic wait_for_stats_write_address_waits_inst(  );
        do_wait_for_stats_write_address_waits_inst(  );
    endtask

    task automatic wait_for_stats_write_address_waits_sw(  );
        do_wait_for_stats_write_address_waits_sw(  );
    endtask

    task automatic wait_for_stats_write_address_waits_sw_updated(  );
        do_wait_for_stats_write_address_waits_sw_updated(  );
    endtask

    task automatic wait_for_stats_write_address_waits_min(  );
        do_wait_for_stats_write_address_waits_min(  );
    endtask

    task automatic wait_for_stats_write_address_waits_max(  );
        do_wait_for_stats_write_address_waits_max(  );
    endtask

    task automatic wait_for_stats_write_address_waits_mean(  );
        do_wait_for_stats_write_address_waits_mean(  );
    endtask

    task automatic wait_for_config_stats_write_data_waits_step(  );
        do_wait_for_config_stats_write_data_waits_step(  );
    endtask

    task automatic wait_for_config_stats_write_data_waits_multiple(  );
        do_wait_for_config_stats_write_data_waits_multiple(  );
    endtask

    task automatic wait_for_stats_write_data_waits_inst(  );
        do_wait_for_stats_write_data_waits_inst(  );
    endtask

    task automatic wait_for_stats_write_data_waits_sw(  );
        do_wait_for_stats_write_data_waits_sw(  );
    endtask

    task automatic wait_for_stats_write_data_waits_sw_updated(  );
        do_wait_for_stats_write_data_waits_sw_updated(  );
    endtask

    task automatic wait_for_stats_write_data_waits_min(  );
        do_wait_for_stats_write_data_waits_min(  );
    endtask

    task automatic wait_for_stats_write_data_waits_max(  );
        do_wait_for_stats_write_data_waits_max(  );
    endtask

    task automatic wait_for_stats_write_data_waits_mean(  );
        do_wait_for_stats_write_data_waits_mean(  );
    endtask

    task automatic wait_for_config_stats_write_response_waits_step(  );
        do_wait_for_config_stats_write_response_waits_step(  );
    endtask

    task automatic wait_for_config_stats_write_response_waits_multiple(  );
        do_wait_for_config_stats_write_response_waits_multiple(  );
    endtask

    task automatic wait_for_stats_write_response_waits_inst(  );
        do_wait_for_stats_write_response_waits_inst(  );
    endtask

    task automatic wait_for_stats_write_response_waits_sw(  );
        do_wait_for_stats_write_response_waits_sw(  );
    endtask

    task automatic wait_for_stats_write_response_waits_sw_updated(  );
        do_wait_for_stats_write_response_waits_sw_updated(  );
    endtask

    task automatic wait_for_stats_write_response_waits_min(  );
        do_wait_for_stats_write_response_waits_min(  );
    endtask

    task automatic wait_for_stats_write_response_waits_max(  );
        do_wait_for_stats_write_response_waits_max(  );
    endtask

    task automatic wait_for_stats_write_response_waits_mean(  );
        do_wait_for_stats_write_response_waits_mean(  );
    endtask

    task automatic wait_for_stats_rw_transaction_last_duration(  );
        do_wait_for_stats_rw_transaction_last_duration(  );
    endtask

    task automatic wait_for_stats_AXI_read_last_duration(  );
        do_wait_for_stats_AXI_read_last_duration(  );
    endtask

    task automatic wait_for_stats_AXI_write_last_duration(  );
        do_wait_for_stats_AXI_write_last_duration(  );
    endtask

    task automatic wait_for_stats_read_addr_channel_phase_last_duration(  );
        do_wait_for_stats_read_addr_channel_phase_last_duration(  );
    endtask

    task automatic wait_for_stats_read_data_burst_last_duration(  );
        do_wait_for_stats_read_data_burst_last_duration(  );
    endtask

    task automatic wait_for_stats_read_channel_phase_last_duration(  );
        do_wait_for_stats_read_channel_phase_last_duration(  );
    endtask

    task automatic wait_for_stats_write_addr_channel_phase_last_duration(  );
        do_wait_for_stats_write_addr_channel_phase_last_duration(  );
    endtask

    task automatic wait_for_stats_write_data_burst_last_duration(  );
        do_wait_for_stats_write_data_burst_last_duration(  );
    endtask

    task automatic wait_for_stats_write_channel_phase_last_duration(  );
        do_wait_for_stats_write_channel_phase_last_duration(  );
    endtask

    task automatic wait_for_stats_write_resp_channel_phase_last_duration(  );
        do_wait_for_stats_write_resp_channel_phase_last_duration(  );
    endtask


    //------------------------------------------------------------------------------
    // Functions to set global variables with write access
    //------------------------------------------------------------------------------
    function automatic void set_config_clk_init_value( bit config_clk_init_value_param );
        do_set_config_clk_init_value( config_clk_init_value_param );
    endfunction

    function automatic void set_config_clk_phase_shift( int config_clk_phase_shift_param );
        do_set_config_clk_phase_shift( config_clk_phase_shift_param );
    endfunction

    function automatic void set_config_clk_1st_time( int config_clk_1st_time_param );
        do_set_config_clk_1st_time( config_clk_1st_time_param );
    endfunction

    function automatic void set_config_clk_2nd_time( int config_clk_2nd_time_param );
        do_set_config_clk_2nd_time( config_clk_2nd_time_param );
    endfunction

    function automatic void set_config_setup_time( int config_setup_time_param );
        do_set_config_setup_time( config_setup_time_param );
    endfunction

    function automatic void set_config_hold_time( int config_hold_time_param );
        do_set_config_hold_time( config_hold_time_param );
    endfunction

    function automatic void set_config_max_transaction_time_factor( int unsigned config_max_transaction_time_factor_param );
        do_set_config_max_transaction_time_factor( config_max_transaction_time_factor_param );
    endfunction

    function automatic void set_config_timeout_max_data_transfer( int config_timeout_max_data_transfer_param );
        do_set_config_timeout_max_data_transfer( config_timeout_max_data_transfer_param );
    endfunction

    function automatic void set_config_burst_timeout_factor( int unsigned config_burst_timeout_factor_param );
        do_set_config_burst_timeout_factor( config_burst_timeout_factor_param );
    endfunction

    function automatic void set_config_max_latency_AWVALID_assertion_to_AWREADY( int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
        do_set_config_max_latency_AWVALID_assertion_to_AWREADY( config_max_latency_AWVALID_assertion_to_AWREADY_param );
    endfunction

    function automatic void set_config_max_latency_ARVALID_assertion_to_ARREADY( int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
        do_set_config_max_latency_ARVALID_assertion_to_ARREADY( config_max_latency_ARVALID_assertion_to_ARREADY_param );
    endfunction

    function automatic void set_config_max_latency_RVALID_assertion_to_RREADY( int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
        do_set_config_max_latency_RVALID_assertion_to_RREADY( config_max_latency_RVALID_assertion_to_RREADY_param );
    endfunction

    function automatic void set_config_max_latency_BVALID_assertion_to_BREADY( int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
        do_set_config_max_latency_BVALID_assertion_to_BREADY( config_max_latency_BVALID_assertion_to_BREADY_param );
    endfunction

    function automatic void set_config_max_latency_WVALID_assertion_to_WREADY( int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
        do_set_config_max_latency_WVALID_assertion_to_WREADY( config_max_latency_WVALID_assertion_to_WREADY_param );
    endfunction

    function automatic void set_config_write_ctrl_first_ratio( int config_write_ctrl_first_ratio_param );
        do_set_config_write_ctrl_first_ratio( config_write_ctrl_first_ratio_param );
    endfunction

    function automatic void set_config_write_data_first_ratio( int config_write_data_first_ratio_param );
        do_set_config_write_data_first_ratio( config_write_data_first_ratio_param );
    endfunction

    function automatic void set_config_write_ctrl_to_data_mintime( int unsigned config_write_ctrl_to_data_mintime_param );
        do_set_config_write_ctrl_to_data_mintime( config_write_ctrl_to_data_mintime_param );
    endfunction

    function automatic void set_config_write_data_to_ctrl_mintime( int unsigned config_write_data_to_ctrl_mintime_param );
        do_set_config_write_data_to_ctrl_mintime( config_write_data_to_ctrl_mintime_param );
    endfunction

    function automatic void set_config_master_write_delay( bit config_master_write_delay_param );
        do_set_config_master_write_delay( config_master_write_delay_param );
    endfunction

    function automatic void set_config_reset_low_clocks( int config_reset_low_clocks_param );
        do_set_config_reset_low_clocks( config_reset_low_clocks_param );
    endfunction

    function automatic void set_config_reset_hold_time( int config_reset_hold_time_param );
        do_set_config_reset_hold_time( config_reset_hold_time_param );
    endfunction

    function automatic void set_config_protect_ready( bit config_protect_ready_param );
        do_set_config_protect_ready( config_protect_ready_param );
    endfunction

    function automatic void set_config_enable_user_sideband( bit config_enable_user_sideband_param );
        do_set_config_enable_user_sideband( config_enable_user_sideband_param );
    endfunction

    function automatic void set_config_extended_length_enable( bit config_extended_length_enable_param );
        do_set_config_extended_length_enable( config_extended_length_enable_param );
    endfunction

    function automatic void set_config_enable_burst_reserved_value( bit config_enable_burst_reserved_value_param );
        do_set_config_enable_burst_reserved_value( config_enable_burst_reserved_value_param );
    endfunction

    function automatic void set_config_enable_lock_reserved_value( bit config_enable_lock_reserved_value_param );
        do_set_config_enable_lock_reserved_value( config_enable_lock_reserved_value_param );
    endfunction

    function automatic void set_config_enable_cache_reserved_value( bit config_enable_cache_reserved_value_param );
        do_set_config_enable_cache_reserved_value( config_enable_cache_reserved_value_param );
    endfunction

    function automatic void set_config_enable_all_assertions( bit config_enable_all_assertions_param );
        do_set_config_enable_all_assertions( config_enable_all_assertions_param );
    endfunction

    function automatic void set_config_enable_assertion( bit [255:0] config_enable_assertion_param );
        do_set_config_enable_assertion( config_enable_assertion_param );
    endfunction

    function automatic void set_config_enable_assertion_index1( int _this_dot_1, bit  config_enable_assertion_param );
        do_set_config_enable_assertion_index1( _this_dot_1, config_enable_assertion_param );
    endfunction

    function automatic void set_config_enable_error( bit [255:0] config_enable_error_param );
        do_set_config_enable_error( config_enable_error_param );
    endfunction

    function automatic void set_config_enable_error_index1( int _this_dot_1, bit  config_enable_error_param );
        do_set_config_enable_error_index1( _this_dot_1, config_enable_error_param );
    endfunction

    function automatic void set_config_enable_errors( bit config_enable_errors_param );
        do_set_config_enable_errors( config_enable_errors_param );
    endfunction

    function automatic void set_config_enable_all_assertion_errors( bit config_enable_all_assertion_errors_param );
        do_set_config_enable_all_assertion_errors( config_enable_all_assertion_errors_param );
    endfunction

    function automatic void set_config_abstraction_level( axi_abstraction_level_e config_abstraction_level_param );
        do_set_config_abstraction_level( config_abstraction_level_param );
    endfunction

    function automatic void set_config_slave_start_addr( bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param );
        do_set_config_slave_start_addr( config_slave_start_addr_param );
    endfunction

    function automatic void set_config_slave_start_addr_index1( int _this_dot_1, bit  config_slave_start_addr_param );
        do_set_config_slave_start_addr_index1( _this_dot_1, config_slave_start_addr_param );
    endfunction

    function automatic void set_config_slave_end_addr( bit [((AXI_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param );
        do_set_config_slave_end_addr( config_slave_end_addr_param );
    endfunction

    function automatic void set_config_slave_end_addr_index1( int _this_dot_1, bit  config_slave_end_addr_param );
        do_set_config_slave_end_addr_index1( _this_dot_1, config_slave_end_addr_param );
    endfunction

    function automatic void set_config_enable_slave_addr_range_in_bfm( bit config_enable_slave_addr_range_in_bfm_param );
        do_set_config_enable_slave_addr_range_in_bfm( config_enable_slave_addr_range_in_bfm_param );
    endfunction

    function automatic void set_config_read_data_reordering_depth( int unsigned config_read_data_reordering_depth_param );
        do_set_config_read_data_reordering_depth( config_read_data_reordering_depth_param );
    endfunction

    function automatic void set_config_enable_read_data_reordering_depth_in_bfm( bit config_enable_read_data_reordering_depth_in_bfm_param );
        do_set_config_enable_read_data_reordering_depth_in_bfm( config_enable_read_data_reordering_depth_in_bfm_param );
    endfunction

    function automatic void set_config_awid_wid_mismatch( bit config_awid_wid_mismatch_param );
        do_set_config_awid_wid_mismatch( config_awid_wid_mismatch_param );
    endfunction

    function automatic void set_config_length_last_mismatch_error( bit config_length_last_mismatch_error_param );
        do_set_config_length_last_mismatch_error( config_length_last_mismatch_error_param );
    endfunction

    function automatic void set_config_master_error_position( axi_error_e config_master_error_position_param );
        do_set_config_master_error_position( config_master_error_position_param );
    endfunction

    function automatic void set_dummy_var( axi_assertion_type_e dummy_var_param );
        do_set_dummy_var( dummy_var_param );
    endfunction

    function automatic void set_config_wlast_length( int config_wlast_length_param );
        do_set_config_wlast_length( config_wlast_length_param );
    endfunction

    function automatic void set_config_wid_for_awid_not_matching( bit [((AXI_ID_WIDTH) - 1):0]  config_wid_for_awid_not_matching_param );
        do_set_config_wid_for_awid_not_matching( config_wid_for_awid_not_matching_param );
    endfunction

    function automatic void set_config_wid_for_awid_not_matching_index1( int _this_dot_1, bit  config_wid_for_awid_not_matching_param );
        do_set_config_wid_for_awid_not_matching_index1( _this_dot_1, config_wid_for_awid_not_matching_param );
    endfunction

    function automatic void set_config_support_exclusive_access( bit config_support_exclusive_access_param );
        do_set_config_support_exclusive_access( config_support_exclusive_access_param );
    endfunction

    function automatic void set_config_write_data_interleaving_depth( int config_write_data_interleaving_depth_param );
        do_set_config_write_data_interleaving_depth( config_write_data_interleaving_depth_param );
    endfunction

    function automatic void set_status_master_error( bit [15:0] status_master_error_param );
        do_set_status_master_error( status_master_error_param );
    endfunction

    function automatic void set_status_master_error_index1( int _this_dot_1, bit  status_master_error_param );
        do_set_status_master_error_index1( _this_dot_1, status_master_error_param );
    endfunction

    function automatic void set_check_total_num_wdata_outstanding( bit check_total_num_wdata_outstanding_param );
        do_set_check_total_num_wdata_outstanding( check_total_num_wdata_outstanding_param );
    endfunction

    function automatic void set_total_num_wdata_outstanding( int total_num_wdata_outstanding_param );
        do_set_total_num_wdata_outstanding( total_num_wdata_outstanding_param );
    endfunction

    function automatic void set_check_max_num_wdata_outstanding_per_id( bit check_max_num_wdata_outstanding_per_id_param );
        do_set_check_max_num_wdata_outstanding_per_id( check_max_num_wdata_outstanding_per_id_param );
    endfunction

    function automatic void set_max_num_wdata_outstanding_per_id( int max_num_wdata_outstanding_per_id_param );
        do_set_max_num_wdata_outstanding_per_id( max_num_wdata_outstanding_per_id_param );
    endfunction

    function automatic void set_check_max_num_waddr_outstanding_per_id( bit check_max_num_waddr_outstanding_per_id_param );
        do_set_check_max_num_waddr_outstanding_per_id( check_max_num_waddr_outstanding_per_id_param );
    endfunction

    function automatic void set_max_num_waddr_outstanding_per_id( int max_num_waddr_outstanding_per_id_param );
        do_set_max_num_waddr_outstanding_per_id( max_num_waddr_outstanding_per_id_param );
    endfunction

    function automatic void set_check_total_num_waddr_outstanding( bit check_total_num_waddr_outstanding_param );
        do_set_check_total_num_waddr_outstanding( check_total_num_waddr_outstanding_param );
    endfunction

    function automatic void set_total_num_waddr_outstanding( int total_num_waddr_outstanding_param );
        do_set_total_num_waddr_outstanding( total_num_waddr_outstanding_param );
    endfunction

    function automatic void set_status_outstanding_num_for_waddr( int status_outstanding_num_for_waddr_param );
        do_set_status_outstanding_num_for_waddr( status_outstanding_num_for_waddr_param );
    endfunction

    function automatic void set_start_finding_outstanding_waddr( bit start_finding_outstanding_waddr_param );
        do_set_start_finding_outstanding_waddr( start_finding_outstanding_waddr_param );
    endfunction

    function automatic void set_status_outstanding_num_for_wdata( int status_outstanding_num_for_wdata_param );
        do_set_status_outstanding_num_for_wdata( status_outstanding_num_for_wdata_param );
    endfunction

    function automatic void set_start_finding_outstanding_wdata( bit start_finding_outstanding_wdata_param );
        do_set_start_finding_outstanding_wdata( start_finding_outstanding_wdata_param );
    endfunction

    function automatic void set_find_waddr_outstanding_for_wid( bit [((AXI_ID_WIDTH) - 1):0]  find_waddr_outstanding_for_wid_param );
        do_set_find_waddr_outstanding_for_wid( find_waddr_outstanding_for_wid_param );
    endfunction

    function automatic void set_find_waddr_outstanding_for_wid_index1( int _this_dot_1, bit  find_waddr_outstanding_for_wid_param );
        do_set_find_waddr_outstanding_for_wid_index1( _this_dot_1, find_waddr_outstanding_for_wid_param );
    endfunction

    function automatic void set_find_wdata_outstanding_for_wid( bit [((AXI_ID_WIDTH) - 1):0]  find_wdata_outstanding_for_wid_param );
        do_set_find_wdata_outstanding_for_wid( find_wdata_outstanding_for_wid_param );
    endfunction

    function automatic void set_find_wdata_outstanding_for_wid_index1( int _this_dot_1, bit  find_wdata_outstanding_for_wid_param );
        do_set_find_wdata_outstanding_for_wid_index1( _this_dot_1, find_wdata_outstanding_for_wid_param );
    endfunction

    function automatic void set_change_in_wdata_outstanding_per_id( bit change_in_wdata_outstanding_per_id_param );
        do_set_change_in_wdata_outstanding_per_id( change_in_wdata_outstanding_per_id_param );
    endfunction

    function automatic void set_start_finding_change_in_wdata( bit start_finding_change_in_wdata_param );
        do_set_start_finding_change_in_wdata( start_finding_change_in_wdata_param );
    endfunction

    function automatic void set_find_change_in_wdata_outstanding_for_wid( bit [((AXI_ID_WIDTH) - 1):0]  find_change_in_wdata_outstanding_for_wid_param );
        do_set_find_change_in_wdata_outstanding_for_wid( find_change_in_wdata_outstanding_for_wid_param );
    endfunction

    function automatic void set_find_change_in_wdata_outstanding_for_wid_index1( int _this_dot_1, bit  find_change_in_wdata_outstanding_for_wid_param );
        do_set_find_change_in_wdata_outstanding_for_wid_index1( _this_dot_1, find_change_in_wdata_outstanding_for_wid_param );
    endfunction

    function automatic void set_config_max_outstanding_wr( int config_max_outstanding_wr_param );
        do_set_config_max_outstanding_wr( config_max_outstanding_wr_param );
    endfunction

    function automatic void set_config_max_outstanding_rd( int config_max_outstanding_rd_param );
        do_set_config_max_outstanding_rd( config_max_outstanding_rd_param );
    endfunction

    function automatic void set_config_error_on_deleted_valid_cycles( bit config_error_on_deleted_valid_cycles_param );
        do_set_config_error_on_deleted_valid_cycles( config_error_on_deleted_valid_cycles_param );
    endfunction

    function automatic void set_config_stats_enable( bit config_stats_enable_param );
        do_set_config_stats_enable( config_stats_enable_param );
    endfunction

    function automatic void set_config_stats_enable_AXI_read_occupancy( bit config_stats_enable_AXI_read_occupancy_param );
        do_set_config_stats_enable_AXI_read_occupancy( config_stats_enable_AXI_read_occupancy_param );
    endfunction

    function automatic void set_config_stats_enable_AXI_write_occupancy( bit config_stats_enable_AXI_write_occupancy_param );
        do_set_config_stats_enable_AXI_write_occupancy( config_stats_enable_AXI_write_occupancy_param );
    endfunction

    function automatic void set_config_stats_enable_read_data_occupancy( bit config_stats_enable_read_data_occupancy_param );
        do_set_config_stats_enable_read_data_occupancy( config_stats_enable_read_data_occupancy_param );
    endfunction

    function automatic void set_config_stats_enable_write_data_occupancy( bit config_stats_enable_write_data_occupancy_param );
        do_set_config_stats_enable_write_data_occupancy( config_stats_enable_write_data_occupancy_param );
    endfunction

    function automatic void set_config_stats_enable_read_latency( bit config_stats_enable_read_latency_param );
        do_set_config_stats_enable_read_latency( config_stats_enable_read_latency_param );
    endfunction

    function automatic void set_config_stats_enable_write_latency( bit config_stats_enable_write_latency_param );
        do_set_config_stats_enable_write_latency( config_stats_enable_write_latency_param );
    endfunction

    function automatic void set_config_stats_enable_read_address_waits( bit config_stats_enable_read_address_waits_param );
        do_set_config_stats_enable_read_address_waits( config_stats_enable_read_address_waits_param );
    endfunction

    function automatic void set_config_stats_enable_read_data_waits( bit config_stats_enable_read_data_waits_param );
        do_set_config_stats_enable_read_data_waits( config_stats_enable_read_data_waits_param );
    endfunction

    function automatic void set_config_stats_enable_write_address_waits( bit config_stats_enable_write_address_waits_param );
        do_set_config_stats_enable_write_address_waits( config_stats_enable_write_address_waits_param );
    endfunction

    function automatic void set_config_stats_enable_write_data_waits( bit config_stats_enable_write_data_waits_param );
        do_set_config_stats_enable_write_data_waits( config_stats_enable_write_data_waits_param );
    endfunction

    function automatic void set_config_stats_enable_write_response_waits( bit config_stats_enable_write_response_waits_param );
        do_set_config_stats_enable_write_response_waits( config_stats_enable_write_response_waits_param );
    endfunction

    function automatic void set_config_stats_enable_read_bandwidth( bit config_stats_enable_read_bandwidth_param );
        do_set_config_stats_enable_read_bandwidth( config_stats_enable_read_bandwidth_param );
    endfunction

    function automatic void set_config_stats_enable_write_bandwidth( bit config_stats_enable_write_bandwidth_param );
        do_set_config_stats_enable_write_bandwidth( config_stats_enable_write_bandwidth_param );
    endfunction

    function automatic void set_config_stats_AXI_read_occupancy_step( int config_stats_AXI_read_occupancy_step_param );
        do_set_config_stats_AXI_read_occupancy_step( config_stats_AXI_read_occupancy_step_param );
    endfunction

    function automatic void set_config_stats_AXI_read_occupancy_multiple( int config_stats_AXI_read_occupancy_multiple_param );
        do_set_config_stats_AXI_read_occupancy_multiple( config_stats_AXI_read_occupancy_multiple_param );
    endfunction

    function automatic void set_config_stats_AXI_write_occupancy_step( int config_stats_AXI_write_occupancy_step_param );
        do_set_config_stats_AXI_write_occupancy_step( config_stats_AXI_write_occupancy_step_param );
    endfunction

    function automatic void set_config_stats_AXI_write_occupancy_multiple( int config_stats_AXI_write_occupancy_multiple_param );
        do_set_config_stats_AXI_write_occupancy_multiple( config_stats_AXI_write_occupancy_multiple_param );
    endfunction

    function automatic void set_config_stats_read_data_occupancy_step( int config_stats_read_data_occupancy_step_param );
        do_set_config_stats_read_data_occupancy_step( config_stats_read_data_occupancy_step_param );
    endfunction

    function automatic void set_config_stats_read_data_occupancy_multiple( int config_stats_read_data_occupancy_multiple_param );
        do_set_config_stats_read_data_occupancy_multiple( config_stats_read_data_occupancy_multiple_param );
    endfunction

    function automatic void set_config_stats_write_data_occupancy_step( int config_stats_write_data_occupancy_step_param );
        do_set_config_stats_write_data_occupancy_step( config_stats_write_data_occupancy_step_param );
    endfunction

    function automatic void set_config_stats_write_data_occupancy_multiple( int config_stats_write_data_occupancy_multiple_param );
        do_set_config_stats_write_data_occupancy_multiple( config_stats_write_data_occupancy_multiple_param );
    endfunction

    function automatic void set_config_stats_read_bandwidth_step( int config_stats_read_bandwidth_step_param );
        do_set_config_stats_read_bandwidth_step( config_stats_read_bandwidth_step_param );
    endfunction

    function automatic void set_config_stats_read_bandwidth_multiple( int config_stats_read_bandwidth_multiple_param );
        do_set_config_stats_read_bandwidth_multiple( config_stats_read_bandwidth_multiple_param );
    endfunction

    function automatic void set_config_stats_write_bandwidth_step( int config_stats_write_bandwidth_step_param );
        do_set_config_stats_write_bandwidth_step( config_stats_write_bandwidth_step_param );
    endfunction

    function automatic void set_config_stats_write_bandwidth_multiple( int config_stats_write_bandwidth_multiple_param );
        do_set_config_stats_write_bandwidth_multiple( config_stats_write_bandwidth_multiple_param );
    endfunction

    function automatic void set_config_stats_read_latency_step( int config_stats_read_latency_step_param );
        do_set_config_stats_read_latency_step( config_stats_read_latency_step_param );
    endfunction

    function automatic void set_config_stats_read_latency_multiple( int config_stats_read_latency_multiple_param );
        do_set_config_stats_read_latency_multiple( config_stats_read_latency_multiple_param );
    endfunction

    function automatic void set_config_stats_write_latency_step( int config_stats_write_latency_step_param );
        do_set_config_stats_write_latency_step( config_stats_write_latency_step_param );
    endfunction

    function automatic void set_config_stats_write_latency_multiple( int config_stats_write_latency_multiple_param );
        do_set_config_stats_write_latency_multiple( config_stats_write_latency_multiple_param );
    endfunction

    function automatic void set_config_stats_read_address_waits_step( int config_stats_read_address_waits_step_param );
        do_set_config_stats_read_address_waits_step( config_stats_read_address_waits_step_param );
    endfunction

    function automatic void set_config_stats_read_address_waits_multiple( int config_stats_read_address_waits_multiple_param );
        do_set_config_stats_read_address_waits_multiple( config_stats_read_address_waits_multiple_param );
    endfunction

    function automatic void set_config_stats_read_data_waits_step( int config_stats_read_data_waits_step_param );
        do_set_config_stats_read_data_waits_step( config_stats_read_data_waits_step_param );
    endfunction

    function automatic void set_config_stats_read_data_waits_multiple( int config_stats_read_data_waits_multiple_param );
        do_set_config_stats_read_data_waits_multiple( config_stats_read_data_waits_multiple_param );
    endfunction

    function automatic void set_config_stats_write_address_waits_step( int config_stats_write_address_waits_step_param );
        do_set_config_stats_write_address_waits_step( config_stats_write_address_waits_step_param );
    endfunction

    function automatic void set_config_stats_write_address_waits_multiple( int config_stats_write_address_waits_multiple_param );
        do_set_config_stats_write_address_waits_multiple( config_stats_write_address_waits_multiple_param );
    endfunction

    function automatic void set_config_stats_write_data_waits_step( int config_stats_write_data_waits_step_param );
        do_set_config_stats_write_data_waits_step( config_stats_write_data_waits_step_param );
    endfunction

    function automatic void set_config_stats_write_data_waits_multiple( int config_stats_write_data_waits_multiple_param );
        do_set_config_stats_write_data_waits_multiple( config_stats_write_data_waits_multiple_param );
    endfunction

    function automatic void set_config_stats_write_response_waits_step( int config_stats_write_response_waits_step_param );
        do_set_config_stats_write_response_waits_step( config_stats_write_response_waits_step_param );
    endfunction

    function automatic void set_config_stats_write_response_waits_multiple( int config_stats_write_response_waits_multiple_param );
        do_set_config_stats_write_response_waits_multiple( config_stats_write_response_waits_multiple_param );
    endfunction


    //------------------------------------------------------------------------------
    // Functions to get global variables with read access
    //------------------------------------------------------------------------------
    function automatic bit get_config_clk_init_value(  );
        return do_get_config_clk_init_value(  );
    endfunction

    function automatic int get_config_clk_phase_shift(  );
        return do_get_config_clk_phase_shift(  );
    endfunction

    function automatic int get_config_clk_1st_time(  );
        return do_get_config_clk_1st_time(  );
    endfunction

    function automatic int get_config_clk_2nd_time(  );
        return do_get_config_clk_2nd_time(  );
    endfunction

    function automatic int get_config_setup_time(  );
        return do_get_config_setup_time(  );
    endfunction

    function automatic int get_config_hold_time(  );
        return do_get_config_hold_time(  );
    endfunction

    function automatic int unsigned get_config_max_transaction_time_factor(  );
        return do_get_config_max_transaction_time_factor(  );
    endfunction

    function automatic int get_config_timeout_max_data_transfer(  );
        return do_get_config_timeout_max_data_transfer(  );
    endfunction

    function automatic int unsigned get_config_burst_timeout_factor(  );
        return do_get_config_burst_timeout_factor(  );
    endfunction

    function automatic int unsigned get_config_max_latency_AWVALID_assertion_to_AWREADY(  );
        return do_get_config_max_latency_AWVALID_assertion_to_AWREADY(  );
    endfunction

    function automatic int unsigned get_config_max_latency_ARVALID_assertion_to_ARREADY(  );
        return do_get_config_max_latency_ARVALID_assertion_to_ARREADY(  );
    endfunction

    function automatic int unsigned get_config_max_latency_RVALID_assertion_to_RREADY(  );
        return do_get_config_max_latency_RVALID_assertion_to_RREADY(  );
    endfunction

    function automatic int unsigned get_config_max_latency_BVALID_assertion_to_BREADY(  );
        return do_get_config_max_latency_BVALID_assertion_to_BREADY(  );
    endfunction

    function automatic int unsigned get_config_max_latency_WVALID_assertion_to_WREADY(  );
        return do_get_config_max_latency_WVALID_assertion_to_WREADY(  );
    endfunction

    function automatic int get_config_write_ctrl_first_ratio(  );
        return do_get_config_write_ctrl_first_ratio(  );
    endfunction

    function automatic int get_config_write_data_first_ratio(  );
        return do_get_config_write_data_first_ratio(  );
    endfunction

    function automatic int unsigned get_config_write_ctrl_to_data_mintime(  );
        return do_get_config_write_ctrl_to_data_mintime(  );
    endfunction

    function automatic int unsigned get_config_write_data_to_ctrl_mintime(  );
        return do_get_config_write_data_to_ctrl_mintime(  );
    endfunction

    function automatic bit get_config_master_write_delay(  );
        return do_get_config_master_write_delay(  );
    endfunction

    function automatic int get_config_reset_low_clocks(  );
        return do_get_config_reset_low_clocks(  );
    endfunction

    function automatic int get_config_reset_hold_time(  );
        return do_get_config_reset_hold_time(  );
    endfunction

    function automatic bit get_config_protect_ready(  );
        return do_get_config_protect_ready(  );
    endfunction

    function automatic bit get_config_enable_user_sideband(  );
        return do_get_config_enable_user_sideband(  );
    endfunction

    function automatic bit get_config_extended_length_enable(  );
        return do_get_config_extended_length_enable(  );
    endfunction

    function automatic bit get_config_enable_burst_reserved_value(  );
        return do_get_config_enable_burst_reserved_value(  );
    endfunction

    function automatic bit get_config_enable_lock_reserved_value(  );
        return do_get_config_enable_lock_reserved_value(  );
    endfunction

    function automatic bit get_config_enable_cache_reserved_value(  );
        return do_get_config_enable_cache_reserved_value(  );
    endfunction

    function automatic bit get_config_enable_all_assertions(  );
        return do_get_config_enable_all_assertions(  );
    endfunction

    function automatic bit [255:0]  get_config_enable_assertion(  );
        return do_get_config_enable_assertion(  );
    endfunction

    function automatic bit   get_config_enable_assertion_index1( int _this_dot_1 );
        return do_get_config_enable_assertion_index1( _this_dot_1 );
    endfunction

    function automatic bit [255:0]  get_config_enable_error(  );
        return do_get_config_enable_error(  );
    endfunction

    function automatic bit   get_config_enable_error_index1( int _this_dot_1 );
        return do_get_config_enable_error_index1( _this_dot_1 );
    endfunction

    function automatic bit get_config_enable_errors(  );
        return do_get_config_enable_errors(  );
    endfunction

    function automatic bit get_config_enable_all_assertion_errors(  );
        return do_get_config_enable_all_assertion_errors(  );
    endfunction

    function automatic axi_abstraction_level_e get_config_abstraction_level(  );
        return do_get_config_abstraction_level(  );
    endfunction

    function automatic bit [((AXI_ADDRESS_WIDTH) - 1):0]   get_config_slave_start_addr(  );
        return do_get_config_slave_start_addr(  );
    endfunction

    function automatic bit   get_config_slave_start_addr_index1( int _this_dot_1 );
        return do_get_config_slave_start_addr_index1( _this_dot_1 );
    endfunction

    function automatic bit [((AXI_ADDRESS_WIDTH) - 1):0]   get_config_slave_end_addr(  );
        return do_get_config_slave_end_addr(  );
    endfunction

    function automatic bit   get_config_slave_end_addr_index1( int _this_dot_1 );
        return do_get_config_slave_end_addr_index1( _this_dot_1 );
    endfunction

    function automatic bit get_config_enable_slave_addr_range_in_bfm(  );
        return do_get_config_enable_slave_addr_range_in_bfm(  );
    endfunction

    function automatic int unsigned get_config_read_data_reordering_depth(  );
        return do_get_config_read_data_reordering_depth(  );
    endfunction

    function automatic bit get_config_enable_read_data_reordering_depth_in_bfm(  );
        return do_get_config_enable_read_data_reordering_depth_in_bfm(  );
    endfunction

    function automatic bit get_config_awid_wid_mismatch(  );
        return do_get_config_awid_wid_mismatch(  );
    endfunction

    function automatic bit get_config_length_last_mismatch_error(  );
        return do_get_config_length_last_mismatch_error(  );
    endfunction

    function automatic axi_error_e get_config_master_error_position(  );
        return do_get_config_master_error_position(  );
    endfunction

    function automatic axi_assertion_type_e get_dummy_var(  );
        return do_get_dummy_var(  );
    endfunction

    function automatic int get_config_wlast_length(  );
        return do_get_config_wlast_length(  );
    endfunction

    function automatic bit [((AXI_ID_WIDTH) - 1):0]   get_config_wid_for_awid_not_matching(  );
        return do_get_config_wid_for_awid_not_matching(  );
    endfunction

    function automatic bit   get_config_wid_for_awid_not_matching_index1( int _this_dot_1 );
        return do_get_config_wid_for_awid_not_matching_index1( _this_dot_1 );
    endfunction

    function automatic bit get_config_support_exclusive_access(  );
        return do_get_config_support_exclusive_access(  );
    endfunction

    function automatic int get_config_write_data_interleaving_depth(  );
        return do_get_config_write_data_interleaving_depth(  );
    endfunction

    function automatic bit [15:0]  get_status_master_error(  );
        return do_get_status_master_error(  );
    endfunction

    function automatic bit   get_status_master_error_index1( int _this_dot_1 );
        return do_get_status_master_error_index1( _this_dot_1 );
    endfunction

    function automatic int get_status_num_reads_waiting_for_resp(  );
        return do_get_status_num_reads_waiting_for_resp(  );
    endfunction

    function automatic int get_status_num_writes_waiting_for_response(  );
        return do_get_status_num_writes_waiting_for_response(  );
    endfunction

    function automatic bit get_check_total_num_wdata_outstanding(  );
        return do_get_check_total_num_wdata_outstanding(  );
    endfunction

    function automatic int get_total_num_wdata_outstanding(  );
        return do_get_total_num_wdata_outstanding(  );
    endfunction

    function automatic bit get_check_max_num_wdata_outstanding_per_id(  );
        return do_get_check_max_num_wdata_outstanding_per_id(  );
    endfunction

    function automatic int get_max_num_wdata_outstanding_per_id(  );
        return do_get_max_num_wdata_outstanding_per_id(  );
    endfunction

    function automatic bit get_check_max_num_waddr_outstanding_per_id(  );
        return do_get_check_max_num_waddr_outstanding_per_id(  );
    endfunction

    function automatic int get_max_num_waddr_outstanding_per_id(  );
        return do_get_max_num_waddr_outstanding_per_id(  );
    endfunction

    function automatic bit get_check_total_num_waddr_outstanding(  );
        return do_get_check_total_num_waddr_outstanding(  );
    endfunction

    function automatic int get_total_num_waddr_outstanding(  );
        return do_get_total_num_waddr_outstanding(  );
    endfunction

    function automatic int get_status_outstanding_num_for_waddr(  );
        return do_get_status_outstanding_num_for_waddr(  );
    endfunction

    function automatic bit get_start_finding_outstanding_waddr(  );
        return do_get_start_finding_outstanding_waddr(  );
    endfunction

    function automatic int get_status_outstanding_num_for_wdata(  );
        return do_get_status_outstanding_num_for_wdata(  );
    endfunction

    function automatic bit get_start_finding_outstanding_wdata(  );
        return do_get_start_finding_outstanding_wdata(  );
    endfunction

    function automatic bit [((AXI_ID_WIDTH) - 1):0]   get_find_waddr_outstanding_for_wid(  );
        return do_get_find_waddr_outstanding_for_wid(  );
    endfunction

    function automatic bit   get_find_waddr_outstanding_for_wid_index1( int _this_dot_1 );
        return do_get_find_waddr_outstanding_for_wid_index1( _this_dot_1 );
    endfunction

    function automatic bit [((AXI_ID_WIDTH) - 1):0]   get_find_wdata_outstanding_for_wid(  );
        return do_get_find_wdata_outstanding_for_wid(  );
    endfunction

    function automatic bit   get_find_wdata_outstanding_for_wid_index1( int _this_dot_1 );
        return do_get_find_wdata_outstanding_for_wid_index1( _this_dot_1 );
    endfunction

    function automatic bit get_change_in_wdata_outstanding_per_id(  );
        return do_get_change_in_wdata_outstanding_per_id(  );
    endfunction

    function automatic bit get_start_finding_change_in_wdata(  );
        return do_get_start_finding_change_in_wdata(  );
    endfunction

    function automatic bit [((AXI_ID_WIDTH) - 1):0]   get_find_change_in_wdata_outstanding_for_wid(  );
        return do_get_find_change_in_wdata_outstanding_for_wid(  );
    endfunction

    function automatic bit   get_find_change_in_wdata_outstanding_for_wid_index1( int _this_dot_1 );
        return do_get_find_change_in_wdata_outstanding_for_wid_index1( _this_dot_1 );
    endfunction

    function automatic int get_config_max_outstanding_wr(  );
        return do_get_config_max_outstanding_wr(  );
    endfunction

    function automatic int get_config_max_outstanding_rd(  );
        return do_get_config_max_outstanding_rd(  );
    endfunction

    function automatic bit get_config_error_on_deleted_valid_cycles(  );
        return do_get_config_error_on_deleted_valid_cycles(  );
    endfunction

    function automatic bit get_config_stats_enable(  );
        return do_get_config_stats_enable(  );
    endfunction

    function automatic bit get_config_stats_enable_AXI_read_occupancy(  );
        return do_get_config_stats_enable_AXI_read_occupancy(  );
    endfunction

    function automatic bit get_config_stats_enable_AXI_write_occupancy(  );
        return do_get_config_stats_enable_AXI_write_occupancy(  );
    endfunction

    function automatic bit get_config_stats_enable_read_data_occupancy(  );
        return do_get_config_stats_enable_read_data_occupancy(  );
    endfunction

    function automatic bit get_config_stats_enable_write_data_occupancy(  );
        return do_get_config_stats_enable_write_data_occupancy(  );
    endfunction

    function automatic bit get_config_stats_enable_read_latency(  );
        return do_get_config_stats_enable_read_latency(  );
    endfunction

    function automatic bit get_config_stats_enable_write_latency(  );
        return do_get_config_stats_enable_write_latency(  );
    endfunction

    function automatic bit get_config_stats_enable_read_address_waits(  );
        return do_get_config_stats_enable_read_address_waits(  );
    endfunction

    function automatic bit get_config_stats_enable_read_data_waits(  );
        return do_get_config_stats_enable_read_data_waits(  );
    endfunction

    function automatic bit get_config_stats_enable_write_address_waits(  );
        return do_get_config_stats_enable_write_address_waits(  );
    endfunction

    function automatic bit get_config_stats_enable_write_data_waits(  );
        return do_get_config_stats_enable_write_data_waits(  );
    endfunction

    function automatic bit get_config_stats_enable_write_response_waits(  );
        return do_get_config_stats_enable_write_response_waits(  );
    endfunction

    function automatic bit get_config_stats_enable_read_bandwidth(  );
        return do_get_config_stats_enable_read_bandwidth(  );
    endfunction

    function automatic bit get_config_stats_enable_write_bandwidth(  );
        return do_get_config_stats_enable_write_bandwidth(  );
    endfunction

    function automatic int get_config_stats_AXI_read_occupancy_step(  );
        return do_get_config_stats_AXI_read_occupancy_step(  );
    endfunction

    function automatic int get_config_stats_AXI_read_occupancy_multiple(  );
        return do_get_config_stats_AXI_read_occupancy_multiple(  );
    endfunction

    function automatic bit get_stats_AXI_read_active(  );
        return do_get_stats_AXI_read_active(  );
    endfunction

    function automatic int get_stats_AXI_read_occupancy_sw(  );
        return do_get_stats_AXI_read_occupancy_sw(  );
    endfunction

    function automatic int get_stats_AXI_read_occupancy_sw_updated(  );
        return do_get_stats_AXI_read_occupancy_sw_updated(  );
    endfunction

    function automatic int get_stats_AXI_read_idle_sw(  );
        return do_get_stats_AXI_read_idle_sw(  );
    endfunction

    function automatic int get_stats_AXI_read_occupancy_min(  );
        return do_get_stats_AXI_read_occupancy_min(  );
    endfunction

    function automatic int get_stats_AXI_read_idle_min(  );
        return do_get_stats_AXI_read_idle_min(  );
    endfunction

    function automatic int get_stats_AXI_read_occupancy_max(  );
        return do_get_stats_AXI_read_occupancy_max(  );
    endfunction

    function automatic int get_stats_AXI_read_idle_max(  );
        return do_get_stats_AXI_read_idle_max(  );
    endfunction

    function automatic int get_stats_AXI_read_occupancy_mean(  );
        return do_get_stats_AXI_read_occupancy_mean(  );
    endfunction

    function automatic int get_stats_AXI_read_idle_mean(  );
        return do_get_stats_AXI_read_idle_mean(  );
    endfunction

    function automatic int get_config_stats_AXI_write_occupancy_step(  );
        return do_get_config_stats_AXI_write_occupancy_step(  );
    endfunction

    function automatic int get_config_stats_AXI_write_occupancy_multiple(  );
        return do_get_config_stats_AXI_write_occupancy_multiple(  );
    endfunction

    function automatic bit get_stats_AXI_write_active(  );
        return do_get_stats_AXI_write_active(  );
    endfunction

    function automatic int get_stats_AXI_write_occupancy_sw(  );
        return do_get_stats_AXI_write_occupancy_sw(  );
    endfunction

    function automatic int get_stats_AXI_write_occupancy_sw_updated(  );
        return do_get_stats_AXI_write_occupancy_sw_updated(  );
    endfunction

    function automatic int get_stats_AXI_write_idle_sw(  );
        return do_get_stats_AXI_write_idle_sw(  );
    endfunction

    function automatic int get_stats_AXI_write_occupancy_min(  );
        return do_get_stats_AXI_write_occupancy_min(  );
    endfunction

    function automatic int get_stats_AXI_write_idle_min(  );
        return do_get_stats_AXI_write_idle_min(  );
    endfunction

    function automatic int get_stats_AXI_write_occupancy_max(  );
        return do_get_stats_AXI_write_occupancy_max(  );
    endfunction

    function automatic int get_stats_AXI_write_idle_max(  );
        return do_get_stats_AXI_write_idle_max(  );
    endfunction

    function automatic int get_stats_AXI_write_occupancy_mean(  );
        return do_get_stats_AXI_write_occupancy_mean(  );
    endfunction

    function automatic int get_stats_AXI_write_idle_mean(  );
        return do_get_stats_AXI_write_idle_mean(  );
    endfunction

    function automatic int get_config_stats_read_data_occupancy_step(  );
        return do_get_config_stats_read_data_occupancy_step(  );
    endfunction

    function automatic int get_config_stats_read_data_occupancy_multiple(  );
        return do_get_config_stats_read_data_occupancy_multiple(  );
    endfunction

    function automatic int get_stats_read_data_occupancy_sw(  );
        return do_get_stats_read_data_occupancy_sw(  );
    endfunction

    function automatic int get_stats_read_data_occupancy_sw_updated(  );
        return do_get_stats_read_data_occupancy_sw_updated(  );
    endfunction

    function automatic int get_stats_read_data_idle_sw(  );
        return do_get_stats_read_data_idle_sw(  );
    endfunction

    function automatic int get_stats_read_data_occupancy_min(  );
        return do_get_stats_read_data_occupancy_min(  );
    endfunction

    function automatic int get_stats_read_data_idle_min(  );
        return do_get_stats_read_data_idle_min(  );
    endfunction

    function automatic int get_stats_read_data_occupancy_max(  );
        return do_get_stats_read_data_occupancy_max(  );
    endfunction

    function automatic int get_stats_read_data_idle_max(  );
        return do_get_stats_read_data_idle_max(  );
    endfunction

    function automatic int get_stats_read_data_occupancy_mean(  );
        return do_get_stats_read_data_occupancy_mean(  );
    endfunction

    function automatic int get_stats_read_data_idle_mean(  );
        return do_get_stats_read_data_idle_mean(  );
    endfunction

    function automatic int get_config_stats_write_data_occupancy_step(  );
        return do_get_config_stats_write_data_occupancy_step(  );
    endfunction

    function automatic int get_config_stats_write_data_occupancy_multiple(  );
        return do_get_config_stats_write_data_occupancy_multiple(  );
    endfunction

    function automatic int get_stats_write_data_occupancy_sw(  );
        return do_get_stats_write_data_occupancy_sw(  );
    endfunction

    function automatic int get_stats_write_data_occupancy_sw_updated(  );
        return do_get_stats_write_data_occupancy_sw_updated(  );
    endfunction

    function automatic int get_stats_write_data_idle_sw(  );
        return do_get_stats_write_data_idle_sw(  );
    endfunction

    function automatic int get_stats_write_data_occupancy_min(  );
        return do_get_stats_write_data_occupancy_min(  );
    endfunction

    function automatic int get_stats_write_data_idle_min(  );
        return do_get_stats_write_data_idle_min(  );
    endfunction

    function automatic int get_stats_write_data_occupancy_max(  );
        return do_get_stats_write_data_occupancy_max(  );
    endfunction

    function automatic int get_stats_write_data_idle_max(  );
        return do_get_stats_write_data_idle_max(  );
    endfunction

    function automatic int get_stats_write_data_occupancy_mean(  );
        return do_get_stats_write_data_occupancy_mean(  );
    endfunction

    function automatic int get_stats_write_data_idle_mean(  );
        return do_get_stats_write_data_idle_mean(  );
    endfunction

    function automatic int get_config_stats_read_bandwidth_step(  );
        return do_get_config_stats_read_bandwidth_step(  );
    endfunction

    function automatic int get_config_stats_read_bandwidth_multiple(  );
        return do_get_config_stats_read_bandwidth_multiple(  );
    endfunction

    function automatic int get_stats_read_bandwidth_sw(  );
        return do_get_stats_read_bandwidth_sw(  );
    endfunction

    function automatic int get_stats_read_bandwidth_sw_updated(  );
        return do_get_stats_read_bandwidth_sw_updated(  );
    endfunction

    function automatic int get_stats_read_bandwidth_min(  );
        return do_get_stats_read_bandwidth_min(  );
    endfunction

    function automatic int get_stats_read_bandwidth_max(  );
        return do_get_stats_read_bandwidth_max(  );
    endfunction

    function automatic int get_stats_read_bandwidth_mean(  );
        return do_get_stats_read_bandwidth_mean(  );
    endfunction

    function automatic int get_config_stats_write_bandwidth_step(  );
        return do_get_config_stats_write_bandwidth_step(  );
    endfunction

    function automatic int get_config_stats_write_bandwidth_multiple(  );
        return do_get_config_stats_write_bandwidth_multiple(  );
    endfunction

    function automatic int get_stats_write_bandwidth_sw(  );
        return do_get_stats_write_bandwidth_sw(  );
    endfunction

    function automatic int get_stats_write_bandwidth_sw_updated(  );
        return do_get_stats_write_bandwidth_sw_updated(  );
    endfunction

    function automatic int get_stats_write_bandwidth_min(  );
        return do_get_stats_write_bandwidth_min(  );
    endfunction

    function automatic int get_stats_write_bandwidth_max(  );
        return do_get_stats_write_bandwidth_max(  );
    endfunction

    function automatic int get_stats_write_bandwidth_mean(  );
        return do_get_stats_write_bandwidth_mean(  );
    endfunction

    function automatic int get_config_stats_read_latency_step(  );
        return do_get_config_stats_read_latency_step(  );
    endfunction

    function automatic int get_config_stats_read_latency_multiple(  );
        return do_get_config_stats_read_latency_multiple(  );
    endfunction

    function automatic int get_stats_read_latency_sw_updated(  );
        return do_get_stats_read_latency_sw_updated(  );
    endfunction

    function automatic int get_stats_read_address_data_latency_inst(  );
        return do_get_stats_read_address_data_latency_inst(  );
    endfunction

    function automatic int get_stats_read_address_data_latency_sw(  );
        return do_get_stats_read_address_data_latency_sw(  );
    endfunction

    function automatic int get_stats_read_address_data_latency_min(  );
        return do_get_stats_read_address_data_latency_min(  );
    endfunction

    function automatic int get_stats_read_address_data_latency_max(  );
        return do_get_stats_read_address_data_latency_max(  );
    endfunction

    function automatic int get_stats_read_address_data_latency_mean(  );
        return do_get_stats_read_address_data_latency_mean(  );
    endfunction

    function automatic int get_stats_read_address_address_latency_inst(  );
        return do_get_stats_read_address_address_latency_inst(  );
    endfunction

    function automatic int get_stats_read_address_address_latency_sw(  );
        return do_get_stats_read_address_address_latency_sw(  );
    endfunction

    function automatic int get_stats_read_address_address_latency_min(  );
        return do_get_stats_read_address_address_latency_min(  );
    endfunction

    function automatic int get_stats_read_address_address_latency_max(  );
        return do_get_stats_read_address_address_latency_max(  );
    endfunction

    function automatic int get_stats_read_address_address_latency_mean(  );
        return do_get_stats_read_address_address_latency_mean(  );
    endfunction

    function automatic int get_config_stats_write_latency_step(  );
        return do_get_config_stats_write_latency_step(  );
    endfunction

    function automatic int get_config_stats_write_latency_multiple(  );
        return do_get_config_stats_write_latency_multiple(  );
    endfunction

    function automatic int get_stats_write_latency_sw_updated(  );
        return do_get_stats_write_latency_sw_updated(  );
    endfunction

    function automatic int get_stats_write_address_data_latency_inst(  );
        return do_get_stats_write_address_data_latency_inst(  );
    endfunction

    function automatic int get_stats_write_address_data_latency_sw(  );
        return do_get_stats_write_address_data_latency_sw(  );
    endfunction

    function automatic int get_stats_write_address_data_latency_min(  );
        return do_get_stats_write_address_data_latency_min(  );
    endfunction

    function automatic int get_stats_write_address_data_latency_max(  );
        return do_get_stats_write_address_data_latency_max(  );
    endfunction

    function automatic int get_stats_write_address_data_latency_mean(  );
        return do_get_stats_write_address_data_latency_mean(  );
    endfunction

    function automatic int get_stats_write_data_response_latency_inst(  );
        return do_get_stats_write_data_response_latency_inst(  );
    endfunction

    function automatic int get_stats_write_data_response_latency_sw(  );
        return do_get_stats_write_data_response_latency_sw(  );
    endfunction

    function automatic int get_stats_write_data_response_latency_min(  );
        return do_get_stats_write_data_response_latency_min(  );
    endfunction

    function automatic int get_stats_write_data_response_latency_max(  );
        return do_get_stats_write_data_response_latency_max(  );
    endfunction

    function automatic int get_stats_write_data_response_latency_mean(  );
        return do_get_stats_write_data_response_latency_mean(  );
    endfunction

    function automatic int get_stats_write_address_address_latency_inst(  );
        return do_get_stats_write_address_address_latency_inst(  );
    endfunction

    function automatic int get_stats_write_address_address_latency_sw(  );
        return do_get_stats_write_address_address_latency_sw(  );
    endfunction

    function automatic int get_stats_write_address_address_latency_min(  );
        return do_get_stats_write_address_address_latency_min(  );
    endfunction

    function automatic int get_stats_write_address_address_latency_max(  );
        return do_get_stats_write_address_address_latency_max(  );
    endfunction

    function automatic int get_stats_write_address_address_latency_mean(  );
        return do_get_stats_write_address_address_latency_mean(  );
    endfunction

    function automatic int get_config_stats_read_address_waits_step(  );
        return do_get_config_stats_read_address_waits_step(  );
    endfunction

    function automatic int get_config_stats_read_address_waits_multiple(  );
        return do_get_config_stats_read_address_waits_multiple(  );
    endfunction

    function automatic int get_stats_read_address_waits_inst(  );
        return do_get_stats_read_address_waits_inst(  );
    endfunction

    function automatic int get_stats_read_address_waits_sw(  );
        return do_get_stats_read_address_waits_sw(  );
    endfunction

    function automatic int get_stats_read_address_waits_sw_updated(  );
        return do_get_stats_read_address_waits_sw_updated(  );
    endfunction

    function automatic int get_stats_read_address_waits_min(  );
        return do_get_stats_read_address_waits_min(  );
    endfunction

    function automatic int get_stats_read_address_waits_max(  );
        return do_get_stats_read_address_waits_max(  );
    endfunction

    function automatic int get_stats_read_address_waits_mean(  );
        return do_get_stats_read_address_waits_mean(  );
    endfunction

    function automatic int get_config_stats_read_data_waits_step(  );
        return do_get_config_stats_read_data_waits_step(  );
    endfunction

    function automatic int get_config_stats_read_data_waits_multiple(  );
        return do_get_config_stats_read_data_waits_multiple(  );
    endfunction

    function automatic int get_stats_read_data_waits_inst(  );
        return do_get_stats_read_data_waits_inst(  );
    endfunction

    function automatic int get_stats_read_data_waits_sw(  );
        return do_get_stats_read_data_waits_sw(  );
    endfunction

    function automatic int get_stats_read_data_waits_sw_updated(  );
        return do_get_stats_read_data_waits_sw_updated(  );
    endfunction

    function automatic int get_stats_read_data_waits_min(  );
        return do_get_stats_read_data_waits_min(  );
    endfunction

    function automatic int get_stats_read_data_waits_max(  );
        return do_get_stats_read_data_waits_max(  );
    endfunction

    function automatic int get_stats_read_data_waits_mean(  );
        return do_get_stats_read_data_waits_mean(  );
    endfunction

    function automatic int get_config_stats_write_address_waits_step(  );
        return do_get_config_stats_write_address_waits_step(  );
    endfunction

    function automatic int get_config_stats_write_address_waits_multiple(  );
        return do_get_config_stats_write_address_waits_multiple(  );
    endfunction

    function automatic int get_stats_write_address_waits_inst(  );
        return do_get_stats_write_address_waits_inst(  );
    endfunction

    function automatic int get_stats_write_address_waits_sw(  );
        return do_get_stats_write_address_waits_sw(  );
    endfunction

    function automatic int get_stats_write_address_waits_sw_updated(  );
        return do_get_stats_write_address_waits_sw_updated(  );
    endfunction

    function automatic int get_stats_write_address_waits_min(  );
        return do_get_stats_write_address_waits_min(  );
    endfunction

    function automatic int get_stats_write_address_waits_max(  );
        return do_get_stats_write_address_waits_max(  );
    endfunction

    function automatic int get_stats_write_address_waits_mean(  );
        return do_get_stats_write_address_waits_mean(  );
    endfunction

    function automatic int get_config_stats_write_data_waits_step(  );
        return do_get_config_stats_write_data_waits_step(  );
    endfunction

    function automatic int get_config_stats_write_data_waits_multiple(  );
        return do_get_config_stats_write_data_waits_multiple(  );
    endfunction

    function automatic int get_stats_write_data_waits_inst(  );
        return do_get_stats_write_data_waits_inst(  );
    endfunction

    function automatic int get_stats_write_data_waits_sw(  );
        return do_get_stats_write_data_waits_sw(  );
    endfunction

    function automatic int get_stats_write_data_waits_sw_updated(  );
        return do_get_stats_write_data_waits_sw_updated(  );
    endfunction

    function automatic int get_stats_write_data_waits_min(  );
        return do_get_stats_write_data_waits_min(  );
    endfunction

    function automatic int get_stats_write_data_waits_max(  );
        return do_get_stats_write_data_waits_max(  );
    endfunction

    function automatic int get_stats_write_data_waits_mean(  );
        return do_get_stats_write_data_waits_mean(  );
    endfunction

    function automatic int get_config_stats_write_response_waits_step(  );
        return do_get_config_stats_write_response_waits_step(  );
    endfunction

    function automatic int get_config_stats_write_response_waits_multiple(  );
        return do_get_config_stats_write_response_waits_multiple(  );
    endfunction

    function automatic int get_stats_write_response_waits_inst(  );
        return do_get_stats_write_response_waits_inst(  );
    endfunction

    function automatic int get_stats_write_response_waits_sw(  );
        return do_get_stats_write_response_waits_sw(  );
    endfunction

    function automatic int get_stats_write_response_waits_sw_updated(  );
        return do_get_stats_write_response_waits_sw_updated(  );
    endfunction

    function automatic int get_stats_write_response_waits_min(  );
        return do_get_stats_write_response_waits_min(  );
    endfunction

    function automatic int get_stats_write_response_waits_max(  );
        return do_get_stats_write_response_waits_max(  );
    endfunction

    function automatic int get_stats_write_response_waits_mean(  );
        return do_get_stats_write_response_waits_mean(  );
    endfunction

    function automatic int get_stats_rw_transaction_last_duration(  );
        return do_get_stats_rw_transaction_last_duration(  );
    endfunction

    function automatic int get_stats_AXI_read_last_duration(  );
        return do_get_stats_AXI_read_last_duration(  );
    endfunction

    function automatic int get_stats_AXI_write_last_duration(  );
        return do_get_stats_AXI_write_last_duration(  );
    endfunction

    function automatic int get_stats_read_addr_channel_phase_last_duration(  );
        return do_get_stats_read_addr_channel_phase_last_duration(  );
    endfunction

    function automatic int get_stats_read_data_burst_last_duration(  );
        return do_get_stats_read_data_burst_last_duration(  );
    endfunction

    function automatic int get_stats_read_channel_phase_last_duration(  );
        return do_get_stats_read_channel_phase_last_duration(  );
    endfunction

    function automatic int get_stats_write_addr_channel_phase_last_duration(  );
        return do_get_stats_write_addr_channel_phase_last_duration(  );
    endfunction

    function automatic int get_stats_write_data_burst_last_duration(  );
        return do_get_stats_write_data_burst_last_duration(  );
    endfunction

    function automatic int get_stats_write_channel_phase_last_duration(  );
        return do_get_stats_write_channel_phase_last_duration(  );
    endfunction

    function automatic int get_stats_write_resp_channel_phase_last_duration(  );
        return do_get_stats_write_resp_channel_phase_last_duration(  );
    endfunction


    //------------------------------------------------------------------------------
    // Function to get last database handle
    //------------------------------------------------------------------------------

    function longint get_last_handle();
        return do_get_last_handle();
    endfunction

    //------------------------------------------------------------------------------
    // Function to get last start time
    //------------------------------------------------------------------------------

    function longint get_last_start_time();
        return do_get_last_start_time();
    endfunction

    //------------------------------------------------------------------------------
    // Function to get last end time
    //------------------------------------------------------------------------------

    function longint get_last_end_time();
        return do_get_last_end_time();
    endfunction


    //------------------------------------------------------------------------------
    // Functions to set/get generic interface configuration
    //------------------------------------------------------------------------------

    function void set_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0,
        input int arg10 = 0
    );
        do_set_interface( what, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10 );
    endfunction

    function int get_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0
    );
        return do_get_interface( what, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 );
    endfunction

    //------------------------------------------------------------------------------
    // Functions to get the hierarchic name of this interface
    //------------------------------------------------------------------------------
    function string get_full_name();
        return do_get_full_name();
    endfunction

    //------------------------------------------------------------------------------
    // Functions to set/get the abstraction levels of interface ends
    //------------------------------------------------------------------------------
    function void axi_set_master_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        do_axi_set_master_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi_get_master_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        do_axi_get_master_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi_set_slave_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        do_axi_set_slave_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi_get_slave_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        do_axi_get_slave_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi_set_clock_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        do_axi_set_clock_source_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi_get_clock_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        do_axi_get_clock_source_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi_set_reset_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        do_axi_set_reset_source_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi_get_reset_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        do_axi_get_reset_source_abstraction_level( wire_level, TLM_level );
    endfunction


    //------------------------------------------------------------------------------
    // Interface end access functions
    //------------------------------------------------------------------------------

    function longint get_axi_master_end();
        return do_get_axi_master_end();
    endfunction

    function longint get_axi_slave_end();
        return do_get_axi_slave_end();
    endfunction

    function longint get_axi_clock_source_end();
        return do_get_axi_clock_source_end();
    endfunction

    function longint get_axi_reset_source_end();
        return do_get_axi_reset_source_end();
    endfunction

    function longint get_axi__monitor_end();
        return do_get_axi__monitor_end();
    endfunction


    //------------------------------------------------------------------------------
    // Transaction interface
    //------------------------------------------------------------------------------
    task automatic dvc_activate_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi_size_e size,
        ref axi_burst_e burst,
        ref axi_lock_e lock,
        ref axi_cache_e cache,
        ref axi_prot_e prot,
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [3:0] burst_length,
        ref bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref axi_response_e resp[],
        ref bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        ref bit [7:0] resp_user,
        ref axi_rw_e read_or_write,
        ref int address_to_data_latency,
        ref int data_to_response_latency,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        ref int address_valid_delay,
        ref int data_valid_delay[],
        ref int write_response_valid_delay,
        ref int address_ready_delay,
        ref int data_ready_delay[],
        ref int write_response_ready_delay,
        ref bit write_data_with_address,
        input int _unit_id = 0
    );
        do_dvc_activate_rw_transaction(_comms_semantic, _as_end,addr,size,burst,lock,cache,prot,id,burst_length,data_words,write_strobes,resp,addr_user,data_user,resp_user,read_or_write,address_to_data_latency,data_to_response_latency,write_address_to_data_delay,write_data_to_address_delay,write_data_beats_delay,address_valid_delay,data_valid_delay,write_response_valid_delay,address_ready_delay,data_ready_delay,write_response_ready_delay,write_data_with_address,_unit_id);
    endtask

    task automatic dvc_get_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        ref bit [((((AXI_RDATA_WIDTH > AXI_WDATA_WIDTH) ? AXI_RDATA_WIDTH : AXI_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref axi_response_e resp[],
        output bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output axi_rw_e read_or_write,
        output int address_to_data_latency,
        output int data_to_response_latency,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        output int address_valid_delay,
        ref int data_valid_delay[],
        output int write_response_valid_delay,
        output int address_ready_delay,
        ref int data_ready_delay[],
        output int write_response_ready_delay,
        output bit write_data_with_address,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_rw_transaction(_comms_semantic, _as_end,addr,size,burst,lock,cache,prot,id,burst_length,data_words,write_strobes,resp,addr_user,data_user,resp_user,read_or_write,address_to_data_latency,data_to_response_latency,write_address_to_data_delay,write_data_to_address_delay,write_data_beats_delay,address_valid_delay,data_valid_delay,write_response_valid_delay,address_ready_delay,data_ready_delay,write_response_ready_delay,write_data_with_address,_unit_id,_using);
    endtask

    task automatic dvc_activate_AXI_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi_size_e size,
        ref axi_burst_e burst,
        ref axi_lock_e lock,
        ref axi_cache_e cache,
        ref axi_prot_e prot,
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        ref bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        ref int address_to_data_latency,
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int address_valid_delay,
        input int _unit_id = 0
    );
        do_dvc_activate_AXI_read(_comms_semantic, _as_end,addr,size,burst,lock,cache,prot,id,burst_length,data_words,resp,addr_user,data_user,address_to_data_latency,addr_start_time,addr_end_time,data_start_time,data_end_time,address_valid_delay,_unit_id);
    endtask

    task automatic dvc_get_AXI_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        output bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        output int address_to_data_latency,
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output int address_valid_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_AXI_read(_comms_semantic, _as_end,addr,size,burst,lock,cache,prot,id,burst_length,data_words,resp,addr_user,data_user,address_to_data_latency,addr_start_time,addr_end_time,data_start_time,data_end_time,address_valid_delay,_unit_id,_using);
    endtask

    task automatic dvc_activate_AXI_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi_size_e size,
        ref axi_burst_e burst,
        ref axi_lock_e lock,
        ref axi_cache_e cache,
        ref axi_prot_e prot,
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [3:0] burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref axi_response_e resp,
        ref bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        ref bit [7:0] resp_user,
        ref int address_to_data_latency,
        ref int data_to_response_latency,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref longint wr_resp_start_time,
        ref longint wr_resp_end_time,
        ref int address_valid_delay,
        input int _unit_id = 0
    );
        do_dvc_activate_AXI_write(_comms_semantic, _as_end,addr,size,burst,lock,cache,prot,id,burst_length,data_words,write_strobes,resp,addr_user,data_user,resp_user,address_to_data_latency,data_to_response_latency,write_address_to_data_delay,write_data_to_address_delay,write_data_beats_delay,addr_start_time,addr_end_time,data_start_time,data_end_time,wr_resp_start_time,wr_resp_end_time,address_valid_delay,_unit_id);
    endtask

    task automatic dvc_get_AXI_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [3:0] burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output axi_response_e resp,
        output bit [7:0] addr_user,
        ref bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output int address_to_data_latency,
        output int data_to_response_latency,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output longint wr_resp_start_time,
        output longint wr_resp_end_time,
        output int address_valid_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_AXI_write(_comms_semantic, _as_end,addr,size,burst,lock,cache,prot,id,burst_length,data_words,write_strobes,resp,addr_user,data_user,resp_user,address_to_data_latency,data_to_response_latency,write_address_to_data_delay,write_data_to_address_delay,write_data_beats_delay,addr_start_time,addr_end_time,data_start_time,data_end_time,wr_resp_start_time,wr_resp_end_time,address_valid_delay,_unit_id,_using);
    endtask

    task automatic dvc_activate_data_resp
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref axi_response_e resp,
        ref bit [7:0] data_user [],
        ref bit [7:0] resp_user,
        ref longint data_start,
        ref longint data_end,
        ref longint response_start,
        ref int write_data_beats_delay[],
        ref longint data_beat_start_time[],
        ref longint data_beat_end_time[],
        ref longint response_end_time,
        input int _unit_id = 0
    );
        do_dvc_activate_data_resp(_comms_semantic, _as_end,burst_length,data_words,write_strobes,id,resp,data_user,resp_user,data_start,data_end,response_start,write_data_beats_delay,data_beat_start_time,data_beat_end_time,response_end_time,_unit_id);
    endtask

    task automatic dvc_get_data_resp
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output axi_response_e resp,
        ref bit [7:0] data_user [],
        output bit [7:0] resp_user,
        output longint data_start,
        output longint data_end,
        output longint response_start,
        ref int write_data_beats_delay[],
        ref longint data_beat_start_time[],
        ref longint data_beat_end_time[],
        output longint response_end_time,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_data_resp(_comms_semantic, _as_end,burst_length,data_words,write_strobes,id,resp,data_user,resp_user,data_start,data_end,response_start,write_data_beats_delay,data_beat_start_time,data_beat_end_time,response_end_time,_unit_id,_using);
    endtask

    task automatic dvc_put_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0
    );
        do_dvc_put_read_data_burst(_comms_semantic, _as_end,burst_length,data_words,resp,id,data_user,data_start_time,data_end_time,_unit_id);
    endtask

    task automatic dvc_get_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [3:0] burst_length,
        ref bit [((AXI_RDATA_WIDTH) - 1):0] data_words [],
        ref axi_response_e resp[],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_data_burst(_comms_semantic, _as_end,burst_length,data_words,resp,id,data_user,data_start_time,data_end_time,_unit_id,_using);
    endtask

    task automatic dvc_put_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref int write_data_beats_delay[],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0
    );
        do_dvc_put_write_data_burst(_comms_semantic, _as_end,burst_length,data_words,write_strobes,id,data_user,write_data_beats_delay,data_start_time,data_end_time,_unit_id);
    endtask

    task automatic dvc_get_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output int burst_length,
        ref bit [((AXI_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] data_user [],
        ref int write_data_beats_delay[],
        ref longint data_start_time[],
        ref longint data_end_time[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_data_burst(_comms_semantic, _as_end,burst_length,data_words,write_strobes,id,data_user,write_data_beats_delay,data_start_time,data_end_time,_unit_id,_using);
    endtask

    task automatic dvc_put_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
        do_dvc_put_read_addr_channel_phase(_comms_semantic, _as_end,addr,burst_length,size,burst,lock,cache,prot,id,addr_user,address_valid_delay,address_ready_delay,_unit_id);
    endtask

    task automatic dvc_get_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_addr_channel_phase(_comms_semantic, _as_end,addr,burst_length,size,burst,lock,cache,prot,id,addr_user,address_valid_delay,address_ready_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int data_ready_delay,
        input int _unit_id = 0
    );
        do_dvc_put_read_channel_phase(_comms_semantic, _as_end,last,data,resp,id,data_user,data_ready_delay,_unit_id);
    endtask

    task automatic dvc_get_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_channel_phase(_comms_semantic, _as_end,last,data,resp,id,data_user,data_ready_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
        do_dvc_put_write_addr_channel_phase(_comms_semantic, _as_end,addr,burst_length,size,burst,lock,cache,prot,id,addr_user,address_valid_delay,address_ready_delay,_unit_id);
    endtask

    task automatic dvc_get_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_addr_channel_phase(_comms_semantic, _as_end,addr,burst_length,size,burst,lock,cache,prot,id,addr_user,address_valid_delay,address_ready_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int data_ready_delay,
        input int _unit_id = 0
    );
        do_dvc_put_write_channel_phase(_comms_semantic, _as_end,last,data,write_strobes,id,data_user,data_ready_delay,_unit_id);
    endtask

    task automatic dvc_get_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_channel_phase(_comms_semantic, _as_end,last,data,write_strobes,id,data_user,data_ready_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] resp_user,
        input int write_response_ready_delay,
        input int _unit_id = 0
    );
        do_dvc_put_write_resp_channel_phase(_comms_semantic, _as_end,resp,id,resp_user,write_response_ready_delay,_unit_id);
    endtask

    task automatic dvc_get_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] resp_user,
        output int write_response_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_resp_channel_phase(_comms_semantic, _as_end,resp,id,resp_user,write_response_ready_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int _unit_id = 0
    );
        do_dvc_put_read_addr_channel_cycle(_comms_semantic, _as_end,addr,burst_length,size,burst,lock,cache,prot,id,addr_user,_unit_id);
    endtask

    task automatic dvc_get_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_addr_channel_cycle(_comms_semantic, _as_end,addr,burst_length,size,burst,lock,cache,prot,id,addr_user,_unit_id,_using);
    endtask

    task automatic dvc_put_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        do_dvc_put_read_addr_channel_ready(_comms_semantic, _as_end,ready,_unit_id);
    endtask

    task automatic dvc_get_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_addr_channel_ready(_comms_semantic, _as_end,ready,_unit_id,_using);
    endtask

    task automatic dvc_put_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int _unit_id = 0
    );
        do_dvc_put_read_channel_cycle(_comms_semantic, _as_end,last,data,resp,id,data_user,_unit_id);
    endtask

    task automatic dvc_get_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_RDATA_WIDTH) - 1):0]  data,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_channel_cycle(_comms_semantic, _as_end,last,data,resp,id,data_user,_unit_id,_using);
    endtask

    task automatic dvc_put_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        do_dvc_put_read_channel_ready(_comms_semantic, _as_end,ready,_unit_id);
    endtask

    task automatic dvc_get_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_channel_ready(_comms_semantic, _as_end,ready,_unit_id,_using);
    endtask

    task automatic dvc_put_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] burst_length,
        input axi_size_e size,
        input axi_burst_e burst,
        input axi_lock_e lock,
        input axi_cache_e cache,
        input axi_prot_e prot,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] addr_user,
        input int _unit_id = 0
    );
        do_dvc_put_write_addr_channel_cycle(_comms_semantic, _as_end,addr,burst_length,size,burst,lock,cache,prot,id,addr_user,_unit_id);
    endtask

    task automatic dvc_get_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] burst_length,
        output axi_size_e size,
        output axi_burst_e burst,
        output axi_lock_e lock,
        output axi_cache_e cache,
        output axi_prot_e prot,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] addr_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_addr_channel_cycle(_comms_semantic, _as_end,addr,burst_length,size,burst,lock,cache,prot,id,addr_user,_unit_id,_using);
    endtask

    task automatic dvc_put_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        do_dvc_put_write_addr_channel_ready(_comms_semantic, _as_end,ready,_unit_id);
    endtask

    task automatic dvc_get_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_addr_channel_ready(_comms_semantic, _as_end,ready,_unit_id,_using);
    endtask

    task automatic dvc_put_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit last,
        input bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  strb,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] data_user,
        input int _unit_id = 0
    );
        do_dvc_put_write_channel_cycle(_comms_semantic, _as_end,last,data,strb,id,data_user,_unit_id);
    endtask

    task automatic dvc_get_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit last,
        output bit [((AXI_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI_WDATA_WIDTH / 8)) - 1):0]  strb,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] data_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_channel_cycle(_comms_semantic, _as_end,last,data,strb,id,data_user,_unit_id,_using);
    endtask

    task automatic dvc_put_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        do_dvc_put_write_channel_ready(_comms_semantic, _as_end,ready,_unit_id);
    endtask

    task automatic dvc_get_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_channel_ready(_comms_semantic, _as_end,ready,_unit_id,_using);
    endtask

    task automatic dvc_put_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi_response_e resp,
        input bit [((AXI_ID_WIDTH) - 1):0]  id,
        input bit [7:0] resp_user,
        input int _unit_id = 0
    );
        do_dvc_put_write_resp_channel_cycle(_comms_semantic, _as_end,resp,id,resp_user,_unit_id);
    endtask

    task automatic dvc_get_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi_response_e resp,
        output bit [((AXI_ID_WIDTH) - 1):0]  id,
        output bit [7:0] resp_user,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_resp_channel_cycle(_comms_semantic, _as_end,resp,id,resp_user,_unit_id,_using);
    endtask

    task automatic dvc_put_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        do_dvc_put_write_resp_channel_ready(_comms_semantic, _as_end,ready,_unit_id);
    endtask

    task automatic dvc_get_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_resp_channel_ready(_comms_semantic, _as_end,ready,_unit_id,_using);
    endtask

    //------------------------------------------------------------------------------
    // Functions to register reports for the interface and interface-ends.
    //------------------------------------------------------------------------------
    //------------------------------------------------------------------------------
    // Tasks for registering reports
    //------------------------------------------------------------------------------
    function void register_interface_reporter( input questa_mvc_reporter _rep = null );
        register_end_point( _interface_ref, _rep );
    endfunction

    function void register_master_reporter
    (
        input questa_mvc_reporter rep = null
    );
        do_register_master_reporter( rep );
    endfunction

    function void register_slave_reporter
    (
        input questa_mvc_reporter rep = null
    );
        do_register_slave_reporter( rep );
    endfunction

    function void register_clock_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
        do_register_clock_source_reporter( rep );
    endfunction

    function void register_reset_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
        do_register_reset_source_reporter( rep );
    endfunction

endclass

    (* elab_init *) axi_implementation_class #(AXI_ADDRESS_WIDTH, AXI_RDATA_WIDTH, AXI_WDATA_WIDTH, AXI_ID_WIDTH) this_interface_class = new();

    //------------------------------------------------------------------------------
    //
    // FUNCTION: get_interface_class
    //     Return a handle to the <axi_interface_class> API for this interface
    //
    //------------------------------------------------------------------------------
    function axi_interface_class #(AXI_ADDRESS_WIDTH, AXI_RDATA_WIDTH, AXI_WDATA_WIDTH, AXI_ID_WIDTH) get_interface_class();
        return this_interface_class;
    endfunction

endinterface

`endif // VCS

