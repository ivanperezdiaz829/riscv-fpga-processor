// *****************************************************************************
//
// Copyright 2007-2013 Mentor Graphics Corporation
// All Rights Reserved.
//
// THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION WHICH IS THE PROPERTY OF
// MENTOR GRAPHICS CORPORATION OR ITS LICENSORS AND IS SUBJECT TO LICENSE TERMS.
//
// *****************************************************************************
// SystemVerilog           Version: 20130911_Questa_10.2c
// *****************************************************************************

// Title: axi4_top
//

package mgc_axi4_pkg;
import QUESTA_MVC::*;

`ifdef MODEL_TECH
// *****************************************************************************
//
// Copyright 2007-2013 Mentor Graphics Corporation
// All Rights Reserved.
//
// THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION WHICH IS THE PROPERTY OF
// MENTOR GRAPHICS CORPORATION OR ITS LICENSORS AND IS SUBJECT TO LICENSE TERMS.
//
// *****************************************************************************
// SystemVerilog           Version: 20130911_Questa_10.2c
// *****************************************************************************

// Title: axi4_types
//

// enum: axi4_prot_e
//
//------------------------------------------------------------------------------
//  Protection type mapped to the AxPROT signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.7))
//  
// AXI4_NORM_SEC_DATA - Normal/Secure/Data
// AXI4_PRIV_SEC_DATA - Privileged/Secure/Data
// AXI4_NORM_NONSEC_DATA - Normal/Non-secure/Data
// AXI4_PRIV_NONSEC_DATA - Privileged/Non-secure/Data
// AXI4_NORM_SEC_INST - Normal/Secure/Instruction
// AXI4_PRIV_SEC_INST - Privileged/Secure/Instruction
// AXI4_NORM_NONSEC_INST - Normal/Non-secure/Instruction
// AXI4_PRIV_NONSEC_INST - Privileged/Non-secure/Instruction
//  
//------------------------------------------------------------------------------
typedef enum bit [2:0]
{
    AXI4_NORM_SEC_DATA    = 3'h0,
    AXI4_PRIV_SEC_DATA    = 3'h1,
    AXI4_NORM_NONSEC_DATA = 3'h2,
    AXI4_PRIV_NONSEC_DATA = 3'h3,
    AXI4_NORM_SEC_INST    = 3'h4,
    AXI4_PRIV_SEC_INST    = 3'h5,
    AXI4_NORM_NONSEC_INST = 3'h6,
    AXI4_PRIV_NONSEC_INST = 3'h7
} axi4_prot_e;


// enum: axi4_response_e
//
//------------------------------------------------------------------------------
//  Response type mapped to the xRESP signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.4)
// 
// AXI4_OKAY   - Normal access has been successful, or exclusive access has failed (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.4).
// AXI4_EXOKAY - Exclusive acess okay (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.4)) OR Reserved value if QVIP BFM is configured as axi4lite interface (see AMBA AXI and ACE Protocol Specification IHI0022D section B1.1.1.
// AXI4_SLVERR - Slave signals an error to the originating master.
// AXI4_DECERR - Decode error (generally used to indicate that there is no slave at the transaction address).
//  
//------------------------------------------------------------------------------
typedef enum bit [1:0]
{
    AXI4_OKAY   = 2'h0,
    AXI4_EXOKAY = 2'h1,
    AXI4_SLVERR = 2'h2,
    AXI4_DECERR = 2'h3
} axi4_response_e;


// enum: axi4_rw_e
//
//------------------------------------------------------------------------------
//  This is used as the <axi4_master_rw_transaction::read_or_write> argument to the <axi4_master_rw_transaction> transaction to indicate read or write.
// 
// AXI4_TRANS_READ - read transaction
// AXI4_TRANS_WRITE - write transaction
//  
//------------------------------------------------------------------------------
typedef enum bit [0:0]
{
    AXI4_TRANS_READ  = 1'h0,
    AXI4_TRANS_WRITE = 1'h1
} axi4_rw_e;


// enum: axi4_size_e
//
//------------------------------------------------------------------------------
//  Word-size encoding mapped to the AxSIZE signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1). 
// 
// AXI4_BYTES_1 - 3'b000 i.e. 1 byte
// AXI4_BYTES_2 - 3'b001 i.e. 2 bytes
// AXI4_BYTES_4 - 3'b010 i.e. 4 bytes
// AXI4_BYTES_8 - 3'b011 i.e. 8 bytes
// AXI4_BYTES_16 - 3'b100 i.e. 16 bytes
// AXI4_BYTES_32 - 3'b101 i.e. 32 bytes
// AXI4_BYTES_64 - 3'b110 i.e. 64 bytes
// AXI4_BYTES_128 - 3'b111 i.e. 128 bytes
// 
//------------------------------------------------------------------------------
typedef enum bit [2:0]
{
    AXI4_BYTES_1   = 3'h0,
    AXI4_BYTES_2   = 3'h1,
    AXI4_BYTES_4   = 3'h2,
    AXI4_BYTES_8   = 3'h3,
    AXI4_BYTES_16  = 3'h4,
    AXI4_BYTES_32  = 3'h5,
    AXI4_BYTES_64  = 3'h6,
    AXI4_BYTES_128 = 3'h7
} axi4_size_e;


// enum: axi4_cache_e
//
//------------------------------------------------------------------------------
//  Cache behaviour type, mapped to the AxCACHE signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4).
// 
// This has identical values to those in AXI3, but the AxCACHE[1] bit is now named 'Modifiable' (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.3.1)
// 
// AXI4_NONMODIFIABLE_NONBUF - Non-modifiable and non-bufferable
// AXI4_BUF_ONLY - Bufferable only
// AXI4_CACHE_2 - Bit pattern 0010
// AXI4_CACHE_3 - Bit pattern 0011
// AXI4_CACHE_RSVD_4 - Reserved
// AXI4_CACHE_RSVD_5 - Reserved
// AXI4_CACHE_6 - Bit pattern 0110
// AXI4_CACHE_7 - Bit pattern 0111
// AXI4_CACHE_RSVD_8 - Reserved
// AXI4_CACHE_RSVD_9 - Reserved
// AXI4_CACHE_10 - Bit pattern 1010
// AXI4_CACHE_11 - Bit pattern 1011
// AXI4_CACHE_RSVD_12 - Reserved
// AXI4_CACHE_RSVD_13 - Reserved
// AXI4_CACHE_14 - Bit pattern 1110
// AXI4_CACHE_15 - Bit pattern 1111
// 
//------------------------------------------------------------------------------
typedef enum bit [3:0]
{
    AXI4_NONMODIFIABLE_NONBUF = 4'h0,
    AXI4_BUF_ONLY             = 4'h1,
    AXI4_CACHE_2              = 4'h2,
    AXI4_CACHE_3              = 4'h3,
    AXI4_CACHE_RSVD_4         = 4'h4,
    AXI4_CACHE_RSVD_5         = 4'h5,
    AXI4_CACHE_6              = 4'h6,
    AXI4_CACHE_7              = 4'h7,
    AXI4_CACHE_RSVD_8         = 4'h8,
    AXI4_CACHE_RSVD_9         = 4'h9,
    AXI4_CACHE_10             = 4'ha,
    AXI4_CACHE_11             = 4'hb,
    AXI4_CACHE_RSVD_12        = 4'hc,
    AXI4_CACHE_RSVD_13        = 4'hd,
    AXI4_CACHE_14             = 4'he,
    AXI4_CACHE_15             = 4'hf
} axi4_cache_e;


// enum: axi4_burst_e
//
//------------------------------------------------------------------------------
//  Burst type mapped to the AxBURST signals to determine address calculation (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.4). 
// 
// AXI4_FIXED - Fixed
// AXI4_INCR - Incrementing
// AXI4_WRAP - Wrap
// AXI4_RESERVED - Reserved value. May be enabled by setting the configuration parameter <mgc_axi4::config_enable_burst_reserved_value>.
// 
//------------------------------------------------------------------------------
typedef enum bit [1:0]
{
    AXI4_FIXED    = 2'h0,
    AXI4_INCR     = 2'h1,
    AXI4_WRAP     = 2'h2,
    AXI4_RESERVED = 2'h3
} axi4_burst_e;


// enum: axi4_lock_e
//
//------------------------------------------------------------------------------
//  Access type mapped to the AxLOCK signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.4).
// 
// AXI4_NORMAL - Normal Access, respecting barriers
// AXI4_EXCLUSIVE - Exclusive Access, respecting barriers
// 
//------------------------------------------------------------------------------
typedef enum bit [1:0]
{
    AXI4_NORMAL    = 2'h0,
    AXI4_EXCLUSIVE = 2'h1
} axi4_lock_e;


// enum: axi4_interface_type_e
//
//------------------------------------------------------------------------------
//  Type to configure the category of the interface (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.2) as read/write, read-only or write-only by setting the value of <mgc_axi4::config_interface_type> configuration parameter.
// 
// AXI4_READWRITE - Read and Write
// AXI4_READONLY - Read Only
// AXI4_WRITEONLY - Write Only
// 
//------------------------------------------------------------------------------
typedef enum bit [1:0]
{
    AXI4_READWRITE = 2'h0,
    AXI4_READONLY  = 2'h1,
    AXI4_WRITEONLY = 2'h2
} axi4_interface_type_e;


// enum: axi4_error_e
//
//------------------------------------------------------------------------------
//  Type defining the error messages which can be produced by the <mgc_axi4> Questa Verification IP.
// 
// Individual error messages can be disabled using the <mgc_axi4::config_enable_assertion> array of configuration bits.
// 
//------------------------------------------------------------------------------
//    AXI4_ADDRESS_WIDTH_EXCEEDS_64 -  AXI4 supports up to 64-bit addressing (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.3.1)
//    AXI4_ARADDR_CHANGED_BEFORE_ARREADY -  The value of <mgc_axi4::ARADDR> has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARADDR_UNKN -  <mgc_axi4::ARADDR> has an X value/<mgc_axi4::ARADDR> has an Z value
//    AXI4_ARPROT_CHANGED_BEFORE_ARREADY -  The value of <mgc_axi4::ARPROT> has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARPROT_UNKN -  <mgc_axi4::ARPROT> has an X value/<mgc_axi4::ARPROT> has an Z value
//    AXI4_ARREADY_NOT_ASSERTED_AFTER_ARVALID -  Once <mgc_axi4::ARVALID> has been asserted, <mgc_axi4::ARREADY> should be asserted within <mgc_axi4::config_max_latency_ARVALID_assertion_to_ARREADY> clock periods
//    AXI4_ARREADY_UNKN -  <mgc_axi4::ARREADY> has an X value/<mgc_axi4::ARREADY> has a Z value
//    AXI4_ARVALID_DEASSERTED_BEFORE_ARREADY -  <mgc_axi4::ARVALID> has been de-asserted before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARVALID_HIGH_ON_FIRST_CLOCK -  A master interface must begin driving <mgc_axi4::ARVALID> high only at a rising clock edge after <mgc_axi4::ARESETn> is HIGH (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.1.2)
//    AXI4_ARVALID_UNKN -  <mgc_axi4::ARVALID> has an X value/<mgc_axi4::ARVALID> has an Z value
//    AXI4_AWADDR_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWADDR> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWADDR_UNKN -  <mgc_axi4::AWADDR> has an X value/<mgc_axi4::AWADDR> has an Z value
//    AXI4_AWPROT_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWPROT> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWPROT_UNKN -  <mgc_axi4::AWPROT> has an X value/<mgc_axi4::AWPROT> has an Z value
//    AXI4_AWREADY_NOT_ASSERTED_AFTER_AWVALID -  Once <mgc_axi4::AWVALID> has been asserted, <mgc_axi4::AWREADY> should be asserted within <mgc_axi4::config_max_latency_AWVALID_assertion_to_AWREADY> clock periods
//    AXI4_AWREADY_UNKN -  <mgc_axi4::AWREADY> has an X value/<mgc_axi4::AWREADY> has an Z value
//    AXI4_AWVALID_DEASSERTED_BEFORE_AWREADY -  <mgc_axi4::AWVALID> has been de-asserted before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWVALID_HIGH_ON_FIRST_CLOCK -  A master interface must begin driving <mgc_axi4::AWVALID> high only at a rising clock edge after <mgc_axi4::ARESETn> is HIGH (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.1.2)
//    AXI4_AWVALID_UNKN -  <mgc_axi4::AWVALID> has an X value/<mgc_axi4::AWVALID> has an Z value
//    AXI4_BREADY_NOT_ASSERTED_AFTER_BVALID -  Once <mgc_axi4::BVALID> has been asserted, <mgc_axi4::BREADY> should be asserted within <mgc_axi4::config_max_latency_BVALID_assertion_to_BREADY> clock periods
//    AXI4_BREADY_UNKN -  <mgc_axi4::BREADY> has an X value/<mgc_axi4::BREADY> has an Z value
//    AXI4_BRESP_CHANGED_BEFORE_BREADY -  The value of <mgc_axi4::BRESP> has changed from its initial value between the time <mgc_axi4::BVALID> was asserted, and before <mgc_axi4::BREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_BRESP_UNKN -  <mgc_axi4::BRESP> has an X value/<mgc_axi4::BRESP> has a Z value
//    AXI4_BVALID_DEASSERTED_BEFORE_BREADY -  <mgc_axi4::BVALID> has been de-asserted before <mgc_axi4::BREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_BVALID_HIGH_EXITING_RESET -  <mgc_axi4::BVALID> should have been driven low when exiting reset (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.1.2)
//    AXI4_BVALID_UNKN -  <mgc_axi4::BVALID> has an X value/<mgc_axi4::BVALID> has a Z value
//    AXI4_DEC_ERR_RESP_FOR_READ -  No slave at the address for this read transfer (signaled by <AXI4_DECERR>)
//    AXI4_DEC_ERR_RESP_FOR_WRITE -  No slave at the address for this write transfer (signaled by <AXI4_DECERR>)
//    AXI4_EXOKAY_RESPONSE_NORMAL_READ -  Slave has responded <AXI4_EXOKAY> to a non exclusive read transfer
//    AXI4_EXOKAY_RESPONSE_NORMAL_WRITE -  Slave has responded <AXI4_EXOKAY> to a non exclusive write transfer 
//    AXI4_INVALID_WRITE_STROBES_ON_UNALIGNED_WRITE_TRANSFER -  Write strobe(s) incorrect for address/size of an unaligned transaction (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.3)
//    AXI4_MINIMUM_SLAVE_ADDRESS_SPACE_VIOLATION -  The minimum address space occupied by a single slave device is 4 kilobytes (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.3.2)
//    AXI4_PARAM_READ_DATA_BUS_WIDTH -  The value of <mgc_axi4::AXI4_RDATA_WIDTH> must be either 32 or 64 (see AMBA AXI and ACE Protocol Specification IHI0022D section B1.1.2)
//    AXI4_PARAM_WRITE_DATA_BUS_WIDTH -  The value of <mgc_axi4::AXI4_WDATA_WIDTH> must be either 32 or 64 (see AMBA AXI and ACE Protocol Specification IHI0022D section B1.1.2)
//    AXI4_READ_DATA_BEFORE_ADDRESS -  An unexpected read response has occurred (there are no outstanding read transactions with this id) (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.3)
//    AXI4_READ_DATA_CHANGED_BEFORE_RREADY -  The value of <mgc_axi4::RDATA> has changed from its initial value between the time <mgc_axi4::RVALID> was asserted, and before <mgc_axi4::RREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_READ_DATA_UNKN -  <mgc_axi4::RDATA> has an X value/<mgc_axi4::RDATA> has a Z value
//    AXI4_READ_RESP_CHANGED_BEFORE_RREADY -  The value of <mgc_axi4::RRESP> has changed from its initial value between the time <mgc_axi4::RVALID> was asserted, and before <mgc_axi4::RREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_RREADY_NOT_ASSERTED_AFTER_RVALID -  Once <mgc_axi4::RVALID> has been asserted, <mgc_axi4::RREADY> should be asserted within <mgc_axi4::config_max_latency_RVALID_assertion_to_RREADY> clock periods
//    AXI4_RREADY_UNKN -  <mgc_axi4::RREADY> has an X value/<mgc_axi4::RREADY> has a Z value
//    AXI4_RRESP_UNKN -  <mgc_axi4::RRESP> has an X value/<mgc_axi4::RRESP> has a Z value
//    AXI4_RVALID_DEASSERTED_BEFORE_RREADY -  <mgc_axi4::RVALID> has been de-asserted before <mgc_axi4::RREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_RVALID_HIGH_EXITING_RESET -  <mgc_axi4::RVALID> should have been driven low when exiting reset (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.1.2)
//    AXI4_RVALID_UNKN -  <mgc_axi4::RVALID> has an X value/<mgc_axi4::RVALID> has a Z value
//    AXI4_SLV_ERR_RESP_FOR_READ -  Slave has detected an error for this read transfer (signaled by <AXI4_SLVERR>)
//    AXI4_SLV_ERR_RESP_FOR_WRITE -  Slave has detected an error for this write transfer (signaled by <AXI4_SLVERR>)
//    AXI4_TIMEOUT_WAITING_FOR_READ_RESPONSE -  Timed-out waiting for a read response (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.6)
//    AXI4_TIMEOUT_WAITING_FOR_WRITE_RESPONSE -  Timed-out waiting for a write response (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.6)
//    AXI4_WDATA_CHANGED_BEFORE_WREADY_ON_INVALID_LANE -  On a lane whose strobe is 0, the value of <mgc_axi4::WDATA> has changed from its initial value between the time <mgc_axi4::WVALID> was asserted, and before <mgc_axi4::WREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_WDATA_CHANGED_BEFORE_WREADY_ON_VALID_LANE -  On a lane whose strobe is 1, the value of <mgc_axi4::WDATA> has changed from its initial value between the time <mgc_axi4::WVALID> was asserted, and before <mgc_axi4::WREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_WREADY_NOT_ASSERTED_AFTER_WVALID -  Once <mgc_axi4::WVALID> has been asserted, <mgc_axi4::WREADY> should be asserted within <mgc_axi4::config_max_latency_WVALID_assertion_to_WREADY> clock periods
//    AXI4_WREADY_UNKN -  <mgc_axi4::WREADY> has an X value/<mgc_axi4::WREADY> has a Z value
//    AXI4_WRITE_DATA_BEFORE_ADDRESS -  A write data beat has occurred before the corresponding address phase
//    AXI4_WRITE_DATA_UNKN_ON_INVALID_LANE -  On a lane whose strobe is 0, <mgc_axi4::WDATA> has an X value/<mgc_axi4::WDATA> has a Z value
//    AXI4_WRITE_DATA_UNKN_ON_VALID_LANE -  On a lane whose strobe is 1, <mgc_axi4::WDATA> has an X value/<mgc_axi4::WDATA> has a Z value
//    AXI4_WRITE_RESPONSE_WITHOUT_ADDR_DATA -  An unexpected write response has occurred (there are no outstanding write transactions with this id) 
//    AXI4_WSTRB_CHANGED_BEFORE_WREADY -  The value of <mgc_axi4::WSTRB> has changed from its initial value between the time <mgc_axi4::WVALID> was asserted, and before <mgc_axi4::WREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_WSTRB_UNKN -  <mgc_axi4::WSTRB> has an X value/<mgc_axi4::WSTRB> has an Z value
//    AXI4_WVALID_DEASSERTED_BEFORE_WREADY -  <mgc_axi4::WVALID> has been de-asserted before <mgc_axi4::WREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_WVALID_HIGH_ON_FIRST_CLOCK -  A master interface must begin driving <mgc_axi4::WVALID> high only at a rising clock edge after <mgc_axi4::ARESETn> is HIGH (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.1.2)
//    AXI4_WVALID_UNKN -  <mgc_axi4::WVALID> has an X value/<mgc_axi4::WVALID> has an Z value
//    MVC_FAILED_POSTCONDITION -  A postcondition failed
//    MVC_FAILED_RECOGNITION -  An item failed to be recognized  
//    AXI4_DEC_ERR_ILLEGAL_FOR_MAPPED_SLAVE_ADDR -  Slave receives a burst to a mapped address but responds with DECERR (signaled by <AXI4_DECERR>) (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.4)
//    AXI4_AWVALID_HIGH_DURING_RESET -  AWVALID asserted during the reset state (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.1.2)
//    AXI4_WVALID_HIGH_DURING_RESET -  WVALID asserted during the reset state (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.1.2)
//    AXI4_BVALID_HIGH_DURING_RESET -  BVALID asserted during the reset state (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.1.2)
//    AXI4_ARVALID_HIGH_DURING_RESET -  ARVALID asserted during the reset state (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.1.2)
//    AXI4_RVALID_HIGH_DURING_RESET -  RVALID asserted during the reset state (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.1.2)
//    AXI4_TIMEOUT_WAITING_FOR_WRITE_DATA -  Timed-out waiting for a data phase in write data burst (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.6)
//    AXI4_TIMEOUT_WAITING_FOR_WRITE_ADDR_AFTER_DATA -  Timed-out waiting for a write address phase to be coming after data see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2
//    AXI4_ARESETn_SIGNAL_Z -  AXI4 Reset signal has z value
//    AXI4_ARESETn_SIGNAL_X -  AXI4 Reset signal has x value
//    AXI4_ADDR_FOR_READ_BURST_ACROSS_4K_BOUNDARY -  This read transaction has crossed a 4KB boundary (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1) 
//    AXI4_ADDR_FOR_WRITE_BURST_ACROSS_4K_BOUNDARY -  This write transaction has crossed a 4KB boundary (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)
//    AXI4_ARADDR_FALLS_IN_REGION_HOLE -  The <mgc_axi4::ARADDR> value cannot be decoded to a region in the region map (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1)
//    AXI4_ARBURST_CHANGED_BEFORE_ARREADY -  The value of <mgc_axi4::ARBURST> has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARBURST_UNKN -  <mgc_axi4::ARBURST> has an X value/<mgc_axi4::ARBURST> has an Z value
//    AXI4_ARCACHE_CHANGED_BEFORE_ARREADY -  The value of <mgc_axi4::ARCACHE> has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARCACHE_UNKN -  <mgc_axi4::ARCACHE> has an X value/<mgc_axi4::ARCACHE> has an Z value
//    AXI4_ARID_CHANGED_BEFORE_ARREADY -  The value of <mgc_axi4::ARID> has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARID_UNKN -  <mgc_axi4::ARID> has an X value/<mgc_axi4::ARID> has an Z value
//    AXI4_ARLEN_CHANGED_BEFORE_ARREADY -   The value of <mgc_axi4::ARLEN> has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARLEN_UNKN -  <mgc_axi4::ARLEN> has an X value/<mgc_axi4::ARLEN> has an Z value
//    AXI4_ARLOCK_CHANGED_BEFORE_ARREADY -  The value of <mgc_axi4::ARLOCK> has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARLOCK_UNKN -  <mgc_axi4::ARLOCK> has an X value/<mgc_axi4::ARLOCK> has an Z value
//    AXI4_ARQOS_CHANGED_BEFORE_ARREADY -  The value of <mgc_axi4::ARQOS>  has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARQOS_UNKN -  <mgc_axi4::ARQOS>  has an X value/<mgc_axi4::ARQOS> has an Z value
//    AXI4_ARREGION_CHANGED_BEFORE_ARREADY -  The value of <mgc_axi4::ARREGION> has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARREGION_MISMATCH -  The <mgc_axi4::ARREGION> value does not match the value defined in the region map (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1)
//    AXI4_ARREGION_UNKN -  <mgc_axi4::ARREGION> has an X value/<mgc_axi4::ARREGION> has an Z value
//    AXI4_ARSIZE_CHANGED_BEFORE_ARREADY -  The value of <mgc_axi4::ARSIZE> has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARSIZE_UNKN -  <mgc_axi4::ARSIZE> has an X value/<mgc_axi4::ARSIZE> has an Z value
//    AXI4_ARUSER_CHANGED_BEFORE_ARREADY -  The value of <mgc_axi4::ARUSER> has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARUSER_UNKN -  <mgc_axi4::ARUSER> has an X value/<mgc_axi4::ARUSER> has an Z value
//    AXI4_AWADDR_FALLS_IN_REGION_HOLE -  The addr value cannot be decoded to a region in the region map (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1)
//    AXI4_AWBURST_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWBURST> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWBURST_UNKN -  <mgc_axi4::AWBURST> has an X value/<mgc_axi4::AWBURST> has an Z value
//    AXI4_AWCACHE_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWCACHE> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWCACHE_UNKN -  <mgc_axi4::AWCACHE> has an X value/AWCACHE has an Z value
//    AXI4_AWID_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWID> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWID_UNKN -  <mgc_axi4::AWID> has an X value/<mgc_axi4::AWID> has an Z value
//    AXI4_AWLEN_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWLEN> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWLEN_UNKN -  <mgc_axi4::AWLEN> has an X value/<mgc_axi4::AWLEN> has an Z value
//    AXI4_AWLOCK_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWLOCK> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWLOCK_UNKN -  <mgc_axi4::AWLOCK> has an X value/<mgc_axi4::AWLOCK> has an Z value
//    AXI4_AWQOS_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWQOS> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWQOS_UNKN -  <mgc_axi4::AWQOS> has an X value/<mgc_axi4::AWQOS> has an Z value
//    AXI4_AWREGION_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWREGION> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWREGION_MISMATCH -  The <mgc_axi4::AWREGION> value does not match the value defined in the region map (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1)
//    AXI4_AWREGION_UNKN -  <mgc_axi4::AWREGION> has an X value/<mgc_axi4::AWREGION> has an Z value
//    AXI4_AWSIZE_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWSIZE> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWSIZE_UNKN -  <mgc_axi4::AWSIZE> has an X value/<mgc_axi4::AWSIZE> has an Z value
//    AXI4_AWUSER_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWUSER> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWUSER_UNKN -  <mgc_axi4::AWUSER> has an X value/<mgc_axi4::AWUSER> has an Z value
//    AXI4_BID_CHANGED_BEFORE_BREADY -  The value of <mgc_axi4::BID> has changed from its initial value between the time <mgc_axi4::BVALID> was asserted, and before <mgc_axi4::BREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_BID_UNKN -  <mgc_axi4::BID> has an X value/<mgc_axi4::BID> has a Z value
//    AXI4_BUSER_CHANGED_BEFORE_BREADY -  The value of <mgc_axi4::BUSER> has changed from its initial value between the time <mgc_axi4::BVALID> was asserted, and before <mgc_axi4::BREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_BUSER_UNKN -  <mgc_axi4::BUSER> has an X value/<mgc_axi4::BUSER> has a Z value
//    AXI4_EXCLUSIVE_READ_ACCESS_MODIFIABLE -  The modifiable bit (bit 1 of the cache parameter) should not be set for an exclusive read access (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_READ_BYTES_TRANSFER_EXCEEDS_128 -  Number of bytes in an exclusive read transaction must be less than or equal to 128 (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_WRITE_BYTES_TRANSFER_EXCEEDS_128 -  Number of bytes in an exclusive write transaction must be less than or equal to 128 (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_READ_BYTES_TRANSFER_NOT_POWER_OF_2 -  Number of bytes of an exclusive read transaction is not a power of 2 (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_WRITE_BYTES_TRANSFER_NOT_POWER_OF_2 -  Number of bytes of an exclusive write transaction is not a power of 2 (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_READ_LENGTH_EXCEEDS_16 -  Exclusive read accesses are not permitted to use a burst length greater than 16 (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_WR_ADDRESS_NOT_SAME_AS_RD -  Exclusive write does not match the address of the previous exclusive read to this id (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_WR_BURST_NOT_SAME_AS_RD -  Exclusive write does not match the burst setting of the previous exclusive read to this id (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_WR_CACHE_NOT_SAME_AS_RD -  Exclusive write does not match the cache setting of the previous exclusive read to this id (see the ARM AXI4 compliance-checker AXI4_RECM_EXCL_MATCH assertion code)
//    AXI4_EXCLUSIVE_WRITE_ACCESS_MODIFIABLE -  The modifiable bit (bit 1 of the cache parameter) should not be set for an exclusive write access (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_WR_LENGTH_NOT_SAME_AS_RD -  Exclusive write does not match the length of the previous exclusive read to this id (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_WR_PROT_NOT_SAME_AS_RD -  Exclusive write does not match the prot setting of the previous exclusive read to this id (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_WR_REGION_NOT_SAME_AS_RD -  Exclusive write does not match the region setting of the previous exclusive read to this id (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_WR_SIZE_NOT_SAME_AS_RD -  Exclusive write does not match the size of the previous exclusive read to this id (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EX_RD_EXOKAY_RESP_EXPECTED_OKAY -  Expected <AXI4_OKAY> response to this exclusive read (because the parameters did not meet the the restrictions), but got <AXI4_EXOKAY> (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EX_RD_EXOKAY_RESP_SLAVE_WITHOUT_EXCLUSIVE_ACCESS -  Response for an exclusive read to a slave which does not support exclusive access should be <AXI4_OKAY>, but it returned <AXI4_EXOKAY> (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.5)
//    AXI4_EX_RD_OKAY_RESP_EXPECTED_EXOKAY -  Expected <AXI4_EXOKAY> response to this exclusive read (because the parameters met the restrictions), but got <AXI4_OKAY> (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EX_RD_WHEN_EX_NOT_ENABLED -  An exclusive read should not be issued when exclusive transactions are not enabled
//    AXI4_EX_WRITE_BEFORE_EX_READ_RESPONSE -  Exclusive write has occurred, with no previous exclusive read
//    AXI4_EX_WRITE_EXOKAY_RESP_EXPECTED_OKAY -  Exclusive write has not been successful, yet slave has responded with <AXI4_EXOKAY> (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.2)
//    AXI4_EX_WRITE_EXOKAY_RESP_SLAVE_WITHOUT_EXCLUSIVE_ACCESS -  Response for an exclusive write to a slave which does not support exclusive access should be <AXI4_OKAY>, but it returned <AXI4_EXOKAY> (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.5)
//    AXI4_EX_WRITE_OKAY_RESP_EXPECTED_EXOKAY -  An <AXI4_OKAY> response to an exclusive write occurred, but an <AXI4_EXOKAY> response had been expected (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.2). If the slave has multiple interfaces to the system, this check should be disabled, as it is possible for this response to occur as a result of activity on another port.
//    AXI4_EX_WR_WHEN_EX_NOT_ENABLED -  An exclusive write should not be issued when exclusive transactions are not enabled
//    AXI4_ILLEGAL_ARCACHE_VALUE_FOR_CACHEABLE_ADDRESS_REGION -  For a read from a cacheable address region, one of bits 2 or 3 of the cache parameter must be HIGH (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.5)
//    AXI4_ILLEGAL_ARCACHE_VALUE_FOR_NON_CACHEABLE_ADDRESS_REGION -  For a read from a non-cacheable address region, bits 2 and 3 of the cache parameter must be LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.5)
//    AXI4_ILLEGAL_AWCACHE_VALUE_FOR_CACHEABLE_ADDRESS_REGION -  For a write to a cacheable address region, one of bits 2 or 3 of the cache parameter must be HIGH (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.5)
//    AXI4_ILLEGAL_AWCACHE_VALUE_FOR_NON_CACHEABLE_ADDRESS_REGION -  For a write to a non-cacheable address region, bits 2 and 3 of the cache parameter must be LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.5)
//    AXI4_ILLEGAL_LENGTH_FIXED_READ_BURST -  In the last read address phase burst_length has an illegal value for a burst of type AXI4_FIXED (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)
//    AXI4_ILLEGAL_LENGTH_FIXED_WRITE_BURST -  In the last write address phase burst_length has an illegal value for a burst of type AXI4_FIXED (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1) 
//    AXI4_ILLEGAL_LENGTH_WRAPPING_READ_BURST -  In the last read address phase burst_length has an illegal value for a burst of type AXI4_WRAP (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)
//    AXI4_ILLEGAL_LENGTH_WRAPPING_WRITE_BURST -  In the last write address phase burst_length has an illegal value for a burst of type AXI4_WRAP (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)
//    AXI4_ILLEGAL_RESPONSE_EXCLUSIVE_READ -  Error response (<AXI4_SLVERR>/<AXI4_DECERR>) received for an exclusive read
//    AXI4_ILLEGAL_RESPONSE_EXCLUSIVE_WRITE -  Error response (<AXI4_SLVERR>/<AXI4_DECERR>) received for an exclusive write
//    AXI4_INVALID_REGION_CARDINALITY -  The configuration parameter <mgc_axi4::config_slave_regions> does not lie in the range 1-16, inclusive (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1).
//    AXI4_INVALID_WRITE_STROBES_ON_ALIGNED_WRITE_TRANSFER -  Write strobe(s) incorrect for address/size of an aligned transaction (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.3)
//    AXI4_NON_INCREASING_REGION_SPECIFICATION -  A region address-range has an upper bound smaller than the lower bound.
//    AXI4_NON_ZERO_ARQOS -  The master is configured to not participate in the Quality-of-Service scheme, but <mgc_axi4::ARQOS>  is not 4'b0000, as it should be (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.1.2)
//    AXI4_NON_ZERO_AWQOS -  The master is configured to not participate in the Quality-of-Service scheme, but <mgc_axi4::AWQOS> is not 4'b0000, as it should be (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.1.2)
//    AXI4_OVERLAPPING_REGION -  An address-range in the region map overlaps with another address in the region map (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1). 
//    AXI4_PARAM_READ_REORDERING_DEPTH_EQUALS_ZERO -  The user-supplied config_read_data_reordering_depth should be greater than zero (see AMBA AXI and ACE Protocol Specification IHI0022D section A5.3.1)
//    AXI4_PARAM_READ_REORDERING_DEPTH_EXCEEDS_MAX_ID -  The user-supplied config_read_data_reordering_depth exceeds the maximum possible value, as defined by the AXI4_ID_WIDTH parameter (see AMBA AXI and ACE Protocol Specification IHI0022D section A5.3.1)
//    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_12 -  The RA bit of the cache parameter should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_13 -  The RA bit of the cache parameter should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_4 -  The RA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_5 -  The RA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_8 -  The RA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_9 -  The RA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_READ_BURST_LENGTH_VIOLATION -  The burst_length implied by the number of beats actually read does not match the burst_length defined by the <axi4_master_read_addr_channel_phase>
//    AXI4_READ_BURST_MAXIMUM_LENGTH_VIOLATION -  256 read data beats were seen without <mgc_axi4::RLAST> (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)
//    AXI4_READ_BURST_SIZE_VIOLATION -  In this read transaction, size has been set too high for the defined data buswidth
//    AXI4_READ_EXCLUSIVE_ENCODING_VIOLATION -  A read-only interface does not support exclusive accesses (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.2.2)
//    AXI4_READ_REORDERING_VIOLATION -  The arrival of a read response has exceeded the read reordering depth (see AMBA AXI and ACE Protocol Specification IHI0022D section A5.3.1)
//    AXI4_READ_TRANSFER_EXCEEDS_ADDRESS_SPACE -  This read transfer runs off the edge of the address space defined by AXI4_ADDRESS_WIDTH (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.3.1)
//    AXI4_REGION_SMALLER_THAN_4KB -  An address-range in the region map is smaller than 4kB (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1)
//    AXI4_RESERVED_ARBURST_ENCODING -  The reserved encoding of 2'b11 should not be used for <mgc_axi4::ARBURST> (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)
//    AXI4_RESERVED_AWBURST_ENCODING -  The reserved encoding of 2'b11 should not be used for <mgc_axi4::AWBURST> (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)
//    AXI4_RID_CHANGED_BEFORE_RREADY -  The value of <mgc_axi4::RID> has changed from its initial value between the time <mgc_axi4::RVALID> was asserted, and before <mgc_axi4::RREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_RID_UNKN -  <mgc_axi4::RID> has an X value/<mgc_axi4::RID> has a Z value
//    AXI4_RLAST_CHANGED_BEFORE_RREADY -  The value of <mgc_axi4::RLAST> has changed from its initial value between the time <mgc_axi4::RVALID> was asserted, and before <mgc_axi4::RREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_RLAST_UNKN -  <mgc_axi4::RLAST> has an X value/<mgc_axi4::RLAST> has a Z value
//    AXI4_RUSER_CHANGED_BEFORE_RREADY -  The value of <mgc_axi4::RUSER> has changed from its initial value between the time <mgc_axi4::RVALID> was asserted, and before <mgc_axi4::RREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_RUSER_UNKN -  <mgc_axi4::RUSER> has an X value/<mgc_axi4::RUSER> has a Z value
//    AXI4_UNALIGNED_ADDRESS_FOR_EXCLUSIVE_READ -  Exclusive read accesses must have address aligned to the total number of bytes in the transaction (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_UNALIGNED_ADDRESS_FOR_EXCLUSIVE_WRITE -  Exclusive write accesses must have address aligned to the total number of bytes in the transaction (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_UNALIGNED_ADDR_FOR_WRAPPING_READ_BURST -  Wrapping bursts must have address aligned to the start of the read transfer (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)
//    AXI4_UNALIGNED_ADDR_FOR_WRAPPING_WRITE_BURST -  Wrapping bursts must have address aligned to the start of the write transfet (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)   
//    AXI4_WLAST_CHANGED_BEFORE_WREADY -  The value of <mgc_axi4::WLAST> has changed from its initial value between the time <mgc_axi4::WVALID> was asserted, and before <mgc_axi4::WREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_WLAST_UNKN -  <mgc_axi4::WLAST> has an X value/<mgc_axi4::WLAST> has an Z value
//    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_12 -  The WA bit of the cache parameter should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_13 -  The WA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_4 -  The WA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_5 -  The WA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_8 -  The WA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_9 -  The WA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_WRITE_BURST_LENGTH_VIOLATION -  The number of data beats in a write transfer should match the value given by <mgc_axi4::AWLEN>
//    AXI4_WRITE_STROBES_LENGTH_VIOLATION -  The size of the write_strobes array in a write transfer should match the value given by <mgc_axi4::AWLEN>
//    AXI4_WRITE_USER_DATA_LENGTH_VIOLATION -  The size of the wdata_user_data array in a write transfer should match the value given by <mgc_axi4::AWLEN>
//    AXI4_WRITE_BURST_MAXIMUM_LENGTH_VIOLATION -  256 write data beats were seen without <mgc_axi4::WLAST> (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1 )
//    AXI4_WRITE_BURST_SIZE_VIOLATION -  In this write transaction, size has been set too high for the defined data buswidth
//    AXI4_WRITE_EXCLUSIVE_ENCODING_VIOLATION -  A write-only interface does not support exclusive accesses (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.2.3)
//    AXI4_WRITE_STROBE_FIXED_BURST_VIOLATION -  Write strobe(s) incorrect for the address/size of a fixed transfer 
//    AXI4_WRITE_TRANSFER_EXCEEDS_ADDRESS_SPACE -  This write transfer runs off the edge of the address space defined by <mgc_axi4::AXI4_ADDRESS_WIDTH> (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.3.1)
//    AXI4_WRONG_ARREGION_FOR_SLAVE_WITH_SINGLE_ADDRESS_DECODE -  The region value should be 4'b0000 for a read from a slave with a single address decode in the region map (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1)
//    AXI4_WRONG_AWREGION_FOR_SLAVE_WITH_SINGLE_ADDRESS_DECODE -  The region value should be 4'b0000 for a write to a slave with a single address decode in the region map (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1) 
//    AXI4_WUSER_CHANGED_BEFORE_WREADY -  The value of <mgc_axi4::WUSER> has changed from its initial value between the time <mgc_axi4::WVALID> was asserted, and before <mgc_axi4::WREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_WUSER_UNKN -  <mgc_axi4::WUSER> has an X value/<mgc_axi4::WUSER> has an Z value
//    AXI4_EXCL_RD_WHILE_EXCL_WR_IN_PROGRESS_SAME_ID -  Master starts an exclusive read burst while exclusive write burst with same ID tag is in progress (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCL_WR_WHILE_EXCL_RD_IN_PROGRESS_SAME_ID -  Master starts an exclusive write burst while exclusive read burst with same ID tag is in progress (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_RLAST_VIOLATION -  RLAST signal should be asserted along with the final transfer of the read data burst (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)
//    AXI4_WLAST_ASSERTED_DURING_DATA_PHASE_OTHER_THAN_LAST -  Wlast must only be asserted during the last data phase (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)
typedef enum bit [7:0]
{
    AXI4_ADDRESS_WIDTH_EXCEEDS_64                               = 8'h00,
    AXI4_ARADDR_CHANGED_BEFORE_ARREADY                          = 8'h01,
    AXI4_ARADDR_UNKN                                            = 8'h02,
    AXI4_ARPROT_CHANGED_BEFORE_ARREADY                          = 8'h03,
    AXI4_ARPROT_UNKN                                            = 8'h04,
    AXI4_ARREADY_NOT_ASSERTED_AFTER_ARVALID                     = 8'h05,
    AXI4_ARREADY_UNKN                                           = 8'h06,
    AXI4_ARVALID_DEASSERTED_BEFORE_ARREADY                      = 8'h07,
    AXI4_ARVALID_HIGH_ON_FIRST_CLOCK                            = 8'h08,
    AXI4_ARVALID_UNKN                                           = 8'h09,
    AXI4_AWADDR_CHANGED_BEFORE_AWREADY                          = 8'h0a,
    AXI4_AWADDR_UNKN                                            = 8'h0b,
    AXI4_AWPROT_CHANGED_BEFORE_AWREADY                          = 8'h0c,
    AXI4_AWPROT_UNKN                                            = 8'h0d,
    AXI4_AWREADY_NOT_ASSERTED_AFTER_AWVALID                     = 8'h0e,
    AXI4_AWREADY_UNKN                                           = 8'h0f,
    AXI4_AWVALID_DEASSERTED_BEFORE_AWREADY                      = 8'h10,
    AXI4_AWVALID_HIGH_ON_FIRST_CLOCK                            = 8'h11,
    AXI4_AWVALID_UNKN                                           = 8'h12,
    AXI4_BREADY_NOT_ASSERTED_AFTER_BVALID                       = 8'h13,
    AXI4_BREADY_UNKN                                            = 8'h14,
    AXI4_BRESP_CHANGED_BEFORE_BREADY                            = 8'h15,
    AXI4_BRESP_UNKN                                             = 8'h16,
    AXI4_BVALID_DEASSERTED_BEFORE_BREADY                        = 8'h17,
    AXI4_BVALID_HIGH_EXITING_RESET                              = 8'h18,
    AXI4_BVALID_UNKN                                            = 8'h19,
    AXI4_DEC_ERR_RESP_FOR_READ                                  = 8'h1a,
    AXI4_DEC_ERR_RESP_FOR_WRITE                                 = 8'h1b,
    AXI4_EXOKAY_RESPONSE_NORMAL_READ                            = 8'h1c,
    AXI4_EXOKAY_RESPONSE_NORMAL_WRITE                           = 8'h1d,
    AXI4_INVALID_WRITE_STROBES_ON_UNALIGNED_WRITE_TRANSFER      = 8'h1e,
    AXI4_MINIMUM_SLAVE_ADDRESS_SPACE_VIOLATION                  = 8'h1f,
    AXI4_PARAM_READ_DATA_BUS_WIDTH                              = 8'h20,
    AXI4_PARAM_WRITE_DATA_BUS_WIDTH                             = 8'h21,
    AXI4_READ_DATA_BEFORE_ADDRESS                               = 8'h22,
    AXI4_READ_DATA_CHANGED_BEFORE_RREADY                        = 8'h23,
    AXI4_READ_DATA_UNKN                                         = 8'h24,
    AXI4_READ_RESP_CHANGED_BEFORE_RREADY                        = 8'h25,
    AXI4_RREADY_NOT_ASSERTED_AFTER_RVALID                       = 8'h26,
    AXI4_RREADY_UNKN                                            = 8'h27,
    AXI4_RRESP_UNKN                                             = 8'h28,
    AXI4_RVALID_DEASSERTED_BEFORE_RREADY                        = 8'h29,
    AXI4_RVALID_HIGH_EXITING_RESET                              = 8'h2a,
    AXI4_RVALID_UNKN                                            = 8'h2b,
    AXI4_SLV_ERR_RESP_FOR_READ                                  = 8'h2c,
    AXI4_SLV_ERR_RESP_FOR_WRITE                                 = 8'h2d,
    AXI4_TIMEOUT_WAITING_FOR_READ_RESPONSE                      = 8'h2e,
    AXI4_TIMEOUT_WAITING_FOR_WRITE_RESPONSE                     = 8'h2f,
    AXI4_WDATA_CHANGED_BEFORE_WREADY_ON_INVALID_LANE            = 8'h30,
    AXI4_WDATA_CHANGED_BEFORE_WREADY_ON_VALID_LANE              = 8'h31,
    AXI4_WREADY_NOT_ASSERTED_AFTER_WVALID                       = 8'h32,
    AXI4_WREADY_UNKN                                            = 8'h33,
    AXI4_WRITE_DATA_BEFORE_ADDRESS                              = 8'h34,
    AXI4_WRITE_DATA_UNKN_ON_INVALID_LANE                        = 8'h35,
    AXI4_WRITE_DATA_UNKN_ON_VALID_LANE                          = 8'h36,
    AXI4_WRITE_RESPONSE_WITHOUT_ADDR_DATA                       = 8'h37,
    AXI4_WSTRB_CHANGED_BEFORE_WREADY                            = 8'h38,
    AXI4_WSTRB_UNKN                                             = 8'h39,
    AXI4_WVALID_DEASSERTED_BEFORE_WREADY                        = 8'h3a,
    AXI4_WVALID_HIGH_ON_FIRST_CLOCK                             = 8'h3b,
    AXI4_WVALID_UNKN                                            = 8'h3c,
    MVC_FAILED_POSTCONDITION                                    = 8'h3d,
    MVC_FAILED_RECOGNITION                                      = 8'h3e,
    AXI4_DEC_ERR_ILLEGAL_FOR_MAPPED_SLAVE_ADDR                  = 8'h3f,
    AXI4_AWVALID_HIGH_DURING_RESET                              = 8'h40,
    AXI4_WVALID_HIGH_DURING_RESET                               = 8'h41,
    AXI4_BVALID_HIGH_DURING_RESET                               = 8'h42,
    AXI4_ARVALID_HIGH_DURING_RESET                              = 8'h43,
    AXI4_RVALID_HIGH_DURING_RESET                               = 8'h44,
    AXI4_TIMEOUT_WAITING_FOR_WRITE_DATA                         = 8'h45,
    AXI4_TIMEOUT_WAITING_FOR_WRITE_ADDR_AFTER_DATA              = 8'h46,
    AXI4_ARESETn_SIGNAL_Z                                       = 8'h47,
    AXI4_ARESETn_SIGNAL_X                                       = 8'h48,
    AXI4_ADDR_FOR_READ_BURST_ACROSS_4K_BOUNDARY                 = 8'h49,
    AXI4_ADDR_FOR_WRITE_BURST_ACROSS_4K_BOUNDARY                = 8'h4a,
    AXI4_ARADDR_FALLS_IN_REGION_HOLE                            = 8'h4b,
    AXI4_ARBURST_CHANGED_BEFORE_ARREADY                         = 8'h4c,
    AXI4_ARBURST_UNKN                                           = 8'h4d,
    AXI4_ARCACHE_CHANGED_BEFORE_ARREADY                         = 8'h4e,
    AXI4_ARCACHE_UNKN                                           = 8'h4f,
    AXI4_ARID_CHANGED_BEFORE_ARREADY                            = 8'h50,
    AXI4_ARID_UNKN                                              = 8'h51,
    AXI4_ARLEN_CHANGED_BEFORE_ARREADY                           = 8'h52,
    AXI4_ARLEN_UNKN                                             = 8'h53,
    AXI4_ARLOCK_CHANGED_BEFORE_ARREADY                          = 8'h54,
    AXI4_ARLOCK_UNKN                                            = 8'h55,
    AXI4_ARQOS_CHANGED_BEFORE_ARREADY                           = 8'h56,
    AXI4_ARQOS_UNKN                                             = 8'h57,
    AXI4_ARREGION_CHANGED_BEFORE_ARREADY                        = 8'h58,
    AXI4_ARREGION_MISMATCH                                      = 8'h59,
    AXI4_ARREGION_UNKN                                          = 8'h5a,
    AXI4_ARSIZE_CHANGED_BEFORE_ARREADY                          = 8'h5b,
    AXI4_ARSIZE_UNKN                                            = 8'h5c,
    AXI4_ARUSER_CHANGED_BEFORE_ARREADY                          = 8'h5d,
    AXI4_ARUSER_UNKN                                            = 8'h5e,
    AXI4_AWADDR_FALLS_IN_REGION_HOLE                            = 8'h5f,
    AXI4_AWBURST_CHANGED_BEFORE_AWREADY                         = 8'h60,
    AXI4_AWBURST_UNKN                                           = 8'h61,
    AXI4_AWCACHE_CHANGED_BEFORE_AWREADY                         = 8'h62,
    AXI4_AWCACHE_UNKN                                           = 8'h63,
    AXI4_AWID_CHANGED_BEFORE_AWREADY                            = 8'h64,
    AXI4_AWID_UNKN                                              = 8'h65,
    AXI4_AWLEN_CHANGED_BEFORE_AWREADY                           = 8'h66,
    AXI4_AWLEN_UNKN                                             = 8'h67,
    AXI4_AWLOCK_CHANGED_BEFORE_AWREADY                          = 8'h68,
    AXI4_AWLOCK_UNKN                                            = 8'h69,
    AXI4_AWQOS_CHANGED_BEFORE_AWREADY                           = 8'h6a,
    AXI4_AWQOS_UNKN                                             = 8'h6b,
    AXI4_AWREGION_CHANGED_BEFORE_AWREADY                        = 8'h6c,
    AXI4_AWREGION_MISMATCH                                      = 8'h6d,
    AXI4_AWREGION_UNKN                                          = 8'h6e,
    AXI4_AWSIZE_CHANGED_BEFORE_AWREADY                          = 8'h6f,
    AXI4_AWSIZE_UNKN                                            = 8'h70,
    AXI4_AWUSER_CHANGED_BEFORE_AWREADY                          = 8'h71,
    AXI4_AWUSER_UNKN                                            = 8'h72,
    AXI4_BID_CHANGED_BEFORE_BREADY                              = 8'h73,
    AXI4_BID_UNKN                                               = 8'h74,
    AXI4_BUSER_CHANGED_BEFORE_BREADY                            = 8'h75,
    AXI4_BUSER_UNKN                                             = 8'h76,
    AXI4_EXCLUSIVE_READ_ACCESS_MODIFIABLE                       = 8'h77,
    AXI4_EXCLUSIVE_READ_BYTES_TRANSFER_EXCEEDS_128              = 8'h78,
    AXI4_EXCLUSIVE_WRITE_BYTES_TRANSFER_EXCEEDS_128             = 8'h79,
    AXI4_EXCLUSIVE_READ_BYTES_TRANSFER_NOT_POWER_OF_2           = 8'h7a,
    AXI4_EXCLUSIVE_WRITE_BYTES_TRANSFER_NOT_POWER_OF_2          = 8'h7b,
    AXI4_EXCLUSIVE_READ_LENGTH_EXCEEDS_16                       = 8'h7c,
    AXI4_EXCLUSIVE_WR_ADDRESS_NOT_SAME_AS_RD                    = 8'h7d,
    AXI4_EXCLUSIVE_WR_BURST_NOT_SAME_AS_RD                      = 8'h7e,
    AXI4_EXCLUSIVE_WR_CACHE_NOT_SAME_AS_RD                      = 8'h7f,
    AXI4_EXCLUSIVE_WRITE_ACCESS_MODIFIABLE                      = 8'h80,
    AXI4_EXCLUSIVE_WR_LENGTH_NOT_SAME_AS_RD                     = 8'h81,
    AXI4_EXCLUSIVE_WR_PROT_NOT_SAME_AS_RD                       = 8'h82,
    AXI4_EXCLUSIVE_WR_REGION_NOT_SAME_AS_RD                     = 8'h83,
    AXI4_EXCLUSIVE_WR_SIZE_NOT_SAME_AS_RD                       = 8'h84,
    AXI4_EX_RD_EXOKAY_RESP_EXPECTED_OKAY                        = 8'h85,
    AXI4_EX_RD_EXOKAY_RESP_SLAVE_WITHOUT_EXCLUSIVE_ACCESS       = 8'h86,
    AXI4_EX_RD_OKAY_RESP_EXPECTED_EXOKAY                        = 8'h87,
    AXI4_EX_RD_WHEN_EX_NOT_ENABLED                              = 8'h88,
    AXI4_EX_WRITE_BEFORE_EX_READ_RESPONSE                       = 8'h89,
    AXI4_EX_WRITE_EXOKAY_RESP_EXPECTED_OKAY                     = 8'h8a,
    AXI4_EX_WRITE_EXOKAY_RESP_SLAVE_WITHOUT_EXCLUSIVE_ACCESS    = 8'h8b,
    AXI4_EX_WRITE_OKAY_RESP_EXPECTED_EXOKAY                     = 8'h8c,
    AXI4_EX_WR_WHEN_EX_NOT_ENABLED                              = 8'h8d,
    AXI4_ILLEGAL_ARCACHE_VALUE_FOR_CACHEABLE_ADDRESS_REGION     = 8'h8e,
    AXI4_ILLEGAL_ARCACHE_VALUE_FOR_NON_CACHEABLE_ADDRESS_REGION = 8'h8f,
    AXI4_ILLEGAL_AWCACHE_VALUE_FOR_CACHEABLE_ADDRESS_REGION     = 8'h90,
    AXI4_ILLEGAL_AWCACHE_VALUE_FOR_NON_CACHEABLE_ADDRESS_REGION = 8'h91,
    AXI4_ILLEGAL_LENGTH_FIXED_READ_BURST                        = 8'h92,
    AXI4_ILLEGAL_LENGTH_FIXED_WRITE_BURST                       = 8'h93,
    AXI4_ILLEGAL_LENGTH_WRAPPING_READ_BURST                     = 8'h94,
    AXI4_ILLEGAL_LENGTH_WRAPPING_WRITE_BURST                    = 8'h95,
    AXI4_ILLEGAL_RESPONSE_EXCLUSIVE_READ                        = 8'h96,
    AXI4_ILLEGAL_RESPONSE_EXCLUSIVE_WRITE                       = 8'h97,
    AXI4_INVALID_REGION_CARDINALITY                             = 8'h98,
    AXI4_INVALID_WRITE_STROBES_ON_ALIGNED_WRITE_TRANSFER        = 8'h99,
    AXI4_NON_INCREASING_REGION_SPECIFICATION                    = 8'h9a,
    AXI4_NON_ZERO_ARQOS                                         = 8'h9b,
    AXI4_NON_ZERO_AWQOS                                         = 8'h9c,
    AXI4_OVERLAPPING_REGION                                     = 8'h9d,
    AXI4_PARAM_READ_REORDERING_DEPTH_EQUALS_ZERO                = 8'h9e,
    AXI4_PARAM_READ_REORDERING_DEPTH_EXCEEDS_MAX_ID             = 8'h9f,
    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_12                   = 8'ha0,
    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_13                   = 8'ha1,
    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_4                    = 8'ha2,
    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_5                    = 8'ha3,
    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_8                    = 8'ha4,
    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_9                    = 8'ha5,
    AXI4_READ_BURST_LENGTH_VIOLATION                            = 8'ha6,
    AXI4_READ_BURST_MAXIMUM_LENGTH_VIOLATION                    = 8'ha7,
    AXI4_READ_BURST_SIZE_VIOLATION                              = 8'ha8,
    AXI4_READ_EXCLUSIVE_ENCODING_VIOLATION                      = 8'ha9,
    AXI4_READ_REORDERING_VIOLATION                              = 8'haa,
    AXI4_READ_TRANSFER_EXCEEDS_ADDRESS_SPACE                    = 8'hab,
    AXI4_REGION_SMALLER_THAN_4KB                                = 8'hac,
    AXI4_RESERVED_ARBURST_ENCODING                              = 8'had,
    AXI4_RESERVED_AWBURST_ENCODING                              = 8'hae,
    AXI4_RID_CHANGED_BEFORE_RREADY                              = 8'haf,
    AXI4_RID_UNKN                                               = 8'hb0,
    AXI4_RLAST_CHANGED_BEFORE_RREADY                            = 8'hb1,
    AXI4_RLAST_UNKN                                             = 8'hb2,
    AXI4_RUSER_CHANGED_BEFORE_RREADY                            = 8'hb3,
    AXI4_RUSER_UNKN                                             = 8'hb4,
    AXI4_UNALIGNED_ADDRESS_FOR_EXCLUSIVE_READ                   = 8'hb5,
    AXI4_UNALIGNED_ADDRESS_FOR_EXCLUSIVE_WRITE                  = 8'hb6,
    AXI4_UNALIGNED_ADDR_FOR_WRAPPING_READ_BURST                 = 8'hb7,
    AXI4_UNALIGNED_ADDR_FOR_WRAPPING_WRITE_BURST                = 8'hb8,
    AXI4_WLAST_CHANGED_BEFORE_WREADY                            = 8'hb9,
    AXI4_WLAST_UNKN                                             = 8'hba,
    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_12                  = 8'hbb,
    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_13                  = 8'hbc,
    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_4                   = 8'hbd,
    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_5                   = 8'hbe,
    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_8                   = 8'hbf,
    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_9                   = 8'hc0,
    AXI4_WRITE_BURST_LENGTH_VIOLATION                           = 8'hc1,
    AXI4_WRITE_STROBES_LENGTH_VIOLATION                         = 8'hc2,
    AXI4_WRITE_USER_DATA_LENGTH_VIOLATION                       = 8'hc3,
    AXI4_WRITE_BURST_MAXIMUM_LENGTH_VIOLATION                   = 8'hc4,
    AXI4_WRITE_BURST_SIZE_VIOLATION                             = 8'hc5,
    AXI4_WRITE_EXCLUSIVE_ENCODING_VIOLATION                     = 8'hc6,
    AXI4_WRITE_STROBE_FIXED_BURST_VIOLATION                     = 8'hc7,
    AXI4_WRITE_TRANSFER_EXCEEDS_ADDRESS_SPACE                   = 8'hc8,
    AXI4_WRONG_ARREGION_FOR_SLAVE_WITH_SINGLE_ADDRESS_DECODE    = 8'hc9,
    AXI4_WRONG_AWREGION_FOR_SLAVE_WITH_SINGLE_ADDRESS_DECODE    = 8'hca,
    AXI4_WUSER_CHANGED_BEFORE_WREADY                            = 8'hcb,
    AXI4_WUSER_UNKN                                             = 8'hcc,
    AXI4_EXCL_RD_WHILE_EXCL_WR_IN_PROGRESS_SAME_ID              = 8'hcd,
    AXI4_EXCL_WR_WHILE_EXCL_RD_IN_PROGRESS_SAME_ID              = 8'hce,
    AXI4_RLAST_VIOLATION                                        = 8'hcf,
    AXI4_WLAST_ASSERTED_DURING_DATA_PHASE_OTHER_THAN_LAST       = 8'hd0
} axi4_error_e;


typedef bit [1023:0] axi4_max_bits_t;

// enum: axi4_config_e
//
// An enum which fields corresponding to each configuration parameter of the VIP
//    AXI4_CONFIG_INTERFACE_TYPE - 
//          A configuration parameter (of type <axi4_interface_type_e>) defining the interface category: read/write, read only or write only (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.2).
//         
//         The value defaults to <AXI4_READWRITE>.
//         
//    AXI4_CONFIG_SETUP_TIME - 
//          The setup-time, in units of simulator time-steps, for all signals. By default this is set to 0. Users should use the
//         <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
//         See <Configuration of Time-Units> for background on configuration of time-units.
//         
//    AXI4_CONFIG_HOLD_TIME - 
//          The hold-time, in units of simulator time-steps, for all signals. By default this is set to 0. Users should use the
//         <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
//         See <Configuration of Time-Units> for background on configuration of time-units.
//         
//    AXI4_CONFIG_BURST_TIMEOUT_FACTOR - 
//          The maximum number of clock-periods between phases.
//         
//         This causes a timeout when an unreasonable time passes between transaction phases. It defaults to 10000 clock periods.
//         
//    AXI4_CONFIG_ENABLE_RLAST - 
//          A configuration parameter controlling whether the optional <RLAST> signal is used, or not.
//         
//         <RLAST> is an optional input to the master, because the length of a read burst is always known (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.3.5).
//         
//    AXI4_CONFIG_ENABLE_SLAVE_EXCLUSIVE - 
//          A configuration parameter controlling whether the slave supports exclusive accesses. (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.5)
//         
//         By default this is set to true so that the slave will support exclusive accesses by responding with <AXI4_EXOKAY>.
//         
//         The coverage collected by the covergroup <axi4_coverage::axi4_cvg> is affected by this parameter value setting.
//         
//    AXI4_CONFIG_AXI4LITE_axi4 - 
//          If user want to use QVIP BFM on the axi4lite interface, then this
//          configuration variable should be set to true.
//         
//    AXI4_CONFIG_AXI4LITE_TR_ID - 
//          Configuration variable to set ID to a fixed value when QVIP BFM is configured as axi4lite
//         
//    AXI4_CONFIG_ENABLE_ALL_ASSERTIONS - 
//          Configuration parameter controlling whether the error messages(Assertions) issued from the QVIP are Enabled or Disabled.  
//              By default, it is enabled.
//           
//    AXI4_CONFIG_ENABLE_ASSERTION - 
//          An array of configuration parameters controlling whether specific error messages(Assertion) can be issued by the QVIP.
//              By default, all errors are enabled. 
//              To suppress a particular error, set the corresponding bit to 0 (false).
//           
//    AXI4_CONFIG_MAX_LATENCY_AWVALID_ASSERTION_TO_AWREADY - 
//          A configuration parameter defining the timeout (in clock periods) from the assertion of <AWVALID> to the assertion of <AWREADY> (default 10000).
//         
//         The error message <AXI4_AWREADY_NOT_ASSERTED_AFTER_AWVALID> will be issued if this period elapses from the assertion of <AWVALID>.
//         
//    AXI4_CONFIG_MAX_LATENCY_ARVALID_ASSERTION_TO_ARREADY - 
//          A configuration parameter defining the timeout (in clock periods) from the assertion of <ARVALID> to the assertion of <ARREADY> (default 10000).
//         
//         The error message <AXI4_ARREADY_NOT_ASSERTED_AFTER_ARVALID> will be issued if this period elapses from the assertion of <ARVALID>.
//         
//    AXI4_CONFIG_MAX_LATENCY_RVALID_ASSERTION_TO_RREADY - 
//          A configuration parameter defining the timeout (in clock periods) from the assertion of <RVALID> to the assertion of <RREADY> (default 10000).
//         
//         The error message <AXI4_RREADY_NOT_ASSERTED_AFTER_RVALID> will be issued if this period elapses from the assertion of <RVALID>.
//         
//    AXI4_CONFIG_MAX_LATENCY_BVALID_ASSERTION_TO_BREADY - 
//          A configuration parameter defining the timeout (in clock periods) from the assertion of <BVALID> to the assertion of <BREADY> (default 10000).
//         
//         The error message <AXI4_BREADY_NOT_ASSERTED_AFTER_BVALID> will be issued if this period elapses from the assertion of <BVALID>.
//         
//    AXI4_CONFIG_MAX_LATENCY_WVALID_ASSERTION_TO_WREADY - 
//          A configuration parameter defining the timeout (in clock periods) from the assertion of <WVALID> to the assertion of <WREADY> (default 10000).
//         
//         The error message <AXI4_WREADY_NOT_ASSERTED_AFTER_WVALID> will be issued if this period elapses from the assertion of <WVALID>.
//         
//    AXI4_CONFIG_ENABLE_QOS - 
//          A configuration parameter defining whether the master participates in the Quality-of-Service scheme  (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.1.2). 
//         
//         This defaults to 'true' i.e. the master participates in the Quality-of-Service scheme. If a master does not participate, the <AWQOS>/<ARQOS> value used in write/read transactions must be b0000.
//         
//    AXI4_CONFIG_READ_DATA_REORDERING_DEPTH - 
//          A configuration parameter defining the read reordering depth of the slave end of the interface (see AMBA AXI and ACE Protocol Specification IHI0022D section A5.3.1).
//         
//         Responses from the first <config_read_data_reordering_depth> outstanding read transactions, each with address <ARID> values different from any
//          earlier outstanding read transaction(as seen by the slave) are expected, interleaved at random. A violation causes a <AXI4_READ_REORDERING_VIOLATION> error.
//         
//         The default value of <config_read_data_reordering_depth> is (1 << AXI4_ID_WIDTH), so that the slave is expected to process all transactions in any order (up to uniqueness of <ARID>).
//         
//         For a given <AXI4_ID_WIDTH> parameter value, the maximum possible value of <config_read_data_reordering_depth> is 2**AXI4_ID_WIDTH. The <AXI4_PARAM_READ_REORDERING_DEPTH_EXCEEDS_MAX_ID>
//          error report will be issued if <config_read_data_reordering_depth> exceeds this value.
//         
//         If the user-supplied value is 0, the <AXI4_PARAM_READ_REORDERING_DEPTH_EQUALS_ZERO> error will be issued, and the value will be set to 1.
//         
//    AXI4_CONFIG_SLAVE_START_ADDR - 
//          A configuration parameter indicating start address for slave.
//         
//    AXI4_CONFIG_SLAVE_END_ADDR - 
//          A configuration parameter indicating end address for slave.
//         
//    AXI4_AXI4_MAX_SW_MULTIPLE - 
//         **************************************************************************************
//          *
//          * Copyright 2007-2013 Mentor Graphics Corporation
//          * All Rights Reserved.
//          *
//          * THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION WHICH IS THE PROPERTY OF 
//          * MENTOR GRAPHICS CORPORATION OR ITS LICENSORS AND IS SUBJECT TO LICENSE TERMS.
//          *
//          **************************************************************************************

typedef enum bit [7:0]
{
    AXI4_CONFIG_INTERFACE_TYPE               = 8'd0,
    AXI4_CONFIG_SETUP_TIME                   = 8'd1,
    AXI4_CONFIG_HOLD_TIME                    = 8'd2,
    AXI4_CONFIG_BURST_TIMEOUT_FACTOR         = 8'd3,
    AXI4_CONFIG_MAX_TRANSACTION_TIME_FACTOR  = 8'd4,
    AXI4_CONFIG_ENABLE_RLAST                 = 8'd5,
    AXI4_CONFIG_ENABLE_SLAVE_EXCLUSIVE       = 8'd6,
    AXI4_CONFIG_AXI4LITE_axi4           = 8'd7,
    AXI4_CONFIG_AXI4LITE_TR_ID               = 8'd8,
    AXI4_CONFIG_ENABLE_ALL_ASSERTIONS        = 8'd9,
    AXI4_CONFIG_ENABLE_ASSERTION             = 8'd10,
    AXI4_CONFIG_MAX_LATENCY_AWVALID_ASSERTION_TO_AWREADY = 8'd11,
    AXI4_CONFIG_MAX_LATENCY_ARVALID_ASSERTION_TO_ARREADY = 8'd12,
    AXI4_CONFIG_MAX_LATENCY_RVALID_ASSERTION_TO_RREADY = 8'd13,
    AXI4_CONFIG_MAX_LATENCY_BVALID_ASSERTION_TO_BREADY = 8'd14,
    AXI4_CONFIG_MAX_LATENCY_WVALID_ASSERTION_TO_WREADY = 8'd15,
    AXI4_CONFIG_ENABLE_QOS                   = 8'd16,
    AXI4_CONFIG_READ_DATA_REORDERING_DEPTH   = 8'd17,
    AXI4_CONFIG_SLAVE_START_ADDR             = 8'd18,
    AXI4_CONFIG_SLAVE_END_ADDR               = 8'd19,
    AXI4_CONFIG_MAX_OUTSTANDING_WR           = 8'd20,
    AXI4_CONFIG_MAX_OUTSTANDING_RD           = 8'd21,
    AXI4_CONFIG_NUM_OUTSTANDING_WR_PHASE     = 8'd22,
    AXI4_CONFIG_NUM_OUTSTANDING_RD_PHASE     = 8'd23,
    AXI4_AXI4_MAX_SW_MULTIPLE                = 8'd24
} axi4_config_e;

// enum: axi4_vhd_if_e
//
// For VHDL use only
typedef enum int
{
    AXI4_VHD_SET_CONFIG                         = 32'd0,
    AXI4_VHD_GET_CONFIG                         = 32'd1,
    AXI4_VHD_CREATE_WRITE_TRANSACTION           = 32'd2,
    AXI4_VHD_CREATE_READ_TRANSACTION            = 32'd3,
    AXI4_VHD_SET_READ_OR_WRITE                  = 32'd4,
    AXI4_VHD_GET_READ_OR_WRITE                  = 32'd5,
    AXI4_VHD_SET_ADDR                           = 32'd6,
    AXI4_VHD_GET_ADDR                           = 32'd7,
    AXI4_VHD_SET_PROT                           = 32'd8,
    AXI4_VHD_GET_PROT                           = 32'd9,
    AXI4_VHD_SET_REGION                         = 32'd10,
    AXI4_VHD_GET_REGION                         = 32'd11,
    AXI4_VHD_SET_SIZE                           = 32'd12,
    AXI4_VHD_GET_SIZE                           = 32'd13,
    AXI4_VHD_SET_BURST                          = 32'd14,
    AXI4_VHD_GET_BURST                          = 32'd15,
    AXI4_VHD_SET_LOCK                           = 32'd16,
    AXI4_VHD_GET_LOCK                           = 32'd17,
    AXI4_VHD_SET_CACHE                          = 32'd18,
    AXI4_VHD_GET_CACHE                          = 32'd19,
    AXI4_VHD_SET_QOS                            = 32'd20,
    AXI4_VHD_GET_QOS                            = 32'd21,
    AXI4_VHD_SET_ID                             = 32'd22,
    AXI4_VHD_GET_ID                             = 32'd23,
    AXI4_VHD_SET_BURST_LENGTH                   = 32'd24,
    AXI4_VHD_GET_BURST_LENGTH                   = 32'd25,
    AXI4_VHD_SET_ADDR_USER                      = 32'd26,
    AXI4_VHD_GET_ADDR_USER                      = 32'd27,
    AXI4_VHD_SET_DATA_WORDS                     = 32'd28,
    AXI4_VHD_GET_DATA_WORDS                     = 32'd29,
    AXI4_VHD_SET_WRITE_STROBES                  = 32'd30,
    AXI4_VHD_GET_WRITE_STROBES                  = 32'd31,
    AXI4_VHD_SET_RESP                           = 32'd32,
    AXI4_VHD_GET_RESP                           = 32'd33,
    AXI4_VHD_SET_ADDRESS_VALID_DELAY            = 32'd34,
    AXI4_VHD_GET_ADDRESS_VALID_DELAY            = 32'd35,
    AXI4_VHD_SET_DATA_VALID_DELAY               = 32'd36,
    AXI4_VHD_GET_DATA_VALID_DELAY               = 32'd37,
    AXI4_VHD_SET_WRITE_RESPONSE_VALID_DELAY     = 32'd38,
    AXI4_VHD_GET_WRITE_RESPONSE_VALID_DELAY     = 32'd39,
    AXI4_VHD_SET_ADDRESS_READY_DELAY            = 32'd40,
    AXI4_VHD_GET_ADDRESS_READY_DELAY            = 32'd41,
    AXI4_VHD_SET_DATA_READY_DELAY               = 32'd42,
    AXI4_VHD_GET_DATA_READY_DELAY               = 32'd43,
    AXI4_VHD_SET_WRITE_RESPONSE_READY_DELAY     = 32'd44,
    AXI4_VHD_GET_WRITE_RESPONSE_READY_DELAY     = 32'd45,
    AXI4_VHD_SET_GEN_WRITE_STROBES              = 32'd46,
    AXI4_VHD_GET_GEN_WRITE_STROBES              = 32'd47,
    AXI4_VHD_SET_OPERATION_MODE                 = 32'd48,
    AXI4_VHD_GET_OPERATION_MODE                 = 32'd49,
    AXI4_VHD_SET_WRITE_DATA_MODE                = 32'd50,
    AXI4_VHD_GET_WRITE_DATA_MODE                = 32'd51,
    AXI4_VHD_SET_DATA_BEAT_DONE                 = 32'd52,
    AXI4_VHD_GET_DATA_BEAT_DONE                 = 32'd53,
    AXI4_VHD_SET_TRANSACTION_DONE               = 32'd54,
    AXI4_VHD_GET_TRANSACTION_DONE               = 32'd55,
    AXI4_VHD_EXECUTE_TRANSACTION                = 32'd56,
    AXI4_VHD_GET_RW_TRANSACTION                 = 32'd57,
    AXI4_VHD_EXECUTE_WRITE_DATA_BURST           = 32'd58,
    AXI4_VHD_GET_WRITE_DATA_BURST               = 32'd59,
    AXI4_VHD_EXECUTE_READ_ADDR_PHASE            = 32'd60,
    AXI4_VHD_GET_READ_ADDR_PHASE                = 32'd61,
    AXI4_VHD_EXECUTE_READ_DATA_BURST            = 32'd62,
    AXI4_VHD_GET_READ_DATA_BURST                = 32'd63,
    AXI4_VHD_EXECUTE_READ_DATA_PHASE            = 32'd64,
    AXI4_VHD_GET_READ_DATA_PHASE                = 32'd65,
    AXI4_VHD_EXECUTE_WRITE_ADDR_PHASE           = 32'd66,
    AXI4_VHD_GET_WRITE_ADDR_PHASE               = 32'd67,
    AXI4_VHD_EXECUTE_WRITE_DATA_PHASE           = 32'd68,
    AXI4_VHD_GET_WRITE_DATA_PHASE               = 32'd69,
    AXI4_VHD_EXECUTE_WRITE_RESPONSE_PHASE       = 32'd70,
    AXI4_VHD_GET_WRITE_RESPONSE_PHASE           = 32'd71,
    AXI4_VHD_GET_READ_ADDR_CYCLE                = 32'd72,
    AXI4_VHD_EXECUTE_READ_ADDR_READY            = 32'd73,
    AXI4_VHD_GET_READ_ADDR_READY                = 32'd74,
    AXI4_VHD_GET_READ_DATA_CYCLE                = 32'd75,
    AXI4_VHD_EXECUTE_READ_DATA_READY            = 32'd76,
    AXI4_VHD_GET_READ_DATA_READY                = 32'd77,
    AXI4_VHD_GET_WRITE_ADDR_CYCLE               = 32'd78,
    AXI4_VHD_EXECUTE_WRITE_ADDR_READY           = 32'd79,
    AXI4_VHD_GET_WRITE_ADDR_READY               = 32'd80,
    AXI4_VHD_GET_WRITE_DATA_CYCLE               = 32'd81,
    AXI4_VHD_EXECUTE_WRITE_DATA_READY           = 32'd82,
    AXI4_VHD_GET_WRITE_DATA_READY               = 32'd83,
    AXI4_VHD_GET_WRITE_RESPONSE_CYCLE           = 32'd84,
    AXI4_VHD_EXECUTE_WRITE_RESP_READY           = 32'd85,
    AXI4_VHD_GET_WRITE_RESP_READY               = 32'd86,
    AXI4_VHD_CREATE_MONITOR_TRANSACTION         = 32'd87,
    AXI4_VHD_CREATE_SLAVE_TRANSACTION           = 32'd88,
    AXI4_VHD_PUSH_TRANSACTION_ID                = 32'd89,
    AXI4_VHD_POP_TRANSACTION_ID                 = 32'd90,
    AXI4_VHD_GET_WRITE_ADDR_DATA                = 32'd91,
    AXI4_VHD_GET_READ_ADDR                      = 32'd92,
    AXI4_VHD_SET_READ_DATA                      = 32'd93,
    AXI4_VHD_PRINT                              = 32'd94,
    AXI4_VHD_DESTRUCT_TRANSACTION               = 32'd95,
    AXI4_VHD_WAIT_ON                            = 32'd96
} axi4_vhd_if_e;


typedef enum bit [7:0]
{
    AXI4_CLOCK_POSEDGE = 8'd0,
    AXI4_CLOCK_NEGEDGE = 8'd1,
    AXI4_CLOCK_ANYEDGE = 8'd2,
    AXI4_CLOCK_0_TO_1  = 8'd3,
    AXI4_CLOCK_1_TO_0  = 8'd4,
    AXI4_RESET_POSEDGE = 8'd5,
    AXI4_RESET_NEGEDGE = 8'd6,
    AXI4_RESET_ANYEDGE = 8'd7,
    AXI4_RESET_0_TO_1  = 8'd8,
    AXI4_RESET_1_TO_0  = 8'd9
} axi4_wait_e;

`ifndef MAX_AXI4_ADDRESS_WIDTH
  `define MAX_AXI4_ADDRESS_WIDTH 64
`endif

`ifndef MAX_AXI4_RDATA_WIDTH
  `define MAX_AXI4_RDATA_WIDTH 1024
`endif

`ifndef MAX_AXI4_WDATA_WIDTH
  `define MAX_AXI4_WDATA_WIDTH 1024
`endif

`ifndef MAX_AXI4_ID_WIDTH
  `define MAX_AXI4_ID_WIDTH 18
`endif

`ifndef MAX_AXI4_USER_WIDTH
  `define MAX_AXI4_USER_WIDTH 8
`endif

`ifndef MAX_AXI4_REGION_MAP_SIZE
  `define MAX_AXI4_REGION_MAP_SIZE 16
`endif

// enum: axi4_operation_mode_e
//
typedef enum int
{
    AXI4_TRANSACTION_NON_BLOCKING = 32'd0,
    AXI4_TRANSACTION_BLOCKING     = 32'd1
} axi4_operation_mode_e;

// enum: axi4_write_data_mode_e
//
typedef enum int
{
    AXI4_DATA_AFTER_ADDRESS = 32'd0,
    AXI4_DATA_WITH_ADDRESS  = 32'd1
} axi4_write_data_mode_e;

// Global Transaction Class
class axi4_transaction;
    // Protocol 
    axi4_rw_e read_or_write;
    bit [((`MAX_AXI4_ADDRESS_WIDTH) - 1):0]  addr;
    axi4_prot_e prot;
    bit [3:0] region;
    axi4_size_e size;
    axi4_burst_e burst;
    axi4_lock_e lock;
    axi4_cache_e cache;
    bit [3:0] qos;
    bit [((`MAX_AXI4_ID_WIDTH) - 1):0]  id;
    bit [7:0] burst_length;
    bit [((`MAX_AXI4_USER_WIDTH) - 1):0]  addr_user;
    bit [((((`MAX_AXI4_RDATA_WIDTH > `MAX_AXI4_WDATA_WIDTH) ? `MAX_AXI4_RDATA_WIDTH : `MAX_AXI4_WDATA_WIDTH)) - 1):0] data_words [];
    bit [(((`MAX_AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [];
    axi4_response_e resp[];
    int address_valid_delay;
    int data_valid_delay[];
    int write_response_valid_delay;
    int address_ready_delay;
    int data_ready_delay[];
    int write_response_ready_delay;

    // Housekeeping
    bit gen_write_strobes = 1'b1;
    axi4_operation_mode_e  operation_mode  = AXI4_TRANSACTION_BLOCKING;
    axi4_write_data_mode_e write_data_mode = AXI4_DATA_AFTER_ADDRESS;
    bit data_beat_done[];
    bit transaction_done;

    // This varaible is for printing component name and should not be visible/documented
    string driver_name;

    function void set_read_or_write( input axi4_rw_e lread_or_write );
      read_or_write = lread_or_write;
    endfunction

    function axi4_rw_e get_read_or_write();
      return read_or_write;
    endfunction

    function void set_addr( input bit [((`MAX_AXI4_ADDRESS_WIDTH) - 1):0]  laddr );
      addr = laddr;
    endfunction

    function bit [((`MAX_AXI4_ADDRESS_WIDTH) - 1):0]   get_addr();
      return addr;
    endfunction

    function void set_prot( input axi4_prot_e lprot );
      prot = lprot;
    endfunction

    function axi4_prot_e get_prot();
      return prot;
    endfunction

    function void set_region( input bit [3:0] lregion );
      region = lregion;
    endfunction

    function bit [3:0]  get_region();
      return region;
    endfunction

    function void set_size( input axi4_size_e lsize );
      size = lsize;
    endfunction

    function axi4_size_e get_size();
      return size;
    endfunction

    function void set_burst( input axi4_burst_e lburst );
      burst = lburst;
    endfunction

    function axi4_burst_e get_burst();
      return burst;
    endfunction

    function void set_lock( input axi4_lock_e llock );
      lock = llock;
    endfunction

    function axi4_lock_e get_lock();
      return lock;
    endfunction

    function void set_cache( input axi4_cache_e lcache );
      cache = lcache;
    endfunction

    function axi4_cache_e get_cache();
      return cache;
    endfunction

    function void set_qos( input bit [3:0] lqos );
      qos = lqos;
    endfunction

    function bit [3:0]  get_qos();
      return qos;
    endfunction

    function void set_id( input bit [((`MAX_AXI4_ID_WIDTH) - 1):0]  lid );
      id = lid;
    endfunction

    function bit [((`MAX_AXI4_ID_WIDTH) - 1):0]   get_id();
      return id;
    endfunction

    function void set_burst_length( input bit [7:0] lburst_length );
      burst_length = lburst_length;
      data_words           = new[(lburst_length + 1)];
      write_strobes        = new[(lburst_length + 1)];
      resp                 = new[(lburst_length + 1)];
      data_valid_delay     = new[(lburst_length + 1)];
      data_ready_delay     = new[(lburst_length + 1)];
      data_beat_done       = new[(lburst_length + 1)];
    endfunction

    function bit [7:0]  get_burst_length();
      return burst_length;
    endfunction

    function void set_addr_user( input bit [((`MAX_AXI4_USER_WIDTH) - 1):0]  laddr_user );
      addr_user = laddr_user;
    endfunction

    function bit [((`MAX_AXI4_USER_WIDTH) - 1):0]   get_addr_user();
      return addr_user;
    endfunction

    function void set_data_words( input bit [((((`MAX_AXI4_RDATA_WIDTH > `MAX_AXI4_WDATA_WIDTH) ? `MAX_AXI4_RDATA_WIDTH : `MAX_AXI4_WDATA_WIDTH)) - 1):0] ldata_words, input int index = 0 );
      data_words[index] = ldata_words;
    endfunction

    function bit [((((`MAX_AXI4_RDATA_WIDTH > `MAX_AXI4_WDATA_WIDTH) ? `MAX_AXI4_RDATA_WIDTH : `MAX_AXI4_WDATA_WIDTH)) - 1):0]  get_data_words( input int index = 0 );
      return data_words[index];
    endfunction

    function void set_write_strobes( input bit [(((`MAX_AXI4_WDATA_WIDTH / 8)) - 1):0] lwrite_strobes, input int index = 0 );
      write_strobes[index] = lwrite_strobes;
    endfunction

    function bit [(((`MAX_AXI4_WDATA_WIDTH / 8)) - 1):0]  get_write_strobes( input int index = 0 );
      return write_strobes[index];
    endfunction

    function void set_resp( input axi4_response_e lresp, input int index = 0 );
      resp[index] = lresp;
    endfunction

    function axi4_response_e get_resp( input int index = 0 );
      return resp[index];
    endfunction

    function void set_address_valid_delay( input int laddress_valid_delay );
      address_valid_delay = laddress_valid_delay;
    endfunction

    function int get_address_valid_delay();
      return address_valid_delay;
    endfunction

    function void set_data_valid_delay( input int ldata_valid_delay, input int index = 0 );
      data_valid_delay[index] = ldata_valid_delay;
    endfunction

    function int get_data_valid_delay( input int index = 0 );
      return data_valid_delay[index];
    endfunction

    function void set_write_response_valid_delay( input int lwrite_response_valid_delay );
      write_response_valid_delay = lwrite_response_valid_delay;
    endfunction

    function int get_write_response_valid_delay();
      return write_response_valid_delay;
    endfunction

    function void set_address_ready_delay( input int laddress_ready_delay );
      address_ready_delay = laddress_ready_delay;
    endfunction

    function int get_address_ready_delay();
      return address_ready_delay;
    endfunction

    function void set_data_ready_delay( input int ldata_ready_delay, input int index = 0 );
      data_ready_delay[index] = ldata_ready_delay;
    endfunction

    function int get_data_ready_delay( input int index = 0 );
      return data_ready_delay[index];
    endfunction

    function void set_write_response_ready_delay( input int lwrite_response_ready_delay );
      write_response_ready_delay = lwrite_response_ready_delay;
    endfunction

    function int get_write_response_ready_delay();
      return write_response_ready_delay;
    endfunction

    function void set_gen_write_strobes( input bit lgen_write_strobes);
      gen_write_strobes = lgen_write_strobes;
    endfunction

    function bit get_gen_write_strobes();
      return gen_write_strobes;
    endfunction

    function void set_operation_mode( input axi4_operation_mode_e loperation_mode );
      operation_mode = loperation_mode;
    endfunction

    function axi4_operation_mode_e get_operation_mode();
      return operation_mode;
    endfunction

    function void set_write_data_mode( input axi4_write_data_mode_e lwrite_data_mode );
      write_data_mode = lwrite_data_mode;
    endfunction

    function axi4_write_data_mode_e get_write_data_mode();
      return write_data_mode;
    endfunction

    function void set_data_beat_done( input int ldata_beat_done, input int index = 0 );
      data_beat_done[index] = ldata_beat_done;
    endfunction

    function int get_data_beat_done( input int index = 0 );
      return data_beat_done[index];
    endfunction

    function void set_transaction_done( input int ltransaction_done );
      transaction_done = ltransaction_done;
    endfunction

    function int get_transaction_done();
      return transaction_done;
    endfunction

    // Function: do_print
    //
    // Prints axi4_transaction transaction attributes
    function void print (bit print_delays = 1'b0);
      $display("------------------------------------------------------------------------");
      $display("%0t: %s axi4_transaction", $time, driver_name);
      $display("------------------------------------------------------------------------");
      $display("read_or_write : %s", read_or_write.name());
      $display("addr : 'h%h", addr);
      $display("prot : %s", prot.name());
      $display("region : 'h%h", region);
      $display("size : %s", size.name());
      $display("burst : %s", burst.name());
      $display("lock : %s", lock.name());
      $display("cache : %s", cache.name());
      $display("qos : 'h%h", qos);
      $display("id : 'h%h", id);
      $display("burst_length : 'h%h", burst_length);
      $display("addr_user : 'h%h", addr_user);
      foreach( data_words[i0_1] )
        $display("data_words[%0d] : 'h%h", i0_1, data_words[i0_1]);
      foreach( write_strobes[i0_1] )
        $display("write_strobes[%0d] : 'h%h", i0_1, write_strobes[i0_1]);
      foreach( resp[i0_1] )
        $display("resp[%0d] : %s", i0_1, resp[i0_1].name());
      $display("gen_write_strobes : 'b%b", gen_write_strobes );
      $display("operation_mode   : %s", operation_mode.name() );
      $display("write_data_mode  : %s", write_data_mode.name() );
      foreach( data_beat_done[i0_1] )
        $display("data_beat_done[%0d] : 'b%b", i0_1, data_beat_done[i0_1] );
      $display("transaction_done : 'b%b", transaction_done );
      if ( print_delays == 1'b1 )
      begin
        $display("address_valid_delay : %0d", address_valid_delay);
        foreach( data_valid_delay[i0_1] )
          $display("data_valid_delay[%0d] : %0d", i0_1, data_valid_delay[i0_1]);
        $display("write_response_valid_delay : %0d", write_response_valid_delay);
        $display("address_ready_delay : %0d", address_ready_delay);
        foreach( data_ready_delay[i0_1] )
          $display("data_ready_delay[%0d] : %0d", i0_1, data_ready_delay[i0_1]);
        $display("write_response_ready_delay : %0d", write_response_ready_delay);
      end
    endfunction
endclass

`else
// *****************************************************************************
//
// Copyright 2007-2013 Mentor Graphics Corporation
// All Rights Reserved.
//
// THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION WHICH IS THE PROPERTY OF
// MENTOR GRAPHICS CORPORATION OR ITS LICENSORS AND IS SUBJECT TO LICENSE TERMS.
//
// *****************************************************************************
// SystemVerilog           Version: 20130911_Questa_10.2c
// *****************************************************************************

// Title: axi4_types
//

// enum: axi4_prot_e
//
//------------------------------------------------------------------------------
//  Protection type mapped to the AxPROT signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.7))
//  
// AXI4_NORM_SEC_DATA - Normal/Secure/Data
// AXI4_PRIV_SEC_DATA - Privileged/Secure/Data
// AXI4_NORM_NONSEC_DATA - Normal/Non-secure/Data
// AXI4_PRIV_NONSEC_DATA - Privileged/Non-secure/Data
// AXI4_NORM_SEC_INST - Normal/Secure/Instruction
// AXI4_PRIV_SEC_INST - Privileged/Secure/Instruction
// AXI4_NORM_NONSEC_INST - Normal/Non-secure/Instruction
// AXI4_PRIV_NONSEC_INST - Privileged/Non-secure/Instruction
//  
//------------------------------------------------------------------------------
typedef enum bit [2:0]
{
    AXI4_NORM_SEC_DATA    = 3'h0,
    AXI4_PRIV_SEC_DATA    = 3'h1,
    AXI4_NORM_NONSEC_DATA = 3'h2,
    AXI4_PRIV_NONSEC_DATA = 3'h3,
    AXI4_NORM_SEC_INST    = 3'h4,
    AXI4_PRIV_SEC_INST    = 3'h5,
    AXI4_NORM_NONSEC_INST = 3'h6,
    AXI4_PRIV_NONSEC_INST = 3'h7
} axi4_prot_e;


// enum: axi4_response_e
//
//------------------------------------------------------------------------------
//  Response type mapped to the xRESP signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.4)
// 
// AXI4_OKAY   - Normal access has been successful, or exclusive access has failed (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.4).
// AXI4_EXOKAY - Exclusive acess okay (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.4)) OR Reserved value if QVIP BFM is configured as axi4lite interface (see AMBA AXI and ACE Protocol Specification IHI0022D section B1.1.1.
// AXI4_SLVERR - Slave signals an error to the originating master.
// AXI4_DECERR - Decode error (generally used to indicate that there is no slave at the transaction address).
//  
//------------------------------------------------------------------------------
typedef enum bit [1:0]
{
    AXI4_OKAY   = 2'h0,
    AXI4_EXOKAY = 2'h1,
    AXI4_SLVERR = 2'h2,
    AXI4_DECERR = 2'h3
} axi4_response_e;


// enum: axi4_rw_e
//
//------------------------------------------------------------------------------
//  This is used as the <axi4_master_rw_transaction::read_or_write> argument to the <axi4_master_rw_transaction> transaction to indicate read or write.
// 
// AXI4_TRANS_READ - read transaction
// AXI4_TRANS_WRITE - write transaction
//  
//------------------------------------------------------------------------------
typedef enum bit [0:0]
{
    AXI4_TRANS_READ  = 1'h0,
    AXI4_TRANS_WRITE = 1'h1
} axi4_rw_e;


// enum: axi4_size_e
//
//------------------------------------------------------------------------------
//  Word-size encoding mapped to the AxSIZE signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1). 
// 
// AXI4_BYTES_1 - 3'b000 i.e. 1 byte
// AXI4_BYTES_2 - 3'b001 i.e. 2 bytes
// AXI4_BYTES_4 - 3'b010 i.e. 4 bytes
// AXI4_BYTES_8 - 3'b011 i.e. 8 bytes
// AXI4_BYTES_16 - 3'b100 i.e. 16 bytes
// AXI4_BYTES_32 - 3'b101 i.e. 32 bytes
// AXI4_BYTES_64 - 3'b110 i.e. 64 bytes
// AXI4_BYTES_128 - 3'b111 i.e. 128 bytes
// 
//------------------------------------------------------------------------------
typedef enum bit [2:0]
{
    AXI4_BYTES_1   = 3'h0,
    AXI4_BYTES_2   = 3'h1,
    AXI4_BYTES_4   = 3'h2,
    AXI4_BYTES_8   = 3'h3,
    AXI4_BYTES_16  = 3'h4,
    AXI4_BYTES_32  = 3'h5,
    AXI4_BYTES_64  = 3'h6,
    AXI4_BYTES_128 = 3'h7
} axi4_size_e;


// enum: axi4_cache_e
//
//------------------------------------------------------------------------------
//  Cache behaviour type, mapped to the AxCACHE signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4).
// 
// This has identical values to those in AXI3, but the AxCACHE[1] bit is now named 'Modifiable' (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.3.1)
// 
// AXI4_NONMODIFIABLE_NONBUF - Non-modifiable and non-bufferable
// AXI4_BUF_ONLY - Bufferable only
// AXI4_CACHE_2 - Bit pattern 0010
// AXI4_CACHE_3 - Bit pattern 0011
// AXI4_CACHE_RSVD_4 - Reserved
// AXI4_CACHE_RSVD_5 - Reserved
// AXI4_CACHE_6 - Bit pattern 0110
// AXI4_CACHE_7 - Bit pattern 0111
// AXI4_CACHE_RSVD_8 - Reserved
// AXI4_CACHE_RSVD_9 - Reserved
// AXI4_CACHE_10 - Bit pattern 1010
// AXI4_CACHE_11 - Bit pattern 1011
// AXI4_CACHE_RSVD_12 - Reserved
// AXI4_CACHE_RSVD_13 - Reserved
// AXI4_CACHE_14 - Bit pattern 1110
// AXI4_CACHE_15 - Bit pattern 1111
// 
//------------------------------------------------------------------------------
typedef enum bit [3:0]
{
    AXI4_NONMODIFIABLE_NONBUF = 4'h0,
    AXI4_BUF_ONLY             = 4'h1,
    AXI4_CACHE_2              = 4'h2,
    AXI4_CACHE_3              = 4'h3,
    AXI4_CACHE_RSVD_4         = 4'h4,
    AXI4_CACHE_RSVD_5         = 4'h5,
    AXI4_CACHE_6              = 4'h6,
    AXI4_CACHE_7              = 4'h7,
    AXI4_CACHE_RSVD_8         = 4'h8,
    AXI4_CACHE_RSVD_9         = 4'h9,
    AXI4_CACHE_10             = 4'ha,
    AXI4_CACHE_11             = 4'hb,
    AXI4_CACHE_RSVD_12        = 4'hc,
    AXI4_CACHE_RSVD_13        = 4'hd,
    AXI4_CACHE_14             = 4'he,
    AXI4_CACHE_15             = 4'hf
} axi4_cache_e;


// enum: axi4_burst_e
//
//------------------------------------------------------------------------------
//  Burst type mapped to the AxBURST signals to determine address calculation (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.4). 
// 
// AXI4_FIXED - Fixed
// AXI4_INCR - Incrementing
// AXI4_WRAP - Wrap
// AXI4_RESERVED - Reserved value. May be enabled by setting the configuration parameter <mgc_axi4::config_enable_burst_reserved_value>.
// 
//------------------------------------------------------------------------------
typedef enum bit [1:0]
{
    AXI4_FIXED    = 2'h0,
    AXI4_INCR     = 2'h1,
    AXI4_WRAP     = 2'h2,
    AXI4_RESERVED = 2'h3
} axi4_burst_e;


// enum: axi4_lock_e
//
//------------------------------------------------------------------------------
//  Access type mapped to the AxLOCK signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.4).
// 
// AXI4_NORMAL - Normal Access, respecting barriers
// AXI4_EXCLUSIVE - Exclusive Access, respecting barriers
// 
//------------------------------------------------------------------------------
typedef enum bit [1:0]
{
    AXI4_NORMAL    = 2'h0,
    AXI4_EXCLUSIVE = 2'h1
} axi4_lock_e;


// enum: axi4_interface_type_e
//
//------------------------------------------------------------------------------
//  Type to configure the category of the interface (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.2) as read/write, read-only or write-only by setting the value of <mgc_axi4::config_interface_type> configuration parameter.
// 
// AXI4_READWRITE - Read and Write
// AXI4_READONLY - Read Only
// AXI4_WRITEONLY - Write Only
// 
//------------------------------------------------------------------------------
typedef enum bit [1:0]
{
    AXI4_READWRITE = 2'h0,
    AXI4_READONLY  = 2'h1,
    AXI4_WRITEONLY = 2'h2
} axi4_interface_type_e;


// enum: axi4_error_e
//
//------------------------------------------------------------------------------
//  Type defining the error messages which can be produced by the <mgc_axi4> Questa Verification IP.
// 
// Individual error messages can be disabled using the <mgc_axi4::config_enable_assertion> array of configuration bits.
// 
//------------------------------------------------------------------------------
//    AXI4_ADDRESS_WIDTH_EXCEEDS_64 -  AXI4 supports up to 64-bit addressing (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.3.1)
//    AXI4_ARADDR_CHANGED_BEFORE_ARREADY -  The value of <mgc_axi4::ARADDR> has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARADDR_UNKN -  <mgc_axi4::ARADDR> has an X value/<mgc_axi4::ARADDR> has an Z value
//    AXI4_ARPROT_CHANGED_BEFORE_ARREADY -  The value of <mgc_axi4::ARPROT> has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARPROT_UNKN -  <mgc_axi4::ARPROT> has an X value/<mgc_axi4::ARPROT> has an Z value
//    AXI4_ARREADY_NOT_ASSERTED_AFTER_ARVALID -  Once <mgc_axi4::ARVALID> has been asserted, <mgc_axi4::ARREADY> should be asserted within <mgc_axi4::config_max_latency_ARVALID_assertion_to_ARREADY> clock periods
//    AXI4_ARREADY_UNKN -  <mgc_axi4::ARREADY> has an X value/<mgc_axi4::ARREADY> has a Z value
//    AXI4_ARVALID_DEASSERTED_BEFORE_ARREADY -  <mgc_axi4::ARVALID> has been de-asserted before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARVALID_HIGH_ON_FIRST_CLOCK -  A master interface must begin driving <mgc_axi4::ARVALID> high only at a rising clock edge after <mgc_axi4::ARESETn> is HIGH (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.1.2)
//    AXI4_ARVALID_UNKN -  <mgc_axi4::ARVALID> has an X value/<mgc_axi4::ARVALID> has an Z value
//    AXI4_AWADDR_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWADDR> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWADDR_UNKN -  <mgc_axi4::AWADDR> has an X value/<mgc_axi4::AWADDR> has an Z value
//    AXI4_AWPROT_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWPROT> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWPROT_UNKN -  <mgc_axi4::AWPROT> has an X value/<mgc_axi4::AWPROT> has an Z value
//    AXI4_AWREADY_NOT_ASSERTED_AFTER_AWVALID -  Once <mgc_axi4::AWVALID> has been asserted, <mgc_axi4::AWREADY> should be asserted within <mgc_axi4::config_max_latency_AWVALID_assertion_to_AWREADY> clock periods
//    AXI4_AWREADY_UNKN -  <mgc_axi4::AWREADY> has an X value/<mgc_axi4::AWREADY> has an Z value
//    AXI4_AWVALID_DEASSERTED_BEFORE_AWREADY -  <mgc_axi4::AWVALID> has been de-asserted before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWVALID_HIGH_ON_FIRST_CLOCK -  A master interface must begin driving <mgc_axi4::AWVALID> high only at a rising clock edge after <mgc_axi4::ARESETn> is HIGH (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.1.2)
//    AXI4_AWVALID_UNKN -  <mgc_axi4::AWVALID> has an X value/<mgc_axi4::AWVALID> has an Z value
//    AXI4_BREADY_NOT_ASSERTED_AFTER_BVALID -  Once <mgc_axi4::BVALID> has been asserted, <mgc_axi4::BREADY> should be asserted within <mgc_axi4::config_max_latency_BVALID_assertion_to_BREADY> clock periods
//    AXI4_BREADY_UNKN -  <mgc_axi4::BREADY> has an X value/<mgc_axi4::BREADY> has an Z value
//    AXI4_BRESP_CHANGED_BEFORE_BREADY -  The value of <mgc_axi4::BRESP> has changed from its initial value between the time <mgc_axi4::BVALID> was asserted, and before <mgc_axi4::BREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_BRESP_UNKN -  <mgc_axi4::BRESP> has an X value/<mgc_axi4::BRESP> has a Z value
//    AXI4_BVALID_DEASSERTED_BEFORE_BREADY -  <mgc_axi4::BVALID> has been de-asserted before <mgc_axi4::BREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_BVALID_HIGH_EXITING_RESET -  <mgc_axi4::BVALID> should have been driven low when exiting reset (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.1.2)
//    AXI4_BVALID_UNKN -  <mgc_axi4::BVALID> has an X value/<mgc_axi4::BVALID> has a Z value
//    AXI4_DEC_ERR_RESP_FOR_READ -  No slave at the address for this read transfer (signaled by <AXI4_DECERR>)
//    AXI4_DEC_ERR_RESP_FOR_WRITE -  No slave at the address for this write transfer (signaled by <AXI4_DECERR>)
//    AXI4_EXOKAY_RESPONSE_NORMAL_READ -  Slave has responded <AXI4_EXOKAY> to a non exclusive read transfer
//    AXI4_EXOKAY_RESPONSE_NORMAL_WRITE -  Slave has responded <AXI4_EXOKAY> to a non exclusive write transfer 
//    AXI4_INVALID_WRITE_STROBES_ON_UNALIGNED_WRITE_TRANSFER -  Write strobe(s) incorrect for address/size of an unaligned transaction (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.3)
//    AXI4_MINIMUM_SLAVE_ADDRESS_SPACE_VIOLATION -  The minimum address space occupied by a single slave device is 4 kilobytes (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.3.2)
//    AXI4_PARAM_READ_DATA_BUS_WIDTH -  The value of <mgc_axi4::AXI4_RDATA_WIDTH> must be either 32 or 64 (see AMBA AXI and ACE Protocol Specification IHI0022D section B1.1.2)
//    AXI4_PARAM_WRITE_DATA_BUS_WIDTH -  The value of <mgc_axi4::AXI4_WDATA_WIDTH> must be either 32 or 64 (see AMBA AXI and ACE Protocol Specification IHI0022D section B1.1.2)
//    AXI4_READ_DATA_BEFORE_ADDRESS -  An unexpected read response has occurred (there are no outstanding read transactions with this id) (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.3)
//    AXI4_READ_DATA_CHANGED_BEFORE_RREADY -  The value of <mgc_axi4::RDATA> has changed from its initial value between the time <mgc_axi4::RVALID> was asserted, and before <mgc_axi4::RREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_READ_DATA_UNKN -  <mgc_axi4::RDATA> has an X value/<mgc_axi4::RDATA> has a Z value
//    AXI4_READ_RESP_CHANGED_BEFORE_RREADY -  The value of <mgc_axi4::RRESP> has changed from its initial value between the time <mgc_axi4::RVALID> was asserted, and before <mgc_axi4::RREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_RREADY_NOT_ASSERTED_AFTER_RVALID -  Once <mgc_axi4::RVALID> has been asserted, <mgc_axi4::RREADY> should be asserted within <mgc_axi4::config_max_latency_RVALID_assertion_to_RREADY> clock periods
//    AXI4_RREADY_UNKN -  <mgc_axi4::RREADY> has an X value/<mgc_axi4::RREADY> has a Z value
//    AXI4_RRESP_UNKN -  <mgc_axi4::RRESP> has an X value/<mgc_axi4::RRESP> has a Z value
//    AXI4_RVALID_DEASSERTED_BEFORE_RREADY -  <mgc_axi4::RVALID> has been de-asserted before <mgc_axi4::RREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_RVALID_HIGH_EXITING_RESET -  <mgc_axi4::RVALID> should have been driven low when exiting reset (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.1.2)
//    AXI4_RVALID_UNKN -  <mgc_axi4::RVALID> has an X value/<mgc_axi4::RVALID> has a Z value
//    AXI4_SLV_ERR_RESP_FOR_READ -  Slave has detected an error for this read transfer (signaled by <AXI4_SLVERR>)
//    AXI4_SLV_ERR_RESP_FOR_WRITE -  Slave has detected an error for this write transfer (signaled by <AXI4_SLVERR>)
//    AXI4_TIMEOUT_WAITING_FOR_READ_RESPONSE -  Timed-out waiting for a read response (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.6)
//    AXI4_TIMEOUT_WAITING_FOR_WRITE_RESPONSE -  Timed-out waiting for a write response (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.6)
//    AXI4_WDATA_CHANGED_BEFORE_WREADY_ON_INVALID_LANE -  On a lane whose strobe is 0, the value of <mgc_axi4::WDATA> has changed from its initial value between the time <mgc_axi4::WVALID> was asserted, and before <mgc_axi4::WREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_WDATA_CHANGED_BEFORE_WREADY_ON_VALID_LANE -  On a lane whose strobe is 1, the value of <mgc_axi4::WDATA> has changed from its initial value between the time <mgc_axi4::WVALID> was asserted, and before <mgc_axi4::WREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_WREADY_NOT_ASSERTED_AFTER_WVALID -  Once <mgc_axi4::WVALID> has been asserted, <mgc_axi4::WREADY> should be asserted within <mgc_axi4::config_max_latency_WVALID_assertion_to_WREADY> clock periods
//    AXI4_WREADY_UNKN -  <mgc_axi4::WREADY> has an X value/<mgc_axi4::WREADY> has a Z value
//    AXI4_WRITE_DATA_BEFORE_ADDRESS -  A write data beat has occurred before the corresponding address phase
//    AXI4_WRITE_DATA_UNKN_ON_INVALID_LANE -  On a lane whose strobe is 0, <mgc_axi4::WDATA> has an X value/<mgc_axi4::WDATA> has a Z value
//    AXI4_WRITE_DATA_UNKN_ON_VALID_LANE -  On a lane whose strobe is 1, <mgc_axi4::WDATA> has an X value/<mgc_axi4::WDATA> has a Z value
//    AXI4_WRITE_RESPONSE_WITHOUT_ADDR_DATA -  An unexpected write response has occurred (there are no outstanding write transactions with this id) 
//    AXI4_WSTRB_CHANGED_BEFORE_WREADY -  The value of <mgc_axi4::WSTRB> has changed from its initial value between the time <mgc_axi4::WVALID> was asserted, and before <mgc_axi4::WREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_WSTRB_UNKN -  <mgc_axi4::WSTRB> has an X value/<mgc_axi4::WSTRB> has an Z value
//    AXI4_WVALID_DEASSERTED_BEFORE_WREADY -  <mgc_axi4::WVALID> has been de-asserted before <mgc_axi4::WREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_WVALID_HIGH_ON_FIRST_CLOCK -  A master interface must begin driving <mgc_axi4::WVALID> high only at a rising clock edge after <mgc_axi4::ARESETn> is HIGH (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.1.2)
//    AXI4_WVALID_UNKN -  <mgc_axi4::WVALID> has an X value/<mgc_axi4::WVALID> has an Z value
//    MVC_FAILED_POSTCONDITION -  A postcondition failed
//    MVC_FAILED_RECOGNITION -  An item failed to be recognized  
//    AXI4_DEC_ERR_ILLEGAL_FOR_MAPPED_SLAVE_ADDR -  Slave receives a burst to a mapped address but responds with DECERR (signaled by <AXI4_DECERR>) (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.4)
//    AXI4_AWVALID_HIGH_DURING_RESET -  AWVALID asserted during the reset state (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.1.2)
//    AXI4_WVALID_HIGH_DURING_RESET -  WVALID asserted during the reset state (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.1.2)
//    AXI4_BVALID_HIGH_DURING_RESET -  BVALID asserted during the reset state (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.1.2)
//    AXI4_ARVALID_HIGH_DURING_RESET -  ARVALID asserted during the reset state (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.1.2)
//    AXI4_RVALID_HIGH_DURING_RESET -  RVALID asserted during the reset state (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.1.2)
//    AXI4_TIMEOUT_WAITING_FOR_WRITE_DATA -  Timed-out waiting for a data phase in write data burst (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.6)
//    AXI4_TIMEOUT_WAITING_FOR_WRITE_ADDR_AFTER_DATA -  Timed-out waiting for a write address phase to be coming after data see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2
//    AXI4_ARESETn_SIGNAL_Z -  AXI4 Reset signal has z value
//    AXI4_ARESETn_SIGNAL_X -  AXI4 Reset signal has x value
//    AXI4_ADDR_FOR_READ_BURST_ACROSS_4K_BOUNDARY -  This read transaction has crossed a 4KB boundary (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1) 
//    AXI4_ADDR_FOR_WRITE_BURST_ACROSS_4K_BOUNDARY -  This write transaction has crossed a 4KB boundary (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)
//    AXI4_ARADDR_FALLS_IN_REGION_HOLE -  The <mgc_axi4::ARADDR> value cannot be decoded to a region in the region map (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1)
//    AXI4_ARBURST_CHANGED_BEFORE_ARREADY -  The value of <mgc_axi4::ARBURST> has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARBURST_UNKN -  <mgc_axi4::ARBURST> has an X value/<mgc_axi4::ARBURST> has an Z value
//    AXI4_ARCACHE_CHANGED_BEFORE_ARREADY -  The value of <mgc_axi4::ARCACHE> has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARCACHE_UNKN -  <mgc_axi4::ARCACHE> has an X value/<mgc_axi4::ARCACHE> has an Z value
//    AXI4_ARID_CHANGED_BEFORE_ARREADY -  The value of <mgc_axi4::ARID> has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARID_UNKN -  <mgc_axi4::ARID> has an X value/<mgc_axi4::ARID> has an Z value
//    AXI4_ARLEN_CHANGED_BEFORE_ARREADY -   The value of <mgc_axi4::ARLEN> has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARLEN_UNKN -  <mgc_axi4::ARLEN> has an X value/<mgc_axi4::ARLEN> has an Z value
//    AXI4_ARLOCK_CHANGED_BEFORE_ARREADY -  The value of <mgc_axi4::ARLOCK> has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARLOCK_UNKN -  <mgc_axi4::ARLOCK> has an X value/<mgc_axi4::ARLOCK> has an Z value
//    AXI4_ARQOS_CHANGED_BEFORE_ARREADY -  The value of <mgc_axi4::ARQOS>  has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARQOS_UNKN -  <mgc_axi4::ARQOS>  has an X value/<mgc_axi4::ARQOS> has an Z value
//    AXI4_ARREGION_CHANGED_BEFORE_ARREADY -  The value of <mgc_axi4::ARREGION> has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARREGION_MISMATCH -  The <mgc_axi4::ARREGION> value does not match the value defined in the region map (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1)
//    AXI4_ARREGION_UNKN -  <mgc_axi4::ARREGION> has an X value/<mgc_axi4::ARREGION> has an Z value
//    AXI4_ARSIZE_CHANGED_BEFORE_ARREADY -  The value of <mgc_axi4::ARSIZE> has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARSIZE_UNKN -  <mgc_axi4::ARSIZE> has an X value/<mgc_axi4::ARSIZE> has an Z value
//    AXI4_ARUSER_CHANGED_BEFORE_ARREADY -  The value of <mgc_axi4::ARUSER> has changed from its initial value between the time <mgc_axi4::ARVALID> was asserted, and before <mgc_axi4::ARREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_ARUSER_UNKN -  <mgc_axi4::ARUSER> has an X value/<mgc_axi4::ARUSER> has an Z value
//    AXI4_AWADDR_FALLS_IN_REGION_HOLE -  The addr value cannot be decoded to a region in the region map (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1)
//    AXI4_AWBURST_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWBURST> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWBURST_UNKN -  <mgc_axi4::AWBURST> has an X value/<mgc_axi4::AWBURST> has an Z value
//    AXI4_AWCACHE_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWCACHE> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWCACHE_UNKN -  <mgc_axi4::AWCACHE> has an X value/AWCACHE has an Z value
//    AXI4_AWID_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWID> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWID_UNKN -  <mgc_axi4::AWID> has an X value/<mgc_axi4::AWID> has an Z value
//    AXI4_AWLEN_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWLEN> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWLEN_UNKN -  <mgc_axi4::AWLEN> has an X value/<mgc_axi4::AWLEN> has an Z value
//    AXI4_AWLOCK_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWLOCK> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWLOCK_UNKN -  <mgc_axi4::AWLOCK> has an X value/<mgc_axi4::AWLOCK> has an Z value
//    AXI4_AWQOS_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWQOS> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWQOS_UNKN -  <mgc_axi4::AWQOS> has an X value/<mgc_axi4::AWQOS> has an Z value
//    AXI4_AWREGION_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWREGION> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWREGION_MISMATCH -  The <mgc_axi4::AWREGION> value does not match the value defined in the region map (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1)
//    AXI4_AWREGION_UNKN -  <mgc_axi4::AWREGION> has an X value/<mgc_axi4::AWREGION> has an Z value
//    AXI4_AWSIZE_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWSIZE> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWSIZE_UNKN -  <mgc_axi4::AWSIZE> has an X value/<mgc_axi4::AWSIZE> has an Z value
//    AXI4_AWUSER_CHANGED_BEFORE_AWREADY -  The value of <mgc_axi4::AWUSER> has changed from its initial value between the time <mgc_axi4::AWVALID> was asserted, and before <mgc_axi4::AWREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_AWUSER_UNKN -  <mgc_axi4::AWUSER> has an X value/<mgc_axi4::AWUSER> has an Z value
//    AXI4_BID_CHANGED_BEFORE_BREADY -  The value of <mgc_axi4::BID> has changed from its initial value between the time <mgc_axi4::BVALID> was asserted, and before <mgc_axi4::BREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_BID_UNKN -  <mgc_axi4::BID> has an X value/<mgc_axi4::BID> has a Z value
//    AXI4_BUSER_CHANGED_BEFORE_BREADY -  The value of <mgc_axi4::BUSER> has changed from its initial value between the time <mgc_axi4::BVALID> was asserted, and before <mgc_axi4::BREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_BUSER_UNKN -  <mgc_axi4::BUSER> has an X value/<mgc_axi4::BUSER> has a Z value
//    AXI4_EXCLUSIVE_READ_ACCESS_MODIFIABLE -  The modifiable bit (bit 1 of the cache parameter) should not be set for an exclusive read access (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_READ_BYTES_TRANSFER_EXCEEDS_128 -  Number of bytes in an exclusive read transaction must be less than or equal to 128 (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_WRITE_BYTES_TRANSFER_EXCEEDS_128 -  Number of bytes in an exclusive write transaction must be less than or equal to 128 (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_READ_BYTES_TRANSFER_NOT_POWER_OF_2 -  Number of bytes of an exclusive read transaction is not a power of 2 (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_WRITE_BYTES_TRANSFER_NOT_POWER_OF_2 -  Number of bytes of an exclusive write transaction is not a power of 2 (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_READ_LENGTH_EXCEEDS_16 -  Exclusive read accesses are not permitted to use a burst length greater than 16 (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_WR_ADDRESS_NOT_SAME_AS_RD -  Exclusive write does not match the address of the previous exclusive read to this id (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_WR_BURST_NOT_SAME_AS_RD -  Exclusive write does not match the burst setting of the previous exclusive read to this id (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_WR_CACHE_NOT_SAME_AS_RD -  Exclusive write does not match the cache setting of the previous exclusive read to this id (see the ARM AXI4 compliance-checker AXI4_RECM_EXCL_MATCH assertion code)
//    AXI4_EXCLUSIVE_WRITE_ACCESS_MODIFIABLE -  The modifiable bit (bit 1 of the cache parameter) should not be set for an exclusive write access (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_WR_LENGTH_NOT_SAME_AS_RD -  Exclusive write does not match the length of the previous exclusive read to this id (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_WR_PROT_NOT_SAME_AS_RD -  Exclusive write does not match the prot setting of the previous exclusive read to this id (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_WR_REGION_NOT_SAME_AS_RD -  Exclusive write does not match the region setting of the previous exclusive read to this id (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCLUSIVE_WR_SIZE_NOT_SAME_AS_RD -  Exclusive write does not match the size of the previous exclusive read to this id (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EX_RD_EXOKAY_RESP_EXPECTED_OKAY -  Expected <AXI4_OKAY> response to this exclusive read (because the parameters did not meet the the restrictions), but got <AXI4_EXOKAY> (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EX_RD_EXOKAY_RESP_SLAVE_WITHOUT_EXCLUSIVE_ACCESS -  Response for an exclusive read to a slave which does not support exclusive access should be <AXI4_OKAY>, but it returned <AXI4_EXOKAY> (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.5)
//    AXI4_EX_RD_OKAY_RESP_EXPECTED_EXOKAY -  Expected <AXI4_EXOKAY> response to this exclusive read (because the parameters met the restrictions), but got <AXI4_OKAY> (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EX_RD_WHEN_EX_NOT_ENABLED -  An exclusive read should not be issued when exclusive transactions are not enabled
//    AXI4_EX_WRITE_BEFORE_EX_READ_RESPONSE -  Exclusive write has occurred, with no previous exclusive read
//    AXI4_EX_WRITE_EXOKAY_RESP_EXPECTED_OKAY -  Exclusive write has not been successful, yet slave has responded with <AXI4_EXOKAY> (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.2)
//    AXI4_EX_WRITE_EXOKAY_RESP_SLAVE_WITHOUT_EXCLUSIVE_ACCESS -  Response for an exclusive write to a slave which does not support exclusive access should be <AXI4_OKAY>, but it returned <AXI4_EXOKAY> (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.5)
//    AXI4_EX_WRITE_OKAY_RESP_EXPECTED_EXOKAY -  An <AXI4_OKAY> response to an exclusive write occurred, but an <AXI4_EXOKAY> response had been expected (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.2). If the slave has multiple interfaces to the system, this check should be disabled, as it is possible for this response to occur as a result of activity on another port.
//    AXI4_EX_WR_WHEN_EX_NOT_ENABLED -  An exclusive write should not be issued when exclusive transactions are not enabled
//    AXI4_ILLEGAL_ARCACHE_VALUE_FOR_CACHEABLE_ADDRESS_REGION -  For a read from a cacheable address region, one of bits 2 or 3 of the cache parameter must be HIGH (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.5)
//    AXI4_ILLEGAL_ARCACHE_VALUE_FOR_NON_CACHEABLE_ADDRESS_REGION -  For a read from a non-cacheable address region, bits 2 and 3 of the cache parameter must be LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.5)
//    AXI4_ILLEGAL_AWCACHE_VALUE_FOR_CACHEABLE_ADDRESS_REGION -  For a write to a cacheable address region, one of bits 2 or 3 of the cache parameter must be HIGH (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.5)
//    AXI4_ILLEGAL_AWCACHE_VALUE_FOR_NON_CACHEABLE_ADDRESS_REGION -  For a write to a non-cacheable address region, bits 2 and 3 of the cache parameter must be LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.5)
//    AXI4_ILLEGAL_LENGTH_FIXED_READ_BURST -  In the last read address phase burst_length has an illegal value for a burst of type AXI4_FIXED (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)
//    AXI4_ILLEGAL_LENGTH_FIXED_WRITE_BURST -  In the last write address phase burst_length has an illegal value for a burst of type AXI4_FIXED (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1) 
//    AXI4_ILLEGAL_LENGTH_WRAPPING_READ_BURST -  In the last read address phase burst_length has an illegal value for a burst of type AXI4_WRAP (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)
//    AXI4_ILLEGAL_LENGTH_WRAPPING_WRITE_BURST -  In the last write address phase burst_length has an illegal value for a burst of type AXI4_WRAP (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)
//    AXI4_ILLEGAL_RESPONSE_EXCLUSIVE_READ -  Error response (<AXI4_SLVERR>/<AXI4_DECERR>) received for an exclusive read
//    AXI4_ILLEGAL_RESPONSE_EXCLUSIVE_WRITE -  Error response (<AXI4_SLVERR>/<AXI4_DECERR>) received for an exclusive write
//    AXI4_INVALID_REGION_CARDINALITY -  The configuration parameter <mgc_axi4::config_slave_regions> does not lie in the range 1-16, inclusive (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1).
//    AXI4_INVALID_WRITE_STROBES_ON_ALIGNED_WRITE_TRANSFER -  Write strobe(s) incorrect for address/size of an aligned transaction (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.3)
//    AXI4_NON_INCREASING_REGION_SPECIFICATION -  A region address-range has an upper bound smaller than the lower bound.
//    AXI4_NON_ZERO_ARQOS -  The master is configured to not participate in the Quality-of-Service scheme, but <mgc_axi4::ARQOS>  is not 4'b0000, as it should be (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.1.2)
//    AXI4_NON_ZERO_AWQOS -  The master is configured to not participate in the Quality-of-Service scheme, but <mgc_axi4::AWQOS> is not 4'b0000, as it should be (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.1.2)
//    AXI4_OVERLAPPING_REGION -  An address-range in the region map overlaps with another address in the region map (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1). 
//    AXI4_PARAM_READ_REORDERING_DEPTH_EQUALS_ZERO -  The user-supplied config_read_data_reordering_depth should be greater than zero (see AMBA AXI and ACE Protocol Specification IHI0022D section A5.3.1)
//    AXI4_PARAM_READ_REORDERING_DEPTH_EXCEEDS_MAX_ID -  The user-supplied config_read_data_reordering_depth exceeds the maximum possible value, as defined by the AXI4_ID_WIDTH parameter (see AMBA AXI and ACE Protocol Specification IHI0022D section A5.3.1)
//    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_12 -  The RA bit of the cache parameter should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_13 -  The RA bit of the cache parameter should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_4 -  The RA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_5 -  The RA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_8 -  The RA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_9 -  The RA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_READ_BURST_LENGTH_VIOLATION -  The burst_length implied by the number of beats actually read does not match the burst_length defined by the <axi4_master_read_addr_channel_phase>
//    AXI4_READ_BURST_MAXIMUM_LENGTH_VIOLATION -  256 read data beats were seen without <mgc_axi4::RLAST> (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)
//    AXI4_READ_BURST_SIZE_VIOLATION -  In this read transaction, size has been set too high for the defined data buswidth
//    AXI4_READ_EXCLUSIVE_ENCODING_VIOLATION -  A read-only interface does not support exclusive accesses (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.2.2)
//    AXI4_READ_REORDERING_VIOLATION -  The arrival of a read response has exceeded the read reordering depth (see AMBA AXI and ACE Protocol Specification IHI0022D section A5.3.1)
//    AXI4_READ_TRANSFER_EXCEEDS_ADDRESS_SPACE -  This read transfer runs off the edge of the address space defined by AXI4_ADDRESS_WIDTH (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.3.1)
//    AXI4_REGION_SMALLER_THAN_4KB -  An address-range in the region map is smaller than 4kB (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1)
//    AXI4_RESERVED_ARBURST_ENCODING -  The reserved encoding of 2'b11 should not be used for <mgc_axi4::ARBURST> (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)
//    AXI4_RESERVED_AWBURST_ENCODING -  The reserved encoding of 2'b11 should not be used for <mgc_axi4::AWBURST> (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)
//    AXI4_RID_CHANGED_BEFORE_RREADY -  The value of <mgc_axi4::RID> has changed from its initial value between the time <mgc_axi4::RVALID> was asserted, and before <mgc_axi4::RREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_RID_UNKN -  <mgc_axi4::RID> has an X value/<mgc_axi4::RID> has a Z value
//    AXI4_RLAST_CHANGED_BEFORE_RREADY -  The value of <mgc_axi4::RLAST> has changed from its initial value between the time <mgc_axi4::RVALID> was asserted, and before <mgc_axi4::RREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_RLAST_UNKN -  <mgc_axi4::RLAST> has an X value/<mgc_axi4::RLAST> has a Z value
//    AXI4_RUSER_CHANGED_BEFORE_RREADY -  The value of <mgc_axi4::RUSER> has changed from its initial value between the time <mgc_axi4::RVALID> was asserted, and before <mgc_axi4::RREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_RUSER_UNKN -  <mgc_axi4::RUSER> has an X value/<mgc_axi4::RUSER> has a Z value
//    AXI4_UNALIGNED_ADDRESS_FOR_EXCLUSIVE_READ -  Exclusive read accesses must have address aligned to the total number of bytes in the transaction (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_UNALIGNED_ADDRESS_FOR_EXCLUSIVE_WRITE -  Exclusive write accesses must have address aligned to the total number of bytes in the transaction (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_UNALIGNED_ADDR_FOR_WRAPPING_READ_BURST -  Wrapping bursts must have address aligned to the start of the read transfer (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)
//    AXI4_UNALIGNED_ADDR_FOR_WRAPPING_WRITE_BURST -  Wrapping bursts must have address aligned to the start of the write transfet (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)   
//    AXI4_WLAST_CHANGED_BEFORE_WREADY -  The value of <mgc_axi4::WLAST> has changed from its initial value between the time <mgc_axi4::WVALID> was asserted, and before <mgc_axi4::WREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_WLAST_UNKN -  <mgc_axi4::WLAST> has an X value/<mgc_axi4::WLAST> has an Z value
//    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_12 -  The WA bit of the cache parameter should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_13 -  The WA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_4 -  The WA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_5 -  The WA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_8 -  The WA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_9 -  The WA of the cache parameter bit should not be HIGH when the Modifiable bit is LOW (see AMBA AXI and ACE Protocol Specification IHI0022D section A4.4)
//    AXI4_WRITE_BURST_LENGTH_VIOLATION -  The number of data beats in a write transfer should match the value given by <mgc_axi4::AWLEN>
//    AXI4_WRITE_STROBES_LENGTH_VIOLATION -  The size of the write_strobes array in a write transfer should match the value given by <mgc_axi4::AWLEN>
//    AXI4_WRITE_USER_DATA_LENGTH_VIOLATION -  The size of the wdata_user_data array in a write transfer should match the value given by <mgc_axi4::AWLEN>
//    AXI4_WRITE_BURST_MAXIMUM_LENGTH_VIOLATION -  256 write data beats were seen without <mgc_axi4::WLAST> (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1 )
//    AXI4_WRITE_BURST_SIZE_VIOLATION -  In this write transaction, size has been set too high for the defined data buswidth
//    AXI4_WRITE_EXCLUSIVE_ENCODING_VIOLATION -  A write-only interface does not support exclusive accesses (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.2.3)
//    AXI4_WRITE_STROBE_FIXED_BURST_VIOLATION -  Write strobe(s) incorrect for the address/size of a fixed transfer 
//    AXI4_WRITE_TRANSFER_EXCEEDS_ADDRESS_SPACE -  This write transfer runs off the edge of the address space defined by <mgc_axi4::AXI4_ADDRESS_WIDTH> (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.3.1)
//    AXI4_WRONG_ARREGION_FOR_SLAVE_WITH_SINGLE_ADDRESS_DECODE -  The region value should be 4'b0000 for a read from a slave with a single address decode in the region map (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1)
//    AXI4_WRONG_AWREGION_FOR_SLAVE_WITH_SINGLE_ADDRESS_DECODE -  The region value should be 4'b0000 for a write to a slave with a single address decode in the region map (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1) 
//    AXI4_WUSER_CHANGED_BEFORE_WREADY -  The value of <mgc_axi4::WUSER> has changed from its initial value between the time <mgc_axi4::WVALID> was asserted, and before <mgc_axi4::WREADY> was asserted (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.2.1)
//    AXI4_WUSER_UNKN -  <mgc_axi4::WUSER> has an X value/<mgc_axi4::WUSER> has an Z value
//    AXI4_EXCL_RD_WHILE_EXCL_WR_IN_PROGRESS_SAME_ID -  Master starts an exclusive read burst while exclusive write burst with same ID tag is in progress (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_EXCL_WR_WHILE_EXCL_RD_IN_PROGRESS_SAME_ID -  Master starts an exclusive write burst while exclusive read burst with same ID tag is in progress (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4)
//    AXI4_RLAST_VIOLATION -  RLAST signal should be asserted along with the final transfer of the read data burst (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)
//    AXI4_WLAST_ASSERTED_DURING_DATA_PHASE_OTHER_THAN_LAST -  Wlast must only be asserted during the last data phase (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.1)
typedef enum bit [7:0]
{
    AXI4_ADDRESS_WIDTH_EXCEEDS_64                               = 8'h00,
    AXI4_ARADDR_CHANGED_BEFORE_ARREADY                          = 8'h01,
    AXI4_ARADDR_UNKN                                            = 8'h02,
    AXI4_ARPROT_CHANGED_BEFORE_ARREADY                          = 8'h03,
    AXI4_ARPROT_UNKN                                            = 8'h04,
    AXI4_ARREADY_NOT_ASSERTED_AFTER_ARVALID                     = 8'h05,
    AXI4_ARREADY_UNKN                                           = 8'h06,
    AXI4_ARVALID_DEASSERTED_BEFORE_ARREADY                      = 8'h07,
    AXI4_ARVALID_HIGH_ON_FIRST_CLOCK                            = 8'h08,
    AXI4_ARVALID_UNKN                                           = 8'h09,
    AXI4_AWADDR_CHANGED_BEFORE_AWREADY                          = 8'h0a,
    AXI4_AWADDR_UNKN                                            = 8'h0b,
    AXI4_AWPROT_CHANGED_BEFORE_AWREADY                          = 8'h0c,
    AXI4_AWPROT_UNKN                                            = 8'h0d,
    AXI4_AWREADY_NOT_ASSERTED_AFTER_AWVALID                     = 8'h0e,
    AXI4_AWREADY_UNKN                                           = 8'h0f,
    AXI4_AWVALID_DEASSERTED_BEFORE_AWREADY                      = 8'h10,
    AXI4_AWVALID_HIGH_ON_FIRST_CLOCK                            = 8'h11,
    AXI4_AWVALID_UNKN                                           = 8'h12,
    AXI4_BREADY_NOT_ASSERTED_AFTER_BVALID                       = 8'h13,
    AXI4_BREADY_UNKN                                            = 8'h14,
    AXI4_BRESP_CHANGED_BEFORE_BREADY                            = 8'h15,
    AXI4_BRESP_UNKN                                             = 8'h16,
    AXI4_BVALID_DEASSERTED_BEFORE_BREADY                        = 8'h17,
    AXI4_BVALID_HIGH_EXITING_RESET                              = 8'h18,
    AXI4_BVALID_UNKN                                            = 8'h19,
    AXI4_DEC_ERR_RESP_FOR_READ                                  = 8'h1a,
    AXI4_DEC_ERR_RESP_FOR_WRITE                                 = 8'h1b,
    AXI4_EXOKAY_RESPONSE_NORMAL_READ                            = 8'h1c,
    AXI4_EXOKAY_RESPONSE_NORMAL_WRITE                           = 8'h1d,
    AXI4_INVALID_WRITE_STROBES_ON_UNALIGNED_WRITE_TRANSFER      = 8'h1e,
    AXI4_MINIMUM_SLAVE_ADDRESS_SPACE_VIOLATION                  = 8'h1f,
    AXI4_PARAM_READ_DATA_BUS_WIDTH                              = 8'h20,
    AXI4_PARAM_WRITE_DATA_BUS_WIDTH                             = 8'h21,
    AXI4_READ_DATA_BEFORE_ADDRESS                               = 8'h22,
    AXI4_READ_DATA_CHANGED_BEFORE_RREADY                        = 8'h23,
    AXI4_READ_DATA_UNKN                                         = 8'h24,
    AXI4_READ_RESP_CHANGED_BEFORE_RREADY                        = 8'h25,
    AXI4_RREADY_NOT_ASSERTED_AFTER_RVALID                       = 8'h26,
    AXI4_RREADY_UNKN                                            = 8'h27,
    AXI4_RRESP_UNKN                                             = 8'h28,
    AXI4_RVALID_DEASSERTED_BEFORE_RREADY                        = 8'h29,
    AXI4_RVALID_HIGH_EXITING_RESET                              = 8'h2a,
    AXI4_RVALID_UNKN                                            = 8'h2b,
    AXI4_SLV_ERR_RESP_FOR_READ                                  = 8'h2c,
    AXI4_SLV_ERR_RESP_FOR_WRITE                                 = 8'h2d,
    AXI4_TIMEOUT_WAITING_FOR_READ_RESPONSE                      = 8'h2e,
    AXI4_TIMEOUT_WAITING_FOR_WRITE_RESPONSE                     = 8'h2f,
    AXI4_WDATA_CHANGED_BEFORE_WREADY_ON_INVALID_LANE            = 8'h30,
    AXI4_WDATA_CHANGED_BEFORE_WREADY_ON_VALID_LANE              = 8'h31,
    AXI4_WREADY_NOT_ASSERTED_AFTER_WVALID                       = 8'h32,
    AXI4_WREADY_UNKN                                            = 8'h33,
    AXI4_WRITE_DATA_BEFORE_ADDRESS                              = 8'h34,
    AXI4_WRITE_DATA_UNKN_ON_INVALID_LANE                        = 8'h35,
    AXI4_WRITE_DATA_UNKN_ON_VALID_LANE                          = 8'h36,
    AXI4_WRITE_RESPONSE_WITHOUT_ADDR_DATA                       = 8'h37,
    AXI4_WSTRB_CHANGED_BEFORE_WREADY                            = 8'h38,
    AXI4_WSTRB_UNKN                                             = 8'h39,
    AXI4_WVALID_DEASSERTED_BEFORE_WREADY                        = 8'h3a,
    AXI4_WVALID_HIGH_ON_FIRST_CLOCK                             = 8'h3b,
    AXI4_WVALID_UNKN                                            = 8'h3c,
    MVC_FAILED_POSTCONDITION                                    = 8'h3d,
    MVC_FAILED_RECOGNITION                                      = 8'h3e,
    AXI4_DEC_ERR_ILLEGAL_FOR_MAPPED_SLAVE_ADDR                  = 8'h3f,
    AXI4_AWVALID_HIGH_DURING_RESET                              = 8'h40,
    AXI4_WVALID_HIGH_DURING_RESET                               = 8'h41,
    AXI4_BVALID_HIGH_DURING_RESET                               = 8'h42,
    AXI4_ARVALID_HIGH_DURING_RESET                              = 8'h43,
    AXI4_RVALID_HIGH_DURING_RESET                               = 8'h44,
    AXI4_TIMEOUT_WAITING_FOR_WRITE_DATA                         = 8'h45,
    AXI4_TIMEOUT_WAITING_FOR_WRITE_ADDR_AFTER_DATA              = 8'h46,
    AXI4_ARESETn_SIGNAL_Z                                       = 8'h47,
    AXI4_ARESETn_SIGNAL_X                                       = 8'h48,
    AXI4_ADDR_FOR_READ_BURST_ACROSS_4K_BOUNDARY                 = 8'h49,
    AXI4_ADDR_FOR_WRITE_BURST_ACROSS_4K_BOUNDARY                = 8'h4a,
    AXI4_ARADDR_FALLS_IN_REGION_HOLE                            = 8'h4b,
    AXI4_ARBURST_CHANGED_BEFORE_ARREADY                         = 8'h4c,
    AXI4_ARBURST_UNKN                                           = 8'h4d,
    AXI4_ARCACHE_CHANGED_BEFORE_ARREADY                         = 8'h4e,
    AXI4_ARCACHE_UNKN                                           = 8'h4f,
    AXI4_ARID_CHANGED_BEFORE_ARREADY                            = 8'h50,
    AXI4_ARID_UNKN                                              = 8'h51,
    AXI4_ARLEN_CHANGED_BEFORE_ARREADY                           = 8'h52,
    AXI4_ARLEN_UNKN                                             = 8'h53,
    AXI4_ARLOCK_CHANGED_BEFORE_ARREADY                          = 8'h54,
    AXI4_ARLOCK_UNKN                                            = 8'h55,
    AXI4_ARQOS_CHANGED_BEFORE_ARREADY                           = 8'h56,
    AXI4_ARQOS_UNKN                                             = 8'h57,
    AXI4_ARREGION_CHANGED_BEFORE_ARREADY                        = 8'h58,
    AXI4_ARREGION_MISMATCH                                      = 8'h59,
    AXI4_ARREGION_UNKN                                          = 8'h5a,
    AXI4_ARSIZE_CHANGED_BEFORE_ARREADY                          = 8'h5b,
    AXI4_ARSIZE_UNKN                                            = 8'h5c,
    AXI4_ARUSER_CHANGED_BEFORE_ARREADY                          = 8'h5d,
    AXI4_ARUSER_UNKN                                            = 8'h5e,
    AXI4_AWADDR_FALLS_IN_REGION_HOLE                            = 8'h5f,
    AXI4_AWBURST_CHANGED_BEFORE_AWREADY                         = 8'h60,
    AXI4_AWBURST_UNKN                                           = 8'h61,
    AXI4_AWCACHE_CHANGED_BEFORE_AWREADY                         = 8'h62,
    AXI4_AWCACHE_UNKN                                           = 8'h63,
    AXI4_AWID_CHANGED_BEFORE_AWREADY                            = 8'h64,
    AXI4_AWID_UNKN                                              = 8'h65,
    AXI4_AWLEN_CHANGED_BEFORE_AWREADY                           = 8'h66,
    AXI4_AWLEN_UNKN                                             = 8'h67,
    AXI4_AWLOCK_CHANGED_BEFORE_AWREADY                          = 8'h68,
    AXI4_AWLOCK_UNKN                                            = 8'h69,
    AXI4_AWQOS_CHANGED_BEFORE_AWREADY                           = 8'h6a,
    AXI4_AWQOS_UNKN                                             = 8'h6b,
    AXI4_AWREGION_CHANGED_BEFORE_AWREADY                        = 8'h6c,
    AXI4_AWREGION_MISMATCH                                      = 8'h6d,
    AXI4_AWREGION_UNKN                                          = 8'h6e,
    AXI4_AWSIZE_CHANGED_BEFORE_AWREADY                          = 8'h6f,
    AXI4_AWSIZE_UNKN                                            = 8'h70,
    AXI4_AWUSER_CHANGED_BEFORE_AWREADY                          = 8'h71,
    AXI4_AWUSER_UNKN                                            = 8'h72,
    AXI4_BID_CHANGED_BEFORE_BREADY                              = 8'h73,
    AXI4_BID_UNKN                                               = 8'h74,
    AXI4_BUSER_CHANGED_BEFORE_BREADY                            = 8'h75,
    AXI4_BUSER_UNKN                                             = 8'h76,
    AXI4_EXCLUSIVE_READ_ACCESS_MODIFIABLE                       = 8'h77,
    AXI4_EXCLUSIVE_READ_BYTES_TRANSFER_EXCEEDS_128              = 8'h78,
    AXI4_EXCLUSIVE_WRITE_BYTES_TRANSFER_EXCEEDS_128             = 8'h79,
    AXI4_EXCLUSIVE_READ_BYTES_TRANSFER_NOT_POWER_OF_2           = 8'h7a,
    AXI4_EXCLUSIVE_WRITE_BYTES_TRANSFER_NOT_POWER_OF_2          = 8'h7b,
    AXI4_EXCLUSIVE_READ_LENGTH_EXCEEDS_16                       = 8'h7c,
    AXI4_EXCLUSIVE_WR_ADDRESS_NOT_SAME_AS_RD                    = 8'h7d,
    AXI4_EXCLUSIVE_WR_BURST_NOT_SAME_AS_RD                      = 8'h7e,
    AXI4_EXCLUSIVE_WR_CACHE_NOT_SAME_AS_RD                      = 8'h7f,
    AXI4_EXCLUSIVE_WRITE_ACCESS_MODIFIABLE                      = 8'h80,
    AXI4_EXCLUSIVE_WR_LENGTH_NOT_SAME_AS_RD                     = 8'h81,
    AXI4_EXCLUSIVE_WR_PROT_NOT_SAME_AS_RD                       = 8'h82,
    AXI4_EXCLUSIVE_WR_REGION_NOT_SAME_AS_RD                     = 8'h83,
    AXI4_EXCLUSIVE_WR_SIZE_NOT_SAME_AS_RD                       = 8'h84,
    AXI4_EX_RD_EXOKAY_RESP_EXPECTED_OKAY                        = 8'h85,
    AXI4_EX_RD_EXOKAY_RESP_SLAVE_WITHOUT_EXCLUSIVE_ACCESS       = 8'h86,
    AXI4_EX_RD_OKAY_RESP_EXPECTED_EXOKAY                        = 8'h87,
    AXI4_EX_RD_WHEN_EX_NOT_ENABLED                              = 8'h88,
    AXI4_EX_WRITE_BEFORE_EX_READ_RESPONSE                       = 8'h89,
    AXI4_EX_WRITE_EXOKAY_RESP_EXPECTED_OKAY                     = 8'h8a,
    AXI4_EX_WRITE_EXOKAY_RESP_SLAVE_WITHOUT_EXCLUSIVE_ACCESS    = 8'h8b,
    AXI4_EX_WRITE_OKAY_RESP_EXPECTED_EXOKAY                     = 8'h8c,
    AXI4_EX_WR_WHEN_EX_NOT_ENABLED                              = 8'h8d,
    AXI4_ILLEGAL_ARCACHE_VALUE_FOR_CACHEABLE_ADDRESS_REGION     = 8'h8e,
    AXI4_ILLEGAL_ARCACHE_VALUE_FOR_NON_CACHEABLE_ADDRESS_REGION = 8'h8f,
    AXI4_ILLEGAL_AWCACHE_VALUE_FOR_CACHEABLE_ADDRESS_REGION     = 8'h90,
    AXI4_ILLEGAL_AWCACHE_VALUE_FOR_NON_CACHEABLE_ADDRESS_REGION = 8'h91,
    AXI4_ILLEGAL_LENGTH_FIXED_READ_BURST                        = 8'h92,
    AXI4_ILLEGAL_LENGTH_FIXED_WRITE_BURST                       = 8'h93,
    AXI4_ILLEGAL_LENGTH_WRAPPING_READ_BURST                     = 8'h94,
    AXI4_ILLEGAL_LENGTH_WRAPPING_WRITE_BURST                    = 8'h95,
    AXI4_ILLEGAL_RESPONSE_EXCLUSIVE_READ                        = 8'h96,
    AXI4_ILLEGAL_RESPONSE_EXCLUSIVE_WRITE                       = 8'h97,
    AXI4_INVALID_REGION_CARDINALITY                             = 8'h98,
    AXI4_INVALID_WRITE_STROBES_ON_ALIGNED_WRITE_TRANSFER        = 8'h99,
    AXI4_NON_INCREASING_REGION_SPECIFICATION                    = 8'h9a,
    AXI4_NON_ZERO_ARQOS                                         = 8'h9b,
    AXI4_NON_ZERO_AWQOS                                         = 8'h9c,
    AXI4_OVERLAPPING_REGION                                     = 8'h9d,
    AXI4_PARAM_READ_REORDERING_DEPTH_EQUALS_ZERO                = 8'h9e,
    AXI4_PARAM_READ_REORDERING_DEPTH_EXCEEDS_MAX_ID             = 8'h9f,
    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_12                   = 8'ha0,
    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_13                   = 8'ha1,
    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_4                    = 8'ha2,
    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_5                    = 8'ha3,
    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_8                    = 8'ha4,
    AXI4_READ_ALLOCATE_WHEN_NON_MODIFIABLE_9                    = 8'ha5,
    AXI4_READ_BURST_LENGTH_VIOLATION                            = 8'ha6,
    AXI4_READ_BURST_MAXIMUM_LENGTH_VIOLATION                    = 8'ha7,
    AXI4_READ_BURST_SIZE_VIOLATION                              = 8'ha8,
    AXI4_READ_EXCLUSIVE_ENCODING_VIOLATION                      = 8'ha9,
    AXI4_READ_REORDERING_VIOLATION                              = 8'haa,
    AXI4_READ_TRANSFER_EXCEEDS_ADDRESS_SPACE                    = 8'hab,
    AXI4_REGION_SMALLER_THAN_4KB                                = 8'hac,
    AXI4_RESERVED_ARBURST_ENCODING                              = 8'had,
    AXI4_RESERVED_AWBURST_ENCODING                              = 8'hae,
    AXI4_RID_CHANGED_BEFORE_RREADY                              = 8'haf,
    AXI4_RID_UNKN                                               = 8'hb0,
    AXI4_RLAST_CHANGED_BEFORE_RREADY                            = 8'hb1,
    AXI4_RLAST_UNKN                                             = 8'hb2,
    AXI4_RUSER_CHANGED_BEFORE_RREADY                            = 8'hb3,
    AXI4_RUSER_UNKN                                             = 8'hb4,
    AXI4_UNALIGNED_ADDRESS_FOR_EXCLUSIVE_READ                   = 8'hb5,
    AXI4_UNALIGNED_ADDRESS_FOR_EXCLUSIVE_WRITE                  = 8'hb6,
    AXI4_UNALIGNED_ADDR_FOR_WRAPPING_READ_BURST                 = 8'hb7,
    AXI4_UNALIGNED_ADDR_FOR_WRAPPING_WRITE_BURST                = 8'hb8,
    AXI4_WLAST_CHANGED_BEFORE_WREADY                            = 8'hb9,
    AXI4_WLAST_UNKN                                             = 8'hba,
    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_12                  = 8'hbb,
    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_13                  = 8'hbc,
    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_4                   = 8'hbd,
    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_5                   = 8'hbe,
    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_8                   = 8'hbf,
    AXI4_WRITE_ALLOCATE_WHEN_NON_MODIFIABLE_9                   = 8'hc0,
    AXI4_WRITE_BURST_LENGTH_VIOLATION                           = 8'hc1,
    AXI4_WRITE_STROBES_LENGTH_VIOLATION                         = 8'hc2,
    AXI4_WRITE_USER_DATA_LENGTH_VIOLATION                       = 8'hc3,
    AXI4_WRITE_BURST_MAXIMUM_LENGTH_VIOLATION                   = 8'hc4,
    AXI4_WRITE_BURST_SIZE_VIOLATION                             = 8'hc5,
    AXI4_WRITE_EXCLUSIVE_ENCODING_VIOLATION                     = 8'hc6,
    AXI4_WRITE_STROBE_FIXED_BURST_VIOLATION                     = 8'hc7,
    AXI4_WRITE_TRANSFER_EXCEEDS_ADDRESS_SPACE                   = 8'hc8,
    AXI4_WRONG_ARREGION_FOR_SLAVE_WITH_SINGLE_ADDRESS_DECODE    = 8'hc9,
    AXI4_WRONG_AWREGION_FOR_SLAVE_WITH_SINGLE_ADDRESS_DECODE    = 8'hca,
    AXI4_WUSER_CHANGED_BEFORE_WREADY                            = 8'hcb,
    AXI4_WUSER_UNKN                                             = 8'hcc,
    AXI4_EXCL_RD_WHILE_EXCL_WR_IN_PROGRESS_SAME_ID              = 8'hcd,
    AXI4_EXCL_WR_WHILE_EXCL_RD_IN_PROGRESS_SAME_ID              = 8'hce,
    AXI4_RLAST_VIOLATION                                        = 8'hcf,
    AXI4_WLAST_ASSERTED_DURING_DATA_PHASE_OTHER_THAN_LAST       = 8'hd0
} axi4_error_e;

//------------------------------------------------------------------------------
//
// CLASS: axi4_interface_class
//     Abstract class which defines the API to the <axi4> interface
//
//------------------------------------------------------------------------------
virtual class axi4_interface_class #(int AXI4_ADDRESS_WIDTH = 64, int AXI4_RDATA_WIDTH = 1024, int AXI4_WDATA_WIDTH = 1024, int AXI4_ID_WIDTH = 18, int AXI4_USER_WIDTH = 8, int AXI4_REGION_MAP_SIZE = 16);

    //------------------------------------------------------------------------------
    // Tasks to wait for a number of specified edges on a wire
    //------------------------------------------------------------------------------

    //------------------------------------------------------------------------------
    // Function:- wait_for_ACLK
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ACLK>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ACLK( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARESETn
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARESETn>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARESETn( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWVALID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWVALID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWVALID( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWADDR
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWADDR>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWADDR( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWADDR_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWPROT
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWPROT>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWPROT( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWPROT_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWREGION
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWREGION>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWREGION( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWREGION_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWREGION>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWREGION_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWLEN
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWLEN>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWLEN( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWLEN_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWSIZE
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWSIZE>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWSIZE( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWSIZE_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWBURST
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWBURST>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWBURST( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWBURST_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWLOCK
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWLOCK>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWLOCK( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWCACHE
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWCACHE>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWCACHE( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWCACHE_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWQOS
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWQOS>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWQOS( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWQOS_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWQOS>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWQOS_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWID( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWID_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWUSER
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWUSER>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWUSER( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWUSER_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_AWREADY
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWREADY>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_AWREADY( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARVALID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARVALID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARVALID( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARADDR
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARADDR>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARADDR( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARADDR_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARPROT
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARPROT>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARPROT( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARPROT_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARREGION
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARREGION>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARREGION( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARREGION_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARREGION>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARREGION_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARLEN
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARLEN>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARLEN( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARLEN_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARSIZE
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARSIZE>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARSIZE( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARSIZE_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARBURST
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARBURST>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARBURST( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARBURST_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARLOCK
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARLOCK>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARLOCK( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARCACHE
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARCACHE>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARCACHE( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARCACHE_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARQOS
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARQOS>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARQOS( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARQOS_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARQOS>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARQOS_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARID( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARID_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARUSER
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARUSER>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARUSER( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARUSER_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_ARREADY
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARREADY>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_ARREADY( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RVALID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RVALID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RVALID( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RDATA
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RDATA>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RDATA( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RDATA_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RRESP
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RRESP>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RRESP( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RRESP_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RLAST
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RLAST>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RLAST( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RID( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RID_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RUSER
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RUSER>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RUSER( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RUSER_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_RREADY
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RREADY>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_RREADY( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_WVALID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::WVALID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_WVALID( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_WDATA
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::WDATA>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_WDATA( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_WDATA_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::WDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_WDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_WSTRB
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::WSTRB>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_WSTRB( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_WSTRB_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::WSTRB>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_WSTRB_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_WLAST
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::WLAST>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_WLAST( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_WUSER
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::WUSER>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_WUSER( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_WUSER_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::WUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_WUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_WREADY
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::WREADY>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_WREADY( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_BVALID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::BVALID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_BVALID( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_BRESP
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::BRESP>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_BRESP( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_BRESP_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::BRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_BRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_BID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::BID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_BID( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_BID_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::BID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_BID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_BUSER
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::BUSER>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_BUSER( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_BUSER_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::BUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_BUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_BREADY
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::BREADY>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    pure virtual task automatic wait_for_BREADY( input questa_mvc_edge which_edge, input int count = 1 );

    //------------------------------------------------------------------------------
    // Tasks/functions to set/get wires
    //------------------------------------------------------------------------------

    //------------------------------------------------------------------------------
    // Function:- set_ACLK
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ACLK>.
    //
    // Parameters:
    //     ACLK_param - The value to set onto wire <axi4::ACLK>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ACLK( logic ACLK_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ACLK
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ACLK>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ACLK>.
    //
    pure virtual function automatic logic get_ACLK(  );


    //------------------------------------------------------------------------------
    // Function:- set_ARESETn
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARESETn>.
    //
    // Parameters:
    //     ARESETn_param - The value to set onto wire <axi4::ARESETn>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARESETn( logic ARESETn_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARESETn
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARESETn>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARESETn>.
    //
    pure virtual function automatic logic get_ARESETn(  );


    //------------------------------------------------------------------------------
    // Function:- set_AWVALID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWVALID>.
    //
    // Parameters:
    //     AWVALID_param - The value to set onto wire <axi4::AWVALID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWVALID( logic AWVALID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWVALID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWVALID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWVALID>.
    //
    pure virtual function automatic logic get_AWVALID(  );


    //------------------------------------------------------------------------------
    // Function:- set_AWADDR
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWADDR>.
    //
    // Parameters:
    //     AWADDR_param - The value to set onto wire <axi4::AWADDR>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWADDR( logic [((AXI4_ADDRESS_WIDTH) - 1):0]  AWADDR_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_AWADDR_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::AWADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWADDR_param - The value to set onto wire <axi4::AWADDR>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWADDR_index1( int _this_dot_1, logic  AWADDR_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWADDR
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWADDR>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWADDR>.
    //
    pure virtual function automatic logic [((AXI4_ADDRESS_WIDTH) - 1):0]   get_AWADDR(  );

    //------------------------------------------------------------------------------
    // Function:- get_AWADDR_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::AWADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::AWADDR>.
    //
    pure virtual function automatic logic   get_AWADDR_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_AWPROT
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWPROT>.
    //
    // Parameters:
    //     AWPROT_param - The value to set onto wire <axi4::AWPROT>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWPROT( logic [2:0] AWPROT_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_AWPROT_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::AWPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWPROT_param - The value to set onto wire <axi4::AWPROT>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWPROT_index1( int _this_dot_1, logic  AWPROT_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWPROT
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWPROT>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWPROT>.
    //
    pure virtual function automatic logic [2:0]  get_AWPROT(  );

    //------------------------------------------------------------------------------
    // Function:- get_AWPROT_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::AWPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::AWPROT>.
    //
    pure virtual function automatic logic   get_AWPROT_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_AWREGION
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWREGION>.
    //
    // Parameters:
    //     AWREGION_param - The value to set onto wire <axi4::AWREGION>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWREGION( logic [3:0] AWREGION_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_AWREGION_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::AWREGION>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWREGION_param - The value to set onto wire <axi4::AWREGION>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWREGION_index1( int _this_dot_1, logic  AWREGION_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWREGION
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWREGION>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWREGION>.
    //
    pure virtual function automatic logic [3:0]  get_AWREGION(  );

    //------------------------------------------------------------------------------
    // Function:- get_AWREGION_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::AWREGION>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::AWREGION>.
    //
    pure virtual function automatic logic   get_AWREGION_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_AWLEN
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWLEN>.
    //
    // Parameters:
    //     AWLEN_param - The value to set onto wire <axi4::AWLEN>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWLEN( logic [7:0] AWLEN_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_AWLEN_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::AWLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWLEN_param - The value to set onto wire <axi4::AWLEN>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWLEN_index1( int _this_dot_1, logic  AWLEN_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWLEN
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWLEN>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWLEN>.
    //
    pure virtual function automatic logic [7:0]  get_AWLEN(  );

    //------------------------------------------------------------------------------
    // Function:- get_AWLEN_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::AWLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::AWLEN>.
    //
    pure virtual function automatic logic   get_AWLEN_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_AWSIZE
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWSIZE>.
    //
    // Parameters:
    //     AWSIZE_param - The value to set onto wire <axi4::AWSIZE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWSIZE( logic [2:0] AWSIZE_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_AWSIZE_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::AWSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWSIZE_param - The value to set onto wire <axi4::AWSIZE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWSIZE_index1( int _this_dot_1, logic  AWSIZE_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWSIZE
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWSIZE>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWSIZE>.
    //
    pure virtual function automatic logic [2:0]  get_AWSIZE(  );

    //------------------------------------------------------------------------------
    // Function:- get_AWSIZE_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::AWSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::AWSIZE>.
    //
    pure virtual function automatic logic   get_AWSIZE_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_AWBURST
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWBURST>.
    //
    // Parameters:
    //     AWBURST_param - The value to set onto wire <axi4::AWBURST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWBURST( logic [1:0] AWBURST_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_AWBURST_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::AWBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWBURST_param - The value to set onto wire <axi4::AWBURST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWBURST_index1( int _this_dot_1, logic  AWBURST_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWBURST
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWBURST>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWBURST>.
    //
    pure virtual function automatic logic [1:0]  get_AWBURST(  );

    //------------------------------------------------------------------------------
    // Function:- get_AWBURST_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::AWBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::AWBURST>.
    //
    pure virtual function automatic logic   get_AWBURST_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_AWLOCK
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWLOCK>.
    //
    // Parameters:
    //     AWLOCK_param - The value to set onto wire <axi4::AWLOCK>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWLOCK( logic AWLOCK_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWLOCK
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWLOCK>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWLOCK>.
    //
    pure virtual function automatic logic get_AWLOCK(  );


    //------------------------------------------------------------------------------
    // Function:- set_AWCACHE
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWCACHE>.
    //
    // Parameters:
    //     AWCACHE_param - The value to set onto wire <axi4::AWCACHE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWCACHE( logic [3:0] AWCACHE_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_AWCACHE_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::AWCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWCACHE_param - The value to set onto wire <axi4::AWCACHE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWCACHE_index1( int _this_dot_1, logic  AWCACHE_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWCACHE
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWCACHE>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWCACHE>.
    //
    pure virtual function automatic logic [3:0]  get_AWCACHE(  );

    //------------------------------------------------------------------------------
    // Function:- get_AWCACHE_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::AWCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::AWCACHE>.
    //
    pure virtual function automatic logic   get_AWCACHE_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_AWQOS
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWQOS>.
    //
    // Parameters:
    //     AWQOS_param - The value to set onto wire <axi4::AWQOS>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWQOS( logic [3:0] AWQOS_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_AWQOS_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::AWQOS>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWQOS_param - The value to set onto wire <axi4::AWQOS>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWQOS_index1( int _this_dot_1, logic  AWQOS_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWQOS
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWQOS>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWQOS>.
    //
    pure virtual function automatic logic [3:0]  get_AWQOS(  );

    //------------------------------------------------------------------------------
    // Function:- get_AWQOS_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::AWQOS>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::AWQOS>.
    //
    pure virtual function automatic logic   get_AWQOS_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_AWID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWID>.
    //
    // Parameters:
    //     AWID_param - The value to set onto wire <axi4::AWID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWID( logic [((AXI4_ID_WIDTH) - 1):0]  AWID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_AWID_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::AWID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWID_param - The value to set onto wire <axi4::AWID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWID_index1( int _this_dot_1, logic  AWID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWID>.
    //
    pure virtual function automatic logic [((AXI4_ID_WIDTH) - 1):0]   get_AWID(  );

    //------------------------------------------------------------------------------
    // Function:- get_AWID_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::AWID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::AWID>.
    //
    pure virtual function automatic logic   get_AWID_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_AWUSER
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWUSER>.
    //
    // Parameters:
    //     AWUSER_param - The value to set onto wire <axi4::AWUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWUSER( logic [((AXI4_USER_WIDTH) - 1):0]  AWUSER_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_AWUSER_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::AWUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWUSER_param - The value to set onto wire <axi4::AWUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWUSER_index1( int _this_dot_1, logic  AWUSER_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWUSER
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWUSER>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWUSER>.
    //
    pure virtual function automatic logic [((AXI4_USER_WIDTH) - 1):0]   get_AWUSER(  );

    //------------------------------------------------------------------------------
    // Function:- get_AWUSER_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::AWUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::AWUSER>.
    //
    pure virtual function automatic logic   get_AWUSER_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_AWREADY
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWREADY>.
    //
    // Parameters:
    //     AWREADY_param - The value to set onto wire <axi4::AWREADY>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_AWREADY( logic AWREADY_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_AWREADY
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWREADY>.
    //
    pure virtual function automatic logic get_AWREADY(  );


    //------------------------------------------------------------------------------
    // Function:- set_ARVALID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARVALID>.
    //
    // Parameters:
    //     ARVALID_param - The value to set onto wire <axi4::ARVALID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARVALID( logic ARVALID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARVALID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARVALID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARVALID>.
    //
    pure virtual function automatic logic get_ARVALID(  );


    //------------------------------------------------------------------------------
    // Function:- set_ARADDR
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARADDR>.
    //
    // Parameters:
    //     ARADDR_param - The value to set onto wire <axi4::ARADDR>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARADDR( logic [((AXI4_ADDRESS_WIDTH) - 1):0]  ARADDR_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_ARADDR_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::ARADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARADDR_param - The value to set onto wire <axi4::ARADDR>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARADDR_index1( int _this_dot_1, logic  ARADDR_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARADDR
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARADDR>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARADDR>.
    //
    pure virtual function automatic logic [((AXI4_ADDRESS_WIDTH) - 1):0]   get_ARADDR(  );

    //------------------------------------------------------------------------------
    // Function:- get_ARADDR_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::ARADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::ARADDR>.
    //
    pure virtual function automatic logic   get_ARADDR_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_ARPROT
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARPROT>.
    //
    // Parameters:
    //     ARPROT_param - The value to set onto wire <axi4::ARPROT>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARPROT( logic [2:0] ARPROT_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_ARPROT_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::ARPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARPROT_param - The value to set onto wire <axi4::ARPROT>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARPROT_index1( int _this_dot_1, logic  ARPROT_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARPROT
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARPROT>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARPROT>.
    //
    pure virtual function automatic logic [2:0]  get_ARPROT(  );

    //------------------------------------------------------------------------------
    // Function:- get_ARPROT_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::ARPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::ARPROT>.
    //
    pure virtual function automatic logic   get_ARPROT_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_ARREGION
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARREGION>.
    //
    // Parameters:
    //     ARREGION_param - The value to set onto wire <axi4::ARREGION>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARREGION( logic [3:0] ARREGION_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_ARREGION_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::ARREGION>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARREGION_param - The value to set onto wire <axi4::ARREGION>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARREGION_index1( int _this_dot_1, logic  ARREGION_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARREGION
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARREGION>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARREGION>.
    //
    pure virtual function automatic logic [3:0]  get_ARREGION(  );

    //------------------------------------------------------------------------------
    // Function:- get_ARREGION_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::ARREGION>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::ARREGION>.
    //
    pure virtual function automatic logic   get_ARREGION_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_ARLEN
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARLEN>.
    //
    // Parameters:
    //     ARLEN_param - The value to set onto wire <axi4::ARLEN>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARLEN( logic [7:0] ARLEN_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_ARLEN_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::ARLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARLEN_param - The value to set onto wire <axi4::ARLEN>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARLEN_index1( int _this_dot_1, logic  ARLEN_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARLEN
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARLEN>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARLEN>.
    //
    pure virtual function automatic logic [7:0]  get_ARLEN(  );

    //------------------------------------------------------------------------------
    // Function:- get_ARLEN_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::ARLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::ARLEN>.
    //
    pure virtual function automatic logic   get_ARLEN_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_ARSIZE
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARSIZE>.
    //
    // Parameters:
    //     ARSIZE_param - The value to set onto wire <axi4::ARSIZE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARSIZE( logic [2:0] ARSIZE_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_ARSIZE_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::ARSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARSIZE_param - The value to set onto wire <axi4::ARSIZE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARSIZE_index1( int _this_dot_1, logic  ARSIZE_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARSIZE
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARSIZE>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARSIZE>.
    //
    pure virtual function automatic logic [2:0]  get_ARSIZE(  );

    //------------------------------------------------------------------------------
    // Function:- get_ARSIZE_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::ARSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::ARSIZE>.
    //
    pure virtual function automatic logic   get_ARSIZE_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_ARBURST
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARBURST>.
    //
    // Parameters:
    //     ARBURST_param - The value to set onto wire <axi4::ARBURST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARBURST( logic [1:0] ARBURST_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_ARBURST_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::ARBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARBURST_param - The value to set onto wire <axi4::ARBURST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARBURST_index1( int _this_dot_1, logic  ARBURST_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARBURST
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARBURST>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARBURST>.
    //
    pure virtual function automatic logic [1:0]  get_ARBURST(  );

    //------------------------------------------------------------------------------
    // Function:- get_ARBURST_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::ARBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::ARBURST>.
    //
    pure virtual function automatic logic   get_ARBURST_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_ARLOCK
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARLOCK>.
    //
    // Parameters:
    //     ARLOCK_param - The value to set onto wire <axi4::ARLOCK>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARLOCK( logic ARLOCK_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARLOCK
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARLOCK>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARLOCK>.
    //
    pure virtual function automatic logic get_ARLOCK(  );


    //------------------------------------------------------------------------------
    // Function:- set_ARCACHE
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARCACHE>.
    //
    // Parameters:
    //     ARCACHE_param - The value to set onto wire <axi4::ARCACHE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARCACHE( logic [3:0] ARCACHE_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_ARCACHE_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::ARCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARCACHE_param - The value to set onto wire <axi4::ARCACHE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARCACHE_index1( int _this_dot_1, logic  ARCACHE_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARCACHE
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARCACHE>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARCACHE>.
    //
    pure virtual function automatic logic [3:0]  get_ARCACHE(  );

    //------------------------------------------------------------------------------
    // Function:- get_ARCACHE_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::ARCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::ARCACHE>.
    //
    pure virtual function automatic logic   get_ARCACHE_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_ARQOS
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARQOS>.
    //
    // Parameters:
    //     ARQOS_param - The value to set onto wire <axi4::ARQOS>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARQOS( logic [3:0] ARQOS_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_ARQOS_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::ARQOS>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARQOS_param - The value to set onto wire <axi4::ARQOS>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARQOS_index1( int _this_dot_1, logic  ARQOS_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARQOS
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARQOS>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARQOS>.
    //
    pure virtual function automatic logic [3:0]  get_ARQOS(  );

    //------------------------------------------------------------------------------
    // Function:- get_ARQOS_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::ARQOS>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::ARQOS>.
    //
    pure virtual function automatic logic   get_ARQOS_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_ARID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARID>.
    //
    // Parameters:
    //     ARID_param - The value to set onto wire <axi4::ARID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARID( logic [((AXI4_ID_WIDTH) - 1):0]  ARID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_ARID_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::ARID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARID_param - The value to set onto wire <axi4::ARID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARID_index1( int _this_dot_1, logic  ARID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARID>.
    //
    pure virtual function automatic logic [((AXI4_ID_WIDTH) - 1):0]   get_ARID(  );

    //------------------------------------------------------------------------------
    // Function:- get_ARID_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::ARID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::ARID>.
    //
    pure virtual function automatic logic   get_ARID_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_ARUSER
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARUSER>.
    //
    // Parameters:
    //     ARUSER_param - The value to set onto wire <axi4::ARUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARUSER( logic [((AXI4_USER_WIDTH) - 1):0]  ARUSER_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_ARUSER_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::ARUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARUSER_param - The value to set onto wire <axi4::ARUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARUSER_index1( int _this_dot_1, logic  ARUSER_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARUSER
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARUSER>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARUSER>.
    //
    pure virtual function automatic logic [((AXI4_USER_WIDTH) - 1):0]   get_ARUSER(  );

    //------------------------------------------------------------------------------
    // Function:- get_ARUSER_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::ARUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::ARUSER>.
    //
    pure virtual function automatic logic   get_ARUSER_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_ARREADY
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARREADY>.
    //
    // Parameters:
    //     ARREADY_param - The value to set onto wire <axi4::ARREADY>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_ARREADY( logic ARREADY_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_ARREADY
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARREADY>.
    //
    pure virtual function automatic logic get_ARREADY(  );


    //------------------------------------------------------------------------------
    // Function:- set_RVALID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::RVALID>.
    //
    // Parameters:
    //     RVALID_param - The value to set onto wire <axi4::RVALID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RVALID( logic RVALID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_RVALID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::RVALID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::RVALID>.
    //
    pure virtual function automatic logic get_RVALID(  );


    //------------------------------------------------------------------------------
    // Function:- set_RDATA
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::RDATA>.
    //
    // Parameters:
    //     RDATA_param - The value to set onto wire <axi4::RDATA>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RDATA( logic [((AXI4_RDATA_WIDTH) - 1):0]  RDATA_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_RDATA_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::RDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     RDATA_param - The value to set onto wire <axi4::RDATA>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RDATA_index1( int _this_dot_1, logic  RDATA_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_RDATA
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::RDATA>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::RDATA>.
    //
    pure virtual function automatic logic [((AXI4_RDATA_WIDTH) - 1):0]   get_RDATA(  );

    //------------------------------------------------------------------------------
    // Function:- get_RDATA_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::RDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::RDATA>.
    //
    pure virtual function automatic logic   get_RDATA_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_RRESP
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::RRESP>.
    //
    // Parameters:
    //     RRESP_param - The value to set onto wire <axi4::RRESP>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RRESP( logic [1:0] RRESP_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_RRESP_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::RRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     RRESP_param - The value to set onto wire <axi4::RRESP>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RRESP_index1( int _this_dot_1, logic  RRESP_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_RRESP
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::RRESP>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::RRESP>.
    //
    pure virtual function automatic logic [1:0]  get_RRESP(  );

    //------------------------------------------------------------------------------
    // Function:- get_RRESP_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::RRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::RRESP>.
    //
    pure virtual function automatic logic   get_RRESP_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_RLAST
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::RLAST>.
    //
    // Parameters:
    //     RLAST_param - The value to set onto wire <axi4::RLAST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RLAST( logic RLAST_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_RLAST
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::RLAST>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::RLAST>.
    //
    pure virtual function automatic logic get_RLAST(  );


    //------------------------------------------------------------------------------
    // Function:- set_RID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::RID>.
    //
    // Parameters:
    //     RID_param - The value to set onto wire <axi4::RID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RID( logic [((AXI4_ID_WIDTH) - 1):0]  RID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_RID_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::RID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     RID_param - The value to set onto wire <axi4::RID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RID_index1( int _this_dot_1, logic  RID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_RID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::RID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::RID>.
    //
    pure virtual function automatic logic [((AXI4_ID_WIDTH) - 1):0]   get_RID(  );

    //------------------------------------------------------------------------------
    // Function:- get_RID_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::RID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::RID>.
    //
    pure virtual function automatic logic   get_RID_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_RUSER
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::RUSER>.
    //
    // Parameters:
    //     RUSER_param - The value to set onto wire <axi4::RUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RUSER( logic [((AXI4_USER_WIDTH) - 1):0]  RUSER_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_RUSER_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::RUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     RUSER_param - The value to set onto wire <axi4::RUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RUSER_index1( int _this_dot_1, logic  RUSER_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_RUSER
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::RUSER>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::RUSER>.
    //
    pure virtual function automatic logic [((AXI4_USER_WIDTH) - 1):0]   get_RUSER(  );

    //------------------------------------------------------------------------------
    // Function:- get_RUSER_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::RUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::RUSER>.
    //
    pure virtual function automatic logic   get_RUSER_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_RREADY
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::RREADY>.
    //
    // Parameters:
    //     RREADY_param - The value to set onto wire <axi4::RREADY>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_RREADY( logic RREADY_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_RREADY
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::RREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::RREADY>.
    //
    pure virtual function automatic logic get_RREADY(  );


    //------------------------------------------------------------------------------
    // Function:- set_WVALID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::WVALID>.
    //
    // Parameters:
    //     WVALID_param - The value to set onto wire <axi4::WVALID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_WVALID( logic WVALID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_WVALID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::WVALID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::WVALID>.
    //
    pure virtual function automatic logic get_WVALID(  );


    //------------------------------------------------------------------------------
    // Function:- set_WDATA
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::WDATA>.
    //
    // Parameters:
    //     WDATA_param - The value to set onto wire <axi4::WDATA>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_WDATA( logic [((AXI4_WDATA_WIDTH) - 1):0]  WDATA_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_WDATA_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::WDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     WDATA_param - The value to set onto wire <axi4::WDATA>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_WDATA_index1( int _this_dot_1, logic  WDATA_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_WDATA
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::WDATA>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::WDATA>.
    //
    pure virtual function automatic logic [((AXI4_WDATA_WIDTH) - 1):0]   get_WDATA(  );

    //------------------------------------------------------------------------------
    // Function:- get_WDATA_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::WDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::WDATA>.
    //
    pure virtual function automatic logic   get_WDATA_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_WSTRB
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::WSTRB>.
    //
    // Parameters:
    //     WSTRB_param - The value to set onto wire <axi4::WSTRB>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_WSTRB( logic [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  WSTRB_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_WSTRB_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::WSTRB>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     WSTRB_param - The value to set onto wire <axi4::WSTRB>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_WSTRB_index1( int _this_dot_1, logic  WSTRB_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_WSTRB
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::WSTRB>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::WSTRB>.
    //
    pure virtual function automatic logic [(((AXI4_WDATA_WIDTH / 8)) - 1):0]   get_WSTRB(  );

    //------------------------------------------------------------------------------
    // Function:- get_WSTRB_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::WSTRB>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::WSTRB>.
    //
    pure virtual function automatic logic   get_WSTRB_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_WLAST
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::WLAST>.
    //
    // Parameters:
    //     WLAST_param - The value to set onto wire <axi4::WLAST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_WLAST( logic WLAST_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_WLAST
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::WLAST>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::WLAST>.
    //
    pure virtual function automatic logic get_WLAST(  );


    //------------------------------------------------------------------------------
    // Function:- set_WUSER
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::WUSER>.
    //
    // Parameters:
    //     WUSER_param - The value to set onto wire <axi4::WUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_WUSER( logic [((AXI4_USER_WIDTH) - 1):0]  WUSER_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_WUSER_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::WUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     WUSER_param - The value to set onto wire <axi4::WUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_WUSER_index1( int _this_dot_1, logic  WUSER_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_WUSER
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::WUSER>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::WUSER>.
    //
    pure virtual function automatic logic [((AXI4_USER_WIDTH) - 1):0]   get_WUSER(  );

    //------------------------------------------------------------------------------
    // Function:- get_WUSER_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::WUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::WUSER>.
    //
    pure virtual function automatic logic   get_WUSER_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_WREADY
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::WREADY>.
    //
    // Parameters:
    //     WREADY_param - The value to set onto wire <axi4::WREADY>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_WREADY( logic WREADY_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_WREADY
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::WREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::WREADY>.
    //
    pure virtual function automatic logic get_WREADY(  );


    //------------------------------------------------------------------------------
    // Function:- set_BVALID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::BVALID>.
    //
    // Parameters:
    //     BVALID_param - The value to set onto wire <axi4::BVALID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_BVALID( logic BVALID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_BVALID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::BVALID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::BVALID>.
    //
    pure virtual function automatic logic get_BVALID(  );


    //------------------------------------------------------------------------------
    // Function:- set_BRESP
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::BRESP>.
    //
    // Parameters:
    //     BRESP_param - The value to set onto wire <axi4::BRESP>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_BRESP( logic [1:0] BRESP_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_BRESP_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::BRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     BRESP_param - The value to set onto wire <axi4::BRESP>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_BRESP_index1( int _this_dot_1, logic  BRESP_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_BRESP
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::BRESP>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::BRESP>.
    //
    pure virtual function automatic logic [1:0]  get_BRESP(  );

    //------------------------------------------------------------------------------
    // Function:- get_BRESP_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::BRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::BRESP>.
    //
    pure virtual function automatic logic   get_BRESP_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_BID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::BID>.
    //
    // Parameters:
    //     BID_param - The value to set onto wire <axi4::BID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_BID( logic [((AXI4_ID_WIDTH) - 1):0]  BID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_BID_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::BID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     BID_param - The value to set onto wire <axi4::BID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_BID_index1( int _this_dot_1, logic  BID_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_BID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::BID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::BID>.
    //
    pure virtual function automatic logic [((AXI4_ID_WIDTH) - 1):0]   get_BID(  );

    //------------------------------------------------------------------------------
    // Function:- get_BID_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::BID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::BID>.
    //
    pure virtual function automatic logic   get_BID_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_BUSER
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::BUSER>.
    //
    // Parameters:
    //     BUSER_param - The value to set onto wire <axi4::BUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_BUSER( logic [((AXI4_USER_WIDTH) - 1):0]  BUSER_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- set_BUSER_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::BUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     BUSER_param - The value to set onto wire <axi4::BUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_BUSER_index1( int _this_dot_1, logic  BUSER_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_BUSER
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::BUSER>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::BUSER>.
    //
    pure virtual function automatic logic [((AXI4_USER_WIDTH) - 1):0]   get_BUSER(  );

    //------------------------------------------------------------------------------
    // Function:- get_BUSER_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::BUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::BUSER>.
    //
    pure virtual function automatic logic   get_BUSER_index1( int _this_dot_1 );


    //------------------------------------------------------------------------------
    // Function:- set_BREADY
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::BREADY>.
    //
    // Parameters:
    //     BREADY_param - The value to set onto wire <axi4::BREADY>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    pure virtual task automatic set_BREADY( logic BREADY_param = 'z, bit non_blocking = 1'b0 );

    //------------------------------------------------------------------------------
    // Function:- get_BREADY
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::BREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::BREADY>.
    //
    pure virtual function automatic logic get_BREADY(  );


    //------------------------------------------------------------------------------
    // Tasks to wait for a change to a global variable with read access
    //------------------------------------------------------------------------------

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_interface_type
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_interface_type>.
    //
    pure virtual task automatic wait_for_config_interface_type(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_clk_init_value
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_clk_init_value>.
    //
    pure virtual task automatic wait_for_config_clk_init_value(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_clk_phase_shift
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_clk_phase_shift>.
    //
    pure virtual task automatic wait_for_config_clk_phase_shift(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_clk_1st_time
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_clk_1st_time>.
    //
    pure virtual task automatic wait_for_config_clk_1st_time(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_clk_2nd_time
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_clk_2nd_time>.
    //
    pure virtual task automatic wait_for_config_clk_2nd_time(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_setup_time
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_setup_time>.
    //
    pure virtual task automatic wait_for_config_setup_time(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_hold_time
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_hold_time>.
    //
    pure virtual task automatic wait_for_config_hold_time(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_burst_timeout_factor
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_burst_timeout_factor>.
    //
    pure virtual task automatic wait_for_config_burst_timeout_factor(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_transaction_time_factor
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_max_transaction_time_factor>.
    //
    pure virtual task automatic wait_for_config_max_transaction_time_factor(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_write_ctrl_first_ratio
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_write_ctrl_first_ratio>.
    //
    pure virtual task automatic wait_for_config_write_ctrl_first_ratio(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_write_data_first_ratio
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_write_data_first_ratio>.
    //
    pure virtual task automatic wait_for_config_write_data_first_ratio(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_reset_low_clocks
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_reset_low_clocks>.
    //
    pure virtual task automatic wait_for_config_reset_low_clocks(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_reset_hold_time
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_reset_hold_time>.
    //
    pure virtual task automatic wait_for_config_reset_hold_time(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_rlast
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_rlast>.
    //
    pure virtual task automatic wait_for_config_enable_rlast(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_slave_exclusive
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_slave_exclusive>.
    //
    pure virtual task automatic wait_for_config_enable_slave_exclusive(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_burst_reserved_value
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_burst_reserved_value>.
    //
    pure virtual task automatic wait_for_config_enable_burst_reserved_value(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_cache_value
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_cache_value>.
    //
    pure virtual task automatic wait_for_config_enable_cache_value(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_cache_value_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_cache_value>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_config_enable_cache_value_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_internal_dummy_variable
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::internal_dummy_variable>.
    //
    pure virtual task automatic wait_for_internal_dummy_variable(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_axi4lite_interface
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_axi4lite_interface>.
    //
    pure virtual task automatic wait_for_config_axi4lite_interface(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_axi4lite_tr_id
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_axi4lite_tr_id>.
    //
    pure virtual task automatic wait_for_config_axi4lite_tr_id(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_axi4lite_tr_id_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_axi4lite_tr_id>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_config_axi4lite_tr_id_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_all_assertions
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_all_assertions>.
    //
    pure virtual task automatic wait_for_config_enable_all_assertions(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_assertion
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_assertion>.
    //
    pure virtual task automatic wait_for_config_enable_assertion(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_assertion_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_assertion>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_config_enable_assertion_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_error
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_error>.
    //
    pure virtual task automatic wait_for_config_enable_error(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_error_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_error>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_config_enable_error_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_latency_AWVALID_assertion_to_AWREADY
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_max_latency_AWVALID_assertion_to_AWREADY>.
    //
    pure virtual task automatic wait_for_config_max_latency_AWVALID_assertion_to_AWREADY(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_latency_ARVALID_assertion_to_ARREADY
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_max_latency_ARVALID_assertion_to_ARREADY>.
    //
    pure virtual task automatic wait_for_config_max_latency_ARVALID_assertion_to_ARREADY(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_latency_RVALID_assertion_to_RREADY
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_max_latency_RVALID_assertion_to_RREADY>.
    //
    pure virtual task automatic wait_for_config_max_latency_RVALID_assertion_to_RREADY(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_latency_BVALID_assertion_to_BREADY
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_max_latency_BVALID_assertion_to_BREADY>.
    //
    pure virtual task automatic wait_for_config_max_latency_BVALID_assertion_to_BREADY(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_latency_WVALID_assertion_to_WREADY
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_max_latency_WVALID_assertion_to_WREADY>.
    //
    pure virtual task automatic wait_for_config_max_latency_WVALID_assertion_to_WREADY(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_qos
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_qos>.
    //
    pure virtual task automatic wait_for_config_enable_qos(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_region_support
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_region_support>.
    //
    pure virtual task automatic wait_for_config_enable_region_support(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_regions
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_regions>.
    //
    pure virtual task automatic wait_for_config_slave_regions(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_region
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_region>.
    //
    pure virtual task automatic wait_for_config_region(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_region_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_region>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_config_region_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_region_index2
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_region>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //    _this_dot_2 - The array index for dimension 2.
    //
    pure virtual task automatic wait_for_config_region_index2( input int _this_dot_1, input int _this_dot_2 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_region_error_state
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::region_error_state>.
    //
    pure virtual task automatic wait_for_region_error_state(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_region_map_lb
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::region_map_lb>.
    //
    pure virtual task automatic wait_for_region_map_lb(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_region_map_lb_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::region_map_lb>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_region_map_lb_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_region_map_ub
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::region_map_ub>.
    //
    pure virtual task automatic wait_for_region_map_ub(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_region_map_ub_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::region_map_ub>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_region_map_ub_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_region_map_region
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::region_map_region>.
    //
    pure virtual task automatic wait_for_region_map_region(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_region_map_region_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::region_map_region>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_region_map_region_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_cacheable
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::cacheable>.
    //
    pure virtual task automatic wait_for_cacheable(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_cacheable_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::cacheable>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_cacheable_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_read_data_reordering_depth
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_read_data_reordering_depth>.
    //
    pure virtual task automatic wait_for_config_read_data_reordering_depth(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_start_addr
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_start_addr>.
    //
    pure virtual task automatic wait_for_config_slave_start_addr(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_start_addr_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_start_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_config_slave_start_addr_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_end_addr
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_end_addr>.
    //
    pure virtual task automatic wait_for_config_slave_end_addr(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_end_addr_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_end_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_config_slave_end_addr_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_enabled_non_contiguous_address_spaces
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_enabled_non_contiguous_address_spaces>.
    //
    pure virtual task automatic wait_for_config_slave_enabled_non_contiguous_address_spaces(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_possess_multiple_non_contiguous_address_spaces
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_possess_multiple_non_contiguous_address_spaces>.
    //
    pure virtual task automatic wait_for_config_slave_possess_multiple_non_contiguous_address_spaces(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_multiple_non_contiguous_start_address_range
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    pure virtual task automatic wait_for_config_slave_multiple_non_contiguous_start_address_range(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_multiple_non_contiguous_start_address_range_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_config_slave_multiple_non_contiguous_start_address_range_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_multiple_non_contiguous_start_address_range_index2
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //    _this_dot_2 - The array index for dimension 2.
    //
    pure virtual task automatic wait_for_config_slave_multiple_non_contiguous_start_address_range_index2( input int _this_dot_1, input int _this_dot_2 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_multiple_non_contiguous_end_address_range
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    pure virtual task automatic wait_for_config_slave_multiple_non_contiguous_end_address_range(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_multiple_non_contiguous_end_address_range_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    pure virtual task automatic wait_for_config_slave_multiple_non_contiguous_end_address_range_index1( input int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_multiple_non_contiguous_end_address_range_index2
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //    _this_dot_2 - The array index for dimension 2.
    //
    pure virtual task automatic wait_for_config_slave_multiple_non_contiguous_end_address_range_index2( input int _this_dot_1, input int _this_dot_2 );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_protect_ready
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_protect_ready>.
    //
    pure virtual task automatic wait_for_config_protect_ready(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_master_end_tlm_status
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::master_end_tlm_status>.
    //
    pure virtual task automatic wait_for_master_end_tlm_status(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_master_end_wlm_status
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::master_end_wlm_status>.
    //
    pure virtual task automatic wait_for_master_end_wlm_status(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_slave_end_tlm_status
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::slave_end_tlm_status>.
    //
    pure virtual task automatic wait_for_slave_end_tlm_status(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_slave_end_wlm_status
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::slave_end_wlm_status>.
    //
    pure virtual task automatic wait_for_slave_end_wlm_status(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_clock_source_end_tlm_status
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::clock_source_end_tlm_status>.
    //
    pure virtual task automatic wait_for_clock_source_end_tlm_status(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_clock_source_end_wlm_status
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::clock_source_end_wlm_status>.
    //
    pure virtual task automatic wait_for_clock_source_end_wlm_status(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_reset_source_end_tlm_status
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::reset_source_end_tlm_status>.
    //
    pure virtual task automatic wait_for_reset_source_end_tlm_status(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_reset_source_end_wlm_status
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::reset_source_end_wlm_status>.
    //
    pure virtual task automatic wait_for_reset_source_end_wlm_status(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_outstanding_wr
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_max_outstanding_wr>.
    //
    pure virtual task automatic wait_for_config_max_outstanding_wr(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_outstanding_rd
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_max_outstanding_rd>.
    //
    pure virtual task automatic wait_for_config_max_outstanding_rd(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_num_outstanding_wr_phase
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_num_outstanding_wr_phase>.
    //
    pure virtual task automatic wait_for_config_num_outstanding_wr_phase(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_num_outstanding_rd_phase
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_num_outstanding_rd_phase>.
    //
    pure virtual task automatic wait_for_config_num_outstanding_rd_phase(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_warnings
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_warnings>.
    //
    pure virtual task automatic wait_for_config_enable_warnings(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_errors
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_errors>.
    //
    pure virtual task automatic wait_for_config_enable_errors(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_exclusive_checks
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_exclusive_checks>.
    //
    pure virtual task automatic wait_for_config_enable_exclusive_checks(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_warn_on_slave_errors
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_warn_on_slave_errors>.
    //
    pure virtual task automatic wait_for_config_warn_on_slave_errors(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_error_on_deleted_valid_cycles
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_error_on_deleted_valid_cycles>.
    //
    pure virtual task automatic wait_for_config_error_on_deleted_valid_cycles(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable>.
    //
    pure virtual task automatic wait_for_config_stats_enable(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_occupancy
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_read_occupancy>.
    //
    pure virtual task automatic wait_for_config_stats_enable_read_occupancy(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_occupancy
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_write_occupancy>.
    //
    pure virtual task automatic wait_for_config_stats_enable_write_occupancy(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_data_occupancy
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_read_data_occupancy>.
    //
    pure virtual task automatic wait_for_config_stats_enable_read_data_occupancy(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_data_occupancy
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_write_data_occupancy>.
    //
    pure virtual task automatic wait_for_config_stats_enable_write_data_occupancy(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_latency
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_read_latency>.
    //
    pure virtual task automatic wait_for_config_stats_enable_read_latency(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_latency
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_write_latency>.
    //
    pure virtual task automatic wait_for_config_stats_enable_write_latency(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_address_waits
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_read_address_waits>.
    //
    pure virtual task automatic wait_for_config_stats_enable_read_address_waits(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_data_waits
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_read_data_waits>.
    //
    pure virtual task automatic wait_for_config_stats_enable_read_data_waits(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_address_waits
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_write_address_waits>.
    //
    pure virtual task automatic wait_for_config_stats_enable_write_address_waits(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_data_waits
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_write_data_waits>.
    //
    pure virtual task automatic wait_for_config_stats_enable_write_data_waits(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_response_waits
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_write_response_waits>.
    //
    pure virtual task automatic wait_for_config_stats_enable_write_response_waits(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_bandwidth
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_read_bandwidth>.
    //
    pure virtual task automatic wait_for_config_stats_enable_read_bandwidth(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_bandwidth
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_write_bandwidth>.
    //
    pure virtual task automatic wait_for_config_stats_enable_write_bandwidth(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_rw_transaction_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_rw_transaction_last_duration>.
    //
    pure virtual task automatic wait_for_stats_rw_transaction_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_occupancy_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_occupancy_step>.
    //
    pure virtual task automatic wait_for_config_stats_read_occupancy_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_occupancy_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_read_occupancy_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_active
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_active>.
    //
    pure virtual task automatic wait_for_stats_read_active(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_occupancy_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_occupancy_sw>.
    //
    pure virtual task automatic wait_for_stats_read_occupancy_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_idle_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_idle_sw>.
    //
    pure virtual task automatic wait_for_stats_read_idle_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_occupancy_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_occupancy_min>.
    //
    pure virtual task automatic wait_for_stats_read_occupancy_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_idle_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_idle_min>.
    //
    pure virtual task automatic wait_for_stats_read_idle_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_occupancy_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_occupancy_max>.
    //
    pure virtual task automatic wait_for_stats_read_occupancy_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_idle_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_idle_max>.
    //
    pure virtual task automatic wait_for_stats_read_idle_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_occupancy_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_occupancy_mean>.
    //
    pure virtual task automatic wait_for_stats_read_occupancy_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_idle_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_idle_mean>.
    //
    pure virtual task automatic wait_for_stats_read_idle_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_last_duration>.
    //
    pure virtual task automatic wait_for_stats_read_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_occupancy_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_occupancy_step>.
    //
    pure virtual task automatic wait_for_config_stats_write_occupancy_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_occupancy_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_write_occupancy_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_active
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_active>.
    //
    pure virtual task automatic wait_for_stats_write_active(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_occupancy_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_occupancy_sw>.
    //
    pure virtual task automatic wait_for_stats_write_occupancy_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_idle_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_idle_sw>.
    //
    pure virtual task automatic wait_for_stats_write_idle_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_occupancy_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_occupancy_min>.
    //
    pure virtual task automatic wait_for_stats_write_occupancy_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_idle_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_idle_min>.
    //
    pure virtual task automatic wait_for_stats_write_idle_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_occupancy_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_occupancy_max>.
    //
    pure virtual task automatic wait_for_stats_write_occupancy_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_idle_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_idle_max>.
    //
    pure virtual task automatic wait_for_stats_write_idle_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_occupancy_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_occupancy_mean>.
    //
    pure virtual task automatic wait_for_stats_write_occupancy_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_idle_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_idle_mean>.
    //
    pure virtual task automatic wait_for_stats_write_idle_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_last_duration>.
    //
    pure virtual task automatic wait_for_stats_write_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_data_occupancy_step>.
    //
    pure virtual task automatic wait_for_config_stats_read_data_occupancy_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_data_occupancy_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_read_data_occupancy_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_occupancy_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_occupancy_sw>.
    //
    pure virtual task automatic wait_for_stats_read_data_occupancy_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_idle_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_idle_sw>.
    //
    pure virtual task automatic wait_for_stats_read_data_idle_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_occupancy_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_occupancy_min>.
    //
    pure virtual task automatic wait_for_stats_read_data_occupancy_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_idle_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_idle_min>.
    //
    pure virtual task automatic wait_for_stats_read_data_idle_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_occupancy_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_occupancy_max>.
    //
    pure virtual task automatic wait_for_stats_read_data_occupancy_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_idle_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_idle_max>.
    //
    pure virtual task automatic wait_for_stats_read_data_idle_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_occupancy_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_occupancy_mean>.
    //
    pure virtual task automatic wait_for_stats_read_data_occupancy_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_idle_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_idle_mean>.
    //
    pure virtual task automatic wait_for_stats_read_data_idle_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_data_occupancy_step>.
    //
    pure virtual task automatic wait_for_config_stats_write_data_occupancy_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_data_occupancy_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_write_data_occupancy_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_occupancy_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_occupancy_sw>.
    //
    pure virtual task automatic wait_for_stats_write_data_occupancy_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_idle_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_idle_sw>.
    //
    pure virtual task automatic wait_for_stats_write_data_idle_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_occupancy_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_occupancy_min>.
    //
    pure virtual task automatic wait_for_stats_write_data_occupancy_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_idle_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_idle_min>.
    //
    pure virtual task automatic wait_for_stats_write_data_idle_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_occupancy_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_occupancy_max>.
    //
    pure virtual task automatic wait_for_stats_write_data_occupancy_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_idle_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_idle_max>.
    //
    pure virtual task automatic wait_for_stats_write_data_idle_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_occupancy_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_occupancy_mean>.
    //
    pure virtual task automatic wait_for_stats_write_data_occupancy_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_idle_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_idle_mean>.
    //
    pure virtual task automatic wait_for_stats_write_data_idle_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_bandwidth_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_bandwidth_step>.
    //
    pure virtual task automatic wait_for_config_stats_read_bandwidth_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_bandwidth_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_read_bandwidth_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_bandwidth_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_bandwidth_sw>.
    //
    pure virtual task automatic wait_for_stats_read_bandwidth_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_bandwidth_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_bandwidth_min>.
    //
    pure virtual task automatic wait_for_stats_read_bandwidth_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_bandwidth_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_bandwidth_max>.
    //
    pure virtual task automatic wait_for_stats_read_bandwidth_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_bandwidth_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_bandwidth_mean>.
    //
    pure virtual task automatic wait_for_stats_read_bandwidth_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_bandwidth_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_bandwidth_step>.
    //
    pure virtual task automatic wait_for_config_stats_write_bandwidth_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_bandwidth_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_write_bandwidth_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_bandwidth_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_bandwidth_sw>.
    //
    pure virtual task automatic wait_for_stats_write_bandwidth_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_bandwidth_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_bandwidth_min>.
    //
    pure virtual task automatic wait_for_stats_write_bandwidth_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_bandwidth_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_bandwidth_max>.
    //
    pure virtual task automatic wait_for_stats_write_bandwidth_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_bandwidth_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_bandwidth_mean>.
    //
    pure virtual task automatic wait_for_stats_write_bandwidth_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_latency_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_latency_step>.
    //
    pure virtual task automatic wait_for_config_stats_read_latency_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_latency_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_latency_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_read_latency_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_data_latency_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_data_latency_inst>.
    //
    pure virtual task automatic wait_for_stats_read_address_data_latency_inst(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_data_latency_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_data_latency_sw>.
    //
    pure virtual task automatic wait_for_stats_read_address_data_latency_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_data_latency_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_data_latency_min>.
    //
    pure virtual task automatic wait_for_stats_read_address_data_latency_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_data_latency_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_data_latency_max>.
    //
    pure virtual task automatic wait_for_stats_read_address_data_latency_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_data_latency_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_data_latency_mean>.
    //
    pure virtual task automatic wait_for_stats_read_address_data_latency_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_address_latency_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_address_latency_inst>.
    //
    pure virtual task automatic wait_for_stats_read_address_address_latency_inst(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_address_latency_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_address_latency_sw>.
    //
    pure virtual task automatic wait_for_stats_read_address_address_latency_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_address_latency_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_address_latency_min>.
    //
    pure virtual task automatic wait_for_stats_read_address_address_latency_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_address_latency_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_address_latency_max>.
    //
    pure virtual task automatic wait_for_stats_read_address_address_latency_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_address_latency_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_address_latency_mean>.
    //
    pure virtual task automatic wait_for_stats_read_address_address_latency_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_latency_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_latency_step>.
    //
    pure virtual task automatic wait_for_config_stats_write_latency_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_latency_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_latency_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_write_latency_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_response_latency_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_response_latency_inst>.
    //
    pure virtual task automatic wait_for_stats_write_address_response_latency_inst(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_response_latency_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_response_latency_sw>.
    //
    pure virtual task automatic wait_for_stats_write_address_response_latency_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_response_latency_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_response_latency_min>.
    //
    pure virtual task automatic wait_for_stats_write_address_response_latency_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_response_latency_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_response_latency_max>.
    //
    pure virtual task automatic wait_for_stats_write_address_response_latency_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_response_latency_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_response_latency_mean>.
    //
    pure virtual task automatic wait_for_stats_write_address_response_latency_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_address_latency_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_address_latency_inst>.
    //
    pure virtual task automatic wait_for_stats_write_address_address_latency_inst(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_address_latency_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_address_latency_sw>.
    //
    pure virtual task automatic wait_for_stats_write_address_address_latency_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_address_latency_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_address_latency_min>.
    //
    pure virtual task automatic wait_for_stats_write_address_address_latency_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_address_latency_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_address_latency_max>.
    //
    pure virtual task automatic wait_for_stats_write_address_address_latency_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_address_latency_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_address_latency_mean>.
    //
    pure virtual task automatic wait_for_stats_write_address_address_latency_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_address_waits_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_address_waits_step>.
    //
    pure virtual task automatic wait_for_config_stats_read_address_waits_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_address_waits_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_read_address_waits_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_waits_inst>.
    //
    pure virtual task automatic wait_for_stats_read_address_waits_inst(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_waits_sw>.
    //
    pure virtual task automatic wait_for_stats_read_address_waits_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_waits_min>.
    //
    pure virtual task automatic wait_for_stats_read_address_waits_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_waits_max>.
    //
    pure virtual task automatic wait_for_stats_read_address_waits_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_waits_mean>.
    //
    pure virtual task automatic wait_for_stats_read_address_waits_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_data_waits_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_data_waits_step>.
    //
    pure virtual task automatic wait_for_config_stats_read_data_waits_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_data_waits_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_read_data_waits_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_waits_inst>.
    //
    pure virtual task automatic wait_for_stats_read_data_waits_inst(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_waits_sw>.
    //
    pure virtual task automatic wait_for_stats_read_data_waits_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_waits_min>.
    //
    pure virtual task automatic wait_for_stats_read_data_waits_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_waits_max>.
    //
    pure virtual task automatic wait_for_stats_read_data_waits_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_waits_mean>.
    //
    pure virtual task automatic wait_for_stats_read_data_waits_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_address_waits_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_address_waits_step>.
    //
    pure virtual task automatic wait_for_config_stats_write_address_waits_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_address_waits_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_write_address_waits_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_waits_inst>.
    //
    pure virtual task automatic wait_for_stats_write_address_waits_inst(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_waits_sw>.
    //
    pure virtual task automatic wait_for_stats_write_address_waits_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_waits_min>.
    //
    pure virtual task automatic wait_for_stats_write_address_waits_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_waits_max>.
    //
    pure virtual task automatic wait_for_stats_write_address_waits_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_waits_mean>.
    //
    pure virtual task automatic wait_for_stats_write_address_waits_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_data_waits_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_data_waits_step>.
    //
    pure virtual task automatic wait_for_config_stats_write_data_waits_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_data_waits_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_write_data_waits_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_waits_inst>.
    //
    pure virtual task automatic wait_for_stats_write_data_waits_inst(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_waits_sw>.
    //
    pure virtual task automatic wait_for_stats_write_data_waits_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_waits_min>.
    //
    pure virtual task automatic wait_for_stats_write_data_waits_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_waits_max>.
    //
    pure virtual task automatic wait_for_stats_write_data_waits_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_waits_mean>.
    //
    pure virtual task automatic wait_for_stats_write_data_waits_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_response_waits_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_response_waits_step>.
    //
    pure virtual task automatic wait_for_config_stats_write_response_waits_step(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_response_waits_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_response_waits_multiple>.
    //
    pure virtual task automatic wait_for_config_stats_write_response_waits_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_response_waits_inst>.
    //
    pure virtual task automatic wait_for_stats_write_response_waits_inst(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_response_waits_sw>.
    //
    pure virtual task automatic wait_for_stats_write_response_waits_sw(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_response_waits_min>.
    //
    pure virtual task automatic wait_for_stats_write_response_waits_min(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_response_waits_max>.
    //
    pure virtual task automatic wait_for_stats_write_response_waits_max(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_response_waits_mean>.
    //
    pure virtual task automatic wait_for_stats_write_response_waits_mean(  );

    //------------------------------------------------------------------------------
    // Function:- wait_for_reordering_depth_of_last_read_transaction
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::reordering_depth_of_last_read_transaction>.
    //
    pure virtual task automatic wait_for_reordering_depth_of_last_read_transaction(  );

    //------------------------------------------------------------------------------
    // Functions to set global variables with write access
    //------------------------------------------------------------------------------

    //------------------------------------------------------------------------------
    // Function:- set_config_interface_type
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_interface_type>.
    //
    // Parameters:
    //     config_interface_type_param - The value to assign to variable <axi4::config_interface_type>.
    //
    pure virtual function automatic void set_config_interface_type( axi4_interface_type_e config_interface_type_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_clk_init_value
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_clk_init_value>.
    //
    // Parameters:
    //     config_clk_init_value_param - The value to assign to variable <axi4::config_clk_init_value>.
    //
    pure virtual function automatic void set_config_clk_init_value( bit config_clk_init_value_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_clk_phase_shift
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_clk_phase_shift>.
    //
    // Parameters:
    //     config_clk_phase_shift_param - The value to assign to variable <axi4::config_clk_phase_shift>.
    //
    pure virtual function automatic void set_config_clk_phase_shift( longint unsigned config_clk_phase_shift_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_clk_1st_time
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_clk_1st_time>.
    //
    // Parameters:
    //     config_clk_1st_time_param - The value to assign to variable <axi4::config_clk_1st_time>.
    //
    pure virtual function automatic void set_config_clk_1st_time( longint unsigned config_clk_1st_time_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_clk_2nd_time
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_clk_2nd_time>.
    //
    // Parameters:
    //     config_clk_2nd_time_param - The value to assign to variable <axi4::config_clk_2nd_time>.
    //
    pure virtual function automatic void set_config_clk_2nd_time( longint unsigned config_clk_2nd_time_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_setup_time
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_setup_time>.
    //
    // Parameters:
    //     config_setup_time_param - The value to assign to variable <axi4::config_setup_time>.
    //
    pure virtual function automatic void set_config_setup_time( longint unsigned config_setup_time_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_hold_time
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_hold_time>.
    //
    // Parameters:
    //     config_hold_time_param - The value to assign to variable <axi4::config_hold_time>.
    //
    pure virtual function automatic void set_config_hold_time( longint unsigned config_hold_time_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_burst_timeout_factor
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_burst_timeout_factor>.
    //
    // Parameters:
    //     config_burst_timeout_factor_param - The value to assign to variable <axi4::config_burst_timeout_factor>.
    //
    pure virtual function automatic void set_config_burst_timeout_factor( int unsigned config_burst_timeout_factor_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_max_transaction_time_factor
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_max_transaction_time_factor>.
    //
    // Parameters:
    //     config_max_transaction_time_factor_param - The value to assign to variable <axi4::config_max_transaction_time_factor>.
    //
    pure virtual function automatic void set_config_max_transaction_time_factor( int unsigned config_max_transaction_time_factor_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_write_ctrl_first_ratio
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_write_ctrl_first_ratio>.
    //
    // Parameters:
    //     config_write_ctrl_first_ratio_param - The value to assign to variable <axi4::config_write_ctrl_first_ratio>.
    //
    pure virtual function automatic void set_config_write_ctrl_first_ratio( int config_write_ctrl_first_ratio_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_write_data_first_ratio
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_write_data_first_ratio>.
    //
    // Parameters:
    //     config_write_data_first_ratio_param - The value to assign to variable <axi4::config_write_data_first_ratio>.
    //
    pure virtual function automatic void set_config_write_data_first_ratio( int config_write_data_first_ratio_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_reset_low_clocks
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_reset_low_clocks>.
    //
    // Parameters:
    //     config_reset_low_clocks_param - The value to assign to variable <axi4::config_reset_low_clocks>.
    //
    pure virtual function automatic void set_config_reset_low_clocks( int config_reset_low_clocks_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_reset_hold_time
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_reset_hold_time>.
    //
    // Parameters:
    //     config_reset_hold_time_param - The value to assign to variable <axi4::config_reset_hold_time>.
    //
    pure virtual function automatic void set_config_reset_hold_time( int config_reset_hold_time_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_rlast
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_rlast>.
    //
    // Parameters:
    //     config_enable_rlast_param - The value to assign to variable <axi4::config_enable_rlast>.
    //
    pure virtual function automatic void set_config_enable_rlast( bit config_enable_rlast_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_slave_exclusive
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_slave_exclusive>.
    //
    // Parameters:
    //     config_enable_slave_exclusive_param - The value to assign to variable <axi4::config_enable_slave_exclusive>.
    //
    pure virtual function automatic void set_config_enable_slave_exclusive( bit config_enable_slave_exclusive_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_burst_reserved_value
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_burst_reserved_value>.
    //
    // Parameters:
    //     config_enable_burst_reserved_value_param - The value to assign to variable <axi4::config_enable_burst_reserved_value>.
    //
    pure virtual function automatic void set_config_enable_burst_reserved_value( bit config_enable_burst_reserved_value_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_cache_value
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_cache_value>.
    //
    // Parameters:
    //     config_enable_cache_value_param - The value to assign to variable <axi4::config_enable_cache_value>.
    //
    pure virtual function automatic void set_config_enable_cache_value( bit [15:0] config_enable_cache_value_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_cache_value_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_enable_cache_value>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_enable_cache_value_param - The value to assign to variable <axi4::config_enable_cache_value>.
    //
    pure virtual function automatic void set_config_enable_cache_value_index1( int _this_dot_1, bit  config_enable_cache_value_param );

    //------------------------------------------------------------------------------
    // Function:- set_internal_dummy_variable
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::internal_dummy_variable>.
    //
    // Parameters:
    //     internal_dummy_variable_param - The value to assign to variable <axi4::internal_dummy_variable>.
    //
    pure virtual function automatic void set_internal_dummy_variable( axi4_error_e internal_dummy_variable_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_axi4lite_interface
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_axi4lite_interface>.
    //
    // Parameters:
    //     config_axi4lite_interface_param - The value to assign to variable <axi4::config_axi4lite_interface>.
    //
    pure virtual function automatic void set_config_axi4lite_interface( bit config_axi4lite_interface_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_axi4lite_tr_id
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_axi4lite_tr_id>.
    //
    // Parameters:
    //     config_axi4lite_tr_id_param - The value to assign to variable <axi4::config_axi4lite_tr_id>.
    //
    pure virtual function automatic void set_config_axi4lite_tr_id( bit [((AXI4_ID_WIDTH) - 1):0]  config_axi4lite_tr_id_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_axi4lite_tr_id_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_axi4lite_tr_id>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_axi4lite_tr_id_param - The value to assign to variable <axi4::config_axi4lite_tr_id>.
    //
    pure virtual function automatic void set_config_axi4lite_tr_id_index1( int _this_dot_1, bit  config_axi4lite_tr_id_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_all_assertions
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_all_assertions>.
    //
    // Parameters:
    //     config_enable_all_assertions_param - The value to assign to variable <axi4::config_enable_all_assertions>.
    //
    pure virtual function automatic void set_config_enable_all_assertions( bit config_enable_all_assertions_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_assertion
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_assertion>.
    //
    // Parameters:
    //     config_enable_assertion_param - The value to assign to variable <axi4::config_enable_assertion>.
    //
    pure virtual function automatic void set_config_enable_assertion( bit [255:0] config_enable_assertion_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_assertion_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_enable_assertion>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_enable_assertion_param - The value to assign to variable <axi4::config_enable_assertion>.
    //
    pure virtual function automatic void set_config_enable_assertion_index1( int _this_dot_1, bit  config_enable_assertion_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_error
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_error>.
    //
    // Parameters:
    //     config_enable_error_param - The value to assign to variable <axi4::config_enable_error>.
    //
    pure virtual function automatic void set_config_enable_error( bit [255:0] config_enable_error_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_error_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_enable_error>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_enable_error_param - The value to assign to variable <axi4::config_enable_error>.
    //
    pure virtual function automatic void set_config_enable_error_index1( int _this_dot_1, bit  config_enable_error_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_max_latency_AWVALID_assertion_to_AWREADY
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_max_latency_AWVALID_assertion_to_AWREADY>.
    //
    // Parameters:
    //     config_max_latency_AWVALID_assertion_to_AWREADY_param - The value to assign to variable <axi4::config_max_latency_AWVALID_assertion_to_AWREADY>.
    //
    pure virtual function automatic void set_config_max_latency_AWVALID_assertion_to_AWREADY( int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_max_latency_ARVALID_assertion_to_ARREADY
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_max_latency_ARVALID_assertion_to_ARREADY>.
    //
    // Parameters:
    //     config_max_latency_ARVALID_assertion_to_ARREADY_param - The value to assign to variable <axi4::config_max_latency_ARVALID_assertion_to_ARREADY>.
    //
    pure virtual function automatic void set_config_max_latency_ARVALID_assertion_to_ARREADY( int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_max_latency_RVALID_assertion_to_RREADY
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_max_latency_RVALID_assertion_to_RREADY>.
    //
    // Parameters:
    //     config_max_latency_RVALID_assertion_to_RREADY_param - The value to assign to variable <axi4::config_max_latency_RVALID_assertion_to_RREADY>.
    //
    pure virtual function automatic void set_config_max_latency_RVALID_assertion_to_RREADY( int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_max_latency_BVALID_assertion_to_BREADY
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_max_latency_BVALID_assertion_to_BREADY>.
    //
    // Parameters:
    //     config_max_latency_BVALID_assertion_to_BREADY_param - The value to assign to variable <axi4::config_max_latency_BVALID_assertion_to_BREADY>.
    //
    pure virtual function automatic void set_config_max_latency_BVALID_assertion_to_BREADY( int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_max_latency_WVALID_assertion_to_WREADY
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_max_latency_WVALID_assertion_to_WREADY>.
    //
    // Parameters:
    //     config_max_latency_WVALID_assertion_to_WREADY_param - The value to assign to variable <axi4::config_max_latency_WVALID_assertion_to_WREADY>.
    //
    pure virtual function automatic void set_config_max_latency_WVALID_assertion_to_WREADY( int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_qos
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_qos>.
    //
    // Parameters:
    //     config_enable_qos_param - The value to assign to variable <axi4::config_enable_qos>.
    //
    pure virtual function automatic void set_config_enable_qos( bit config_enable_qos_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_region_support
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_region_support>.
    //
    // Parameters:
    //     config_enable_region_support_param - The value to assign to variable <axi4::config_enable_region_support>.
    //
    pure virtual function automatic void set_config_enable_region_support( bit config_enable_region_support_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_slave_regions
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_slave_regions>.
    //
    // Parameters:
    //     config_slave_regions_param - The value to assign to variable <axi4::config_slave_regions>.
    //
    pure virtual function automatic void set_config_slave_regions( int config_slave_regions_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_region
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_region>.
    //
    // Parameters:
    //     config_region_param - The value to assign to variable <axi4::config_region>.
    //
    pure virtual function automatic void set_config_region( bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  config_region_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_region_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_region>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_region_param - The value to assign to variable <axi4::config_region>.
    //
    pure virtual function automatic void set_config_region_index1( int _this_dot_1, bit [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  config_region_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_region_index2
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_region>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //    _this_dot_2 - The array index for dimension 2.
    //     config_region_param - The value to assign to variable <axi4::config_region>.
    //
    pure virtual function automatic void set_config_region_index2( int _this_dot_1, int _this_dot_2, bit  config_region_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_read_data_reordering_depth
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_read_data_reordering_depth>.
    //
    // Parameters:
    //     config_read_data_reordering_depth_param - The value to assign to variable <axi4::config_read_data_reordering_depth>.
    //
    pure virtual function automatic void set_config_read_data_reordering_depth( int unsigned config_read_data_reordering_depth_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_slave_start_addr
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_slave_start_addr>.
    //
    // Parameters:
    //     config_slave_start_addr_param - The value to assign to variable <axi4::config_slave_start_addr>.
    //
    pure virtual function automatic void set_config_slave_start_addr( bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_slave_start_addr_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_slave_start_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_slave_start_addr_param - The value to assign to variable <axi4::config_slave_start_addr>.
    //
    pure virtual function automatic void set_config_slave_start_addr_index1( int _this_dot_1, bit  config_slave_start_addr_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_slave_end_addr
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_slave_end_addr>.
    //
    // Parameters:
    //     config_slave_end_addr_param - The value to assign to variable <axi4::config_slave_end_addr>.
    //
    pure virtual function automatic void set_config_slave_end_addr( bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_slave_end_addr_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_slave_end_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_slave_end_addr_param - The value to assign to variable <axi4::config_slave_end_addr>.
    //
    pure virtual function automatic void set_config_slave_end_addr_index1( int _this_dot_1, bit  config_slave_end_addr_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_slave_enabled_non_contiguous_address_spaces
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_slave_enabled_non_contiguous_address_spaces>.
    //
    // Parameters:
    //     config_slave_enabled_non_contiguous_address_spaces_param - The value to assign to variable <axi4::config_slave_enabled_non_contiguous_address_spaces>.
    //
    pure virtual function automatic void set_config_slave_enabled_non_contiguous_address_spaces( int config_slave_enabled_non_contiguous_address_spaces_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_slave_possess_multiple_non_contiguous_address_spaces
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_slave_possess_multiple_non_contiguous_address_spaces>.
    //
    // Parameters:
    //     config_slave_possess_multiple_non_contiguous_address_spaces_param - The value to assign to variable <axi4::config_slave_possess_multiple_non_contiguous_address_spaces>.
    //
    pure virtual function automatic void set_config_slave_possess_multiple_non_contiguous_address_spaces( bit config_slave_possess_multiple_non_contiguous_address_spaces_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_slave_multiple_non_contiguous_start_address_range
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    // Parameters:
    //     config_slave_multiple_non_contiguous_start_address_range_param - The value to assign to variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    pure virtual function automatic void set_config_slave_multiple_non_contiguous_start_address_range( bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_start_address_range_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_slave_multiple_non_contiguous_start_address_range_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_slave_multiple_non_contiguous_start_address_range_param - The value to assign to variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    pure virtual function automatic void set_config_slave_multiple_non_contiguous_start_address_range_index1( int _this_dot_1, bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_start_address_range_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_slave_multiple_non_contiguous_start_address_range_index2
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //    _this_dot_2 - The array index for dimension 2.
    //     config_slave_multiple_non_contiguous_start_address_range_param - The value to assign to variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    pure virtual function automatic void set_config_slave_multiple_non_contiguous_start_address_range_index2( int _this_dot_1, int _this_dot_2, bit  config_slave_multiple_non_contiguous_start_address_range_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_slave_multiple_non_contiguous_end_address_range
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    // Parameters:
    //     config_slave_multiple_non_contiguous_end_address_range_param - The value to assign to variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    pure virtual function automatic void set_config_slave_multiple_non_contiguous_end_address_range( bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_end_address_range_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_slave_multiple_non_contiguous_end_address_range_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_slave_multiple_non_contiguous_end_address_range_param - The value to assign to variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    pure virtual function automatic void set_config_slave_multiple_non_contiguous_end_address_range_index1( int _this_dot_1, bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_end_address_range_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_slave_multiple_non_contiguous_end_address_range_index2
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //    _this_dot_2 - The array index for dimension 2.
    //     config_slave_multiple_non_contiguous_end_address_range_param - The value to assign to variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    pure virtual function automatic void set_config_slave_multiple_non_contiguous_end_address_range_index2( int _this_dot_1, int _this_dot_2, bit  config_slave_multiple_non_contiguous_end_address_range_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_protect_ready
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_protect_ready>.
    //
    // Parameters:
    //     config_protect_ready_param - The value to assign to variable <axi4::config_protect_ready>.
    //
    pure virtual function automatic void set_config_protect_ready( bit config_protect_ready_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_max_outstanding_wr
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_max_outstanding_wr>.
    //
    // Parameters:
    //     config_max_outstanding_wr_param - The value to assign to variable <axi4::config_max_outstanding_wr>.
    //
    pure virtual function automatic void set_config_max_outstanding_wr( int config_max_outstanding_wr_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_max_outstanding_rd
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_max_outstanding_rd>.
    //
    // Parameters:
    //     config_max_outstanding_rd_param - The value to assign to variable <axi4::config_max_outstanding_rd>.
    //
    pure virtual function automatic void set_config_max_outstanding_rd( int config_max_outstanding_rd_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_num_outstanding_wr_phase
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_num_outstanding_wr_phase>.
    //
    // Parameters:
    //     config_num_outstanding_wr_phase_param - The value to assign to variable <axi4::config_num_outstanding_wr_phase>.
    //
    pure virtual function automatic void set_config_num_outstanding_wr_phase( int config_num_outstanding_wr_phase_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_num_outstanding_rd_phase
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_num_outstanding_rd_phase>.
    //
    // Parameters:
    //     config_num_outstanding_rd_phase_param - The value to assign to variable <axi4::config_num_outstanding_rd_phase>.
    //
    pure virtual function automatic void set_config_num_outstanding_rd_phase( int config_num_outstanding_rd_phase_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_warnings
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_warnings>.
    //
    // Parameters:
    //     config_enable_warnings_param - The value to assign to variable <axi4::config_enable_warnings>.
    //
    pure virtual function automatic void set_config_enable_warnings( bit config_enable_warnings_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_errors
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_errors>.
    //
    // Parameters:
    //     config_enable_errors_param - The value to assign to variable <axi4::config_enable_errors>.
    //
    pure virtual function automatic void set_config_enable_errors( bit config_enable_errors_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_enable_exclusive_checks
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_exclusive_checks>.
    //
    // Parameters:
    //     config_enable_exclusive_checks_param - The value to assign to variable <axi4::config_enable_exclusive_checks>.
    //
    pure virtual function automatic void set_config_enable_exclusive_checks( bit config_enable_exclusive_checks_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_warn_on_slave_errors
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_warn_on_slave_errors>.
    //
    // Parameters:
    //     config_warn_on_slave_errors_param - The value to assign to variable <axi4::config_warn_on_slave_errors>.
    //
    pure virtual function automatic void set_config_warn_on_slave_errors( bit config_warn_on_slave_errors_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_error_on_deleted_valid_cycles
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_error_on_deleted_valid_cycles>.
    //
    // Parameters:
    //     config_error_on_deleted_valid_cycles_param - The value to assign to variable <axi4::config_error_on_deleted_valid_cycles>.
    //
    pure virtual function automatic void set_config_error_on_deleted_valid_cycles( bit config_error_on_deleted_valid_cycles_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable>.
    //
    // Parameters:
    //     config_stats_enable_param - The value to assign to variable <axi4::config_stats_enable>.
    //
    pure virtual function automatic void set_config_stats_enable( bit config_stats_enable_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_occupancy
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_read_occupancy>.
    //
    // Parameters:
    //     config_stats_enable_read_occupancy_param - The value to assign to variable <axi4::config_stats_enable_read_occupancy>.
    //
    pure virtual function automatic void set_config_stats_enable_read_occupancy( bit config_stats_enable_read_occupancy_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_occupancy
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_write_occupancy>.
    //
    // Parameters:
    //     config_stats_enable_write_occupancy_param - The value to assign to variable <axi4::config_stats_enable_write_occupancy>.
    //
    pure virtual function automatic void set_config_stats_enable_write_occupancy( bit config_stats_enable_write_occupancy_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_data_occupancy
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_read_data_occupancy>.
    //
    // Parameters:
    //     config_stats_enable_read_data_occupancy_param - The value to assign to variable <axi4::config_stats_enable_read_data_occupancy>.
    //
    pure virtual function automatic void set_config_stats_enable_read_data_occupancy( bit config_stats_enable_read_data_occupancy_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_data_occupancy
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_write_data_occupancy>.
    //
    // Parameters:
    //     config_stats_enable_write_data_occupancy_param - The value to assign to variable <axi4::config_stats_enable_write_data_occupancy>.
    //
    pure virtual function automatic void set_config_stats_enable_write_data_occupancy( bit config_stats_enable_write_data_occupancy_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_latency
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_read_latency>.
    //
    // Parameters:
    //     config_stats_enable_read_latency_param - The value to assign to variable <axi4::config_stats_enable_read_latency>.
    //
    pure virtual function automatic void set_config_stats_enable_read_latency( bit config_stats_enable_read_latency_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_latency
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_write_latency>.
    //
    // Parameters:
    //     config_stats_enable_write_latency_param - The value to assign to variable <axi4::config_stats_enable_write_latency>.
    //
    pure virtual function automatic void set_config_stats_enable_write_latency( bit config_stats_enable_write_latency_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_address_waits
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_read_address_waits>.
    //
    // Parameters:
    //     config_stats_enable_read_address_waits_param - The value to assign to variable <axi4::config_stats_enable_read_address_waits>.
    //
    pure virtual function automatic void set_config_stats_enable_read_address_waits( bit config_stats_enable_read_address_waits_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_data_waits
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_read_data_waits>.
    //
    // Parameters:
    //     config_stats_enable_read_data_waits_param - The value to assign to variable <axi4::config_stats_enable_read_data_waits>.
    //
    pure virtual function automatic void set_config_stats_enable_read_data_waits( bit config_stats_enable_read_data_waits_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_address_waits
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_write_address_waits>.
    //
    // Parameters:
    //     config_stats_enable_write_address_waits_param - The value to assign to variable <axi4::config_stats_enable_write_address_waits>.
    //
    pure virtual function automatic void set_config_stats_enable_write_address_waits( bit config_stats_enable_write_address_waits_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_data_waits
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_write_data_waits>.
    //
    // Parameters:
    //     config_stats_enable_write_data_waits_param - The value to assign to variable <axi4::config_stats_enable_write_data_waits>.
    //
    pure virtual function automatic void set_config_stats_enable_write_data_waits( bit config_stats_enable_write_data_waits_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_response_waits
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_write_response_waits>.
    //
    // Parameters:
    //     config_stats_enable_write_response_waits_param - The value to assign to variable <axi4::config_stats_enable_write_response_waits>.
    //
    pure virtual function automatic void set_config_stats_enable_write_response_waits( bit config_stats_enable_write_response_waits_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_bandwidth
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_read_bandwidth>.
    //
    // Parameters:
    //     config_stats_enable_read_bandwidth_param - The value to assign to variable <axi4::config_stats_enable_read_bandwidth>.
    //
    pure virtual function automatic void set_config_stats_enable_read_bandwidth( bit config_stats_enable_read_bandwidth_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_bandwidth
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_write_bandwidth>.
    //
    // Parameters:
    //     config_stats_enable_write_bandwidth_param - The value to assign to variable <axi4::config_stats_enable_write_bandwidth>.
    //
    pure virtual function automatic void set_config_stats_enable_write_bandwidth( bit config_stats_enable_write_bandwidth_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_occupancy_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_occupancy_step>.
    //
    // Parameters:
    //     config_stats_read_occupancy_step_param - The value to assign to variable <axi4::config_stats_read_occupancy_step>.
    //
    pure virtual function automatic void set_config_stats_read_occupancy_step( int config_stats_read_occupancy_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_occupancy_multiple>.
    //
    // Parameters:
    //     config_stats_read_occupancy_multiple_param - The value to assign to variable <axi4::config_stats_read_occupancy_multiple>.
    //
    pure virtual function automatic void set_config_stats_read_occupancy_multiple( int config_stats_read_occupancy_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_occupancy_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_occupancy_step>.
    //
    // Parameters:
    //     config_stats_write_occupancy_step_param - The value to assign to variable <axi4::config_stats_write_occupancy_step>.
    //
    pure virtual function automatic void set_config_stats_write_occupancy_step( int config_stats_write_occupancy_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_occupancy_multiple>.
    //
    // Parameters:
    //     config_stats_write_occupancy_multiple_param - The value to assign to variable <axi4::config_stats_write_occupancy_multiple>.
    //
    pure virtual function automatic void set_config_stats_write_occupancy_multiple( int config_stats_write_occupancy_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_data_occupancy_step>.
    //
    // Parameters:
    //     config_stats_read_data_occupancy_step_param - The value to assign to variable <axi4::config_stats_read_data_occupancy_step>.
    //
    pure virtual function automatic void set_config_stats_read_data_occupancy_step( int config_stats_read_data_occupancy_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_data_occupancy_multiple>.
    //
    // Parameters:
    //     config_stats_read_data_occupancy_multiple_param - The value to assign to variable <axi4::config_stats_read_data_occupancy_multiple>.
    //
    pure virtual function automatic void set_config_stats_read_data_occupancy_multiple( int config_stats_read_data_occupancy_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_data_occupancy_step>.
    //
    // Parameters:
    //     config_stats_write_data_occupancy_step_param - The value to assign to variable <axi4::config_stats_write_data_occupancy_step>.
    //
    pure virtual function automatic void set_config_stats_write_data_occupancy_step( int config_stats_write_data_occupancy_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_data_occupancy_multiple>.
    //
    // Parameters:
    //     config_stats_write_data_occupancy_multiple_param - The value to assign to variable <axi4::config_stats_write_data_occupancy_multiple>.
    //
    pure virtual function automatic void set_config_stats_write_data_occupancy_multiple( int config_stats_write_data_occupancy_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_bandwidth_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_bandwidth_step>.
    //
    // Parameters:
    //     config_stats_read_bandwidth_step_param - The value to assign to variable <axi4::config_stats_read_bandwidth_step>.
    //
    pure virtual function automatic void set_config_stats_read_bandwidth_step( int config_stats_read_bandwidth_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_bandwidth_multiple>.
    //
    // Parameters:
    //     config_stats_read_bandwidth_multiple_param - The value to assign to variable <axi4::config_stats_read_bandwidth_multiple>.
    //
    pure virtual function automatic void set_config_stats_read_bandwidth_multiple( int config_stats_read_bandwidth_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_bandwidth_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_bandwidth_step>.
    //
    // Parameters:
    //     config_stats_write_bandwidth_step_param - The value to assign to variable <axi4::config_stats_write_bandwidth_step>.
    //
    pure virtual function automatic void set_config_stats_write_bandwidth_step( int config_stats_write_bandwidth_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_bandwidth_multiple>.
    //
    // Parameters:
    //     config_stats_write_bandwidth_multiple_param - The value to assign to variable <axi4::config_stats_write_bandwidth_multiple>.
    //
    pure virtual function automatic void set_config_stats_write_bandwidth_multiple( int config_stats_write_bandwidth_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_latency_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_latency_step>.
    //
    // Parameters:
    //     config_stats_read_latency_step_param - The value to assign to variable <axi4::config_stats_read_latency_step>.
    //
    pure virtual function automatic void set_config_stats_read_latency_step( int config_stats_read_latency_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_latency_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_latency_multiple>.
    //
    // Parameters:
    //     config_stats_read_latency_multiple_param - The value to assign to variable <axi4::config_stats_read_latency_multiple>.
    //
    pure virtual function automatic void set_config_stats_read_latency_multiple( int config_stats_read_latency_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_latency_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_latency_step>.
    //
    // Parameters:
    //     config_stats_write_latency_step_param - The value to assign to variable <axi4::config_stats_write_latency_step>.
    //
    pure virtual function automatic void set_config_stats_write_latency_step( int config_stats_write_latency_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_latency_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_latency_multiple>.
    //
    // Parameters:
    //     config_stats_write_latency_multiple_param - The value to assign to variable <axi4::config_stats_write_latency_multiple>.
    //
    pure virtual function automatic void set_config_stats_write_latency_multiple( int config_stats_write_latency_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_address_waits_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_address_waits_step>.
    //
    // Parameters:
    //     config_stats_read_address_waits_step_param - The value to assign to variable <axi4::config_stats_read_address_waits_step>.
    //
    pure virtual function automatic void set_config_stats_read_address_waits_step( int config_stats_read_address_waits_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_address_waits_multiple>.
    //
    // Parameters:
    //     config_stats_read_address_waits_multiple_param - The value to assign to variable <axi4::config_stats_read_address_waits_multiple>.
    //
    pure virtual function automatic void set_config_stats_read_address_waits_multiple( int config_stats_read_address_waits_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_data_waits_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_data_waits_step>.
    //
    // Parameters:
    //     config_stats_read_data_waits_step_param - The value to assign to variable <axi4::config_stats_read_data_waits_step>.
    //
    pure virtual function automatic void set_config_stats_read_data_waits_step( int config_stats_read_data_waits_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_data_waits_multiple>.
    //
    // Parameters:
    //     config_stats_read_data_waits_multiple_param - The value to assign to variable <axi4::config_stats_read_data_waits_multiple>.
    //
    pure virtual function automatic void set_config_stats_read_data_waits_multiple( int config_stats_read_data_waits_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_address_waits_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_address_waits_step>.
    //
    // Parameters:
    //     config_stats_write_address_waits_step_param - The value to assign to variable <axi4::config_stats_write_address_waits_step>.
    //
    pure virtual function automatic void set_config_stats_write_address_waits_step( int config_stats_write_address_waits_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_address_waits_multiple>.
    //
    // Parameters:
    //     config_stats_write_address_waits_multiple_param - The value to assign to variable <axi4::config_stats_write_address_waits_multiple>.
    //
    pure virtual function automatic void set_config_stats_write_address_waits_multiple( int config_stats_write_address_waits_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_data_waits_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_data_waits_step>.
    //
    // Parameters:
    //     config_stats_write_data_waits_step_param - The value to assign to variable <axi4::config_stats_write_data_waits_step>.
    //
    pure virtual function automatic void set_config_stats_write_data_waits_step( int config_stats_write_data_waits_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_data_waits_multiple>.
    //
    // Parameters:
    //     config_stats_write_data_waits_multiple_param - The value to assign to variable <axi4::config_stats_write_data_waits_multiple>.
    //
    pure virtual function automatic void set_config_stats_write_data_waits_multiple( int config_stats_write_data_waits_multiple_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_response_waits_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_response_waits_step>.
    //
    // Parameters:
    //     config_stats_write_response_waits_step_param - The value to assign to variable <axi4::config_stats_write_response_waits_step>.
    //
    pure virtual function automatic void set_config_stats_write_response_waits_step( int config_stats_write_response_waits_step_param );

    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_response_waits_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_response_waits_multiple>.
    //
    // Parameters:
    //     config_stats_write_response_waits_multiple_param - The value to assign to variable <axi4::config_stats_write_response_waits_multiple>.
    //
    pure virtual function automatic void set_config_stats_write_response_waits_multiple( int config_stats_write_response_waits_multiple_param );

    //------------------------------------------------------------------------------
    // Functions to get global variables with read access
    //------------------------------------------------------------------------------

    //------------------------------------------------------------------------------
    // Function:- get_config_interface_type
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_interface_type>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_interface_type>.
    //
    pure virtual function automatic axi4_interface_type_e get_config_interface_type(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_clk_init_value
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_clk_init_value>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_clk_init_value>.
    //
    pure virtual function automatic bit get_config_clk_init_value(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_clk_phase_shift
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_clk_phase_shift>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_clk_phase_shift>.
    //
    pure virtual function automatic longint unsigned get_config_clk_phase_shift(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_clk_1st_time
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_clk_1st_time>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_clk_1st_time>.
    //
    pure virtual function automatic longint unsigned get_config_clk_1st_time(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_clk_2nd_time
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_clk_2nd_time>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_clk_2nd_time>.
    //
    pure virtual function automatic longint unsigned get_config_clk_2nd_time(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_setup_time
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_setup_time>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_setup_time>.
    //
    pure virtual function automatic longint unsigned get_config_setup_time(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_hold_time
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_hold_time>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_hold_time>.
    //
    pure virtual function automatic longint unsigned get_config_hold_time(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_burst_timeout_factor
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_burst_timeout_factor>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_burst_timeout_factor>.
    //
    pure virtual function automatic int unsigned get_config_burst_timeout_factor(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_max_transaction_time_factor
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_max_transaction_time_factor>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_max_transaction_time_factor>.
    //
    pure virtual function automatic int unsigned get_config_max_transaction_time_factor(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_write_ctrl_first_ratio
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_write_ctrl_first_ratio>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_write_ctrl_first_ratio>.
    //
    pure virtual function automatic int get_config_write_ctrl_first_ratio(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_write_data_first_ratio
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_write_data_first_ratio>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_write_data_first_ratio>.
    //
    pure virtual function automatic int get_config_write_data_first_ratio(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_reset_low_clocks
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_reset_low_clocks>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_reset_low_clocks>.
    //
    pure virtual function automatic int get_config_reset_low_clocks(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_reset_hold_time
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_reset_hold_time>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_reset_hold_time>.
    //
    pure virtual function automatic int get_config_reset_hold_time(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_rlast
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_rlast>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_rlast>.
    //
    pure virtual function automatic bit get_config_enable_rlast(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_slave_exclusive
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_slave_exclusive>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_slave_exclusive>.
    //
    pure virtual function automatic bit get_config_enable_slave_exclusive(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_burst_reserved_value
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_burst_reserved_value>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_burst_reserved_value>.
    //
    pure virtual function automatic bit get_config_enable_burst_reserved_value(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_cache_value
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_cache_value>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_cache_value>.
    //
    pure virtual function automatic bit [15:0]  get_config_enable_cache_value(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_cache_value_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_enable_cache_value>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_cache_value>.
    //
    pure virtual function automatic bit   get_config_enable_cache_value_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_internal_dummy_variable
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::internal_dummy_variable>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::internal_dummy_variable>.
    //
    pure virtual function automatic axi4_error_e get_internal_dummy_variable(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_axi4lite_interface
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_axi4lite_interface>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_axi4lite_interface>.
    //
    pure virtual function automatic bit get_config_axi4lite_interface(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_axi4lite_tr_id
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_axi4lite_tr_id>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_axi4lite_tr_id>.
    //
    pure virtual function automatic bit [((AXI4_ID_WIDTH) - 1):0]   get_config_axi4lite_tr_id(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_axi4lite_tr_id_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_axi4lite_tr_id>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::config_axi4lite_tr_id>.
    //
    pure virtual function automatic bit   get_config_axi4lite_tr_id_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_all_assertions
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_all_assertions>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_all_assertions>.
    //
    pure virtual function automatic bit get_config_enable_all_assertions(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_assertion
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_assertion>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_assertion>.
    //
    pure virtual function automatic bit [255:0]  get_config_enable_assertion(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_assertion_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_enable_assertion>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_assertion>.
    //
    pure virtual function automatic bit   get_config_enable_assertion_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_error
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_error>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_error>.
    //
    pure virtual function automatic bit [255:0]  get_config_enable_error(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_error_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_enable_error>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_error>.
    //
    pure virtual function automatic bit   get_config_enable_error_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_config_max_latency_AWVALID_assertion_to_AWREADY
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_max_latency_AWVALID_assertion_to_AWREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_max_latency_AWVALID_assertion_to_AWREADY>.
    //
    pure virtual function automatic int unsigned get_config_max_latency_AWVALID_assertion_to_AWREADY(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_max_latency_ARVALID_assertion_to_ARREADY
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_max_latency_ARVALID_assertion_to_ARREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_max_latency_ARVALID_assertion_to_ARREADY>.
    //
    pure virtual function automatic int unsigned get_config_max_latency_ARVALID_assertion_to_ARREADY(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_max_latency_RVALID_assertion_to_RREADY
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_max_latency_RVALID_assertion_to_RREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_max_latency_RVALID_assertion_to_RREADY>.
    //
    pure virtual function automatic int unsigned get_config_max_latency_RVALID_assertion_to_RREADY(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_max_latency_BVALID_assertion_to_BREADY
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_max_latency_BVALID_assertion_to_BREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_max_latency_BVALID_assertion_to_BREADY>.
    //
    pure virtual function automatic int unsigned get_config_max_latency_BVALID_assertion_to_BREADY(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_max_latency_WVALID_assertion_to_WREADY
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_max_latency_WVALID_assertion_to_WREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_max_latency_WVALID_assertion_to_WREADY>.
    //
    pure virtual function automatic int unsigned get_config_max_latency_WVALID_assertion_to_WREADY(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_qos
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_qos>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_qos>.
    //
    pure virtual function automatic bit get_config_enable_qos(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_region_support
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_region_support>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_region_support>.
    //
    pure virtual function automatic bit get_config_enable_region_support(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_slave_regions
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_slave_regions>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_regions>.
    //
    pure virtual function automatic int get_config_slave_regions(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_region
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_region>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_region>.
    //
    pure virtual function automatic bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]   get_config_region(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_region_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_region>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::config_region>.
    //
    pure virtual function automatic bit [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]   get_config_region_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_config_region_index2
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_region>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //    _this_dot_2 - The array index for dimension 2.
    //
    // Returns:
    //     The current value of the variable <axi4::config_region>.
    //
    pure virtual function automatic bit   get_config_region_index2( int _this_dot_1, int _this_dot_2 );

    //------------------------------------------------------------------------------
    // Function:- get_region_error_state
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::region_error_state>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::region_error_state>.
    //
    pure virtual function automatic bit get_region_error_state(  );

    //------------------------------------------------------------------------------
    // Function:- get_region_map_lb
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::region_map_lb>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::region_map_lb>.
    //
    typedef longint unsigned _region_map_lb_t [((AXI4_REGION_MAP_SIZE) - 1):0];
    pure virtual function automatic _region_map_lb_t get_region_map_lb(  );

    //------------------------------------------------------------------------------
    // Function:- get_region_map_lb_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::region_map_lb>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::region_map_lb>.
    //
    pure virtual function automatic longint unsigned get_region_map_lb_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_region_map_ub
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::region_map_ub>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::region_map_ub>.
    //
    typedef longint unsigned _region_map_ub_t [((AXI4_REGION_MAP_SIZE) - 1):0];
    pure virtual function automatic _region_map_ub_t get_region_map_ub(  );

    //------------------------------------------------------------------------------
    // Function:- get_region_map_ub_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::region_map_ub>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::region_map_ub>.
    //
    pure virtual function automatic longint unsigned get_region_map_ub_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_region_map_region
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::region_map_region>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::region_map_region>.
    //
    typedef byte unsigned _region_map_region_t [((AXI4_REGION_MAP_SIZE) - 1):0];
    pure virtual function automatic _region_map_region_t get_region_map_region(  );

    //------------------------------------------------------------------------------
    // Function:- get_region_map_region_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::region_map_region>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::region_map_region>.
    //
    pure virtual function automatic byte unsigned get_region_map_region_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_cacheable
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::cacheable>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::cacheable>.
    //
    typedef byte unsigned _cacheable_t [((AXI4_REGION_MAP_SIZE) - 1):0];
    pure virtual function automatic _cacheable_t get_cacheable(  );

    //------------------------------------------------------------------------------
    // Function:- get_cacheable_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::cacheable>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::cacheable>.
    //
    pure virtual function automatic byte unsigned get_cacheable_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_config_read_data_reordering_depth
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_read_data_reordering_depth>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_read_data_reordering_depth>.
    //
    pure virtual function automatic int unsigned get_config_read_data_reordering_depth(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_slave_start_addr
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_slave_start_addr>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_start_addr>.
    //
    pure virtual function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_start_addr(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_slave_start_addr_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_slave_start_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_start_addr>.
    //
    pure virtual function automatic bit   get_config_slave_start_addr_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_config_slave_end_addr
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_slave_end_addr>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_end_addr>.
    //
    pure virtual function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_end_addr(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_slave_end_addr_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_slave_end_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_end_addr>.
    //
    pure virtual function automatic bit   get_config_slave_end_addr_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_config_slave_enabled_non_contiguous_address_spaces
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_slave_enabled_non_contiguous_address_spaces>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_enabled_non_contiguous_address_spaces>.
    //
    pure virtual function automatic int get_config_slave_enabled_non_contiguous_address_spaces(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_slave_possess_multiple_non_contiguous_address_spaces
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_slave_possess_multiple_non_contiguous_address_spaces>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_possess_multiple_non_contiguous_address_spaces>.
    //
    pure virtual function automatic bit get_config_slave_possess_multiple_non_contiguous_address_spaces(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_slave_multiple_non_contiguous_start_address_range
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    pure virtual function automatic bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_multiple_non_contiguous_start_address_range(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_slave_multiple_non_contiguous_start_address_range_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    pure virtual function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_multiple_non_contiguous_start_address_range_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_config_slave_multiple_non_contiguous_start_address_range_index2
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //    _this_dot_2 - The array index for dimension 2.
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    pure virtual function automatic bit   get_config_slave_multiple_non_contiguous_start_address_range_index2( int _this_dot_1, int _this_dot_2 );

    //------------------------------------------------------------------------------
    // Function:- get_config_slave_multiple_non_contiguous_end_address_range
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    pure virtual function automatic bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_multiple_non_contiguous_end_address_range(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_slave_multiple_non_contiguous_end_address_range_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    pure virtual function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_multiple_non_contiguous_end_address_range_index1( int _this_dot_1 );

    //------------------------------------------------------------------------------
    // Function:- get_config_slave_multiple_non_contiguous_end_address_range_index2
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //    _this_dot_2 - The array index for dimension 2.
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    pure virtual function automatic bit   get_config_slave_multiple_non_contiguous_end_address_range_index2( int _this_dot_1, int _this_dot_2 );

    //------------------------------------------------------------------------------
    // Function:- get_config_protect_ready
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_protect_ready>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_protect_ready>.
    //
    pure virtual function automatic bit get_config_protect_ready(  );

    //------------------------------------------------------------------------------
    // Function:- get_master_end_tlm_status
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::master_end_tlm_status>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::master_end_tlm_status>.
    //
    pure virtual function automatic bit get_master_end_tlm_status(  );

    //------------------------------------------------------------------------------
    // Function:- get_master_end_wlm_status
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::master_end_wlm_status>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::master_end_wlm_status>.
    //
    pure virtual function automatic bit get_master_end_wlm_status(  );

    //------------------------------------------------------------------------------
    // Function:- get_slave_end_tlm_status
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::slave_end_tlm_status>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::slave_end_tlm_status>.
    //
    pure virtual function automatic bit get_slave_end_tlm_status(  );

    //------------------------------------------------------------------------------
    // Function:- get_slave_end_wlm_status
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::slave_end_wlm_status>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::slave_end_wlm_status>.
    //
    pure virtual function automatic bit get_slave_end_wlm_status(  );

    //------------------------------------------------------------------------------
    // Function:- get_clock_source_end_tlm_status
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::clock_source_end_tlm_status>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::clock_source_end_tlm_status>.
    //
    pure virtual function automatic bit get_clock_source_end_tlm_status(  );

    //------------------------------------------------------------------------------
    // Function:- get_clock_source_end_wlm_status
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::clock_source_end_wlm_status>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::clock_source_end_wlm_status>.
    //
    pure virtual function automatic bit get_clock_source_end_wlm_status(  );

    //------------------------------------------------------------------------------
    // Function:- get_reset_source_end_tlm_status
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::reset_source_end_tlm_status>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::reset_source_end_tlm_status>.
    //
    pure virtual function automatic bit get_reset_source_end_tlm_status(  );

    //------------------------------------------------------------------------------
    // Function:- get_reset_source_end_wlm_status
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::reset_source_end_wlm_status>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::reset_source_end_wlm_status>.
    //
    pure virtual function automatic bit get_reset_source_end_wlm_status(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_max_outstanding_wr
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_max_outstanding_wr>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_max_outstanding_wr>.
    //
    pure virtual function automatic int get_config_max_outstanding_wr(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_max_outstanding_rd
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_max_outstanding_rd>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_max_outstanding_rd>.
    //
    pure virtual function automatic int get_config_max_outstanding_rd(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_num_outstanding_wr_phase
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_num_outstanding_wr_phase>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_num_outstanding_wr_phase>.
    //
    pure virtual function automatic int get_config_num_outstanding_wr_phase(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_num_outstanding_rd_phase
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_num_outstanding_rd_phase>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_num_outstanding_rd_phase>.
    //
    pure virtual function automatic int get_config_num_outstanding_rd_phase(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_warnings
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_warnings>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_warnings>.
    //
    pure virtual function automatic bit get_config_enable_warnings(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_errors
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_errors>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_errors>.
    //
    pure virtual function automatic bit get_config_enable_errors(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_enable_exclusive_checks
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_exclusive_checks>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_exclusive_checks>.
    //
    pure virtual function automatic bit get_config_enable_exclusive_checks(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_warn_on_slave_errors
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_warn_on_slave_errors>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_warn_on_slave_errors>.
    //
    pure virtual function automatic bit get_config_warn_on_slave_errors(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_error_on_deleted_valid_cycles
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_error_on_deleted_valid_cycles>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_error_on_deleted_valid_cycles>.
    //
    pure virtual function automatic bit get_config_error_on_deleted_valid_cycles(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable>.
    //
    pure virtual function automatic bit get_config_stats_enable(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_occupancy
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_read_occupancy>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_read_occupancy>.
    //
    pure virtual function automatic bit get_config_stats_enable_read_occupancy(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_occupancy
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_write_occupancy>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_write_occupancy>.
    //
    pure virtual function automatic bit get_config_stats_enable_write_occupancy(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_data_occupancy
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_read_data_occupancy>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_read_data_occupancy>.
    //
    pure virtual function automatic bit get_config_stats_enable_read_data_occupancy(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_data_occupancy
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_write_data_occupancy>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_write_data_occupancy>.
    //
    pure virtual function automatic bit get_config_stats_enable_write_data_occupancy(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_latency
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_read_latency>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_read_latency>.
    //
    pure virtual function automatic bit get_config_stats_enable_read_latency(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_latency
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_write_latency>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_write_latency>.
    //
    pure virtual function automatic bit get_config_stats_enable_write_latency(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_address_waits
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_read_address_waits>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_read_address_waits>.
    //
    pure virtual function automatic bit get_config_stats_enable_read_address_waits(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_data_waits
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_read_data_waits>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_read_data_waits>.
    //
    pure virtual function automatic bit get_config_stats_enable_read_data_waits(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_address_waits
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_write_address_waits>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_write_address_waits>.
    //
    pure virtual function automatic bit get_config_stats_enable_write_address_waits(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_data_waits
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_write_data_waits>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_write_data_waits>.
    //
    pure virtual function automatic bit get_config_stats_enable_write_data_waits(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_response_waits
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_write_response_waits>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_write_response_waits>.
    //
    pure virtual function automatic bit get_config_stats_enable_write_response_waits(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_bandwidth
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_read_bandwidth>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_read_bandwidth>.
    //
    pure virtual function automatic bit get_config_stats_enable_read_bandwidth(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_bandwidth
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_write_bandwidth>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_write_bandwidth>.
    //
    pure virtual function automatic bit get_config_stats_enable_write_bandwidth(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_rw_transaction_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_rw_transaction_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_rw_transaction_last_duration>.
    //
    pure virtual function automatic int get_stats_rw_transaction_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_occupancy_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_occupancy_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_occupancy_step>.
    //
    pure virtual function automatic int get_config_stats_read_occupancy_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_occupancy_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_occupancy_multiple>.
    //
    pure virtual function automatic int get_config_stats_read_occupancy_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_active
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_active>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_active>.
    //
    pure virtual function automatic bit get_stats_read_active(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_occupancy_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_occupancy_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_occupancy_sw>.
    //
    pure virtual function automatic int get_stats_read_occupancy_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_idle_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_idle_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_idle_sw>.
    //
    pure virtual function automatic int get_stats_read_idle_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_occupancy_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_occupancy_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_occupancy_min>.
    //
    pure virtual function automatic int get_stats_read_occupancy_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_idle_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_idle_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_idle_min>.
    //
    pure virtual function automatic int get_stats_read_idle_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_occupancy_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_occupancy_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_occupancy_max>.
    //
    pure virtual function automatic int get_stats_read_occupancy_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_idle_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_idle_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_idle_max>.
    //
    pure virtual function automatic int get_stats_read_idle_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_occupancy_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_occupancy_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_occupancy_mean>.
    //
    pure virtual function automatic int get_stats_read_occupancy_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_idle_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_idle_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_idle_mean>.
    //
    pure virtual function automatic int get_stats_read_idle_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_last_duration>.
    //
    pure virtual function automatic int get_stats_read_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_occupancy_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_occupancy_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_occupancy_step>.
    //
    pure virtual function automatic int get_config_stats_write_occupancy_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_occupancy_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_occupancy_multiple>.
    //
    pure virtual function automatic int get_config_stats_write_occupancy_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_active
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_active>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_active>.
    //
    pure virtual function automatic bit get_stats_write_active(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_occupancy_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_occupancy_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_occupancy_sw>.
    //
    pure virtual function automatic int get_stats_write_occupancy_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_idle_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_idle_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_idle_sw>.
    //
    pure virtual function automatic int get_stats_write_idle_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_occupancy_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_occupancy_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_occupancy_min>.
    //
    pure virtual function automatic int get_stats_write_occupancy_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_idle_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_idle_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_idle_min>.
    //
    pure virtual function automatic int get_stats_write_idle_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_occupancy_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_occupancy_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_occupancy_max>.
    //
    pure virtual function automatic int get_stats_write_occupancy_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_idle_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_idle_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_idle_max>.
    //
    pure virtual function automatic int get_stats_write_idle_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_occupancy_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_occupancy_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_occupancy_mean>.
    //
    pure virtual function automatic int get_stats_write_occupancy_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_idle_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_idle_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_idle_mean>.
    //
    pure virtual function automatic int get_stats_write_idle_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_last_duration>.
    //
    pure virtual function automatic int get_stats_write_last_duration(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_data_occupancy_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_data_occupancy_step>.
    //
    pure virtual function automatic int get_config_stats_read_data_occupancy_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_data_occupancy_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_data_occupancy_multiple>.
    //
    pure virtual function automatic int get_config_stats_read_data_occupancy_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_occupancy_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_occupancy_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_occupancy_sw>.
    //
    pure virtual function automatic int get_stats_read_data_occupancy_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_idle_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_idle_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_idle_sw>.
    //
    pure virtual function automatic int get_stats_read_data_idle_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_occupancy_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_occupancy_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_occupancy_min>.
    //
    pure virtual function automatic int get_stats_read_data_occupancy_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_idle_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_idle_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_idle_min>.
    //
    pure virtual function automatic int get_stats_read_data_idle_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_occupancy_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_occupancy_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_occupancy_max>.
    //
    pure virtual function automatic int get_stats_read_data_occupancy_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_idle_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_idle_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_idle_max>.
    //
    pure virtual function automatic int get_stats_read_data_idle_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_occupancy_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_occupancy_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_occupancy_mean>.
    //
    pure virtual function automatic int get_stats_read_data_occupancy_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_idle_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_idle_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_idle_mean>.
    //
    pure virtual function automatic int get_stats_read_data_idle_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_data_occupancy_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_data_occupancy_step>.
    //
    pure virtual function automatic int get_config_stats_write_data_occupancy_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_data_occupancy_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_data_occupancy_multiple>.
    //
    pure virtual function automatic int get_config_stats_write_data_occupancy_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_occupancy_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_occupancy_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_occupancy_sw>.
    //
    pure virtual function automatic int get_stats_write_data_occupancy_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_idle_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_idle_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_idle_sw>.
    //
    pure virtual function automatic int get_stats_write_data_idle_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_occupancy_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_occupancy_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_occupancy_min>.
    //
    pure virtual function automatic int get_stats_write_data_occupancy_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_idle_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_idle_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_idle_min>.
    //
    pure virtual function automatic int get_stats_write_data_idle_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_occupancy_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_occupancy_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_occupancy_max>.
    //
    pure virtual function automatic int get_stats_write_data_occupancy_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_idle_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_idle_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_idle_max>.
    //
    pure virtual function automatic int get_stats_write_data_idle_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_occupancy_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_occupancy_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_occupancy_mean>.
    //
    pure virtual function automatic int get_stats_write_data_occupancy_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_idle_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_idle_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_idle_mean>.
    //
    pure virtual function automatic int get_stats_write_data_idle_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_bandwidth_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_bandwidth_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_bandwidth_step>.
    //
    pure virtual function automatic int get_config_stats_read_bandwidth_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_bandwidth_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_bandwidth_multiple>.
    //
    pure virtual function automatic int get_config_stats_read_bandwidth_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_bandwidth_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_bandwidth_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_bandwidth_sw>.
    //
    pure virtual function automatic int get_stats_read_bandwidth_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_bandwidth_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_bandwidth_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_bandwidth_min>.
    //
    pure virtual function automatic int get_stats_read_bandwidth_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_bandwidth_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_bandwidth_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_bandwidth_max>.
    //
    pure virtual function automatic int get_stats_read_bandwidth_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_bandwidth_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_bandwidth_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_bandwidth_mean>.
    //
    pure virtual function automatic int get_stats_read_bandwidth_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_bandwidth_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_bandwidth_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_bandwidth_step>.
    //
    pure virtual function automatic int get_config_stats_write_bandwidth_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_bandwidth_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_bandwidth_multiple>.
    //
    pure virtual function automatic int get_config_stats_write_bandwidth_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_bandwidth_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_bandwidth_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_bandwidth_sw>.
    //
    pure virtual function automatic int get_stats_write_bandwidth_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_bandwidth_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_bandwidth_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_bandwidth_min>.
    //
    pure virtual function automatic int get_stats_write_bandwidth_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_bandwidth_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_bandwidth_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_bandwidth_max>.
    //
    pure virtual function automatic int get_stats_write_bandwidth_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_bandwidth_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_bandwidth_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_bandwidth_mean>.
    //
    pure virtual function automatic int get_stats_write_bandwidth_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_latency_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_latency_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_latency_step>.
    //
    pure virtual function automatic int get_config_stats_read_latency_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_latency_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_latency_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_latency_multiple>.
    //
    pure virtual function automatic int get_config_stats_read_latency_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_data_latency_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_data_latency_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_data_latency_inst>.
    //
    pure virtual function automatic int get_stats_read_address_data_latency_inst(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_data_latency_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_data_latency_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_data_latency_sw>.
    //
    pure virtual function automatic int get_stats_read_address_data_latency_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_data_latency_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_data_latency_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_data_latency_min>.
    //
    pure virtual function automatic int get_stats_read_address_data_latency_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_data_latency_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_data_latency_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_data_latency_max>.
    //
    pure virtual function automatic int get_stats_read_address_data_latency_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_data_latency_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_data_latency_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_data_latency_mean>.
    //
    pure virtual function automatic int get_stats_read_address_data_latency_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_address_latency_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_address_latency_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_address_latency_inst>.
    //
    pure virtual function automatic int get_stats_read_address_address_latency_inst(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_address_latency_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_address_latency_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_address_latency_sw>.
    //
    pure virtual function automatic int get_stats_read_address_address_latency_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_address_latency_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_address_latency_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_address_latency_min>.
    //
    pure virtual function automatic int get_stats_read_address_address_latency_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_address_latency_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_address_latency_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_address_latency_max>.
    //
    pure virtual function automatic int get_stats_read_address_address_latency_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_address_latency_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_address_latency_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_address_latency_mean>.
    //
    pure virtual function automatic int get_stats_read_address_address_latency_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_latency_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_latency_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_latency_step>.
    //
    pure virtual function automatic int get_config_stats_write_latency_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_latency_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_latency_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_latency_multiple>.
    //
    pure virtual function automatic int get_config_stats_write_latency_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_response_latency_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_response_latency_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_response_latency_inst>.
    //
    pure virtual function automatic int get_stats_write_address_response_latency_inst(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_response_latency_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_response_latency_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_response_latency_sw>.
    //
    pure virtual function automatic int get_stats_write_address_response_latency_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_response_latency_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_response_latency_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_response_latency_min>.
    //
    pure virtual function automatic int get_stats_write_address_response_latency_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_response_latency_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_response_latency_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_response_latency_max>.
    //
    pure virtual function automatic int get_stats_write_address_response_latency_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_response_latency_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_response_latency_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_response_latency_mean>.
    //
    pure virtual function automatic int get_stats_write_address_response_latency_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_address_latency_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_address_latency_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_address_latency_inst>.
    //
    pure virtual function automatic int get_stats_write_address_address_latency_inst(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_address_latency_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_address_latency_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_address_latency_sw>.
    //
    pure virtual function automatic int get_stats_write_address_address_latency_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_address_latency_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_address_latency_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_address_latency_min>.
    //
    pure virtual function automatic int get_stats_write_address_address_latency_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_address_latency_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_address_latency_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_address_latency_max>.
    //
    pure virtual function automatic int get_stats_write_address_address_latency_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_address_latency_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_address_latency_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_address_latency_mean>.
    //
    pure virtual function automatic int get_stats_write_address_address_latency_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_address_waits_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_address_waits_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_address_waits_step>.
    //
    pure virtual function automatic int get_config_stats_read_address_waits_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_address_waits_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_address_waits_multiple>.
    //
    pure virtual function automatic int get_config_stats_read_address_waits_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_waits_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_waits_inst>.
    //
    pure virtual function automatic int get_stats_read_address_waits_inst(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_waits_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_waits_sw>.
    //
    pure virtual function automatic int get_stats_read_address_waits_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_waits_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_waits_min>.
    //
    pure virtual function automatic int get_stats_read_address_waits_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_waits_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_waits_max>.
    //
    pure virtual function automatic int get_stats_read_address_waits_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_waits_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_waits_mean>.
    //
    pure virtual function automatic int get_stats_read_address_waits_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_data_waits_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_data_waits_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_data_waits_step>.
    //
    pure virtual function automatic int get_config_stats_read_data_waits_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_data_waits_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_data_waits_multiple>.
    //
    pure virtual function automatic int get_config_stats_read_data_waits_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_waits_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_waits_inst>.
    //
    pure virtual function automatic int get_stats_read_data_waits_inst(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_waits_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_waits_sw>.
    //
    pure virtual function automatic int get_stats_read_data_waits_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_waits_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_waits_min>.
    //
    pure virtual function automatic int get_stats_read_data_waits_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_waits_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_waits_max>.
    //
    pure virtual function automatic int get_stats_read_data_waits_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_waits_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_waits_mean>.
    //
    pure virtual function automatic int get_stats_read_data_waits_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_address_waits_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_address_waits_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_address_waits_step>.
    //
    pure virtual function automatic int get_config_stats_write_address_waits_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_address_waits_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_address_waits_multiple>.
    //
    pure virtual function automatic int get_config_stats_write_address_waits_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_waits_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_waits_inst>.
    //
    pure virtual function automatic int get_stats_write_address_waits_inst(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_waits_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_waits_sw>.
    //
    pure virtual function automatic int get_stats_write_address_waits_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_waits_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_waits_min>.
    //
    pure virtual function automatic int get_stats_write_address_waits_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_waits_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_waits_max>.
    //
    pure virtual function automatic int get_stats_write_address_waits_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_waits_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_waits_mean>.
    //
    pure virtual function automatic int get_stats_write_address_waits_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_data_waits_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_data_waits_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_data_waits_step>.
    //
    pure virtual function automatic int get_config_stats_write_data_waits_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_data_waits_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_data_waits_multiple>.
    //
    pure virtual function automatic int get_config_stats_write_data_waits_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_waits_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_waits_inst>.
    //
    pure virtual function automatic int get_stats_write_data_waits_inst(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_waits_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_waits_sw>.
    //
    pure virtual function automatic int get_stats_write_data_waits_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_waits_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_waits_min>.
    //
    pure virtual function automatic int get_stats_write_data_waits_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_waits_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_waits_max>.
    //
    pure virtual function automatic int get_stats_write_data_waits_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_waits_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_waits_mean>.
    //
    pure virtual function automatic int get_stats_write_data_waits_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_response_waits_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_response_waits_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_response_waits_step>.
    //
    pure virtual function automatic int get_config_stats_write_response_waits_step(  );

    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_response_waits_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_response_waits_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_response_waits_multiple>.
    //
    pure virtual function automatic int get_config_stats_write_response_waits_multiple(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_response_waits_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_response_waits_inst>.
    //
    pure virtual function automatic int get_stats_write_response_waits_inst(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_response_waits_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_response_waits_sw>.
    //
    pure virtual function automatic int get_stats_write_response_waits_sw(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_response_waits_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_response_waits_min>.
    //
    pure virtual function automatic int get_stats_write_response_waits_min(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_response_waits_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_response_waits_max>.
    //
    pure virtual function automatic int get_stats_write_response_waits_max(  );

    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_response_waits_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_response_waits_mean>.
    //
    pure virtual function automatic int get_stats_write_response_waits_mean(  );

    //------------------------------------------------------------------------------
    // Function:- get_reordering_depth_of_last_read_transaction
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::reordering_depth_of_last_read_transaction>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::reordering_depth_of_last_read_transaction>.
    //
    pure virtual function automatic int get_reordering_depth_of_last_read_transaction(  );

    //------------------------------------------------------------------------------
    // Function to get last database handle
    //------------------------------------------------------------------------------

    pure virtual function longint get_last_handle();

    //------------------------------------------------------------------------------
    // Function to get last start time
    //------------------------------------------------------------------------------

    pure virtual function longint get_last_start_time();

    //------------------------------------------------------------------------------
    // Function to get last end time
    //------------------------------------------------------------------------------

    pure virtual function longint get_last_end_time();


    //------------------------------------------------------------------------------
    // Functions to set/get generic interface configuration
    //------------------------------------------------------------------------------

    pure virtual function void set_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0,
        input int arg10 = 0
    );

    pure virtual function int get_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0
    );

    //------------------------------------------------------------------------------
    // Functions to get the hierarchic name of this interface
    //------------------------------------------------------------------------------
    pure virtual function string get_full_name();

    //------------------------------------------------------------------------------
    // Functions to set/get the abstraction levels of interface ends
    //------------------------------------------------------------------------------
    //------------------------------------------------------------------------------
    // Function: axi4_set_master_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to set whether the <master> end of the interface is WLM or TLM connected.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels,
    //     how they affect the behaviour of the QVIP, and guidelines for setting them.
    //
    // Parameters:
    //    wire_level - Set to 1 to be WLM connected.
    //    TLM_level -  Set to 1 to be TLM connected.
    //------------------------------------------------------------------------------
    pure virtual function void axi4_set_master_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
    //------------------------------------------------------------------------------
    // Function: axi4_get_master_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to return the Abstraction level setting for the master end.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels
    //     and how they affect the behaviour of the Questa Verification IP.
    //
    // Parameters:
    //
    //    wire_level - Value = 1 if this end is WLM connected.
    //    TLM_level -  Value = 1 if this end is TLM connected.
    //------------------------------------------------------------------------------
    pure virtual function void axi4_get_master_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    //------------------------------------------------------------------------------
    // Function: axi4_set_slave_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to set whether the <slave> end of the interface is WLM or TLM connected.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels,
    //     how they affect the behaviour of the QVIP, and guidelines for setting them.
    //
    // Parameters:
    //    wire_level - Set to 1 to be WLM connected.
    //    TLM_level -  Set to 1 to be TLM connected.
    //------------------------------------------------------------------------------
    pure virtual function void axi4_set_slave_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
    //------------------------------------------------------------------------------
    // Function: axi4_get_slave_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to return the Abstraction level setting for the slave end.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels
    //     and how they affect the behaviour of the Questa Verification IP.
    //
    // Parameters:
    //
    //    wire_level - Value = 1 if this end is WLM connected.
    //    TLM_level -  Value = 1 if this end is TLM connected.
    //------------------------------------------------------------------------------
    pure virtual function void axi4_get_slave_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    //------------------------------------------------------------------------------
    // Function: axi4_set_clock_source_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to set whether the <clock_source> end of the interface is WLM or TLM connected.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels,
    //     how they affect the behaviour of the QVIP, and guidelines for setting them.
    //
    // Parameters:
    //    wire_level - Set to 1 to be WLM connected.
    //    TLM_level -  Set to 1 to be TLM connected.
    //------------------------------------------------------------------------------
    pure virtual function void axi4_set_clock_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
    //------------------------------------------------------------------------------
    // Function: axi4_get_clock_source_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to return the Abstraction level setting for the clock_source end.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels
    //     and how they affect the behaviour of the Questa Verification IP.
    //
    // Parameters:
    //
    //    wire_level - Value = 1 if this end is WLM connected.
    //    TLM_level -  Value = 1 if this end is TLM connected.
    //------------------------------------------------------------------------------
    pure virtual function void axi4_get_clock_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    //------------------------------------------------------------------------------
    // Function: axi4_set_reset_source_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to set whether the <reset_source> end of the interface is WLM or TLM connected.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels,
    //     how they affect the behaviour of the QVIP, and guidelines for setting them.
    //
    // Parameters:
    //    wire_level - Set to 1 to be WLM connected.
    //    TLM_level -  Set to 1 to be TLM connected.
    //------------------------------------------------------------------------------
    pure virtual function void axi4_set_reset_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
    //------------------------------------------------------------------------------
    // Function: axi4_get_reset_source_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to return the Abstraction level setting for the reset_source end.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels
    //     and how they affect the behaviour of the Questa Verification IP.
    //
    // Parameters:
    //
    //    wire_level - Value = 1 if this end is WLM connected.
    //    TLM_level -  Value = 1 if this end is TLM connected.
    //------------------------------------------------------------------------------
    pure virtual function void axi4_get_reset_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );

    //------------------------------------------------------------------------------
    // Interface end access functions
    //------------------------------------------------------------------------------

    //------------------------------------------------------------------------------
    // Function: get_axi4_master_end
    //------------------------------------------------------------------------------
    //
    // Returns:
    //     A handle to the master end of this instance of the <axi4> interface.
    //
    pure virtual function longint get_axi4_master_end();
    //------------------------------------------------------------------------------
    // Function: get_axi4_slave_end
    //------------------------------------------------------------------------------
    //
    // Returns:
    //     A handle to the slave end of this instance of the <axi4> interface.
    //
    pure virtual function longint get_axi4_slave_end();
    //------------------------------------------------------------------------------
    // Function:- get_axi4_clock_source_end
    //------------------------------------------------------------------------------
    //
    // Returns:
    //     A handle to the clock_source end of this instance of the <axi4> interface.
    //
    pure virtual function longint get_axi4_clock_source_end();
    //------------------------------------------------------------------------------
    // Function:- get_axi4_reset_source_end
    //------------------------------------------------------------------------------
    //
    // Returns:
    //     A handle to the reset_source end of this instance of the <axi4> interface.
    //
    pure virtual function longint get_axi4_reset_source_end();
    //------------------------------------------------------------------------------
    // Function: get_axi4__monitor_end
    //------------------------------------------------------------------------------
    //
    // Returns:
    //     A handle to the _monitor end of this instance of the <axi4> interface.
    //
    pure virtual function longint get_axi4__monitor_end();

    //------------------------------------------------------------------------------
    // Transaction interface
    //------------------------------------------------------------------------------
    pure virtual task automatic dvc_activate_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref axi4_rw_e read_or_write,
        ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi4_prot_e prot,
        ref bit [3:0] region,
        ref axi4_size_e size,
        ref axi4_burst_e burst,
        ref axi4_lock_e lock,
        ref axi4_cache_e cache,
        ref bit [3:0] qos,
        ref bit [((AXI4_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] burst_length,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        ref int address_valid_delay,
        ref int data_valid_delay[],
        ref int write_response_valid_delay,
        ref int address_ready_delay,
        ref int data_ready_delay[],
        ref int write_response_ready_delay,
        ref bit write_data_with_address,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi4_rw_e read_or_write,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        output int address_valid_delay,
        ref int data_valid_delay[],
        output int write_response_valid_delay,
        output int address_ready_delay,
        ref int data_ready_delay[],
        output int write_response_ready_delay,
        output bit write_data_with_address,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_activate_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi4_prot_e prot,
        ref int rresp_delays[255:0],
        ref bit [3:0] region,
        ref axi4_size_e size,
        ref axi4_burst_e burst,
        ref axi4_lock_e lock,
        ref axi4_cache_e cache,
        ref bit [3:0] qos,
        ref bit [((AXI4_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] burst_length,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_RDATA_WIDTH) - 1):0] data_words [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int address_valid_delay,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        ref int rresp_delays[255:0],
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_RDATA_WIDTH) - 1):0] data_words [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output int address_valid_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_activate_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi4_prot_e prot,
        ref int bresp_delay,
        ref bit [3:0] region,
        ref axi4_size_e size,
        ref axi4_burst_e burst,
        ref axi4_lock_e lock,
        ref axi4_cache_e cache,
        ref bit [3:0] qos,
        ref bit [((AXI4_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] burst_length,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        ref axi4_response_e resp,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref longint wr_resp_start_time,
        ref longint wr_resp_end_time,
        ref int address_valid_delay,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output int bresp_delay,
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        output axi4_response_e resp,
        output bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output longint wr_resp_start_time,
        output longint wr_resp_end_time,
        output int address_valid_delay,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int burst_length,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] user_data [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int write_data_beats_delay[],
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output int burst_length,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] user_data [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int write_data_beats_delay[],
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input axi4_prot_e prot,
        input bit [3:0] region,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input axi4_cache_e cache,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int data_ready_delay,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input axi4_prot_e prot,
        input bit [3:0] region,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input axi4_cache_e cache,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        input bit last,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int data_ready_delay,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        output bit last,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi4_response_e resp,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int write_response_ready_delay,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi4_response_e resp,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int write_response_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] region,
        input axi4_cache_e cache,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input axi4_prot_e prot,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] region,
        output axi4_cache_e cache,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output axi4_prot_e prot,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] region,
        input axi4_cache_e cache,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input axi4_prot_e prot,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] region,
        output axi4_cache_e cache,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output axi4_prot_e prot,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  strb,
        input bit last,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  strb,
        output bit last,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi4_response_e resp,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi4_response_e resp,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_unexpected_write_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input axi4_response_e resp,
        input bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_unexpected_write_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output axi4_response_e resp,
        output bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
    pure virtual task automatic dvc_put_unexpected_read_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
    pure virtual task automatic dvc_get_unexpected_read_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
    //------------------------------------------------------------------------------
    // Functions to register reports for the interface and interface-ends.
    //------------------------------------------------------------------------------
    //------------------------------------------------------------------------------
    // Tasks for registering reports
    //------------------------------------------------------------------------------
    pure virtual function void register_interface_reporter( input questa_mvc_reporter _rep = null );
    //------------------------------------------------------------------------------
    // Function: register_master_reporter
    //------------------------------------------------------------------------------
    //     Function used to register a reporter for the <master> end of the <axi4> interface.
    //     See <Customizing Error-Reporting> for a description of creating, customising and using reporters.
    //
    // Parameters:
    //    rep - The reporter to be used for the master end.
    //------------------------------------------------------------------------------
    pure virtual function void register_master_reporter
    (
        input questa_mvc_reporter rep = null
    );
    //------------------------------------------------------------------------------
    // Function: register_slave_reporter
    //------------------------------------------------------------------------------
    //     Function used to register a reporter for the <slave> end of the <axi4> interface.
    //     See <Customizing Error-Reporting> for a description of creating, customising and using reporters.
    //
    // Parameters:
    //    rep - The reporter to be used for the slave end.
    //------------------------------------------------------------------------------
    pure virtual function void register_slave_reporter
    (
        input questa_mvc_reporter rep = null
    );
    //------------------------------------------------------------------------------
    // Function:- register_clock_source_reporter
    //------------------------------------------------------------------------------
    //     Function used to register a reporter for the <clock_source> end of the <axi4> interface.
    //     See <Customizing Error-Reporting> for a description of creating, customising and using reporters.
    //
    // Parameters:
    //    rep - The reporter to be used for the clock_source end.
    //------------------------------------------------------------------------------
    pure virtual function void register_clock_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
    //------------------------------------------------------------------------------
    // Function:- register_reset_source_reporter
    //------------------------------------------------------------------------------
    //     Function used to register a reporter for the <reset_source> end of the <axi4> interface.
    //     See <Customizing Error-Reporting> for a description of creating, customising and using reporters.
    //
    // Parameters:
    //    rep - The reporter to be used for the reset_source end.
    //------------------------------------------------------------------------------
    pure virtual function void register_reset_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
endclass


typedef bit [1023:0] axi4_max_bits_t;

// enum: axi4_config_e
//
// An enum which fields corresponding to each configuration parameter of the VIP
//    AXI4_CONFIG_INTERFACE_TYPE - 
//          A configuration parameter (of type <axi4_interface_type_e>) defining the interface category: read/write, read only or write only (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.2).
//         
//         The value defaults to <AXI4_READWRITE>.
//         
//    AXI4_CONFIG_SETUP_TIME - 
//          The setup-time, in units of simulator time-steps, for all signals. By default this is set to 0. Users should use the
//         <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
//         See <Configuration of Time-Units> for background on configuration of time-units.
//         
//    AXI4_CONFIG_HOLD_TIME - 
//          The hold-time, in units of simulator time-steps, for all signals. By default this is set to 0. Users should use the
//         <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
//         See <Configuration of Time-Units> for background on configuration of time-units.
//         
//    AXI4_CONFIG_BURST_TIMEOUT_FACTOR - 
//          The maximum number of clock-periods between phases.
//         
//         This causes a timeout when an unreasonable time passes between transaction phases. It defaults to 10000 clock periods.
//         
//    AXI4_CONFIG_ENABLE_RLAST - 
//          A configuration parameter controlling whether the optional <RLAST> signal is used, or not.
//         
//         <RLAST> is an optional input to the master, because the length of a read burst is always known (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.3.5).
//         
//    AXI4_CONFIG_ENABLE_SLAVE_EXCLUSIVE - 
//          A configuration parameter controlling whether the slave supports exclusive accesses. (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.5)
//         
//         By default this is set to true so that the slave will support exclusive accesses by responding with <AXI4_EXOKAY>.
//         
//         The coverage collected by the covergroup <axi4_coverage::axi4_cvg> is affected by this parameter value setting.
//         
//    AXI4_CONFIG_AXI4LITE_axi4 - 
//          If user want to use QVIP BFM on the axi4lite interface, then this
//          configuration variable should be set to true.
//         
//    AXI4_CONFIG_AXI4LITE_TR_ID - 
//          Configuration variable to set ID to a fixed value when QVIP BFM is configured as axi4lite
//         
//    AXI4_CONFIG_ENABLE_ALL_ASSERTIONS - 
//          Configuration parameter controlling whether the error messages(Assertions) issued from the QVIP are Enabled or Disabled.  
//              By default, it is enabled.
//           
//    AXI4_CONFIG_ENABLE_ASSERTION - 
//          An array of configuration parameters controlling whether specific error messages(Assertion) can be issued by the QVIP.
//              By default, all errors are enabled. 
//              To suppress a particular error, set the corresponding bit to 0 (false).
//           
//    AXI4_CONFIG_MAX_LATENCY_AWVALID_ASSERTION_TO_AWREADY - 
//          A configuration parameter defining the timeout (in clock periods) from the assertion of <AWVALID> to the assertion of <AWREADY> (default 10000).
//         
//         The error message <AXI4_AWREADY_NOT_ASSERTED_AFTER_AWVALID> will be issued if this period elapses from the assertion of <AWVALID>.
//         
//    AXI4_CONFIG_MAX_LATENCY_ARVALID_ASSERTION_TO_ARREADY - 
//          A configuration parameter defining the timeout (in clock periods) from the assertion of <ARVALID> to the assertion of <ARREADY> (default 10000).
//         
//         The error message <AXI4_ARREADY_NOT_ASSERTED_AFTER_ARVALID> will be issued if this period elapses from the assertion of <ARVALID>.
//         
//    AXI4_CONFIG_MAX_LATENCY_RVALID_ASSERTION_TO_RREADY - 
//          A configuration parameter defining the timeout (in clock periods) from the assertion of <RVALID> to the assertion of <RREADY> (default 10000).
//         
//         The error message <AXI4_RREADY_NOT_ASSERTED_AFTER_RVALID> will be issued if this period elapses from the assertion of <RVALID>.
//         
//    AXI4_CONFIG_MAX_LATENCY_BVALID_ASSERTION_TO_BREADY - 
//          A configuration parameter defining the timeout (in clock periods) from the assertion of <BVALID> to the assertion of <BREADY> (default 10000).
//         
//         The error message <AXI4_BREADY_NOT_ASSERTED_AFTER_BVALID> will be issued if this period elapses from the assertion of <BVALID>.
//         
//    AXI4_CONFIG_MAX_LATENCY_WVALID_ASSERTION_TO_WREADY - 
//          A configuration parameter defining the timeout (in clock periods) from the assertion of <WVALID> to the assertion of <WREADY> (default 10000).
//         
//         The error message <AXI4_WREADY_NOT_ASSERTED_AFTER_WVALID> will be issued if this period elapses from the assertion of <WVALID>.
//         
//    AXI4_CONFIG_ENABLE_QOS - 
//          A configuration parameter defining whether the master participates in the Quality-of-Service scheme  (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.1.2). 
//         
//         This defaults to 'true' i.e. the master participates in the Quality-of-Service scheme. If a master does not participate, the <AWQOS>/<ARQOS> value used in write/read transactions must be b0000.
//         
//    AXI4_CONFIG_READ_DATA_REORDERING_DEPTH - 
//          A configuration parameter defining the read reordering depth of the slave end of the interface (see AMBA AXI and ACE Protocol Specification IHI0022D section A5.3.1).
//         
//         Responses from the first <config_read_data_reordering_depth> outstanding read transactions, each with address <ARID> values different from any
//          earlier outstanding read transaction(as seen by the slave) are expected, interleaved at random. A violation causes a <AXI4_READ_REORDERING_VIOLATION> error.
//         
//         The default value of <config_read_data_reordering_depth> is (1 << AXI4_ID_WIDTH), so that the slave is expected to process all transactions in any order (up to uniqueness of <ARID>).
//         
//         For a given <AXI4_ID_WIDTH> parameter value, the maximum possible value of <config_read_data_reordering_depth> is 2**AXI4_ID_WIDTH. The <AXI4_PARAM_READ_REORDERING_DEPTH_EXCEEDS_MAX_ID>
//          error report will be issued if <config_read_data_reordering_depth> exceeds this value.
//         
//         If the user-supplied value is 0, the <AXI4_PARAM_READ_REORDERING_DEPTH_EQUALS_ZERO> error will be issued, and the value will be set to 1.
//         
//    AXI4_CONFIG_SLAVE_START_ADDR - 
//          A configuration parameter indicating start address for slave.
//         
//    AXI4_CONFIG_SLAVE_END_ADDR - 
//          A configuration parameter indicating end address for slave.
//         
//    AXI4_AXI4_MAX_SW_MULTIPLE - 
//         **************************************************************************************
//          *
//          * Copyright 2007-2013 Mentor Graphics Corporation
//          * All Rights Reserved.
//          *
//          * THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION WHICH IS THE PROPERTY OF 
//          * MENTOR GRAPHICS CORPORATION OR ITS LICENSORS AND IS SUBJECT TO LICENSE TERMS.
//          *
//          **************************************************************************************

typedef enum bit [7:0]
{
    AXI4_CONFIG_INTERFACE_TYPE               = 8'd0,
    AXI4_CONFIG_SETUP_TIME                   = 8'd1,
    AXI4_CONFIG_HOLD_TIME                    = 8'd2,
    AXI4_CONFIG_BURST_TIMEOUT_FACTOR         = 8'd3,
    AXI4_CONFIG_MAX_TRANSACTION_TIME_FACTOR  = 8'd4,
    AXI4_CONFIG_ENABLE_RLAST                 = 8'd5,
    AXI4_CONFIG_ENABLE_SLAVE_EXCLUSIVE       = 8'd6,
    AXI4_CONFIG_AXI4LITE_axi4           = 8'd7,
    AXI4_CONFIG_AXI4LITE_TR_ID               = 8'd8,
    AXI4_CONFIG_ENABLE_ALL_ASSERTIONS        = 8'd9,
    AXI4_CONFIG_ENABLE_ASSERTION             = 8'd10,
    AXI4_CONFIG_MAX_LATENCY_AWVALID_ASSERTION_TO_AWREADY = 8'd11,
    AXI4_CONFIG_MAX_LATENCY_ARVALID_ASSERTION_TO_ARREADY = 8'd12,
    AXI4_CONFIG_MAX_LATENCY_RVALID_ASSERTION_TO_RREADY = 8'd13,
    AXI4_CONFIG_MAX_LATENCY_BVALID_ASSERTION_TO_BREADY = 8'd14,
    AXI4_CONFIG_MAX_LATENCY_WVALID_ASSERTION_TO_WREADY = 8'd15,
    AXI4_CONFIG_ENABLE_QOS                   = 8'd16,
    AXI4_CONFIG_READ_DATA_REORDERING_DEPTH   = 8'd17,
    AXI4_CONFIG_SLAVE_START_ADDR             = 8'd18,
    AXI4_CONFIG_SLAVE_END_ADDR               = 8'd19,
    AXI4_CONFIG_MAX_OUTSTANDING_WR           = 8'd20,
    AXI4_CONFIG_MAX_OUTSTANDING_RD           = 8'd21,
    AXI4_CONFIG_NUM_OUTSTANDING_WR_PHASE     = 8'd22,
    AXI4_CONFIG_NUM_OUTSTANDING_RD_PHASE     = 8'd23,
    AXI4_AXI4_MAX_SW_MULTIPLE                = 8'd24
} axi4_config_e;

// enum: axi4_vhd_if_e
//
// For VHDL use only
typedef enum int
{
    AXI4_VHD_SET_CONFIG                         = 32'd0,
    AXI4_VHD_GET_CONFIG                         = 32'd1,
    AXI4_VHD_CREATE_WRITE_TRANSACTION           = 32'd2,
    AXI4_VHD_CREATE_READ_TRANSACTION            = 32'd3,
    AXI4_VHD_SET_READ_OR_WRITE                  = 32'd4,
    AXI4_VHD_GET_READ_OR_WRITE                  = 32'd5,
    AXI4_VHD_SET_ADDR                           = 32'd6,
    AXI4_VHD_GET_ADDR                           = 32'd7,
    AXI4_VHD_SET_PROT                           = 32'd8,
    AXI4_VHD_GET_PROT                           = 32'd9,
    AXI4_VHD_SET_REGION                         = 32'd10,
    AXI4_VHD_GET_REGION                         = 32'd11,
    AXI4_VHD_SET_SIZE                           = 32'd12,
    AXI4_VHD_GET_SIZE                           = 32'd13,
    AXI4_VHD_SET_BURST                          = 32'd14,
    AXI4_VHD_GET_BURST                          = 32'd15,
    AXI4_VHD_SET_LOCK                           = 32'd16,
    AXI4_VHD_GET_LOCK                           = 32'd17,
    AXI4_VHD_SET_CACHE                          = 32'd18,
    AXI4_VHD_GET_CACHE                          = 32'd19,
    AXI4_VHD_SET_QOS                            = 32'd20,
    AXI4_VHD_GET_QOS                            = 32'd21,
    AXI4_VHD_SET_ID                             = 32'd22,
    AXI4_VHD_GET_ID                             = 32'd23,
    AXI4_VHD_SET_BURST_LENGTH                   = 32'd24,
    AXI4_VHD_GET_BURST_LENGTH                   = 32'd25,
    AXI4_VHD_SET_ADDR_USER                      = 32'd26,
    AXI4_VHD_GET_ADDR_USER                      = 32'd27,
    AXI4_VHD_SET_DATA_WORDS                     = 32'd28,
    AXI4_VHD_GET_DATA_WORDS                     = 32'd29,
    AXI4_VHD_SET_WRITE_STROBES                  = 32'd30,
    AXI4_VHD_GET_WRITE_STROBES                  = 32'd31,
    AXI4_VHD_SET_RESP                           = 32'd32,
    AXI4_VHD_GET_RESP                           = 32'd33,
    AXI4_VHD_SET_ADDRESS_VALID_DELAY            = 32'd34,
    AXI4_VHD_GET_ADDRESS_VALID_DELAY            = 32'd35,
    AXI4_VHD_SET_DATA_VALID_DELAY               = 32'd36,
    AXI4_VHD_GET_DATA_VALID_DELAY               = 32'd37,
    AXI4_VHD_SET_WRITE_RESPONSE_VALID_DELAY     = 32'd38,
    AXI4_VHD_GET_WRITE_RESPONSE_VALID_DELAY     = 32'd39,
    AXI4_VHD_SET_ADDRESS_READY_DELAY            = 32'd40,
    AXI4_VHD_GET_ADDRESS_READY_DELAY            = 32'd41,
    AXI4_VHD_SET_DATA_READY_DELAY               = 32'd42,
    AXI4_VHD_GET_DATA_READY_DELAY               = 32'd43,
    AXI4_VHD_SET_WRITE_RESPONSE_READY_DELAY     = 32'd44,
    AXI4_VHD_GET_WRITE_RESPONSE_READY_DELAY     = 32'd45,
    AXI4_VHD_SET_GEN_WRITE_STROBES              = 32'd46,
    AXI4_VHD_GET_GEN_WRITE_STROBES              = 32'd47,
    AXI4_VHD_SET_OPERATION_MODE                 = 32'd48,
    AXI4_VHD_GET_OPERATION_MODE                 = 32'd49,
    AXI4_VHD_SET_WRITE_DATA_MODE                = 32'd50,
    AXI4_VHD_GET_WRITE_DATA_MODE                = 32'd51,
    AXI4_VHD_SET_DATA_BEAT_DONE                 = 32'd52,
    AXI4_VHD_GET_DATA_BEAT_DONE                 = 32'd53,
    AXI4_VHD_SET_TRANSACTION_DONE               = 32'd54,
    AXI4_VHD_GET_TRANSACTION_DONE               = 32'd55,
    AXI4_VHD_EXECUTE_TRANSACTION                = 32'd56,
    AXI4_VHD_GET_RW_TRANSACTION                 = 32'd57,
    AXI4_VHD_EXECUTE_WRITE_DATA_BURST           = 32'd58,
    AXI4_VHD_GET_WRITE_DATA_BURST               = 32'd59,
    AXI4_VHD_EXECUTE_READ_ADDR_PHASE            = 32'd60,
    AXI4_VHD_GET_READ_ADDR_PHASE                = 32'd61,
    AXI4_VHD_EXECUTE_READ_DATA_BURST            = 32'd62,
    AXI4_VHD_GET_READ_DATA_BURST                = 32'd63,
    AXI4_VHD_EXECUTE_READ_DATA_PHASE            = 32'd64,
    AXI4_VHD_GET_READ_DATA_PHASE                = 32'd65,
    AXI4_VHD_EXECUTE_WRITE_ADDR_PHASE           = 32'd66,
    AXI4_VHD_GET_WRITE_ADDR_PHASE               = 32'd67,
    AXI4_VHD_EXECUTE_WRITE_DATA_PHASE           = 32'd68,
    AXI4_VHD_GET_WRITE_DATA_PHASE               = 32'd69,
    AXI4_VHD_EXECUTE_WRITE_RESPONSE_PHASE       = 32'd70,
    AXI4_VHD_GET_WRITE_RESPONSE_PHASE           = 32'd71,
    AXI4_VHD_GET_READ_ADDR_CYCLE                = 32'd72,
    AXI4_VHD_EXECUTE_READ_ADDR_READY            = 32'd73,
    AXI4_VHD_GET_READ_ADDR_READY                = 32'd74,
    AXI4_VHD_GET_READ_DATA_CYCLE                = 32'd75,
    AXI4_VHD_EXECUTE_READ_DATA_READY            = 32'd76,
    AXI4_VHD_GET_READ_DATA_READY                = 32'd77,
    AXI4_VHD_GET_WRITE_ADDR_CYCLE               = 32'd78,
    AXI4_VHD_EXECUTE_WRITE_ADDR_READY           = 32'd79,
    AXI4_VHD_GET_WRITE_ADDR_READY               = 32'd80,
    AXI4_VHD_GET_WRITE_DATA_CYCLE               = 32'd81,
    AXI4_VHD_EXECUTE_WRITE_DATA_READY           = 32'd82,
    AXI4_VHD_GET_WRITE_DATA_READY               = 32'd83,
    AXI4_VHD_GET_WRITE_RESPONSE_CYCLE           = 32'd84,
    AXI4_VHD_EXECUTE_WRITE_RESP_READY           = 32'd85,
    AXI4_VHD_GET_WRITE_RESP_READY               = 32'd86,
    AXI4_VHD_CREATE_MONITOR_TRANSACTION         = 32'd87,
    AXI4_VHD_CREATE_SLAVE_TRANSACTION           = 32'd88,
    AXI4_VHD_PUSH_TRANSACTION_ID                = 32'd89,
    AXI4_VHD_POP_TRANSACTION_ID                 = 32'd90,
    AXI4_VHD_GET_WRITE_ADDR_DATA                = 32'd91,
    AXI4_VHD_GET_READ_ADDR                      = 32'd92,
    AXI4_VHD_SET_READ_DATA                      = 32'd93,
    AXI4_VHD_PRINT                              = 32'd94,
    AXI4_VHD_DESTRUCT_TRANSACTION               = 32'd95,
    AXI4_VHD_WAIT_ON                            = 32'd96
} axi4_vhd_if_e;


typedef enum bit [7:0]
{
    AXI4_CLOCK_POSEDGE = 8'd0,
    AXI4_CLOCK_NEGEDGE = 8'd1,
    AXI4_CLOCK_ANYEDGE = 8'd2,
    AXI4_CLOCK_0_TO_1  = 8'd3,
    AXI4_CLOCK_1_TO_0  = 8'd4,
    AXI4_RESET_POSEDGE = 8'd5,
    AXI4_RESET_NEGEDGE = 8'd6,
    AXI4_RESET_ANYEDGE = 8'd7,
    AXI4_RESET_0_TO_1  = 8'd8,
    AXI4_RESET_1_TO_0  = 8'd9
} axi4_wait_e;

`ifndef MAX_AXI4_ADDRESS_WIDTH
  `define MAX_AXI4_ADDRESS_WIDTH 64
`endif

`ifndef MAX_AXI4_RDATA_WIDTH
  `define MAX_AXI4_RDATA_WIDTH 1024
`endif

`ifndef MAX_AXI4_WDATA_WIDTH
  `define MAX_AXI4_WDATA_WIDTH 1024
`endif

`ifndef MAX_AXI4_ID_WIDTH
  `define MAX_AXI4_ID_WIDTH 18
`endif

`ifndef MAX_AXI4_USER_WIDTH
  `define MAX_AXI4_USER_WIDTH 8
`endif

`ifndef MAX_AXI4_REGION_MAP_SIZE
  `define MAX_AXI4_REGION_MAP_SIZE 16
`endif

// enum: axi4_operation_mode_e
//
typedef enum int
{
    AXI4_TRANSACTION_NON_BLOCKING = 32'd0,
    AXI4_TRANSACTION_BLOCKING     = 32'd1
} axi4_operation_mode_e;

// enum: axi4_write_data_mode_e
//
typedef enum int
{
    AXI4_DATA_AFTER_ADDRESS = 32'd0,
    AXI4_DATA_WITH_ADDRESS  = 32'd1
} axi4_write_data_mode_e;

// Global Transaction Class
class axi4_transaction;
    // Protocol 
    axi4_rw_e read_or_write;
    bit [((`MAX_AXI4_ADDRESS_WIDTH) - 1):0]  addr;
    axi4_prot_e prot;
    bit [3:0] region;
    axi4_size_e size;
    axi4_burst_e burst;
    axi4_lock_e lock;
    axi4_cache_e cache;
    bit [3:0] qos;
    bit [((`MAX_AXI4_ID_WIDTH) - 1):0]  id;
    bit [7:0] burst_length;
    bit [((`MAX_AXI4_USER_WIDTH) - 1):0]  addr_user;
    bit [((((`MAX_AXI4_RDATA_WIDTH > `MAX_AXI4_WDATA_WIDTH) ? `MAX_AXI4_RDATA_WIDTH : `MAX_AXI4_WDATA_WIDTH)) - 1):0] data_words [];
    bit [(((`MAX_AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [];
    axi4_response_e resp[];
    int address_valid_delay;
    int data_valid_delay[];
    int write_response_valid_delay;
    int address_ready_delay;
    int data_ready_delay[];
    int write_response_ready_delay;

    // Housekeeping
    bit gen_write_strobes = 1'b1;
    axi4_operation_mode_e  operation_mode  = AXI4_TRANSACTION_BLOCKING;
    axi4_write_data_mode_e write_data_mode = AXI4_DATA_AFTER_ADDRESS;
    bit data_beat_done[];
    bit transaction_done;

    // This varaible is for printing component name and should not be visible/documented
    string driver_name;

    function void set_read_or_write( input axi4_rw_e lread_or_write );
      read_or_write = lread_or_write;
    endfunction

    function axi4_rw_e get_read_or_write();
      return read_or_write;
    endfunction

    function void set_addr( input bit [((`MAX_AXI4_ADDRESS_WIDTH) - 1):0]  laddr );
      addr = laddr;
    endfunction

    function bit [((`MAX_AXI4_ADDRESS_WIDTH) - 1):0]   get_addr();
      return addr;
    endfunction

    function void set_prot( input axi4_prot_e lprot );
      prot = lprot;
    endfunction

    function axi4_prot_e get_prot();
      return prot;
    endfunction

    function void set_region( input bit [3:0] lregion );
      region = lregion;
    endfunction

    function bit [3:0]  get_region();
      return region;
    endfunction

    function void set_size( input axi4_size_e lsize );
      size = lsize;
    endfunction

    function axi4_size_e get_size();
      return size;
    endfunction

    function void set_burst( input axi4_burst_e lburst );
      burst = lburst;
    endfunction

    function axi4_burst_e get_burst();
      return burst;
    endfunction

    function void set_lock( input axi4_lock_e llock );
      lock = llock;
    endfunction

    function axi4_lock_e get_lock();
      return lock;
    endfunction

    function void set_cache( input axi4_cache_e lcache );
      cache = lcache;
    endfunction

    function axi4_cache_e get_cache();
      return cache;
    endfunction

    function void set_qos( input bit [3:0] lqos );
      qos = lqos;
    endfunction

    function bit [3:0]  get_qos();
      return qos;
    endfunction

    function void set_id( input bit [((`MAX_AXI4_ID_WIDTH) - 1):0]  lid );
      id = lid;
    endfunction

    function bit [((`MAX_AXI4_ID_WIDTH) - 1):0]   get_id();
      return id;
    endfunction

    function void set_burst_length( input bit [7:0] lburst_length );
      burst_length = lburst_length;
      data_words           = new[(lburst_length + 1)];
      write_strobes        = new[(lburst_length + 1)];
      resp                 = new[(lburst_length + 1)];
      data_valid_delay     = new[(lburst_length + 1)];
      data_ready_delay     = new[(lburst_length + 1)];
      data_beat_done       = new[(lburst_length + 1)];
    endfunction

    function bit [7:0]  get_burst_length();
      return burst_length;
    endfunction

    function void set_addr_user( input bit [((`MAX_AXI4_USER_WIDTH) - 1):0]  laddr_user );
      addr_user = laddr_user;
    endfunction

    function bit [((`MAX_AXI4_USER_WIDTH) - 1):0]   get_addr_user();
      return addr_user;
    endfunction

    function void set_data_words( input bit [((((`MAX_AXI4_RDATA_WIDTH > `MAX_AXI4_WDATA_WIDTH) ? `MAX_AXI4_RDATA_WIDTH : `MAX_AXI4_WDATA_WIDTH)) - 1):0] ldata_words, input int index = 0 );
      data_words[index] = ldata_words;
    endfunction

    function bit [((((`MAX_AXI4_RDATA_WIDTH > `MAX_AXI4_WDATA_WIDTH) ? `MAX_AXI4_RDATA_WIDTH : `MAX_AXI4_WDATA_WIDTH)) - 1):0]  get_data_words( input int index = 0 );
      return data_words[index];
    endfunction

    function void set_write_strobes( input bit [(((`MAX_AXI4_WDATA_WIDTH / 8)) - 1):0] lwrite_strobes, input int index = 0 );
      write_strobes[index] = lwrite_strobes;
    endfunction

    function bit [(((`MAX_AXI4_WDATA_WIDTH / 8)) - 1):0]  get_write_strobes( input int index = 0 );
      return write_strobes[index];
    endfunction

    function void set_resp( input axi4_response_e lresp, input int index = 0 );
      resp[index] = lresp;
    endfunction

    function axi4_response_e get_resp( input int index = 0 );
      return resp[index];
    endfunction

    function void set_address_valid_delay( input int laddress_valid_delay );
      address_valid_delay = laddress_valid_delay;
    endfunction

    function int get_address_valid_delay();
      return address_valid_delay;
    endfunction

    function void set_data_valid_delay( input int ldata_valid_delay, input int index = 0 );
      data_valid_delay[index] = ldata_valid_delay;
    endfunction

    function int get_data_valid_delay( input int index = 0 );
      return data_valid_delay[index];
    endfunction

    function void set_write_response_valid_delay( input int lwrite_response_valid_delay );
      write_response_valid_delay = lwrite_response_valid_delay;
    endfunction

    function int get_write_response_valid_delay();
      return write_response_valid_delay;
    endfunction

    function void set_address_ready_delay( input int laddress_ready_delay );
      address_ready_delay = laddress_ready_delay;
    endfunction

    function int get_address_ready_delay();
      return address_ready_delay;
    endfunction

    function void set_data_ready_delay( input int ldata_ready_delay, input int index = 0 );
      data_ready_delay[index] = ldata_ready_delay;
    endfunction

    function int get_data_ready_delay( input int index = 0 );
      return data_ready_delay[index];
    endfunction

    function void set_write_response_ready_delay( input int lwrite_response_ready_delay );
      write_response_ready_delay = lwrite_response_ready_delay;
    endfunction

    function int get_write_response_ready_delay();
      return write_response_ready_delay;
    endfunction

    function void set_gen_write_strobes( input bit lgen_write_strobes);
      gen_write_strobes = lgen_write_strobes;
    endfunction

    function bit get_gen_write_strobes();
      return gen_write_strobes;
    endfunction

    function void set_operation_mode( input axi4_operation_mode_e loperation_mode );
      operation_mode = loperation_mode;
    endfunction

    function axi4_operation_mode_e get_operation_mode();
      return operation_mode;
    endfunction

    function void set_write_data_mode( input axi4_write_data_mode_e lwrite_data_mode );
      write_data_mode = lwrite_data_mode;
    endfunction

    function axi4_write_data_mode_e get_write_data_mode();
      return write_data_mode;
    endfunction

    function void set_data_beat_done( input int ldata_beat_done, input int index = 0 );
      data_beat_done[index] = ldata_beat_done;
    endfunction

    function int get_data_beat_done( input int index = 0 );
      return data_beat_done[index];
    endfunction

    function void set_transaction_done( input int ltransaction_done );
      transaction_done = ltransaction_done;
    endfunction

    function int get_transaction_done();
      return transaction_done;
    endfunction

    // Function: do_print
    //
    // Prints axi4_transaction transaction attributes
    function void print (bit print_delays = 1'b0);
      $display("------------------------------------------------------------------------");
      $display("%0t: %s axi4_transaction", $time, driver_name);
      $display("------------------------------------------------------------------------");
      $display("read_or_write : %s", read_or_write.name());
      $display("addr : 'h%h", addr);
      $display("prot : %s", prot.name());
      $display("region : 'h%h", region);
      $display("size : %s", size.name());
      $display("burst : %s", burst.name());
      $display("lock : %s", lock.name());
      $display("cache : %s", cache.name());
      $display("qos : 'h%h", qos);
      $display("id : 'h%h", id);
      $display("burst_length : 'h%h", burst_length);
      $display("addr_user : 'h%h", addr_user);
      foreach( data_words[i0_1] )
        $display("data_words[%0d] : 'h%h", i0_1, data_words[i0_1]);
      foreach( write_strobes[i0_1] )
        $display("write_strobes[%0d] : 'h%h", i0_1, write_strobes[i0_1]);
      foreach( resp[i0_1] )
        $display("resp[%0d] : %s", i0_1, resp[i0_1].name());
      $display("gen_write_strobes : 'b%b", gen_write_strobes );
      $display("operation_mode   : %s", operation_mode.name() );
      $display("write_data_mode  : %s", write_data_mode.name() );
      foreach( data_beat_done[i0_1] )
        $display("data_beat_done[%0d] : 'b%b", i0_1, data_beat_done[i0_1] );
      $display("transaction_done : 'b%b", transaction_done );
      if ( print_delays == 1'b1 )
      begin
        $display("address_valid_delay : %0d", address_valid_delay);
        foreach( data_valid_delay[i0_1] )
          $display("data_valid_delay[%0d] : %0d", i0_1, data_valid_delay[i0_1]);
        $display("write_response_valid_delay : %0d", write_response_valid_delay);
        $display("address_ready_delay : %0d", address_ready_delay);
        foreach( data_ready_delay[i0_1] )
          $display("data_ready_delay[%0d] : %0d", i0_1, data_ready_delay[i0_1]);
        $display("write_response_ready_delay : %0d", write_response_ready_delay);
      end
    endfunction
endclass

`endif // MODEL_TECH
endpackage

import mgc_axi4_pkg::*;
`ifdef MODEL_TECH
// *****************************************************************************
//
// Copyright 2007-2013 Mentor Graphics Corporation
// All Rights Reserved.
//
// THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION WHICH IS THE PROPERTY OF
// MENTOR GRAPHICS CORPORATION OR ITS LICENSORS AND IS SUBJECT TO LICENSE TERMS.
//
// *****************************************************************************
// SystemVerilog           Version: 20130911_Questa_10.2c
// *****************************************************************************

// Title: axi4
//

import QUESTA_MVC::questa_mvc_reporter;
import QUESTA_MVC::questa_mvc_item_comms_semantic;
import QUESTA_MVC::questa_mvc_edge;
import QUESTA_MVC::QUESTA_MVC_POSEDGE;
import QUESTA_MVC::QUESTA_MVC_NEGEDGE;
import QUESTA_MVC::QUESTA_MVC_ANYEDGE;
import QUESTA_MVC::QUESTA_MVC_0_TO_1_EDGE;
import QUESTA_MVC::QUESTA_MVC_1_TO_0_EDGE;

//------------------------------------------------------------------------------
//
// Interface:- axi4
//
//------------------------------------------------------------------------------
//  This interface contains all the wires and BFM configuration variables.
// 
// For all Configuration variables set/get/wait functions are available in the
// interface.
// 
// For e.g.
// 
// bit config_enable_slave_exclusive:
// 
// >   function void set_config_enable_slave_exclusive( bit arg1 )
// >
// >   function bit get_config_enable_slave_exclusive()
// >
// >   task wait_for_config_enable_slave_exclusive()
// 
// bit [255:0] config_enable_assertion:
// 
// >     task wait_for_config_enable_assertion()
// >     
// >     task wait_for_config_enable_assertion_index1( input int _this_dot_1 )
// >     
// >     function void set_config_enable_assertion( bit [255:0] arg2 )
// >     
// >     function set_config_enable_assertion_index1( int _this_dot_1, bit  arg3 )
// >     
// >     function bit [255:0]  get_config_enable_assertion()
// >     
// >     function bit get_config_enable_assertion_index1( int _this_dot_1 ) 
// >
// 
//------------------------------------------------------------------------------
(* cy_so="libaxi4_IN_SystemVerilog_MTI_full" *)
(* on_lib_load="axi4_IN_SystemVerilog_load" *)
interface mgc_common_axi4
    #(int AXI4_ADDRESS_WIDTH = 64, int AXI4_RDATA_WIDTH = 1024, int AXI4_WDATA_WIDTH = 1024, int AXI4_ID_WIDTH = 18, int AXI4_USER_WIDTH = 8, int AXI4_REGION_MAP_SIZE = 16)
    (input wire iACLK, input wire iARESETn);
    // Constant: AXI4_ADDRESS_WIDTH
    //
    // The width of the AWADDR and ARADDR signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2).
    //

    // Constant: AXI4_RDATA_WIDTH
    //
    // The width of the RDATA signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6).
    //

    // Constant: AXI4_WDATA_WIDTH
    //
    // The width of the WDATA signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.3).
    //

    // Constant: AXI4_ID_WIDTH
    //
    // The width of the AWID, ARID, RID and BID signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2).
    //

    // Constant: AXI4_USER_WIDTH
    //
    // The width of the AWUSER, ARUSER, WUSER, RUSER and BUSER signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.3).
    //

    // Constant: AXI4_REGION_MAP_SIZE
    //
    //  The number of address-decode entries in the region map (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2)
    // 
    // The address-decode function is done by the interconnect, generating a value for <mgc_axi4::AWREGION>/<mgc_axi4::ARREGION> from the transaction address. This parameter defines the size of the entries
    //  in the <mgc_axi4::config_region> region map array, where each entry defines a mapping from address-range to region value. The entry encodes these as a concatenation of lower-address bound, upper-address bound and region value.
    // 


    //------------------------------------------------------------------------------
    //
    // Wires for interface: axi4
    //
    //------------------------------------------------------------------------------

    // Wire: ACLK
    //
    //------------------------------------------------------------------------------
    //  The clock signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.1)
    // 
    //------------------------------------------------------------------------------
    wire ACLK;

    // Wire: ARESETn
    //
    // Note, no reference to X/Z, as they don't appear in emulation 
    //
    wire ARESETn;

    // Wire: AWVALID
    //
    //------------------------------------------------------------------------------
    //  The address-channel valid signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2, A3.2 and A3.3)
    // 
    //------------------------------------------------------------------------------
    wire AWVALID;

    // Wire: AWADDR
    //
    //------------------------------------------------------------------------------
    //  The write address signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_ADDRESS_WIDTH) - 1):0]  AWADDR;

    // Wire: AWPROT
    //
    //------------------------------------------------------------------------------
    //  The write-channel protection type (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [2:0] AWPROT;

    // Wire: AWREGION
    //
    //------------------------------------------------------------------------------
    //  The write-channel region signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [3:0] AWREGION;

    // Wire: AWLEN
    //
    //------------------------------------------------------------------------------
    //  The write-channel burst-length signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [7:0] AWLEN;

    // Wire: AWSIZE
    //
    //------------------------------------------------------------------------------
    //  The write-channel burst size signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [2:0] AWSIZE;

    // Wire: AWBURST
    //
    //------------------------------------------------------------------------------
    //  The write-channel burst type signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2.)
    // 
    //------------------------------------------------------------------------------
    wire [1:0] AWBURST;

    // Wire: AWLOCK
    //
    //------------------------------------------------------------------------------
    //  The write-channel lock type (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire AWLOCK;

    // Wire: AWCACHE
    //
    //------------------------------------------------------------------------------
    //  The write-channel cache type signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [3:0] AWCACHE;

    // Wire: AWQOS
    //
    //------------------------------------------------------------------------------
    //  The write-channel Quality-of-Service signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [3:0] AWQOS;

    // Wire: AWID
    //
    //------------------------------------------------------------------------------
    //  The write-channel master ID signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_ID_WIDTH) - 1):0]  AWID;

    // Wire: AWUSER
    //
    //------------------------------------------------------------------------------
    //  User-defined write-channel signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.3)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_USER_WIDTH) - 1):0]  AWUSER;

    // Wire: AWREADY
    //
    //------------------------------------------------------------------------------
    //  The write-channel handshake ready signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2 and A3.2)
    // 
    //------------------------------------------------------------------------------
    wire AWREADY;

    // Wire: ARVALID
    //
    //------------------------------------------------------------------------------
    //  The read address channel valid signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5 and A3.2)
    // 
    //------------------------------------------------------------------------------
    wire ARVALID;

    // Wire: ARADDR
    //
    //------------------------------------------------------------------------------
    //  The read address channel address signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_ADDRESS_WIDTH) - 1):0]  ARADDR;

    // Wire: ARPROT
    //
    //------------------------------------------------------------------------------
    //  The read address channel protection type signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [2:0] ARPROT;

    // Wire: ARREGION
    //
    //------------------------------------------------------------------------------
    //  The read address channel region signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [3:0] ARREGION;

    // Wire: ARLEN
    //
    //------------------------------------------------------------------------------
    //  The read address channel burst length signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [7:0] ARLEN;

    // Wire: ARSIZE
    //
    //------------------------------------------------------------------------------
    //  The read address channel burst size signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [2:0] ARSIZE;

    // Wire: ARBURST
    //
    //------------------------------------------------------------------------------
    //  The read address channel burst type signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [1:0] ARBURST;

    // Wire: ARLOCK
    //
    //------------------------------------------------------------------------------
    //  The read address channel lock type signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire ARLOCK;

    // Wire: ARCACHE
    //
    //------------------------------------------------------------------------------
    //  The read address channel cache type signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [3:0] ARCACHE;

    // Wire: ARQOS
    //
    //------------------------------------------------------------------------------
    //  The read address channel Quality-of-Service signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [3:0] ARQOS;

    // Wire: ARID
    //
    //------------------------------------------------------------------------------
    //  The read address channel master ID signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_ID_WIDTH) - 1):0]  ARID;

    // Wire: ARUSER
    //
    //------------------------------------------------------------------------------
    //  User-defined read address channel signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.3)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_USER_WIDTH) - 1):0]  ARUSER;

    // Wire: ARREADY
    //
    //------------------------------------------------------------------------------
    //  The read address channel handshake ready signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5 and A3.2)
    // 
    //------------------------------------------------------------------------------
    wire ARREADY;

    // Wire: RVALID
    //
    //------------------------------------------------------------------------------
    //  The read data channel handshake valid signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6 and A3.2)
    // 
    //------------------------------------------------------------------------------
    wire RVALID;

    // Wire: RDATA
    //
    //------------------------------------------------------------------------------
    //  The read data channel data signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_RDATA_WIDTH) - 1):0]  RDATA;

    // Wire: RRESP
    //
    //------------------------------------------------------------------------------
    //  The read data channel response signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6)
    // 
    //------------------------------------------------------------------------------
    wire [1:0] RRESP;

    // Wire: RLAST
    //
    //------------------------------------------------------------------------------
    //  The read data channel LAST signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6)
    // 
    //------------------------------------------------------------------------------
    wire RLAST;

    // Wire: RID
    //
    //------------------------------------------------------------------------------
    //  The read data channel master ID signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_ID_WIDTH) - 1):0]  RID;

    // Wire: RUSER
    //
    //------------------------------------------------------------------------------
    //  User-defined read data channel signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.3)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_USER_WIDTH) - 1):0]  RUSER;

    // Wire: RREADY
    //
    //------------------------------------------------------------------------------
    //  The read data channel handshake ready signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6)
    // 
    //------------------------------------------------------------------------------
    wire RREADY;

    // Wire: WVALID
    //
    //------------------------------------------------------------------------------
    //  The write data channel handshake valid signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.3)
    // 
    //------------------------------------------------------------------------------
    wire WVALID;

    // Wire: WDATA
    //
    //------------------------------------------------------------------------------
    //  The write data channel data signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.3)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_WDATA_WIDTH) - 1):0]  WDATA;

    // Wire: WSTRB
    //
    //------------------------------------------------------------------------------
    //  The write data channel strobe signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.3)
    // 
    //------------------------------------------------------------------------------
    wire [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  WSTRB;

    // Wire: WLAST
    //
    //------------------------------------------------------------------------------
    //  The write data channel LAST signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.3)
    // 
    //------------------------------------------------------------------------------
    wire WLAST;

    // Wire: WUSER
    //
    //------------------------------------------------------------------------------
    //  User-defined write data channel signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.3)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_USER_WIDTH) - 1):0]  WUSER;

    // Wire: WREADY
    //
    //------------------------------------------------------------------------------
    //  The write data channel handshake ready signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.3)
    // 
    //------------------------------------------------------------------------------
    wire WREADY;

    // Wire: BVALID
    //
    //------------------------------------------------------------------------------
    //  The write response channel handshake valid signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.4)
    // 
    //------------------------------------------------------------------------------
    wire BVALID;

    // Wire: BRESP
    //
    //------------------------------------------------------------------------------
    //  The write response channel response signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.4)
    // 
    //------------------------------------------------------------------------------
    wire [1:0] BRESP;

    // Wire: BID
    //
    //------------------------------------------------------------------------------
    //  The write response channel ID signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.4)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_ID_WIDTH) - 1):0]  BID;

    // Wire: BUSER
    //
    //------------------------------------------------------------------------------
    //  User-defined write response channel signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.4, A8.3)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_USER_WIDTH) - 1):0]  BUSER;

    // Wire: BREADY
    //
    //------------------------------------------------------------------------------
    //  The write response channel handshake ready signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.4)
    // 
    //------------------------------------------------------------------------------
    wire BREADY;

    // Propagate global signals onto interface wires
    assign ACLK = iACLK;
    assign ARESETn = iARESETn;

    //------------------------------------------------------------------------------
    // Global Variables - config
    //------------------------------------------------------------------------------

    // Variable:- config_interface_type
    //
    //  A configuration parameter (of type <axi4_interface_type_e>) defining the interface category: read/write, read only or write only (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.2).
    // 
    // The value defaults to <AXI4_READWRITE>.
    // 
    //
    axi4_interface_type_e config_interface_type;

    // Variable:- config_clk_init_value
    //
    //   The initial value of the clock signal (<ACLK>) generated by the <mgc_axi4> Questa Verification IP built-in clock generator (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.1). Defaults to 1'b0.
    // 
    //
    bit config_clk_init_value;

    // Variable:- config_clk_phase_shift
    //
    //  The number of simulator time-steps for which the initial value of the clock signal (<ACLK>) (when generated by the <mgc_axi4> Questa Verification IP built-in clock generator) shall be held.
    // 
    // By default, this is set to 5000, so that for the common case of simulating with 1 pico-second precision, the phase-shift is 5 nano-seconds. Users should use the
    // <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
    // See <Configuration of Time-Units> for background on configuration of time-units.
    // 
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    longint unsigned config_clk_phase_shift;

    // Variable:- config_clk_1st_time
    //
    //  The number of simulator time-steps for the first phase of the repeating clock signal (<ACLK>) generated by the <mgc_axi4> Questa Verification IP built-in clock generator.
    // 
    // By default, this is set to 5000, so that for the common case of simulating with 1 pico-second precision, the phase is 5 nano-seconds. Users should use the
    // <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
    // See <Configuration of Time-Units> for background on configuration of time-units.
    // 
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    longint unsigned config_clk_1st_time;

    // Variable:- config_clk_2nd_time
    //
    //  The number of simulator time-steps for the second phase of the repeating clock signal (<ACLK>) generated by the <mgc_axi4> Questa Verification IP built-in clock generator.
    // 
    // By default, this is set to 5000, so that for the common case of simulating with 1 pico-second precision, the phase is 5 nano-seconds. Users should use the
    // <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
    // See <Configuration of Time-Units> for background on configuration of time-units.
    // 
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    longint unsigned config_clk_2nd_time;

    // Variable:- config_setup_time
    //
    //  The setup-time, in units of simulator time-steps, for all signals. By default this is set to 0. Users should use the
    // <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
    // See <Configuration of Time-Units> for background on configuration of time-units.
    // 
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    longint unsigned config_setup_time;

    // Variable:- config_hold_time
    //
    //  The hold-time, in units of simulator time-steps, for all signals. By default this is set to 0. Users should use the
    // <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
    // See <Configuration of Time-Units> for background on configuration of time-units.
    // 
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    longint unsigned config_hold_time;

    // Variable:- config_burst_timeout_factor
    //
    //  The maximum number of clock-periods between phases.
    // 
    // This causes a timeout when an unreasonable time passes between transaction phases. It defaults to 10000 clock periods.
    // 
    //
    int unsigned config_burst_timeout_factor;

    // Variable:- config_max_transaction_time_factor
    //
    int unsigned config_max_transaction_time_factor;

    // Variable:- config_write_ctrl_first_ratio
    //
    // Data starts at same time as or after control phase.  Response follows data.
    //
    int config_write_ctrl_first_ratio;

    // Variable:- config_write_data_first_ratio
    //
    // control phase starts at same time as or after data phase.  Response follows data.
    //
    int config_write_data_first_ratio;

    // Variable:- config_reset_low_clocks
    //
    //  The number of clock-periods for which reset will be driven low (if the abstraction-level of the reset_source interface end is set to TLM-connected). This defaults to 5 clock-periods.
    // 
    //
    int config_reset_low_clocks;

    // Variable:- config_reset_hold_time
    //
    // The delay, as a number of simulator time-steps, after a rising clock edge before the reset signal (<ARESETn>) generated by the <mgc_axi4> Questa Verification IP built-in reset generator changes to inactive high.
    // By default this has the value 0. Users should use the <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
    //  See <Configuration of Time-Units> for background on configuration of time-units.
    // 
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    int config_reset_hold_time;

    // Variable:- config_enable_rlast
    //
    //  A configuration parameter controlling whether the optional <RLAST> signal is used, or not.
    // 
    // <RLAST> is an optional input to the master, because the length of a read burst is always known (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.3.5).
    // 
    //
    bit config_enable_rlast;

    // Variable:- config_enable_slave_exclusive
    //
    //  A configuration parameter controlling whether the slave supports exclusive accesses. (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.5)
    // 
    // By default this is set to true so that the slave will support exclusive accesses by responding with <AXI4_EXOKAY>.
    // 
    // The coverage collected by the covergroup <axi4_coverage::axi4_cvg> is affected by this parameter value setting.
    // 
    //
    bit config_enable_slave_exclusive;

    // Variable:- config_enable_burst_reserved_value
    //
    //  A configuration parameter controlling whether the <axi4_burst_e> reserved value <AXI4_RESERVED> is allowed as a legal value for the 'burst' parameter of <axi4_master_write>/<axi4_master_read>.
    // 
    // To enable this value, set the flag to 1(true) by e.g. config.m_bfm.set_config_enable_burst_reserved_value(1'b1). By default this has the value 0 (false).
    // 
    //
    bit config_enable_burst_reserved_value;

    // Variable:- config_enable_cache_value
    //
    //  An array of configuration parameters controlling whether individual reserved values of the <axi4_master_write::cache>/<axi4_master_read::cache> parameter (of type <axi4_cache_e>) are allowed as legal values of the AxCACHE signal.
    // 
    // To enable an individual reserved value, set the flag to 1 (true) by e.g. config.m_bfm.set_config_enable_cache_value_index1( <AXI4_CACHE_RSVD_12>, 1'b1). To enable all reserved values, do config.set_config_enable_cache_value('1); 
    // 
    // See Also:
    // The <axi4_payload_error_sequence::body()> function shows how this feature may be exercised. The following covergroups are used to collect coverage of these parameter values:
    // + <axi4_coverage::coverage_of_cache_rsvd_4_value>
    // + <axi4_coverage::coverage_of_cache_rsvd_5_value>
    // + <axi4_coverage::coverage_of_cache_rsvd_8_value>
    // + <axi4_coverage::coverage_of_cache_rsvd_9_value>
    // + <axi4_coverage::coverage_of_cache_rsvd_12_value>
    // + <axi4_coverage::coverage_of_cache_rsvd_13_value>
    // 
    // <Error Injection in AXI4> gives a fuller description of configurable error-injection.
    // 
    //
    bit [15:0] config_enable_cache_value;

    // Variable:- internal_dummy_variable
    //
    //  A variable required for internal technical reasons. Ignore it (changes to this will have no effect on behavior).
    // 
    //
    axi4_error_e internal_dummy_variable;

    // Variable:- config_axi4lite_interface
    //
    //  If user want to use QVIP BFM on the axi4lite interface, then this
    //  configuration variable should be set to true.
    // 
    //
    bit config_axi4lite_interface;

    // Variable:- config_axi4lite_tr_id
    //
    //  Configuration variable to set ID to a fixed value when QVIP BFM is configured as axi4lite
    // 
    //
    bit [((AXI4_ID_WIDTH) - 1):0]  config_axi4lite_tr_id;

    // Variable:- config_enable_all_assertions
    //
    //  Configuration parameter controlling whether the error messages(Assertions) issued from the QVIP are Enabled or Disabled.  
    //      By default, it is enabled.
    //   
    //
    bit config_enable_all_assertions;

    // Variable:- config_enable_assertion
    //
    //  An array of configuration parameters controlling whether specific error messages(Assertion) can be issued by the QVIP.
    //      By default, all errors are enabled. 
    //      To suppress a particular error, set the corresponding bit to 0 (false).
    //   
    //
    bit [255:0] config_enable_assertion;

    // Variable:- config_enable_error
    //
    //  This configuration variable is deprecated. Please use <config_enable_assertion> variable for this functionality.
    // An array of configuration parameters controlling whether specific error messages (of type <axi4_error_e>) can be issued by the Questa Verification IP. 
    // By default, all errors (excepting <AXI4_WRITE_DATA_BEFORE_ADDRESS>) are enabled. To suppress a particular error, set the corresponding bit to 0 (false) by e.g. config.m_bfm.set_config_enable_error_index1(<AXI4_WRITE_DATA_BEFORE_ADDRESS>, 0);
    // 
    //
    bit [255:0] config_enable_error;

    // Variable:- config_max_latency_AWVALID_assertion_to_AWREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <AWVALID> to the assertion of <AWREADY> (default 10000).
    // 
    // The error message <AXI4_AWREADY_NOT_ASSERTED_AFTER_AWVALID> will be issued if this period elapses from the assertion of <AWVALID>.
    // 
    //
    int unsigned config_max_latency_AWVALID_assertion_to_AWREADY;

    // Variable:- config_max_latency_ARVALID_assertion_to_ARREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <ARVALID> to the assertion of <ARREADY> (default 10000).
    // 
    // The error message <AXI4_ARREADY_NOT_ASSERTED_AFTER_ARVALID> will be issued if this period elapses from the assertion of <ARVALID>.
    // 
    //
    int unsigned config_max_latency_ARVALID_assertion_to_ARREADY;

    // Variable:- config_max_latency_RVALID_assertion_to_RREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <RVALID> to the assertion of <RREADY> (default 10000).
    // 
    // The error message <AXI4_RREADY_NOT_ASSERTED_AFTER_RVALID> will be issued if this period elapses from the assertion of <RVALID>.
    // 
    //
    int unsigned config_max_latency_RVALID_assertion_to_RREADY;

    // Variable:- config_max_latency_BVALID_assertion_to_BREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <BVALID> to the assertion of <BREADY> (default 10000).
    // 
    // The error message <AXI4_BREADY_NOT_ASSERTED_AFTER_BVALID> will be issued if this period elapses from the assertion of <BVALID>.
    // 
    //
    int unsigned config_max_latency_BVALID_assertion_to_BREADY;

    // Variable:- config_max_latency_WVALID_assertion_to_WREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <WVALID> to the assertion of <WREADY> (default 10000).
    // 
    // The error message <AXI4_WREADY_NOT_ASSERTED_AFTER_WVALID> will be issued if this period elapses from the assertion of <WVALID>.
    // 
    //
    int unsigned config_max_latency_WVALID_assertion_to_WREADY;

    // Variable:- config_enable_qos
    //
    //  A configuration parameter defining whether the master participates in the Quality-of-Service scheme  (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.1.2). 
    // 
    // This defaults to 'true' i.e. the master participates in the Quality-of-Service scheme. If a master does not participate, the <AWQOS>/<ARQOS> value used in write/read transactions must be b0000.
    // 
    //
    bit config_enable_qos;

    // Variable:- config_enable_region_support
    //
    //  A configuration parameter enabling region address decoding by the Questa Verification IP (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1).
    // 
    // When set to 'true', the Questa Verification IP will, during generation, perform an address decode function, using the <config_region> region map, and provide the
    //  <axi4_master_rw_transaction::region>, <axi4_master_write::region>, <axi4_master_write::region> parameter values (ignoring any value provided by the user); during recognition the Questa Verification IP will check the observed region value against the region map for correctness.
    // 
    // When set to 'false' (the default), the Questa Verification IP will not perform the decode function, and will pass the user-defined region parameter value to the slave; this supports error-injection (see <Error Injection in AXI4>).
    // 
    //
    bit config_enable_region_support;

    // Variable:- config_slave_regions
    //
    //  The number of regions supported by the slave end of this interface.
    // 
    // The system interconnect can provide an address decode of the address space into regions (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1), relieving the slave of the need to decode the address itself.   
    // 
    //  This defaults to <AXI4_REGION_MAP_SIZE>.
    // 
    //
    int config_slave_regions;

    // Variable:- config_region
    //
    //  An array of configurable system region map entries.
    // 
    // Each entry consists of a concatenation of the region lower-address boundary, upper-address boundary, region value and cachable/non-cacheable bit. The number of entries is given by <config_slave_regions>, and the size of the array by the configuration parameter <AXI4_REGION_MAP_SIZE> (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1 and A4.5).
    // 
    // When <config_enable_region_support> is set to true (1'b1), and no errors were detected in the region-map (<region_error_state>), constraints will be applied to enforce that the region parameter of <axi4_master_write>, <axi4_master_read>, <axi4_master_rw_transaction>, <axi4_master_write_addr_channel_phase> and <axi4_master_read_addr_channel_phase>) has the value defined in the region map for the given address. 
    // 
    // In addition, a constraint (for example, <axi4_master_write::exclusive_access_to_non_cacheable_address_region_constraint>) will be enforced to ensure that exclusive accesses can only be made to non-cacheable regions of the address map (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4 and A4.5). 
    // 
    // Here is example code for initializing the region map in SystemVerilog (for the case AXI4_ADDRESS_WIDTH = 32, AXI4_REGION_MAP_SIZE = 16). Note that the first entry in the array is at the end of the initializer!
    // 
    // (start code)
    //   typedef bit[AXI4_ADDRESS_WIDTH-1:0] Address;
    //   axi4_if.set_config_enable_region_support(1'b1);
    //   axi4_if.set_config_slave_regions(16);
    //   axi4_if.set_config_region(config_t::axi4_region_map_t'{
    //     // lower-bound address   upper-bound address    region cacheable
    //     {Address'(32'hf0000000), Address'(32'hffffffff),4'hf, 1'b0},
    //     {Address'(32'he0000000), Address'(32'hefffffff),4'he, 1'b0},
    //     {Address'(32'hd0000000), Address'(32'hdfffffff),4'hd, 1'b0},
    //     {Address'(32'hc0000000), Address'(32'hcfffffff),4'hc, 1'b0},
    //     {Address'(32'hb0000000), Address'(32'hbfffffff),4'hb, 1'b0},
    //     {Address'(32'ha0000000), Address'(32'hafffffff),4'ha, 1'b0},
    //     {Address'(32'h90000000), Address'(32'h9fffffff),4'h9, 1'b0},
    //     {Address'(32'h80000000), Address'(32'h8fffffff),4'h8, 1'b1},
    //     {Address'(32'h70000000), Address'(32'h7fffffff),4'h7, 1'b1},
    //     {Address'(32'h60000000), Address'(32'h6fffffff),4'h6, 1'b1},
    //     {Address'(32'h50000000), Address'(32'h5fffffff),4'h5, 1'b1},
    //     {Address'(32'h40000000), Address'(32'h4fffffff),4'h4, 1'b1},
    //     {Address'(32'h30000000), Address'(32'h3fffffff),4'h3, 1'b1},
    //     {Address'(32'h20000000), Address'(32'h2fffffff),4'h2, 1'b1},
    //     {Address'(32'h10000000), Address'(32'h1fffffff),4'h1, 1'b1},
    //     {Address'(32'h00000000), Address'(32'h0fffffff),4'h0, 1'b1}
    //   });
    // (end code)
    // 
    // Note the use of the axi4_region_map_t type defined in <axi4_vip_config>, to avoid conversion problems on some simulators.
    // 
    // 
    //
    bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  config_region;

    // Variable:- config_read_data_reordering_depth
    //
    //  A configuration parameter defining the read reordering depth of the slave end of the interface (see AMBA AXI and ACE Protocol Specification IHI0022D section A5.3.1).
    // 
    // Responses from the first <config_read_data_reordering_depth> outstanding read transactions, each with address <ARID> values different from any
    //  earlier outstanding read transaction(as seen by the slave) are expected, interleaved at random. A violation causes a <AXI4_READ_REORDERING_VIOLATION> error.
    // 
    // The default value of <config_read_data_reordering_depth> is (1 << AXI4_ID_WIDTH), so that the slave is expected to process all transactions in any order (up to uniqueness of <ARID>).
    // 
    // For a given <AXI4_ID_WIDTH> parameter value, the maximum possible value of <config_read_data_reordering_depth> is 2**AXI4_ID_WIDTH. The <AXI4_PARAM_READ_REORDERING_DEPTH_EXCEEDS_MAX_ID>
    //  error report will be issued if <config_read_data_reordering_depth> exceeds this value.
    // 
    // If the user-supplied value is 0, the <AXI4_PARAM_READ_REORDERING_DEPTH_EQUALS_ZERO> error will be issued, and the value will be set to 1.
    // 
    //
    int unsigned config_read_data_reordering_depth;

    // Variable:- config_slave_start_addr
    //
    //  A configuration parameter indicating start address for slave.
    // 
    //
    bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr;

    // Variable:- config_slave_end_addr
    //
    //  A configuration parameter indicating end address for slave.
    // 
    //
    bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr;

    // Variable:- config_slave_enabled_non_contiguous_address_spaces
    //
    // 
    //    This variable is used to configure the number of enabled non-contiguous address spaces for AXI4 Slaves in the system.
    //    By default, it is assumed that AXI4 slave posses only one contiguous address space. The default value of this configuration is 1.  
    //    If this configuration is set to (let's say 10), it indicates that the AXI4 slave in the system possess 10 non-contiguous address spaces.
    //    Default value is 1.
    //    Please note that this configuration shall come into effect only when the AXI4 slaves in the system support multiple non-contiguous address spaces. (i.e. config_slave_possess_multiple_non_contiguous_address_spaces = 0b1) 
    // 
    //
    int config_slave_enabled_non_contiguous_address_spaces;

    // Variable:- config_slave_possess_multiple_non_contiguous_address_spaces
    //
    // 
    //    This variable is used to configure whether AXI4 Slaves in the system possess multiple non-contiguous address space.
    //    If this configuration is set to False, it indicate that AXI4 slaves in the system possess single contiguous address space.
    //    If this configuration is set to True, it indicate that AXI4 slaves in the system possess multiple contiguous address spaces.
    //    Default value is False.
    // 
    //
    bit config_slave_possess_multiple_non_contiguous_address_spaces;

    // Variable:- config_slave_multiple_non_contiguous_start_address_range
    //
    // 
    //    This variable is used to configure the Start Addresses of all the non-contiguous address spaces for the Various AXI4 Slaves in the system.
    //    Address map for the for a particular non-contiguous address space in the slave - Start Address for that non-contiguous address space in the Slave
    // 
    //
    bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_start_address_range;

    // Variable:- config_slave_multiple_non_contiguous_end_address_range
    //
    // 
    //    This variable is used to configure the End Addresses of all the non-contiguous address spaces for the Various AXI4 Slaves in the system.
    //    Address map for the for a particular non-contiguous address space in the slave - End Address for that non-contiguous address space in the Slave
    // 
    //
    bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_end_address_range;

    // Variable:- config_protect_ready
    //
    //  A configuration parameter controlling whether the wave display will show transaction items representing the state of the <mgc_axi4::AWREADY>, <mgc_axi4::ARREADY>, <mgc_axi4::BREADY>, <mgc_axi4::WREADY> and <mgc_axi4::RREADY> signals. 
    // 
    // If set to 1'b0, the transaction items will be shown on the wave display. Since this display has a performance penalty, the default value of this parameter is 1'b1 (i.e. do not display).
    // 
    //
    bit config_protect_ready;

    // Variable:- config_max_outstanding_wr
    //
    int config_max_outstanding_wr;

    // Variable:- config_max_outstanding_rd
    //
    int config_max_outstanding_rd;

    // Variable:- config_num_outstanding_wr_phase
    //
    int config_num_outstanding_wr_phase;

    // Variable:- config_num_outstanding_rd_phase
    //
    int config_num_outstanding_rd_phase;

    // Variable:- config_enable_warnings
    //
    // A configuration parameter controlling whether warning messages are to be output.  This defaults to 1'b1 i.e. output warnings.
    //
    bit config_enable_warnings;

    // Variable:- config_enable_errors
    //
    //  This configuration variable is deprecated. Please use <config_enable_all_assertions> variable for this functionality.
    //    A configuration parameter controlling whether error messages are to be output.  This defaults to 1'b1 i.e. output error messages.
    // 
    //
    bit config_enable_errors;

    // Variable:- config_enable_exclusive_checks
    //
    // A configuration parameter controlling whether error messages related to exclusive accesses are to be output.  This defaults to 1'b1 i.e. output error messages.
    //
    bit config_enable_exclusive_checks;

    // Variable:- config_warn_on_slave_errors
    //
    //  A configuration parameter controlling whether an error message is to be issued in the case where the slave returns a response indicating an error. (This default to 1'b1 i.e. output error messages).
    // 
    // An error response (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.4) from the slave end occurs when
    // + the interconnect responds with <AXI4_DECERR> because it cannot locate a slave at the transaction address;
    // + the slave responds with <AXI4_SLVERR> because it wishes to signal an error condition to the master;
    // 
    // 
    //
    bit config_warn_on_slave_errors;

    // Variable:- config_error_on_deleted_valid_cycles
    //
    //  A configuration parameter controlling whether an error message will be issued when a valid transaction item is not recognized. 
    // 
    // When set to 1'b1 (the default), an error message will be issued.
    // 
    //
    bit config_error_on_deleted_valid_cycles;

    // Variable:- config_stats_enable
    //
    bit config_stats_enable;

    // Variable:- config_stats_enable_read_occupancy
    //
    bit config_stats_enable_read_occupancy;

    // Variable:- config_stats_enable_write_occupancy
    //
    bit config_stats_enable_write_occupancy;

    // Variable:- config_stats_enable_read_data_occupancy
    //
    bit config_stats_enable_read_data_occupancy;

    // Variable:- config_stats_enable_write_data_occupancy
    //
    bit config_stats_enable_write_data_occupancy;

    // Variable:- config_stats_enable_read_latency
    //
    bit config_stats_enable_read_latency;

    // Variable:- config_stats_enable_write_latency
    //
    bit config_stats_enable_write_latency;

    // Variable:- config_stats_enable_read_address_waits
    //
    bit config_stats_enable_read_address_waits;

    // Variable:- config_stats_enable_read_data_waits
    //
    bit config_stats_enable_read_data_waits;

    // Variable:- config_stats_enable_write_address_waits
    //
    bit config_stats_enable_write_address_waits;

    // Variable:- config_stats_enable_write_data_waits
    //
    bit config_stats_enable_write_data_waits;

    // Variable:- config_stats_enable_write_response_waits
    //
    bit config_stats_enable_write_response_waits;

    // Variable:- config_stats_enable_read_bandwidth
    //
    bit config_stats_enable_read_bandwidth;

    // Variable:- config_stats_enable_write_bandwidth
    //
    bit config_stats_enable_write_bandwidth;

    // Variable:- config_stats_read_occupancy_step
    //
    int config_stats_read_occupancy_step;

    // Variable:- config_stats_read_occupancy_multiple
    //
    int config_stats_read_occupancy_multiple;

    // Variable:- config_stats_write_occupancy_step
    //
    int config_stats_write_occupancy_step;

    // Variable:- config_stats_write_occupancy_multiple
    //
    int config_stats_write_occupancy_multiple;

    // Variable:- config_stats_read_data_occupancy_step
    //
    int config_stats_read_data_occupancy_step;

    // Variable:- config_stats_read_data_occupancy_multiple
    //
    int config_stats_read_data_occupancy_multiple;

    // Variable:- config_stats_write_data_occupancy_step
    //
    int config_stats_write_data_occupancy_step;

    // Variable:- config_stats_write_data_occupancy_multiple
    //
    int config_stats_write_data_occupancy_multiple;

    // Variable:- config_stats_read_bandwidth_step
    //
    int config_stats_read_bandwidth_step;

    // Variable:- config_stats_read_bandwidth_multiple
    //
    int config_stats_read_bandwidth_multiple;

    // Variable:- config_stats_write_bandwidth_step
    //
    int config_stats_write_bandwidth_step;

    // Variable:- config_stats_write_bandwidth_multiple
    //
    int config_stats_write_bandwidth_multiple;

    // Variable:- config_stats_read_latency_step
    //
    int config_stats_read_latency_step;

    // Variable:- config_stats_read_latency_multiple
    //
    int config_stats_read_latency_multiple;

    // Variable:- config_stats_write_latency_step
    //
    int config_stats_write_latency_step;

    // Variable:- config_stats_write_latency_multiple
    //
    int config_stats_write_latency_multiple;

    // Variable:- config_stats_read_address_waits_step
    //
    int config_stats_read_address_waits_step;

    // Variable:- config_stats_read_address_waits_multiple
    //
    int config_stats_read_address_waits_multiple;

    // Variable:- config_stats_read_data_waits_step
    //
    int config_stats_read_data_waits_step;

    // Variable:- config_stats_read_data_waits_multiple
    //
    int config_stats_read_data_waits_multiple;

    // Variable:- config_stats_write_address_waits_step
    //
    int config_stats_write_address_waits_step;

    // Variable:- config_stats_write_address_waits_multiple
    //
    int config_stats_write_address_waits_multiple;

    // Variable:- config_stats_write_data_waits_step
    //
    int config_stats_write_data_waits_step;

    // Variable:- config_stats_write_data_waits_multiple
    //
    int config_stats_write_data_waits_multiple;

    // Variable:- config_stats_write_response_waits_step
    //
    int config_stats_write_response_waits_step;

    // Variable:- config_stats_write_response_waits_multiple
    //
    int config_stats_write_response_waits_multiple;

    //------------------------------------------------------------------------------
    // Global Variables - status
    //------------------------------------------------------------------------------

    // Variable:- region_error_state
    //
    //  A read-only flag, internally set to true if there had been an error with the region specification provided by the user.
    // 
    // If true, behave as though <config_enable_region_support> is false. 
    // 
    // 
    //
    bit region_error_state;

    // Variable:- region_map_lb
    //
    //  An array showing the lower address bound for each region in the <config_region> region map. This is extracted from the user-supplied <config_region>, and is non-modifiable.
    // 
    // Although the information is already present in <config_region>, on certain simulators it was not usable within constraints, and had to be extracted into a separate array. 
    // 
    //
    longint unsigned region_map_lb [((AXI4_REGION_MAP_SIZE) - 1):0];

    // Variable:- region_map_ub
    //
    //  An array showing the upper address bound for each region in the <config_region> region map. This is extracted from the user-supplied <config_region>, and is non-modifiable.
    // 
    // Although the information is already present in <config_region>, on certain simulators it was not usable within constraints, and had to be extracted into a separate array. 
    // 
    //
    longint unsigned region_map_ub [((AXI4_REGION_MAP_SIZE) - 1):0];

    // Variable:- region_map_region
    //
    //  An array showing the regions in the <config_region> region map. This is extracted from the user-supplied <config_region>, and is non-modifiable.
    // 
    // Although the information is already present in <config_region>, on certain simulators it was not usable within constraints, and had to be extracted into a separate array. 
    // 
    //
    byte unsigned region_map_region [((AXI4_REGION_MAP_SIZE) - 1):0];

    // Variable:- cacheable
    //
    //  An array showing the cacheability of each region in the <config_region> region map. This is extracted from the user-supplied <config_region>, and is non-modifiable.
    // 
    // Although the information is already present in <config_region>, on certain simulators it was not usable within constraints, and had to be extracted into a separate array. 
    // 
    //
    byte unsigned cacheable [((AXI4_REGION_MAP_SIZE) - 1):0];

    // Variable:- master_end_tlm_status
    //
    //  A status variable indicating whether the master end of the interface is TLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    // Once the end is set as TLM-connected, it should not be changed.
    // 
    //
    bit master_end_tlm_status;

    // Variable:- master_end_wlm_status
    //
    //  A status variable indicating whether the master end of the interface is WLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    //
    bit master_end_wlm_status;

    // Variable:- slave_end_tlm_status
    //
    //  A status variable indicating whether the slave end of the interface is TLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    // Once the end is set as TLM-connected, it should not be changed.
    // 
    //
    bit slave_end_tlm_status;

    // Variable:- slave_end_wlm_status
    //
    //  A status variable indicating whether the slave end of the interface is WLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    //
    bit slave_end_wlm_status;

    // Variable:- clock_source_end_tlm_status
    //
    //  A status variable indicating whether the clock_source end of the interface is TLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    // Once the end is set as TLM-connected, it should not be changed.
    // 
    //
    bit clock_source_end_tlm_status;

    // Variable:- clock_source_end_wlm_status
    //
    //  A status variable indicating whether the clock_source end of the interface is WLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    //
    bit clock_source_end_wlm_status;

    // Variable:- reset_source_end_tlm_status
    //
    //  A status variable indicating whether the reset_source end of the interface is TLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    // Once the end is set as TLM-connected, it should not be changed.
    // 
    //
    bit reset_source_end_tlm_status;

    // Variable:- reset_source_end_wlm_status
    //
    //  A status variable indicating whether the reset_source end of the interface is WLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    //
    bit reset_source_end_wlm_status;

    // Variable:- stats_rw_transaction_last_duration
    //
    int stats_rw_transaction_last_duration;

    // Variable:- stats_read_active
    //
    bit stats_read_active;

    // Variable:- stats_read_occupancy_sw
    //
    int stats_read_occupancy_sw;

    // Variable:- stats_read_idle_sw
    //
    int stats_read_idle_sw;

    // Variable:- stats_read_occupancy_min
    //
    int stats_read_occupancy_min;

    // Variable:- stats_read_idle_min
    //
    int stats_read_idle_min;

    // Variable:- stats_read_occupancy_max
    //
    int stats_read_occupancy_max;

    // Variable:- stats_read_idle_max
    //
    int stats_read_idle_max;

    // Variable:- stats_read_occupancy_mean
    //
    int stats_read_occupancy_mean;

    // Variable:- stats_read_idle_mean
    //
    int stats_read_idle_mean;

    // Variable:- stats_read_last_duration
    //
    int stats_read_last_duration;

    // Variable:- stats_write_active
    //
    bit stats_write_active;

    // Variable:- stats_write_occupancy_sw
    //
    int stats_write_occupancy_sw;

    // Variable:- stats_write_idle_sw
    //
    int stats_write_idle_sw;

    // Variable:- stats_write_occupancy_min
    //
    int stats_write_occupancy_min;

    // Variable:- stats_write_idle_min
    //
    int stats_write_idle_min;

    // Variable:- stats_write_occupancy_max
    //
    int stats_write_occupancy_max;

    // Variable:- stats_write_idle_max
    //
    int stats_write_idle_max;

    // Variable:- stats_write_occupancy_mean
    //
    int stats_write_occupancy_mean;

    // Variable:- stats_write_idle_mean
    //
    int stats_write_idle_mean;

    // Variable:- stats_write_last_duration
    //
    int stats_write_last_duration;

    // Variable:- stats_read_data_occupancy_sw
    //
    int stats_read_data_occupancy_sw;

    // Variable:- stats_read_data_idle_sw
    //
    int stats_read_data_idle_sw;

    // Variable:- stats_read_data_occupancy_min
    //
    int stats_read_data_occupancy_min;

    // Variable:- stats_read_data_idle_min
    //
    int stats_read_data_idle_min;

    // Variable:- stats_read_data_occupancy_max
    //
    int stats_read_data_occupancy_max;

    // Variable:- stats_read_data_idle_max
    //
    int stats_read_data_idle_max;

    // Variable:- stats_read_data_occupancy_mean
    //
    int stats_read_data_occupancy_mean;

    // Variable:- stats_read_data_idle_mean
    //
    int stats_read_data_idle_mean;

    // Variable:- stats_write_data_occupancy_sw
    //
    int stats_write_data_occupancy_sw;

    // Variable:- stats_write_data_idle_sw
    //
    int stats_write_data_idle_sw;

    // Variable:- stats_write_data_occupancy_min
    //
    int stats_write_data_occupancy_min;

    // Variable:- stats_write_data_idle_min
    //
    int stats_write_data_idle_min;

    // Variable:- stats_write_data_occupancy_max
    //
    int stats_write_data_occupancy_max;

    // Variable:- stats_write_data_idle_max
    //
    int stats_write_data_idle_max;

    // Variable:- stats_write_data_occupancy_mean
    //
    int stats_write_data_occupancy_mean;

    // Variable:- stats_write_data_idle_mean
    //
    int stats_write_data_idle_mean;

    // Variable:- stats_read_bandwidth_sw
    //
    int stats_read_bandwidth_sw;

    // Variable:- stats_read_bandwidth_min
    //
    int stats_read_bandwidth_min;

    // Variable:- stats_read_bandwidth_max
    //
    int stats_read_bandwidth_max;

    // Variable:- stats_read_bandwidth_mean
    //
    int stats_read_bandwidth_mean;

    // Variable:- stats_write_bandwidth_sw
    //
    int stats_write_bandwidth_sw;

    // Variable:- stats_write_bandwidth_min
    //
    int stats_write_bandwidth_min;

    // Variable:- stats_write_bandwidth_max
    //
    int stats_write_bandwidth_max;

    // Variable:- stats_write_bandwidth_mean
    //
    int stats_write_bandwidth_mean;

    // Variable:- stats_read_address_data_latency_inst
    //
    int stats_read_address_data_latency_inst;

    // Variable:- stats_read_address_data_latency_sw
    //
    int stats_read_address_data_latency_sw;

    // Variable:- stats_read_address_data_latency_min
    //
    int stats_read_address_data_latency_min;

    // Variable:- stats_read_address_data_latency_max
    //
    int stats_read_address_data_latency_max;

    // Variable:- stats_read_address_data_latency_mean
    //
    int stats_read_address_data_latency_mean;

    // Variable:- stats_read_address_address_latency_inst
    //
    int stats_read_address_address_latency_inst;

    // Variable:- stats_read_address_address_latency_sw
    //
    int stats_read_address_address_latency_sw;

    // Variable:- stats_read_address_address_latency_min
    //
    int stats_read_address_address_latency_min;

    // Variable:- stats_read_address_address_latency_max
    //
    int stats_read_address_address_latency_max;

    // Variable:- stats_read_address_address_latency_mean
    //
    int stats_read_address_address_latency_mean;

    // Variable:- stats_write_address_response_latency_inst
    //
    int stats_write_address_response_latency_inst;

    // Variable:- stats_write_address_response_latency_sw
    //
    int stats_write_address_response_latency_sw;

    // Variable:- stats_write_address_response_latency_min
    //
    int stats_write_address_response_latency_min;

    // Variable:- stats_write_address_response_latency_max
    //
    int stats_write_address_response_latency_max;

    // Variable:- stats_write_address_response_latency_mean
    //
    int stats_write_address_response_latency_mean;

    // Variable:- stats_write_address_address_latency_inst
    //
    int stats_write_address_address_latency_inst;

    // Variable:- stats_write_address_address_latency_sw
    //
    int stats_write_address_address_latency_sw;

    // Variable:- stats_write_address_address_latency_min
    //
    int stats_write_address_address_latency_min;

    // Variable:- stats_write_address_address_latency_max
    //
    int stats_write_address_address_latency_max;

    // Variable:- stats_write_address_address_latency_mean
    //
    int stats_write_address_address_latency_mean;

    // Variable:- stats_read_address_waits_inst
    //
    int stats_read_address_waits_inst;

    // Variable:- stats_read_address_waits_sw
    //
    int stats_read_address_waits_sw;

    // Variable:- stats_read_address_waits_min
    //
    int stats_read_address_waits_min;

    // Variable:- stats_read_address_waits_max
    //
    int stats_read_address_waits_max;

    // Variable:- stats_read_address_waits_mean
    //
    int stats_read_address_waits_mean;

    // Variable:- stats_read_data_waits_inst
    //
    int stats_read_data_waits_inst;

    // Variable:- stats_read_data_waits_sw
    //
    int stats_read_data_waits_sw;

    // Variable:- stats_read_data_waits_min
    //
    int stats_read_data_waits_min;

    // Variable:- stats_read_data_waits_max
    //
    int stats_read_data_waits_max;

    // Variable:- stats_read_data_waits_mean
    //
    int stats_read_data_waits_mean;

    // Variable:- stats_write_address_waits_inst
    //
    int stats_write_address_waits_inst;

    // Variable:- stats_write_address_waits_sw
    //
    int stats_write_address_waits_sw;

    // Variable:- stats_write_address_waits_min
    //
    int stats_write_address_waits_min;

    // Variable:- stats_write_address_waits_max
    //
    int stats_write_address_waits_max;

    // Variable:- stats_write_address_waits_mean
    //
    int stats_write_address_waits_mean;

    // Variable:- stats_write_data_waits_inst
    //
    int stats_write_data_waits_inst;

    // Variable:- stats_write_data_waits_sw
    //
    int stats_write_data_waits_sw;

    // Variable:- stats_write_data_waits_min
    //
    int stats_write_data_waits_min;

    // Variable:- stats_write_data_waits_max
    //
    int stats_write_data_waits_max;

    // Variable:- stats_write_data_waits_mean
    //
    int stats_write_data_waits_mean;

    // Variable:- stats_write_response_waits_inst
    //
    int stats_write_response_waits_inst;

    // Variable:- stats_write_response_waits_sw
    //
    int stats_write_response_waits_sw;

    // Variable:- stats_write_response_waits_min
    //
    int stats_write_response_waits_min;

    // Variable:- stats_write_response_waits_max
    //
    int stats_write_response_waits_max;

    // Variable:- stats_write_response_waits_mean
    //
    int stats_write_response_waits_mean;

    // Variable:- reordering_depth_of_last_read_transaction
    //
    //  The read reordering depth at which the first response to the last read transaction arrived (see AMBA AXI and ACE Protocol Specification IHI0022D section A5.3.1)
    // 
    // For <config_read_data_reordering_depth> equal to 1, responses to read transactions must arrive in the order of issuing the read addresses,
    // and all responses for a transaction must have arrived before any response to a later transaction arrive.
    // When the <config_read_data_reordering_depth> is greater than 1, the first responses to read transactions must still arrive in the order of issuing the read addresses,
    // but responses to later transactions do not have to wait until all responses to earlier transactions have arrived.
    // Instead, up to <config_read_data_reordering_depth> transactions can be receiving responses.
    // 
    // when the first response to a read transaction is observed, the Questa Verification IP records the position of this transaction is the queue of unfinished transactions;
    // at the end of the transaction, this value is copied to <reordering_depth_of_last_read_transaction>, so allowing coverage of the depth of read reordering.
    // This variable is read-only, and its value is overwritten by the next read transaction to finish.
    // 
    //
    int reordering_depth_of_last_read_transaction;

    //------------------------------------------------------------------------------
    // Interface ends and access functions
    //------------------------------------------------------------------------------

    longint axi4_master_end;

    //------------------------------------------------------------------------------
    // Function: get_axi4_master_end
    //------------------------------------------------------------------------------
    //
    // Returns:
    //     A handle to the master end of this instance of the <axi4> interface.
    //
    function longint get_axi4_master_end();
        return axi4_master_end;
    endfunction

    longint axi4_slave_end;

    //------------------------------------------------------------------------------
    // Function: get_axi4_slave_end
    //------------------------------------------------------------------------------
    //
    // Returns:
    //     A handle to the slave end of this instance of the <axi4> interface.
    //
    function longint get_axi4_slave_end();
        return axi4_slave_end;
    endfunction

    longint axi4_clock_source_end;

    //------------------------------------------------------------------------------
    // Function:- get_axi4_clock_source_end
    //------------------------------------------------------------------------------
    //
    // Returns:
    //     A handle to the clock_source end of this instance of the <axi4> interface.
    //
    function longint get_axi4_clock_source_end();
        return axi4_clock_source_end;
    endfunction

    longint axi4_reset_source_end;

    //------------------------------------------------------------------------------
    // Function:- get_axi4_reset_source_end
    //------------------------------------------------------------------------------
    //
    // Returns:
    //     A handle to the reset_source end of this instance of the <axi4> interface.
    //
    function longint get_axi4_reset_source_end();
        return axi4_reset_source_end;
    endfunction

    longint axi4__monitor_end;

    //------------------------------------------------------------------------------
    // Function: get_axi4__monitor_end
    //------------------------------------------------------------------------------
    //
    // Returns:
    //     A handle to the _monitor end of this instance of the <axi4> interface.
    //
    function longint get_axi4__monitor_end();
        return axi4__monitor_end;
    endfunction


    //------------------------------------------------------------------------------
    // Assertions
    //------------------------------------------------------------------------------
    // Documentation for assertions has been moved to <axi4_assertions.svh>.

    // Declare user visible wires variables, for non-continuous assignments.
    logic m_ACLK = 'z;
    logic m_ARESETn = 'z;
    logic m_AWVALID = 'z;
    logic [((AXI4_ADDRESS_WIDTH) - 1):0]  m_AWADDR = 'z;
    logic [2:0] m_AWPROT = 'z;
    logic [3:0] m_AWREGION = 'z;
    logic [7:0] m_AWLEN = 'z;
    logic [2:0] m_AWSIZE = 'z;
    logic [1:0] m_AWBURST = 'z;
    logic m_AWLOCK = 'z;
    logic [3:0] m_AWCACHE = 'z;
    logic [3:0] m_AWQOS = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  m_AWID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  m_AWUSER = 'z;
    logic m_AWREADY = 'z;
    logic m_ARVALID = 'z;
    logic [((AXI4_ADDRESS_WIDTH) - 1):0]  m_ARADDR = 'z;
    logic [2:0] m_ARPROT = 'z;
    logic [3:0] m_ARREGION = 'z;
    logic [7:0] m_ARLEN = 'z;
    logic [2:0] m_ARSIZE = 'z;
    logic [1:0] m_ARBURST = 'z;
    logic m_ARLOCK = 'z;
    logic [3:0] m_ARCACHE = 'z;
    logic [3:0] m_ARQOS = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  m_ARID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  m_ARUSER = 'z;
    logic m_ARREADY = 'z;
    logic m_RVALID = 'z;
    logic [((AXI4_RDATA_WIDTH) - 1):0]  m_RDATA = 'z;
    logic [1:0] m_RRESP = 'z;
    logic m_RLAST = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  m_RID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  m_RUSER = 'z;
    logic m_RREADY = 'z;
    logic m_WVALID = 'z;
    logic [((AXI4_WDATA_WIDTH) - 1):0]  m_WDATA = 'z;
    logic [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  m_WSTRB = 'z;
    logic m_WLAST = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  m_WUSER = 'z;
    logic m_WREADY = 'z;
    logic m_BVALID = 'z;
    logic [1:0] m_BRESP = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  m_BID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  m_BUSER = 'z;
    logic m_BREADY = 'z;

    import "DPI-C" context function longint axi4_initialise_SystemVerilog
    (
        int usage_code,
        output longint master_end,
        output longint slave_end,
        output longint clock_source_end,
        output longint reset_source_end,
        output longint _monitor_end,
        input int AXI4_ADDRESS_WIDTH,
        input int AXI4_RDATA_WIDTH,
        input int AXI4_WDATA_WIDTH,
        input int AXI4_ID_WIDTH,
        input int AXI4_USER_WIDTH,
        input int AXI4_REGION_MAP_SIZE
    );

    // Handle to the linkage
    (* elab_init *) longint _interface_ref =
                                axi4_initialise_SystemVerilog
                                (
                                    18102076,
                                    axi4_master_end,
                                    axi4_slave_end,
                                    axi4_clock_source_end,
                                    axi4_reset_source_end,
                                    axi4__monitor_end,
                                    AXI4_ADDRESS_WIDTH,
                                    AXI4_RDATA_WIDTH,
                                    AXI4_WDATA_WIDTH,
                                    AXI4_ID_WIDTH,
                                    AXI4_USER_WIDTH,
                                    AXI4_REGION_MAP_SIZE
                                ); // DPI call to create transactor (called at elaboration time as initialiser)

    // Forces a sweep through the wire change checkers at time 0 to get around process kick-off order unknowns
    bit _check_t0_values;
    always_comb _check_t0_values = 1;


    //------------------------------------------------------------------------------
    // Generic Interface Configuration Support
    //------------------------------------------------------------------------------

    import "DPI-C" context axi4_set_interface = function void axi4_set_interface
    (
        input int what,
        input int arg1,
        input int arg2,
        input int arg3,
        input int arg4,
        input int arg5,
        input int arg6,
        input int arg7,
        input int arg8,
        input int arg9,
        input int arg10
    );
    import "DPI-C" context axi4_get_interface = function int axi4_get_interface
    (
        input int what,
        input int arg1,
        input int arg2,
        input int arg3,
        input int arg4,
        input int arg5,
        input int arg6,
        input int arg7,
        input int arg8,
        input int arg9
    );
    //------------------------------------------------------------------------------
    // Functions to get the hierarchic name of this interface
    //------------------------------------------------------------------------------
    import "DPI-C" context axi4_get_full_name = function string axi4_get_full_name();

    //------------------------------------------------------------------------------
    // Abstraction level Support
    //------------------------------------------------------------------------------

    import "DPI-C" context axi4_set_master_end_abstraction_level = function void axi4_set_master_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi4_get_master_end_abstraction_level = function void axi4_get_master_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    import "DPI-C" context axi4_set_slave_end_abstraction_level = function void axi4_set_slave_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi4_get_slave_end_abstraction_level = function void axi4_get_slave_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    import "DPI-C" context axi4_set_clock_source_end_abstraction_level = function void axi4_set_clock_source_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi4_get_clock_source_end_abstraction_level = function void axi4_get_clock_source_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    import "DPI-C" context axi4_set_reset_source_end_abstraction_level = function void axi4_set_reset_source_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi4_get_reset_source_end_abstraction_level = function void axi4_get_reset_source_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );

    //------------------------------------------------------------------------------
    // Wire Level Interface Support
    //------------------------------------------------------------------------------
    logic internal_ACLK = 'z;
    logic internal_ARESETn = 'z;
    logic internal_AWVALID = 'z;
    logic [((AXI4_ADDRESS_WIDTH) - 1):0]  internal_AWADDR = 'z;
    logic [2:0] internal_AWPROT = 'z;
    logic [3:0] internal_AWREGION = 'z;
    logic [7:0] internal_AWLEN = 'z;
    logic [2:0] internal_AWSIZE = 'z;
    logic [1:0] internal_AWBURST = 'z;
    logic internal_AWLOCK = 'z;
    logic [3:0] internal_AWCACHE = 'z;
    logic [3:0] internal_AWQOS = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  internal_AWID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  internal_AWUSER = 'z;
    logic internal_AWREADY = 'z;
    logic internal_ARVALID = 'z;
    logic [((AXI4_ADDRESS_WIDTH) - 1):0]  internal_ARADDR = 'z;
    logic [2:0] internal_ARPROT = 'z;
    logic [3:0] internal_ARREGION = 'z;
    logic [7:0] internal_ARLEN = 'z;
    logic [2:0] internal_ARSIZE = 'z;
    logic [1:0] internal_ARBURST = 'z;
    logic internal_ARLOCK = 'z;
    logic [3:0] internal_ARCACHE = 'z;
    logic [3:0] internal_ARQOS = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  internal_ARID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  internal_ARUSER = 'z;
    logic internal_ARREADY = 'z;
    logic internal_RVALID = 'z;
    logic [((AXI4_RDATA_WIDTH) - 1):0]  internal_RDATA = 'z;
    logic [1:0] internal_RRESP = 'z;
    logic internal_RLAST = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  internal_RID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  internal_RUSER = 'z;
    logic internal_RREADY = 'z;
    logic internal_WVALID = 'z;
    logic [((AXI4_WDATA_WIDTH) - 1):0]  internal_WDATA = 'z;
    logic [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  internal_WSTRB = 'z;
    logic internal_WLAST = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  internal_WUSER = 'z;
    logic internal_WREADY = 'z;
    logic internal_BVALID = 'z;
    logic [1:0] internal_BRESP = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  internal_BID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  internal_BUSER = 'z;
    logic internal_BREADY = 'z;

    import "DPI-C" context function void axi4_set_ACLK_from_SystemVerilog
    (
        input bit ACLK_param
    );
    import "DPI-C" context function void axi4_get_ACLK_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ACLK_from_CY;
    export "DPI-C" function axi4_initialise_ACLK_from_CY;

    import "DPI-C" context function void axi4_set_ARESETn_from_SystemVerilog
    (
        input logic ARESETn_param
    );
    import "DPI-C" context function void axi4_get_ARESETn_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARESETn_from_CY;
    export "DPI-C" function axi4_initialise_ARESETn_from_CY;

    import "DPI-C" context function void axi4_set_AWVALID_from_SystemVerilog
    (
        input logic AWVALID_param
    );
    import "DPI-C" context function void axi4_get_AWVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWVALID_from_CY;
    export "DPI-C" function axi4_initialise_AWVALID_from_CY;

    import "DPI-C" context function void axi4_set_AWADDR_from_SystemVerilog
    (
        input logic [((AXI4_ADDRESS_WIDTH) - 1):0]  AWADDR_param
    );
    import "DPI-C" context function void axi4_get_AWADDR_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWADDR_from_CY;
    export "DPI-C" function axi4_initialise_AWADDR_from_CY;

    import "DPI-C" context function void axi4_set_AWPROT_from_SystemVerilog
    (
        input logic [2:0] AWPROT_param
    );
    import "DPI-C" context function void axi4_get_AWPROT_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWPROT_from_CY;
    export "DPI-C" function axi4_initialise_AWPROT_from_CY;

    import "DPI-C" context function void axi4_set_AWREGION_from_SystemVerilog
    (
        input logic [3:0] AWREGION_param
    );
    import "DPI-C" context function void axi4_get_AWREGION_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWREGION_from_CY;
    export "DPI-C" function axi4_initialise_AWREGION_from_CY;

    import "DPI-C" context function void axi4_set_AWLEN_from_SystemVerilog
    (
        input logic [7:0] AWLEN_param
    );
    import "DPI-C" context function void axi4_get_AWLEN_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWLEN_from_CY;
    export "DPI-C" function axi4_initialise_AWLEN_from_CY;

    import "DPI-C" context function void axi4_set_AWSIZE_from_SystemVerilog
    (
        input logic [2:0] AWSIZE_param
    );
    import "DPI-C" context function void axi4_get_AWSIZE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWSIZE_from_CY;
    export "DPI-C" function axi4_initialise_AWSIZE_from_CY;

    import "DPI-C" context function void axi4_set_AWBURST_from_SystemVerilog
    (
        input logic [1:0] AWBURST_param
    );
    import "DPI-C" context function void axi4_get_AWBURST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWBURST_from_CY;
    export "DPI-C" function axi4_initialise_AWBURST_from_CY;

    import "DPI-C" context function void axi4_set_AWLOCK_from_SystemVerilog
    (
        input logic AWLOCK_param
    );
    import "DPI-C" context function void axi4_get_AWLOCK_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWLOCK_from_CY;
    export "DPI-C" function axi4_initialise_AWLOCK_from_CY;

    import "DPI-C" context function void axi4_set_AWCACHE_from_SystemVerilog
    (
        input logic [3:0] AWCACHE_param
    );
    import "DPI-C" context function void axi4_get_AWCACHE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWCACHE_from_CY;
    export "DPI-C" function axi4_initialise_AWCACHE_from_CY;

    import "DPI-C" context function void axi4_set_AWQOS_from_SystemVerilog
    (
        input logic [3:0] AWQOS_param
    );
    import "DPI-C" context function void axi4_get_AWQOS_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWQOS_from_CY;
    export "DPI-C" function axi4_initialise_AWQOS_from_CY;

    import "DPI-C" context function void axi4_set_AWID_from_SystemVerilog
    (
        input logic [((AXI4_ID_WIDTH) - 1):0]  AWID_param
    );
    import "DPI-C" context function void axi4_get_AWID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWID_from_CY;
    export "DPI-C" function axi4_initialise_AWID_from_CY;

    import "DPI-C" context function void axi4_set_AWUSER_from_SystemVerilog
    (
        input logic [((AXI4_USER_WIDTH) - 1):0]  AWUSER_param
    );
    import "DPI-C" context function void axi4_get_AWUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWUSER_from_CY;
    export "DPI-C" function axi4_initialise_AWUSER_from_CY;

    import "DPI-C" context function void axi4_set_AWREADY_from_SystemVerilog
    (
        input logic AWREADY_param
    );
    import "DPI-C" context function void axi4_get_AWREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWREADY_from_CY;
    export "DPI-C" function axi4_initialise_AWREADY_from_CY;

    import "DPI-C" context function void axi4_set_ARVALID_from_SystemVerilog
    (
        input logic ARVALID_param
    );
    import "DPI-C" context function void axi4_get_ARVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARVALID_from_CY;
    export "DPI-C" function axi4_initialise_ARVALID_from_CY;

    import "DPI-C" context function void axi4_set_ARADDR_from_SystemVerilog
    (
        input logic [((AXI4_ADDRESS_WIDTH) - 1):0]  ARADDR_param
    );
    import "DPI-C" context function void axi4_get_ARADDR_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARADDR_from_CY;
    export "DPI-C" function axi4_initialise_ARADDR_from_CY;

    import "DPI-C" context function void axi4_set_ARPROT_from_SystemVerilog
    (
        input logic [2:0] ARPROT_param
    );
    import "DPI-C" context function void axi4_get_ARPROT_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARPROT_from_CY;
    export "DPI-C" function axi4_initialise_ARPROT_from_CY;

    import "DPI-C" context function void axi4_set_ARREGION_from_SystemVerilog
    (
        input logic [3:0] ARREGION_param
    );
    import "DPI-C" context function void axi4_get_ARREGION_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARREGION_from_CY;
    export "DPI-C" function axi4_initialise_ARREGION_from_CY;

    import "DPI-C" context function void axi4_set_ARLEN_from_SystemVerilog
    (
        input logic [7:0] ARLEN_param
    );
    import "DPI-C" context function void axi4_get_ARLEN_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARLEN_from_CY;
    export "DPI-C" function axi4_initialise_ARLEN_from_CY;

    import "DPI-C" context function void axi4_set_ARSIZE_from_SystemVerilog
    (
        input logic [2:0] ARSIZE_param
    );
    import "DPI-C" context function void axi4_get_ARSIZE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARSIZE_from_CY;
    export "DPI-C" function axi4_initialise_ARSIZE_from_CY;

    import "DPI-C" context function void axi4_set_ARBURST_from_SystemVerilog
    (
        input logic [1:0] ARBURST_param
    );
    import "DPI-C" context function void axi4_get_ARBURST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARBURST_from_CY;
    export "DPI-C" function axi4_initialise_ARBURST_from_CY;

    import "DPI-C" context function void axi4_set_ARLOCK_from_SystemVerilog
    (
        input logic ARLOCK_param
    );
    import "DPI-C" context function void axi4_get_ARLOCK_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARLOCK_from_CY;
    export "DPI-C" function axi4_initialise_ARLOCK_from_CY;

    import "DPI-C" context function void axi4_set_ARCACHE_from_SystemVerilog
    (
        input logic [3:0] ARCACHE_param
    );
    import "DPI-C" context function void axi4_get_ARCACHE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARCACHE_from_CY;
    export "DPI-C" function axi4_initialise_ARCACHE_from_CY;

    import "DPI-C" context function void axi4_set_ARQOS_from_SystemVerilog
    (
        input logic [3:0] ARQOS_param
    );
    import "DPI-C" context function void axi4_get_ARQOS_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARQOS_from_CY;
    export "DPI-C" function axi4_initialise_ARQOS_from_CY;

    import "DPI-C" context function void axi4_set_ARID_from_SystemVerilog
    (
        input logic [((AXI4_ID_WIDTH) - 1):0]  ARID_param
    );
    import "DPI-C" context function void axi4_get_ARID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARID_from_CY;
    export "DPI-C" function axi4_initialise_ARID_from_CY;

    import "DPI-C" context function void axi4_set_ARUSER_from_SystemVerilog
    (
        input logic [((AXI4_USER_WIDTH) - 1):0]  ARUSER_param
    );
    import "DPI-C" context function void axi4_get_ARUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARUSER_from_CY;
    export "DPI-C" function axi4_initialise_ARUSER_from_CY;

    import "DPI-C" context function void axi4_set_ARREADY_from_SystemVerilog
    (
        input logic ARREADY_param
    );
    import "DPI-C" context function void axi4_get_ARREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARREADY_from_CY;
    export "DPI-C" function axi4_initialise_ARREADY_from_CY;

    import "DPI-C" context function void axi4_set_RVALID_from_SystemVerilog
    (
        input logic RVALID_param
    );
    import "DPI-C" context function void axi4_get_RVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_RVALID_from_CY;
    export "DPI-C" function axi4_initialise_RVALID_from_CY;

    import "DPI-C" context function void axi4_set_RDATA_from_SystemVerilog
    (
        input logic [((AXI4_RDATA_WIDTH) - 1):0]  RDATA_param
    );
    import "DPI-C" context function void axi4_get_RDATA_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_RDATA_from_CY;
    export "DPI-C" function axi4_initialise_RDATA_from_CY;

    import "DPI-C" context function void axi4_set_RRESP_from_SystemVerilog
    (
        input logic [1:0] RRESP_param
    );
    import "DPI-C" context function void axi4_get_RRESP_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_RRESP_from_CY;
    export "DPI-C" function axi4_initialise_RRESP_from_CY;

    import "DPI-C" context function void axi4_set_RLAST_from_SystemVerilog
    (
        input logic RLAST_param
    );
    import "DPI-C" context function void axi4_get_RLAST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_RLAST_from_CY;
    export "DPI-C" function axi4_initialise_RLAST_from_CY;

    import "DPI-C" context function void axi4_set_RID_from_SystemVerilog
    (
        input logic [((AXI4_ID_WIDTH) - 1):0]  RID_param
    );
    import "DPI-C" context function void axi4_get_RID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_RID_from_CY;
    export "DPI-C" function axi4_initialise_RID_from_CY;

    import "DPI-C" context function void axi4_set_RUSER_from_SystemVerilog
    (
        input logic [((AXI4_USER_WIDTH) - 1):0]  RUSER_param
    );
    import "DPI-C" context function void axi4_get_RUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_RUSER_from_CY;
    export "DPI-C" function axi4_initialise_RUSER_from_CY;

    import "DPI-C" context function void axi4_set_RREADY_from_SystemVerilog
    (
        input logic RREADY_param
    );
    import "DPI-C" context function void axi4_get_RREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_RREADY_from_CY;
    export "DPI-C" function axi4_initialise_RREADY_from_CY;

    import "DPI-C" context function void axi4_set_WVALID_from_SystemVerilog
    (
        input logic WVALID_param
    );
    import "DPI-C" context function void axi4_get_WVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_WVALID_from_CY;
    export "DPI-C" function axi4_initialise_WVALID_from_CY;

    import "DPI-C" context function void axi4_set_WDATA_from_SystemVerilog
    (
        input logic [((AXI4_WDATA_WIDTH) - 1):0]  WDATA_param
    );
    import "DPI-C" context function void axi4_get_WDATA_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_WDATA_from_CY;
    export "DPI-C" function axi4_initialise_WDATA_from_CY;

    import "DPI-C" context function void axi4_set_WSTRB_from_SystemVerilog
    (
        input logic [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  WSTRB_param
    );
    import "DPI-C" context function void axi4_get_WSTRB_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_WSTRB_from_CY;
    export "DPI-C" function axi4_initialise_WSTRB_from_CY;

    import "DPI-C" context function void axi4_set_WLAST_from_SystemVerilog
    (
        input logic WLAST_param
    );
    import "DPI-C" context function void axi4_get_WLAST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_WLAST_from_CY;
    export "DPI-C" function axi4_initialise_WLAST_from_CY;

    import "DPI-C" context function void axi4_set_WUSER_from_SystemVerilog
    (
        input logic [((AXI4_USER_WIDTH) - 1):0]  WUSER_param
    );
    import "DPI-C" context function void axi4_get_WUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_WUSER_from_CY;
    export "DPI-C" function axi4_initialise_WUSER_from_CY;

    import "DPI-C" context function void axi4_set_WREADY_from_SystemVerilog
    (
        input logic WREADY_param
    );
    import "DPI-C" context function void axi4_get_WREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_WREADY_from_CY;
    export "DPI-C" function axi4_initialise_WREADY_from_CY;

    import "DPI-C" context function void axi4_set_BVALID_from_SystemVerilog
    (
        input logic BVALID_param
    );
    import "DPI-C" context function void axi4_get_BVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_BVALID_from_CY;
    export "DPI-C" function axi4_initialise_BVALID_from_CY;

    import "DPI-C" context function void axi4_set_BRESP_from_SystemVerilog
    (
        input logic [1:0] BRESP_param
    );
    import "DPI-C" context function void axi4_get_BRESP_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_BRESP_from_CY;
    export "DPI-C" function axi4_initialise_BRESP_from_CY;

    import "DPI-C" context function void axi4_set_BID_from_SystemVerilog
    (
        input logic [((AXI4_ID_WIDTH) - 1):0]  BID_param
    );
    import "DPI-C" context function void axi4_get_BID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_BID_from_CY;
    export "DPI-C" function axi4_initialise_BID_from_CY;

    import "DPI-C" context function void axi4_set_BUSER_from_SystemVerilog
    (
        input logic [((AXI4_USER_WIDTH) - 1):0]  BUSER_param
    );
    import "DPI-C" context function void axi4_get_BUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_BUSER_from_CY;
    export "DPI-C" function axi4_initialise_BUSER_from_CY;

    import "DPI-C" context function void axi4_set_BREADY_from_SystemVerilog
    (
        input logic BREADY_param
    );
    import "DPI-C" context function void axi4_get_BREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_BREADY_from_CY;
    export "DPI-C" function axi4_initialise_BREADY_from_CY;

    import "DPI-C" context function void axi4_set_config_interface_type_from_SystemVerilog
    (
        input axi4_interface_type_e config_interface_type_param
    );
    import "DPI-C" context function void axi4_get_config_interface_type_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_interface_type_from_CY;

    import "DPI-C" context function void axi4_set_config_clk_init_value_from_SystemVerilog
    (
        input bit config_clk_init_value_param
    );
    import "DPI-C" context function void axi4_get_config_clk_init_value_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_clk_init_value_from_CY;

    import "DPI-C" context function void axi4_set_config_clk_phase_shift_from_SystemVerilog
    (
        input longint unsigned config_clk_phase_shift_param
    );
    import "DPI-C" context function void axi4_get_config_clk_phase_shift_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_clk_phase_shift_from_CY;

    import "DPI-C" context function void axi4_set_config_clk_1st_time_from_SystemVerilog
    (
        input longint unsigned config_clk_1st_time_param
    );
    import "DPI-C" context function void axi4_get_config_clk_1st_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_clk_1st_time_from_CY;

    import "DPI-C" context function void axi4_set_config_clk_2nd_time_from_SystemVerilog
    (
        input longint unsigned config_clk_2nd_time_param
    );
    import "DPI-C" context function void axi4_get_config_clk_2nd_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_clk_2nd_time_from_CY;

    import "DPI-C" context function void axi4_set_config_setup_time_from_SystemVerilog
    (
        input longint unsigned config_setup_time_param
    );
    import "DPI-C" context function void axi4_get_config_setup_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_setup_time_from_CY;

    import "DPI-C" context function void axi4_set_config_hold_time_from_SystemVerilog
    (
        input longint unsigned config_hold_time_param
    );
    import "DPI-C" context function void axi4_get_config_hold_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_hold_time_from_CY;

    import "DPI-C" context function void axi4_set_config_burst_timeout_factor_from_SystemVerilog
    (
        input int unsigned config_burst_timeout_factor_param
    );
    import "DPI-C" context function void axi4_get_config_burst_timeout_factor_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_burst_timeout_factor_from_CY;

    import "DPI-C" context function void axi4_set_config_max_transaction_time_factor_from_SystemVerilog
    (
        input int unsigned config_max_transaction_time_factor_param
    );
    import "DPI-C" context function void axi4_get_config_max_transaction_time_factor_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_transaction_time_factor_from_CY;

    import "DPI-C" context function void axi4_set_config_write_ctrl_first_ratio_from_SystemVerilog
    (
        input int config_write_ctrl_first_ratio_param
    );
    import "DPI-C" context function void axi4_get_config_write_ctrl_first_ratio_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_write_ctrl_first_ratio_from_CY;

    import "DPI-C" context function void axi4_set_config_write_data_first_ratio_from_SystemVerilog
    (
        input int config_write_data_first_ratio_param
    );
    import "DPI-C" context function void axi4_get_config_write_data_first_ratio_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_write_data_first_ratio_from_CY;

    import "DPI-C" context function void axi4_set_config_reset_low_clocks_from_SystemVerilog
    (
        input int config_reset_low_clocks_param
    );
    import "DPI-C" context function void axi4_get_config_reset_low_clocks_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_reset_low_clocks_from_CY;

    import "DPI-C" context function void axi4_set_config_reset_hold_time_from_SystemVerilog
    (
        input int config_reset_hold_time_param
    );
    import "DPI-C" context function void axi4_get_config_reset_hold_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_reset_hold_time_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_rlast_from_SystemVerilog
    (
        input bit config_enable_rlast_param
    );
    import "DPI-C" context function void axi4_get_config_enable_rlast_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_rlast_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_slave_exclusive_from_SystemVerilog
    (
        input bit config_enable_slave_exclusive_param
    );
    import "DPI-C" context function void axi4_get_config_enable_slave_exclusive_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_slave_exclusive_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_burst_reserved_value_from_SystemVerilog
    (
        input bit config_enable_burst_reserved_value_param
    );
    import "DPI-C" context function void axi4_get_config_enable_burst_reserved_value_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_burst_reserved_value_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_cache_value_from_SystemVerilog
    (
        input bit [15:0] config_enable_cache_value_param
    );
    import "DPI-C" context function void axi4_get_config_enable_cache_value_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_cache_value_from_CY;

    import "DPI-C" context function void axi4_set_internal_dummy_variable_from_SystemVerilog
    (
        input axi4_error_e internal_dummy_variable_param
    );
    import "DPI-C" context function void axi4_get_internal_dummy_variable_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_internal_dummy_variable_from_CY;

    import "DPI-C" context function void axi4_set_config_axi4lite_interface_from_SystemVerilog
    (
        input bit config_axi4lite_interface_param
    );
    import "DPI-C" context function void axi4_get_config_axi4lite_interface_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_axi4lite_interface_from_CY;

    import "DPI-C" context function void axi4_set_config_axi4lite_tr_id_from_SystemVerilog
    (
        input bit [((AXI4_ID_WIDTH) - 1):0]  config_axi4lite_tr_id_param
    );
    import "DPI-C" context function void axi4_get_config_axi4lite_tr_id_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_axi4lite_tr_id_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_all_assertions_from_SystemVerilog
    (
        input bit config_enable_all_assertions_param
    );
    import "DPI-C" context function void axi4_get_config_enable_all_assertions_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_all_assertions_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_assertion_from_SystemVerilog
    (
        input bit [255:0] config_enable_assertion_param
    );
    import "DPI-C" context function void axi4_get_config_enable_assertion_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_assertion_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_error_from_SystemVerilog
    (
        input bit [255:0] config_enable_error_param
    );
    import "DPI-C" context function void axi4_get_config_enable_error_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_error_from_CY;

    import "DPI-C" context function void axi4_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param
    );
    import "DPI-C" context function void axi4_get_config_max_latency_AWVALID_assertion_to_AWREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_CY;

    import "DPI-C" context function void axi4_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param
    );
    import "DPI-C" context function void axi4_get_config_max_latency_ARVALID_assertion_to_ARREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_CY;

    import "DPI-C" context function void axi4_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_RVALID_assertion_to_RREADY_param
    );
    import "DPI-C" context function void axi4_get_config_max_latency_RVALID_assertion_to_RREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_latency_RVALID_assertion_to_RREADY_from_CY;

    import "DPI-C" context function void axi4_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_BVALID_assertion_to_BREADY_param
    );
    import "DPI-C" context function void axi4_get_config_max_latency_BVALID_assertion_to_BREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_latency_BVALID_assertion_to_BREADY_from_CY;

    import "DPI-C" context function void axi4_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_WVALID_assertion_to_WREADY_param
    );
    import "DPI-C" context function void axi4_get_config_max_latency_WVALID_assertion_to_WREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_latency_WVALID_assertion_to_WREADY_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_qos_from_SystemVerilog
    (
        input bit config_enable_qos_param
    );
    import "DPI-C" context function void axi4_get_config_enable_qos_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_qos_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_region_support_from_SystemVerilog
    (
        input bit config_enable_region_support_param
    );
    import "DPI-C" context function void axi4_get_config_enable_region_support_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_region_support_from_CY;

    import "DPI-C" context function void axi4_set_config_slave_regions_from_SystemVerilog
    (
        input int config_slave_regions_param
    );
    import "DPI-C" context function void axi4_get_config_slave_regions_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_slave_regions_from_CY;

    import "DPI-C" context function void axi4_set_config_region_from_SystemVerilog
    (
        input bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  config_region_param
    );
    import "DPI-C" context function void axi4_get_config_region_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_region_from_CY;

    import "DPI-C" context function void axi4_get_region_error_state_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_region_error_state_from_CY;

    import "DPI-C" context function void axi4_get_region_map_lb_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_region_map_lb_from_CY;

    import "DPI-C" context function void axi4_get_region_map_ub_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_region_map_ub_from_CY;

    import "DPI-C" context function void axi4_get_region_map_region_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_region_map_region_from_CY;

    import "DPI-C" context function void axi4_get_cacheable_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_cacheable_from_CY;

    import "DPI-C" context function void axi4_set_config_read_data_reordering_depth_from_SystemVerilog
    (
        input int unsigned config_read_data_reordering_depth_param
    );
    import "DPI-C" context function void axi4_get_config_read_data_reordering_depth_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_read_data_reordering_depth_from_CY;

    import "DPI-C" context function void axi4_set_config_slave_start_addr_from_SystemVerilog
    (
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param
    );
    import "DPI-C" context function void axi4_get_config_slave_start_addr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_slave_start_addr_from_CY;

    import "DPI-C" context function void axi4_set_config_slave_end_addr_from_SystemVerilog
    (
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param
    );
    import "DPI-C" context function void axi4_get_config_slave_end_addr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_slave_end_addr_from_CY;

    import "DPI-C" context function void axi4_set_config_slave_enabled_non_contiguous_address_spaces_from_SystemVerilog
    (
        input int config_slave_enabled_non_contiguous_address_spaces_param
    );
    import "DPI-C" context function void axi4_get_config_slave_enabled_non_contiguous_address_spaces_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_slave_enabled_non_contiguous_address_spaces_from_CY;

    import "DPI-C" context function void axi4_set_config_slave_possess_multiple_non_contiguous_address_spaces_from_SystemVerilog
    (
        input bit config_slave_possess_multiple_non_contiguous_address_spaces_param
    );
    import "DPI-C" context function void axi4_get_config_slave_possess_multiple_non_contiguous_address_spaces_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_slave_possess_multiple_non_contiguous_address_spaces_from_CY;

    import "DPI-C" context function void axi4_set_config_slave_multiple_non_contiguous_start_address_range_from_SystemVerilog
    (
        input bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_start_address_range_param
    );
    import "DPI-C" context function void axi4_get_config_slave_multiple_non_contiguous_start_address_range_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_slave_multiple_non_contiguous_start_address_range_from_CY;

    import "DPI-C" context function void axi4_set_config_slave_multiple_non_contiguous_end_address_range_from_SystemVerilog
    (
        input bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_end_address_range_param
    );
    import "DPI-C" context function void axi4_get_config_slave_multiple_non_contiguous_end_address_range_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_slave_multiple_non_contiguous_end_address_range_from_CY;

    import "DPI-C" context function void axi4_set_config_protect_ready_from_SystemVerilog
    (
        input bit config_protect_ready_param
    );
    import "DPI-C" context function void axi4_get_config_protect_ready_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_protect_ready_from_CY;

    import "DPI-C" context function void axi4_get_master_end_tlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_master_end_tlm_status_from_CY;

    import "DPI-C" context function void axi4_get_master_end_wlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_master_end_wlm_status_from_CY;

    import "DPI-C" context function void axi4_get_slave_end_tlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_slave_end_tlm_status_from_CY;

    import "DPI-C" context function void axi4_get_slave_end_wlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_slave_end_wlm_status_from_CY;

    import "DPI-C" context function void axi4_get_clock_source_end_tlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_clock_source_end_tlm_status_from_CY;

    import "DPI-C" context function void axi4_get_clock_source_end_wlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_clock_source_end_wlm_status_from_CY;

    import "DPI-C" context function void axi4_get_reset_source_end_tlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_reset_source_end_tlm_status_from_CY;

    import "DPI-C" context function void axi4_get_reset_source_end_wlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_reset_source_end_wlm_status_from_CY;

    import "DPI-C" context function void axi4_set_config_max_outstanding_wr_from_SystemVerilog
    (
        input int config_max_outstanding_wr_param
    );
    import "DPI-C" context function void axi4_get_config_max_outstanding_wr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_outstanding_wr_from_CY;

    import "DPI-C" context function void axi4_set_config_max_outstanding_rd_from_SystemVerilog
    (
        input int config_max_outstanding_rd_param
    );
    import "DPI-C" context function void axi4_get_config_max_outstanding_rd_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_outstanding_rd_from_CY;

    import "DPI-C" context function void axi4_set_config_num_outstanding_wr_phase_from_SystemVerilog
    (
        input int config_num_outstanding_wr_phase_param
    );
    import "DPI-C" context function void axi4_get_config_num_outstanding_wr_phase_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_num_outstanding_wr_phase_from_CY;

    import "DPI-C" context function void axi4_set_config_num_outstanding_rd_phase_from_SystemVerilog
    (
        input int config_num_outstanding_rd_phase_param
    );
    import "DPI-C" context function void axi4_get_config_num_outstanding_rd_phase_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_num_outstanding_rd_phase_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_warnings_from_SystemVerilog
    (
        input bit config_enable_warnings_param
    );
    import "DPI-C" context function void axi4_get_config_enable_warnings_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_warnings_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_errors_from_SystemVerilog
    (
        input bit config_enable_errors_param
    );
    import "DPI-C" context function void axi4_get_config_enable_errors_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_errors_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_exclusive_checks_from_SystemVerilog
    (
        input bit config_enable_exclusive_checks_param
    );
    import "DPI-C" context function void axi4_get_config_enable_exclusive_checks_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_exclusive_checks_from_CY;

    import "DPI-C" context function void axi4_set_config_warn_on_slave_errors_from_SystemVerilog
    (
        input bit config_warn_on_slave_errors_param
    );
    import "DPI-C" context function void axi4_get_config_warn_on_slave_errors_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_warn_on_slave_errors_from_CY;

    import "DPI-C" context function void axi4_set_config_error_on_deleted_valid_cycles_from_SystemVerilog
    (
        input bit config_error_on_deleted_valid_cycles_param
    );
    import "DPI-C" context function void axi4_get_config_error_on_deleted_valid_cycles_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_error_on_deleted_valid_cycles_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_from_SystemVerilog
    (
        input bit config_stats_enable_param
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_read_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_read_occupancy_param
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_read_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_read_occupancy_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_write_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_write_occupancy_param
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_write_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_write_occupancy_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_read_data_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_read_data_occupancy_param
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_read_data_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_read_data_occupancy_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_write_data_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_write_data_occupancy_param
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_write_data_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_write_data_occupancy_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_read_latency_from_SystemVerilog
    (
        input bit config_stats_enable_read_latency_param
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_read_latency_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_read_latency_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_write_latency_from_SystemVerilog
    (
        input bit config_stats_enable_write_latency_param
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_write_latency_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_write_latency_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_read_address_waits_from_SystemVerilog
    (
        input bit config_stats_enable_read_address_waits_param
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_read_address_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_read_address_waits_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_read_data_waits_from_SystemVerilog
    (
        input bit config_stats_enable_read_data_waits_param
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_read_data_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_read_data_waits_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_write_address_waits_from_SystemVerilog
    (
        input bit config_stats_enable_write_address_waits_param
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_write_address_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_write_address_waits_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_write_data_waits_from_SystemVerilog
    (
        input bit config_stats_enable_write_data_waits_param
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_write_data_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_write_data_waits_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_write_response_waits_from_SystemVerilog
    (
        input bit config_stats_enable_write_response_waits_param
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_write_response_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_write_response_waits_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_read_bandwidth_from_SystemVerilog
    (
        input bit config_stats_enable_read_bandwidth_param
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_read_bandwidth_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_read_bandwidth_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_write_bandwidth_from_SystemVerilog
    (
        input bit config_stats_enable_write_bandwidth_param
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_write_bandwidth_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_write_bandwidth_from_CY;

    import "DPI-C" context function void axi4_get_stats_rw_transaction_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_rw_transaction_last_duration_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_occupancy_step_from_SystemVerilog
    (
        input int config_stats_read_occupancy_step_param
    );
    import "DPI-C" context function void axi4_get_config_stats_read_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_occupancy_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_read_occupancy_multiple_param
    );
    import "DPI-C" context function void axi4_get_config_stats_read_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_active_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_active_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_occupancy_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_idle_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_occupancy_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_idle_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_occupancy_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_idle_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_occupancy_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_idle_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_last_duration_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_occupancy_step_from_SystemVerilog
    (
        input int config_stats_write_occupancy_step_param
    );
    import "DPI-C" context function void axi4_get_config_stats_write_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_occupancy_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_write_occupancy_multiple_param
    );
    import "DPI-C" context function void axi4_get_config_stats_write_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_active_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_active_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_occupancy_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_idle_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_occupancy_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_idle_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_occupancy_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_idle_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_occupancy_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_idle_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_last_duration_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_data_occupancy_step_from_SystemVerilog
    (
        input int config_stats_read_data_occupancy_step_param
    );
    import "DPI-C" context function void axi4_get_config_stats_read_data_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_data_occupancy_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_read_data_occupancy_multiple_param
    );
    import "DPI-C" context function void axi4_get_config_stats_read_data_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_data_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_occupancy_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_idle_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_occupancy_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_idle_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_occupancy_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_idle_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_occupancy_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_idle_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_data_occupancy_step_from_SystemVerilog
    (
        input int config_stats_write_data_occupancy_step_param
    );
    import "DPI-C" context function void axi4_get_config_stats_write_data_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_data_occupancy_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_write_data_occupancy_multiple_param
    );
    import "DPI-C" context function void axi4_get_config_stats_write_data_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_data_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_occupancy_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_idle_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_occupancy_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_idle_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_occupancy_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_idle_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_occupancy_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_idle_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_bandwidth_step_from_SystemVerilog
    (
        input int config_stats_read_bandwidth_step_param
    );
    import "DPI-C" context function void axi4_get_config_stats_read_bandwidth_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_bandwidth_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_bandwidth_multiple_from_SystemVerilog
    (
        input int config_stats_read_bandwidth_multiple_param
    );
    import "DPI-C" context function void axi4_get_config_stats_read_bandwidth_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_bandwidth_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_bandwidth_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_bandwidth_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_bandwidth_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_bandwidth_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_bandwidth_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_bandwidth_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_bandwidth_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_bandwidth_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_bandwidth_step_from_SystemVerilog
    (
        input int config_stats_write_bandwidth_step_param
    );
    import "DPI-C" context function void axi4_get_config_stats_write_bandwidth_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_bandwidth_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_bandwidth_multiple_from_SystemVerilog
    (
        input int config_stats_write_bandwidth_multiple_param
    );
    import "DPI-C" context function void axi4_get_config_stats_write_bandwidth_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_bandwidth_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_bandwidth_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_bandwidth_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_bandwidth_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_bandwidth_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_bandwidth_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_bandwidth_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_bandwidth_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_bandwidth_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_latency_step_from_SystemVerilog
    (
        input int config_stats_read_latency_step_param
    );
    import "DPI-C" context function void axi4_get_config_stats_read_latency_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_latency_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_latency_multiple_from_SystemVerilog
    (
        input int config_stats_read_latency_multiple_param
    );
    import "DPI-C" context function void axi4_get_config_stats_read_latency_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_latency_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_data_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_data_latency_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_data_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_data_latency_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_data_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_data_latency_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_data_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_data_latency_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_data_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_data_latency_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_address_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_address_latency_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_address_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_address_latency_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_address_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_address_latency_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_address_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_address_latency_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_address_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_address_latency_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_latency_step_from_SystemVerilog
    (
        input int config_stats_write_latency_step_param
    );
    import "DPI-C" context function void axi4_get_config_stats_write_latency_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_latency_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_latency_multiple_from_SystemVerilog
    (
        input int config_stats_write_latency_multiple_param
    );
    import "DPI-C" context function void axi4_get_config_stats_write_latency_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_latency_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_response_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_response_latency_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_response_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_response_latency_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_response_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_response_latency_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_response_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_response_latency_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_response_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_response_latency_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_address_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_address_latency_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_address_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_address_latency_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_address_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_address_latency_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_address_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_address_latency_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_address_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_address_latency_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_address_waits_step_from_SystemVerilog
    (
        input int config_stats_read_address_waits_step_param
    );
    import "DPI-C" context function void axi4_get_config_stats_read_address_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_address_waits_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_address_waits_multiple_from_SystemVerilog
    (
        input int config_stats_read_address_waits_multiple_param
    );
    import "DPI-C" context function void axi4_get_config_stats_read_address_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_address_waits_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_waits_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_waits_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_waits_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_waits_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_waits_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_data_waits_step_from_SystemVerilog
    (
        input int config_stats_read_data_waits_step_param
    );
    import "DPI-C" context function void axi4_get_config_stats_read_data_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_data_waits_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_data_waits_multiple_from_SystemVerilog
    (
        input int config_stats_read_data_waits_multiple_param
    );
    import "DPI-C" context function void axi4_get_config_stats_read_data_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_data_waits_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_waits_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_waits_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_waits_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_waits_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_waits_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_address_waits_step_from_SystemVerilog
    (
        input int config_stats_write_address_waits_step_param
    );
    import "DPI-C" context function void axi4_get_config_stats_write_address_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_address_waits_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_address_waits_multiple_from_SystemVerilog
    (
        input int config_stats_write_address_waits_multiple_param
    );
    import "DPI-C" context function void axi4_get_config_stats_write_address_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_address_waits_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_waits_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_waits_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_waits_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_waits_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_waits_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_data_waits_step_from_SystemVerilog
    (
        input int config_stats_write_data_waits_step_param
    );
    import "DPI-C" context function void axi4_get_config_stats_write_data_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_data_waits_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_data_waits_multiple_from_SystemVerilog
    (
        input int config_stats_write_data_waits_multiple_param
    );
    import "DPI-C" context function void axi4_get_config_stats_write_data_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_data_waits_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_waits_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_waits_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_waits_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_waits_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_waits_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_response_waits_step_from_SystemVerilog
    (
        input int config_stats_write_response_waits_step_param
    );
    import "DPI-C" context function void axi4_get_config_stats_write_response_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_response_waits_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_response_waits_multiple_from_SystemVerilog
    (
        input int config_stats_write_response_waits_multiple_param
    );
    import "DPI-C" context function void axi4_get_config_stats_write_response_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_response_waits_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_response_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_response_waits_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_response_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_response_waits_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_response_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_response_waits_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_response_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_response_waits_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_response_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_response_waits_mean_from_CY;

    import "DPI-C" context function void axi4_get_reordering_depth_of_last_read_transaction_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_reordering_depth_of_last_read_transaction_from_CY;

    function void axi4_set_ACLK_from_CY( bit ACLK_param );
        internal_ACLK = ACLK_param;
    endfunction

    function void axi4_initialise_ACLK_from_CY();
        internal_ACLK = 'z;
        m_ACLK = 'z;
    endfunction

    function void axi4_set_ARESETn_from_CY( logic ARESETn_param );
        internal_ARESETn = ARESETn_param;
    endfunction

    function void axi4_initialise_ARESETn_from_CY();
        internal_ARESETn = 'z;
        m_ARESETn = 'z;
    endfunction

    function void axi4_set_AWVALID_from_CY( logic AWVALID_param );
        internal_AWVALID = AWVALID_param;
    endfunction

    function void axi4_initialise_AWVALID_from_CY();
        internal_AWVALID = 'z;
        m_AWVALID = 'z;
    endfunction

    function void axi4_set_AWADDR_from_CY( logic [((AXI4_ADDRESS_WIDTH) - 1):0]  AWADDR_param );
        internal_AWADDR = AWADDR_param;
    endfunction

    function void axi4_initialise_AWADDR_from_CY();
        internal_AWADDR = 'z;
        m_AWADDR = 'z;
    endfunction

    function void axi4_set_AWPROT_from_CY( logic [2:0] AWPROT_param );
        internal_AWPROT = AWPROT_param;
    endfunction

    function void axi4_initialise_AWPROT_from_CY();
        internal_AWPROT = 'z;
        m_AWPROT = 'z;
    endfunction

    function void axi4_set_AWREGION_from_CY( logic [3:0] AWREGION_param );
        internal_AWREGION = AWREGION_param;
    endfunction

    function void axi4_initialise_AWREGION_from_CY();
        internal_AWREGION = 'z;
        m_AWREGION = 'z;
    endfunction

    function void axi4_set_AWLEN_from_CY( logic [7:0] AWLEN_param );
        internal_AWLEN = AWLEN_param;
    endfunction

    function void axi4_initialise_AWLEN_from_CY();
        internal_AWLEN = 'z;
        m_AWLEN = 'z;
    endfunction

    function void axi4_set_AWSIZE_from_CY( logic [2:0] AWSIZE_param );
        internal_AWSIZE = AWSIZE_param;
    endfunction

    function void axi4_initialise_AWSIZE_from_CY();
        internal_AWSIZE = 'z;
        m_AWSIZE = 'z;
    endfunction

    function void axi4_set_AWBURST_from_CY( logic [1:0] AWBURST_param );
        internal_AWBURST = AWBURST_param;
    endfunction

    function void axi4_initialise_AWBURST_from_CY();
        internal_AWBURST = 'z;
        m_AWBURST = 'z;
    endfunction

    function void axi4_set_AWLOCK_from_CY( logic AWLOCK_param );
        internal_AWLOCK = AWLOCK_param;
    endfunction

    function void axi4_initialise_AWLOCK_from_CY();
        internal_AWLOCK = 'z;
        m_AWLOCK = 'z;
    endfunction

    function void axi4_set_AWCACHE_from_CY( logic [3:0] AWCACHE_param );
        internal_AWCACHE = AWCACHE_param;
    endfunction

    function void axi4_initialise_AWCACHE_from_CY();
        internal_AWCACHE = 'z;
        m_AWCACHE = 'z;
    endfunction

    function void axi4_set_AWQOS_from_CY( logic [3:0] AWQOS_param );
        internal_AWQOS = AWQOS_param;
    endfunction

    function void axi4_initialise_AWQOS_from_CY();
        internal_AWQOS = 'z;
        m_AWQOS = 'z;
    endfunction

    function void axi4_set_AWID_from_CY( logic [((AXI4_ID_WIDTH) - 1):0]  AWID_param );
        internal_AWID = AWID_param;
    endfunction

    function void axi4_initialise_AWID_from_CY();
        internal_AWID = 'z;
        m_AWID = 'z;
    endfunction

    function void axi4_set_AWUSER_from_CY( logic [((AXI4_USER_WIDTH) - 1):0]  AWUSER_param );
        internal_AWUSER = AWUSER_param;
    endfunction

    function void axi4_initialise_AWUSER_from_CY();
        internal_AWUSER = 'z;
        m_AWUSER = 'z;
    endfunction

    function void axi4_set_AWREADY_from_CY( logic AWREADY_param );
        internal_AWREADY = AWREADY_param;
    endfunction

    function void axi4_initialise_AWREADY_from_CY();
        internal_AWREADY = 'z;
        m_AWREADY = 'z;
    endfunction

    function void axi4_set_ARVALID_from_CY( logic ARVALID_param );
        internal_ARVALID = ARVALID_param;
    endfunction

    function void axi4_initialise_ARVALID_from_CY();
        internal_ARVALID = 'z;
        m_ARVALID = 'z;
    endfunction

    function void axi4_set_ARADDR_from_CY( logic [((AXI4_ADDRESS_WIDTH) - 1):0]  ARADDR_param );
        internal_ARADDR = ARADDR_param;
    endfunction

    function void axi4_initialise_ARADDR_from_CY();
        internal_ARADDR = 'z;
        m_ARADDR = 'z;
    endfunction

    function void axi4_set_ARPROT_from_CY( logic [2:0] ARPROT_param );
        internal_ARPROT = ARPROT_param;
    endfunction

    function void axi4_initialise_ARPROT_from_CY();
        internal_ARPROT = 'z;
        m_ARPROT = 'z;
    endfunction

    function void axi4_set_ARREGION_from_CY( logic [3:0] ARREGION_param );
        internal_ARREGION = ARREGION_param;
    endfunction

    function void axi4_initialise_ARREGION_from_CY();
        internal_ARREGION = 'z;
        m_ARREGION = 'z;
    endfunction

    function void axi4_set_ARLEN_from_CY( logic [7:0] ARLEN_param );
        internal_ARLEN = ARLEN_param;
    endfunction

    function void axi4_initialise_ARLEN_from_CY();
        internal_ARLEN = 'z;
        m_ARLEN = 'z;
    endfunction

    function void axi4_set_ARSIZE_from_CY( logic [2:0] ARSIZE_param );
        internal_ARSIZE = ARSIZE_param;
    endfunction

    function void axi4_initialise_ARSIZE_from_CY();
        internal_ARSIZE = 'z;
        m_ARSIZE = 'z;
    endfunction

    function void axi4_set_ARBURST_from_CY( logic [1:0] ARBURST_param );
        internal_ARBURST = ARBURST_param;
    endfunction

    function void axi4_initialise_ARBURST_from_CY();
        internal_ARBURST = 'z;
        m_ARBURST = 'z;
    endfunction

    function void axi4_set_ARLOCK_from_CY( logic ARLOCK_param );
        internal_ARLOCK = ARLOCK_param;
    endfunction

    function void axi4_initialise_ARLOCK_from_CY();
        internal_ARLOCK = 'z;
        m_ARLOCK = 'z;
    endfunction

    function void axi4_set_ARCACHE_from_CY( logic [3:0] ARCACHE_param );
        internal_ARCACHE = ARCACHE_param;
    endfunction

    function void axi4_initialise_ARCACHE_from_CY();
        internal_ARCACHE = 'z;
        m_ARCACHE = 'z;
    endfunction

    function void axi4_set_ARQOS_from_CY( logic [3:0] ARQOS_param );
        internal_ARQOS = ARQOS_param;
    endfunction

    function void axi4_initialise_ARQOS_from_CY();
        internal_ARQOS = 'z;
        m_ARQOS = 'z;
    endfunction

    function void axi4_set_ARID_from_CY( logic [((AXI4_ID_WIDTH) - 1):0]  ARID_param );
        internal_ARID = ARID_param;
    endfunction

    function void axi4_initialise_ARID_from_CY();
        internal_ARID = 'z;
        m_ARID = 'z;
    endfunction

    function void axi4_set_ARUSER_from_CY( logic [((AXI4_USER_WIDTH) - 1):0]  ARUSER_param );
        internal_ARUSER = ARUSER_param;
    endfunction

    function void axi4_initialise_ARUSER_from_CY();
        internal_ARUSER = 'z;
        m_ARUSER = 'z;
    endfunction

    function void axi4_set_ARREADY_from_CY( logic ARREADY_param );
        internal_ARREADY = ARREADY_param;
    endfunction

    function void axi4_initialise_ARREADY_from_CY();
        internal_ARREADY = 'z;
        m_ARREADY = 'z;
    endfunction

    function void axi4_set_RVALID_from_CY( logic RVALID_param );
        internal_RVALID = RVALID_param;
    endfunction

    function void axi4_initialise_RVALID_from_CY();
        internal_RVALID = 'z;
        m_RVALID = 'z;
    endfunction

    function void axi4_set_RDATA_from_CY( logic [((AXI4_RDATA_WIDTH) - 1):0]  RDATA_param );
        internal_RDATA = RDATA_param;
    endfunction

    function void axi4_initialise_RDATA_from_CY();
        internal_RDATA = 'z;
        m_RDATA = 'z;
    endfunction

    function void axi4_set_RRESP_from_CY( logic [1:0] RRESP_param );
        internal_RRESP = RRESP_param;
    endfunction

    function void axi4_initialise_RRESP_from_CY();
        internal_RRESP = 'z;
        m_RRESP = 'z;
    endfunction

    function void axi4_set_RLAST_from_CY( logic RLAST_param );
        internal_RLAST = RLAST_param;
    endfunction

    function void axi4_initialise_RLAST_from_CY();
        internal_RLAST = 'z;
        m_RLAST = 'z;
    endfunction

    function void axi4_set_RID_from_CY( logic [((AXI4_ID_WIDTH) - 1):0]  RID_param );
        internal_RID = RID_param;
    endfunction

    function void axi4_initialise_RID_from_CY();
        internal_RID = 'z;
        m_RID = 'z;
    endfunction

    function void axi4_set_RUSER_from_CY( logic [((AXI4_USER_WIDTH) - 1):0]  RUSER_param );
        internal_RUSER = RUSER_param;
    endfunction

    function void axi4_initialise_RUSER_from_CY();
        internal_RUSER = 'z;
        m_RUSER = 'z;
    endfunction

    function void axi4_set_RREADY_from_CY( logic RREADY_param );
        internal_RREADY = RREADY_param;
    endfunction

    function void axi4_initialise_RREADY_from_CY();
        internal_RREADY = 'z;
        m_RREADY = 'z;
    endfunction

    function void axi4_set_WVALID_from_CY( logic WVALID_param );
        internal_WVALID = WVALID_param;
    endfunction

    function void axi4_initialise_WVALID_from_CY();
        internal_WVALID = 'z;
        m_WVALID = 'z;
    endfunction

    function void axi4_set_WDATA_from_CY( logic [((AXI4_WDATA_WIDTH) - 1):0]  WDATA_param );
        internal_WDATA = WDATA_param;
    endfunction

    function void axi4_initialise_WDATA_from_CY();
        internal_WDATA = 'z;
        m_WDATA = 'z;
    endfunction

    function void axi4_set_WSTRB_from_CY( logic [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  WSTRB_param );
        internal_WSTRB = WSTRB_param;
    endfunction

    function void axi4_initialise_WSTRB_from_CY();
        internal_WSTRB = 'z;
        m_WSTRB = 'z;
    endfunction

    function void axi4_set_WLAST_from_CY( logic WLAST_param );
        internal_WLAST = WLAST_param;
    endfunction

    function void axi4_initialise_WLAST_from_CY();
        internal_WLAST = 'z;
        m_WLAST = 'z;
    endfunction

    function void axi4_set_WUSER_from_CY( logic [((AXI4_USER_WIDTH) - 1):0]  WUSER_param );
        internal_WUSER = WUSER_param;
    endfunction

    function void axi4_initialise_WUSER_from_CY();
        internal_WUSER = 'z;
        m_WUSER = 'z;
    endfunction

    function void axi4_set_WREADY_from_CY( logic WREADY_param );
        internal_WREADY = WREADY_param;
    endfunction

    function void axi4_initialise_WREADY_from_CY();
        internal_WREADY = 'z;
        m_WREADY = 'z;
    endfunction

    function void axi4_set_BVALID_from_CY( logic BVALID_param );
        internal_BVALID = BVALID_param;
    endfunction

    function void axi4_initialise_BVALID_from_CY();
        internal_BVALID = 'z;
        m_BVALID = 'z;
    endfunction

    function void axi4_set_BRESP_from_CY( logic [1:0] BRESP_param );
        internal_BRESP = BRESP_param;
    endfunction

    function void axi4_initialise_BRESP_from_CY();
        internal_BRESP = 'z;
        m_BRESP = 'z;
    endfunction

    function void axi4_set_BID_from_CY( logic [((AXI4_ID_WIDTH) - 1):0]  BID_param );
        internal_BID = BID_param;
    endfunction

    function void axi4_initialise_BID_from_CY();
        internal_BID = 'z;
        m_BID = 'z;
    endfunction

    function void axi4_set_BUSER_from_CY( logic [((AXI4_USER_WIDTH) - 1):0]  BUSER_param );
        internal_BUSER = BUSER_param;
    endfunction

    function void axi4_initialise_BUSER_from_CY();
        internal_BUSER = 'z;
        m_BUSER = 'z;
    endfunction

    function void axi4_set_BREADY_from_CY( logic BREADY_param );
        internal_BREADY = BREADY_param;
    endfunction

    function void axi4_initialise_BREADY_from_CY();
        internal_BREADY = 'z;
        m_BREADY = 'z;
    endfunction

    function void axi4_set_config_interface_type_from_CY( axi4_interface_type_e config_interface_type_param );
        config_interface_type = config_interface_type_param;
    endfunction

    function void axi4_set_config_clk_init_value_from_CY( bit config_clk_init_value_param );
        config_clk_init_value = config_clk_init_value_param;
    endfunction

    function void axi4_set_config_clk_phase_shift_from_CY( longint unsigned config_clk_phase_shift_param );
        config_clk_phase_shift = config_clk_phase_shift_param;
    endfunction

    function void axi4_set_config_clk_1st_time_from_CY( longint unsigned config_clk_1st_time_param );
        config_clk_1st_time = config_clk_1st_time_param;
    endfunction

    function void axi4_set_config_clk_2nd_time_from_CY( longint unsigned config_clk_2nd_time_param );
        config_clk_2nd_time = config_clk_2nd_time_param;
    endfunction

    function void axi4_set_config_setup_time_from_CY( longint unsigned config_setup_time_param );
        config_setup_time = config_setup_time_param;
    endfunction

    function void axi4_set_config_hold_time_from_CY( longint unsigned config_hold_time_param );
        config_hold_time = config_hold_time_param;
    endfunction

    function void axi4_set_config_burst_timeout_factor_from_CY( int unsigned config_burst_timeout_factor_param );
        config_burst_timeout_factor = config_burst_timeout_factor_param;
    endfunction

    function void axi4_set_config_max_transaction_time_factor_from_CY( int unsigned config_max_transaction_time_factor_param );
        config_max_transaction_time_factor = config_max_transaction_time_factor_param;
    endfunction

    function void axi4_set_config_write_ctrl_first_ratio_from_CY( int config_write_ctrl_first_ratio_param );
        config_write_ctrl_first_ratio = config_write_ctrl_first_ratio_param;
    endfunction

    function void axi4_set_config_write_data_first_ratio_from_CY( int config_write_data_first_ratio_param );
        config_write_data_first_ratio = config_write_data_first_ratio_param;
    endfunction

    function void axi4_set_config_reset_low_clocks_from_CY( int config_reset_low_clocks_param );
        config_reset_low_clocks = config_reset_low_clocks_param;
    endfunction

    function void axi4_set_config_reset_hold_time_from_CY( int config_reset_hold_time_param );
        config_reset_hold_time = config_reset_hold_time_param;
    endfunction

    function void axi4_set_config_enable_rlast_from_CY( bit config_enable_rlast_param );
        config_enable_rlast = config_enable_rlast_param;
    endfunction

    function void axi4_set_config_enable_slave_exclusive_from_CY( bit config_enable_slave_exclusive_param );
        config_enable_slave_exclusive = config_enable_slave_exclusive_param;
    endfunction

    function void axi4_set_config_enable_burst_reserved_value_from_CY( bit config_enable_burst_reserved_value_param );
        config_enable_burst_reserved_value = config_enable_burst_reserved_value_param;
    endfunction

    function void axi4_set_config_enable_cache_value_from_CY( bit [15:0] config_enable_cache_value_param );
        config_enable_cache_value = config_enable_cache_value_param;
    endfunction

    function void axi4_set_internal_dummy_variable_from_CY( axi4_error_e internal_dummy_variable_param );
        internal_dummy_variable = internal_dummy_variable_param;
    endfunction

    function void axi4_set_config_axi4lite_interface_from_CY( bit config_axi4lite_interface_param );
        config_axi4lite_interface = config_axi4lite_interface_param;
    endfunction

    function void axi4_set_config_axi4lite_tr_id_from_CY( bit [((AXI4_ID_WIDTH) - 1):0]  config_axi4lite_tr_id_param );
        config_axi4lite_tr_id = config_axi4lite_tr_id_param;
    endfunction

    function void axi4_set_config_enable_all_assertions_from_CY( bit config_enable_all_assertions_param );
        config_enable_all_assertions = config_enable_all_assertions_param;
    endfunction

    function void axi4_set_config_enable_assertion_from_CY( bit [255:0] config_enable_assertion_param );
        config_enable_assertion = config_enable_assertion_param;
    endfunction

    function void axi4_set_config_enable_error_from_CY( bit [255:0] config_enable_error_param );
        config_enable_error = config_enable_error_param;
    endfunction

    function void axi4_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_CY( int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
        config_max_latency_AWVALID_assertion_to_AWREADY = config_max_latency_AWVALID_assertion_to_AWREADY_param;
    endfunction

    function void axi4_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_CY( int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
        config_max_latency_ARVALID_assertion_to_ARREADY = config_max_latency_ARVALID_assertion_to_ARREADY_param;
    endfunction

    function void axi4_set_config_max_latency_RVALID_assertion_to_RREADY_from_CY( int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
        config_max_latency_RVALID_assertion_to_RREADY = config_max_latency_RVALID_assertion_to_RREADY_param;
    endfunction

    function void axi4_set_config_max_latency_BVALID_assertion_to_BREADY_from_CY( int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
        config_max_latency_BVALID_assertion_to_BREADY = config_max_latency_BVALID_assertion_to_BREADY_param;
    endfunction

    function void axi4_set_config_max_latency_WVALID_assertion_to_WREADY_from_CY( int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
        config_max_latency_WVALID_assertion_to_WREADY = config_max_latency_WVALID_assertion_to_WREADY_param;
    endfunction

    function void axi4_set_config_enable_qos_from_CY( bit config_enable_qos_param );
        config_enable_qos = config_enable_qos_param;
    endfunction

    function void axi4_set_config_enable_region_support_from_CY( bit config_enable_region_support_param );
        config_enable_region_support = config_enable_region_support_param;
    endfunction

    function void axi4_set_config_slave_regions_from_CY( int config_slave_regions_param );
        config_slave_regions = config_slave_regions_param;
    endfunction

    function void axi4_set_config_region_from_CY( bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  config_region_param );
        config_region = config_region_param;
    endfunction

    function void axi4_set_region_error_state_from_CY( bit region_error_state_param );
        region_error_state = region_error_state_param;
    endfunction

    function void axi4_set_region_map_lb_from_CY( longint unsigned region_map_lb_param [((AXI4_REGION_MAP_SIZE) - 1):0] );
        region_map_lb = region_map_lb_param;
    endfunction

    function void axi4_set_region_map_ub_from_CY( longint unsigned region_map_ub_param [((AXI4_REGION_MAP_SIZE) - 1):0] );
        region_map_ub = region_map_ub_param;
    endfunction

    function void axi4_set_region_map_region_from_CY( byte unsigned region_map_region_param [((AXI4_REGION_MAP_SIZE) - 1):0] );
        region_map_region = region_map_region_param;
    endfunction

    function void axi4_set_cacheable_from_CY( byte unsigned cacheable_param [((AXI4_REGION_MAP_SIZE) - 1):0] );
        cacheable = cacheable_param;
    endfunction

    function void axi4_set_config_read_data_reordering_depth_from_CY( int unsigned config_read_data_reordering_depth_param );
        config_read_data_reordering_depth = config_read_data_reordering_depth_param;
    endfunction

    function void axi4_set_config_slave_start_addr_from_CY( bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param );
        config_slave_start_addr = config_slave_start_addr_param;
    endfunction

    function void axi4_set_config_slave_end_addr_from_CY( bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param );
        config_slave_end_addr = config_slave_end_addr_param;
    endfunction

    function void axi4_set_config_slave_enabled_non_contiguous_address_spaces_from_CY( int config_slave_enabled_non_contiguous_address_spaces_param );
        config_slave_enabled_non_contiguous_address_spaces = config_slave_enabled_non_contiguous_address_spaces_param;
    endfunction

    function void axi4_set_config_slave_possess_multiple_non_contiguous_address_spaces_from_CY( bit config_slave_possess_multiple_non_contiguous_address_spaces_param );
        config_slave_possess_multiple_non_contiguous_address_spaces = config_slave_possess_multiple_non_contiguous_address_spaces_param;
    endfunction

    function void axi4_set_config_slave_multiple_non_contiguous_start_address_range_from_CY( bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_start_address_range_param );
        config_slave_multiple_non_contiguous_start_address_range = config_slave_multiple_non_contiguous_start_address_range_param;
    endfunction

    function void axi4_set_config_slave_multiple_non_contiguous_end_address_range_from_CY( bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_end_address_range_param );
        config_slave_multiple_non_contiguous_end_address_range = config_slave_multiple_non_contiguous_end_address_range_param;
    endfunction

    function void axi4_set_config_protect_ready_from_CY( bit config_protect_ready_param );
        config_protect_ready = config_protect_ready_param;
    endfunction

    function void axi4_set_master_end_tlm_status_from_CY( bit master_end_tlm_status_param );
        master_end_tlm_status = master_end_tlm_status_param;
    endfunction

    function void axi4_set_master_end_wlm_status_from_CY( bit master_end_wlm_status_param );
        master_end_wlm_status = master_end_wlm_status_param;
    endfunction

    function void axi4_set_slave_end_tlm_status_from_CY( bit slave_end_tlm_status_param );
        slave_end_tlm_status = slave_end_tlm_status_param;
    endfunction

    function void axi4_set_slave_end_wlm_status_from_CY( bit slave_end_wlm_status_param );
        slave_end_wlm_status = slave_end_wlm_status_param;
    endfunction

    function void axi4_set_clock_source_end_tlm_status_from_CY( bit clock_source_end_tlm_status_param );
        clock_source_end_tlm_status = clock_source_end_tlm_status_param;
    endfunction

    function void axi4_set_clock_source_end_wlm_status_from_CY( bit clock_source_end_wlm_status_param );
        clock_source_end_wlm_status = clock_source_end_wlm_status_param;
    endfunction

    function void axi4_set_reset_source_end_tlm_status_from_CY( bit reset_source_end_tlm_status_param );
        reset_source_end_tlm_status = reset_source_end_tlm_status_param;
    endfunction

    function void axi4_set_reset_source_end_wlm_status_from_CY( bit reset_source_end_wlm_status_param );
        reset_source_end_wlm_status = reset_source_end_wlm_status_param;
    endfunction

    function void axi4_set_config_max_outstanding_wr_from_CY( int config_max_outstanding_wr_param );
        config_max_outstanding_wr = config_max_outstanding_wr_param;
    endfunction

    function void axi4_set_config_max_outstanding_rd_from_CY( int config_max_outstanding_rd_param );
        config_max_outstanding_rd = config_max_outstanding_rd_param;
    endfunction

    function void axi4_set_config_num_outstanding_wr_phase_from_CY( int config_num_outstanding_wr_phase_param );
        config_num_outstanding_wr_phase = config_num_outstanding_wr_phase_param;
    endfunction

    function void axi4_set_config_num_outstanding_rd_phase_from_CY( int config_num_outstanding_rd_phase_param );
        config_num_outstanding_rd_phase = config_num_outstanding_rd_phase_param;
    endfunction

    function void axi4_set_config_enable_warnings_from_CY( bit config_enable_warnings_param );
        config_enable_warnings = config_enable_warnings_param;
    endfunction

    function void axi4_set_config_enable_errors_from_CY( bit config_enable_errors_param );
        config_enable_errors = config_enable_errors_param;
    endfunction

    function void axi4_set_config_enable_exclusive_checks_from_CY( bit config_enable_exclusive_checks_param );
        config_enable_exclusive_checks = config_enable_exclusive_checks_param;
    endfunction

    function void axi4_set_config_warn_on_slave_errors_from_CY( bit config_warn_on_slave_errors_param );
        config_warn_on_slave_errors = config_warn_on_slave_errors_param;
    endfunction

    function void axi4_set_config_error_on_deleted_valid_cycles_from_CY( bit config_error_on_deleted_valid_cycles_param );
        config_error_on_deleted_valid_cycles = config_error_on_deleted_valid_cycles_param;
    endfunction

    function void axi4_set_config_stats_enable_from_CY( bit config_stats_enable_param );
        config_stats_enable = config_stats_enable_param;
    endfunction

    function void axi4_set_config_stats_enable_read_occupancy_from_CY( bit config_stats_enable_read_occupancy_param );
        config_stats_enable_read_occupancy = config_stats_enable_read_occupancy_param;
    endfunction

    function void axi4_set_config_stats_enable_write_occupancy_from_CY( bit config_stats_enable_write_occupancy_param );
        config_stats_enable_write_occupancy = config_stats_enable_write_occupancy_param;
    endfunction

    function void axi4_set_config_stats_enable_read_data_occupancy_from_CY( bit config_stats_enable_read_data_occupancy_param );
        config_stats_enable_read_data_occupancy = config_stats_enable_read_data_occupancy_param;
    endfunction

    function void axi4_set_config_stats_enable_write_data_occupancy_from_CY( bit config_stats_enable_write_data_occupancy_param );
        config_stats_enable_write_data_occupancy = config_stats_enable_write_data_occupancy_param;
    endfunction

    function void axi4_set_config_stats_enable_read_latency_from_CY( bit config_stats_enable_read_latency_param );
        config_stats_enable_read_latency = config_stats_enable_read_latency_param;
    endfunction

    function void axi4_set_config_stats_enable_write_latency_from_CY( bit config_stats_enable_write_latency_param );
        config_stats_enable_write_latency = config_stats_enable_write_latency_param;
    endfunction

    function void axi4_set_config_stats_enable_read_address_waits_from_CY( bit config_stats_enable_read_address_waits_param );
        config_stats_enable_read_address_waits = config_stats_enable_read_address_waits_param;
    endfunction

    function void axi4_set_config_stats_enable_read_data_waits_from_CY( bit config_stats_enable_read_data_waits_param );
        config_stats_enable_read_data_waits = config_stats_enable_read_data_waits_param;
    endfunction

    function void axi4_set_config_stats_enable_write_address_waits_from_CY( bit config_stats_enable_write_address_waits_param );
        config_stats_enable_write_address_waits = config_stats_enable_write_address_waits_param;
    endfunction

    function void axi4_set_config_stats_enable_write_data_waits_from_CY( bit config_stats_enable_write_data_waits_param );
        config_stats_enable_write_data_waits = config_stats_enable_write_data_waits_param;
    endfunction

    function void axi4_set_config_stats_enable_write_response_waits_from_CY( bit config_stats_enable_write_response_waits_param );
        config_stats_enable_write_response_waits = config_stats_enable_write_response_waits_param;
    endfunction

    function void axi4_set_config_stats_enable_read_bandwidth_from_CY( bit config_stats_enable_read_bandwidth_param );
        config_stats_enable_read_bandwidth = config_stats_enable_read_bandwidth_param;
    endfunction

    function void axi4_set_config_stats_enable_write_bandwidth_from_CY( bit config_stats_enable_write_bandwidth_param );
        config_stats_enable_write_bandwidth = config_stats_enable_write_bandwidth_param;
    endfunction

    function void axi4_set_stats_rw_transaction_last_duration_from_CY( int stats_rw_transaction_last_duration_param );
        stats_rw_transaction_last_duration = stats_rw_transaction_last_duration_param;
    endfunction

    function void axi4_set_config_stats_read_occupancy_step_from_CY( int config_stats_read_occupancy_step_param );
        config_stats_read_occupancy_step = config_stats_read_occupancy_step_param;
    endfunction

    function void axi4_set_config_stats_read_occupancy_multiple_from_CY( int config_stats_read_occupancy_multiple_param );
        config_stats_read_occupancy_multiple = config_stats_read_occupancy_multiple_param;
    endfunction

    function void axi4_set_stats_read_active_from_CY( bit stats_read_active_param );
        stats_read_active = stats_read_active_param;
    endfunction

    function void axi4_set_stats_read_occupancy_sw_from_CY( int stats_read_occupancy_sw_param );
        stats_read_occupancy_sw = stats_read_occupancy_sw_param;
    endfunction

    function void axi4_set_stats_read_idle_sw_from_CY( int stats_read_idle_sw_param );
        stats_read_idle_sw = stats_read_idle_sw_param;
    endfunction

    function void axi4_set_stats_read_occupancy_min_from_CY( int stats_read_occupancy_min_param );
        stats_read_occupancy_min = stats_read_occupancy_min_param;
    endfunction

    function void axi4_set_stats_read_idle_min_from_CY( int stats_read_idle_min_param );
        stats_read_idle_min = stats_read_idle_min_param;
    endfunction

    function void axi4_set_stats_read_occupancy_max_from_CY( int stats_read_occupancy_max_param );
        stats_read_occupancy_max = stats_read_occupancy_max_param;
    endfunction

    function void axi4_set_stats_read_idle_max_from_CY( int stats_read_idle_max_param );
        stats_read_idle_max = stats_read_idle_max_param;
    endfunction

    function void axi4_set_stats_read_occupancy_mean_from_CY( int stats_read_occupancy_mean_param );
        stats_read_occupancy_mean = stats_read_occupancy_mean_param;
    endfunction

    function void axi4_set_stats_read_idle_mean_from_CY( int stats_read_idle_mean_param );
        stats_read_idle_mean = stats_read_idle_mean_param;
    endfunction

    function void axi4_set_stats_read_last_duration_from_CY( int stats_read_last_duration_param );
        stats_read_last_duration = stats_read_last_duration_param;
    endfunction

    function void axi4_set_config_stats_write_occupancy_step_from_CY( int config_stats_write_occupancy_step_param );
        config_stats_write_occupancy_step = config_stats_write_occupancy_step_param;
    endfunction

    function void axi4_set_config_stats_write_occupancy_multiple_from_CY( int config_stats_write_occupancy_multiple_param );
        config_stats_write_occupancy_multiple = config_stats_write_occupancy_multiple_param;
    endfunction

    function void axi4_set_stats_write_active_from_CY( bit stats_write_active_param );
        stats_write_active = stats_write_active_param;
    endfunction

    function void axi4_set_stats_write_occupancy_sw_from_CY( int stats_write_occupancy_sw_param );
        stats_write_occupancy_sw = stats_write_occupancy_sw_param;
    endfunction

    function void axi4_set_stats_write_idle_sw_from_CY( int stats_write_idle_sw_param );
        stats_write_idle_sw = stats_write_idle_sw_param;
    endfunction

    function void axi4_set_stats_write_occupancy_min_from_CY( int stats_write_occupancy_min_param );
        stats_write_occupancy_min = stats_write_occupancy_min_param;
    endfunction

    function void axi4_set_stats_write_idle_min_from_CY( int stats_write_idle_min_param );
        stats_write_idle_min = stats_write_idle_min_param;
    endfunction

    function void axi4_set_stats_write_occupancy_max_from_CY( int stats_write_occupancy_max_param );
        stats_write_occupancy_max = stats_write_occupancy_max_param;
    endfunction

    function void axi4_set_stats_write_idle_max_from_CY( int stats_write_idle_max_param );
        stats_write_idle_max = stats_write_idle_max_param;
    endfunction

    function void axi4_set_stats_write_occupancy_mean_from_CY( int stats_write_occupancy_mean_param );
        stats_write_occupancy_mean = stats_write_occupancy_mean_param;
    endfunction

    function void axi4_set_stats_write_idle_mean_from_CY( int stats_write_idle_mean_param );
        stats_write_idle_mean = stats_write_idle_mean_param;
    endfunction

    function void axi4_set_stats_write_last_duration_from_CY( int stats_write_last_duration_param );
        stats_write_last_duration = stats_write_last_duration_param;
    endfunction

    function void axi4_set_config_stats_read_data_occupancy_step_from_CY( int config_stats_read_data_occupancy_step_param );
        config_stats_read_data_occupancy_step = config_stats_read_data_occupancy_step_param;
    endfunction

    function void axi4_set_config_stats_read_data_occupancy_multiple_from_CY( int config_stats_read_data_occupancy_multiple_param );
        config_stats_read_data_occupancy_multiple = config_stats_read_data_occupancy_multiple_param;
    endfunction

    function void axi4_set_stats_read_data_occupancy_sw_from_CY( int stats_read_data_occupancy_sw_param );
        stats_read_data_occupancy_sw = stats_read_data_occupancy_sw_param;
    endfunction

    function void axi4_set_stats_read_data_idle_sw_from_CY( int stats_read_data_idle_sw_param );
        stats_read_data_idle_sw = stats_read_data_idle_sw_param;
    endfunction

    function void axi4_set_stats_read_data_occupancy_min_from_CY( int stats_read_data_occupancy_min_param );
        stats_read_data_occupancy_min = stats_read_data_occupancy_min_param;
    endfunction

    function void axi4_set_stats_read_data_idle_min_from_CY( int stats_read_data_idle_min_param );
        stats_read_data_idle_min = stats_read_data_idle_min_param;
    endfunction

    function void axi4_set_stats_read_data_occupancy_max_from_CY( int stats_read_data_occupancy_max_param );
        stats_read_data_occupancy_max = stats_read_data_occupancy_max_param;
    endfunction

    function void axi4_set_stats_read_data_idle_max_from_CY( int stats_read_data_idle_max_param );
        stats_read_data_idle_max = stats_read_data_idle_max_param;
    endfunction

    function void axi4_set_stats_read_data_occupancy_mean_from_CY( int stats_read_data_occupancy_mean_param );
        stats_read_data_occupancy_mean = stats_read_data_occupancy_mean_param;
    endfunction

    function void axi4_set_stats_read_data_idle_mean_from_CY( int stats_read_data_idle_mean_param );
        stats_read_data_idle_mean = stats_read_data_idle_mean_param;
    endfunction

    function void axi4_set_config_stats_write_data_occupancy_step_from_CY( int config_stats_write_data_occupancy_step_param );
        config_stats_write_data_occupancy_step = config_stats_write_data_occupancy_step_param;
    endfunction

    function void axi4_set_config_stats_write_data_occupancy_multiple_from_CY( int config_stats_write_data_occupancy_multiple_param );
        config_stats_write_data_occupancy_multiple = config_stats_write_data_occupancy_multiple_param;
    endfunction

    function void axi4_set_stats_write_data_occupancy_sw_from_CY( int stats_write_data_occupancy_sw_param );
        stats_write_data_occupancy_sw = stats_write_data_occupancy_sw_param;
    endfunction

    function void axi4_set_stats_write_data_idle_sw_from_CY( int stats_write_data_idle_sw_param );
        stats_write_data_idle_sw = stats_write_data_idle_sw_param;
    endfunction

    function void axi4_set_stats_write_data_occupancy_min_from_CY( int stats_write_data_occupancy_min_param );
        stats_write_data_occupancy_min = stats_write_data_occupancy_min_param;
    endfunction

    function void axi4_set_stats_write_data_idle_min_from_CY( int stats_write_data_idle_min_param );
        stats_write_data_idle_min = stats_write_data_idle_min_param;
    endfunction

    function void axi4_set_stats_write_data_occupancy_max_from_CY( int stats_write_data_occupancy_max_param );
        stats_write_data_occupancy_max = stats_write_data_occupancy_max_param;
    endfunction

    function void axi4_set_stats_write_data_idle_max_from_CY( int stats_write_data_idle_max_param );
        stats_write_data_idle_max = stats_write_data_idle_max_param;
    endfunction

    function void axi4_set_stats_write_data_occupancy_mean_from_CY( int stats_write_data_occupancy_mean_param );
        stats_write_data_occupancy_mean = stats_write_data_occupancy_mean_param;
    endfunction

    function void axi4_set_stats_write_data_idle_mean_from_CY( int stats_write_data_idle_mean_param );
        stats_write_data_idle_mean = stats_write_data_idle_mean_param;
    endfunction

    function void axi4_set_config_stats_read_bandwidth_step_from_CY( int config_stats_read_bandwidth_step_param );
        config_stats_read_bandwidth_step = config_stats_read_bandwidth_step_param;
    endfunction

    function void axi4_set_config_stats_read_bandwidth_multiple_from_CY( int config_stats_read_bandwidth_multiple_param );
        config_stats_read_bandwidth_multiple = config_stats_read_bandwidth_multiple_param;
    endfunction

    function void axi4_set_stats_read_bandwidth_sw_from_CY( int stats_read_bandwidth_sw_param );
        stats_read_bandwidth_sw = stats_read_bandwidth_sw_param;
    endfunction

    function void axi4_set_stats_read_bandwidth_min_from_CY( int stats_read_bandwidth_min_param );
        stats_read_bandwidth_min = stats_read_bandwidth_min_param;
    endfunction

    function void axi4_set_stats_read_bandwidth_max_from_CY( int stats_read_bandwidth_max_param );
        stats_read_bandwidth_max = stats_read_bandwidth_max_param;
    endfunction

    function void axi4_set_stats_read_bandwidth_mean_from_CY( int stats_read_bandwidth_mean_param );
        stats_read_bandwidth_mean = stats_read_bandwidth_mean_param;
    endfunction

    function void axi4_set_config_stats_write_bandwidth_step_from_CY( int config_stats_write_bandwidth_step_param );
        config_stats_write_bandwidth_step = config_stats_write_bandwidth_step_param;
    endfunction

    function void axi4_set_config_stats_write_bandwidth_multiple_from_CY( int config_stats_write_bandwidth_multiple_param );
        config_stats_write_bandwidth_multiple = config_stats_write_bandwidth_multiple_param;
    endfunction

    function void axi4_set_stats_write_bandwidth_sw_from_CY( int stats_write_bandwidth_sw_param );
        stats_write_bandwidth_sw = stats_write_bandwidth_sw_param;
    endfunction

    function void axi4_set_stats_write_bandwidth_min_from_CY( int stats_write_bandwidth_min_param );
        stats_write_bandwidth_min = stats_write_bandwidth_min_param;
    endfunction

    function void axi4_set_stats_write_bandwidth_max_from_CY( int stats_write_bandwidth_max_param );
        stats_write_bandwidth_max = stats_write_bandwidth_max_param;
    endfunction

    function void axi4_set_stats_write_bandwidth_mean_from_CY( int stats_write_bandwidth_mean_param );
        stats_write_bandwidth_mean = stats_write_bandwidth_mean_param;
    endfunction

    function void axi4_set_config_stats_read_latency_step_from_CY( int config_stats_read_latency_step_param );
        config_stats_read_latency_step = config_stats_read_latency_step_param;
    endfunction

    function void axi4_set_config_stats_read_latency_multiple_from_CY( int config_stats_read_latency_multiple_param );
        config_stats_read_latency_multiple = config_stats_read_latency_multiple_param;
    endfunction

    function void axi4_set_stats_read_address_data_latency_inst_from_CY( int stats_read_address_data_latency_inst_param );
        stats_read_address_data_latency_inst = stats_read_address_data_latency_inst_param;
    endfunction

    function void axi4_set_stats_read_address_data_latency_sw_from_CY( int stats_read_address_data_latency_sw_param );
        stats_read_address_data_latency_sw = stats_read_address_data_latency_sw_param;
    endfunction

    function void axi4_set_stats_read_address_data_latency_min_from_CY( int stats_read_address_data_latency_min_param );
        stats_read_address_data_latency_min = stats_read_address_data_latency_min_param;
    endfunction

    function void axi4_set_stats_read_address_data_latency_max_from_CY( int stats_read_address_data_latency_max_param );
        stats_read_address_data_latency_max = stats_read_address_data_latency_max_param;
    endfunction

    function void axi4_set_stats_read_address_data_latency_mean_from_CY( int stats_read_address_data_latency_mean_param );
        stats_read_address_data_latency_mean = stats_read_address_data_latency_mean_param;
    endfunction

    function void axi4_set_stats_read_address_address_latency_inst_from_CY( int stats_read_address_address_latency_inst_param );
        stats_read_address_address_latency_inst = stats_read_address_address_latency_inst_param;
    endfunction

    function void axi4_set_stats_read_address_address_latency_sw_from_CY( int stats_read_address_address_latency_sw_param );
        stats_read_address_address_latency_sw = stats_read_address_address_latency_sw_param;
    endfunction

    function void axi4_set_stats_read_address_address_latency_min_from_CY( int stats_read_address_address_latency_min_param );
        stats_read_address_address_latency_min = stats_read_address_address_latency_min_param;
    endfunction

    function void axi4_set_stats_read_address_address_latency_max_from_CY( int stats_read_address_address_latency_max_param );
        stats_read_address_address_latency_max = stats_read_address_address_latency_max_param;
    endfunction

    function void axi4_set_stats_read_address_address_latency_mean_from_CY( int stats_read_address_address_latency_mean_param );
        stats_read_address_address_latency_mean = stats_read_address_address_latency_mean_param;
    endfunction

    function void axi4_set_config_stats_write_latency_step_from_CY( int config_stats_write_latency_step_param );
        config_stats_write_latency_step = config_stats_write_latency_step_param;
    endfunction

    function void axi4_set_config_stats_write_latency_multiple_from_CY( int config_stats_write_latency_multiple_param );
        config_stats_write_latency_multiple = config_stats_write_latency_multiple_param;
    endfunction

    function void axi4_set_stats_write_address_response_latency_inst_from_CY( int stats_write_address_response_latency_inst_param );
        stats_write_address_response_latency_inst = stats_write_address_response_latency_inst_param;
    endfunction

    function void axi4_set_stats_write_address_response_latency_sw_from_CY( int stats_write_address_response_latency_sw_param );
        stats_write_address_response_latency_sw = stats_write_address_response_latency_sw_param;
    endfunction

    function void axi4_set_stats_write_address_response_latency_min_from_CY( int stats_write_address_response_latency_min_param );
        stats_write_address_response_latency_min = stats_write_address_response_latency_min_param;
    endfunction

    function void axi4_set_stats_write_address_response_latency_max_from_CY( int stats_write_address_response_latency_max_param );
        stats_write_address_response_latency_max = stats_write_address_response_latency_max_param;
    endfunction

    function void axi4_set_stats_write_address_response_latency_mean_from_CY( int stats_write_address_response_latency_mean_param );
        stats_write_address_response_latency_mean = stats_write_address_response_latency_mean_param;
    endfunction

    function void axi4_set_stats_write_address_address_latency_inst_from_CY( int stats_write_address_address_latency_inst_param );
        stats_write_address_address_latency_inst = stats_write_address_address_latency_inst_param;
    endfunction

    function void axi4_set_stats_write_address_address_latency_sw_from_CY( int stats_write_address_address_latency_sw_param );
        stats_write_address_address_latency_sw = stats_write_address_address_latency_sw_param;
    endfunction

    function void axi4_set_stats_write_address_address_latency_min_from_CY( int stats_write_address_address_latency_min_param );
        stats_write_address_address_latency_min = stats_write_address_address_latency_min_param;
    endfunction

    function void axi4_set_stats_write_address_address_latency_max_from_CY( int stats_write_address_address_latency_max_param );
        stats_write_address_address_latency_max = stats_write_address_address_latency_max_param;
    endfunction

    function void axi4_set_stats_write_address_address_latency_mean_from_CY( int stats_write_address_address_latency_mean_param );
        stats_write_address_address_latency_mean = stats_write_address_address_latency_mean_param;
    endfunction

    function void axi4_set_config_stats_read_address_waits_step_from_CY( int config_stats_read_address_waits_step_param );
        config_stats_read_address_waits_step = config_stats_read_address_waits_step_param;
    endfunction

    function void axi4_set_config_stats_read_address_waits_multiple_from_CY( int config_stats_read_address_waits_multiple_param );
        config_stats_read_address_waits_multiple = config_stats_read_address_waits_multiple_param;
    endfunction

    function void axi4_set_stats_read_address_waits_inst_from_CY( int stats_read_address_waits_inst_param );
        stats_read_address_waits_inst = stats_read_address_waits_inst_param;
    endfunction

    function void axi4_set_stats_read_address_waits_sw_from_CY( int stats_read_address_waits_sw_param );
        stats_read_address_waits_sw = stats_read_address_waits_sw_param;
    endfunction

    function void axi4_set_stats_read_address_waits_min_from_CY( int stats_read_address_waits_min_param );
        stats_read_address_waits_min = stats_read_address_waits_min_param;
    endfunction

    function void axi4_set_stats_read_address_waits_max_from_CY( int stats_read_address_waits_max_param );
        stats_read_address_waits_max = stats_read_address_waits_max_param;
    endfunction

    function void axi4_set_stats_read_address_waits_mean_from_CY( int stats_read_address_waits_mean_param );
        stats_read_address_waits_mean = stats_read_address_waits_mean_param;
    endfunction

    function void axi4_set_config_stats_read_data_waits_step_from_CY( int config_stats_read_data_waits_step_param );
        config_stats_read_data_waits_step = config_stats_read_data_waits_step_param;
    endfunction

    function void axi4_set_config_stats_read_data_waits_multiple_from_CY( int config_stats_read_data_waits_multiple_param );
        config_stats_read_data_waits_multiple = config_stats_read_data_waits_multiple_param;
    endfunction

    function void axi4_set_stats_read_data_waits_inst_from_CY( int stats_read_data_waits_inst_param );
        stats_read_data_waits_inst = stats_read_data_waits_inst_param;
    endfunction

    function void axi4_set_stats_read_data_waits_sw_from_CY( int stats_read_data_waits_sw_param );
        stats_read_data_waits_sw = stats_read_data_waits_sw_param;
    endfunction

    function void axi4_set_stats_read_data_waits_min_from_CY( int stats_read_data_waits_min_param );
        stats_read_data_waits_min = stats_read_data_waits_min_param;
    endfunction

    function void axi4_set_stats_read_data_waits_max_from_CY( int stats_read_data_waits_max_param );
        stats_read_data_waits_max = stats_read_data_waits_max_param;
    endfunction

    function void axi4_set_stats_read_data_waits_mean_from_CY( int stats_read_data_waits_mean_param );
        stats_read_data_waits_mean = stats_read_data_waits_mean_param;
    endfunction

    function void axi4_set_config_stats_write_address_waits_step_from_CY( int config_stats_write_address_waits_step_param );
        config_stats_write_address_waits_step = config_stats_write_address_waits_step_param;
    endfunction

    function void axi4_set_config_stats_write_address_waits_multiple_from_CY( int config_stats_write_address_waits_multiple_param );
        config_stats_write_address_waits_multiple = config_stats_write_address_waits_multiple_param;
    endfunction

    function void axi4_set_stats_write_address_waits_inst_from_CY( int stats_write_address_waits_inst_param );
        stats_write_address_waits_inst = stats_write_address_waits_inst_param;
    endfunction

    function void axi4_set_stats_write_address_waits_sw_from_CY( int stats_write_address_waits_sw_param );
        stats_write_address_waits_sw = stats_write_address_waits_sw_param;
    endfunction

    function void axi4_set_stats_write_address_waits_min_from_CY( int stats_write_address_waits_min_param );
        stats_write_address_waits_min = stats_write_address_waits_min_param;
    endfunction

    function void axi4_set_stats_write_address_waits_max_from_CY( int stats_write_address_waits_max_param );
        stats_write_address_waits_max = stats_write_address_waits_max_param;
    endfunction

    function void axi4_set_stats_write_address_waits_mean_from_CY( int stats_write_address_waits_mean_param );
        stats_write_address_waits_mean = stats_write_address_waits_mean_param;
    endfunction

    function void axi4_set_config_stats_write_data_waits_step_from_CY( int config_stats_write_data_waits_step_param );
        config_stats_write_data_waits_step = config_stats_write_data_waits_step_param;
    endfunction

    function void axi4_set_config_stats_write_data_waits_multiple_from_CY( int config_stats_write_data_waits_multiple_param );
        config_stats_write_data_waits_multiple = config_stats_write_data_waits_multiple_param;
    endfunction

    function void axi4_set_stats_write_data_waits_inst_from_CY( int stats_write_data_waits_inst_param );
        stats_write_data_waits_inst = stats_write_data_waits_inst_param;
    endfunction

    function void axi4_set_stats_write_data_waits_sw_from_CY( int stats_write_data_waits_sw_param );
        stats_write_data_waits_sw = stats_write_data_waits_sw_param;
    endfunction

    function void axi4_set_stats_write_data_waits_min_from_CY( int stats_write_data_waits_min_param );
        stats_write_data_waits_min = stats_write_data_waits_min_param;
    endfunction

    function void axi4_set_stats_write_data_waits_max_from_CY( int stats_write_data_waits_max_param );
        stats_write_data_waits_max = stats_write_data_waits_max_param;
    endfunction

    function void axi4_set_stats_write_data_waits_mean_from_CY( int stats_write_data_waits_mean_param );
        stats_write_data_waits_mean = stats_write_data_waits_mean_param;
    endfunction

    function void axi4_set_config_stats_write_response_waits_step_from_CY( int config_stats_write_response_waits_step_param );
        config_stats_write_response_waits_step = config_stats_write_response_waits_step_param;
    endfunction

    function void axi4_set_config_stats_write_response_waits_multiple_from_CY( int config_stats_write_response_waits_multiple_param );
        config_stats_write_response_waits_multiple = config_stats_write_response_waits_multiple_param;
    endfunction

    function void axi4_set_stats_write_response_waits_inst_from_CY( int stats_write_response_waits_inst_param );
        stats_write_response_waits_inst = stats_write_response_waits_inst_param;
    endfunction

    function void axi4_set_stats_write_response_waits_sw_from_CY( int stats_write_response_waits_sw_param );
        stats_write_response_waits_sw = stats_write_response_waits_sw_param;
    endfunction

    function void axi4_set_stats_write_response_waits_min_from_CY( int stats_write_response_waits_min_param );
        stats_write_response_waits_min = stats_write_response_waits_min_param;
    endfunction

    function void axi4_set_stats_write_response_waits_max_from_CY( int stats_write_response_waits_max_param );
        stats_write_response_waits_max = stats_write_response_waits_max_param;
    endfunction

    function void axi4_set_stats_write_response_waits_mean_from_CY( int stats_write_response_waits_mean_param );
        stats_write_response_waits_mean = stats_write_response_waits_mean_param;
    endfunction

    function void axi4_set_reordering_depth_of_last_read_transaction_from_CY( int reordering_depth_of_last_read_transaction_param );
        reordering_depth_of_last_read_transaction = reordering_depth_of_last_read_transaction_param;
    endfunction

    //------------------------------------------------------------------------------
    // TLM Interface Support
    //------------------------------------------------------------------------------

    import "DPI-C" context axi4_rw_transaction_ActivatesActivatingActivate_SystemVerilog =
    task axi4_rw_transaction_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout axi4_rw_e read_or_write,
        inout bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi4_prot_e prot,
        inout bit [3:0] region,
        inout axi4_size_e size,
        inout axi4_burst_e burst,
        inout axi4_lock_e lock,
        inout axi4_cache_e cache,
        inout bit [3:0] qos,
        inout bit [((AXI4_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] burst_length,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        input bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] data_words [],
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        input bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        inout int wdata_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        input axi4_response_e resp[],
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        input bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        inout int resp_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int address_valid_delay,
        input int data_valid_delay[],
        inout int data_valid_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_response_valid_delay,
        inout int address_ready_delay,
        input int data_ready_delay[],
        inout int data_ready_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_response_ready_delay,
        inout bit write_data_with_address,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        input int write_data_beats_delay[],
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi4_rw_transaction_ActivatesActivatingActivate_open_SystemVerilog =
    task axi4_rw_transaction_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout axi4_rw_e read_or_write,
        inout bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi4_prot_e prot,
        inout bit [3:0] region,
        inout axi4_size_e size,
        inout axi4_burst_e burst,
        inout axi4_lock_e lock,
        inout axi4_cache_e cache,
        inout bit [3:0] qos,
        inout bit [((AXI4_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] burst_length,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        inout bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] data_words [],
        inout bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        inout axi4_response_e resp[],
        inout bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        inout int address_valid_delay,
        inout int data_valid_delay[],
        inout int write_response_valid_delay,
        inout int address_ready_delay,
        inout int data_ready_delay[],
        inout int write_response_ready_delay,
        inout bit write_data_with_address,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int write_data_beats_delay[],
        input int _unit_id
    );
    import "DPI-C" context axi4_rw_transaction_START_ActivatesActivatingActivate_SystemVerilog =
    function int axi4_rw_transaction_START_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        inout axi4_rw_e read_or_write,
        inout bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi4_prot_e prot,
        inout bit [3:0] region,
        inout axi4_size_e size,
        inout axi4_burst_e burst,
        inout axi4_lock_e lock,
        inout axi4_cache_e cache,
        inout bit [3:0] qos,
        inout bit [((AXI4_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] burst_length,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        input bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] data_words [],
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        input bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        input axi4_response_e resp[],
        input bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        inout int address_valid_delay,
        input int data_valid_delay[],
        inout int write_response_valid_delay,
        inout int address_ready_delay,
        input int data_ready_delay[],
        inout int write_response_ready_delay,
        inout bit write_data_with_address,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        input int write_data_beats_delay[],
        input int _unit_id
    );
    import "DPI-C" context axi4_rw_transaction_END_ActivatesActivatingActivate_SystemVerilog =
    function int axi4_rw_transaction_END_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int wdata_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_valid_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_ready_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi4_rw_transaction_END_ActivatesActivatingActivate_open_SystemVerilog =
    function int axi4_rw_transaction_END_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout axi4_rw_e read_or_write,
        inout bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi4_prot_e prot,
        inout bit [3:0] region,
        inout axi4_size_e size,
        inout axi4_burst_e burst,
        inout axi4_lock_e lock,
        inout axi4_cache_e cache,
        inout bit [3:0] qos,
        inout bit [((AXI4_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] burst_length,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        inout bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] data_words [],
        inout bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        inout axi4_response_e resp[],
        inout bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        inout int address_valid_delay,
        inout int data_valid_delay[],
        inout int write_response_valid_delay,
        inout int address_ready_delay,
        inout int data_ready_delay[],
        inout int write_response_ready_delay,
        inout bit write_data_with_address,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int write_data_beats_delay[],
        input int _unit_id
    );
    import "DPI-C" context axi4_rw_transaction_Initiate_Join_SystemVerilog =
    task axi4_rw_transaction_Initiate_Join_SystemVerilog
    (
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int wdata_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_valid_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_ready_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi4_rw_transaction_Initiate_Join_open_SystemVerilog =
    task axi4_rw_transaction_Initiate_Join_open_SystemVerilog
    (
        input longint _as_end,
        output int _trans_id,
        inout axi4_rw_e read_or_write,
        inout bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi4_prot_e prot,
        inout bit [3:0] region,
        inout axi4_size_e size,
        inout axi4_burst_e burst,
        inout axi4_lock_e lock,
        inout axi4_cache_e cache,
        inout bit [3:0] qos,
        inout bit [((AXI4_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] burst_length,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        inout bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] data_words [],
        inout bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        inout axi4_response_e resp[],
        inout bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        inout int address_valid_delay,
        inout int data_valid_delay[],
        inout int write_response_valid_delay,
        inout int address_ready_delay,
        inout int data_ready_delay[],
        inout int write_response_ready_delay,
        inout bit write_data_with_address,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int write_data_beats_delay[],
        input int _unit_id
    );
    import "DPI-C" context axi4_rw_transaction_Complete_Join_SystemVerilog =
    task axi4_rw_transaction_Complete_Join_SystemVerilog
    (
        input longint _as_end,
        input int _trans_id,
        inout axi4_rw_e read_or_write,
        inout bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi4_prot_e prot,
        inout bit [3:0] region,
        inout axi4_size_e size,
        inout axi4_burst_e burst,
        inout axi4_lock_e lock,
        inout axi4_cache_e cache,
        inout bit [3:0] qos,
        inout bit [((AXI4_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] burst_length,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        input bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] data_words [],
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        input bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        input axi4_response_e resp[],
        input bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        inout int address_valid_delay,
        input int data_valid_delay[],
        inout int write_response_valid_delay,
        inout int address_ready_delay,
        input int data_ready_delay[],
        inout int write_response_ready_delay,
        inout bit write_data_with_address,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        input int write_data_beats_delay[],
        input int _unit_id
    );
    import "DPI-C" context axi4_rw_transaction_ReceivedReceivingReceive_SystemVerilog =
    task axi4_rw_transaction_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int wdata_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_valid_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_ready_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_rw_transaction_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_rw_transaction_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output axi4_rw_e read_or_write,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        inout bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] data_words [],
        inout bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        inout axi4_response_e resp[],
        inout bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        output int address_valid_delay,
        inout int data_valid_delay[],
        output int write_response_valid_delay,
        output int address_ready_delay,
        inout int data_ready_delay[],
        output int write_response_ready_delay,
        output bit write_data_with_address,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        inout int write_data_beats_delay[],
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_rw_transaction_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_rw_transaction_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_rw_transaction_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_rw_transaction_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int wdata_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_valid_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_ready_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi4_rw_transaction_END_ReceivedReceivingReceive_open_SystemVerilog =
    function int axi4_rw_transaction_END_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output axi4_rw_e read_or_write,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        inout bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] data_words [],
        inout bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        inout axi4_response_e resp[],
        inout bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        output int address_valid_delay,
        inout int data_valid_delay[],
        output int write_response_valid_delay,
        output int address_ready_delay,
        inout int data_ready_delay[],
        output int write_response_ready_delay,
        output bit write_data_with_address,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        inout int write_data_beats_delay[],
        input int _unit_id
    );
    import "DPI-C" context axi4_read_ActivatesActivatingActivate_SystemVerilog =
    task axi4_read_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi4_prot_e prot,
        inout int rresp_delays[255:0],
        inout bit [3:0] region,
        inout axi4_size_e size,
        inout axi4_burst_e burst,
        inout axi4_lock_e lock,
        inout axi4_cache_e cache,
        inout bit [3:0] qos,
        inout bit [((AXI4_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] burst_length,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        input bit [((AXI4_RDATA_WIDTH) - 1):0] data_words [],
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        input axi4_response_e resp[],
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        input bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        inout int resp_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout longint addr_start_time,
        inout longint addr_end_time,
        input longint data_start_time[],
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input longint data_end_time[],
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_ActivatesActivatingActivate_open_SystemVerilog =
    task axi4_read_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi4_prot_e prot,
        inout int rresp_delays[255:0],
        inout bit [3:0] region,
        inout axi4_size_e size,
        inout axi4_burst_e burst,
        inout axi4_lock_e lock,
        inout axi4_cache_e cache,
        inout bit [3:0] qos,
        inout bit [((AXI4_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] burst_length,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        inout bit [((AXI4_RDATA_WIDTH) - 1):0] data_words [],
        inout axi4_response_e resp[],
        inout bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout longint data_start_time[],
        inout longint data_end_time[],
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_START_ActivatesActivatingActivate_SystemVerilog =
    function int axi4_read_START_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        inout bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi4_prot_e prot,
        inout int rresp_delays[255:0],
        inout bit [3:0] region,
        inout axi4_size_e size,
        inout axi4_burst_e burst,
        inout axi4_lock_e lock,
        inout axi4_cache_e cache,
        inout bit [3:0] qos,
        inout bit [((AXI4_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] burst_length,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        input bit [((AXI4_RDATA_WIDTH) - 1):0] data_words [],
        input axi4_response_e resp[],
        input bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        inout longint addr_start_time,
        inout longint addr_end_time,
        input longint data_start_time[],
        input longint data_end_time[],
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_END_ActivatesActivatingActivate_SystemVerilog =
    function int axi4_read_END_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi4_read_END_ActivatesActivatingActivate_open_SystemVerilog =
    function int axi4_read_END_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi4_prot_e prot,
        inout int rresp_delays[255:0],
        inout bit [3:0] region,
        inout axi4_size_e size,
        inout axi4_burst_e burst,
        inout axi4_lock_e lock,
        inout axi4_cache_e cache,
        inout bit [3:0] qos,
        inout bit [((AXI4_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] burst_length,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        inout bit [((AXI4_RDATA_WIDTH) - 1):0] data_words [],
        inout axi4_response_e resp[],
        inout bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout longint data_start_time[],
        inout longint data_end_time[],
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_Initiate_Join_SystemVerilog =
    task axi4_read_Initiate_Join_SystemVerilog
    (
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi4_read_Initiate_Join_open_SystemVerilog =
    task axi4_read_Initiate_Join_open_SystemVerilog
    (
        input longint _as_end,
        output int _trans_id,
        inout bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi4_prot_e prot,
        inout int rresp_delays[255:0],
        inout bit [3:0] region,
        inout axi4_size_e size,
        inout axi4_burst_e burst,
        inout axi4_lock_e lock,
        inout axi4_cache_e cache,
        inout bit [3:0] qos,
        inout bit [((AXI4_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] burst_length,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        inout bit [((AXI4_RDATA_WIDTH) - 1):0] data_words [],
        inout axi4_response_e resp[],
        inout bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout longint data_start_time[],
        inout longint data_end_time[],
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_Complete_Join_SystemVerilog =
    task axi4_read_Complete_Join_SystemVerilog
    (
        input longint _as_end,
        input int _trans_id,
        inout bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi4_prot_e prot,
        inout int rresp_delays[255:0],
        inout bit [3:0] region,
        inout axi4_size_e size,
        inout axi4_burst_e burst,
        inout axi4_lock_e lock,
        inout axi4_cache_e cache,
        inout bit [3:0] qos,
        inout bit [((AXI4_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] burst_length,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        input bit [((AXI4_RDATA_WIDTH) - 1):0] data_words [],
        input axi4_response_e resp[],
        input bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        inout longint addr_start_time,
        inout longint addr_end_time,
        input longint data_start_time[],
        input longint data_end_time[],
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_read_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output int rresp_delays[255:0],
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        inout bit [((AXI4_RDATA_WIDTH) - 1):0] data_words [],
        inout axi4_response_e resp[],
        inout bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        output longint addr_start_time,
        output longint addr_end_time,
        inout longint data_start_time[],
        inout longint data_end_time[],
        output int address_valid_delay,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_read_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_read_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi4_read_END_ReceivedReceivingReceive_open_SystemVerilog =
    function int axi4_read_END_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output int rresp_delays[255:0],
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        inout bit [((AXI4_RDATA_WIDTH) - 1):0] data_words [],
        inout axi4_response_e resp[],
        inout bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        output longint addr_start_time,
        output longint addr_end_time,
        inout longint data_start_time[],
        inout longint data_end_time[],
        output int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_ActivatesActivatingActivate_SystemVerilog =
    task axi4_write_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi4_prot_e prot,
        inout int bresp_delay,
        inout bit [3:0] region,
        inout axi4_size_e size,
        inout axi4_burst_e burst,
        inout axi4_lock_e lock,
        inout axi4_cache_e cache,
        inout bit [3:0] qos,
        inout bit [((AXI4_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] burst_length,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        input bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        input bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        inout int wdata_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout axi4_response_e resp,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        inout longint addr_start_time,
        inout longint addr_end_time,
        input longint data_start_time[],
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input longint data_end_time[],
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout longint wr_resp_start_time,
        inout longint wr_resp_end_time,
        inout int address_valid_delay,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        input int write_data_beats_delay[],
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi4_write_ActivatesActivatingActivate_open_SystemVerilog =
    task axi4_write_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi4_prot_e prot,
        inout int bresp_delay,
        inout bit [3:0] region,
        inout axi4_size_e size,
        inout axi4_burst_e burst,
        inout axi4_lock_e lock,
        inout axi4_cache_e cache,
        inout bit [3:0] qos,
        inout bit [((AXI4_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] burst_length,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        inout bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        inout bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        inout axi4_response_e resp,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout longint data_start_time[],
        inout longint data_end_time[],
        inout longint wr_resp_start_time,
        inout longint wr_resp_end_time,
        inout int address_valid_delay,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int write_data_beats_delay[],
        input int _unit_id
    );
    import "DPI-C" context axi4_write_START_ActivatesActivatingActivate_SystemVerilog =
    function int axi4_write_START_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        inout bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi4_prot_e prot,
        inout int bresp_delay,
        inout bit [3:0] region,
        inout axi4_size_e size,
        inout axi4_burst_e burst,
        inout axi4_lock_e lock,
        inout axi4_cache_e cache,
        inout bit [3:0] qos,
        inout bit [((AXI4_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] burst_length,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        input bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        input bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        inout axi4_response_e resp,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        inout longint addr_start_time,
        inout longint addr_end_time,
        input longint data_start_time[],
        input longint data_end_time[],
        inout longint wr_resp_start_time,
        inout longint wr_resp_end_time,
        inout int address_valid_delay,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        input int write_data_beats_delay[],
        input int _unit_id
    );
    import "DPI-C" context axi4_write_END_ActivatesActivatingActivate_SystemVerilog =
    function int axi4_write_END_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int wdata_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi4_write_END_ActivatesActivatingActivate_open_SystemVerilog =
    function int axi4_write_END_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi4_prot_e prot,
        inout int bresp_delay,
        inout bit [3:0] region,
        inout axi4_size_e size,
        inout axi4_burst_e burst,
        inout axi4_lock_e lock,
        inout axi4_cache_e cache,
        inout bit [3:0] qos,
        inout bit [((AXI4_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] burst_length,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        inout bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        inout bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        inout axi4_response_e resp,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout longint data_start_time[],
        inout longint data_end_time[],
        inout longint wr_resp_start_time,
        inout longint wr_resp_end_time,
        inout int address_valid_delay,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int write_data_beats_delay[],
        input int _unit_id
    );
    import "DPI-C" context axi4_write_Initiate_Join_SystemVerilog =
    task axi4_write_Initiate_Join_SystemVerilog
    (
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int wdata_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi4_write_Initiate_Join_open_SystemVerilog =
    task axi4_write_Initiate_Join_open_SystemVerilog
    (
        input longint _as_end,
        output int _trans_id,
        inout bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi4_prot_e prot,
        inout int bresp_delay,
        inout bit [3:0] region,
        inout axi4_size_e size,
        inout axi4_burst_e burst,
        inout axi4_lock_e lock,
        inout axi4_cache_e cache,
        inout bit [3:0] qos,
        inout bit [((AXI4_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] burst_length,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        inout bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        inout bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        inout axi4_response_e resp,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout longint data_start_time[],
        inout longint data_end_time[],
        inout longint wr_resp_start_time,
        inout longint wr_resp_end_time,
        inout int address_valid_delay,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int write_data_beats_delay[],
        input int _unit_id
    );
    import "DPI-C" context axi4_write_Complete_Join_SystemVerilog =
    task axi4_write_Complete_Join_SystemVerilog
    (
        input longint _as_end,
        input int _trans_id,
        inout bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        inout axi4_prot_e prot,
        inout int bresp_delay,
        inout bit [3:0] region,
        inout axi4_size_e size,
        inout axi4_burst_e burst,
        inout axi4_lock_e lock,
        inout axi4_cache_e cache,
        inout bit [3:0] qos,
        inout bit [((AXI4_ID_WIDTH) - 1):0]  id,
        inout bit [7:0] burst_length,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        input bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        input bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        inout axi4_response_e resp,
        inout bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        inout longint addr_start_time,
        inout longint addr_end_time,
        input longint data_start_time[],
        input longint data_end_time[],
        inout longint wr_resp_start_time,
        inout longint wr_resp_end_time,
        inout int address_valid_delay,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        input int write_data_beats_delay[],
        input int _unit_id
    );
    import "DPI-C" context axi4_write_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int wdata_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_write_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output int bresp_delay,
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        inout bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        inout bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        output axi4_response_e resp,
        output bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        output longint addr_start_time,
        output longint addr_end_time,
        inout longint data_start_time[],
        inout longint data_end_time[],
        output longint wr_resp_start_time,
        output longint wr_resp_end_time,
        output int address_valid_delay,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        inout int write_data_beats_delay[],
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int wdata_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi4_write_END_ReceivedReceivingReceive_open_SystemVerilog =
    function int axi4_write_END_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output int bresp_delay,
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        inout bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        inout bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        output axi4_response_e resp,
        output bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        output longint addr_start_time,
        output longint addr_end_time,
        inout longint data_start_time[],
        inout longint data_end_time[],
        output longint wr_resp_start_time,
        output longint wr_resp_end_time,
        output int address_valid_delay,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        inout int write_data_beats_delay[],
        input int _unit_id
    );
    import "DPI-C" context axi4_write_data_burst_SendSendingSent_SystemVerilog =
    task axi4_write_data_burst_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int burst_length,
        input bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        input bit [((AXI4_USER_WIDTH) - 1):0] user_data [],
        input longint data_start_time[],
        input longint data_end_time[],
        input int write_data_beats_delay[],
        input int _unit_id
    );
    import "DPI-C" context axi4_write_data_burst_START_SendSendingSent_SystemVerilog =
    function int axi4_write_data_burst_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int burst_length,
        input bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        input bit [((AXI4_USER_WIDTH) - 1):0] user_data [],
        input longint data_start_time[],
        input longint data_end_time[],
        input int write_data_beats_delay[],
        input int _unit_id
    );
    import "DPI-C" context axi4_write_data_burst_END_SendSendingSent_SystemVerilog =
    function int axi4_write_data_burst_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_data_burst_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_data_burst_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_data_burst_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_write_data_burst_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int burst_length,
        inout bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        inout bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout bit [((AXI4_USER_WIDTH) - 1):0] user_data [],
        inout longint data_start_time[],
        inout longint data_end_time[],
        inout int write_data_beats_delay[],
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_data_burst_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_data_burst_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_data_burst_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_data_burst_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi4_write_data_burst_END_ReceivedReceivingReceive_open_SystemVerilog =
    function int axi4_write_data_burst_END_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int burst_length,
        inout bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        inout bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        inout bit [((AXI4_USER_WIDTH) - 1):0] user_data [],
        inout longint data_start_time[],
        inout longint data_end_time[],
        inout int write_data_beats_delay[],
        input int _unit_id
    );
    import "DPI-C" context axi4_read_addr_channel_phase_SendSendingSent_SystemVerilog =
    task axi4_read_addr_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input axi4_prot_e prot,
        input bit [3:0] region,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input axi4_cache_e cache,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_addr_channel_phase_START_SendSendingSent_SystemVerilog =
    function int axi4_read_addr_channel_phase_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input axi4_prot_e prot,
        input bit [3:0] region,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input axi4_cache_e cache,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_addr_channel_phase_END_SendSendingSent_SystemVerilog =
    function int axi4_read_addr_channel_phase_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_addr_channel_phase_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_read_addr_channel_phase_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_addr_channel_phase_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_read_addr_channel_phase_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_data_burst_SendSendingSent_SystemVerilog =
    task axi4_read_data_burst_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_data_burst_START_SendSendingSent_SystemVerilog =
    function int axi4_read_data_burst_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_data_burst_END_SendSendingSent_SystemVerilog =
    function int axi4_read_data_burst_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_data_burst_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_data_burst_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_data_burst_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_read_data_burst_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_data_burst_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_read_data_burst_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_channel_phase_SendSendingSent_SystemVerilog =
    task axi4_read_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int data_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_channel_phase_START_SendSendingSent_SystemVerilog =
    function int axi4_read_channel_phase_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int data_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_channel_phase_END_SendSendingSent_SystemVerilog =
    function int axi4_read_channel_phase_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int data_ready_delay,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_channel_phase_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_read_channel_phase_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_channel_phase_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_read_channel_phase_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int data_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_addr_channel_phase_SendSendingSent_SystemVerilog =
    task axi4_write_addr_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input axi4_prot_e prot,
        input bit [3:0] region,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input axi4_cache_e cache,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_addr_channel_phase_START_SendSendingSent_SystemVerilog =
    function int axi4_write_addr_channel_phase_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input axi4_prot_e prot,
        input bit [3:0] region,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input axi4_cache_e cache,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_addr_channel_phase_END_SendSendingSent_SystemVerilog =
    function int axi4_write_addr_channel_phase_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_addr_channel_phase_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_addr_channel_phase_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_addr_channel_phase_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_addr_channel_phase_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_channel_phase_SendSendingSent_SystemVerilog =
    task axi4_write_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        input bit last,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int data_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_channel_phase_START_SendSendingSent_SystemVerilog =
    function int axi4_write_channel_phase_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        input bit last,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int data_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_channel_phase_END_SendSendingSent_SystemVerilog =
    function int axi4_write_channel_phase_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        output bit last,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int data_ready_delay,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_channel_phase_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_channel_phase_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_channel_phase_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_channel_phase_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        output bit last,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int data_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_resp_channel_phase_SendSendingSent_SystemVerilog =
    task axi4_write_resp_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input axi4_response_e resp,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int write_response_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_resp_channel_phase_START_SendSendingSent_SystemVerilog =
    function int axi4_write_resp_channel_phase_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input axi4_response_e resp,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int write_response_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_resp_channel_phase_END_SendSendingSent_SystemVerilog =
    function int axi4_write_resp_channel_phase_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_resp_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_resp_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output axi4_response_e resp,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int write_response_ready_delay,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_resp_channel_phase_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_resp_channel_phase_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_resp_channel_phase_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_resp_channel_phase_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output axi4_response_e resp,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int write_response_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_addr_channel_cycle_SendSendingSent_SystemVerilog =
    task axi4_read_addr_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] region,
        input axi4_cache_e cache,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input axi4_prot_e prot,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_addr_channel_cycle_START_SendSendingSent_SystemVerilog =
    function int axi4_read_addr_channel_cycle_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] region,
        input axi4_cache_e cache,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input axi4_prot_e prot,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_addr_channel_cycle_END_SendSendingSent_SystemVerilog =
    function int axi4_read_addr_channel_cycle_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] region,
        output axi4_cache_e cache,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output axi4_prot_e prot,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_addr_channel_cycle_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_read_addr_channel_cycle_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_addr_channel_cycle_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_read_addr_channel_cycle_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] region,
        output axi4_cache_e cache,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output axi4_prot_e prot,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_addr_channel_ready_SendSendingSent_SystemVerilog =
    task axi4_read_addr_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_addr_channel_ready_START_SendSendingSent_SystemVerilog =
    function int axi4_read_addr_channel_ready_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_addr_channel_ready_END_SendSendingSent_SystemVerilog =
    function int axi4_read_addr_channel_ready_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_addr_channel_ready_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_read_addr_channel_ready_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_addr_channel_ready_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_read_addr_channel_ready_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_channel_cycle_SendSendingSent_SystemVerilog =
    task axi4_read_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_channel_cycle_START_SendSendingSent_SystemVerilog =
    function int axi4_read_channel_cycle_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_channel_cycle_END_SendSendingSent_SystemVerilog =
    function int axi4_read_channel_cycle_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_channel_cycle_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_read_channel_cycle_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_channel_cycle_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_read_channel_cycle_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_channel_ready_SendSendingSent_SystemVerilog =
    task axi4_read_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_channel_ready_START_SendSendingSent_SystemVerilog =
    function int axi4_read_channel_ready_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_channel_ready_END_SendSendingSent_SystemVerilog =
    function int axi4_read_channel_ready_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_channel_ready_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_read_channel_ready_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_channel_ready_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_read_channel_ready_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_addr_channel_cycle_SendSendingSent_SystemVerilog =
    task axi4_write_addr_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] region,
        input axi4_cache_e cache,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input axi4_prot_e prot,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_addr_channel_cycle_START_SendSendingSent_SystemVerilog =
    function int axi4_write_addr_channel_cycle_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] region,
        input axi4_cache_e cache,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input axi4_prot_e prot,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_addr_channel_cycle_END_SendSendingSent_SystemVerilog =
    function int axi4_write_addr_channel_cycle_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] region,
        output axi4_cache_e cache,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output axi4_prot_e prot,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_addr_channel_cycle_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_addr_channel_cycle_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_addr_channel_cycle_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_addr_channel_cycle_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] region,
        output axi4_cache_e cache,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output axi4_prot_e prot,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_addr_channel_ready_SendSendingSent_SystemVerilog =
    task axi4_write_addr_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_addr_channel_ready_START_SendSendingSent_SystemVerilog =
    function int axi4_write_addr_channel_ready_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_addr_channel_ready_END_SendSendingSent_SystemVerilog =
    function int axi4_write_addr_channel_ready_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_addr_channel_ready_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_addr_channel_ready_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_addr_channel_ready_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_addr_channel_ready_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_channel_cycle_SendSendingSent_SystemVerilog =
    task axi4_write_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  strb,
        input bit last,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_channel_cycle_START_SendSendingSent_SystemVerilog =
    function int axi4_write_channel_cycle_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  strb,
        input bit last,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_channel_cycle_END_SendSendingSent_SystemVerilog =
    function int axi4_write_channel_cycle_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  strb,
        output bit last,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_channel_cycle_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_channel_cycle_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_channel_cycle_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_channel_cycle_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  strb,
        output bit last,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_channel_ready_SendSendingSent_SystemVerilog =
    task axi4_write_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_channel_ready_START_SendSendingSent_SystemVerilog =
    function int axi4_write_channel_ready_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_channel_ready_END_SendSendingSent_SystemVerilog =
    function int axi4_write_channel_ready_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_channel_ready_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_channel_ready_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_channel_ready_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_channel_ready_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_resp_channel_cycle_SendSendingSent_SystemVerilog =
    task axi4_write_resp_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input axi4_response_e resp,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_resp_channel_cycle_START_SendSendingSent_SystemVerilog =
    function int axi4_write_resp_channel_cycle_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input axi4_response_e resp,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_resp_channel_cycle_END_SendSendingSent_SystemVerilog =
    function int axi4_write_resp_channel_cycle_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_resp_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_resp_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output axi4_response_e resp,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_resp_channel_cycle_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_resp_channel_cycle_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_resp_channel_cycle_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_resp_channel_cycle_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output axi4_response_e resp,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_resp_channel_ready_SendSendingSent_SystemVerilog =
    task axi4_write_resp_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_resp_channel_ready_START_SendSendingSent_SystemVerilog =
    function int axi4_write_resp_channel_ready_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_resp_channel_ready_END_SendSendingSent_SystemVerilog =
    function int axi4_write_resp_channel_ready_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_resp_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_resp_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_resp_channel_ready_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_resp_channel_ready_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_resp_channel_ready_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_write_resp_channel_ready_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_unexpected_write_response_SendSendingSent_SystemVerilog =
    task axi4_unexpected_write_response_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input axi4_response_e resp,
        input bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        input int _unit_id
    );
    import "DPI-C" context axi4_unexpected_write_response_START_SendSendingSent_SystemVerilog =
    function int axi4_unexpected_write_response_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input axi4_response_e resp,
        input bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        input int _unit_id
    );
    import "DPI-C" context axi4_unexpected_write_response_END_SendSendingSent_SystemVerilog =
    function int axi4_unexpected_write_response_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi4_unexpected_write_response_ReceivedReceivingReceive_SystemVerilog =
    task axi4_unexpected_write_response_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output axi4_response_e resp,
        output bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_unexpected_write_response_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_unexpected_write_response_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_unexpected_write_response_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_unexpected_write_response_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output axi4_response_e resp,
        output bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        input int _unit_id
    );
    import "DPI-C" context axi4_unexpected_read_response_SendSendingSent_SystemVerilog =
    task axi4_unexpected_read_response_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id
    );
    import "DPI-C" context axi4_unexpected_read_response_START_SendSendingSent_SystemVerilog =
    function int axi4_unexpected_read_response_START_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id
    );
    import "DPI-C" context axi4_unexpected_read_response_END_SendSendingSent_SystemVerilog =
    function int axi4_unexpected_read_response_END_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        input int _unit_id
    );
    import "DPI-C" context axi4_unexpected_read_response_ReceivedReceivingReceive_SystemVerilog =
    task axi4_unexpected_read_response_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_unexpected_read_response_START_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_unexpected_read_response_START_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_unexpected_read_response_END_ReceivedReceivingReceive_SystemVerilog =
    function int axi4_unexpected_read_response_END_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id
    );
    // Waiter task and control
    reg wait_for_control = 0;

    always @(posedge wait_for_control)
    begin
        disable wait_for;
        wait_for_control = 0;
    end

    export "DPI-C" axi4_wait_for = task wait_for;

    task wait_for();
        begin
            wait(0 == 1);
        end
    endtask

    // handle control
    longint last_handle = 0;

    longint last_start_time = 0;

    longint last_end_time = 0;

    export "DPI-C" axi4_set_last_handle_and_times = function set_last_handle_and_times;

    function void set_last_handle_and_times(longint _handle, longint _start, longint _end);
        last_handle = _handle;
        last_start_time = _start;
        last_end_time = _end;
    endfunction

    // Drive wires (from Cohesive) 
    assign ACLK = internal_ACLK;
    assign ARESETn = internal_ARESETn;
    assign AWVALID = internal_AWVALID;
    assign AWADDR = internal_AWADDR;
    assign AWPROT = internal_AWPROT;
    assign AWREGION = internal_AWREGION;
    assign AWLEN = internal_AWLEN;
    assign AWSIZE = internal_AWSIZE;
    assign AWBURST = internal_AWBURST;
    assign AWLOCK = internal_AWLOCK;
    assign AWCACHE = internal_AWCACHE;
    assign AWQOS = internal_AWQOS;
    assign AWID = internal_AWID;
    assign AWUSER = internal_AWUSER;
    assign AWREADY = internal_AWREADY;
    assign ARVALID = internal_ARVALID;
    assign ARADDR = internal_ARADDR;
    assign ARPROT = internal_ARPROT;
    assign ARREGION = internal_ARREGION;
    assign ARLEN = internal_ARLEN;
    assign ARSIZE = internal_ARSIZE;
    assign ARBURST = internal_ARBURST;
    assign ARLOCK = internal_ARLOCK;
    assign ARCACHE = internal_ARCACHE;
    assign ARQOS = internal_ARQOS;
    assign ARID = internal_ARID;
    assign ARUSER = internal_ARUSER;
    assign ARREADY = internal_ARREADY;
    assign RVALID = internal_RVALID;
    assign RDATA = internal_RDATA;
    assign RRESP = internal_RRESP;
    assign RLAST = internal_RLAST;
    assign RID = internal_RID;
    assign RUSER = internal_RUSER;
    assign RREADY = internal_RREADY;
    assign WVALID = internal_WVALID;
    assign WDATA = internal_WDATA;
    assign WSTRB = internal_WSTRB;
    assign WLAST = internal_WLAST;
    assign WUSER = internal_WUSER;
    assign WREADY = internal_WREADY;
    assign BVALID = internal_BVALID;
    assign BRESP = internal_BRESP;
    assign BID = internal_BID;
    assign BUSER = internal_BUSER;
    assign BREADY = internal_BREADY;
    // Drive wires (from User) 
    assign ACLK = m_ACLK;
    assign ARESETn = m_ARESETn;
    assign AWVALID = m_AWVALID;
    assign AWADDR = m_AWADDR;
    assign AWPROT = m_AWPROT;
    assign AWREGION = m_AWREGION;
    assign AWLEN = m_AWLEN;
    assign AWSIZE = m_AWSIZE;
    assign AWBURST = m_AWBURST;
    assign AWLOCK = m_AWLOCK;
    assign AWCACHE = m_AWCACHE;
    assign AWQOS = m_AWQOS;
    assign AWID = m_AWID;
    assign AWUSER = m_AWUSER;
    assign AWREADY = m_AWREADY;
    assign ARVALID = m_ARVALID;
    assign ARADDR = m_ARADDR;
    assign ARPROT = m_ARPROT;
    assign ARREGION = m_ARREGION;
    assign ARLEN = m_ARLEN;
    assign ARSIZE = m_ARSIZE;
    assign ARBURST = m_ARBURST;
    assign ARLOCK = m_ARLOCK;
    assign ARCACHE = m_ARCACHE;
    assign ARQOS = m_ARQOS;
    assign ARID = m_ARID;
    assign ARUSER = m_ARUSER;
    assign ARREADY = m_ARREADY;
    assign RVALID = m_RVALID;
    assign RDATA = m_RDATA;
    assign RRESP = m_RRESP;
    assign RLAST = m_RLAST;
    assign RID = m_RID;
    assign RUSER = m_RUSER;
    assign RREADY = m_RREADY;
    assign WVALID = m_WVALID;
    assign WDATA = m_WDATA;
    assign WSTRB = m_WSTRB;
    assign WLAST = m_WLAST;
    assign WUSER = m_WUSER;
    assign WREADY = m_WREADY;
    assign BVALID = m_BVALID;
    assign BRESP = m_BRESP;
    assign BID = m_BID;
    assign BUSER = m_BUSER;
    assign BREADY = m_BREADY;

    reg ACLK_changed = 0;
    reg ARESETn_changed = 0;
    reg AWVALID_changed = 0;
    reg AWADDR_changed = 0;
    reg AWPROT_changed = 0;
    reg AWREGION_changed = 0;
    reg AWLEN_changed = 0;
    reg AWSIZE_changed = 0;
    reg AWBURST_changed = 0;
    reg AWLOCK_changed = 0;
    reg AWCACHE_changed = 0;
    reg AWQOS_changed = 0;
    reg AWID_changed = 0;
    reg AWUSER_changed = 0;
    reg AWREADY_changed = 0;
    reg ARVALID_changed = 0;
    reg ARADDR_changed = 0;
    reg ARPROT_changed = 0;
    reg ARREGION_changed = 0;
    reg ARLEN_changed = 0;
    reg ARSIZE_changed = 0;
    reg ARBURST_changed = 0;
    reg ARLOCK_changed = 0;
    reg ARCACHE_changed = 0;
    reg ARQOS_changed = 0;
    reg ARID_changed = 0;
    reg ARUSER_changed = 0;
    reg ARREADY_changed = 0;
    reg RVALID_changed = 0;
    reg RDATA_changed = 0;
    reg RRESP_changed = 0;
    reg RLAST_changed = 0;
    reg RID_changed = 0;
    reg RUSER_changed = 0;
    reg RREADY_changed = 0;
    reg WVALID_changed = 0;
    reg WDATA_changed = 0;
    reg WSTRB_changed = 0;
    reg WLAST_changed = 0;
    reg WUSER_changed = 0;
    reg WREADY_changed = 0;
    reg BVALID_changed = 0;
    reg BRESP_changed = 0;
    reg BID_changed = 0;
    reg BUSER_changed = 0;
    reg BREADY_changed = 0;
    reg config_interface_type_changed = 0;
    reg config_clk_init_value_changed = 0;
    reg config_clk_phase_shift_changed = 0;
    reg config_clk_1st_time_changed = 0;
    reg config_clk_2nd_time_changed = 0;
    reg config_setup_time_changed = 0;
    reg config_hold_time_changed = 0;
    reg config_burst_timeout_factor_changed = 0;
    reg config_max_transaction_time_factor_changed = 0;
    reg config_write_ctrl_first_ratio_changed = 0;
    reg config_write_data_first_ratio_changed = 0;
    reg config_reset_low_clocks_changed = 0;
    reg config_reset_hold_time_changed = 0;
    reg config_enable_rlast_changed = 0;
    reg config_enable_slave_exclusive_changed = 0;
    reg config_enable_burst_reserved_value_changed = 0;
    reg config_enable_cache_value_changed = 0;
    reg internal_dummy_variable_changed = 0;
    reg config_axi4lite_interface_changed = 0;
    reg config_axi4lite_tr_id_changed = 0;
    reg config_enable_all_assertions_changed = 0;
    reg config_enable_assertion_changed = 0;
    reg config_enable_error_changed = 0;
    reg config_max_latency_AWVALID_assertion_to_AWREADY_changed = 0;
    reg config_max_latency_ARVALID_assertion_to_ARREADY_changed = 0;
    reg config_max_latency_RVALID_assertion_to_RREADY_changed = 0;
    reg config_max_latency_BVALID_assertion_to_BREADY_changed = 0;
    reg config_max_latency_WVALID_assertion_to_WREADY_changed = 0;
    reg config_enable_qos_changed = 0;
    reg config_enable_region_support_changed = 0;
    reg config_slave_regions_changed = 0;
    reg config_region_changed = 0;
    reg region_error_state_changed = 0;
    reg region_map_lb_changed = 0;
    reg region_map_ub_changed = 0;
    reg region_map_region_changed = 0;
    reg cacheable_changed = 0;
    reg config_read_data_reordering_depth_changed = 0;
    reg config_slave_start_addr_changed = 0;
    reg config_slave_end_addr_changed = 0;
    reg config_slave_enabled_non_contiguous_address_spaces_changed = 0;
    reg config_slave_possess_multiple_non_contiguous_address_spaces_changed = 0;
    reg config_slave_multiple_non_contiguous_start_address_range_changed = 0;
    reg config_slave_multiple_non_contiguous_end_address_range_changed = 0;
    reg config_protect_ready_changed = 0;
    reg master_end_tlm_status_changed = 0;
    reg master_end_wlm_status_changed = 0;
    reg slave_end_tlm_status_changed = 0;
    reg slave_end_wlm_status_changed = 0;
    reg clock_source_end_tlm_status_changed = 0;
    reg clock_source_end_wlm_status_changed = 0;
    reg reset_source_end_tlm_status_changed = 0;
    reg reset_source_end_wlm_status_changed = 0;
    reg config_max_outstanding_wr_changed = 0;
    reg config_max_outstanding_rd_changed = 0;
    reg config_num_outstanding_wr_phase_changed = 0;
    reg config_num_outstanding_rd_phase_changed = 0;
    reg config_enable_warnings_changed = 0;
    reg config_enable_errors_changed = 0;
    reg config_enable_exclusive_checks_changed = 0;
    reg config_warn_on_slave_errors_changed = 0;
    reg config_error_on_deleted_valid_cycles_changed = 0;
    reg config_stats_enable_changed = 0;
    reg config_stats_enable_read_occupancy_changed = 0;
    reg config_stats_enable_write_occupancy_changed = 0;
    reg config_stats_enable_read_data_occupancy_changed = 0;
    reg config_stats_enable_write_data_occupancy_changed = 0;
    reg config_stats_enable_read_latency_changed = 0;
    reg config_stats_enable_write_latency_changed = 0;
    reg config_stats_enable_read_address_waits_changed = 0;
    reg config_stats_enable_read_data_waits_changed = 0;
    reg config_stats_enable_write_address_waits_changed = 0;
    reg config_stats_enable_write_data_waits_changed = 0;
    reg config_stats_enable_write_response_waits_changed = 0;
    reg config_stats_enable_read_bandwidth_changed = 0;
    reg config_stats_enable_write_bandwidth_changed = 0;
    reg stats_rw_transaction_last_duration_changed = 0;
    reg config_stats_read_occupancy_step_changed = 0;
    reg config_stats_read_occupancy_multiple_changed = 0;
    reg stats_read_active_changed = 0;
    reg stats_read_occupancy_sw_changed = 0;
    reg stats_read_idle_sw_changed = 0;
    reg stats_read_occupancy_min_changed = 0;
    reg stats_read_idle_min_changed = 0;
    reg stats_read_occupancy_max_changed = 0;
    reg stats_read_idle_max_changed = 0;
    reg stats_read_occupancy_mean_changed = 0;
    reg stats_read_idle_mean_changed = 0;
    reg stats_read_last_duration_changed = 0;
    reg config_stats_write_occupancy_step_changed = 0;
    reg config_stats_write_occupancy_multiple_changed = 0;
    reg stats_write_active_changed = 0;
    reg stats_write_occupancy_sw_changed = 0;
    reg stats_write_idle_sw_changed = 0;
    reg stats_write_occupancy_min_changed = 0;
    reg stats_write_idle_min_changed = 0;
    reg stats_write_occupancy_max_changed = 0;
    reg stats_write_idle_max_changed = 0;
    reg stats_write_occupancy_mean_changed = 0;
    reg stats_write_idle_mean_changed = 0;
    reg stats_write_last_duration_changed = 0;
    reg config_stats_read_data_occupancy_step_changed = 0;
    reg config_stats_read_data_occupancy_multiple_changed = 0;
    reg stats_read_data_occupancy_sw_changed = 0;
    reg stats_read_data_idle_sw_changed = 0;
    reg stats_read_data_occupancy_min_changed = 0;
    reg stats_read_data_idle_min_changed = 0;
    reg stats_read_data_occupancy_max_changed = 0;
    reg stats_read_data_idle_max_changed = 0;
    reg stats_read_data_occupancy_mean_changed = 0;
    reg stats_read_data_idle_mean_changed = 0;
    reg config_stats_write_data_occupancy_step_changed = 0;
    reg config_stats_write_data_occupancy_multiple_changed = 0;
    reg stats_write_data_occupancy_sw_changed = 0;
    reg stats_write_data_idle_sw_changed = 0;
    reg stats_write_data_occupancy_min_changed = 0;
    reg stats_write_data_idle_min_changed = 0;
    reg stats_write_data_occupancy_max_changed = 0;
    reg stats_write_data_idle_max_changed = 0;
    reg stats_write_data_occupancy_mean_changed = 0;
    reg stats_write_data_idle_mean_changed = 0;
    reg config_stats_read_bandwidth_step_changed = 0;
    reg config_stats_read_bandwidth_multiple_changed = 0;
    reg stats_read_bandwidth_sw_changed = 0;
    reg stats_read_bandwidth_min_changed = 0;
    reg stats_read_bandwidth_max_changed = 0;
    reg stats_read_bandwidth_mean_changed = 0;
    reg config_stats_write_bandwidth_step_changed = 0;
    reg config_stats_write_bandwidth_multiple_changed = 0;
    reg stats_write_bandwidth_sw_changed = 0;
    reg stats_write_bandwidth_min_changed = 0;
    reg stats_write_bandwidth_max_changed = 0;
    reg stats_write_bandwidth_mean_changed = 0;
    reg config_stats_read_latency_step_changed = 0;
    reg config_stats_read_latency_multiple_changed = 0;
    reg stats_read_address_data_latency_inst_changed = 0;
    reg stats_read_address_data_latency_sw_changed = 0;
    reg stats_read_address_data_latency_min_changed = 0;
    reg stats_read_address_data_latency_max_changed = 0;
    reg stats_read_address_data_latency_mean_changed = 0;
    reg stats_read_address_address_latency_inst_changed = 0;
    reg stats_read_address_address_latency_sw_changed = 0;
    reg stats_read_address_address_latency_min_changed = 0;
    reg stats_read_address_address_latency_max_changed = 0;
    reg stats_read_address_address_latency_mean_changed = 0;
    reg config_stats_write_latency_step_changed = 0;
    reg config_stats_write_latency_multiple_changed = 0;
    reg stats_write_address_response_latency_inst_changed = 0;
    reg stats_write_address_response_latency_sw_changed = 0;
    reg stats_write_address_response_latency_min_changed = 0;
    reg stats_write_address_response_latency_max_changed = 0;
    reg stats_write_address_response_latency_mean_changed = 0;
    reg stats_write_address_address_latency_inst_changed = 0;
    reg stats_write_address_address_latency_sw_changed = 0;
    reg stats_write_address_address_latency_min_changed = 0;
    reg stats_write_address_address_latency_max_changed = 0;
    reg stats_write_address_address_latency_mean_changed = 0;
    reg config_stats_read_address_waits_step_changed = 0;
    reg config_stats_read_address_waits_multiple_changed = 0;
    reg stats_read_address_waits_inst_changed = 0;
    reg stats_read_address_waits_sw_changed = 0;
    reg stats_read_address_waits_min_changed = 0;
    reg stats_read_address_waits_max_changed = 0;
    reg stats_read_address_waits_mean_changed = 0;
    reg config_stats_read_data_waits_step_changed = 0;
    reg config_stats_read_data_waits_multiple_changed = 0;
    reg stats_read_data_waits_inst_changed = 0;
    reg stats_read_data_waits_sw_changed = 0;
    reg stats_read_data_waits_min_changed = 0;
    reg stats_read_data_waits_max_changed = 0;
    reg stats_read_data_waits_mean_changed = 0;
    reg config_stats_write_address_waits_step_changed = 0;
    reg config_stats_write_address_waits_multiple_changed = 0;
    reg stats_write_address_waits_inst_changed = 0;
    reg stats_write_address_waits_sw_changed = 0;
    reg stats_write_address_waits_min_changed = 0;
    reg stats_write_address_waits_max_changed = 0;
    reg stats_write_address_waits_mean_changed = 0;
    reg config_stats_write_data_waits_step_changed = 0;
    reg config_stats_write_data_waits_multiple_changed = 0;
    reg stats_write_data_waits_inst_changed = 0;
    reg stats_write_data_waits_sw_changed = 0;
    reg stats_write_data_waits_min_changed = 0;
    reg stats_write_data_waits_max_changed = 0;
    reg stats_write_data_waits_mean_changed = 0;
    reg config_stats_write_response_waits_step_changed = 0;
    reg config_stats_write_response_waits_multiple_changed = 0;
    reg stats_write_response_waits_inst_changed = 0;
    reg stats_write_response_waits_sw_changed = 0;
    reg stats_write_response_waits_min_changed = 0;
    reg stats_write_response_waits_max_changed = 0;
    reg stats_write_response_waits_mean_changed = 0;
    reg reordering_depth_of_last_read_transaction_changed = 0;
    // Timeless transaction monitor
    reg timeless_trans_control= 0;

    // SV wire change monitors

    always @( ACLK or posedge _check_t0_values )
    begin
        axi4_set_ACLK_from_SystemVerilog(ACLK); // DPI call to imported task
    end

    always @( ARESETn or posedge _check_t0_values )
    begin
        axi4_set_ARESETn_from_SystemVerilog(ARESETn); // DPI call to imported task
    end

    always @( AWVALID or posedge _check_t0_values )
    begin
        axi4_set_AWVALID_from_SystemVerilog(AWVALID); // DPI call to imported task
    end

    always @( AWADDR or posedge _check_t0_values )
    begin
        axi4_set_AWADDR_from_SystemVerilog(AWADDR); // DPI call to imported task
    end

    always @( AWPROT or posedge _check_t0_values )
    begin
        axi4_set_AWPROT_from_SystemVerilog(AWPROT); // DPI call to imported task
    end

    always @( AWREGION or posedge _check_t0_values )
    begin
        axi4_set_AWREGION_from_SystemVerilog(AWREGION); // DPI call to imported task
    end

    always @( AWLEN or posedge _check_t0_values )
    begin
        axi4_set_AWLEN_from_SystemVerilog(AWLEN); // DPI call to imported task
    end

    always @( AWSIZE or posedge _check_t0_values )
    begin
        axi4_set_AWSIZE_from_SystemVerilog(AWSIZE); // DPI call to imported task
    end

    always @( AWBURST or posedge _check_t0_values )
    begin
        axi4_set_AWBURST_from_SystemVerilog(AWBURST); // DPI call to imported task
    end

    always @( AWLOCK or posedge _check_t0_values )
    begin
        axi4_set_AWLOCK_from_SystemVerilog(AWLOCK); // DPI call to imported task
    end

    always @( AWCACHE or posedge _check_t0_values )
    begin
        axi4_set_AWCACHE_from_SystemVerilog(AWCACHE); // DPI call to imported task
    end

    always @( AWQOS or posedge _check_t0_values )
    begin
        axi4_set_AWQOS_from_SystemVerilog(AWQOS); // DPI call to imported task
    end

    always @( AWID or posedge _check_t0_values )
    begin
        axi4_set_AWID_from_SystemVerilog(AWID); // DPI call to imported task
    end

    always @( AWUSER or posedge _check_t0_values )
    begin
        axi4_set_AWUSER_from_SystemVerilog(AWUSER); // DPI call to imported task
    end

    always @( AWREADY or posedge _check_t0_values )
    begin
        axi4_set_AWREADY_from_SystemVerilog(AWREADY); // DPI call to imported task
    end

    always @( ARVALID or posedge _check_t0_values )
    begin
        axi4_set_ARVALID_from_SystemVerilog(ARVALID); // DPI call to imported task
    end

    always @( ARADDR or posedge _check_t0_values )
    begin
        axi4_set_ARADDR_from_SystemVerilog(ARADDR); // DPI call to imported task
    end

    always @( ARPROT or posedge _check_t0_values )
    begin
        axi4_set_ARPROT_from_SystemVerilog(ARPROT); // DPI call to imported task
    end

    always @( ARREGION or posedge _check_t0_values )
    begin
        axi4_set_ARREGION_from_SystemVerilog(ARREGION); // DPI call to imported task
    end

    always @( ARLEN or posedge _check_t0_values )
    begin
        axi4_set_ARLEN_from_SystemVerilog(ARLEN); // DPI call to imported task
    end

    always @( ARSIZE or posedge _check_t0_values )
    begin
        axi4_set_ARSIZE_from_SystemVerilog(ARSIZE); // DPI call to imported task
    end

    always @( ARBURST or posedge _check_t0_values )
    begin
        axi4_set_ARBURST_from_SystemVerilog(ARBURST); // DPI call to imported task
    end

    always @( ARLOCK or posedge _check_t0_values )
    begin
        axi4_set_ARLOCK_from_SystemVerilog(ARLOCK); // DPI call to imported task
    end

    always @( ARCACHE or posedge _check_t0_values )
    begin
        axi4_set_ARCACHE_from_SystemVerilog(ARCACHE); // DPI call to imported task
    end

    always @( ARQOS or posedge _check_t0_values )
    begin
        axi4_set_ARQOS_from_SystemVerilog(ARQOS); // DPI call to imported task
    end

    always @( ARID or posedge _check_t0_values )
    begin
        axi4_set_ARID_from_SystemVerilog(ARID); // DPI call to imported task
    end

    always @( ARUSER or posedge _check_t0_values )
    begin
        axi4_set_ARUSER_from_SystemVerilog(ARUSER); // DPI call to imported task
    end

    always @( ARREADY or posedge _check_t0_values )
    begin
        axi4_set_ARREADY_from_SystemVerilog(ARREADY); // DPI call to imported task
    end

    always @( RVALID or posedge _check_t0_values )
    begin
        axi4_set_RVALID_from_SystemVerilog(RVALID); // DPI call to imported task
    end

    always @( RDATA or posedge _check_t0_values )
    begin
        axi4_set_RDATA_from_SystemVerilog(RDATA); // DPI call to imported task
    end

    always @( RRESP or posedge _check_t0_values )
    begin
        axi4_set_RRESP_from_SystemVerilog(RRESP); // DPI call to imported task
    end

    always @( RLAST or posedge _check_t0_values )
    begin
        axi4_set_RLAST_from_SystemVerilog(RLAST); // DPI call to imported task
    end

    always @( RID or posedge _check_t0_values )
    begin
        axi4_set_RID_from_SystemVerilog(RID); // DPI call to imported task
    end

    always @( RUSER or posedge _check_t0_values )
    begin
        axi4_set_RUSER_from_SystemVerilog(RUSER); // DPI call to imported task
    end

    always @( RREADY or posedge _check_t0_values )
    begin
        axi4_set_RREADY_from_SystemVerilog(RREADY); // DPI call to imported task
    end

    always @( WVALID or posedge _check_t0_values )
    begin
        axi4_set_WVALID_from_SystemVerilog(WVALID); // DPI call to imported task
    end

    always @( WDATA or posedge _check_t0_values )
    begin
        axi4_set_WDATA_from_SystemVerilog(WDATA); // DPI call to imported task
    end

    always @( WSTRB or posedge _check_t0_values )
    begin
        axi4_set_WSTRB_from_SystemVerilog(WSTRB); // DPI call to imported task
    end

    always @( WLAST or posedge _check_t0_values )
    begin
        axi4_set_WLAST_from_SystemVerilog(WLAST); // DPI call to imported task
    end

    always @( WUSER or posedge _check_t0_values )
    begin
        axi4_set_WUSER_from_SystemVerilog(WUSER); // DPI call to imported task
    end

    always @( WREADY or posedge _check_t0_values )
    begin
        axi4_set_WREADY_from_SystemVerilog(WREADY); // DPI call to imported task
    end

    always @( BVALID or posedge _check_t0_values )
    begin
        axi4_set_BVALID_from_SystemVerilog(BVALID); // DPI call to imported task
    end

    always @( BRESP or posedge _check_t0_values )
    begin
        axi4_set_BRESP_from_SystemVerilog(BRESP); // DPI call to imported task
    end

    always @( BID or posedge _check_t0_values )
    begin
        axi4_set_BID_from_SystemVerilog(BID); // DPI call to imported task
    end

    always @( BUSER or posedge _check_t0_values )
    begin
        axi4_set_BUSER_from_SystemVerilog(BUSER); // DPI call to imported task
    end

    always @( BREADY or posedge _check_t0_values )
    begin
        axi4_set_BREADY_from_SystemVerilog(BREADY); // DPI call to imported task
    end


    // CY wire and variable changed flag monitors

    always @(posedge ACLK_changed or posedge _check_t0_values )
    begin
        while (ACLK_changed == 1'b1)
        begin
            axi4_get_ACLK_into_SystemVerilog(  ); // DPI call to imported task
            ACLK_changed = 1'b0;
            #0 if ( ACLK !== internal_ACLK )
            begin
                axi4_set_ACLK_from_SystemVerilog( ACLK );
            end
        end
    end

    always @(posedge ARESETn_changed or posedge _check_t0_values )
    begin
        while (ARESETn_changed == 1'b1)
        begin
            axi4_get_ARESETn_into_SystemVerilog(  ); // DPI call to imported task
            ARESETn_changed = 1'b0;
            #0 if ( ARESETn !== internal_ARESETn )
            begin
                axi4_set_ARESETn_from_SystemVerilog( ARESETn );
            end
        end
    end

    always @(posedge AWVALID_changed or posedge _check_t0_values )
    begin
        while (AWVALID_changed == 1'b1)
        begin
            axi4_get_AWVALID_into_SystemVerilog(  ); // DPI call to imported task
            AWVALID_changed = 1'b0;
            #0 if ( AWVALID !== internal_AWVALID )
            begin
                axi4_set_AWVALID_from_SystemVerilog( AWVALID );
            end
        end
    end

    always @(posedge AWADDR_changed or posedge _check_t0_values )
    begin
        while (AWADDR_changed == 1'b1)
        begin
            axi4_get_AWADDR_into_SystemVerilog(  ); // DPI call to imported task
            AWADDR_changed = 1'b0;
            #0 if ( AWADDR !== internal_AWADDR )
            begin
                axi4_set_AWADDR_from_SystemVerilog( AWADDR );
            end
        end
    end

    always @(posedge AWPROT_changed or posedge _check_t0_values )
    begin
        while (AWPROT_changed == 1'b1)
        begin
            axi4_get_AWPROT_into_SystemVerilog(  ); // DPI call to imported task
            AWPROT_changed = 1'b0;
            #0 if ( AWPROT !== internal_AWPROT )
            begin
                axi4_set_AWPROT_from_SystemVerilog( AWPROT );
            end
        end
    end

    always @(posedge AWREGION_changed or posedge _check_t0_values )
    begin
        while (AWREGION_changed == 1'b1)
        begin
            axi4_get_AWREGION_into_SystemVerilog(  ); // DPI call to imported task
            AWREGION_changed = 1'b0;
            #0 if ( AWREGION !== internal_AWREGION )
            begin
                axi4_set_AWREGION_from_SystemVerilog( AWREGION );
            end
        end
    end

    always @(posedge AWLEN_changed or posedge _check_t0_values )
    begin
        while (AWLEN_changed == 1'b1)
        begin
            axi4_get_AWLEN_into_SystemVerilog(  ); // DPI call to imported task
            AWLEN_changed = 1'b0;
            #0 if ( AWLEN !== internal_AWLEN )
            begin
                axi4_set_AWLEN_from_SystemVerilog( AWLEN );
            end
        end
    end

    always @(posedge AWSIZE_changed or posedge _check_t0_values )
    begin
        while (AWSIZE_changed == 1'b1)
        begin
            axi4_get_AWSIZE_into_SystemVerilog(  ); // DPI call to imported task
            AWSIZE_changed = 1'b0;
            #0 if ( AWSIZE !== internal_AWSIZE )
            begin
                axi4_set_AWSIZE_from_SystemVerilog( AWSIZE );
            end
        end
    end

    always @(posedge AWBURST_changed or posedge _check_t0_values )
    begin
        while (AWBURST_changed == 1'b1)
        begin
            axi4_get_AWBURST_into_SystemVerilog(  ); // DPI call to imported task
            AWBURST_changed = 1'b0;
            #0 if ( AWBURST !== internal_AWBURST )
            begin
                axi4_set_AWBURST_from_SystemVerilog( AWBURST );
            end
        end
    end

    always @(posedge AWLOCK_changed or posedge _check_t0_values )
    begin
        while (AWLOCK_changed == 1'b1)
        begin
            axi4_get_AWLOCK_into_SystemVerilog(  ); // DPI call to imported task
            AWLOCK_changed = 1'b0;
            #0 if ( AWLOCK !== internal_AWLOCK )
            begin
                axi4_set_AWLOCK_from_SystemVerilog( AWLOCK );
            end
        end
    end

    always @(posedge AWCACHE_changed or posedge _check_t0_values )
    begin
        while (AWCACHE_changed == 1'b1)
        begin
            axi4_get_AWCACHE_into_SystemVerilog(  ); // DPI call to imported task
            AWCACHE_changed = 1'b0;
            #0 if ( AWCACHE !== internal_AWCACHE )
            begin
                axi4_set_AWCACHE_from_SystemVerilog( AWCACHE );
            end
        end
    end

    always @(posedge AWQOS_changed or posedge _check_t0_values )
    begin
        while (AWQOS_changed == 1'b1)
        begin
            axi4_get_AWQOS_into_SystemVerilog(  ); // DPI call to imported task
            AWQOS_changed = 1'b0;
            #0 if ( AWQOS !== internal_AWQOS )
            begin
                axi4_set_AWQOS_from_SystemVerilog( AWQOS );
            end
        end
    end

    always @(posedge AWID_changed or posedge _check_t0_values )
    begin
        while (AWID_changed == 1'b1)
        begin
            axi4_get_AWID_into_SystemVerilog(  ); // DPI call to imported task
            AWID_changed = 1'b0;
            #0 if ( AWID !== internal_AWID )
            begin
                axi4_set_AWID_from_SystemVerilog( AWID );
            end
        end
    end

    always @(posedge AWUSER_changed or posedge _check_t0_values )
    begin
        while (AWUSER_changed == 1'b1)
        begin
            axi4_get_AWUSER_into_SystemVerilog(  ); // DPI call to imported task
            AWUSER_changed = 1'b0;
            #0 if ( AWUSER !== internal_AWUSER )
            begin
                axi4_set_AWUSER_from_SystemVerilog( AWUSER );
            end
        end
    end

    always @(posedge AWREADY_changed or posedge _check_t0_values )
    begin
        while (AWREADY_changed == 1'b1)
        begin
            axi4_get_AWREADY_into_SystemVerilog(  ); // DPI call to imported task
            AWREADY_changed = 1'b0;
            #0 if ( AWREADY !== internal_AWREADY )
            begin
                axi4_set_AWREADY_from_SystemVerilog( AWREADY );
            end
        end
    end

    always @(posedge ARVALID_changed or posedge _check_t0_values )
    begin
        while (ARVALID_changed == 1'b1)
        begin
            axi4_get_ARVALID_into_SystemVerilog(  ); // DPI call to imported task
            ARVALID_changed = 1'b0;
            #0 if ( ARVALID !== internal_ARVALID )
            begin
                axi4_set_ARVALID_from_SystemVerilog( ARVALID );
            end
        end
    end

    always @(posedge ARADDR_changed or posedge _check_t0_values )
    begin
        while (ARADDR_changed == 1'b1)
        begin
            axi4_get_ARADDR_into_SystemVerilog(  ); // DPI call to imported task
            ARADDR_changed = 1'b0;
            #0 if ( ARADDR !== internal_ARADDR )
            begin
                axi4_set_ARADDR_from_SystemVerilog( ARADDR );
            end
        end
    end

    always @(posedge ARPROT_changed or posedge _check_t0_values )
    begin
        while (ARPROT_changed == 1'b1)
        begin
            axi4_get_ARPROT_into_SystemVerilog(  ); // DPI call to imported task
            ARPROT_changed = 1'b0;
            #0 if ( ARPROT !== internal_ARPROT )
            begin
                axi4_set_ARPROT_from_SystemVerilog( ARPROT );
            end
        end
    end

    always @(posedge ARREGION_changed or posedge _check_t0_values )
    begin
        while (ARREGION_changed == 1'b1)
        begin
            axi4_get_ARREGION_into_SystemVerilog(  ); // DPI call to imported task
            ARREGION_changed = 1'b0;
            #0 if ( ARREGION !== internal_ARREGION )
            begin
                axi4_set_ARREGION_from_SystemVerilog( ARREGION );
            end
        end
    end

    always @(posedge ARLEN_changed or posedge _check_t0_values )
    begin
        while (ARLEN_changed == 1'b1)
        begin
            axi4_get_ARLEN_into_SystemVerilog(  ); // DPI call to imported task
            ARLEN_changed = 1'b0;
            #0 if ( ARLEN !== internal_ARLEN )
            begin
                axi4_set_ARLEN_from_SystemVerilog( ARLEN );
            end
        end
    end

    always @(posedge ARSIZE_changed or posedge _check_t0_values )
    begin
        while (ARSIZE_changed == 1'b1)
        begin
            axi4_get_ARSIZE_into_SystemVerilog(  ); // DPI call to imported task
            ARSIZE_changed = 1'b0;
            #0 if ( ARSIZE !== internal_ARSIZE )
            begin
                axi4_set_ARSIZE_from_SystemVerilog( ARSIZE );
            end
        end
    end

    always @(posedge ARBURST_changed or posedge _check_t0_values )
    begin
        while (ARBURST_changed == 1'b1)
        begin
            axi4_get_ARBURST_into_SystemVerilog(  ); // DPI call to imported task
            ARBURST_changed = 1'b0;
            #0 if ( ARBURST !== internal_ARBURST )
            begin
                axi4_set_ARBURST_from_SystemVerilog( ARBURST );
            end
        end
    end

    always @(posedge ARLOCK_changed or posedge _check_t0_values )
    begin
        while (ARLOCK_changed == 1'b1)
        begin
            axi4_get_ARLOCK_into_SystemVerilog(  ); // DPI call to imported task
            ARLOCK_changed = 1'b0;
            #0 if ( ARLOCK !== internal_ARLOCK )
            begin
                axi4_set_ARLOCK_from_SystemVerilog( ARLOCK );
            end
        end
    end

    always @(posedge ARCACHE_changed or posedge _check_t0_values )
    begin
        while (ARCACHE_changed == 1'b1)
        begin
            axi4_get_ARCACHE_into_SystemVerilog(  ); // DPI call to imported task
            ARCACHE_changed = 1'b0;
            #0 if ( ARCACHE !== internal_ARCACHE )
            begin
                axi4_set_ARCACHE_from_SystemVerilog( ARCACHE );
            end
        end
    end

    always @(posedge ARQOS_changed or posedge _check_t0_values )
    begin
        while (ARQOS_changed == 1'b1)
        begin
            axi4_get_ARQOS_into_SystemVerilog(  ); // DPI call to imported task
            ARQOS_changed = 1'b0;
            #0 if ( ARQOS !== internal_ARQOS )
            begin
                axi4_set_ARQOS_from_SystemVerilog( ARQOS );
            end
        end
    end

    always @(posedge ARID_changed or posedge _check_t0_values )
    begin
        while (ARID_changed == 1'b1)
        begin
            axi4_get_ARID_into_SystemVerilog(  ); // DPI call to imported task
            ARID_changed = 1'b0;
            #0 if ( ARID !== internal_ARID )
            begin
                axi4_set_ARID_from_SystemVerilog( ARID );
            end
        end
    end

    always @(posedge ARUSER_changed or posedge _check_t0_values )
    begin
        while (ARUSER_changed == 1'b1)
        begin
            axi4_get_ARUSER_into_SystemVerilog(  ); // DPI call to imported task
            ARUSER_changed = 1'b0;
            #0 if ( ARUSER !== internal_ARUSER )
            begin
                axi4_set_ARUSER_from_SystemVerilog( ARUSER );
            end
        end
    end

    always @(posedge ARREADY_changed or posedge _check_t0_values )
    begin
        while (ARREADY_changed == 1'b1)
        begin
            axi4_get_ARREADY_into_SystemVerilog(  ); // DPI call to imported task
            ARREADY_changed = 1'b0;
            #0 if ( ARREADY !== internal_ARREADY )
            begin
                axi4_set_ARREADY_from_SystemVerilog( ARREADY );
            end
        end
    end

    always @(posedge RVALID_changed or posedge _check_t0_values )
    begin
        while (RVALID_changed == 1'b1)
        begin
            axi4_get_RVALID_into_SystemVerilog(  ); // DPI call to imported task
            RVALID_changed = 1'b0;
            #0 if ( RVALID !== internal_RVALID )
            begin
                axi4_set_RVALID_from_SystemVerilog( RVALID );
            end
        end
    end

    always @(posedge RDATA_changed or posedge _check_t0_values )
    begin
        while (RDATA_changed == 1'b1)
        begin
            axi4_get_RDATA_into_SystemVerilog(  ); // DPI call to imported task
            RDATA_changed = 1'b0;
            #0 if ( RDATA !== internal_RDATA )
            begin
                axi4_set_RDATA_from_SystemVerilog( RDATA );
            end
        end
    end

    always @(posedge RRESP_changed or posedge _check_t0_values )
    begin
        while (RRESP_changed == 1'b1)
        begin
            axi4_get_RRESP_into_SystemVerilog(  ); // DPI call to imported task
            RRESP_changed = 1'b0;
            #0 if ( RRESP !== internal_RRESP )
            begin
                axi4_set_RRESP_from_SystemVerilog( RRESP );
            end
        end
    end

    always @(posedge RLAST_changed or posedge _check_t0_values )
    begin
        while (RLAST_changed == 1'b1)
        begin
            axi4_get_RLAST_into_SystemVerilog(  ); // DPI call to imported task
            RLAST_changed = 1'b0;
            #0 if ( RLAST !== internal_RLAST )
            begin
                axi4_set_RLAST_from_SystemVerilog( RLAST );
            end
        end
    end

    always @(posedge RID_changed or posedge _check_t0_values )
    begin
        while (RID_changed == 1'b1)
        begin
            axi4_get_RID_into_SystemVerilog(  ); // DPI call to imported task
            RID_changed = 1'b0;
            #0 if ( RID !== internal_RID )
            begin
                axi4_set_RID_from_SystemVerilog( RID );
            end
        end
    end

    always @(posedge RUSER_changed or posedge _check_t0_values )
    begin
        while (RUSER_changed == 1'b1)
        begin
            axi4_get_RUSER_into_SystemVerilog(  ); // DPI call to imported task
            RUSER_changed = 1'b0;
            #0 if ( RUSER !== internal_RUSER )
            begin
                axi4_set_RUSER_from_SystemVerilog( RUSER );
            end
        end
    end

    always @(posedge RREADY_changed or posedge _check_t0_values )
    begin
        while (RREADY_changed == 1'b1)
        begin
            axi4_get_RREADY_into_SystemVerilog(  ); // DPI call to imported task
            RREADY_changed = 1'b0;
            #0 if ( RREADY !== internal_RREADY )
            begin
                axi4_set_RREADY_from_SystemVerilog( RREADY );
            end
        end
    end

    always @(posedge WVALID_changed or posedge _check_t0_values )
    begin
        while (WVALID_changed == 1'b1)
        begin
            axi4_get_WVALID_into_SystemVerilog(  ); // DPI call to imported task
            WVALID_changed = 1'b0;
            #0 if ( WVALID !== internal_WVALID )
            begin
                axi4_set_WVALID_from_SystemVerilog( WVALID );
            end
        end
    end

    always @(posedge WDATA_changed or posedge _check_t0_values )
    begin
        while (WDATA_changed == 1'b1)
        begin
            axi4_get_WDATA_into_SystemVerilog(  ); // DPI call to imported task
            WDATA_changed = 1'b0;
            #0 if ( WDATA !== internal_WDATA )
            begin
                axi4_set_WDATA_from_SystemVerilog( WDATA );
            end
        end
    end

    always @(posedge WSTRB_changed or posedge _check_t0_values )
    begin
        while (WSTRB_changed == 1'b1)
        begin
            axi4_get_WSTRB_into_SystemVerilog(  ); // DPI call to imported task
            WSTRB_changed = 1'b0;
            #0 if ( WSTRB !== internal_WSTRB )
            begin
                axi4_set_WSTRB_from_SystemVerilog( WSTRB );
            end
        end
    end

    always @(posedge WLAST_changed or posedge _check_t0_values )
    begin
        while (WLAST_changed == 1'b1)
        begin
            axi4_get_WLAST_into_SystemVerilog(  ); // DPI call to imported task
            WLAST_changed = 1'b0;
            #0 if ( WLAST !== internal_WLAST )
            begin
                axi4_set_WLAST_from_SystemVerilog( WLAST );
            end
        end
    end

    always @(posedge WUSER_changed or posedge _check_t0_values )
    begin
        while (WUSER_changed == 1'b1)
        begin
            axi4_get_WUSER_into_SystemVerilog(  ); // DPI call to imported task
            WUSER_changed = 1'b0;
            #0 if ( WUSER !== internal_WUSER )
            begin
                axi4_set_WUSER_from_SystemVerilog( WUSER );
            end
        end
    end

    always @(posedge WREADY_changed or posedge _check_t0_values )
    begin
        while (WREADY_changed == 1'b1)
        begin
            axi4_get_WREADY_into_SystemVerilog(  ); // DPI call to imported task
            WREADY_changed = 1'b0;
            #0 if ( WREADY !== internal_WREADY )
            begin
                axi4_set_WREADY_from_SystemVerilog( WREADY );
            end
        end
    end

    always @(posedge BVALID_changed or posedge _check_t0_values )
    begin
        while (BVALID_changed == 1'b1)
        begin
            axi4_get_BVALID_into_SystemVerilog(  ); // DPI call to imported task
            BVALID_changed = 1'b0;
            #0 if ( BVALID !== internal_BVALID )
            begin
                axi4_set_BVALID_from_SystemVerilog( BVALID );
            end
        end
    end

    always @(posedge BRESP_changed or posedge _check_t0_values )
    begin
        while (BRESP_changed == 1'b1)
        begin
            axi4_get_BRESP_into_SystemVerilog(  ); // DPI call to imported task
            BRESP_changed = 1'b0;
            #0 if ( BRESP !== internal_BRESP )
            begin
                axi4_set_BRESP_from_SystemVerilog( BRESP );
            end
        end
    end

    always @(posedge BID_changed or posedge _check_t0_values )
    begin
        while (BID_changed == 1'b1)
        begin
            axi4_get_BID_into_SystemVerilog(  ); // DPI call to imported task
            BID_changed = 1'b0;
            #0 if ( BID !== internal_BID )
            begin
                axi4_set_BID_from_SystemVerilog( BID );
            end
        end
    end

    always @(posedge BUSER_changed or posedge _check_t0_values )
    begin
        while (BUSER_changed == 1'b1)
        begin
            axi4_get_BUSER_into_SystemVerilog(  ); // DPI call to imported task
            BUSER_changed = 1'b0;
            #0 if ( BUSER !== internal_BUSER )
            begin
                axi4_set_BUSER_from_SystemVerilog( BUSER );
            end
        end
    end

    always @(posedge BREADY_changed or posedge _check_t0_values )
    begin
        while (BREADY_changed == 1'b1)
        begin
            axi4_get_BREADY_into_SystemVerilog(  ); // DPI call to imported task
            BREADY_changed = 1'b0;
            #0 if ( BREADY !== internal_BREADY )
            begin
                axi4_set_BREADY_from_SystemVerilog( BREADY );
            end
        end
    end

    always @(posedge config_interface_type_changed or posedge _check_t0_values )
    begin
        if (config_interface_type_changed == 1'b1)
        begin
            axi4_get_config_interface_type_into_SystemVerilog(  ); // DPI call to imported task
            config_interface_type_changed = 1'b0;
        end
    end

    always @(posedge config_clk_init_value_changed or posedge _check_t0_values )
    begin
        if (config_clk_init_value_changed == 1'b1)
        begin
            axi4_get_config_clk_init_value_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_init_value_changed = 1'b0;
        end
    end

    always @(posedge config_clk_phase_shift_changed or posedge _check_t0_values )
    begin
        if (config_clk_phase_shift_changed == 1'b1)
        begin
            axi4_get_config_clk_phase_shift_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_phase_shift_changed = 1'b0;
        end
    end

    always @(posedge config_clk_1st_time_changed or posedge _check_t0_values )
    begin
        if (config_clk_1st_time_changed == 1'b1)
        begin
            axi4_get_config_clk_1st_time_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_1st_time_changed = 1'b0;
        end
    end

    always @(posedge config_clk_2nd_time_changed or posedge _check_t0_values )
    begin
        if (config_clk_2nd_time_changed == 1'b1)
        begin
            axi4_get_config_clk_2nd_time_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_2nd_time_changed = 1'b0;
        end
    end

    always @(posedge config_setup_time_changed or posedge _check_t0_values )
    begin
        if (config_setup_time_changed == 1'b1)
        begin
            axi4_get_config_setup_time_into_SystemVerilog(  ); // DPI call to imported task
            config_setup_time_changed = 1'b0;
        end
    end

    always @(posedge config_hold_time_changed or posedge _check_t0_values )
    begin
        if (config_hold_time_changed == 1'b1)
        begin
            axi4_get_config_hold_time_into_SystemVerilog(  ); // DPI call to imported task
            config_hold_time_changed = 1'b0;
        end
    end

    always @(posedge config_burst_timeout_factor_changed or posedge _check_t0_values )
    begin
        if (config_burst_timeout_factor_changed == 1'b1)
        begin
            axi4_get_config_burst_timeout_factor_into_SystemVerilog(  ); // DPI call to imported task
            config_burst_timeout_factor_changed = 1'b0;
        end
    end

    always @(posedge config_max_transaction_time_factor_changed or posedge _check_t0_values )
    begin
        if (config_max_transaction_time_factor_changed == 1'b1)
        begin
            axi4_get_config_max_transaction_time_factor_into_SystemVerilog(  ); // DPI call to imported task
            config_max_transaction_time_factor_changed = 1'b0;
        end
    end

    always @(posedge config_write_ctrl_first_ratio_changed or posedge _check_t0_values )
    begin
        if (config_write_ctrl_first_ratio_changed == 1'b1)
        begin
            axi4_get_config_write_ctrl_first_ratio_into_SystemVerilog(  ); // DPI call to imported task
            config_write_ctrl_first_ratio_changed = 1'b0;
        end
    end

    always @(posedge config_write_data_first_ratio_changed or posedge _check_t0_values )
    begin
        if (config_write_data_first_ratio_changed == 1'b1)
        begin
            axi4_get_config_write_data_first_ratio_into_SystemVerilog(  ); // DPI call to imported task
            config_write_data_first_ratio_changed = 1'b0;
        end
    end

    always @(posedge config_reset_low_clocks_changed or posedge _check_t0_values )
    begin
        if (config_reset_low_clocks_changed == 1'b1)
        begin
            axi4_get_config_reset_low_clocks_into_SystemVerilog(  ); // DPI call to imported task
            config_reset_low_clocks_changed = 1'b0;
        end
    end

    always @(posedge config_reset_hold_time_changed or posedge _check_t0_values )
    begin
        if (config_reset_hold_time_changed == 1'b1)
        begin
            axi4_get_config_reset_hold_time_into_SystemVerilog(  ); // DPI call to imported task
            config_reset_hold_time_changed = 1'b0;
        end
    end

    always @(posedge config_enable_rlast_changed or posedge _check_t0_values )
    begin
        if (config_enable_rlast_changed == 1'b1)
        begin
            axi4_get_config_enable_rlast_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_rlast_changed = 1'b0;
        end
    end

    always @(posedge config_enable_slave_exclusive_changed or posedge _check_t0_values )
    begin
        if (config_enable_slave_exclusive_changed == 1'b1)
        begin
            axi4_get_config_enable_slave_exclusive_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_slave_exclusive_changed = 1'b0;
        end
    end

    always @(posedge config_enable_burst_reserved_value_changed or posedge _check_t0_values )
    begin
        if (config_enable_burst_reserved_value_changed == 1'b1)
        begin
            axi4_get_config_enable_burst_reserved_value_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_burst_reserved_value_changed = 1'b0;
        end
    end

    always @(posedge config_enable_cache_value_changed or posedge _check_t0_values )
    begin
        if (config_enable_cache_value_changed == 1'b1)
        begin
            axi4_get_config_enable_cache_value_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_cache_value_changed = 1'b0;
        end
    end

    always @(posedge internal_dummy_variable_changed or posedge _check_t0_values )
    begin
        if (internal_dummy_variable_changed == 1'b1)
        begin
            axi4_get_internal_dummy_variable_into_SystemVerilog(  ); // DPI call to imported task
            internal_dummy_variable_changed = 1'b0;
        end
    end

    always @(posedge config_axi4lite_interface_changed or posedge _check_t0_values )
    begin
        if (config_axi4lite_interface_changed == 1'b1)
        begin
            axi4_get_config_axi4lite_interface_into_SystemVerilog(  ); // DPI call to imported task
            config_axi4lite_interface_changed = 1'b0;
        end
    end

    always @(posedge config_axi4lite_tr_id_changed or posedge _check_t0_values )
    begin
        if (config_axi4lite_tr_id_changed == 1'b1)
        begin
            axi4_get_config_axi4lite_tr_id_into_SystemVerilog(  ); // DPI call to imported task
            config_axi4lite_tr_id_changed = 1'b0;
        end
    end

    always @(posedge config_enable_all_assertions_changed or posedge _check_t0_values )
    begin
        if (config_enable_all_assertions_changed == 1'b1)
        begin
            axi4_get_config_enable_all_assertions_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_all_assertions_changed = 1'b0;
        end
    end

    always @(posedge config_enable_assertion_changed or posedge _check_t0_values )
    begin
        if (config_enable_assertion_changed == 1'b1)
        begin
            axi4_get_config_enable_assertion_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_assertion_changed = 1'b0;
        end
    end

    always @(posedge config_enable_error_changed or posedge _check_t0_values )
    begin
        if (config_enable_error_changed == 1'b1)
        begin
            axi4_get_config_enable_error_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_error_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_AWVALID_assertion_to_AWREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_AWVALID_assertion_to_AWREADY_changed == 1'b1)
        begin
            axi4_get_config_max_latency_AWVALID_assertion_to_AWREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_AWVALID_assertion_to_AWREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_ARVALID_assertion_to_ARREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_ARVALID_assertion_to_ARREADY_changed == 1'b1)
        begin
            axi4_get_config_max_latency_ARVALID_assertion_to_ARREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_ARVALID_assertion_to_ARREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_RVALID_assertion_to_RREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_RVALID_assertion_to_RREADY_changed == 1'b1)
        begin
            axi4_get_config_max_latency_RVALID_assertion_to_RREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_RVALID_assertion_to_RREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_BVALID_assertion_to_BREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_BVALID_assertion_to_BREADY_changed == 1'b1)
        begin
            axi4_get_config_max_latency_BVALID_assertion_to_BREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_BVALID_assertion_to_BREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_WVALID_assertion_to_WREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_WVALID_assertion_to_WREADY_changed == 1'b1)
        begin
            axi4_get_config_max_latency_WVALID_assertion_to_WREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_WVALID_assertion_to_WREADY_changed = 1'b0;
        end
    end

    always @(posedge config_enable_qos_changed or posedge _check_t0_values )
    begin
        if (config_enable_qos_changed == 1'b1)
        begin
            axi4_get_config_enable_qos_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_qos_changed = 1'b0;
        end
    end

    always @(posedge config_enable_region_support_changed or posedge _check_t0_values )
    begin
        if (config_enable_region_support_changed == 1'b1)
        begin
            axi4_get_config_enable_region_support_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_region_support_changed = 1'b0;
        end
    end

    always @(posedge config_slave_regions_changed or posedge _check_t0_values )
    begin
        if (config_slave_regions_changed == 1'b1)
        begin
            axi4_get_config_slave_regions_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_regions_changed = 1'b0;
        end
    end

    always @(posedge config_region_changed or posedge _check_t0_values )
    begin
        if (config_region_changed == 1'b1)
        begin
            axi4_get_config_region_into_SystemVerilog(  ); // DPI call to imported task
            config_region_changed = 1'b0;
        end
    end

    always @(posedge region_error_state_changed or posedge _check_t0_values )
    begin
        if (region_error_state_changed == 1'b1)
        begin
            axi4_get_region_error_state_into_SystemVerilog(  ); // DPI call to imported task
            region_error_state_changed = 1'b0;
        end
    end

    always @(posedge region_map_lb_changed or posedge _check_t0_values )
    begin
        if (region_map_lb_changed == 1'b1)
        begin
            axi4_get_region_map_lb_into_SystemVerilog(  ); // DPI call to imported task
            region_map_lb_changed = 1'b0;
        end
    end

    always @(posedge region_map_ub_changed or posedge _check_t0_values )
    begin
        if (region_map_ub_changed == 1'b1)
        begin
            axi4_get_region_map_ub_into_SystemVerilog(  ); // DPI call to imported task
            region_map_ub_changed = 1'b0;
        end
    end

    always @(posedge region_map_region_changed or posedge _check_t0_values )
    begin
        if (region_map_region_changed == 1'b1)
        begin
            axi4_get_region_map_region_into_SystemVerilog(  ); // DPI call to imported task
            region_map_region_changed = 1'b0;
        end
    end

    always @(posedge cacheable_changed or posedge _check_t0_values )
    begin
        if (cacheable_changed == 1'b1)
        begin
            axi4_get_cacheable_into_SystemVerilog(  ); // DPI call to imported task
            cacheable_changed = 1'b0;
        end
    end

    always @(posedge config_read_data_reordering_depth_changed or posedge _check_t0_values )
    begin
        if (config_read_data_reordering_depth_changed == 1'b1)
        begin
            axi4_get_config_read_data_reordering_depth_into_SystemVerilog(  ); // DPI call to imported task
            config_read_data_reordering_depth_changed = 1'b0;
        end
    end

    always @(posedge config_slave_start_addr_changed or posedge _check_t0_values )
    begin
        if (config_slave_start_addr_changed == 1'b1)
        begin
            axi4_get_config_slave_start_addr_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_start_addr_changed = 1'b0;
        end
    end

    always @(posedge config_slave_end_addr_changed or posedge _check_t0_values )
    begin
        if (config_slave_end_addr_changed == 1'b1)
        begin
            axi4_get_config_slave_end_addr_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_end_addr_changed = 1'b0;
        end
    end

    always @(posedge config_slave_enabled_non_contiguous_address_spaces_changed or posedge _check_t0_values )
    begin
        if (config_slave_enabled_non_contiguous_address_spaces_changed == 1'b1)
        begin
            axi4_get_config_slave_enabled_non_contiguous_address_spaces_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_enabled_non_contiguous_address_spaces_changed = 1'b0;
        end
    end

    always @(posedge config_slave_possess_multiple_non_contiguous_address_spaces_changed or posedge _check_t0_values )
    begin
        if (config_slave_possess_multiple_non_contiguous_address_spaces_changed == 1'b1)
        begin
            axi4_get_config_slave_possess_multiple_non_contiguous_address_spaces_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_possess_multiple_non_contiguous_address_spaces_changed = 1'b0;
        end
    end

    always @(posedge config_slave_multiple_non_contiguous_start_address_range_changed or posedge _check_t0_values )
    begin
        if (config_slave_multiple_non_contiguous_start_address_range_changed == 1'b1)
        begin
            axi4_get_config_slave_multiple_non_contiguous_start_address_range_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_multiple_non_contiguous_start_address_range_changed = 1'b0;
        end
    end

    always @(posedge config_slave_multiple_non_contiguous_end_address_range_changed or posedge _check_t0_values )
    begin
        if (config_slave_multiple_non_contiguous_end_address_range_changed == 1'b1)
        begin
            axi4_get_config_slave_multiple_non_contiguous_end_address_range_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_multiple_non_contiguous_end_address_range_changed = 1'b0;
        end
    end

    always @(posedge config_protect_ready_changed or posedge _check_t0_values )
    begin
        if (config_protect_ready_changed == 1'b1)
        begin
            axi4_get_config_protect_ready_into_SystemVerilog(  ); // DPI call to imported task
            config_protect_ready_changed = 1'b0;
        end
    end

    always @(posedge master_end_tlm_status_changed or posedge _check_t0_values )
    begin
        if (master_end_tlm_status_changed == 1'b1)
        begin
            axi4_get_master_end_tlm_status_into_SystemVerilog(  ); // DPI call to imported task
            master_end_tlm_status_changed = 1'b0;
        end
    end

    always @(posedge master_end_wlm_status_changed or posedge _check_t0_values )
    begin
        if (master_end_wlm_status_changed == 1'b1)
        begin
            axi4_get_master_end_wlm_status_into_SystemVerilog(  ); // DPI call to imported task
            master_end_wlm_status_changed = 1'b0;
        end
    end

    always @(posedge slave_end_tlm_status_changed or posedge _check_t0_values )
    begin
        if (slave_end_tlm_status_changed == 1'b1)
        begin
            axi4_get_slave_end_tlm_status_into_SystemVerilog(  ); // DPI call to imported task
            slave_end_tlm_status_changed = 1'b0;
        end
    end

    always @(posedge slave_end_wlm_status_changed or posedge _check_t0_values )
    begin
        if (slave_end_wlm_status_changed == 1'b1)
        begin
            axi4_get_slave_end_wlm_status_into_SystemVerilog(  ); // DPI call to imported task
            slave_end_wlm_status_changed = 1'b0;
        end
    end

    always @(posedge clock_source_end_tlm_status_changed or posedge _check_t0_values )
    begin
        if (clock_source_end_tlm_status_changed == 1'b1)
        begin
            axi4_get_clock_source_end_tlm_status_into_SystemVerilog(  ); // DPI call to imported task
            clock_source_end_tlm_status_changed = 1'b0;
        end
    end

    always @(posedge clock_source_end_wlm_status_changed or posedge _check_t0_values )
    begin
        if (clock_source_end_wlm_status_changed == 1'b1)
        begin
            axi4_get_clock_source_end_wlm_status_into_SystemVerilog(  ); // DPI call to imported task
            clock_source_end_wlm_status_changed = 1'b0;
        end
    end

    always @(posedge reset_source_end_tlm_status_changed or posedge _check_t0_values )
    begin
        if (reset_source_end_tlm_status_changed == 1'b1)
        begin
            axi4_get_reset_source_end_tlm_status_into_SystemVerilog(  ); // DPI call to imported task
            reset_source_end_tlm_status_changed = 1'b0;
        end
    end

    always @(posedge reset_source_end_wlm_status_changed or posedge _check_t0_values )
    begin
        if (reset_source_end_wlm_status_changed == 1'b1)
        begin
            axi4_get_reset_source_end_wlm_status_into_SystemVerilog(  ); // DPI call to imported task
            reset_source_end_wlm_status_changed = 1'b0;
        end
    end

    always @(posedge config_max_outstanding_wr_changed or posedge _check_t0_values )
    begin
        if (config_max_outstanding_wr_changed == 1'b1)
        begin
            axi4_get_config_max_outstanding_wr_into_SystemVerilog(  ); // DPI call to imported task
            config_max_outstanding_wr_changed = 1'b0;
        end
    end

    always @(posedge config_max_outstanding_rd_changed or posedge _check_t0_values )
    begin
        if (config_max_outstanding_rd_changed == 1'b1)
        begin
            axi4_get_config_max_outstanding_rd_into_SystemVerilog(  ); // DPI call to imported task
            config_max_outstanding_rd_changed = 1'b0;
        end
    end

    always @(posedge config_num_outstanding_wr_phase_changed or posedge _check_t0_values )
    begin
        if (config_num_outstanding_wr_phase_changed == 1'b1)
        begin
            axi4_get_config_num_outstanding_wr_phase_into_SystemVerilog(  ); // DPI call to imported task
            config_num_outstanding_wr_phase_changed = 1'b0;
        end
    end

    always @(posedge config_num_outstanding_rd_phase_changed or posedge _check_t0_values )
    begin
        if (config_num_outstanding_rd_phase_changed == 1'b1)
        begin
            axi4_get_config_num_outstanding_rd_phase_into_SystemVerilog(  ); // DPI call to imported task
            config_num_outstanding_rd_phase_changed = 1'b0;
        end
    end

    always @(posedge config_enable_warnings_changed or posedge _check_t0_values )
    begin
        if (config_enable_warnings_changed == 1'b1)
        begin
            axi4_get_config_enable_warnings_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_warnings_changed = 1'b0;
        end
    end

    always @(posedge config_enable_errors_changed or posedge _check_t0_values )
    begin
        if (config_enable_errors_changed == 1'b1)
        begin
            axi4_get_config_enable_errors_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_errors_changed = 1'b0;
        end
    end

    always @(posedge config_enable_exclusive_checks_changed or posedge _check_t0_values )
    begin
        if (config_enable_exclusive_checks_changed == 1'b1)
        begin
            axi4_get_config_enable_exclusive_checks_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_exclusive_checks_changed = 1'b0;
        end
    end

    always @(posedge config_warn_on_slave_errors_changed or posedge _check_t0_values )
    begin
        if (config_warn_on_slave_errors_changed == 1'b1)
        begin
            axi4_get_config_warn_on_slave_errors_into_SystemVerilog(  ); // DPI call to imported task
            config_warn_on_slave_errors_changed = 1'b0;
        end
    end

    always @(posedge config_error_on_deleted_valid_cycles_changed or posedge _check_t0_values )
    begin
        if (config_error_on_deleted_valid_cycles_changed == 1'b1)
        begin
            axi4_get_config_error_on_deleted_valid_cycles_into_SystemVerilog(  ); // DPI call to imported task
            config_error_on_deleted_valid_cycles_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_occupancy_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_read_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_occupancy_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_write_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_data_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_data_occupancy_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_read_data_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_data_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_data_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_data_occupancy_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_write_data_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_data_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_latency_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_latency_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_read_latency_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_latency_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_latency_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_latency_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_write_latency_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_latency_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_address_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_address_waits_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_read_address_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_address_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_data_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_data_waits_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_read_data_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_data_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_address_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_address_waits_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_write_address_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_address_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_data_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_data_waits_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_write_data_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_data_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_response_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_response_waits_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_write_response_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_response_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_bandwidth_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_bandwidth_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_read_bandwidth_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_bandwidth_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_bandwidth_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_bandwidth_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_write_bandwidth_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_bandwidth_changed = 1'b0;
        end
    end

    always @(posedge stats_rw_transaction_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_rw_transaction_last_duration_changed == 1'b1)
        begin
            axi4_get_stats_rw_transaction_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_rw_transaction_last_duration_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_occupancy_step_changed == 1'b1)
        begin
            axi4_get_config_stats_read_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_occupancy_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_read_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_active_changed or posedge _check_t0_values )
    begin
        if (stats_read_active_changed == 1'b1)
        begin
            axi4_get_stats_read_active_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_active_changed = 1'b0;
        end
    end

    always @(posedge stats_read_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_occupancy_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_idle_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_occupancy_min_changed == 1'b1)
        begin
            axi4_get_stats_read_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_idle_min_changed == 1'b1)
        begin
            axi4_get_stats_read_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_occupancy_max_changed == 1'b1)
        begin
            axi4_get_stats_read_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_idle_max_changed == 1'b1)
        begin
            axi4_get_stats_read_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_occupancy_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_read_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_idle_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_read_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_read_last_duration_changed == 1'b1)
        begin
            axi4_get_stats_read_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_last_duration_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_occupancy_step_changed == 1'b1)
        begin
            axi4_get_config_stats_write_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_occupancy_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_write_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_active_changed or posedge _check_t0_values )
    begin
        if (stats_write_active_changed == 1'b1)
        begin
            axi4_get_stats_write_active_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_active_changed = 1'b0;
        end
    end

    always @(posedge stats_write_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_occupancy_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_idle_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_occupancy_min_changed == 1'b1)
        begin
            axi4_get_stats_write_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_idle_min_changed == 1'b1)
        begin
            axi4_get_stats_write_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_occupancy_max_changed == 1'b1)
        begin
            axi4_get_stats_write_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_idle_max_changed == 1'b1)
        begin
            axi4_get_stats_write_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_occupancy_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_write_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_idle_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_write_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_write_last_duration_changed == 1'b1)
        begin
            axi4_get_stats_write_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_last_duration_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_occupancy_step_changed == 1'b1)
        begin
            axi4_get_config_stats_read_data_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_occupancy_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_read_data_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_data_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_data_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_min_changed == 1'b1)
        begin
            axi4_get_stats_read_data_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_min_changed == 1'b1)
        begin
            axi4_get_stats_read_data_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_max_changed == 1'b1)
        begin
            axi4_get_stats_read_data_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_max_changed == 1'b1)
        begin
            axi4_get_stats_read_data_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_data_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_data_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_occupancy_step_changed == 1'b1)
        begin
            axi4_get_config_stats_write_data_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_occupancy_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_write_data_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_data_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_data_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_min_changed == 1'b1)
        begin
            axi4_get_stats_write_data_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_min_changed == 1'b1)
        begin
            axi4_get_stats_write_data_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_max_changed == 1'b1)
        begin
            axi4_get_stats_write_data_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_max_changed == 1'b1)
        begin
            axi4_get_stats_write_data_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_data_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_data_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_bandwidth_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_bandwidth_step_changed == 1'b1)
        begin
            axi4_get_config_stats_read_bandwidth_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_bandwidth_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_bandwidth_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_bandwidth_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_read_bandwidth_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_bandwidth_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_bandwidth_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_min_changed == 1'b1)
        begin
            axi4_get_stats_read_bandwidth_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_max_changed == 1'b1)
        begin
            axi4_get_stats_read_bandwidth_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_bandwidth_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_bandwidth_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_bandwidth_step_changed == 1'b1)
        begin
            axi4_get_config_stats_write_bandwidth_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_bandwidth_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_bandwidth_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_bandwidth_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_write_bandwidth_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_bandwidth_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_bandwidth_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_min_changed == 1'b1)
        begin
            axi4_get_stats_write_bandwidth_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_max_changed == 1'b1)
        begin
            axi4_get_stats_write_bandwidth_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_bandwidth_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_latency_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_latency_step_changed == 1'b1)
        begin
            axi4_get_config_stats_read_latency_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_latency_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_latency_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_latency_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_read_latency_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_latency_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_inst_changed == 1'b1)
        begin
            axi4_get_stats_read_address_data_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_address_data_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_min_changed == 1'b1)
        begin
            axi4_get_stats_read_address_data_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_max_changed == 1'b1)
        begin
            axi4_get_stats_read_address_data_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_address_data_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_inst_changed == 1'b1)
        begin
            axi4_get_stats_read_address_address_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_address_address_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_min_changed == 1'b1)
        begin
            axi4_get_stats_read_address_address_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_max_changed == 1'b1)
        begin
            axi4_get_stats_read_address_address_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_address_address_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_latency_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_latency_step_changed == 1'b1)
        begin
            axi4_get_config_stats_write_latency_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_latency_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_latency_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_latency_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_write_latency_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_latency_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_response_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_response_latency_inst_changed == 1'b1)
        begin
            axi4_get_stats_write_address_response_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_response_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_response_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_response_latency_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_address_response_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_response_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_response_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_response_latency_min_changed == 1'b1)
        begin
            axi4_get_stats_write_address_response_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_response_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_response_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_response_latency_max_changed == 1'b1)
        begin
            axi4_get_stats_write_address_response_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_response_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_response_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_response_latency_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_address_response_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_response_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_inst_changed == 1'b1)
        begin
            axi4_get_stats_write_address_address_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_address_address_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_min_changed == 1'b1)
        begin
            axi4_get_stats_write_address_address_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_max_changed == 1'b1)
        begin
            axi4_get_stats_write_address_address_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_address_address_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_address_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_address_waits_step_changed == 1'b1)
        begin
            axi4_get_config_stats_read_address_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_address_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_address_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_address_waits_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_read_address_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_address_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_inst_changed == 1'b1)
        begin
            axi4_get_stats_read_address_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_address_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_min_changed == 1'b1)
        begin
            axi4_get_stats_read_address_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_max_changed == 1'b1)
        begin
            axi4_get_stats_read_address_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_address_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_waits_step_changed == 1'b1)
        begin
            axi4_get_config_stats_read_data_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_waits_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_read_data_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_inst_changed == 1'b1)
        begin
            axi4_get_stats_read_data_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_data_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_min_changed == 1'b1)
        begin
            axi4_get_stats_read_data_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_max_changed == 1'b1)
        begin
            axi4_get_stats_read_data_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_data_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_address_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_address_waits_step_changed == 1'b1)
        begin
            axi4_get_config_stats_write_address_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_address_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_address_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_address_waits_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_write_address_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_address_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_inst_changed == 1'b1)
        begin
            axi4_get_stats_write_address_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_address_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_min_changed == 1'b1)
        begin
            axi4_get_stats_write_address_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_max_changed == 1'b1)
        begin
            axi4_get_stats_write_address_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_address_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_waits_step_changed == 1'b1)
        begin
            axi4_get_config_stats_write_data_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_waits_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_write_data_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_inst_changed == 1'b1)
        begin
            axi4_get_stats_write_data_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_data_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_min_changed == 1'b1)
        begin
            axi4_get_stats_write_data_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_max_changed == 1'b1)
        begin
            axi4_get_stats_write_data_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_data_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_response_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_response_waits_step_changed == 1'b1)
        begin
            axi4_get_config_stats_write_response_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_response_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_response_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_response_waits_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_write_response_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_response_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_inst_changed == 1'b1)
        begin
            axi4_get_stats_write_response_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_response_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_min_changed == 1'b1)
        begin
            axi4_get_stats_write_response_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_max_changed == 1'b1)
        begin
            axi4_get_stats_write_response_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_response_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge reordering_depth_of_last_read_transaction_changed or posedge _check_t0_values )
    begin
        if (reordering_depth_of_last_read_transaction_changed == 1'b1)
        begin
            axi4_get_reordering_depth_of_last_read_transaction_into_SystemVerilog(  ); // DPI call to imported task
            reordering_depth_of_last_read_transaction_changed = 1'b0;
        end
    end

// Timeless transaction interface support

    // assocative array of event indexed by unique_id(int)
    event assoc_timeless_comm_array[int];

    // these three functions are used by the timeless_trans_control event loop:
    // 1. initialise the loop
    import "DPI-C" context axi4_start_next_timeless_trans = function void axi4_start_next_timeless_trans();
    // 2. get next completed timeless transaction, returns null at the end
    import "DPI-C" context axi4_get_next_timeless_trans = function int axi4_get_next_timeless_trans();
    // 3. reset loop and empty the list
    import "DPI-C" context axi4_end_next_timeless_trans = function void axi4_end_next_timeless_trans();
    // could do above a little more efficiently by having each 'get' also remove the element so won't need an 'end'?

    // when timeless transaction monitor goes to 1 ..... trigger all the events associated with each transaction
    always @(posedge timeless_trans_control)
    begin
        int _trans_id ;
        // initialise C++ list
        axi4_start_next_timeless_trans() ; 
        // loop round the list, triggering all associated events
        for ( _trans_id= axi4_get_next_timeless_trans() ;
              _trans_id != 0 ;
              _trans_id= axi4_get_next_timeless_trans() )
        begin
            if ( assoc_timeless_comm_array.exists( _trans_id ) )
            begin
                // trigger the event
                -> assoc_timeless_comm_array[_trans_id] ;
                // the _END_ deletes it from the array after checking existance ...
                // - that's two accesses to the array here and two in the END, there must be a more efficient way! (Could do it in C++)
            end
            else
            begin
                // survivable (?) error - a non-null handle returned which isn't in the array!
                $display("Transaction WARNING @ %t: %m - unknown unique_id received from Adaptor.",$time);
            end
        end
        // completed C++ list
        axi4_end_next_timeless_trans() ; 
        timeless_trans_control= 0 ;
    end


    function longint get_last_handle();
        return last_handle;
    endfunction


    function longint get_last_start_time();
        return last_start_time;
    endfunction


    function longint get_last_end_time();
        return last_end_time;
    endfunction


    generate
    begin : questa_mvc_reporting
        bit report_available;

        // Function for getting a message from QUESTA_MVC. Returns 1 if a message was returned, 0 otherwise.
        import "DPI-C" questa_mvc_sv_get_report =  function bit get_report( input longint recipient,
                                     output string category,     output string objectName,
                                     output string instanceName, output string error_no,
                                     output string typ,          output string mess );
        questa_mvc_reporter endPoint[longint];
        initial report_available = 0;

        always @report_available
        begin
            longint recipient;
            string category;
            string objectName;
            string instanceName;
            string severity;
            string mess;
            string error_no;

            if ( endPoint.first( recipient ) )
              begin
                do
                  begin
                      while ( get_report( recipient, category, objectName, instanceName, error_no, severity, mess ) )
                        begin
                          endPoint[recipient].report_message( category, "axi4", 0, objectName, instanceName, error_no, severity, mess );
                        end
                  end
                while (endPoint.next(recipient));
              end
            report_available = 0;
        end

        import "DPI-C" context questa_mvc_register_end_point = function void questa_mvc_register_end_point( input longint as_end, input string name );

        // A function for registering a reporter to capture any reports coming from as_end
        function automatic void register_end_point( input longint as_end, input questa_mvc_reporter rep = null );
            if ( rep != null )
              begin
                if ( ( rep.name == "" ) || ( rep.name == "NULL" ) )
                  begin
                    $display("Error: %m: Reporter passed to register_end_point has a reserved name. Neither an empty string nor the string 'NULL' can be used.");
                  end
                else
                  begin
                    questa_mvc_register_end_point( as_end, rep.name );
                    endPoint[as_end] = rep;
                  end
              end
            else
              begin
                questa_mvc_register_end_point( as_end, "NULL" );
                endPoint.delete( as_end );
              end
        endfunction

    end : questa_mvc_reporting
    endgenerate

    //------------------------------------------------------------------------------
    // Tasks for registering reports
    //------------------------------------------------------------------------------
    function void register_interface_reporter( input questa_mvc_reporter _rep = null );
        questa_mvc_reporting.register_end_point( _interface_ref, _rep );
    endfunction


    // Support the old API for registering an interface, for backwards compatability.
    // Note that this function is deprecated and may be removed in the future.
    function void interface_register_reporter( input questa_mvc_reporter _rep = null );
        questa_mvc_reporting.register_end_point( _interface_ref, _rep );
    endfunction

    //------------------------------------------------------------------------------
    // Function: register_master_reporter
    //------------------------------------------------------------------------------
    //     Function used to register a reporter for the <master> end of the <axi4> interface.
    //     See <Customizing Error-Reporting> for a description of creating, customising and using reporters.
    //
    // Parameters:
    //    rep - The reporter to be used for the master end.
    //------------------------------------------------------------------------------
    function void register_master_reporter
    (
        input questa_mvc_reporter rep = null
    );
        questa_mvc_reporting.register_end_point( axi4_master_end, rep );
    endfunction

    //------------------------------------------------------------------------------
    // Function: register_slave_reporter
    //------------------------------------------------------------------------------
    //     Function used to register a reporter for the <slave> end of the <axi4> interface.
    //     See <Customizing Error-Reporting> for a description of creating, customising and using reporters.
    //
    // Parameters:
    //    rep - The reporter to be used for the slave end.
    //------------------------------------------------------------------------------
    function void register_slave_reporter
    (
        input questa_mvc_reporter rep = null
    );
        questa_mvc_reporting.register_end_point( axi4_slave_end, rep );
    endfunction

    //------------------------------------------------------------------------------
    // Function:- register_clock_source_reporter
    //------------------------------------------------------------------------------
    //     Function used to register a reporter for the <clock_source> end of the <axi4> interface.
    //     See <Customizing Error-Reporting> for a description of creating, customising and using reporters.
    //
    // Parameters:
    //    rep - The reporter to be used for the clock_source end.
    //------------------------------------------------------------------------------
    function void register_clock_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
        questa_mvc_reporting.register_end_point( axi4_clock_source_end, rep );
    endfunction

    //------------------------------------------------------------------------------
    // Function:- register_reset_source_reporter
    //------------------------------------------------------------------------------
    //     Function used to register a reporter for the <reset_source> end of the <axi4> interface.
    //     See <Customizing Error-Reporting> for a description of creating, customising and using reporters.
    //
    // Parameters:
    //    rep - The reporter to be used for the reset_source end.
    //------------------------------------------------------------------------------
    function void register_reset_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
        questa_mvc_reporting.register_end_point( axi4_reset_source_end, rep );
    endfunction


    //------------------------------------------------------------------------------
    // Tasks to wait for a number of specified edges on a wire
    //------------------------------------------------------------------------------


    //------------------------------------------------------------------------------
    // Function:- wait_for_ACLK
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ACLK>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ACLK( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ACLK);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ACLK);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ACLK);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ACLK === 0 );
                    @( ACLK );
                end
                while ( ACLK !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ACLK === 1 );
                    @( ACLK );
                end
                while ( ACLK !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARESETn
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARESETn>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARESETn( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARESETn);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARESETn);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARESETn);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARESETn === 0 );
                    @( ARESETn );
                end
                while ( ARESETn !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARESETn === 1 );
                    @( ARESETn );
                end
                while ( ARESETn !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWVALID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWVALID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWVALID === 0 );
                    @( AWVALID );
                end
                while ( AWVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWVALID === 1 );
                    @( AWVALID );
                end
                while ( AWVALID !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWADDR
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWADDR>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWADDR( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWADDR);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWADDR);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWADDR);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWADDR === 0 );
                    @( AWADDR );
                end
                while ( AWADDR !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWADDR === 1 );
                    @( AWADDR );
                end
                while ( AWADDR !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWADDR_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWADDR[_this_dot_1] === 0 );
                    @( AWADDR[_this_dot_1] );
                end
                while ( AWADDR[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWADDR[_this_dot_1] === 1 );
                    @( AWADDR[_this_dot_1] );
                end
                while ( AWADDR[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWPROT
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWPROT>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWPROT( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWPROT);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWPROT);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWPROT);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWPROT === 0 );
                    @( AWPROT );
                end
                while ( AWPROT !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWPROT === 1 );
                    @( AWPROT );
                end
                while ( AWPROT !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWPROT_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWPROT[_this_dot_1] === 0 );
                    @( AWPROT[_this_dot_1] );
                end
                while ( AWPROT[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWPROT[_this_dot_1] === 1 );
                    @( AWPROT[_this_dot_1] );
                end
                while ( AWPROT[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWREGION
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWREGION>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWREGION( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWREGION);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWREGION);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWREGION);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWREGION === 0 );
                    @( AWREGION );
                end
                while ( AWREGION !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWREGION === 1 );
                    @( AWREGION );
                end
                while ( AWREGION !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWREGION_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWREGION>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWREGION_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWREGION[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWREGION[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWREGION[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWREGION[_this_dot_1] === 0 );
                    @( AWREGION[_this_dot_1] );
                end
                while ( AWREGION[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWREGION[_this_dot_1] === 1 );
                    @( AWREGION[_this_dot_1] );
                end
                while ( AWREGION[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWLEN
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWLEN>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWLEN( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWLEN);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWLEN);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWLEN);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWLEN === 0 );
                    @( AWLEN );
                end
                while ( AWLEN !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWLEN === 1 );
                    @( AWLEN );
                end
                while ( AWLEN !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWLEN_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWLEN[_this_dot_1] === 0 );
                    @( AWLEN[_this_dot_1] );
                end
                while ( AWLEN[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWLEN[_this_dot_1] === 1 );
                    @( AWLEN[_this_dot_1] );
                end
                while ( AWLEN[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWSIZE
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWSIZE>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWSIZE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWSIZE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWSIZE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWSIZE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWSIZE === 0 );
                    @( AWSIZE );
                end
                while ( AWSIZE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWSIZE === 1 );
                    @( AWSIZE );
                end
                while ( AWSIZE !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWSIZE_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWSIZE[_this_dot_1] === 0 );
                    @( AWSIZE[_this_dot_1] );
                end
                while ( AWSIZE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWSIZE[_this_dot_1] === 1 );
                    @( AWSIZE[_this_dot_1] );
                end
                while ( AWSIZE[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWBURST
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWBURST>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWBURST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWBURST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWBURST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWBURST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWBURST === 0 );
                    @( AWBURST );
                end
                while ( AWBURST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWBURST === 1 );
                    @( AWBURST );
                end
                while ( AWBURST !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWBURST_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWBURST[_this_dot_1] === 0 );
                    @( AWBURST[_this_dot_1] );
                end
                while ( AWBURST[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWBURST[_this_dot_1] === 1 );
                    @( AWBURST[_this_dot_1] );
                end
                while ( AWBURST[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWLOCK
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWLOCK>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWLOCK( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWLOCK);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWLOCK);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWLOCK);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWLOCK === 0 );
                    @( AWLOCK );
                end
                while ( AWLOCK !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWLOCK === 1 );
                    @( AWLOCK );
                end
                while ( AWLOCK !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWCACHE
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWCACHE>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWCACHE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWCACHE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWCACHE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWCACHE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWCACHE === 0 );
                    @( AWCACHE );
                end
                while ( AWCACHE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWCACHE === 1 );
                    @( AWCACHE );
                end
                while ( AWCACHE !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWCACHE_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWCACHE[_this_dot_1] === 0 );
                    @( AWCACHE[_this_dot_1] );
                end
                while ( AWCACHE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWCACHE[_this_dot_1] === 1 );
                    @( AWCACHE[_this_dot_1] );
                end
                while ( AWCACHE[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWQOS
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWQOS>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWQOS( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWQOS);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWQOS);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWQOS);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWQOS === 0 );
                    @( AWQOS );
                end
                while ( AWQOS !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWQOS === 1 );
                    @( AWQOS );
                end
                while ( AWQOS !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWQOS_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWQOS>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWQOS_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWQOS[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWQOS[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWQOS[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWQOS[_this_dot_1] === 0 );
                    @( AWQOS[_this_dot_1] );
                end
                while ( AWQOS[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWQOS[_this_dot_1] === 1 );
                    @( AWQOS[_this_dot_1] );
                end
                while ( AWQOS[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWID === 0 );
                    @( AWID );
                end
                while ( AWID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWID === 1 );
                    @( AWID );
                end
                while ( AWID !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWID_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWID[_this_dot_1] === 0 );
                    @( AWID[_this_dot_1] );
                end
                while ( AWID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWID[_this_dot_1] === 1 );
                    @( AWID[_this_dot_1] );
                end
                while ( AWID[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWUSER
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWUSER>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWUSER === 0 );
                    @( AWUSER );
                end
                while ( AWUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWUSER === 1 );
                    @( AWUSER );
                end
                while ( AWUSER !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWUSER_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWUSER[_this_dot_1] === 0 );
                    @( AWUSER[_this_dot_1] );
                end
                while ( AWUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWUSER[_this_dot_1] === 1 );
                    @( AWUSER[_this_dot_1] );
                end
                while ( AWUSER[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_AWREADY
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::AWREADY>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_AWREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWREADY === 0 );
                    @( AWREADY );
                end
                while ( AWREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWREADY === 1 );
                    @( AWREADY );
                end
                while ( AWREADY !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARVALID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARVALID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARVALID === 0 );
                    @( ARVALID );
                end
                while ( ARVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARVALID === 1 );
                    @( ARVALID );
                end
                while ( ARVALID !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARADDR
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARADDR>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARADDR( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARADDR);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARADDR);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARADDR);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARADDR === 0 );
                    @( ARADDR );
                end
                while ( ARADDR !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARADDR === 1 );
                    @( ARADDR );
                end
                while ( ARADDR !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARADDR_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARADDR[_this_dot_1] === 0 );
                    @( ARADDR[_this_dot_1] );
                end
                while ( ARADDR[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARADDR[_this_dot_1] === 1 );
                    @( ARADDR[_this_dot_1] );
                end
                while ( ARADDR[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARPROT
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARPROT>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARPROT( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARPROT);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARPROT);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARPROT);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARPROT === 0 );
                    @( ARPROT );
                end
                while ( ARPROT !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARPROT === 1 );
                    @( ARPROT );
                end
                while ( ARPROT !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARPROT_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARPROT[_this_dot_1] === 0 );
                    @( ARPROT[_this_dot_1] );
                end
                while ( ARPROT[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARPROT[_this_dot_1] === 1 );
                    @( ARPROT[_this_dot_1] );
                end
                while ( ARPROT[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARREGION
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARREGION>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARREGION( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARREGION);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARREGION);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARREGION);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARREGION === 0 );
                    @( ARREGION );
                end
                while ( ARREGION !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARREGION === 1 );
                    @( ARREGION );
                end
                while ( ARREGION !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARREGION_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARREGION>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARREGION_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARREGION[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARREGION[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARREGION[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARREGION[_this_dot_1] === 0 );
                    @( ARREGION[_this_dot_1] );
                end
                while ( ARREGION[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARREGION[_this_dot_1] === 1 );
                    @( ARREGION[_this_dot_1] );
                end
                while ( ARREGION[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARLEN
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARLEN>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARLEN( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARLEN);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARLEN);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARLEN);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARLEN === 0 );
                    @( ARLEN );
                end
                while ( ARLEN !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARLEN === 1 );
                    @( ARLEN );
                end
                while ( ARLEN !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARLEN_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARLEN[_this_dot_1] === 0 );
                    @( ARLEN[_this_dot_1] );
                end
                while ( ARLEN[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARLEN[_this_dot_1] === 1 );
                    @( ARLEN[_this_dot_1] );
                end
                while ( ARLEN[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARSIZE
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARSIZE>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARSIZE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARSIZE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARSIZE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARSIZE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARSIZE === 0 );
                    @( ARSIZE );
                end
                while ( ARSIZE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARSIZE === 1 );
                    @( ARSIZE );
                end
                while ( ARSIZE !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARSIZE_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARSIZE[_this_dot_1] === 0 );
                    @( ARSIZE[_this_dot_1] );
                end
                while ( ARSIZE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARSIZE[_this_dot_1] === 1 );
                    @( ARSIZE[_this_dot_1] );
                end
                while ( ARSIZE[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARBURST
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARBURST>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARBURST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARBURST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARBURST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARBURST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARBURST === 0 );
                    @( ARBURST );
                end
                while ( ARBURST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARBURST === 1 );
                    @( ARBURST );
                end
                while ( ARBURST !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARBURST_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARBURST[_this_dot_1] === 0 );
                    @( ARBURST[_this_dot_1] );
                end
                while ( ARBURST[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARBURST[_this_dot_1] === 1 );
                    @( ARBURST[_this_dot_1] );
                end
                while ( ARBURST[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARLOCK
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARLOCK>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARLOCK( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARLOCK);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARLOCK);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARLOCK);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARLOCK === 0 );
                    @( ARLOCK );
                end
                while ( ARLOCK !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARLOCK === 1 );
                    @( ARLOCK );
                end
                while ( ARLOCK !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARCACHE
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARCACHE>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARCACHE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARCACHE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARCACHE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARCACHE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARCACHE === 0 );
                    @( ARCACHE );
                end
                while ( ARCACHE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARCACHE === 1 );
                    @( ARCACHE );
                end
                while ( ARCACHE !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARCACHE_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARCACHE[_this_dot_1] === 0 );
                    @( ARCACHE[_this_dot_1] );
                end
                while ( ARCACHE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARCACHE[_this_dot_1] === 1 );
                    @( ARCACHE[_this_dot_1] );
                end
                while ( ARCACHE[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARQOS
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARQOS>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARQOS( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARQOS);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARQOS);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARQOS);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARQOS === 0 );
                    @( ARQOS );
                end
                while ( ARQOS !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARQOS === 1 );
                    @( ARQOS );
                end
                while ( ARQOS !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARQOS_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARQOS>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARQOS_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARQOS[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARQOS[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARQOS[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARQOS[_this_dot_1] === 0 );
                    @( ARQOS[_this_dot_1] );
                end
                while ( ARQOS[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARQOS[_this_dot_1] === 1 );
                    @( ARQOS[_this_dot_1] );
                end
                while ( ARQOS[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARID === 0 );
                    @( ARID );
                end
                while ( ARID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARID === 1 );
                    @( ARID );
                end
                while ( ARID !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARID_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARID[_this_dot_1] === 0 );
                    @( ARID[_this_dot_1] );
                end
                while ( ARID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARID[_this_dot_1] === 1 );
                    @( ARID[_this_dot_1] );
                end
                while ( ARID[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARUSER
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARUSER>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARUSER === 0 );
                    @( ARUSER );
                end
                while ( ARUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARUSER === 1 );
                    @( ARUSER );
                end
                while ( ARUSER !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARUSER_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARUSER[_this_dot_1] === 0 );
                    @( ARUSER[_this_dot_1] );
                end
                while ( ARUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARUSER[_this_dot_1] === 1 );
                    @( ARUSER[_this_dot_1] );
                end
                while ( ARUSER[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_ARREADY
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::ARREADY>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_ARREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARREADY === 0 );
                    @( ARREADY );
                end
                while ( ARREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARREADY === 1 );
                    @( ARREADY );
                end
                while ( ARREADY !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RVALID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RVALID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RVALID === 0 );
                    @( RVALID );
                end
                while ( RVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RVALID === 1 );
                    @( RVALID );
                end
                while ( RVALID !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RDATA
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RDATA>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RDATA( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RDATA);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RDATA);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RDATA);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RDATA === 0 );
                    @( RDATA );
                end
                while ( RDATA !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RDATA === 1 );
                    @( RDATA );
                end
                while ( RDATA !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RDATA_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RDATA[_this_dot_1] === 0 );
                    @( RDATA[_this_dot_1] );
                end
                while ( RDATA[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RDATA[_this_dot_1] === 1 );
                    @( RDATA[_this_dot_1] );
                end
                while ( RDATA[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RRESP
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RRESP>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RRESP( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RRESP);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RRESP);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RRESP);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RRESP === 0 );
                    @( RRESP );
                end
                while ( RRESP !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RRESP === 1 );
                    @( RRESP );
                end
                while ( RRESP !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RRESP_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RRESP[_this_dot_1] === 0 );
                    @( RRESP[_this_dot_1] );
                end
                while ( RRESP[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RRESP[_this_dot_1] === 1 );
                    @( RRESP[_this_dot_1] );
                end
                while ( RRESP[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RLAST
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RLAST>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RLAST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RLAST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RLAST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RLAST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RLAST === 0 );
                    @( RLAST );
                end
                while ( RLAST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RLAST === 1 );
                    @( RLAST );
                end
                while ( RLAST !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RID === 0 );
                    @( RID );
                end
                while ( RID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RID === 1 );
                    @( RID );
                end
                while ( RID !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RID_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RID[_this_dot_1] === 0 );
                    @( RID[_this_dot_1] );
                end
                while ( RID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RID[_this_dot_1] === 1 );
                    @( RID[_this_dot_1] );
                end
                while ( RID[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RUSER
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RUSER>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RUSER === 0 );
                    @( RUSER );
                end
                while ( RUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RUSER === 1 );
                    @( RUSER );
                end
                while ( RUSER !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RUSER_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RUSER[_this_dot_1] === 0 );
                    @( RUSER[_this_dot_1] );
                end
                while ( RUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RUSER[_this_dot_1] === 1 );
                    @( RUSER[_this_dot_1] );
                end
                while ( RUSER[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_RREADY
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::RREADY>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_RREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RREADY === 0 );
                    @( RREADY );
                end
                while ( RREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RREADY === 1 );
                    @( RREADY );
                end
                while ( RREADY !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_WVALID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::WVALID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_WVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WVALID === 0 );
                    @( WVALID );
                end
                while ( WVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WVALID === 1 );
                    @( WVALID );
                end
                while ( WVALID !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_WDATA
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::WDATA>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_WDATA( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WDATA);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WDATA);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WDATA);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WDATA === 0 );
                    @( WDATA );
                end
                while ( WDATA !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WDATA === 1 );
                    @( WDATA );
                end
                while ( WDATA !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_WDATA_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::WDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_WDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WDATA[_this_dot_1] === 0 );
                    @( WDATA[_this_dot_1] );
                end
                while ( WDATA[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WDATA[_this_dot_1] === 1 );
                    @( WDATA[_this_dot_1] );
                end
                while ( WDATA[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_WSTRB
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::WSTRB>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_WSTRB( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WSTRB);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WSTRB);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WSTRB);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WSTRB === 0 );
                    @( WSTRB );
                end
                while ( WSTRB !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WSTRB === 1 );
                    @( WSTRB );
                end
                while ( WSTRB !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_WSTRB_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::WSTRB>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_WSTRB_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WSTRB[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WSTRB[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WSTRB[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WSTRB[_this_dot_1] === 0 );
                    @( WSTRB[_this_dot_1] );
                end
                while ( WSTRB[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WSTRB[_this_dot_1] === 1 );
                    @( WSTRB[_this_dot_1] );
                end
                while ( WSTRB[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_WLAST
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::WLAST>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_WLAST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WLAST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WLAST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WLAST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WLAST === 0 );
                    @( WLAST );
                end
                while ( WLAST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WLAST === 1 );
                    @( WLAST );
                end
                while ( WLAST !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_WUSER
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::WUSER>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_WUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WUSER === 0 );
                    @( WUSER );
                end
                while ( WUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WUSER === 1 );
                    @( WUSER );
                end
                while ( WUSER !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_WUSER_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::WUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_WUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WUSER[_this_dot_1] === 0 );
                    @( WUSER[_this_dot_1] );
                end
                while ( WUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WUSER[_this_dot_1] === 1 );
                    @( WUSER[_this_dot_1] );
                end
                while ( WUSER[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_WREADY
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::WREADY>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_WREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WREADY === 0 );
                    @( WREADY );
                end
                while ( WREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WREADY === 1 );
                    @( WREADY );
                end
                while ( WREADY !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_BVALID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::BVALID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_BVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BVALID === 0 );
                    @( BVALID );
                end
                while ( BVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BVALID === 1 );
                    @( BVALID );
                end
                while ( BVALID !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_BRESP
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::BRESP>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_BRESP( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BRESP);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BRESP);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BRESP);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BRESP === 0 );
                    @( BRESP );
                end
                while ( BRESP !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BRESP === 1 );
                    @( BRESP );
                end
                while ( BRESP !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_BRESP_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::BRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_BRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BRESP[_this_dot_1] === 0 );
                    @( BRESP[_this_dot_1] );
                end
                while ( BRESP[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BRESP[_this_dot_1] === 1 );
                    @( BRESP[_this_dot_1] );
                end
                while ( BRESP[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_BID
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::BID>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_BID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BID === 0 );
                    @( BID );
                end
                while ( BID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BID === 1 );
                    @( BID );
                end
                while ( BID !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_BID_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::BID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_BID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BID[_this_dot_1] === 0 );
                    @( BID[_this_dot_1] );
                end
                while ( BID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BID[_this_dot_1] === 1 );
                    @( BID[_this_dot_1] );
                end
                while ( BID[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_BUSER
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::BUSER>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_BUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BUSER === 0 );
                    @( BUSER );
                end
                while ( BUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BUSER === 1 );
                    @( BUSER );
                end
                while ( BUSER !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_BUSER_index1
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::BUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_BUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BUSER[_this_dot_1] === 0 );
                    @( BUSER[_this_dot_1] );
                end
                while ( BUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BUSER[_this_dot_1] === 1 );
                    @( BUSER[_this_dot_1] );
                end
                while ( BUSER[_this_dot_1] !== 0 );
            end
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_BREADY
    //------------------------------------------------------------------------------
    //     Wait for the specified change on wire <axi4::BREADY>.
    //
    // Parameters:
    //     which_edge - The type of edge to wait for, one of <questa_mvc_edge>.
    //     count - The number of edges to wait for.
    //
    task automatic wait_for_BREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BREADY === 0 );
                    @( BREADY );
                end
                while ( BREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BREADY === 1 );
                    @( BREADY );
                end
                while ( BREADY !== 0 );
            end
        end
    endtask

    //------------------------------------------------------------------------------
    // Tasks/functions to set/get wires
    //------------------------------------------------------------------------------


    //------------------------------------------------------------------------------
    // Function:- set_ACLK
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ACLK>.
    //
    // Parameters:
    //     ACLK_param - The value to set onto wire <axi4::ACLK>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ACLK( logic ACLK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ACLK = ACLK_param;
        else
            m_ACLK <= ACLK_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ACLK
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ACLK>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ACLK>.
    //
    function automatic logic get_ACLK(  );
        return ACLK;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARESETn
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARESETn>.
    //
    // Parameters:
    //     ARESETn_param - The value to set onto wire <axi4::ARESETn>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARESETn( logic ARESETn_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARESETn = ARESETn_param;
        else
            m_ARESETn <= ARESETn_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARESETn
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARESETn>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARESETn>.
    //
    function automatic logic get_ARESETn(  );
        return ARESETn;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWVALID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWVALID>.
    //
    // Parameters:
    //     AWVALID_param - The value to set onto wire <axi4::AWVALID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWVALID( logic AWVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWVALID = AWVALID_param;
        else
            m_AWVALID <= AWVALID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWVALID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWVALID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWVALID>.
    //
    function automatic logic get_AWVALID(  );
        return AWVALID;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWADDR
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWADDR>.
    //
    // Parameters:
    //     AWADDR_param - The value to set onto wire <axi4::AWADDR>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWADDR( logic [((AXI4_ADDRESS_WIDTH) - 1):0]  AWADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWADDR = AWADDR_param;
        else
            m_AWADDR <= AWADDR_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_AWADDR_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::AWADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWADDR_param - The value to set onto wire <axi4::AWADDR>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWADDR_index1( int _this_dot_1, logic  AWADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWADDR[_this_dot_1] = AWADDR_param;
        else
            m_AWADDR[_this_dot_1] <= AWADDR_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWADDR
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWADDR>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWADDR>.
    //
    function automatic logic [((AXI4_ADDRESS_WIDTH) - 1):0]   get_AWADDR(  );
        return AWADDR;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_AWADDR_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::AWADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::AWADDR>.
    //
    function automatic logic   get_AWADDR_index1( int _this_dot_1 );
        return AWADDR[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWPROT
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWPROT>.
    //
    // Parameters:
    //     AWPROT_param - The value to set onto wire <axi4::AWPROT>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWPROT( logic [2:0] AWPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWPROT = AWPROT_param;
        else
            m_AWPROT <= AWPROT_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_AWPROT_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::AWPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWPROT_param - The value to set onto wire <axi4::AWPROT>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWPROT_index1( int _this_dot_1, logic  AWPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWPROT[_this_dot_1] = AWPROT_param;
        else
            m_AWPROT[_this_dot_1] <= AWPROT_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWPROT
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWPROT>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWPROT>.
    //
    function automatic logic [2:0]  get_AWPROT(  );
        return AWPROT;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_AWPROT_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::AWPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::AWPROT>.
    //
    function automatic logic   get_AWPROT_index1( int _this_dot_1 );
        return AWPROT[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWREGION
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWREGION>.
    //
    // Parameters:
    //     AWREGION_param - The value to set onto wire <axi4::AWREGION>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWREGION( logic [3:0] AWREGION_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWREGION = AWREGION_param;
        else
            m_AWREGION <= AWREGION_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_AWREGION_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::AWREGION>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWREGION_param - The value to set onto wire <axi4::AWREGION>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWREGION_index1( int _this_dot_1, logic  AWREGION_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWREGION[_this_dot_1] = AWREGION_param;
        else
            m_AWREGION[_this_dot_1] <= AWREGION_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWREGION
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWREGION>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWREGION>.
    //
    function automatic logic [3:0]  get_AWREGION(  );
        return AWREGION;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_AWREGION_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::AWREGION>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::AWREGION>.
    //
    function automatic logic   get_AWREGION_index1( int _this_dot_1 );
        return AWREGION[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWLEN
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWLEN>.
    //
    // Parameters:
    //     AWLEN_param - The value to set onto wire <axi4::AWLEN>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWLEN( logic [7:0] AWLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWLEN = AWLEN_param;
        else
            m_AWLEN <= AWLEN_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_AWLEN_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::AWLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWLEN_param - The value to set onto wire <axi4::AWLEN>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWLEN_index1( int _this_dot_1, logic  AWLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWLEN[_this_dot_1] = AWLEN_param;
        else
            m_AWLEN[_this_dot_1] <= AWLEN_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWLEN
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWLEN>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWLEN>.
    //
    function automatic logic [7:0]  get_AWLEN(  );
        return AWLEN;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_AWLEN_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::AWLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::AWLEN>.
    //
    function automatic logic   get_AWLEN_index1( int _this_dot_1 );
        return AWLEN[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWSIZE
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWSIZE>.
    //
    // Parameters:
    //     AWSIZE_param - The value to set onto wire <axi4::AWSIZE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWSIZE( logic [2:0] AWSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWSIZE = AWSIZE_param;
        else
            m_AWSIZE <= AWSIZE_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_AWSIZE_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::AWSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWSIZE_param - The value to set onto wire <axi4::AWSIZE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWSIZE_index1( int _this_dot_1, logic  AWSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWSIZE[_this_dot_1] = AWSIZE_param;
        else
            m_AWSIZE[_this_dot_1] <= AWSIZE_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWSIZE
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWSIZE>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWSIZE>.
    //
    function automatic logic [2:0]  get_AWSIZE(  );
        return AWSIZE;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_AWSIZE_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::AWSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::AWSIZE>.
    //
    function automatic logic   get_AWSIZE_index1( int _this_dot_1 );
        return AWSIZE[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWBURST
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWBURST>.
    //
    // Parameters:
    //     AWBURST_param - The value to set onto wire <axi4::AWBURST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWBURST( logic [1:0] AWBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWBURST = AWBURST_param;
        else
            m_AWBURST <= AWBURST_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_AWBURST_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::AWBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWBURST_param - The value to set onto wire <axi4::AWBURST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWBURST_index1( int _this_dot_1, logic  AWBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWBURST[_this_dot_1] = AWBURST_param;
        else
            m_AWBURST[_this_dot_1] <= AWBURST_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWBURST
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWBURST>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWBURST>.
    //
    function automatic logic [1:0]  get_AWBURST(  );
        return AWBURST;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_AWBURST_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::AWBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::AWBURST>.
    //
    function automatic logic   get_AWBURST_index1( int _this_dot_1 );
        return AWBURST[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWLOCK
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWLOCK>.
    //
    // Parameters:
    //     AWLOCK_param - The value to set onto wire <axi4::AWLOCK>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWLOCK( logic AWLOCK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWLOCK = AWLOCK_param;
        else
            m_AWLOCK <= AWLOCK_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWLOCK
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWLOCK>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWLOCK>.
    //
    function automatic logic get_AWLOCK(  );
        return AWLOCK;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWCACHE
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWCACHE>.
    //
    // Parameters:
    //     AWCACHE_param - The value to set onto wire <axi4::AWCACHE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWCACHE( logic [3:0] AWCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWCACHE = AWCACHE_param;
        else
            m_AWCACHE <= AWCACHE_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_AWCACHE_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::AWCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWCACHE_param - The value to set onto wire <axi4::AWCACHE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWCACHE_index1( int _this_dot_1, logic  AWCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWCACHE[_this_dot_1] = AWCACHE_param;
        else
            m_AWCACHE[_this_dot_1] <= AWCACHE_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWCACHE
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWCACHE>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWCACHE>.
    //
    function automatic logic [3:0]  get_AWCACHE(  );
        return AWCACHE;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_AWCACHE_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::AWCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::AWCACHE>.
    //
    function automatic logic   get_AWCACHE_index1( int _this_dot_1 );
        return AWCACHE[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWQOS
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWQOS>.
    //
    // Parameters:
    //     AWQOS_param - The value to set onto wire <axi4::AWQOS>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWQOS( logic [3:0] AWQOS_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWQOS = AWQOS_param;
        else
            m_AWQOS <= AWQOS_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_AWQOS_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::AWQOS>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWQOS_param - The value to set onto wire <axi4::AWQOS>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWQOS_index1( int _this_dot_1, logic  AWQOS_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWQOS[_this_dot_1] = AWQOS_param;
        else
            m_AWQOS[_this_dot_1] <= AWQOS_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWQOS
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWQOS>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWQOS>.
    //
    function automatic logic [3:0]  get_AWQOS(  );
        return AWQOS;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_AWQOS_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::AWQOS>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::AWQOS>.
    //
    function automatic logic   get_AWQOS_index1( int _this_dot_1 );
        return AWQOS[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWID>.
    //
    // Parameters:
    //     AWID_param - The value to set onto wire <axi4::AWID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWID( logic [((AXI4_ID_WIDTH) - 1):0]  AWID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWID = AWID_param;
        else
            m_AWID <= AWID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_AWID_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::AWID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWID_param - The value to set onto wire <axi4::AWID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWID_index1( int _this_dot_1, logic  AWID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWID[_this_dot_1] = AWID_param;
        else
            m_AWID[_this_dot_1] <= AWID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWID>.
    //
    function automatic logic [((AXI4_ID_WIDTH) - 1):0]   get_AWID(  );
        return AWID;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_AWID_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::AWID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::AWID>.
    //
    function automatic logic   get_AWID_index1( int _this_dot_1 );
        return AWID[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWUSER
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWUSER>.
    //
    // Parameters:
    //     AWUSER_param - The value to set onto wire <axi4::AWUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWUSER( logic [((AXI4_USER_WIDTH) - 1):0]  AWUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWUSER = AWUSER_param;
        else
            m_AWUSER <= AWUSER_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_AWUSER_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::AWUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     AWUSER_param - The value to set onto wire <axi4::AWUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWUSER_index1( int _this_dot_1, logic  AWUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWUSER[_this_dot_1] = AWUSER_param;
        else
            m_AWUSER[_this_dot_1] <= AWUSER_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWUSER
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWUSER>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWUSER>.
    //
    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   get_AWUSER(  );
        return AWUSER;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_AWUSER_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::AWUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::AWUSER>.
    //
    function automatic logic   get_AWUSER_index1( int _this_dot_1 );
        return AWUSER[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_AWREADY
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::AWREADY>.
    //
    // Parameters:
    //     AWREADY_param - The value to set onto wire <axi4::AWREADY>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_AWREADY( logic AWREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWREADY = AWREADY_param;
        else
            m_AWREADY <= AWREADY_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_AWREADY
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::AWREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::AWREADY>.
    //
    function automatic logic get_AWREADY(  );
        return AWREADY;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARVALID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARVALID>.
    //
    // Parameters:
    //     ARVALID_param - The value to set onto wire <axi4::ARVALID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARVALID( logic ARVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARVALID = ARVALID_param;
        else
            m_ARVALID <= ARVALID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARVALID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARVALID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARVALID>.
    //
    function automatic logic get_ARVALID(  );
        return ARVALID;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARADDR
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARADDR>.
    //
    // Parameters:
    //     ARADDR_param - The value to set onto wire <axi4::ARADDR>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARADDR( logic [((AXI4_ADDRESS_WIDTH) - 1):0]  ARADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARADDR = ARADDR_param;
        else
            m_ARADDR <= ARADDR_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_ARADDR_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::ARADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARADDR_param - The value to set onto wire <axi4::ARADDR>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARADDR_index1( int _this_dot_1, logic  ARADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARADDR[_this_dot_1] = ARADDR_param;
        else
            m_ARADDR[_this_dot_1] <= ARADDR_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARADDR
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARADDR>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARADDR>.
    //
    function automatic logic [((AXI4_ADDRESS_WIDTH) - 1):0]   get_ARADDR(  );
        return ARADDR;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_ARADDR_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::ARADDR>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::ARADDR>.
    //
    function automatic logic   get_ARADDR_index1( int _this_dot_1 );
        return ARADDR[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARPROT
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARPROT>.
    //
    // Parameters:
    //     ARPROT_param - The value to set onto wire <axi4::ARPROT>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARPROT( logic [2:0] ARPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARPROT = ARPROT_param;
        else
            m_ARPROT <= ARPROT_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_ARPROT_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::ARPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARPROT_param - The value to set onto wire <axi4::ARPROT>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARPROT_index1( int _this_dot_1, logic  ARPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARPROT[_this_dot_1] = ARPROT_param;
        else
            m_ARPROT[_this_dot_1] <= ARPROT_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARPROT
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARPROT>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARPROT>.
    //
    function automatic logic [2:0]  get_ARPROT(  );
        return ARPROT;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_ARPROT_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::ARPROT>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::ARPROT>.
    //
    function automatic logic   get_ARPROT_index1( int _this_dot_1 );
        return ARPROT[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARREGION
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARREGION>.
    //
    // Parameters:
    //     ARREGION_param - The value to set onto wire <axi4::ARREGION>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARREGION( logic [3:0] ARREGION_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARREGION = ARREGION_param;
        else
            m_ARREGION <= ARREGION_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_ARREGION_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::ARREGION>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARREGION_param - The value to set onto wire <axi4::ARREGION>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARREGION_index1( int _this_dot_1, logic  ARREGION_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARREGION[_this_dot_1] = ARREGION_param;
        else
            m_ARREGION[_this_dot_1] <= ARREGION_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARREGION
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARREGION>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARREGION>.
    //
    function automatic logic [3:0]  get_ARREGION(  );
        return ARREGION;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_ARREGION_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::ARREGION>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::ARREGION>.
    //
    function automatic logic   get_ARREGION_index1( int _this_dot_1 );
        return ARREGION[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARLEN
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARLEN>.
    //
    // Parameters:
    //     ARLEN_param - The value to set onto wire <axi4::ARLEN>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARLEN( logic [7:0] ARLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARLEN = ARLEN_param;
        else
            m_ARLEN <= ARLEN_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_ARLEN_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::ARLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARLEN_param - The value to set onto wire <axi4::ARLEN>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARLEN_index1( int _this_dot_1, logic  ARLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARLEN[_this_dot_1] = ARLEN_param;
        else
            m_ARLEN[_this_dot_1] <= ARLEN_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARLEN
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARLEN>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARLEN>.
    //
    function automatic logic [7:0]  get_ARLEN(  );
        return ARLEN;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_ARLEN_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::ARLEN>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::ARLEN>.
    //
    function automatic logic   get_ARLEN_index1( int _this_dot_1 );
        return ARLEN[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARSIZE
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARSIZE>.
    //
    // Parameters:
    //     ARSIZE_param - The value to set onto wire <axi4::ARSIZE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARSIZE( logic [2:0] ARSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARSIZE = ARSIZE_param;
        else
            m_ARSIZE <= ARSIZE_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_ARSIZE_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::ARSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARSIZE_param - The value to set onto wire <axi4::ARSIZE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARSIZE_index1( int _this_dot_1, logic  ARSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARSIZE[_this_dot_1] = ARSIZE_param;
        else
            m_ARSIZE[_this_dot_1] <= ARSIZE_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARSIZE
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARSIZE>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARSIZE>.
    //
    function automatic logic [2:0]  get_ARSIZE(  );
        return ARSIZE;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_ARSIZE_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::ARSIZE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::ARSIZE>.
    //
    function automatic logic   get_ARSIZE_index1( int _this_dot_1 );
        return ARSIZE[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARBURST
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARBURST>.
    //
    // Parameters:
    //     ARBURST_param - The value to set onto wire <axi4::ARBURST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARBURST( logic [1:0] ARBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARBURST = ARBURST_param;
        else
            m_ARBURST <= ARBURST_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_ARBURST_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::ARBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARBURST_param - The value to set onto wire <axi4::ARBURST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARBURST_index1( int _this_dot_1, logic  ARBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARBURST[_this_dot_1] = ARBURST_param;
        else
            m_ARBURST[_this_dot_1] <= ARBURST_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARBURST
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARBURST>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARBURST>.
    //
    function automatic logic [1:0]  get_ARBURST(  );
        return ARBURST;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_ARBURST_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::ARBURST>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::ARBURST>.
    //
    function automatic logic   get_ARBURST_index1( int _this_dot_1 );
        return ARBURST[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARLOCK
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARLOCK>.
    //
    // Parameters:
    //     ARLOCK_param - The value to set onto wire <axi4::ARLOCK>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARLOCK( logic ARLOCK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARLOCK = ARLOCK_param;
        else
            m_ARLOCK <= ARLOCK_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARLOCK
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARLOCK>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARLOCK>.
    //
    function automatic logic get_ARLOCK(  );
        return ARLOCK;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARCACHE
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARCACHE>.
    //
    // Parameters:
    //     ARCACHE_param - The value to set onto wire <axi4::ARCACHE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARCACHE( logic [3:0] ARCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARCACHE = ARCACHE_param;
        else
            m_ARCACHE <= ARCACHE_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_ARCACHE_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::ARCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARCACHE_param - The value to set onto wire <axi4::ARCACHE>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARCACHE_index1( int _this_dot_1, logic  ARCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARCACHE[_this_dot_1] = ARCACHE_param;
        else
            m_ARCACHE[_this_dot_1] <= ARCACHE_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARCACHE
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARCACHE>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARCACHE>.
    //
    function automatic logic [3:0]  get_ARCACHE(  );
        return ARCACHE;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_ARCACHE_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::ARCACHE>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::ARCACHE>.
    //
    function automatic logic   get_ARCACHE_index1( int _this_dot_1 );
        return ARCACHE[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARQOS
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARQOS>.
    //
    // Parameters:
    //     ARQOS_param - The value to set onto wire <axi4::ARQOS>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARQOS( logic [3:0] ARQOS_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARQOS = ARQOS_param;
        else
            m_ARQOS <= ARQOS_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_ARQOS_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::ARQOS>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARQOS_param - The value to set onto wire <axi4::ARQOS>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARQOS_index1( int _this_dot_1, logic  ARQOS_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARQOS[_this_dot_1] = ARQOS_param;
        else
            m_ARQOS[_this_dot_1] <= ARQOS_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARQOS
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARQOS>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARQOS>.
    //
    function automatic logic [3:0]  get_ARQOS(  );
        return ARQOS;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_ARQOS_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::ARQOS>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::ARQOS>.
    //
    function automatic logic   get_ARQOS_index1( int _this_dot_1 );
        return ARQOS[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARID>.
    //
    // Parameters:
    //     ARID_param - The value to set onto wire <axi4::ARID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARID( logic [((AXI4_ID_WIDTH) - 1):0]  ARID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARID = ARID_param;
        else
            m_ARID <= ARID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_ARID_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::ARID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARID_param - The value to set onto wire <axi4::ARID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARID_index1( int _this_dot_1, logic  ARID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARID[_this_dot_1] = ARID_param;
        else
            m_ARID[_this_dot_1] <= ARID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARID>.
    //
    function automatic logic [((AXI4_ID_WIDTH) - 1):0]   get_ARID(  );
        return ARID;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_ARID_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::ARID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::ARID>.
    //
    function automatic logic   get_ARID_index1( int _this_dot_1 );
        return ARID[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARUSER
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARUSER>.
    //
    // Parameters:
    //     ARUSER_param - The value to set onto wire <axi4::ARUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARUSER( logic [((AXI4_USER_WIDTH) - 1):0]  ARUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARUSER = ARUSER_param;
        else
            m_ARUSER <= ARUSER_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_ARUSER_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::ARUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     ARUSER_param - The value to set onto wire <axi4::ARUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARUSER_index1( int _this_dot_1, logic  ARUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARUSER[_this_dot_1] = ARUSER_param;
        else
            m_ARUSER[_this_dot_1] <= ARUSER_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARUSER
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARUSER>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARUSER>.
    //
    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   get_ARUSER(  );
        return ARUSER;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_ARUSER_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::ARUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::ARUSER>.
    //
    function automatic logic   get_ARUSER_index1( int _this_dot_1 );
        return ARUSER[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_ARREADY
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::ARREADY>.
    //
    // Parameters:
    //     ARREADY_param - The value to set onto wire <axi4::ARREADY>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_ARREADY( logic ARREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARREADY = ARREADY_param;
        else
            m_ARREADY <= ARREADY_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_ARREADY
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::ARREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::ARREADY>.
    //
    function automatic logic get_ARREADY(  );
        return ARREADY;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_RVALID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::RVALID>.
    //
    // Parameters:
    //     RVALID_param - The value to set onto wire <axi4::RVALID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RVALID( logic RVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RVALID = RVALID_param;
        else
            m_RVALID <= RVALID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_RVALID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::RVALID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::RVALID>.
    //
    function automatic logic get_RVALID(  );
        return RVALID;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_RDATA
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::RDATA>.
    //
    // Parameters:
    //     RDATA_param - The value to set onto wire <axi4::RDATA>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RDATA( logic [((AXI4_RDATA_WIDTH) - 1):0]  RDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RDATA = RDATA_param;
        else
            m_RDATA <= RDATA_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_RDATA_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::RDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     RDATA_param - The value to set onto wire <axi4::RDATA>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RDATA_index1( int _this_dot_1, logic  RDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RDATA[_this_dot_1] = RDATA_param;
        else
            m_RDATA[_this_dot_1] <= RDATA_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_RDATA
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::RDATA>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::RDATA>.
    //
    function automatic logic [((AXI4_RDATA_WIDTH) - 1):0]   get_RDATA(  );
        return RDATA;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_RDATA_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::RDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::RDATA>.
    //
    function automatic logic   get_RDATA_index1( int _this_dot_1 );
        return RDATA[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_RRESP
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::RRESP>.
    //
    // Parameters:
    //     RRESP_param - The value to set onto wire <axi4::RRESP>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RRESP( logic [1:0] RRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RRESP = RRESP_param;
        else
            m_RRESP <= RRESP_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_RRESP_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::RRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     RRESP_param - The value to set onto wire <axi4::RRESP>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RRESP_index1( int _this_dot_1, logic  RRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RRESP[_this_dot_1] = RRESP_param;
        else
            m_RRESP[_this_dot_1] <= RRESP_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_RRESP
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::RRESP>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::RRESP>.
    //
    function automatic logic [1:0]  get_RRESP(  );
        return RRESP;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_RRESP_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::RRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::RRESP>.
    //
    function automatic logic   get_RRESP_index1( int _this_dot_1 );
        return RRESP[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_RLAST
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::RLAST>.
    //
    // Parameters:
    //     RLAST_param - The value to set onto wire <axi4::RLAST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RLAST( logic RLAST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RLAST = RLAST_param;
        else
            m_RLAST <= RLAST_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_RLAST
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::RLAST>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::RLAST>.
    //
    function automatic logic get_RLAST(  );
        return RLAST;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_RID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::RID>.
    //
    // Parameters:
    //     RID_param - The value to set onto wire <axi4::RID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RID( logic [((AXI4_ID_WIDTH) - 1):0]  RID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RID = RID_param;
        else
            m_RID <= RID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_RID_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::RID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     RID_param - The value to set onto wire <axi4::RID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RID_index1( int _this_dot_1, logic  RID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RID[_this_dot_1] = RID_param;
        else
            m_RID[_this_dot_1] <= RID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_RID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::RID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::RID>.
    //
    function automatic logic [((AXI4_ID_WIDTH) - 1):0]   get_RID(  );
        return RID;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_RID_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::RID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::RID>.
    //
    function automatic logic   get_RID_index1( int _this_dot_1 );
        return RID[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_RUSER
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::RUSER>.
    //
    // Parameters:
    //     RUSER_param - The value to set onto wire <axi4::RUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RUSER( logic [((AXI4_USER_WIDTH) - 1):0]  RUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RUSER = RUSER_param;
        else
            m_RUSER <= RUSER_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_RUSER_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::RUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     RUSER_param - The value to set onto wire <axi4::RUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RUSER_index1( int _this_dot_1, logic  RUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RUSER[_this_dot_1] = RUSER_param;
        else
            m_RUSER[_this_dot_1] <= RUSER_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_RUSER
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::RUSER>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::RUSER>.
    //
    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   get_RUSER(  );
        return RUSER;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_RUSER_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::RUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::RUSER>.
    //
    function automatic logic   get_RUSER_index1( int _this_dot_1 );
        return RUSER[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_RREADY
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::RREADY>.
    //
    // Parameters:
    //     RREADY_param - The value to set onto wire <axi4::RREADY>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_RREADY( logic RREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RREADY = RREADY_param;
        else
            m_RREADY <= RREADY_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_RREADY
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::RREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::RREADY>.
    //
    function automatic logic get_RREADY(  );
        return RREADY;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_WVALID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::WVALID>.
    //
    // Parameters:
    //     WVALID_param - The value to set onto wire <axi4::WVALID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_WVALID( logic WVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WVALID = WVALID_param;
        else
            m_WVALID <= WVALID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_WVALID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::WVALID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::WVALID>.
    //
    function automatic logic get_WVALID(  );
        return WVALID;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_WDATA
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::WDATA>.
    //
    // Parameters:
    //     WDATA_param - The value to set onto wire <axi4::WDATA>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_WDATA( logic [((AXI4_WDATA_WIDTH) - 1):0]  WDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WDATA = WDATA_param;
        else
            m_WDATA <= WDATA_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_WDATA_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::WDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     WDATA_param - The value to set onto wire <axi4::WDATA>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_WDATA_index1( int _this_dot_1, logic  WDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WDATA[_this_dot_1] = WDATA_param;
        else
            m_WDATA[_this_dot_1] <= WDATA_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_WDATA
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::WDATA>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::WDATA>.
    //
    function automatic logic [((AXI4_WDATA_WIDTH) - 1):0]   get_WDATA(  );
        return WDATA;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_WDATA_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::WDATA>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::WDATA>.
    //
    function automatic logic   get_WDATA_index1( int _this_dot_1 );
        return WDATA[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_WSTRB
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::WSTRB>.
    //
    // Parameters:
    //     WSTRB_param - The value to set onto wire <axi4::WSTRB>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_WSTRB( logic [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  WSTRB_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WSTRB = WSTRB_param;
        else
            m_WSTRB <= WSTRB_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_WSTRB_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::WSTRB>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     WSTRB_param - The value to set onto wire <axi4::WSTRB>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_WSTRB_index1( int _this_dot_1, logic  WSTRB_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WSTRB[_this_dot_1] = WSTRB_param;
        else
            m_WSTRB[_this_dot_1] <= WSTRB_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_WSTRB
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::WSTRB>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::WSTRB>.
    //
    function automatic logic [(((AXI4_WDATA_WIDTH / 8)) - 1):0]   get_WSTRB(  );
        return WSTRB;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_WSTRB_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::WSTRB>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::WSTRB>.
    //
    function automatic logic   get_WSTRB_index1( int _this_dot_1 );
        return WSTRB[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_WLAST
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::WLAST>.
    //
    // Parameters:
    //     WLAST_param - The value to set onto wire <axi4::WLAST>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_WLAST( logic WLAST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WLAST = WLAST_param;
        else
            m_WLAST <= WLAST_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_WLAST
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::WLAST>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::WLAST>.
    //
    function automatic logic get_WLAST(  );
        return WLAST;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_WUSER
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::WUSER>.
    //
    // Parameters:
    //     WUSER_param - The value to set onto wire <axi4::WUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_WUSER( logic [((AXI4_USER_WIDTH) - 1):0]  WUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WUSER = WUSER_param;
        else
            m_WUSER <= WUSER_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_WUSER_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::WUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     WUSER_param - The value to set onto wire <axi4::WUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_WUSER_index1( int _this_dot_1, logic  WUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WUSER[_this_dot_1] = WUSER_param;
        else
            m_WUSER[_this_dot_1] <= WUSER_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_WUSER
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::WUSER>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::WUSER>.
    //
    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   get_WUSER(  );
        return WUSER;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_WUSER_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::WUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::WUSER>.
    //
    function automatic logic   get_WUSER_index1( int _this_dot_1 );
        return WUSER[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_WREADY
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::WREADY>.
    //
    // Parameters:
    //     WREADY_param - The value to set onto wire <axi4::WREADY>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_WREADY( logic WREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WREADY = WREADY_param;
        else
            m_WREADY <= WREADY_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_WREADY
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::WREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::WREADY>.
    //
    function automatic logic get_WREADY(  );
        return WREADY;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_BVALID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::BVALID>.
    //
    // Parameters:
    //     BVALID_param - The value to set onto wire <axi4::BVALID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_BVALID( logic BVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BVALID = BVALID_param;
        else
            m_BVALID <= BVALID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_BVALID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::BVALID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::BVALID>.
    //
    function automatic logic get_BVALID(  );
        return BVALID;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_BRESP
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::BRESP>.
    //
    // Parameters:
    //     BRESP_param - The value to set onto wire <axi4::BRESP>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_BRESP( logic [1:0] BRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BRESP = BRESP_param;
        else
            m_BRESP <= BRESP_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_BRESP_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::BRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     BRESP_param - The value to set onto wire <axi4::BRESP>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_BRESP_index1( int _this_dot_1, logic  BRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BRESP[_this_dot_1] = BRESP_param;
        else
            m_BRESP[_this_dot_1] <= BRESP_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_BRESP
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::BRESP>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::BRESP>.
    //
    function automatic logic [1:0]  get_BRESP(  );
        return BRESP;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_BRESP_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::BRESP>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::BRESP>.
    //
    function automatic logic   get_BRESP_index1( int _this_dot_1 );
        return BRESP[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_BID
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::BID>.
    //
    // Parameters:
    //     BID_param - The value to set onto wire <axi4::BID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_BID( logic [((AXI4_ID_WIDTH) - 1):0]  BID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BID = BID_param;
        else
            m_BID <= BID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_BID_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::BID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     BID_param - The value to set onto wire <axi4::BID>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_BID_index1( int _this_dot_1, logic  BID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BID[_this_dot_1] = BID_param;
        else
            m_BID[_this_dot_1] <= BID_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_BID
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::BID>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::BID>.
    //
    function automatic logic [((AXI4_ID_WIDTH) - 1):0]   get_BID(  );
        return BID;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_BID_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::BID>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::BID>.
    //
    function automatic logic   get_BID_index1( int _this_dot_1 );
        return BID[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_BUSER
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::BUSER>.
    //
    // Parameters:
    //     BUSER_param - The value to set onto wire <axi4::BUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_BUSER( logic [((AXI4_USER_WIDTH) - 1):0]  BUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BUSER = BUSER_param;
        else
            m_BUSER <= BUSER_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- set_BUSER_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of wire <axi4::BUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     BUSER_param - The value to set onto wire <axi4::BUSER>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_BUSER_index1( int _this_dot_1, logic  BUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BUSER[_this_dot_1] = BUSER_param;
        else
            m_BUSER[_this_dot_1] <= BUSER_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_BUSER
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::BUSER>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::BUSER>.
    //
    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   get_BUSER(  );
        return BUSER;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_BUSER_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of wire <axi4::BUSER>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the wire <axi4::BUSER>.
    //
    function automatic logic   get_BUSER_index1( int _this_dot_1 );
        return BUSER[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_BREADY
    //------------------------------------------------------------------------------
    //     Set the value of wire <axi4::BREADY>.
    //
    // Parameters:
    //     BREADY_param - The value to set onto wire <axi4::BREADY>.
    //     non_blocking - Set to 1 for a non-blocking assignment.
    //
    task automatic set_BREADY( logic BREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BREADY = BREADY_param;
        else
            m_BREADY <= BREADY_param;
    endtask


    //------------------------------------------------------------------------------
    // Function:- get_BREADY
    //------------------------------------------------------------------------------
    //     Get the value of wire <axi4::BREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the wire <axi4::BREADY>.
    //
    function automatic logic get_BREADY(  );
        return BREADY;
    endfunction

    //------------------------------------------------------------------------------
    // Tasks to wait for a change to a global variable with read access
    //------------------------------------------------------------------------------


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_interface_type
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_interface_type>.
    //
    task automatic wait_for_config_interface_type(  );
        begin
            @( config_interface_type );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_clk_init_value
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_clk_init_value>.
    //
    task automatic wait_for_config_clk_init_value(  );
        begin
            @( config_clk_init_value );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_clk_phase_shift
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_clk_phase_shift>.
    //
    task automatic wait_for_config_clk_phase_shift(  );
        begin
            @( config_clk_phase_shift );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_clk_1st_time
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_clk_1st_time>.
    //
    task automatic wait_for_config_clk_1st_time(  );
        begin
            @( config_clk_1st_time );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_clk_2nd_time
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_clk_2nd_time>.
    //
    task automatic wait_for_config_clk_2nd_time(  );
        begin
            @( config_clk_2nd_time );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_setup_time
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_setup_time>.
    //
    task automatic wait_for_config_setup_time(  );
        begin
            @( config_setup_time );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_hold_time
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_hold_time>.
    //
    task automatic wait_for_config_hold_time(  );
        begin
            @( config_hold_time );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_burst_timeout_factor
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_burst_timeout_factor>.
    //
    task automatic wait_for_config_burst_timeout_factor(  );
        begin
            @( config_burst_timeout_factor );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_transaction_time_factor
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_max_transaction_time_factor>.
    //
    task automatic wait_for_config_max_transaction_time_factor(  );
        begin
            @( config_max_transaction_time_factor );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_write_ctrl_first_ratio
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_write_ctrl_first_ratio>.
    //
    task automatic wait_for_config_write_ctrl_first_ratio(  );
        begin
            @( config_write_ctrl_first_ratio );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_write_data_first_ratio
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_write_data_first_ratio>.
    //
    task automatic wait_for_config_write_data_first_ratio(  );
        begin
            @( config_write_data_first_ratio );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_reset_low_clocks
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_reset_low_clocks>.
    //
    task automatic wait_for_config_reset_low_clocks(  );
        begin
            @( config_reset_low_clocks );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_reset_hold_time
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_reset_hold_time>.
    //
    task automatic wait_for_config_reset_hold_time(  );
        begin
            @( config_reset_hold_time );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_rlast
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_rlast>.
    //
    task automatic wait_for_config_enable_rlast(  );
        begin
            @( config_enable_rlast );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_slave_exclusive
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_slave_exclusive>.
    //
    task automatic wait_for_config_enable_slave_exclusive(  );
        begin
            @( config_enable_slave_exclusive );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_burst_reserved_value
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_burst_reserved_value>.
    //
    task automatic wait_for_config_enable_burst_reserved_value(  );
        begin
            @( config_enable_burst_reserved_value );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_cache_value
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_cache_value>.
    //
    task automatic wait_for_config_enable_cache_value(  );
        begin
            @( config_enable_cache_value );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_cache_value_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_cache_value>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_config_enable_cache_value_index1( input int _this_dot_1 );
        begin
            @( config_enable_cache_value[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_internal_dummy_variable
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::internal_dummy_variable>.
    //
    task automatic wait_for_internal_dummy_variable(  );
        begin
            @( internal_dummy_variable );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_axi4lite_interface
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_axi4lite_interface>.
    //
    task automatic wait_for_config_axi4lite_interface(  );
        begin
            @( config_axi4lite_interface );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_axi4lite_tr_id
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_axi4lite_tr_id>.
    //
    task automatic wait_for_config_axi4lite_tr_id(  );
        begin
            @( config_axi4lite_tr_id );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_axi4lite_tr_id_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_axi4lite_tr_id>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_config_axi4lite_tr_id_index1( input int _this_dot_1 );
        begin
            @( config_axi4lite_tr_id[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_all_assertions
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_all_assertions>.
    //
    task automatic wait_for_config_enable_all_assertions(  );
        begin
            @( config_enable_all_assertions );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_assertion
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_assertion>.
    //
    task automatic wait_for_config_enable_assertion(  );
        begin
            @( config_enable_assertion );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_assertion_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_assertion>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_config_enable_assertion_index1( input int _this_dot_1 );
        begin
            @( config_enable_assertion[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_error
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_error>.
    //
    task automatic wait_for_config_enable_error(  );
        begin
            @( config_enable_error );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_error_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_error>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_config_enable_error_index1( input int _this_dot_1 );
        begin
            @( config_enable_error[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_latency_AWVALID_assertion_to_AWREADY
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_max_latency_AWVALID_assertion_to_AWREADY>.
    //
    task automatic wait_for_config_max_latency_AWVALID_assertion_to_AWREADY(  );
        begin
            @( config_max_latency_AWVALID_assertion_to_AWREADY );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_latency_ARVALID_assertion_to_ARREADY
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_max_latency_ARVALID_assertion_to_ARREADY>.
    //
    task automatic wait_for_config_max_latency_ARVALID_assertion_to_ARREADY(  );
        begin
            @( config_max_latency_ARVALID_assertion_to_ARREADY );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_latency_RVALID_assertion_to_RREADY
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_max_latency_RVALID_assertion_to_RREADY>.
    //
    task automatic wait_for_config_max_latency_RVALID_assertion_to_RREADY(  );
        begin
            @( config_max_latency_RVALID_assertion_to_RREADY );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_latency_BVALID_assertion_to_BREADY
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_max_latency_BVALID_assertion_to_BREADY>.
    //
    task automatic wait_for_config_max_latency_BVALID_assertion_to_BREADY(  );
        begin
            @( config_max_latency_BVALID_assertion_to_BREADY );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_latency_WVALID_assertion_to_WREADY
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_max_latency_WVALID_assertion_to_WREADY>.
    //
    task automatic wait_for_config_max_latency_WVALID_assertion_to_WREADY(  );
        begin
            @( config_max_latency_WVALID_assertion_to_WREADY );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_qos
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_qos>.
    //
    task automatic wait_for_config_enable_qos(  );
        begin
            @( config_enable_qos );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_region_support
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_region_support>.
    //
    task automatic wait_for_config_enable_region_support(  );
        begin
            @( config_enable_region_support );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_regions
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_regions>.
    //
    task automatic wait_for_config_slave_regions(  );
        begin
            @( config_slave_regions );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_region
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_region>.
    //
    task automatic wait_for_config_region(  );
        begin
            @( config_region );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_region_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_region>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_config_region_index1( input int _this_dot_1 );
        begin
            @( config_region[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_region_index2
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_region>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //    _this_dot_2 - The array index for dimension 2.
    //
    task automatic wait_for_config_region_index2( input int _this_dot_1, input int _this_dot_2 );
        begin
            @( config_region[_this_dot_1][_this_dot_2] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_region_error_state
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::region_error_state>.
    //
    task automatic wait_for_region_error_state(  );
        begin
            @( region_error_state );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_region_map_lb
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::region_map_lb>.
    //
    task automatic wait_for_region_map_lb(  );
        begin
        longint unsigned _temp_region_map_lb [((AXI4_REGION_MAP_SIZE) - 1):0];
            @( * ) _temp_region_map_lb = region_map_lb;
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_region_map_lb_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::region_map_lb>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_region_map_lb_index1( input int _this_dot_1 );
        begin
            @( region_map_lb[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_region_map_ub
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::region_map_ub>.
    //
    task automatic wait_for_region_map_ub(  );
        begin
        longint unsigned _temp_region_map_ub [((AXI4_REGION_MAP_SIZE) - 1):0];
            @( * ) _temp_region_map_ub = region_map_ub;
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_region_map_ub_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::region_map_ub>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_region_map_ub_index1( input int _this_dot_1 );
        begin
            @( region_map_ub[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_region_map_region
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::region_map_region>.
    //
    task automatic wait_for_region_map_region(  );
        begin
        byte unsigned _temp_region_map_region [((AXI4_REGION_MAP_SIZE) - 1):0];
            @( * ) _temp_region_map_region = region_map_region;
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_region_map_region_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::region_map_region>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_region_map_region_index1( input int _this_dot_1 );
        begin
            @( region_map_region[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_cacheable
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::cacheable>.
    //
    task automatic wait_for_cacheable(  );
        begin
        byte unsigned _temp_cacheable [((AXI4_REGION_MAP_SIZE) - 1):0];
            @( * ) _temp_cacheable = cacheable;
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_cacheable_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::cacheable>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_cacheable_index1( input int _this_dot_1 );
        begin
            @( cacheable[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_read_data_reordering_depth
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_read_data_reordering_depth>.
    //
    task automatic wait_for_config_read_data_reordering_depth(  );
        begin
            @( config_read_data_reordering_depth );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_start_addr
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_start_addr>.
    //
    task automatic wait_for_config_slave_start_addr(  );
        begin
            @( config_slave_start_addr );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_start_addr_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_start_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_config_slave_start_addr_index1( input int _this_dot_1 );
        begin
            @( config_slave_start_addr[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_end_addr
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_end_addr>.
    //
    task automatic wait_for_config_slave_end_addr(  );
        begin
            @( config_slave_end_addr );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_end_addr_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_end_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_config_slave_end_addr_index1( input int _this_dot_1 );
        begin
            @( config_slave_end_addr[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_enabled_non_contiguous_address_spaces
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_enabled_non_contiguous_address_spaces>.
    //
    task automatic wait_for_config_slave_enabled_non_contiguous_address_spaces(  );
        begin
            @( config_slave_enabled_non_contiguous_address_spaces );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_possess_multiple_non_contiguous_address_spaces
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_possess_multiple_non_contiguous_address_spaces>.
    //
    task automatic wait_for_config_slave_possess_multiple_non_contiguous_address_spaces(  );
        begin
            @( config_slave_possess_multiple_non_contiguous_address_spaces );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_multiple_non_contiguous_start_address_range
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    task automatic wait_for_config_slave_multiple_non_contiguous_start_address_range(  );
        begin
            @( config_slave_multiple_non_contiguous_start_address_range );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_multiple_non_contiguous_start_address_range_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_config_slave_multiple_non_contiguous_start_address_range_index1( input int _this_dot_1 );
        begin
            @( config_slave_multiple_non_contiguous_start_address_range[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_multiple_non_contiguous_start_address_range_index2
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //    _this_dot_2 - The array index for dimension 2.
    //
    task automatic wait_for_config_slave_multiple_non_contiguous_start_address_range_index2( input int _this_dot_1, input int _this_dot_2 );
        begin
            @( config_slave_multiple_non_contiguous_start_address_range[_this_dot_1][_this_dot_2] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_multiple_non_contiguous_end_address_range
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    task automatic wait_for_config_slave_multiple_non_contiguous_end_address_range(  );
        begin
            @( config_slave_multiple_non_contiguous_end_address_range );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_multiple_non_contiguous_end_address_range_index1
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    task automatic wait_for_config_slave_multiple_non_contiguous_end_address_range_index1( input int _this_dot_1 );
        begin
            @( config_slave_multiple_non_contiguous_end_address_range[_this_dot_1] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_slave_multiple_non_contiguous_end_address_range_index2
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //    _this_dot_2 - The array index for dimension 2.
    //
    task automatic wait_for_config_slave_multiple_non_contiguous_end_address_range_index2( input int _this_dot_1, input int _this_dot_2 );
        begin
            @( config_slave_multiple_non_contiguous_end_address_range[_this_dot_1][_this_dot_2] );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_protect_ready
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_protect_ready>.
    //
    task automatic wait_for_config_protect_ready(  );
        begin
            @( config_protect_ready );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_master_end_tlm_status
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::master_end_tlm_status>.
    //
    task automatic wait_for_master_end_tlm_status(  );
        begin
            @( master_end_tlm_status );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_master_end_wlm_status
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::master_end_wlm_status>.
    //
    task automatic wait_for_master_end_wlm_status(  );
        begin
            @( master_end_wlm_status );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_slave_end_tlm_status
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::slave_end_tlm_status>.
    //
    task automatic wait_for_slave_end_tlm_status(  );
        begin
            @( slave_end_tlm_status );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_slave_end_wlm_status
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::slave_end_wlm_status>.
    //
    task automatic wait_for_slave_end_wlm_status(  );
        begin
            @( slave_end_wlm_status );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_clock_source_end_tlm_status
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::clock_source_end_tlm_status>.
    //
    task automatic wait_for_clock_source_end_tlm_status(  );
        begin
            @( clock_source_end_tlm_status );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_clock_source_end_wlm_status
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::clock_source_end_wlm_status>.
    //
    task automatic wait_for_clock_source_end_wlm_status(  );
        begin
            @( clock_source_end_wlm_status );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_reset_source_end_tlm_status
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::reset_source_end_tlm_status>.
    //
    task automatic wait_for_reset_source_end_tlm_status(  );
        begin
            @( reset_source_end_tlm_status );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_reset_source_end_wlm_status
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::reset_source_end_wlm_status>.
    //
    task automatic wait_for_reset_source_end_wlm_status(  );
        begin
            @( reset_source_end_wlm_status );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_outstanding_wr
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_max_outstanding_wr>.
    //
    task automatic wait_for_config_max_outstanding_wr(  );
        begin
            @( config_max_outstanding_wr );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_max_outstanding_rd
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_max_outstanding_rd>.
    //
    task automatic wait_for_config_max_outstanding_rd(  );
        begin
            @( config_max_outstanding_rd );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_num_outstanding_wr_phase
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_num_outstanding_wr_phase>.
    //
    task automatic wait_for_config_num_outstanding_wr_phase(  );
        begin
            @( config_num_outstanding_wr_phase );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_num_outstanding_rd_phase
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_num_outstanding_rd_phase>.
    //
    task automatic wait_for_config_num_outstanding_rd_phase(  );
        begin
            @( config_num_outstanding_rd_phase );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_warnings
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_warnings>.
    //
    task automatic wait_for_config_enable_warnings(  );
        begin
            @( config_enable_warnings );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_errors
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_errors>.
    //
    task automatic wait_for_config_enable_errors(  );
        begin
            @( config_enable_errors );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_enable_exclusive_checks
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_enable_exclusive_checks>.
    //
    task automatic wait_for_config_enable_exclusive_checks(  );
        begin
            @( config_enable_exclusive_checks );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_warn_on_slave_errors
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_warn_on_slave_errors>.
    //
    task automatic wait_for_config_warn_on_slave_errors(  );
        begin
            @( config_warn_on_slave_errors );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_error_on_deleted_valid_cycles
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_error_on_deleted_valid_cycles>.
    //
    task automatic wait_for_config_error_on_deleted_valid_cycles(  );
        begin
            @( config_error_on_deleted_valid_cycles );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable>.
    //
    task automatic wait_for_config_stats_enable(  );
        begin
            @( config_stats_enable );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_occupancy
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_read_occupancy>.
    //
    task automatic wait_for_config_stats_enable_read_occupancy(  );
        begin
            @( config_stats_enable_read_occupancy );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_occupancy
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_write_occupancy>.
    //
    task automatic wait_for_config_stats_enable_write_occupancy(  );
        begin
            @( config_stats_enable_write_occupancy );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_data_occupancy
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_read_data_occupancy>.
    //
    task automatic wait_for_config_stats_enable_read_data_occupancy(  );
        begin
            @( config_stats_enable_read_data_occupancy );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_data_occupancy
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_write_data_occupancy>.
    //
    task automatic wait_for_config_stats_enable_write_data_occupancy(  );
        begin
            @( config_stats_enable_write_data_occupancy );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_latency
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_read_latency>.
    //
    task automatic wait_for_config_stats_enable_read_latency(  );
        begin
            @( config_stats_enable_read_latency );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_latency
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_write_latency>.
    //
    task automatic wait_for_config_stats_enable_write_latency(  );
        begin
            @( config_stats_enable_write_latency );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_address_waits
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_read_address_waits>.
    //
    task automatic wait_for_config_stats_enable_read_address_waits(  );
        begin
            @( config_stats_enable_read_address_waits );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_data_waits
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_read_data_waits>.
    //
    task automatic wait_for_config_stats_enable_read_data_waits(  );
        begin
            @( config_stats_enable_read_data_waits );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_address_waits
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_write_address_waits>.
    //
    task automatic wait_for_config_stats_enable_write_address_waits(  );
        begin
            @( config_stats_enable_write_address_waits );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_data_waits
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_write_data_waits>.
    //
    task automatic wait_for_config_stats_enable_write_data_waits(  );
        begin
            @( config_stats_enable_write_data_waits );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_response_waits
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_write_response_waits>.
    //
    task automatic wait_for_config_stats_enable_write_response_waits(  );
        begin
            @( config_stats_enable_write_response_waits );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_read_bandwidth
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_read_bandwidth>.
    //
    task automatic wait_for_config_stats_enable_read_bandwidth(  );
        begin
            @( config_stats_enable_read_bandwidth );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_enable_write_bandwidth
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_enable_write_bandwidth>.
    //
    task automatic wait_for_config_stats_enable_write_bandwidth(  );
        begin
            @( config_stats_enable_write_bandwidth );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_rw_transaction_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_rw_transaction_last_duration>.
    //
    task automatic wait_for_stats_rw_transaction_last_duration(  );
        begin
            @( stats_rw_transaction_last_duration );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_occupancy_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_occupancy_step>.
    //
    task automatic wait_for_config_stats_read_occupancy_step(  );
        begin
            @( config_stats_read_occupancy_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_occupancy_multiple>.
    //
    task automatic wait_for_config_stats_read_occupancy_multiple(  );
        begin
            @( config_stats_read_occupancy_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_active
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_active>.
    //
    task automatic wait_for_stats_read_active(  );
        begin
            @( stats_read_active );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_occupancy_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_occupancy_sw>.
    //
    task automatic wait_for_stats_read_occupancy_sw(  );
        begin
            @( stats_read_occupancy_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_idle_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_idle_sw>.
    //
    task automatic wait_for_stats_read_idle_sw(  );
        begin
            @( stats_read_idle_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_occupancy_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_occupancy_min>.
    //
    task automatic wait_for_stats_read_occupancy_min(  );
        begin
            @( stats_read_occupancy_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_idle_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_idle_min>.
    //
    task automatic wait_for_stats_read_idle_min(  );
        begin
            @( stats_read_idle_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_occupancy_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_occupancy_max>.
    //
    task automatic wait_for_stats_read_occupancy_max(  );
        begin
            @( stats_read_occupancy_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_idle_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_idle_max>.
    //
    task automatic wait_for_stats_read_idle_max(  );
        begin
            @( stats_read_idle_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_occupancy_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_occupancy_mean>.
    //
    task automatic wait_for_stats_read_occupancy_mean(  );
        begin
            @( stats_read_occupancy_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_idle_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_idle_mean>.
    //
    task automatic wait_for_stats_read_idle_mean(  );
        begin
            @( stats_read_idle_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_last_duration>.
    //
    task automatic wait_for_stats_read_last_duration(  );
        begin
            @( stats_read_last_duration );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_occupancy_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_occupancy_step>.
    //
    task automatic wait_for_config_stats_write_occupancy_step(  );
        begin
            @( config_stats_write_occupancy_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_occupancy_multiple>.
    //
    task automatic wait_for_config_stats_write_occupancy_multiple(  );
        begin
            @( config_stats_write_occupancy_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_active
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_active>.
    //
    task automatic wait_for_stats_write_active(  );
        begin
            @( stats_write_active );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_occupancy_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_occupancy_sw>.
    //
    task automatic wait_for_stats_write_occupancy_sw(  );
        begin
            @( stats_write_occupancy_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_idle_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_idle_sw>.
    //
    task automatic wait_for_stats_write_idle_sw(  );
        begin
            @( stats_write_idle_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_occupancy_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_occupancy_min>.
    //
    task automatic wait_for_stats_write_occupancy_min(  );
        begin
            @( stats_write_occupancy_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_idle_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_idle_min>.
    //
    task automatic wait_for_stats_write_idle_min(  );
        begin
            @( stats_write_idle_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_occupancy_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_occupancy_max>.
    //
    task automatic wait_for_stats_write_occupancy_max(  );
        begin
            @( stats_write_occupancy_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_idle_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_idle_max>.
    //
    task automatic wait_for_stats_write_idle_max(  );
        begin
            @( stats_write_idle_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_occupancy_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_occupancy_mean>.
    //
    task automatic wait_for_stats_write_occupancy_mean(  );
        begin
            @( stats_write_occupancy_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_idle_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_idle_mean>.
    //
    task automatic wait_for_stats_write_idle_mean(  );
        begin
            @( stats_write_idle_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_last_duration
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_last_duration>.
    //
    task automatic wait_for_stats_write_last_duration(  );
        begin
            @( stats_write_last_duration );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_data_occupancy_step>.
    //
    task automatic wait_for_config_stats_read_data_occupancy_step(  );
        begin
            @( config_stats_read_data_occupancy_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_data_occupancy_multiple>.
    //
    task automatic wait_for_config_stats_read_data_occupancy_multiple(  );
        begin
            @( config_stats_read_data_occupancy_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_occupancy_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_occupancy_sw>.
    //
    task automatic wait_for_stats_read_data_occupancy_sw(  );
        begin
            @( stats_read_data_occupancy_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_idle_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_idle_sw>.
    //
    task automatic wait_for_stats_read_data_idle_sw(  );
        begin
            @( stats_read_data_idle_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_occupancy_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_occupancy_min>.
    //
    task automatic wait_for_stats_read_data_occupancy_min(  );
        begin
            @( stats_read_data_occupancy_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_idle_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_idle_min>.
    //
    task automatic wait_for_stats_read_data_idle_min(  );
        begin
            @( stats_read_data_idle_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_occupancy_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_occupancy_max>.
    //
    task automatic wait_for_stats_read_data_occupancy_max(  );
        begin
            @( stats_read_data_occupancy_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_idle_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_idle_max>.
    //
    task automatic wait_for_stats_read_data_idle_max(  );
        begin
            @( stats_read_data_idle_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_occupancy_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_occupancy_mean>.
    //
    task automatic wait_for_stats_read_data_occupancy_mean(  );
        begin
            @( stats_read_data_occupancy_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_idle_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_idle_mean>.
    //
    task automatic wait_for_stats_read_data_idle_mean(  );
        begin
            @( stats_read_data_idle_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_data_occupancy_step>.
    //
    task automatic wait_for_config_stats_write_data_occupancy_step(  );
        begin
            @( config_stats_write_data_occupancy_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_data_occupancy_multiple>.
    //
    task automatic wait_for_config_stats_write_data_occupancy_multiple(  );
        begin
            @( config_stats_write_data_occupancy_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_occupancy_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_occupancy_sw>.
    //
    task automatic wait_for_stats_write_data_occupancy_sw(  );
        begin
            @( stats_write_data_occupancy_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_idle_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_idle_sw>.
    //
    task automatic wait_for_stats_write_data_idle_sw(  );
        begin
            @( stats_write_data_idle_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_occupancy_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_occupancy_min>.
    //
    task automatic wait_for_stats_write_data_occupancy_min(  );
        begin
            @( stats_write_data_occupancy_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_idle_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_idle_min>.
    //
    task automatic wait_for_stats_write_data_idle_min(  );
        begin
            @( stats_write_data_idle_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_occupancy_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_occupancy_max>.
    //
    task automatic wait_for_stats_write_data_occupancy_max(  );
        begin
            @( stats_write_data_occupancy_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_idle_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_idle_max>.
    //
    task automatic wait_for_stats_write_data_idle_max(  );
        begin
            @( stats_write_data_idle_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_occupancy_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_occupancy_mean>.
    //
    task automatic wait_for_stats_write_data_occupancy_mean(  );
        begin
            @( stats_write_data_occupancy_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_idle_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_idle_mean>.
    //
    task automatic wait_for_stats_write_data_idle_mean(  );
        begin
            @( stats_write_data_idle_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_bandwidth_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_bandwidth_step>.
    //
    task automatic wait_for_config_stats_read_bandwidth_step(  );
        begin
            @( config_stats_read_bandwidth_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_bandwidth_multiple>.
    //
    task automatic wait_for_config_stats_read_bandwidth_multiple(  );
        begin
            @( config_stats_read_bandwidth_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_bandwidth_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_bandwidth_sw>.
    //
    task automatic wait_for_stats_read_bandwidth_sw(  );
        begin
            @( stats_read_bandwidth_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_bandwidth_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_bandwidth_min>.
    //
    task automatic wait_for_stats_read_bandwidth_min(  );
        begin
            @( stats_read_bandwidth_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_bandwidth_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_bandwidth_max>.
    //
    task automatic wait_for_stats_read_bandwidth_max(  );
        begin
            @( stats_read_bandwidth_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_bandwidth_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_bandwidth_mean>.
    //
    task automatic wait_for_stats_read_bandwidth_mean(  );
        begin
            @( stats_read_bandwidth_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_bandwidth_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_bandwidth_step>.
    //
    task automatic wait_for_config_stats_write_bandwidth_step(  );
        begin
            @( config_stats_write_bandwidth_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_bandwidth_multiple>.
    //
    task automatic wait_for_config_stats_write_bandwidth_multiple(  );
        begin
            @( config_stats_write_bandwidth_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_bandwidth_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_bandwidth_sw>.
    //
    task automatic wait_for_stats_write_bandwidth_sw(  );
        begin
            @( stats_write_bandwidth_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_bandwidth_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_bandwidth_min>.
    //
    task automatic wait_for_stats_write_bandwidth_min(  );
        begin
            @( stats_write_bandwidth_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_bandwidth_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_bandwidth_max>.
    //
    task automatic wait_for_stats_write_bandwidth_max(  );
        begin
            @( stats_write_bandwidth_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_bandwidth_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_bandwidth_mean>.
    //
    task automatic wait_for_stats_write_bandwidth_mean(  );
        begin
            @( stats_write_bandwidth_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_latency_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_latency_step>.
    //
    task automatic wait_for_config_stats_read_latency_step(  );
        begin
            @( config_stats_read_latency_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_latency_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_latency_multiple>.
    //
    task automatic wait_for_config_stats_read_latency_multiple(  );
        begin
            @( config_stats_read_latency_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_data_latency_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_data_latency_inst>.
    //
    task automatic wait_for_stats_read_address_data_latency_inst(  );
        begin
            @( stats_read_address_data_latency_inst );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_data_latency_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_data_latency_sw>.
    //
    task automatic wait_for_stats_read_address_data_latency_sw(  );
        begin
            @( stats_read_address_data_latency_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_data_latency_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_data_latency_min>.
    //
    task automatic wait_for_stats_read_address_data_latency_min(  );
        begin
            @( stats_read_address_data_latency_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_data_latency_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_data_latency_max>.
    //
    task automatic wait_for_stats_read_address_data_latency_max(  );
        begin
            @( stats_read_address_data_latency_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_data_latency_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_data_latency_mean>.
    //
    task automatic wait_for_stats_read_address_data_latency_mean(  );
        begin
            @( stats_read_address_data_latency_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_address_latency_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_address_latency_inst>.
    //
    task automatic wait_for_stats_read_address_address_latency_inst(  );
        begin
            @( stats_read_address_address_latency_inst );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_address_latency_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_address_latency_sw>.
    //
    task automatic wait_for_stats_read_address_address_latency_sw(  );
        begin
            @( stats_read_address_address_latency_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_address_latency_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_address_latency_min>.
    //
    task automatic wait_for_stats_read_address_address_latency_min(  );
        begin
            @( stats_read_address_address_latency_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_address_latency_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_address_latency_max>.
    //
    task automatic wait_for_stats_read_address_address_latency_max(  );
        begin
            @( stats_read_address_address_latency_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_address_latency_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_address_latency_mean>.
    //
    task automatic wait_for_stats_read_address_address_latency_mean(  );
        begin
            @( stats_read_address_address_latency_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_latency_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_latency_step>.
    //
    task automatic wait_for_config_stats_write_latency_step(  );
        begin
            @( config_stats_write_latency_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_latency_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_latency_multiple>.
    //
    task automatic wait_for_config_stats_write_latency_multiple(  );
        begin
            @( config_stats_write_latency_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_response_latency_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_response_latency_inst>.
    //
    task automatic wait_for_stats_write_address_response_latency_inst(  );
        begin
            @( stats_write_address_response_latency_inst );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_response_latency_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_response_latency_sw>.
    //
    task automatic wait_for_stats_write_address_response_latency_sw(  );
        begin
            @( stats_write_address_response_latency_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_response_latency_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_response_latency_min>.
    //
    task automatic wait_for_stats_write_address_response_latency_min(  );
        begin
            @( stats_write_address_response_latency_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_response_latency_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_response_latency_max>.
    //
    task automatic wait_for_stats_write_address_response_latency_max(  );
        begin
            @( stats_write_address_response_latency_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_response_latency_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_response_latency_mean>.
    //
    task automatic wait_for_stats_write_address_response_latency_mean(  );
        begin
            @( stats_write_address_response_latency_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_address_latency_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_address_latency_inst>.
    //
    task automatic wait_for_stats_write_address_address_latency_inst(  );
        begin
            @( stats_write_address_address_latency_inst );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_address_latency_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_address_latency_sw>.
    //
    task automatic wait_for_stats_write_address_address_latency_sw(  );
        begin
            @( stats_write_address_address_latency_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_address_latency_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_address_latency_min>.
    //
    task automatic wait_for_stats_write_address_address_latency_min(  );
        begin
            @( stats_write_address_address_latency_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_address_latency_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_address_latency_max>.
    //
    task automatic wait_for_stats_write_address_address_latency_max(  );
        begin
            @( stats_write_address_address_latency_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_address_latency_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_address_latency_mean>.
    //
    task automatic wait_for_stats_write_address_address_latency_mean(  );
        begin
            @( stats_write_address_address_latency_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_address_waits_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_address_waits_step>.
    //
    task automatic wait_for_config_stats_read_address_waits_step(  );
        begin
            @( config_stats_read_address_waits_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_address_waits_multiple>.
    //
    task automatic wait_for_config_stats_read_address_waits_multiple(  );
        begin
            @( config_stats_read_address_waits_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_waits_inst>.
    //
    task automatic wait_for_stats_read_address_waits_inst(  );
        begin
            @( stats_read_address_waits_inst );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_waits_sw>.
    //
    task automatic wait_for_stats_read_address_waits_sw(  );
        begin
            @( stats_read_address_waits_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_waits_min>.
    //
    task automatic wait_for_stats_read_address_waits_min(  );
        begin
            @( stats_read_address_waits_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_waits_max>.
    //
    task automatic wait_for_stats_read_address_waits_max(  );
        begin
            @( stats_read_address_waits_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_address_waits_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_address_waits_mean>.
    //
    task automatic wait_for_stats_read_address_waits_mean(  );
        begin
            @( stats_read_address_waits_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_data_waits_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_data_waits_step>.
    //
    task automatic wait_for_config_stats_read_data_waits_step(  );
        begin
            @( config_stats_read_data_waits_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_read_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_read_data_waits_multiple>.
    //
    task automatic wait_for_config_stats_read_data_waits_multiple(  );
        begin
            @( config_stats_read_data_waits_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_waits_inst>.
    //
    task automatic wait_for_stats_read_data_waits_inst(  );
        begin
            @( stats_read_data_waits_inst );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_waits_sw>.
    //
    task automatic wait_for_stats_read_data_waits_sw(  );
        begin
            @( stats_read_data_waits_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_waits_min>.
    //
    task automatic wait_for_stats_read_data_waits_min(  );
        begin
            @( stats_read_data_waits_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_waits_max>.
    //
    task automatic wait_for_stats_read_data_waits_max(  );
        begin
            @( stats_read_data_waits_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_read_data_waits_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_read_data_waits_mean>.
    //
    task automatic wait_for_stats_read_data_waits_mean(  );
        begin
            @( stats_read_data_waits_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_address_waits_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_address_waits_step>.
    //
    task automatic wait_for_config_stats_write_address_waits_step(  );
        begin
            @( config_stats_write_address_waits_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_address_waits_multiple>.
    //
    task automatic wait_for_config_stats_write_address_waits_multiple(  );
        begin
            @( config_stats_write_address_waits_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_waits_inst>.
    //
    task automatic wait_for_stats_write_address_waits_inst(  );
        begin
            @( stats_write_address_waits_inst );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_waits_sw>.
    //
    task automatic wait_for_stats_write_address_waits_sw(  );
        begin
            @( stats_write_address_waits_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_waits_min>.
    //
    task automatic wait_for_stats_write_address_waits_min(  );
        begin
            @( stats_write_address_waits_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_waits_max>.
    //
    task automatic wait_for_stats_write_address_waits_max(  );
        begin
            @( stats_write_address_waits_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_address_waits_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_address_waits_mean>.
    //
    task automatic wait_for_stats_write_address_waits_mean(  );
        begin
            @( stats_write_address_waits_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_data_waits_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_data_waits_step>.
    //
    task automatic wait_for_config_stats_write_data_waits_step(  );
        begin
            @( config_stats_write_data_waits_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_data_waits_multiple>.
    //
    task automatic wait_for_config_stats_write_data_waits_multiple(  );
        begin
            @( config_stats_write_data_waits_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_waits_inst>.
    //
    task automatic wait_for_stats_write_data_waits_inst(  );
        begin
            @( stats_write_data_waits_inst );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_waits_sw>.
    //
    task automatic wait_for_stats_write_data_waits_sw(  );
        begin
            @( stats_write_data_waits_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_waits_min>.
    //
    task automatic wait_for_stats_write_data_waits_min(  );
        begin
            @( stats_write_data_waits_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_waits_max>.
    //
    task automatic wait_for_stats_write_data_waits_max(  );
        begin
            @( stats_write_data_waits_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_data_waits_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_data_waits_mean>.
    //
    task automatic wait_for_stats_write_data_waits_mean(  );
        begin
            @( stats_write_data_waits_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_response_waits_step
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_response_waits_step>.
    //
    task automatic wait_for_config_stats_write_response_waits_step(  );
        begin
            @( config_stats_write_response_waits_step );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_config_stats_write_response_waits_multiple
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::config_stats_write_response_waits_multiple>.
    //
    task automatic wait_for_config_stats_write_response_waits_multiple(  );
        begin
            @( config_stats_write_response_waits_multiple );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_inst
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_response_waits_inst>.
    //
    task automatic wait_for_stats_write_response_waits_inst(  );
        begin
            @( stats_write_response_waits_inst );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_sw
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_response_waits_sw>.
    //
    task automatic wait_for_stats_write_response_waits_sw(  );
        begin
            @( stats_write_response_waits_sw );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_min
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_response_waits_min>.
    //
    task automatic wait_for_stats_write_response_waits_min(  );
        begin
            @( stats_write_response_waits_min );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_max
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_response_waits_max>.
    //
    task automatic wait_for_stats_write_response_waits_max(  );
        begin
            @( stats_write_response_waits_max );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_stats_write_response_waits_mean
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::stats_write_response_waits_mean>.
    //
    task automatic wait_for_stats_write_response_waits_mean(  );
        begin
            @( stats_write_response_waits_mean );
        end
    endtask


    //------------------------------------------------------------------------------
    // Function:- wait_for_reordering_depth_of_last_read_transaction
    //------------------------------------------------------------------------------
    //     Wait for a change on variable <axi4::reordering_depth_of_last_read_transaction>.
    //
    task automatic wait_for_reordering_depth_of_last_read_transaction(  );
        begin
            @( reordering_depth_of_last_read_transaction );
        end
    endtask


    //------------------------------------------------------------------------------
    // Functions to set global variables with write access
    //------------------------------------------------------------------------------


    //------------------------------------------------------------------------------
    // Function:- set_config_interface_type
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_interface_type>.
    //
    // Parameters:
    //     config_interface_type_param - The value to assign to variable <axi4::config_interface_type>.
    //
    function automatic void set_config_interface_type( axi4_interface_type_e config_interface_type_param );
        config_interface_type = config_interface_type_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_clk_init_value
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_clk_init_value>.
    //
    // Parameters:
    //     config_clk_init_value_param - The value to assign to variable <axi4::config_clk_init_value>.
    //
    function automatic void set_config_clk_init_value( bit config_clk_init_value_param );
        config_clk_init_value = config_clk_init_value_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_clk_phase_shift
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_clk_phase_shift>.
    //
    // Parameters:
    //     config_clk_phase_shift_param - The value to assign to variable <axi4::config_clk_phase_shift>.
    //
    function automatic void set_config_clk_phase_shift( longint unsigned config_clk_phase_shift_param );
        config_clk_phase_shift = config_clk_phase_shift_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_clk_1st_time
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_clk_1st_time>.
    //
    // Parameters:
    //     config_clk_1st_time_param - The value to assign to variable <axi4::config_clk_1st_time>.
    //
    function automatic void set_config_clk_1st_time( longint unsigned config_clk_1st_time_param );
        config_clk_1st_time = config_clk_1st_time_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_clk_2nd_time
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_clk_2nd_time>.
    //
    // Parameters:
    //     config_clk_2nd_time_param - The value to assign to variable <axi4::config_clk_2nd_time>.
    //
    function automatic void set_config_clk_2nd_time( longint unsigned config_clk_2nd_time_param );
        config_clk_2nd_time = config_clk_2nd_time_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_setup_time
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_setup_time>.
    //
    // Parameters:
    //     config_setup_time_param - The value to assign to variable <axi4::config_setup_time>.
    //
    function automatic void set_config_setup_time( longint unsigned config_setup_time_param );
        config_setup_time = config_setup_time_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_hold_time
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_hold_time>.
    //
    // Parameters:
    //     config_hold_time_param - The value to assign to variable <axi4::config_hold_time>.
    //
    function automatic void set_config_hold_time( longint unsigned config_hold_time_param );
        config_hold_time = config_hold_time_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_burst_timeout_factor
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_burst_timeout_factor>.
    //
    // Parameters:
    //     config_burst_timeout_factor_param - The value to assign to variable <axi4::config_burst_timeout_factor>.
    //
    function automatic void set_config_burst_timeout_factor( int unsigned config_burst_timeout_factor_param );
        config_burst_timeout_factor = config_burst_timeout_factor_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_max_transaction_time_factor
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_max_transaction_time_factor>.
    //
    // Parameters:
    //     config_max_transaction_time_factor_param - The value to assign to variable <axi4::config_max_transaction_time_factor>.
    //
    function automatic void set_config_max_transaction_time_factor( int unsigned config_max_transaction_time_factor_param );
        config_max_transaction_time_factor = config_max_transaction_time_factor_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_write_ctrl_first_ratio
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_write_ctrl_first_ratio>.
    //
    // Parameters:
    //     config_write_ctrl_first_ratio_param - The value to assign to variable <axi4::config_write_ctrl_first_ratio>.
    //
    function automatic void set_config_write_ctrl_first_ratio( int config_write_ctrl_first_ratio_param );
        config_write_ctrl_first_ratio = config_write_ctrl_first_ratio_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_write_data_first_ratio
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_write_data_first_ratio>.
    //
    // Parameters:
    //     config_write_data_first_ratio_param - The value to assign to variable <axi4::config_write_data_first_ratio>.
    //
    function automatic void set_config_write_data_first_ratio( int config_write_data_first_ratio_param );
        config_write_data_first_ratio = config_write_data_first_ratio_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_reset_low_clocks
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_reset_low_clocks>.
    //
    // Parameters:
    //     config_reset_low_clocks_param - The value to assign to variable <axi4::config_reset_low_clocks>.
    //
    function automatic void set_config_reset_low_clocks( int config_reset_low_clocks_param );
        config_reset_low_clocks = config_reset_low_clocks_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_reset_hold_time
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_reset_hold_time>.
    //
    // Parameters:
    //     config_reset_hold_time_param - The value to assign to variable <axi4::config_reset_hold_time>.
    //
    function automatic void set_config_reset_hold_time( int config_reset_hold_time_param );
        config_reset_hold_time = config_reset_hold_time_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_rlast
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_rlast>.
    //
    // Parameters:
    //     config_enable_rlast_param - The value to assign to variable <axi4::config_enable_rlast>.
    //
    function automatic void set_config_enable_rlast( bit config_enable_rlast_param );
        config_enable_rlast = config_enable_rlast_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_slave_exclusive
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_slave_exclusive>.
    //
    // Parameters:
    //     config_enable_slave_exclusive_param - The value to assign to variable <axi4::config_enable_slave_exclusive>.
    //
    function automatic void set_config_enable_slave_exclusive( bit config_enable_slave_exclusive_param );
        config_enable_slave_exclusive = config_enable_slave_exclusive_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_burst_reserved_value
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_burst_reserved_value>.
    //
    // Parameters:
    //     config_enable_burst_reserved_value_param - The value to assign to variable <axi4::config_enable_burst_reserved_value>.
    //
    function automatic void set_config_enable_burst_reserved_value( bit config_enable_burst_reserved_value_param );
        config_enable_burst_reserved_value = config_enable_burst_reserved_value_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_cache_value
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_cache_value>.
    //
    // Parameters:
    //     config_enable_cache_value_param - The value to assign to variable <axi4::config_enable_cache_value>.
    //
    function automatic void set_config_enable_cache_value( bit [15:0] config_enable_cache_value_param );
        config_enable_cache_value = config_enable_cache_value_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_cache_value_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_enable_cache_value>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_enable_cache_value_param - The value to assign to variable <axi4::config_enable_cache_value>.
    //
    function automatic void set_config_enable_cache_value_index1( int _this_dot_1, bit  config_enable_cache_value_param );
        config_enable_cache_value[_this_dot_1] = config_enable_cache_value_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_internal_dummy_variable
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::internal_dummy_variable>.
    //
    // Parameters:
    //     internal_dummy_variable_param - The value to assign to variable <axi4::internal_dummy_variable>.
    //
    function automatic void set_internal_dummy_variable( axi4_error_e internal_dummy_variable_param );
        internal_dummy_variable = internal_dummy_variable_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_axi4lite_interface
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_axi4lite_interface>.
    //
    // Parameters:
    //     config_axi4lite_interface_param - The value to assign to variable <axi4::config_axi4lite_interface>.
    //
    function automatic void set_config_axi4lite_interface( bit config_axi4lite_interface_param );
        config_axi4lite_interface = config_axi4lite_interface_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_axi4lite_tr_id
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_axi4lite_tr_id>.
    //
    // Parameters:
    //     config_axi4lite_tr_id_param - The value to assign to variable <axi4::config_axi4lite_tr_id>.
    //
    function automatic void set_config_axi4lite_tr_id( bit [((AXI4_ID_WIDTH) - 1):0]  config_axi4lite_tr_id_param );
        config_axi4lite_tr_id = config_axi4lite_tr_id_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_axi4lite_tr_id_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_axi4lite_tr_id>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_axi4lite_tr_id_param - The value to assign to variable <axi4::config_axi4lite_tr_id>.
    //
    function automatic void set_config_axi4lite_tr_id_index1( int _this_dot_1, bit  config_axi4lite_tr_id_param );
        config_axi4lite_tr_id[_this_dot_1] = config_axi4lite_tr_id_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_all_assertions
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_all_assertions>.
    //
    // Parameters:
    //     config_enable_all_assertions_param - The value to assign to variable <axi4::config_enable_all_assertions>.
    //
    function automatic void set_config_enable_all_assertions( bit config_enable_all_assertions_param );
        config_enable_all_assertions = config_enable_all_assertions_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_assertion
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_assertion>.
    //
    // Parameters:
    //     config_enable_assertion_param - The value to assign to variable <axi4::config_enable_assertion>.
    //
    function automatic void set_config_enable_assertion( bit [255:0] config_enable_assertion_param );
        config_enable_assertion = config_enable_assertion_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_assertion_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_enable_assertion>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_enable_assertion_param - The value to assign to variable <axi4::config_enable_assertion>.
    //
    function automatic void set_config_enable_assertion_index1( int _this_dot_1, bit  config_enable_assertion_param );
        config_enable_assertion[_this_dot_1] = config_enable_assertion_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_error
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_error>.
    //
    // Parameters:
    //     config_enable_error_param - The value to assign to variable <axi4::config_enable_error>.
    //
    function automatic void set_config_enable_error( bit [255:0] config_enable_error_param );
        config_enable_error = config_enable_error_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_error_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_enable_error>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_enable_error_param - The value to assign to variable <axi4::config_enable_error>.
    //
    function automatic void set_config_enable_error_index1( int _this_dot_1, bit  config_enable_error_param );
        config_enable_error[_this_dot_1] = config_enable_error_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_max_latency_AWVALID_assertion_to_AWREADY
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_max_latency_AWVALID_assertion_to_AWREADY>.
    //
    // Parameters:
    //     config_max_latency_AWVALID_assertion_to_AWREADY_param - The value to assign to variable <axi4::config_max_latency_AWVALID_assertion_to_AWREADY>.
    //
    function automatic void set_config_max_latency_AWVALID_assertion_to_AWREADY( int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
        config_max_latency_AWVALID_assertion_to_AWREADY = config_max_latency_AWVALID_assertion_to_AWREADY_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_max_latency_ARVALID_assertion_to_ARREADY
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_max_latency_ARVALID_assertion_to_ARREADY>.
    //
    // Parameters:
    //     config_max_latency_ARVALID_assertion_to_ARREADY_param - The value to assign to variable <axi4::config_max_latency_ARVALID_assertion_to_ARREADY>.
    //
    function automatic void set_config_max_latency_ARVALID_assertion_to_ARREADY( int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
        config_max_latency_ARVALID_assertion_to_ARREADY = config_max_latency_ARVALID_assertion_to_ARREADY_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_max_latency_RVALID_assertion_to_RREADY
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_max_latency_RVALID_assertion_to_RREADY>.
    //
    // Parameters:
    //     config_max_latency_RVALID_assertion_to_RREADY_param - The value to assign to variable <axi4::config_max_latency_RVALID_assertion_to_RREADY>.
    //
    function automatic void set_config_max_latency_RVALID_assertion_to_RREADY( int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
        config_max_latency_RVALID_assertion_to_RREADY = config_max_latency_RVALID_assertion_to_RREADY_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_max_latency_BVALID_assertion_to_BREADY
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_max_latency_BVALID_assertion_to_BREADY>.
    //
    // Parameters:
    //     config_max_latency_BVALID_assertion_to_BREADY_param - The value to assign to variable <axi4::config_max_latency_BVALID_assertion_to_BREADY>.
    //
    function automatic void set_config_max_latency_BVALID_assertion_to_BREADY( int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
        config_max_latency_BVALID_assertion_to_BREADY = config_max_latency_BVALID_assertion_to_BREADY_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_max_latency_WVALID_assertion_to_WREADY
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_max_latency_WVALID_assertion_to_WREADY>.
    //
    // Parameters:
    //     config_max_latency_WVALID_assertion_to_WREADY_param - The value to assign to variable <axi4::config_max_latency_WVALID_assertion_to_WREADY>.
    //
    function automatic void set_config_max_latency_WVALID_assertion_to_WREADY( int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
        config_max_latency_WVALID_assertion_to_WREADY = config_max_latency_WVALID_assertion_to_WREADY_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_qos
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_qos>.
    //
    // Parameters:
    //     config_enable_qos_param - The value to assign to variable <axi4::config_enable_qos>.
    //
    function automatic void set_config_enable_qos( bit config_enable_qos_param );
        config_enable_qos = config_enable_qos_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_region_support
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_region_support>.
    //
    // Parameters:
    //     config_enable_region_support_param - The value to assign to variable <axi4::config_enable_region_support>.
    //
    function automatic void set_config_enable_region_support( bit config_enable_region_support_param );
        config_enable_region_support = config_enable_region_support_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_slave_regions
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_slave_regions>.
    //
    // Parameters:
    //     config_slave_regions_param - The value to assign to variable <axi4::config_slave_regions>.
    //
    function automatic void set_config_slave_regions( int config_slave_regions_param );
        config_slave_regions = config_slave_regions_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_region
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_region>.
    //
    // Parameters:
    //     config_region_param - The value to assign to variable <axi4::config_region>.
    //
    function automatic void set_config_region( bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  config_region_param );
        config_region = config_region_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_region_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_region>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_region_param - The value to assign to variable <axi4::config_region>.
    //
    function automatic void set_config_region_index1( int _this_dot_1, bit [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  config_region_param );
        config_region[_this_dot_1] = config_region_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_region_index2
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_region>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //    _this_dot_2 - The array index for dimension 2.
    //     config_region_param - The value to assign to variable <axi4::config_region>.
    //
    function automatic void set_config_region_index2( int _this_dot_1, int _this_dot_2, bit  config_region_param );
        config_region[_this_dot_1][_this_dot_2] = config_region_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_read_data_reordering_depth
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_read_data_reordering_depth>.
    //
    // Parameters:
    //     config_read_data_reordering_depth_param - The value to assign to variable <axi4::config_read_data_reordering_depth>.
    //
    function automatic void set_config_read_data_reordering_depth( int unsigned config_read_data_reordering_depth_param );
        config_read_data_reordering_depth = config_read_data_reordering_depth_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_slave_start_addr
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_slave_start_addr>.
    //
    // Parameters:
    //     config_slave_start_addr_param - The value to assign to variable <axi4::config_slave_start_addr>.
    //
    function automatic void set_config_slave_start_addr( bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param );
        config_slave_start_addr = config_slave_start_addr_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_slave_start_addr_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_slave_start_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_slave_start_addr_param - The value to assign to variable <axi4::config_slave_start_addr>.
    //
    function automatic void set_config_slave_start_addr_index1( int _this_dot_1, bit  config_slave_start_addr_param );
        config_slave_start_addr[_this_dot_1] = config_slave_start_addr_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_slave_end_addr
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_slave_end_addr>.
    //
    // Parameters:
    //     config_slave_end_addr_param - The value to assign to variable <axi4::config_slave_end_addr>.
    //
    function automatic void set_config_slave_end_addr( bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param );
        config_slave_end_addr = config_slave_end_addr_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_slave_end_addr_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_slave_end_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_slave_end_addr_param - The value to assign to variable <axi4::config_slave_end_addr>.
    //
    function automatic void set_config_slave_end_addr_index1( int _this_dot_1, bit  config_slave_end_addr_param );
        config_slave_end_addr[_this_dot_1] = config_slave_end_addr_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_slave_enabled_non_contiguous_address_spaces
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_slave_enabled_non_contiguous_address_spaces>.
    //
    // Parameters:
    //     config_slave_enabled_non_contiguous_address_spaces_param - The value to assign to variable <axi4::config_slave_enabled_non_contiguous_address_spaces>.
    //
    function automatic void set_config_slave_enabled_non_contiguous_address_spaces( int config_slave_enabled_non_contiguous_address_spaces_param );
        config_slave_enabled_non_contiguous_address_spaces = config_slave_enabled_non_contiguous_address_spaces_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_slave_possess_multiple_non_contiguous_address_spaces
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_slave_possess_multiple_non_contiguous_address_spaces>.
    //
    // Parameters:
    //     config_slave_possess_multiple_non_contiguous_address_spaces_param - The value to assign to variable <axi4::config_slave_possess_multiple_non_contiguous_address_spaces>.
    //
    function automatic void set_config_slave_possess_multiple_non_contiguous_address_spaces( bit config_slave_possess_multiple_non_contiguous_address_spaces_param );
        config_slave_possess_multiple_non_contiguous_address_spaces = config_slave_possess_multiple_non_contiguous_address_spaces_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_slave_multiple_non_contiguous_start_address_range
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    // Parameters:
    //     config_slave_multiple_non_contiguous_start_address_range_param - The value to assign to variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    function automatic void set_config_slave_multiple_non_contiguous_start_address_range( bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_start_address_range_param );
        config_slave_multiple_non_contiguous_start_address_range = config_slave_multiple_non_contiguous_start_address_range_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_slave_multiple_non_contiguous_start_address_range_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_slave_multiple_non_contiguous_start_address_range_param - The value to assign to variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    function automatic void set_config_slave_multiple_non_contiguous_start_address_range_index1( int _this_dot_1, bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_start_address_range_param );
        config_slave_multiple_non_contiguous_start_address_range[_this_dot_1] = config_slave_multiple_non_contiguous_start_address_range_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_slave_multiple_non_contiguous_start_address_range_index2
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //    _this_dot_2 - The array index for dimension 2.
    //     config_slave_multiple_non_contiguous_start_address_range_param - The value to assign to variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    function automatic void set_config_slave_multiple_non_contiguous_start_address_range_index2( int _this_dot_1, int _this_dot_2, bit  config_slave_multiple_non_contiguous_start_address_range_param );
        config_slave_multiple_non_contiguous_start_address_range[_this_dot_1][_this_dot_2] = config_slave_multiple_non_contiguous_start_address_range_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_slave_multiple_non_contiguous_end_address_range
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    // Parameters:
    //     config_slave_multiple_non_contiguous_end_address_range_param - The value to assign to variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    function automatic void set_config_slave_multiple_non_contiguous_end_address_range( bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_end_address_range_param );
        config_slave_multiple_non_contiguous_end_address_range = config_slave_multiple_non_contiguous_end_address_range_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_slave_multiple_non_contiguous_end_address_range_index1
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //     config_slave_multiple_non_contiguous_end_address_range_param - The value to assign to variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    function automatic void set_config_slave_multiple_non_contiguous_end_address_range_index1( int _this_dot_1, bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_end_address_range_param );
        config_slave_multiple_non_contiguous_end_address_range[_this_dot_1] = config_slave_multiple_non_contiguous_end_address_range_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_slave_multiple_non_contiguous_end_address_range_index2
    //------------------------------------------------------------------------------
    //     Set the value of one element of variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //    _this_dot_2 - The array index for dimension 2.
    //     config_slave_multiple_non_contiguous_end_address_range_param - The value to assign to variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    function automatic void set_config_slave_multiple_non_contiguous_end_address_range_index2( int _this_dot_1, int _this_dot_2, bit  config_slave_multiple_non_contiguous_end_address_range_param );
        config_slave_multiple_non_contiguous_end_address_range[_this_dot_1][_this_dot_2] = config_slave_multiple_non_contiguous_end_address_range_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_protect_ready
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_protect_ready>.
    //
    // Parameters:
    //     config_protect_ready_param - The value to assign to variable <axi4::config_protect_ready>.
    //
    function automatic void set_config_protect_ready( bit config_protect_ready_param );
        config_protect_ready = config_protect_ready_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_max_outstanding_wr
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_max_outstanding_wr>.
    //
    // Parameters:
    //     config_max_outstanding_wr_param - The value to assign to variable <axi4::config_max_outstanding_wr>.
    //
    function automatic void set_config_max_outstanding_wr( int config_max_outstanding_wr_param );
        config_max_outstanding_wr = config_max_outstanding_wr_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_max_outstanding_rd
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_max_outstanding_rd>.
    //
    // Parameters:
    //     config_max_outstanding_rd_param - The value to assign to variable <axi4::config_max_outstanding_rd>.
    //
    function automatic void set_config_max_outstanding_rd( int config_max_outstanding_rd_param );
        config_max_outstanding_rd = config_max_outstanding_rd_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_num_outstanding_wr_phase
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_num_outstanding_wr_phase>.
    //
    // Parameters:
    //     config_num_outstanding_wr_phase_param - The value to assign to variable <axi4::config_num_outstanding_wr_phase>.
    //
    function automatic void set_config_num_outstanding_wr_phase( int config_num_outstanding_wr_phase_param );
        config_num_outstanding_wr_phase = config_num_outstanding_wr_phase_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_num_outstanding_rd_phase
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_num_outstanding_rd_phase>.
    //
    // Parameters:
    //     config_num_outstanding_rd_phase_param - The value to assign to variable <axi4::config_num_outstanding_rd_phase>.
    //
    function automatic void set_config_num_outstanding_rd_phase( int config_num_outstanding_rd_phase_param );
        config_num_outstanding_rd_phase = config_num_outstanding_rd_phase_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_warnings
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_warnings>.
    //
    // Parameters:
    //     config_enable_warnings_param - The value to assign to variable <axi4::config_enable_warnings>.
    //
    function automatic void set_config_enable_warnings( bit config_enable_warnings_param );
        config_enable_warnings = config_enable_warnings_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_errors
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_errors>.
    //
    // Parameters:
    //     config_enable_errors_param - The value to assign to variable <axi4::config_enable_errors>.
    //
    function automatic void set_config_enable_errors( bit config_enable_errors_param );
        config_enable_errors = config_enable_errors_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_enable_exclusive_checks
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_enable_exclusive_checks>.
    //
    // Parameters:
    //     config_enable_exclusive_checks_param - The value to assign to variable <axi4::config_enable_exclusive_checks>.
    //
    function automatic void set_config_enable_exclusive_checks( bit config_enable_exclusive_checks_param );
        config_enable_exclusive_checks = config_enable_exclusive_checks_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_warn_on_slave_errors
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_warn_on_slave_errors>.
    //
    // Parameters:
    //     config_warn_on_slave_errors_param - The value to assign to variable <axi4::config_warn_on_slave_errors>.
    //
    function automatic void set_config_warn_on_slave_errors( bit config_warn_on_slave_errors_param );
        config_warn_on_slave_errors = config_warn_on_slave_errors_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_error_on_deleted_valid_cycles
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_error_on_deleted_valid_cycles>.
    //
    // Parameters:
    //     config_error_on_deleted_valid_cycles_param - The value to assign to variable <axi4::config_error_on_deleted_valid_cycles>.
    //
    function automatic void set_config_error_on_deleted_valid_cycles( bit config_error_on_deleted_valid_cycles_param );
        config_error_on_deleted_valid_cycles = config_error_on_deleted_valid_cycles_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable>.
    //
    // Parameters:
    //     config_stats_enable_param - The value to assign to variable <axi4::config_stats_enable>.
    //
    function automatic void set_config_stats_enable( bit config_stats_enable_param );
        config_stats_enable = config_stats_enable_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_occupancy
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_read_occupancy>.
    //
    // Parameters:
    //     config_stats_enable_read_occupancy_param - The value to assign to variable <axi4::config_stats_enable_read_occupancy>.
    //
    function automatic void set_config_stats_enable_read_occupancy( bit config_stats_enable_read_occupancy_param );
        config_stats_enable_read_occupancy = config_stats_enable_read_occupancy_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_occupancy
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_write_occupancy>.
    //
    // Parameters:
    //     config_stats_enable_write_occupancy_param - The value to assign to variable <axi4::config_stats_enable_write_occupancy>.
    //
    function automatic void set_config_stats_enable_write_occupancy( bit config_stats_enable_write_occupancy_param );
        config_stats_enable_write_occupancy = config_stats_enable_write_occupancy_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_data_occupancy
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_read_data_occupancy>.
    //
    // Parameters:
    //     config_stats_enable_read_data_occupancy_param - The value to assign to variable <axi4::config_stats_enable_read_data_occupancy>.
    //
    function automatic void set_config_stats_enable_read_data_occupancy( bit config_stats_enable_read_data_occupancy_param );
        config_stats_enable_read_data_occupancy = config_stats_enable_read_data_occupancy_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_data_occupancy
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_write_data_occupancy>.
    //
    // Parameters:
    //     config_stats_enable_write_data_occupancy_param - The value to assign to variable <axi4::config_stats_enable_write_data_occupancy>.
    //
    function automatic void set_config_stats_enable_write_data_occupancy( bit config_stats_enable_write_data_occupancy_param );
        config_stats_enable_write_data_occupancy = config_stats_enable_write_data_occupancy_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_latency
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_read_latency>.
    //
    // Parameters:
    //     config_stats_enable_read_latency_param - The value to assign to variable <axi4::config_stats_enable_read_latency>.
    //
    function automatic void set_config_stats_enable_read_latency( bit config_stats_enable_read_latency_param );
        config_stats_enable_read_latency = config_stats_enable_read_latency_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_latency
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_write_latency>.
    //
    // Parameters:
    //     config_stats_enable_write_latency_param - The value to assign to variable <axi4::config_stats_enable_write_latency>.
    //
    function automatic void set_config_stats_enable_write_latency( bit config_stats_enable_write_latency_param );
        config_stats_enable_write_latency = config_stats_enable_write_latency_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_address_waits
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_read_address_waits>.
    //
    // Parameters:
    //     config_stats_enable_read_address_waits_param - The value to assign to variable <axi4::config_stats_enable_read_address_waits>.
    //
    function automatic void set_config_stats_enable_read_address_waits( bit config_stats_enable_read_address_waits_param );
        config_stats_enable_read_address_waits = config_stats_enable_read_address_waits_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_data_waits
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_read_data_waits>.
    //
    // Parameters:
    //     config_stats_enable_read_data_waits_param - The value to assign to variable <axi4::config_stats_enable_read_data_waits>.
    //
    function automatic void set_config_stats_enable_read_data_waits( bit config_stats_enable_read_data_waits_param );
        config_stats_enable_read_data_waits = config_stats_enable_read_data_waits_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_address_waits
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_write_address_waits>.
    //
    // Parameters:
    //     config_stats_enable_write_address_waits_param - The value to assign to variable <axi4::config_stats_enable_write_address_waits>.
    //
    function automatic void set_config_stats_enable_write_address_waits( bit config_stats_enable_write_address_waits_param );
        config_stats_enable_write_address_waits = config_stats_enable_write_address_waits_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_data_waits
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_write_data_waits>.
    //
    // Parameters:
    //     config_stats_enable_write_data_waits_param - The value to assign to variable <axi4::config_stats_enable_write_data_waits>.
    //
    function automatic void set_config_stats_enable_write_data_waits( bit config_stats_enable_write_data_waits_param );
        config_stats_enable_write_data_waits = config_stats_enable_write_data_waits_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_response_waits
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_write_response_waits>.
    //
    // Parameters:
    //     config_stats_enable_write_response_waits_param - The value to assign to variable <axi4::config_stats_enable_write_response_waits>.
    //
    function automatic void set_config_stats_enable_write_response_waits( bit config_stats_enable_write_response_waits_param );
        config_stats_enable_write_response_waits = config_stats_enable_write_response_waits_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_read_bandwidth
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_read_bandwidth>.
    //
    // Parameters:
    //     config_stats_enable_read_bandwidth_param - The value to assign to variable <axi4::config_stats_enable_read_bandwidth>.
    //
    function automatic void set_config_stats_enable_read_bandwidth( bit config_stats_enable_read_bandwidth_param );
        config_stats_enable_read_bandwidth = config_stats_enable_read_bandwidth_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_enable_write_bandwidth
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_enable_write_bandwidth>.
    //
    // Parameters:
    //     config_stats_enable_write_bandwidth_param - The value to assign to variable <axi4::config_stats_enable_write_bandwidth>.
    //
    function automatic void set_config_stats_enable_write_bandwidth( bit config_stats_enable_write_bandwidth_param );
        config_stats_enable_write_bandwidth = config_stats_enable_write_bandwidth_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_occupancy_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_occupancy_step>.
    //
    // Parameters:
    //     config_stats_read_occupancy_step_param - The value to assign to variable <axi4::config_stats_read_occupancy_step>.
    //
    function automatic void set_config_stats_read_occupancy_step( int config_stats_read_occupancy_step_param );
        config_stats_read_occupancy_step = config_stats_read_occupancy_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_occupancy_multiple>.
    //
    // Parameters:
    //     config_stats_read_occupancy_multiple_param - The value to assign to variable <axi4::config_stats_read_occupancy_multiple>.
    //
    function automatic void set_config_stats_read_occupancy_multiple( int config_stats_read_occupancy_multiple_param );
        config_stats_read_occupancy_multiple = config_stats_read_occupancy_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_occupancy_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_occupancy_step>.
    //
    // Parameters:
    //     config_stats_write_occupancy_step_param - The value to assign to variable <axi4::config_stats_write_occupancy_step>.
    //
    function automatic void set_config_stats_write_occupancy_step( int config_stats_write_occupancy_step_param );
        config_stats_write_occupancy_step = config_stats_write_occupancy_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_occupancy_multiple>.
    //
    // Parameters:
    //     config_stats_write_occupancy_multiple_param - The value to assign to variable <axi4::config_stats_write_occupancy_multiple>.
    //
    function automatic void set_config_stats_write_occupancy_multiple( int config_stats_write_occupancy_multiple_param );
        config_stats_write_occupancy_multiple = config_stats_write_occupancy_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_data_occupancy_step>.
    //
    // Parameters:
    //     config_stats_read_data_occupancy_step_param - The value to assign to variable <axi4::config_stats_read_data_occupancy_step>.
    //
    function automatic void set_config_stats_read_data_occupancy_step( int config_stats_read_data_occupancy_step_param );
        config_stats_read_data_occupancy_step = config_stats_read_data_occupancy_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_data_occupancy_multiple>.
    //
    // Parameters:
    //     config_stats_read_data_occupancy_multiple_param - The value to assign to variable <axi4::config_stats_read_data_occupancy_multiple>.
    //
    function automatic void set_config_stats_read_data_occupancy_multiple( int config_stats_read_data_occupancy_multiple_param );
        config_stats_read_data_occupancy_multiple = config_stats_read_data_occupancy_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_data_occupancy_step>.
    //
    // Parameters:
    //     config_stats_write_data_occupancy_step_param - The value to assign to variable <axi4::config_stats_write_data_occupancy_step>.
    //
    function automatic void set_config_stats_write_data_occupancy_step( int config_stats_write_data_occupancy_step_param );
        config_stats_write_data_occupancy_step = config_stats_write_data_occupancy_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_data_occupancy_multiple>.
    //
    // Parameters:
    //     config_stats_write_data_occupancy_multiple_param - The value to assign to variable <axi4::config_stats_write_data_occupancy_multiple>.
    //
    function automatic void set_config_stats_write_data_occupancy_multiple( int config_stats_write_data_occupancy_multiple_param );
        config_stats_write_data_occupancy_multiple = config_stats_write_data_occupancy_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_bandwidth_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_bandwidth_step>.
    //
    // Parameters:
    //     config_stats_read_bandwidth_step_param - The value to assign to variable <axi4::config_stats_read_bandwidth_step>.
    //
    function automatic void set_config_stats_read_bandwidth_step( int config_stats_read_bandwidth_step_param );
        config_stats_read_bandwidth_step = config_stats_read_bandwidth_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_bandwidth_multiple>.
    //
    // Parameters:
    //     config_stats_read_bandwidth_multiple_param - The value to assign to variable <axi4::config_stats_read_bandwidth_multiple>.
    //
    function automatic void set_config_stats_read_bandwidth_multiple( int config_stats_read_bandwidth_multiple_param );
        config_stats_read_bandwidth_multiple = config_stats_read_bandwidth_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_bandwidth_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_bandwidth_step>.
    //
    // Parameters:
    //     config_stats_write_bandwidth_step_param - The value to assign to variable <axi4::config_stats_write_bandwidth_step>.
    //
    function automatic void set_config_stats_write_bandwidth_step( int config_stats_write_bandwidth_step_param );
        config_stats_write_bandwidth_step = config_stats_write_bandwidth_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_bandwidth_multiple>.
    //
    // Parameters:
    //     config_stats_write_bandwidth_multiple_param - The value to assign to variable <axi4::config_stats_write_bandwidth_multiple>.
    //
    function automatic void set_config_stats_write_bandwidth_multiple( int config_stats_write_bandwidth_multiple_param );
        config_stats_write_bandwidth_multiple = config_stats_write_bandwidth_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_latency_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_latency_step>.
    //
    // Parameters:
    //     config_stats_read_latency_step_param - The value to assign to variable <axi4::config_stats_read_latency_step>.
    //
    function automatic void set_config_stats_read_latency_step( int config_stats_read_latency_step_param );
        config_stats_read_latency_step = config_stats_read_latency_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_latency_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_latency_multiple>.
    //
    // Parameters:
    //     config_stats_read_latency_multiple_param - The value to assign to variable <axi4::config_stats_read_latency_multiple>.
    //
    function automatic void set_config_stats_read_latency_multiple( int config_stats_read_latency_multiple_param );
        config_stats_read_latency_multiple = config_stats_read_latency_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_latency_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_latency_step>.
    //
    // Parameters:
    //     config_stats_write_latency_step_param - The value to assign to variable <axi4::config_stats_write_latency_step>.
    //
    function automatic void set_config_stats_write_latency_step( int config_stats_write_latency_step_param );
        config_stats_write_latency_step = config_stats_write_latency_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_latency_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_latency_multiple>.
    //
    // Parameters:
    //     config_stats_write_latency_multiple_param - The value to assign to variable <axi4::config_stats_write_latency_multiple>.
    //
    function automatic void set_config_stats_write_latency_multiple( int config_stats_write_latency_multiple_param );
        config_stats_write_latency_multiple = config_stats_write_latency_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_address_waits_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_address_waits_step>.
    //
    // Parameters:
    //     config_stats_read_address_waits_step_param - The value to assign to variable <axi4::config_stats_read_address_waits_step>.
    //
    function automatic void set_config_stats_read_address_waits_step( int config_stats_read_address_waits_step_param );
        config_stats_read_address_waits_step = config_stats_read_address_waits_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_address_waits_multiple>.
    //
    // Parameters:
    //     config_stats_read_address_waits_multiple_param - The value to assign to variable <axi4::config_stats_read_address_waits_multiple>.
    //
    function automatic void set_config_stats_read_address_waits_multiple( int config_stats_read_address_waits_multiple_param );
        config_stats_read_address_waits_multiple = config_stats_read_address_waits_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_data_waits_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_data_waits_step>.
    //
    // Parameters:
    //     config_stats_read_data_waits_step_param - The value to assign to variable <axi4::config_stats_read_data_waits_step>.
    //
    function automatic void set_config_stats_read_data_waits_step( int config_stats_read_data_waits_step_param );
        config_stats_read_data_waits_step = config_stats_read_data_waits_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_read_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_read_data_waits_multiple>.
    //
    // Parameters:
    //     config_stats_read_data_waits_multiple_param - The value to assign to variable <axi4::config_stats_read_data_waits_multiple>.
    //
    function automatic void set_config_stats_read_data_waits_multiple( int config_stats_read_data_waits_multiple_param );
        config_stats_read_data_waits_multiple = config_stats_read_data_waits_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_address_waits_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_address_waits_step>.
    //
    // Parameters:
    //     config_stats_write_address_waits_step_param - The value to assign to variable <axi4::config_stats_write_address_waits_step>.
    //
    function automatic void set_config_stats_write_address_waits_step( int config_stats_write_address_waits_step_param );
        config_stats_write_address_waits_step = config_stats_write_address_waits_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_address_waits_multiple>.
    //
    // Parameters:
    //     config_stats_write_address_waits_multiple_param - The value to assign to variable <axi4::config_stats_write_address_waits_multiple>.
    //
    function automatic void set_config_stats_write_address_waits_multiple( int config_stats_write_address_waits_multiple_param );
        config_stats_write_address_waits_multiple = config_stats_write_address_waits_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_data_waits_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_data_waits_step>.
    //
    // Parameters:
    //     config_stats_write_data_waits_step_param - The value to assign to variable <axi4::config_stats_write_data_waits_step>.
    //
    function automatic void set_config_stats_write_data_waits_step( int config_stats_write_data_waits_step_param );
        config_stats_write_data_waits_step = config_stats_write_data_waits_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_data_waits_multiple>.
    //
    // Parameters:
    //     config_stats_write_data_waits_multiple_param - The value to assign to variable <axi4::config_stats_write_data_waits_multiple>.
    //
    function automatic void set_config_stats_write_data_waits_multiple( int config_stats_write_data_waits_multiple_param );
        config_stats_write_data_waits_multiple = config_stats_write_data_waits_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_response_waits_step
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_response_waits_step>.
    //
    // Parameters:
    //     config_stats_write_response_waits_step_param - The value to assign to variable <axi4::config_stats_write_response_waits_step>.
    //
    function automatic void set_config_stats_write_response_waits_step( int config_stats_write_response_waits_step_param );
        config_stats_write_response_waits_step = config_stats_write_response_waits_step_param;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- set_config_stats_write_response_waits_multiple
    //------------------------------------------------------------------------------
    //     Set the value of variable <axi4::config_stats_write_response_waits_multiple>.
    //
    // Parameters:
    //     config_stats_write_response_waits_multiple_param - The value to assign to variable <axi4::config_stats_write_response_waits_multiple>.
    //
    function automatic void set_config_stats_write_response_waits_multiple( int config_stats_write_response_waits_multiple_param );
        config_stats_write_response_waits_multiple = config_stats_write_response_waits_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Functions to get global variables with read access
    //------------------------------------------------------------------------------


    //------------------------------------------------------------------------------
    // Function:- get_config_interface_type
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_interface_type>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_interface_type>.
    //
    function automatic axi4_interface_type_e get_config_interface_type(  );
        return config_interface_type;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_clk_init_value
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_clk_init_value>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_clk_init_value>.
    //
    function automatic bit get_config_clk_init_value(  );
        return config_clk_init_value;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_clk_phase_shift
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_clk_phase_shift>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_clk_phase_shift>.
    //
    function automatic longint unsigned get_config_clk_phase_shift(  );
        return config_clk_phase_shift;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_clk_1st_time
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_clk_1st_time>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_clk_1st_time>.
    //
    function automatic longint unsigned get_config_clk_1st_time(  );
        return config_clk_1st_time;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_clk_2nd_time
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_clk_2nd_time>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_clk_2nd_time>.
    //
    function automatic longint unsigned get_config_clk_2nd_time(  );
        return config_clk_2nd_time;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_setup_time
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_setup_time>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_setup_time>.
    //
    function automatic longint unsigned get_config_setup_time(  );
        return config_setup_time;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_hold_time
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_hold_time>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_hold_time>.
    //
    function automatic longint unsigned get_config_hold_time(  );
        return config_hold_time;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_burst_timeout_factor
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_burst_timeout_factor>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_burst_timeout_factor>.
    //
    function automatic int unsigned get_config_burst_timeout_factor(  );
        return config_burst_timeout_factor;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_max_transaction_time_factor
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_max_transaction_time_factor>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_max_transaction_time_factor>.
    //
    function automatic int unsigned get_config_max_transaction_time_factor(  );
        return config_max_transaction_time_factor;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_write_ctrl_first_ratio
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_write_ctrl_first_ratio>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_write_ctrl_first_ratio>.
    //
    function automatic int get_config_write_ctrl_first_ratio(  );
        return config_write_ctrl_first_ratio;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_write_data_first_ratio
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_write_data_first_ratio>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_write_data_first_ratio>.
    //
    function automatic int get_config_write_data_first_ratio(  );
        return config_write_data_first_ratio;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_reset_low_clocks
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_reset_low_clocks>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_reset_low_clocks>.
    //
    function automatic int get_config_reset_low_clocks(  );
        return config_reset_low_clocks;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_reset_hold_time
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_reset_hold_time>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_reset_hold_time>.
    //
    function automatic int get_config_reset_hold_time(  );
        return config_reset_hold_time;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_rlast
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_rlast>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_rlast>.
    //
    function automatic bit get_config_enable_rlast(  );
        return config_enable_rlast;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_slave_exclusive
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_slave_exclusive>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_slave_exclusive>.
    //
    function automatic bit get_config_enable_slave_exclusive(  );
        return config_enable_slave_exclusive;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_burst_reserved_value
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_burst_reserved_value>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_burst_reserved_value>.
    //
    function automatic bit get_config_enable_burst_reserved_value(  );
        return config_enable_burst_reserved_value;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_cache_value
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_cache_value>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_cache_value>.
    //
    function automatic bit [15:0]  get_config_enable_cache_value(  );
        return config_enable_cache_value;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_cache_value_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_enable_cache_value>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_cache_value>.
    //
    function automatic bit   get_config_enable_cache_value_index1( int _this_dot_1 );
        return config_enable_cache_value[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_internal_dummy_variable
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::internal_dummy_variable>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::internal_dummy_variable>.
    //
    function automatic axi4_error_e get_internal_dummy_variable(  );
        return internal_dummy_variable;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_axi4lite_interface
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_axi4lite_interface>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_axi4lite_interface>.
    //
    function automatic bit get_config_axi4lite_interface(  );
        return config_axi4lite_interface;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_axi4lite_tr_id
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_axi4lite_tr_id>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_axi4lite_tr_id>.
    //
    function automatic bit [((AXI4_ID_WIDTH) - 1):0]   get_config_axi4lite_tr_id(  );
        return config_axi4lite_tr_id;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_axi4lite_tr_id_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_axi4lite_tr_id>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::config_axi4lite_tr_id>.
    //
    function automatic bit   get_config_axi4lite_tr_id_index1( int _this_dot_1 );
        return config_axi4lite_tr_id[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_all_assertions
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_all_assertions>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_all_assertions>.
    //
    function automatic bit get_config_enable_all_assertions(  );
        return config_enable_all_assertions;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_assertion
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_assertion>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_assertion>.
    //
    function automatic bit [255:0]  get_config_enable_assertion(  );
        return config_enable_assertion;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_assertion_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_enable_assertion>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_assertion>.
    //
    function automatic bit   get_config_enable_assertion_index1( int _this_dot_1 );
        return config_enable_assertion[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_error
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_error>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_error>.
    //
    function automatic bit [255:0]  get_config_enable_error(  );
        return config_enable_error;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_error_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_enable_error>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_error>.
    //
    function automatic bit   get_config_enable_error_index1( int _this_dot_1 );
        return config_enable_error[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_max_latency_AWVALID_assertion_to_AWREADY
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_max_latency_AWVALID_assertion_to_AWREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_max_latency_AWVALID_assertion_to_AWREADY>.
    //
    function automatic int unsigned get_config_max_latency_AWVALID_assertion_to_AWREADY(  );
        return config_max_latency_AWVALID_assertion_to_AWREADY;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_max_latency_ARVALID_assertion_to_ARREADY
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_max_latency_ARVALID_assertion_to_ARREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_max_latency_ARVALID_assertion_to_ARREADY>.
    //
    function automatic int unsigned get_config_max_latency_ARVALID_assertion_to_ARREADY(  );
        return config_max_latency_ARVALID_assertion_to_ARREADY;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_max_latency_RVALID_assertion_to_RREADY
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_max_latency_RVALID_assertion_to_RREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_max_latency_RVALID_assertion_to_RREADY>.
    //
    function automatic int unsigned get_config_max_latency_RVALID_assertion_to_RREADY(  );
        return config_max_latency_RVALID_assertion_to_RREADY;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_max_latency_BVALID_assertion_to_BREADY
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_max_latency_BVALID_assertion_to_BREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_max_latency_BVALID_assertion_to_BREADY>.
    //
    function automatic int unsigned get_config_max_latency_BVALID_assertion_to_BREADY(  );
        return config_max_latency_BVALID_assertion_to_BREADY;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_max_latency_WVALID_assertion_to_WREADY
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_max_latency_WVALID_assertion_to_WREADY>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_max_latency_WVALID_assertion_to_WREADY>.
    //
    function automatic int unsigned get_config_max_latency_WVALID_assertion_to_WREADY(  );
        return config_max_latency_WVALID_assertion_to_WREADY;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_qos
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_qos>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_qos>.
    //
    function automatic bit get_config_enable_qos(  );
        return config_enable_qos;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_region_support
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_region_support>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_region_support>.
    //
    function automatic bit get_config_enable_region_support(  );
        return config_enable_region_support;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_slave_regions
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_slave_regions>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_regions>.
    //
    function automatic int get_config_slave_regions(  );
        return config_slave_regions;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_region
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_region>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_region>.
    //
    function automatic bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]   get_config_region(  );
        return config_region;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_region_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_region>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::config_region>.
    //
    function automatic bit [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]   get_config_region_index1( int _this_dot_1 );
        return config_region[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_region_index2
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_region>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //    _this_dot_2 - The array index for dimension 2.
    //
    // Returns:
    //     The current value of the variable <axi4::config_region>.
    //
    function automatic bit   get_config_region_index2( int _this_dot_1, int _this_dot_2 );
        return config_region[_this_dot_1][_this_dot_2];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_region_error_state
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::region_error_state>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::region_error_state>.
    //
    function automatic bit get_region_error_state(  );
        return region_error_state;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_region_map_lb
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::region_map_lb>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::region_map_lb>.
    //
    typedef longint unsigned _region_map_lb_t [((AXI4_REGION_MAP_SIZE) - 1):0];
    function automatic _region_map_lb_t get_region_map_lb(  );
        return region_map_lb;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_region_map_lb_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::region_map_lb>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::region_map_lb>.
    //
    function automatic longint unsigned get_region_map_lb_index1( int _this_dot_1 );
        return region_map_lb[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_region_map_ub
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::region_map_ub>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::region_map_ub>.
    //
    typedef longint unsigned _region_map_ub_t [((AXI4_REGION_MAP_SIZE) - 1):0];
    function automatic _region_map_ub_t get_region_map_ub(  );
        return region_map_ub;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_region_map_ub_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::region_map_ub>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::region_map_ub>.
    //
    function automatic longint unsigned get_region_map_ub_index1( int _this_dot_1 );
        return region_map_ub[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_region_map_region
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::region_map_region>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::region_map_region>.
    //
    typedef byte unsigned _region_map_region_t [((AXI4_REGION_MAP_SIZE) - 1):0];
    function automatic _region_map_region_t get_region_map_region(  );
        return region_map_region;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_region_map_region_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::region_map_region>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::region_map_region>.
    //
    function automatic byte unsigned get_region_map_region_index1( int _this_dot_1 );
        return region_map_region[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_cacheable
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::cacheable>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::cacheable>.
    //
    typedef byte unsigned _cacheable_t [((AXI4_REGION_MAP_SIZE) - 1):0];
    function automatic _cacheable_t get_cacheable(  );
        return cacheable;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_cacheable_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::cacheable>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::cacheable>.
    //
    function automatic byte unsigned get_cacheable_index1( int _this_dot_1 );
        return cacheable[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_read_data_reordering_depth
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_read_data_reordering_depth>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_read_data_reordering_depth>.
    //
    function automatic int unsigned get_config_read_data_reordering_depth(  );
        return config_read_data_reordering_depth;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_slave_start_addr
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_slave_start_addr>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_start_addr>.
    //
    function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_start_addr(  );
        return config_slave_start_addr;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_slave_start_addr_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_slave_start_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_start_addr>.
    //
    function automatic bit   get_config_slave_start_addr_index1( int _this_dot_1 );
        return config_slave_start_addr[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_slave_end_addr
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_slave_end_addr>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_end_addr>.
    //
    function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_end_addr(  );
        return config_slave_end_addr;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_slave_end_addr_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_slave_end_addr>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_end_addr>.
    //
    function automatic bit   get_config_slave_end_addr_index1( int _this_dot_1 );
        return config_slave_end_addr[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_slave_enabled_non_contiguous_address_spaces
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_slave_enabled_non_contiguous_address_spaces>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_enabled_non_contiguous_address_spaces>.
    //
    function automatic int get_config_slave_enabled_non_contiguous_address_spaces(  );
        return config_slave_enabled_non_contiguous_address_spaces;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_slave_possess_multiple_non_contiguous_address_spaces
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_slave_possess_multiple_non_contiguous_address_spaces>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_possess_multiple_non_contiguous_address_spaces>.
    //
    function automatic bit get_config_slave_possess_multiple_non_contiguous_address_spaces(  );
        return config_slave_possess_multiple_non_contiguous_address_spaces;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_slave_multiple_non_contiguous_start_address_range
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    function automatic bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_multiple_non_contiguous_start_address_range(  );
        return config_slave_multiple_non_contiguous_start_address_range;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_slave_multiple_non_contiguous_start_address_range_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_multiple_non_contiguous_start_address_range_index1( int _this_dot_1 );
        return config_slave_multiple_non_contiguous_start_address_range[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_slave_multiple_non_contiguous_start_address_range_index2
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //    _this_dot_2 - The array index for dimension 2.
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_multiple_non_contiguous_start_address_range>.
    //
    function automatic bit   get_config_slave_multiple_non_contiguous_start_address_range_index2( int _this_dot_1, int _this_dot_2 );
        return config_slave_multiple_non_contiguous_start_address_range[_this_dot_1][_this_dot_2];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_slave_multiple_non_contiguous_end_address_range
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    function automatic bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_multiple_non_contiguous_end_address_range(  );
        return config_slave_multiple_non_contiguous_end_address_range;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_slave_multiple_non_contiguous_end_address_range_index1
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_multiple_non_contiguous_end_address_range_index1( int _this_dot_1 );
        return config_slave_multiple_non_contiguous_end_address_range[_this_dot_1];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_slave_multiple_non_contiguous_end_address_range_index2
    //------------------------------------------------------------------------------
    //     Get the value of one element of variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    // Parameters:
    //    _this_dot_1 - The array index for dimension 1.
    //    _this_dot_2 - The array index for dimension 2.
    //
    // Returns:
    //     The current value of the variable <axi4::config_slave_multiple_non_contiguous_end_address_range>.
    //
    function automatic bit   get_config_slave_multiple_non_contiguous_end_address_range_index2( int _this_dot_1, int _this_dot_2 );
        return config_slave_multiple_non_contiguous_end_address_range[_this_dot_1][_this_dot_2];
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_protect_ready
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_protect_ready>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_protect_ready>.
    //
    function automatic bit get_config_protect_ready(  );
        return config_protect_ready;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_master_end_tlm_status
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::master_end_tlm_status>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::master_end_tlm_status>.
    //
    function automatic bit get_master_end_tlm_status(  );
        return master_end_tlm_status;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_master_end_wlm_status
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::master_end_wlm_status>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::master_end_wlm_status>.
    //
    function automatic bit get_master_end_wlm_status(  );
        return master_end_wlm_status;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_slave_end_tlm_status
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::slave_end_tlm_status>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::slave_end_tlm_status>.
    //
    function automatic bit get_slave_end_tlm_status(  );
        return slave_end_tlm_status;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_slave_end_wlm_status
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::slave_end_wlm_status>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::slave_end_wlm_status>.
    //
    function automatic bit get_slave_end_wlm_status(  );
        return slave_end_wlm_status;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_clock_source_end_tlm_status
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::clock_source_end_tlm_status>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::clock_source_end_tlm_status>.
    //
    function automatic bit get_clock_source_end_tlm_status(  );
        return clock_source_end_tlm_status;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_clock_source_end_wlm_status
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::clock_source_end_wlm_status>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::clock_source_end_wlm_status>.
    //
    function automatic bit get_clock_source_end_wlm_status(  );
        return clock_source_end_wlm_status;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_reset_source_end_tlm_status
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::reset_source_end_tlm_status>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::reset_source_end_tlm_status>.
    //
    function automatic bit get_reset_source_end_tlm_status(  );
        return reset_source_end_tlm_status;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_reset_source_end_wlm_status
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::reset_source_end_wlm_status>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::reset_source_end_wlm_status>.
    //
    function automatic bit get_reset_source_end_wlm_status(  );
        return reset_source_end_wlm_status;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_max_outstanding_wr
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_max_outstanding_wr>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_max_outstanding_wr>.
    //
    function automatic int get_config_max_outstanding_wr(  );
        return config_max_outstanding_wr;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_max_outstanding_rd
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_max_outstanding_rd>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_max_outstanding_rd>.
    //
    function automatic int get_config_max_outstanding_rd(  );
        return config_max_outstanding_rd;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_num_outstanding_wr_phase
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_num_outstanding_wr_phase>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_num_outstanding_wr_phase>.
    //
    function automatic int get_config_num_outstanding_wr_phase(  );
        return config_num_outstanding_wr_phase;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_num_outstanding_rd_phase
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_num_outstanding_rd_phase>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_num_outstanding_rd_phase>.
    //
    function automatic int get_config_num_outstanding_rd_phase(  );
        return config_num_outstanding_rd_phase;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_warnings
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_warnings>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_warnings>.
    //
    function automatic bit get_config_enable_warnings(  );
        return config_enable_warnings;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_errors
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_errors>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_errors>.
    //
    function automatic bit get_config_enable_errors(  );
        return config_enable_errors;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_enable_exclusive_checks
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_enable_exclusive_checks>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_enable_exclusive_checks>.
    //
    function automatic bit get_config_enable_exclusive_checks(  );
        return config_enable_exclusive_checks;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_warn_on_slave_errors
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_warn_on_slave_errors>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_warn_on_slave_errors>.
    //
    function automatic bit get_config_warn_on_slave_errors(  );
        return config_warn_on_slave_errors;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_error_on_deleted_valid_cycles
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_error_on_deleted_valid_cycles>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_error_on_deleted_valid_cycles>.
    //
    function automatic bit get_config_error_on_deleted_valid_cycles(  );
        return config_error_on_deleted_valid_cycles;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable>.
    //
    function automatic bit get_config_stats_enable(  );
        return config_stats_enable;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_occupancy
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_read_occupancy>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_read_occupancy>.
    //
    function automatic bit get_config_stats_enable_read_occupancy(  );
        return config_stats_enable_read_occupancy;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_occupancy
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_write_occupancy>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_write_occupancy>.
    //
    function automatic bit get_config_stats_enable_write_occupancy(  );
        return config_stats_enable_write_occupancy;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_data_occupancy
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_read_data_occupancy>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_read_data_occupancy>.
    //
    function automatic bit get_config_stats_enable_read_data_occupancy(  );
        return config_stats_enable_read_data_occupancy;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_data_occupancy
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_write_data_occupancy>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_write_data_occupancy>.
    //
    function automatic bit get_config_stats_enable_write_data_occupancy(  );
        return config_stats_enable_write_data_occupancy;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_latency
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_read_latency>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_read_latency>.
    //
    function automatic bit get_config_stats_enable_read_latency(  );
        return config_stats_enable_read_latency;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_latency
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_write_latency>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_write_latency>.
    //
    function automatic bit get_config_stats_enable_write_latency(  );
        return config_stats_enable_write_latency;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_address_waits
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_read_address_waits>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_read_address_waits>.
    //
    function automatic bit get_config_stats_enable_read_address_waits(  );
        return config_stats_enable_read_address_waits;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_data_waits
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_read_data_waits>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_read_data_waits>.
    //
    function automatic bit get_config_stats_enable_read_data_waits(  );
        return config_stats_enable_read_data_waits;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_address_waits
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_write_address_waits>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_write_address_waits>.
    //
    function automatic bit get_config_stats_enable_write_address_waits(  );
        return config_stats_enable_write_address_waits;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_data_waits
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_write_data_waits>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_write_data_waits>.
    //
    function automatic bit get_config_stats_enable_write_data_waits(  );
        return config_stats_enable_write_data_waits;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_response_waits
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_write_response_waits>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_write_response_waits>.
    //
    function automatic bit get_config_stats_enable_write_response_waits(  );
        return config_stats_enable_write_response_waits;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_read_bandwidth
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_read_bandwidth>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_read_bandwidth>.
    //
    function automatic bit get_config_stats_enable_read_bandwidth(  );
        return config_stats_enable_read_bandwidth;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_enable_write_bandwidth
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_enable_write_bandwidth>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_enable_write_bandwidth>.
    //
    function automatic bit get_config_stats_enable_write_bandwidth(  );
        return config_stats_enable_write_bandwidth;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_rw_transaction_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_rw_transaction_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_rw_transaction_last_duration>.
    //
    function automatic int get_stats_rw_transaction_last_duration(  );
        return stats_rw_transaction_last_duration;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_occupancy_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_occupancy_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_occupancy_step>.
    //
    function automatic int get_config_stats_read_occupancy_step(  );
        return config_stats_read_occupancy_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_occupancy_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_occupancy_multiple>.
    //
    function automatic int get_config_stats_read_occupancy_multiple(  );
        return config_stats_read_occupancy_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_active
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_active>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_active>.
    //
    function automatic bit get_stats_read_active(  );
        return stats_read_active;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_occupancy_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_occupancy_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_occupancy_sw>.
    //
    function automatic int get_stats_read_occupancy_sw(  );
        return stats_read_occupancy_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_idle_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_idle_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_idle_sw>.
    //
    function automatic int get_stats_read_idle_sw(  );
        return stats_read_idle_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_occupancy_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_occupancy_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_occupancy_min>.
    //
    function automatic int get_stats_read_occupancy_min(  );
        return stats_read_occupancy_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_idle_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_idle_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_idle_min>.
    //
    function automatic int get_stats_read_idle_min(  );
        return stats_read_idle_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_occupancy_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_occupancy_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_occupancy_max>.
    //
    function automatic int get_stats_read_occupancy_max(  );
        return stats_read_occupancy_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_idle_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_idle_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_idle_max>.
    //
    function automatic int get_stats_read_idle_max(  );
        return stats_read_idle_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_occupancy_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_occupancy_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_occupancy_mean>.
    //
    function automatic int get_stats_read_occupancy_mean(  );
        return stats_read_occupancy_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_idle_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_idle_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_idle_mean>.
    //
    function automatic int get_stats_read_idle_mean(  );
        return stats_read_idle_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_last_duration>.
    //
    function automatic int get_stats_read_last_duration(  );
        return stats_read_last_duration;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_occupancy_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_occupancy_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_occupancy_step>.
    //
    function automatic int get_config_stats_write_occupancy_step(  );
        return config_stats_write_occupancy_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_occupancy_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_occupancy_multiple>.
    //
    function automatic int get_config_stats_write_occupancy_multiple(  );
        return config_stats_write_occupancy_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_active
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_active>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_active>.
    //
    function automatic bit get_stats_write_active(  );
        return stats_write_active;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_occupancy_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_occupancy_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_occupancy_sw>.
    //
    function automatic int get_stats_write_occupancy_sw(  );
        return stats_write_occupancy_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_idle_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_idle_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_idle_sw>.
    //
    function automatic int get_stats_write_idle_sw(  );
        return stats_write_idle_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_occupancy_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_occupancy_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_occupancy_min>.
    //
    function automatic int get_stats_write_occupancy_min(  );
        return stats_write_occupancy_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_idle_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_idle_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_idle_min>.
    //
    function automatic int get_stats_write_idle_min(  );
        return stats_write_idle_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_occupancy_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_occupancy_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_occupancy_max>.
    //
    function automatic int get_stats_write_occupancy_max(  );
        return stats_write_occupancy_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_idle_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_idle_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_idle_max>.
    //
    function automatic int get_stats_write_idle_max(  );
        return stats_write_idle_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_occupancy_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_occupancy_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_occupancy_mean>.
    //
    function automatic int get_stats_write_occupancy_mean(  );
        return stats_write_occupancy_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_idle_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_idle_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_idle_mean>.
    //
    function automatic int get_stats_write_idle_mean(  );
        return stats_write_idle_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_last_duration
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_last_duration>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_last_duration>.
    //
    function automatic int get_stats_write_last_duration(  );
        return stats_write_last_duration;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_data_occupancy_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_data_occupancy_step>.
    //
    function automatic int get_config_stats_read_data_occupancy_step(  );
        return config_stats_read_data_occupancy_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_data_occupancy_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_data_occupancy_multiple>.
    //
    function automatic int get_config_stats_read_data_occupancy_multiple(  );
        return config_stats_read_data_occupancy_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_occupancy_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_occupancy_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_occupancy_sw>.
    //
    function automatic int get_stats_read_data_occupancy_sw(  );
        return stats_read_data_occupancy_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_idle_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_idle_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_idle_sw>.
    //
    function automatic int get_stats_read_data_idle_sw(  );
        return stats_read_data_idle_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_occupancy_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_occupancy_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_occupancy_min>.
    //
    function automatic int get_stats_read_data_occupancy_min(  );
        return stats_read_data_occupancy_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_idle_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_idle_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_idle_min>.
    //
    function automatic int get_stats_read_data_idle_min(  );
        return stats_read_data_idle_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_occupancy_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_occupancy_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_occupancy_max>.
    //
    function automatic int get_stats_read_data_occupancy_max(  );
        return stats_read_data_occupancy_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_idle_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_idle_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_idle_max>.
    //
    function automatic int get_stats_read_data_idle_max(  );
        return stats_read_data_idle_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_occupancy_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_occupancy_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_occupancy_mean>.
    //
    function automatic int get_stats_read_data_occupancy_mean(  );
        return stats_read_data_occupancy_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_idle_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_idle_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_idle_mean>.
    //
    function automatic int get_stats_read_data_idle_mean(  );
        return stats_read_data_idle_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_data_occupancy_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_data_occupancy_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_data_occupancy_step>.
    //
    function automatic int get_config_stats_write_data_occupancy_step(  );
        return config_stats_write_data_occupancy_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_data_occupancy_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_data_occupancy_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_data_occupancy_multiple>.
    //
    function automatic int get_config_stats_write_data_occupancy_multiple(  );
        return config_stats_write_data_occupancy_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_occupancy_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_occupancy_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_occupancy_sw>.
    //
    function automatic int get_stats_write_data_occupancy_sw(  );
        return stats_write_data_occupancy_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_idle_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_idle_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_idle_sw>.
    //
    function automatic int get_stats_write_data_idle_sw(  );
        return stats_write_data_idle_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_occupancy_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_occupancy_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_occupancy_min>.
    //
    function automatic int get_stats_write_data_occupancy_min(  );
        return stats_write_data_occupancy_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_idle_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_idle_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_idle_min>.
    //
    function automatic int get_stats_write_data_idle_min(  );
        return stats_write_data_idle_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_occupancy_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_occupancy_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_occupancy_max>.
    //
    function automatic int get_stats_write_data_occupancy_max(  );
        return stats_write_data_occupancy_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_idle_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_idle_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_idle_max>.
    //
    function automatic int get_stats_write_data_idle_max(  );
        return stats_write_data_idle_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_occupancy_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_occupancy_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_occupancy_mean>.
    //
    function automatic int get_stats_write_data_occupancy_mean(  );
        return stats_write_data_occupancy_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_idle_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_idle_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_idle_mean>.
    //
    function automatic int get_stats_write_data_idle_mean(  );
        return stats_write_data_idle_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_bandwidth_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_bandwidth_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_bandwidth_step>.
    //
    function automatic int get_config_stats_read_bandwidth_step(  );
        return config_stats_read_bandwidth_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_bandwidth_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_bandwidth_multiple>.
    //
    function automatic int get_config_stats_read_bandwidth_multiple(  );
        return config_stats_read_bandwidth_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_bandwidth_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_bandwidth_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_bandwidth_sw>.
    //
    function automatic int get_stats_read_bandwidth_sw(  );
        return stats_read_bandwidth_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_bandwidth_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_bandwidth_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_bandwidth_min>.
    //
    function automatic int get_stats_read_bandwidth_min(  );
        return stats_read_bandwidth_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_bandwidth_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_bandwidth_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_bandwidth_max>.
    //
    function automatic int get_stats_read_bandwidth_max(  );
        return stats_read_bandwidth_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_bandwidth_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_bandwidth_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_bandwidth_mean>.
    //
    function automatic int get_stats_read_bandwidth_mean(  );
        return stats_read_bandwidth_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_bandwidth_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_bandwidth_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_bandwidth_step>.
    //
    function automatic int get_config_stats_write_bandwidth_step(  );
        return config_stats_write_bandwidth_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_bandwidth_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_bandwidth_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_bandwidth_multiple>.
    //
    function automatic int get_config_stats_write_bandwidth_multiple(  );
        return config_stats_write_bandwidth_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_bandwidth_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_bandwidth_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_bandwidth_sw>.
    //
    function automatic int get_stats_write_bandwidth_sw(  );
        return stats_write_bandwidth_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_bandwidth_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_bandwidth_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_bandwidth_min>.
    //
    function automatic int get_stats_write_bandwidth_min(  );
        return stats_write_bandwidth_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_bandwidth_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_bandwidth_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_bandwidth_max>.
    //
    function automatic int get_stats_write_bandwidth_max(  );
        return stats_write_bandwidth_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_bandwidth_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_bandwidth_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_bandwidth_mean>.
    //
    function automatic int get_stats_write_bandwidth_mean(  );
        return stats_write_bandwidth_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_latency_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_latency_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_latency_step>.
    //
    function automatic int get_config_stats_read_latency_step(  );
        return config_stats_read_latency_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_latency_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_latency_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_latency_multiple>.
    //
    function automatic int get_config_stats_read_latency_multiple(  );
        return config_stats_read_latency_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_data_latency_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_data_latency_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_data_latency_inst>.
    //
    function automatic int get_stats_read_address_data_latency_inst(  );
        return stats_read_address_data_latency_inst;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_data_latency_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_data_latency_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_data_latency_sw>.
    //
    function automatic int get_stats_read_address_data_latency_sw(  );
        return stats_read_address_data_latency_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_data_latency_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_data_latency_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_data_latency_min>.
    //
    function automatic int get_stats_read_address_data_latency_min(  );
        return stats_read_address_data_latency_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_data_latency_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_data_latency_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_data_latency_max>.
    //
    function automatic int get_stats_read_address_data_latency_max(  );
        return stats_read_address_data_latency_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_data_latency_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_data_latency_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_data_latency_mean>.
    //
    function automatic int get_stats_read_address_data_latency_mean(  );
        return stats_read_address_data_latency_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_address_latency_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_address_latency_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_address_latency_inst>.
    //
    function automatic int get_stats_read_address_address_latency_inst(  );
        return stats_read_address_address_latency_inst;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_address_latency_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_address_latency_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_address_latency_sw>.
    //
    function automatic int get_stats_read_address_address_latency_sw(  );
        return stats_read_address_address_latency_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_address_latency_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_address_latency_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_address_latency_min>.
    //
    function automatic int get_stats_read_address_address_latency_min(  );
        return stats_read_address_address_latency_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_address_latency_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_address_latency_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_address_latency_max>.
    //
    function automatic int get_stats_read_address_address_latency_max(  );
        return stats_read_address_address_latency_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_address_latency_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_address_latency_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_address_latency_mean>.
    //
    function automatic int get_stats_read_address_address_latency_mean(  );
        return stats_read_address_address_latency_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_latency_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_latency_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_latency_step>.
    //
    function automatic int get_config_stats_write_latency_step(  );
        return config_stats_write_latency_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_latency_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_latency_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_latency_multiple>.
    //
    function automatic int get_config_stats_write_latency_multiple(  );
        return config_stats_write_latency_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_response_latency_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_response_latency_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_response_latency_inst>.
    //
    function automatic int get_stats_write_address_response_latency_inst(  );
        return stats_write_address_response_latency_inst;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_response_latency_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_response_latency_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_response_latency_sw>.
    //
    function automatic int get_stats_write_address_response_latency_sw(  );
        return stats_write_address_response_latency_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_response_latency_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_response_latency_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_response_latency_min>.
    //
    function automatic int get_stats_write_address_response_latency_min(  );
        return stats_write_address_response_latency_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_response_latency_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_response_latency_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_response_latency_max>.
    //
    function automatic int get_stats_write_address_response_latency_max(  );
        return stats_write_address_response_latency_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_response_latency_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_response_latency_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_response_latency_mean>.
    //
    function automatic int get_stats_write_address_response_latency_mean(  );
        return stats_write_address_response_latency_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_address_latency_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_address_latency_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_address_latency_inst>.
    //
    function automatic int get_stats_write_address_address_latency_inst(  );
        return stats_write_address_address_latency_inst;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_address_latency_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_address_latency_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_address_latency_sw>.
    //
    function automatic int get_stats_write_address_address_latency_sw(  );
        return stats_write_address_address_latency_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_address_latency_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_address_latency_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_address_latency_min>.
    //
    function automatic int get_stats_write_address_address_latency_min(  );
        return stats_write_address_address_latency_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_address_latency_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_address_latency_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_address_latency_max>.
    //
    function automatic int get_stats_write_address_address_latency_max(  );
        return stats_write_address_address_latency_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_address_latency_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_address_latency_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_address_latency_mean>.
    //
    function automatic int get_stats_write_address_address_latency_mean(  );
        return stats_write_address_address_latency_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_address_waits_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_address_waits_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_address_waits_step>.
    //
    function automatic int get_config_stats_read_address_waits_step(  );
        return config_stats_read_address_waits_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_address_waits_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_address_waits_multiple>.
    //
    function automatic int get_config_stats_read_address_waits_multiple(  );
        return config_stats_read_address_waits_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_waits_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_waits_inst>.
    //
    function automatic int get_stats_read_address_waits_inst(  );
        return stats_read_address_waits_inst;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_waits_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_waits_sw>.
    //
    function automatic int get_stats_read_address_waits_sw(  );
        return stats_read_address_waits_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_waits_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_waits_min>.
    //
    function automatic int get_stats_read_address_waits_min(  );
        return stats_read_address_waits_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_waits_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_waits_max>.
    //
    function automatic int get_stats_read_address_waits_max(  );
        return stats_read_address_waits_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_address_waits_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_address_waits_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_address_waits_mean>.
    //
    function automatic int get_stats_read_address_waits_mean(  );
        return stats_read_address_waits_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_data_waits_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_data_waits_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_data_waits_step>.
    //
    function automatic int get_config_stats_read_data_waits_step(  );
        return config_stats_read_data_waits_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_read_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_read_data_waits_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_read_data_waits_multiple>.
    //
    function automatic int get_config_stats_read_data_waits_multiple(  );
        return config_stats_read_data_waits_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_waits_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_waits_inst>.
    //
    function automatic int get_stats_read_data_waits_inst(  );
        return stats_read_data_waits_inst;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_waits_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_waits_sw>.
    //
    function automatic int get_stats_read_data_waits_sw(  );
        return stats_read_data_waits_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_waits_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_waits_min>.
    //
    function automatic int get_stats_read_data_waits_min(  );
        return stats_read_data_waits_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_waits_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_waits_max>.
    //
    function automatic int get_stats_read_data_waits_max(  );
        return stats_read_data_waits_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_read_data_waits_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_read_data_waits_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_read_data_waits_mean>.
    //
    function automatic int get_stats_read_data_waits_mean(  );
        return stats_read_data_waits_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_address_waits_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_address_waits_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_address_waits_step>.
    //
    function automatic int get_config_stats_write_address_waits_step(  );
        return config_stats_write_address_waits_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_address_waits_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_address_waits_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_address_waits_multiple>.
    //
    function automatic int get_config_stats_write_address_waits_multiple(  );
        return config_stats_write_address_waits_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_waits_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_waits_inst>.
    //
    function automatic int get_stats_write_address_waits_inst(  );
        return stats_write_address_waits_inst;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_waits_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_waits_sw>.
    //
    function automatic int get_stats_write_address_waits_sw(  );
        return stats_write_address_waits_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_waits_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_waits_min>.
    //
    function automatic int get_stats_write_address_waits_min(  );
        return stats_write_address_waits_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_waits_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_waits_max>.
    //
    function automatic int get_stats_write_address_waits_max(  );
        return stats_write_address_waits_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_address_waits_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_address_waits_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_address_waits_mean>.
    //
    function automatic int get_stats_write_address_waits_mean(  );
        return stats_write_address_waits_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_data_waits_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_data_waits_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_data_waits_step>.
    //
    function automatic int get_config_stats_write_data_waits_step(  );
        return config_stats_write_data_waits_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_data_waits_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_data_waits_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_data_waits_multiple>.
    //
    function automatic int get_config_stats_write_data_waits_multiple(  );
        return config_stats_write_data_waits_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_waits_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_waits_inst>.
    //
    function automatic int get_stats_write_data_waits_inst(  );
        return stats_write_data_waits_inst;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_waits_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_waits_sw>.
    //
    function automatic int get_stats_write_data_waits_sw(  );
        return stats_write_data_waits_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_waits_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_waits_min>.
    //
    function automatic int get_stats_write_data_waits_min(  );
        return stats_write_data_waits_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_waits_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_waits_max>.
    //
    function automatic int get_stats_write_data_waits_max(  );
        return stats_write_data_waits_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_data_waits_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_data_waits_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_data_waits_mean>.
    //
    function automatic int get_stats_write_data_waits_mean(  );
        return stats_write_data_waits_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_response_waits_step
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_response_waits_step>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_response_waits_step>.
    //
    function automatic int get_config_stats_write_response_waits_step(  );
        return config_stats_write_response_waits_step;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_config_stats_write_response_waits_multiple
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::config_stats_write_response_waits_multiple>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::config_stats_write_response_waits_multiple>.
    //
    function automatic int get_config_stats_write_response_waits_multiple(  );
        return config_stats_write_response_waits_multiple;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_inst
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_response_waits_inst>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_response_waits_inst>.
    //
    function automatic int get_stats_write_response_waits_inst(  );
        return stats_write_response_waits_inst;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_sw
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_response_waits_sw>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_response_waits_sw>.
    //
    function automatic int get_stats_write_response_waits_sw(  );
        return stats_write_response_waits_sw;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_min
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_response_waits_min>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_response_waits_min>.
    //
    function automatic int get_stats_write_response_waits_min(  );
        return stats_write_response_waits_min;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_max
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_response_waits_max>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_response_waits_max>.
    //
    function automatic int get_stats_write_response_waits_max(  );
        return stats_write_response_waits_max;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_stats_write_response_waits_mean
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::stats_write_response_waits_mean>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::stats_write_response_waits_mean>.
    //
    function automatic int get_stats_write_response_waits_mean(  );
        return stats_write_response_waits_mean;
    endfunction


    //------------------------------------------------------------------------------
    // Function:- get_reordering_depth_of_last_read_transaction
    //------------------------------------------------------------------------------
    //     Get the value of variable <axi4::reordering_depth_of_last_read_transaction>.
    //
    // Parameters:
    //
    // Returns:
    //     The current value of the variable <axi4::reordering_depth_of_last_read_transaction>.
    //
    function automatic int get_reordering_depth_of_last_read_transaction(  );
        return reordering_depth_of_last_read_transaction;
    endfunction


    //------------------------------------------------------------------------------
    // Functions to set/get generic interface configuration
    //------------------------------------------------------------------------------

    function void set_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0,
        input int arg10 = 0
    );
        axi4_set_interface( what, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10 );
    endfunction

    function int get_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0
    );
        return axi4_get_interface( what, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 );
    endfunction

    //------------------------------------------------------------------------------
    // Functions to get the hierarchic name of this interface
    //------------------------------------------------------------------------------
    function string get_full_name();
        return axi4_get_full_name();
    endfunction

    //------------------------------------------------------------------------------
    // Functions to set/get the abstraction levels of interface ends
    //------------------------------------------------------------------------------

    //------------------------------------------------------------------------------
    // Function: axi4_set_master_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to set whether the <master> end of the interface is WLM or TLM connected.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels,
    //     how they affect the behaviour of the QVIP, and guidelines for setting them.
    //
    // Parameters:
    //    wire_level - Set to 1 to be WLM connected.
    //    TLM_level -  Set to 1 to be TLM connected.
    //------------------------------------------------------------------------------
    function void axi4_set_master_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi4_set_master_end_abstraction_level( wire_level, TLM_level );
    endfunction

    //------------------------------------------------------------------------------
    // Function: axi4_get_master_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to return the Abstraction level setting for the master end.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels
    //     and how they affect the behaviour of the Questa Verification IP.
    //
    // Parameters:
    //
    //    wire_level - Value = 1 if this end is WLM connected.
    //    TLM_level -  Value = 1 if this end is TLM connected.
    //------------------------------------------------------------------------------
    function void axi4_get_master_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi4_get_master_end_abstraction_level( wire_level, TLM_level );
    endfunction

    //------------------------------------------------------------------------------
    // Function: axi4_set_slave_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to set whether the <slave> end of the interface is WLM or TLM connected.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels,
    //     how they affect the behaviour of the QVIP, and guidelines for setting them.
    //
    // Parameters:
    //    wire_level - Set to 1 to be WLM connected.
    //    TLM_level -  Set to 1 to be TLM connected.
    //------------------------------------------------------------------------------
    function void axi4_set_slave_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi4_set_slave_end_abstraction_level( wire_level, TLM_level );
    endfunction

    //------------------------------------------------------------------------------
    // Function: axi4_get_slave_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to return the Abstraction level setting for the slave end.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels
    //     and how they affect the behaviour of the Questa Verification IP.
    //
    // Parameters:
    //
    //    wire_level - Value = 1 if this end is WLM connected.
    //    TLM_level -  Value = 1 if this end is TLM connected.
    //------------------------------------------------------------------------------
    function void axi4_get_slave_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi4_get_slave_end_abstraction_level( wire_level, TLM_level );
    endfunction

    //------------------------------------------------------------------------------
    // Function: axi4_set_clock_source_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to set whether the <clock_source> end of the interface is WLM or TLM connected.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels,
    //     how they affect the behaviour of the QVIP, and guidelines for setting them.
    //
    // Parameters:
    //    wire_level - Set to 1 to be WLM connected.
    //    TLM_level -  Set to 1 to be TLM connected.
    //------------------------------------------------------------------------------
    function void axi4_set_clock_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi4_set_clock_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

    //------------------------------------------------------------------------------
    // Function: axi4_get_clock_source_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to return the Abstraction level setting for the clock_source end.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels
    //     and how they affect the behaviour of the Questa Verification IP.
    //
    // Parameters:
    //
    //    wire_level - Value = 1 if this end is WLM connected.
    //    TLM_level -  Value = 1 if this end is TLM connected.
    //------------------------------------------------------------------------------
    function void axi4_get_clock_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi4_get_clock_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

    //------------------------------------------------------------------------------
    // Function: axi4_set_reset_source_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to set whether the <reset_source> end of the interface is WLM or TLM connected.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels,
    //     how they affect the behaviour of the QVIP, and guidelines for setting them.
    //
    // Parameters:
    //    wire_level - Set to 1 to be WLM connected.
    //    TLM_level -  Set to 1 to be TLM connected.
    //------------------------------------------------------------------------------
    function void axi4_set_reset_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi4_set_reset_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

    //------------------------------------------------------------------------------
    // Function: axi4_get_reset_source_abstraction_level
    //------------------------------------------------------------------------------
    //     Function to return the Abstraction level setting for the reset_source end.
    //     See <Abstraction Levels of Interface Ends> for a description of abstraction levels
    //     and how they affect the behaviour of the Questa Verification IP.
    //
    // Parameters:
    //
    //    wire_level - Value = 1 if this end is WLM connected.
    //    TLM_level -  Value = 1 if this end is TLM connected.
    //------------------------------------------------------------------------------
    function void axi4_get_reset_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi4_get_reset_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

// Variable monitors

    function automatic void axi4_local_set_config_interface_type_from_SystemVerilog( ref axi4_interface_type_e config_interface_type_param );
        axi4_set_config_interface_type_from_SystemVerilog( config_interface_type );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_interface_type_from_SystemVerilog( config_interface_type );
            end
        end
    end

    function automatic void axi4_local_set_config_clk_init_value_from_SystemVerilog( ref bit config_clk_init_value_param );
        axi4_set_config_clk_init_value_from_SystemVerilog( config_clk_init_value );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_clk_init_value_from_SystemVerilog( config_clk_init_value );
            end
        end
    end

    function automatic void axi4_local_set_config_clk_phase_shift_from_SystemVerilog( ref longint unsigned config_clk_phase_shift_param );
        axi4_set_config_clk_phase_shift_from_SystemVerilog( config_clk_phase_shift );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_clk_phase_shift_from_SystemVerilog( config_clk_phase_shift );
            end
        end
    end

    function automatic void axi4_local_set_config_clk_1st_time_from_SystemVerilog( ref longint unsigned config_clk_1st_time_param );
        axi4_set_config_clk_1st_time_from_SystemVerilog( config_clk_1st_time );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_clk_1st_time_from_SystemVerilog( config_clk_1st_time );
            end
        end
    end

    function automatic void axi4_local_set_config_clk_2nd_time_from_SystemVerilog( ref longint unsigned config_clk_2nd_time_param );
        axi4_set_config_clk_2nd_time_from_SystemVerilog( config_clk_2nd_time );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_clk_2nd_time_from_SystemVerilog( config_clk_2nd_time );
            end
        end
    end

    function automatic void axi4_local_set_config_setup_time_from_SystemVerilog( ref longint unsigned config_setup_time_param );
        axi4_set_config_setup_time_from_SystemVerilog( config_setup_time );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_setup_time_from_SystemVerilog( config_setup_time );
            end
        end
    end

    function automatic void axi4_local_set_config_hold_time_from_SystemVerilog( ref longint unsigned config_hold_time_param );
        axi4_set_config_hold_time_from_SystemVerilog( config_hold_time );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_hold_time_from_SystemVerilog( config_hold_time );
            end
        end
    end

    function automatic void axi4_local_set_config_burst_timeout_factor_from_SystemVerilog( ref int unsigned config_burst_timeout_factor_param );
        axi4_set_config_burst_timeout_factor_from_SystemVerilog( config_burst_timeout_factor );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_burst_timeout_factor_from_SystemVerilog( config_burst_timeout_factor );
            end
        end
    end

    function automatic void axi4_local_set_config_max_transaction_time_factor_from_SystemVerilog( ref int unsigned config_max_transaction_time_factor_param );
        axi4_set_config_max_transaction_time_factor_from_SystemVerilog( config_max_transaction_time_factor );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_transaction_time_factor_from_SystemVerilog( config_max_transaction_time_factor );
            end
        end
    end

    function automatic void axi4_local_set_config_write_ctrl_first_ratio_from_SystemVerilog( ref int config_write_ctrl_first_ratio_param );
        axi4_set_config_write_ctrl_first_ratio_from_SystemVerilog( config_write_ctrl_first_ratio );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_write_ctrl_first_ratio_from_SystemVerilog( config_write_ctrl_first_ratio );
            end
        end
    end

    function automatic void axi4_local_set_config_write_data_first_ratio_from_SystemVerilog( ref int config_write_data_first_ratio_param );
        axi4_set_config_write_data_first_ratio_from_SystemVerilog( config_write_data_first_ratio );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_write_data_first_ratio_from_SystemVerilog( config_write_data_first_ratio );
            end
        end
    end

    function automatic void axi4_local_set_config_reset_low_clocks_from_SystemVerilog( ref int config_reset_low_clocks_param );
        axi4_set_config_reset_low_clocks_from_SystemVerilog( config_reset_low_clocks );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_reset_low_clocks_from_SystemVerilog( config_reset_low_clocks );
            end
        end
    end

    function automatic void axi4_local_set_config_reset_hold_time_from_SystemVerilog( ref int config_reset_hold_time_param );
        axi4_set_config_reset_hold_time_from_SystemVerilog( config_reset_hold_time );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_reset_hold_time_from_SystemVerilog( config_reset_hold_time );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_rlast_from_SystemVerilog( ref bit config_enable_rlast_param );
        axi4_set_config_enable_rlast_from_SystemVerilog( config_enable_rlast );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_rlast_from_SystemVerilog( config_enable_rlast );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_slave_exclusive_from_SystemVerilog( ref bit config_enable_slave_exclusive_param );
        axi4_set_config_enable_slave_exclusive_from_SystemVerilog( config_enable_slave_exclusive );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_slave_exclusive_from_SystemVerilog( config_enable_slave_exclusive );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_burst_reserved_value_from_SystemVerilog( ref bit config_enable_burst_reserved_value_param );
        axi4_set_config_enable_burst_reserved_value_from_SystemVerilog( config_enable_burst_reserved_value );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_burst_reserved_value_from_SystemVerilog( config_enable_burst_reserved_value );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_cache_value_from_SystemVerilog( ref bit [15:0] config_enable_cache_value_param );
        axi4_set_config_enable_cache_value_from_SystemVerilog( config_enable_cache_value );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_cache_value_from_SystemVerilog( config_enable_cache_value );
            end
        end
    end

    function automatic void axi4_local_set_internal_dummy_variable_from_SystemVerilog( ref axi4_error_e internal_dummy_variable_param );
        axi4_set_internal_dummy_variable_from_SystemVerilog( internal_dummy_variable );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_internal_dummy_variable_from_SystemVerilog( internal_dummy_variable );
            end
        end
    end

    function automatic void axi4_local_set_config_axi4lite_interface_from_SystemVerilog( ref bit config_axi4lite_interface_param );
        axi4_set_config_axi4lite_interface_from_SystemVerilog( config_axi4lite_interface );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_axi4lite_interface_from_SystemVerilog( config_axi4lite_interface );
            end
        end
    end

    function automatic void axi4_local_set_config_axi4lite_tr_id_from_SystemVerilog( ref bit [((AXI4_ID_WIDTH) - 1):0]  config_axi4lite_tr_id_param );
        axi4_set_config_axi4lite_tr_id_from_SystemVerilog( config_axi4lite_tr_id );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_axi4lite_tr_id_from_SystemVerilog( config_axi4lite_tr_id );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_all_assertions_from_SystemVerilog( ref bit config_enable_all_assertions_param );
        axi4_set_config_enable_all_assertions_from_SystemVerilog( config_enable_all_assertions );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_all_assertions_from_SystemVerilog( config_enable_all_assertions );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_assertion_from_SystemVerilog( ref bit [255:0] config_enable_assertion_param );
        axi4_set_config_enable_assertion_from_SystemVerilog( config_enable_assertion );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_assertion_from_SystemVerilog( config_enable_assertion );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_error_from_SystemVerilog( ref bit [255:0] config_enable_error_param );
        axi4_set_config_enable_error_from_SystemVerilog( config_enable_error );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_error_from_SystemVerilog( config_enable_error );
            end
        end
    end

    function automatic void axi4_local_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog( ref int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
        axi4_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog( config_max_latency_AWVALID_assertion_to_AWREADY );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog( config_max_latency_AWVALID_assertion_to_AWREADY );
            end
        end
    end

    function automatic void axi4_local_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog( ref int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
        axi4_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog( config_max_latency_ARVALID_assertion_to_ARREADY );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog( config_max_latency_ARVALID_assertion_to_ARREADY );
            end
        end
    end

    function automatic void axi4_local_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog( ref int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
        axi4_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog( config_max_latency_RVALID_assertion_to_RREADY );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog( config_max_latency_RVALID_assertion_to_RREADY );
            end
        end
    end

    function automatic void axi4_local_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog( ref int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
        axi4_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog( config_max_latency_BVALID_assertion_to_BREADY );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog( config_max_latency_BVALID_assertion_to_BREADY );
            end
        end
    end

    function automatic void axi4_local_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog( ref int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
        axi4_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog( config_max_latency_WVALID_assertion_to_WREADY );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog( config_max_latency_WVALID_assertion_to_WREADY );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_qos_from_SystemVerilog( ref bit config_enable_qos_param );
        axi4_set_config_enable_qos_from_SystemVerilog( config_enable_qos );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_qos_from_SystemVerilog( config_enable_qos );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_region_support_from_SystemVerilog( ref bit config_enable_region_support_param );
        axi4_set_config_enable_region_support_from_SystemVerilog( config_enable_region_support );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_region_support_from_SystemVerilog( config_enable_region_support );
            end
        end
    end

    function automatic void axi4_local_set_config_slave_regions_from_SystemVerilog( ref int config_slave_regions_param );
        axi4_set_config_slave_regions_from_SystemVerilog( config_slave_regions );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_slave_regions_from_SystemVerilog( config_slave_regions );
            end
        end
    end

    function automatic void axi4_local_set_config_region_from_SystemVerilog( ref bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  config_region_param );
        axi4_set_config_region_from_SystemVerilog( config_region );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_region_from_SystemVerilog( config_region );
            end
        end
    end

    function automatic void axi4_local_set_config_read_data_reordering_depth_from_SystemVerilog( ref int unsigned config_read_data_reordering_depth_param );
        axi4_set_config_read_data_reordering_depth_from_SystemVerilog( config_read_data_reordering_depth );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_read_data_reordering_depth_from_SystemVerilog( config_read_data_reordering_depth );
            end
        end
    end

    function automatic void axi4_local_set_config_slave_start_addr_from_SystemVerilog( ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param );
        axi4_set_config_slave_start_addr_from_SystemVerilog( config_slave_start_addr );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_slave_start_addr_from_SystemVerilog( config_slave_start_addr );
            end
        end
    end

    function automatic void axi4_local_set_config_slave_end_addr_from_SystemVerilog( ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param );
        axi4_set_config_slave_end_addr_from_SystemVerilog( config_slave_end_addr );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_slave_end_addr_from_SystemVerilog( config_slave_end_addr );
            end
        end
    end

    function automatic void axi4_local_set_config_slave_enabled_non_contiguous_address_spaces_from_SystemVerilog( ref int config_slave_enabled_non_contiguous_address_spaces_param );
        axi4_set_config_slave_enabled_non_contiguous_address_spaces_from_SystemVerilog( config_slave_enabled_non_contiguous_address_spaces );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_slave_enabled_non_contiguous_address_spaces_from_SystemVerilog( config_slave_enabled_non_contiguous_address_spaces );
            end
        end
    end

    function automatic void axi4_local_set_config_slave_possess_multiple_non_contiguous_address_spaces_from_SystemVerilog( ref bit config_slave_possess_multiple_non_contiguous_address_spaces_param );
        axi4_set_config_slave_possess_multiple_non_contiguous_address_spaces_from_SystemVerilog( config_slave_possess_multiple_non_contiguous_address_spaces );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_slave_possess_multiple_non_contiguous_address_spaces_from_SystemVerilog( config_slave_possess_multiple_non_contiguous_address_spaces );
            end
        end
    end

    function automatic void axi4_local_set_config_slave_multiple_non_contiguous_start_address_range_from_SystemVerilog( ref bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_start_address_range_param );
        axi4_set_config_slave_multiple_non_contiguous_start_address_range_from_SystemVerilog( config_slave_multiple_non_contiguous_start_address_range );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_slave_multiple_non_contiguous_start_address_range_from_SystemVerilog( config_slave_multiple_non_contiguous_start_address_range );
            end
        end
    end

    function automatic void axi4_local_set_config_slave_multiple_non_contiguous_end_address_range_from_SystemVerilog( ref bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_end_address_range_param );
        axi4_set_config_slave_multiple_non_contiguous_end_address_range_from_SystemVerilog( config_slave_multiple_non_contiguous_end_address_range );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_slave_multiple_non_contiguous_end_address_range_from_SystemVerilog( config_slave_multiple_non_contiguous_end_address_range );
            end
        end
    end

    function automatic void axi4_local_set_config_protect_ready_from_SystemVerilog( ref bit config_protect_ready_param );
        axi4_set_config_protect_ready_from_SystemVerilog( config_protect_ready );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_protect_ready_from_SystemVerilog( config_protect_ready );
            end
        end
    end

    function automatic void axi4_local_set_config_max_outstanding_wr_from_SystemVerilog( ref int config_max_outstanding_wr_param );
        axi4_set_config_max_outstanding_wr_from_SystemVerilog( config_max_outstanding_wr );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_outstanding_wr_from_SystemVerilog( config_max_outstanding_wr );
            end
        end
    end

    function automatic void axi4_local_set_config_max_outstanding_rd_from_SystemVerilog( ref int config_max_outstanding_rd_param );
        axi4_set_config_max_outstanding_rd_from_SystemVerilog( config_max_outstanding_rd );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_outstanding_rd_from_SystemVerilog( config_max_outstanding_rd );
            end
        end
    end

    function automatic void axi4_local_set_config_num_outstanding_wr_phase_from_SystemVerilog( ref int config_num_outstanding_wr_phase_param );
        axi4_set_config_num_outstanding_wr_phase_from_SystemVerilog( config_num_outstanding_wr_phase );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_num_outstanding_wr_phase_from_SystemVerilog( config_num_outstanding_wr_phase );
            end
        end
    end

    function automatic void axi4_local_set_config_num_outstanding_rd_phase_from_SystemVerilog( ref int config_num_outstanding_rd_phase_param );
        axi4_set_config_num_outstanding_rd_phase_from_SystemVerilog( config_num_outstanding_rd_phase );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_num_outstanding_rd_phase_from_SystemVerilog( config_num_outstanding_rd_phase );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_warnings_from_SystemVerilog( ref bit config_enable_warnings_param );
        axi4_set_config_enable_warnings_from_SystemVerilog( config_enable_warnings );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_warnings_from_SystemVerilog( config_enable_warnings );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_errors_from_SystemVerilog( ref bit config_enable_errors_param );
        axi4_set_config_enable_errors_from_SystemVerilog( config_enable_errors );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_errors_from_SystemVerilog( config_enable_errors );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_exclusive_checks_from_SystemVerilog( ref bit config_enable_exclusive_checks_param );
        axi4_set_config_enable_exclusive_checks_from_SystemVerilog( config_enable_exclusive_checks );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_exclusive_checks_from_SystemVerilog( config_enable_exclusive_checks );
            end
        end
    end

    function automatic void axi4_local_set_config_warn_on_slave_errors_from_SystemVerilog( ref bit config_warn_on_slave_errors_param );
        axi4_set_config_warn_on_slave_errors_from_SystemVerilog( config_warn_on_slave_errors );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_warn_on_slave_errors_from_SystemVerilog( config_warn_on_slave_errors );
            end
        end
    end

    function automatic void axi4_local_set_config_error_on_deleted_valid_cycles_from_SystemVerilog( ref bit config_error_on_deleted_valid_cycles_param );
        axi4_set_config_error_on_deleted_valid_cycles_from_SystemVerilog( config_error_on_deleted_valid_cycles );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_error_on_deleted_valid_cycles_from_SystemVerilog( config_error_on_deleted_valid_cycles );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_from_SystemVerilog( ref bit config_stats_enable_param );
        axi4_set_config_stats_enable_from_SystemVerilog( config_stats_enable );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_from_SystemVerilog( config_stats_enable );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_read_occupancy_from_SystemVerilog( ref bit config_stats_enable_read_occupancy_param );
        axi4_set_config_stats_enable_read_occupancy_from_SystemVerilog( config_stats_enable_read_occupancy );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_read_occupancy_from_SystemVerilog( config_stats_enable_read_occupancy );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_write_occupancy_from_SystemVerilog( ref bit config_stats_enable_write_occupancy_param );
        axi4_set_config_stats_enable_write_occupancy_from_SystemVerilog( config_stats_enable_write_occupancy );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_write_occupancy_from_SystemVerilog( config_stats_enable_write_occupancy );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_read_data_occupancy_from_SystemVerilog( ref bit config_stats_enable_read_data_occupancy_param );
        axi4_set_config_stats_enable_read_data_occupancy_from_SystemVerilog( config_stats_enable_read_data_occupancy );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_read_data_occupancy_from_SystemVerilog( config_stats_enable_read_data_occupancy );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_write_data_occupancy_from_SystemVerilog( ref bit config_stats_enable_write_data_occupancy_param );
        axi4_set_config_stats_enable_write_data_occupancy_from_SystemVerilog( config_stats_enable_write_data_occupancy );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_write_data_occupancy_from_SystemVerilog( config_stats_enable_write_data_occupancy );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_read_latency_from_SystemVerilog( ref bit config_stats_enable_read_latency_param );
        axi4_set_config_stats_enable_read_latency_from_SystemVerilog( config_stats_enable_read_latency );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_read_latency_from_SystemVerilog( config_stats_enable_read_latency );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_write_latency_from_SystemVerilog( ref bit config_stats_enable_write_latency_param );
        axi4_set_config_stats_enable_write_latency_from_SystemVerilog( config_stats_enable_write_latency );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_write_latency_from_SystemVerilog( config_stats_enable_write_latency );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_read_address_waits_from_SystemVerilog( ref bit config_stats_enable_read_address_waits_param );
        axi4_set_config_stats_enable_read_address_waits_from_SystemVerilog( config_stats_enable_read_address_waits );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_read_address_waits_from_SystemVerilog( config_stats_enable_read_address_waits );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_read_data_waits_from_SystemVerilog( ref bit config_stats_enable_read_data_waits_param );
        axi4_set_config_stats_enable_read_data_waits_from_SystemVerilog( config_stats_enable_read_data_waits );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_read_data_waits_from_SystemVerilog( config_stats_enable_read_data_waits );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_write_address_waits_from_SystemVerilog( ref bit config_stats_enable_write_address_waits_param );
        axi4_set_config_stats_enable_write_address_waits_from_SystemVerilog( config_stats_enable_write_address_waits );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_write_address_waits_from_SystemVerilog( config_stats_enable_write_address_waits );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_write_data_waits_from_SystemVerilog( ref bit config_stats_enable_write_data_waits_param );
        axi4_set_config_stats_enable_write_data_waits_from_SystemVerilog( config_stats_enable_write_data_waits );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_write_data_waits_from_SystemVerilog( config_stats_enable_write_data_waits );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_write_response_waits_from_SystemVerilog( ref bit config_stats_enable_write_response_waits_param );
        axi4_set_config_stats_enable_write_response_waits_from_SystemVerilog( config_stats_enable_write_response_waits );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_write_response_waits_from_SystemVerilog( config_stats_enable_write_response_waits );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_read_bandwidth_from_SystemVerilog( ref bit config_stats_enable_read_bandwidth_param );
        axi4_set_config_stats_enable_read_bandwidth_from_SystemVerilog( config_stats_enable_read_bandwidth );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_read_bandwidth_from_SystemVerilog( config_stats_enable_read_bandwidth );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_write_bandwidth_from_SystemVerilog( ref bit config_stats_enable_write_bandwidth_param );
        axi4_set_config_stats_enable_write_bandwidth_from_SystemVerilog( config_stats_enable_write_bandwidth );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_write_bandwidth_from_SystemVerilog( config_stats_enable_write_bandwidth );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_occupancy_step_from_SystemVerilog( ref int config_stats_read_occupancy_step_param );
        axi4_set_config_stats_read_occupancy_step_from_SystemVerilog( config_stats_read_occupancy_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_occupancy_step_from_SystemVerilog( config_stats_read_occupancy_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_occupancy_multiple_from_SystemVerilog( ref int config_stats_read_occupancy_multiple_param );
        axi4_set_config_stats_read_occupancy_multiple_from_SystemVerilog( config_stats_read_occupancy_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_occupancy_multiple_from_SystemVerilog( config_stats_read_occupancy_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_occupancy_step_from_SystemVerilog( ref int config_stats_write_occupancy_step_param );
        axi4_set_config_stats_write_occupancy_step_from_SystemVerilog( config_stats_write_occupancy_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_occupancy_step_from_SystemVerilog( config_stats_write_occupancy_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_occupancy_multiple_from_SystemVerilog( ref int config_stats_write_occupancy_multiple_param );
        axi4_set_config_stats_write_occupancy_multiple_from_SystemVerilog( config_stats_write_occupancy_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_occupancy_multiple_from_SystemVerilog( config_stats_write_occupancy_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_data_occupancy_step_from_SystemVerilog( ref int config_stats_read_data_occupancy_step_param );
        axi4_set_config_stats_read_data_occupancy_step_from_SystemVerilog( config_stats_read_data_occupancy_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_data_occupancy_step_from_SystemVerilog( config_stats_read_data_occupancy_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog( ref int config_stats_read_data_occupancy_multiple_param );
        axi4_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog( config_stats_read_data_occupancy_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog( config_stats_read_data_occupancy_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_data_occupancy_step_from_SystemVerilog( ref int config_stats_write_data_occupancy_step_param );
        axi4_set_config_stats_write_data_occupancy_step_from_SystemVerilog( config_stats_write_data_occupancy_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_data_occupancy_step_from_SystemVerilog( config_stats_write_data_occupancy_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog( ref int config_stats_write_data_occupancy_multiple_param );
        axi4_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog( config_stats_write_data_occupancy_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog( config_stats_write_data_occupancy_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_bandwidth_step_from_SystemVerilog( ref int config_stats_read_bandwidth_step_param );
        axi4_set_config_stats_read_bandwidth_step_from_SystemVerilog( config_stats_read_bandwidth_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_bandwidth_step_from_SystemVerilog( config_stats_read_bandwidth_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_bandwidth_multiple_from_SystemVerilog( ref int config_stats_read_bandwidth_multiple_param );
        axi4_set_config_stats_read_bandwidth_multiple_from_SystemVerilog( config_stats_read_bandwidth_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_bandwidth_multiple_from_SystemVerilog( config_stats_read_bandwidth_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_bandwidth_step_from_SystemVerilog( ref int config_stats_write_bandwidth_step_param );
        axi4_set_config_stats_write_bandwidth_step_from_SystemVerilog( config_stats_write_bandwidth_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_bandwidth_step_from_SystemVerilog( config_stats_write_bandwidth_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_bandwidth_multiple_from_SystemVerilog( ref int config_stats_write_bandwidth_multiple_param );
        axi4_set_config_stats_write_bandwidth_multiple_from_SystemVerilog( config_stats_write_bandwidth_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_bandwidth_multiple_from_SystemVerilog( config_stats_write_bandwidth_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_latency_step_from_SystemVerilog( ref int config_stats_read_latency_step_param );
        axi4_set_config_stats_read_latency_step_from_SystemVerilog( config_stats_read_latency_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_latency_step_from_SystemVerilog( config_stats_read_latency_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_latency_multiple_from_SystemVerilog( ref int config_stats_read_latency_multiple_param );
        axi4_set_config_stats_read_latency_multiple_from_SystemVerilog( config_stats_read_latency_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_latency_multiple_from_SystemVerilog( config_stats_read_latency_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_latency_step_from_SystemVerilog( ref int config_stats_write_latency_step_param );
        axi4_set_config_stats_write_latency_step_from_SystemVerilog( config_stats_write_latency_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_latency_step_from_SystemVerilog( config_stats_write_latency_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_latency_multiple_from_SystemVerilog( ref int config_stats_write_latency_multiple_param );
        axi4_set_config_stats_write_latency_multiple_from_SystemVerilog( config_stats_write_latency_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_latency_multiple_from_SystemVerilog( config_stats_write_latency_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_address_waits_step_from_SystemVerilog( ref int config_stats_read_address_waits_step_param );
        axi4_set_config_stats_read_address_waits_step_from_SystemVerilog( config_stats_read_address_waits_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_address_waits_step_from_SystemVerilog( config_stats_read_address_waits_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_address_waits_multiple_from_SystemVerilog( ref int config_stats_read_address_waits_multiple_param );
        axi4_set_config_stats_read_address_waits_multiple_from_SystemVerilog( config_stats_read_address_waits_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_address_waits_multiple_from_SystemVerilog( config_stats_read_address_waits_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_data_waits_step_from_SystemVerilog( ref int config_stats_read_data_waits_step_param );
        axi4_set_config_stats_read_data_waits_step_from_SystemVerilog( config_stats_read_data_waits_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_data_waits_step_from_SystemVerilog( config_stats_read_data_waits_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_data_waits_multiple_from_SystemVerilog( ref int config_stats_read_data_waits_multiple_param );
        axi4_set_config_stats_read_data_waits_multiple_from_SystemVerilog( config_stats_read_data_waits_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_data_waits_multiple_from_SystemVerilog( config_stats_read_data_waits_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_address_waits_step_from_SystemVerilog( ref int config_stats_write_address_waits_step_param );
        axi4_set_config_stats_write_address_waits_step_from_SystemVerilog( config_stats_write_address_waits_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_address_waits_step_from_SystemVerilog( config_stats_write_address_waits_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_address_waits_multiple_from_SystemVerilog( ref int config_stats_write_address_waits_multiple_param );
        axi4_set_config_stats_write_address_waits_multiple_from_SystemVerilog( config_stats_write_address_waits_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_address_waits_multiple_from_SystemVerilog( config_stats_write_address_waits_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_data_waits_step_from_SystemVerilog( ref int config_stats_write_data_waits_step_param );
        axi4_set_config_stats_write_data_waits_step_from_SystemVerilog( config_stats_write_data_waits_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_data_waits_step_from_SystemVerilog( config_stats_write_data_waits_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_data_waits_multiple_from_SystemVerilog( ref int config_stats_write_data_waits_multiple_param );
        axi4_set_config_stats_write_data_waits_multiple_from_SystemVerilog( config_stats_write_data_waits_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_data_waits_multiple_from_SystemVerilog( config_stats_write_data_waits_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_response_waits_step_from_SystemVerilog( ref int config_stats_write_response_waits_step_param );
        axi4_set_config_stats_write_response_waits_step_from_SystemVerilog( config_stats_write_response_waits_step );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_response_waits_step_from_SystemVerilog( config_stats_write_response_waits_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_response_waits_multiple_from_SystemVerilog( ref int config_stats_write_response_waits_multiple_param );
        axi4_set_config_stats_write_response_waits_multiple_from_SystemVerilog( config_stats_write_response_waits_multiple );
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_response_waits_multiple_from_SystemVerilog( config_stats_write_response_waits_multiple );
            end
        end
    end

    //------------------------------------------------------------------------------
    // Transaction interface
    //------------------------------------------------------------------------------

    task automatic dvc_activate_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref axi4_rw_e read_or_write,
        ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi4_prot_e prot,
        ref bit [3:0] region,
        ref axi4_size_e size,
        ref axi4_burst_e burst,
        ref axi4_lock_e lock,
        ref axi4_cache_e cache,
        ref bit [3:0] qos,
        ref bit [((AXI4_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] burst_length,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        ref int address_valid_delay,
        ref int data_valid_delay[],
        ref int write_response_valid_delay,
        ref int address_ready_delay,
        ref int data_ready_delay[],
        ref int write_response_ready_delay,
        ref bit write_data_with_address,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int wdata_user_data_DIMS0;
                automatic int resp_DIMS0;
                automatic int resp_user_data_DIMS0;
                automatic int data_valid_delay_DIMS0;
                automatic int data_ready_delay_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                // Call function to provide sized and unsized params.
                // In addition gets back updated sizes of unsized params.
                axi4_rw_transaction_ActivatesActivatingActivate_SystemVerilog(_comms_semantic,_as_end, _trans_id, read_or_write, addr, prot, region, size, burst, lock, cache, qos, id, burst_length, addr_user_data, data_words, data_words_DIMS0, write_strobes, write_strobes_DIMS0, wdata_user_data, wdata_user_data_DIMS0, resp, resp_DIMS0, resp_user_data, resp_user_data_DIMS0, address_valid_delay, data_valid_delay, data_valid_delay_DIMS0, write_response_valid_delay, address_ready_delay, data_ready_delay, data_ready_delay_DIMS0, write_response_ready_delay, write_data_with_address, write_address_to_data_delay, write_data_to_address_delay, write_data_beats_delay, write_data_beats_delay_DIMS0, _unit_id); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    data_words = new [data_words_DIMS0];
                end
                else
                begin
                    data_words = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    write_strobes = new [1];  // Create dummy instead of a zero sized array
                end
                if (wdata_user_data_DIMS0 != 0)
                begin
                    wdata_user_data = new [wdata_user_data_DIMS0];
                end
                else
                begin
                    wdata_user_data = new [1];  // Create dummy instead of a zero sized array
                end
                if (resp_DIMS0 != 0)
                begin
                    resp = new [resp_DIMS0];
                end
                else
                begin
                    resp = new [1];  // Create dummy instead of a zero sized array
                end
                if (resp_user_data_DIMS0 != 0)
                begin
                    resp_user_data = new [resp_user_data_DIMS0];
                end
                else
                begin
                    resp_user_data = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_valid_delay_DIMS0 != 0)
                begin
                    data_valid_delay = new [data_valid_delay_DIMS0];
                end
                else
                begin
                    data_valid_delay = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_ready_delay_DIMS0 != 0)
                begin
                    data_ready_delay = new [data_ready_delay_DIMS0];
                end
                else
                begin
                    data_ready_delay = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    write_data_beats_delay = new [1];  // Create dummy instead of a zero sized array
                end
                // Call function to get the sized and unsized params
                axi4_rw_transaction_ActivatesActivatingActivate_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, read_or_write, addr, prot, region, size, burst, lock, cache, qos, id, burst_length, addr_user_data, data_words, write_strobes, wdata_user_data, resp, resp_user_data, address_valid_delay, data_valid_delay, write_response_valid_delay, address_ready_delay, data_ready_delay, write_response_ready_delay, write_data_with_address, write_address_to_data_delay, write_data_to_address_delay, write_data_beats_delay, _unit_id); // DPI call to imported task
                if (data_words_DIMS0 == 0)
                    data_words.delete;  // Delete each zero sized param
                if (write_strobes_DIMS0 == 0)
                    write_strobes.delete;  // Delete each zero sized param
                if (wdata_user_data_DIMS0 == 0)
                    wdata_user_data.delete;  // Delete each zero sized param
                if (resp_DIMS0 == 0)
                    resp.delete;  // Delete each zero sized param
                if (resp_user_data_DIMS0 == 0)
                    resp_user_data.delete;  // Delete each zero sized param
                if (data_valid_delay_DIMS0 == 0)
                    data_valid_delay.delete;  // Delete each zero sized param
                if (data_ready_delay_DIMS0 == 0)
                    data_ready_delay.delete;  // Delete each zero sized param
                if (write_data_beats_delay_DIMS0 == 0)
                    write_data_beats_delay.delete;  // Delete each zero sized param
            end // Block to create unsized data arrays
        end
    endtask

    task automatic dvc_get_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi4_rw_e read_or_write,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        output int address_valid_delay,
        ref int data_valid_delay[],
        output int write_response_valid_delay,
        output int address_ready_delay,
        ref int data_ready_delay[],
        output int write_response_ready_delay,
        output bit write_data_with_address,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int wdata_user_data_DIMS0;
                automatic int resp_DIMS0;
                automatic int resp_user_data_DIMS0;
                automatic int data_valid_delay_DIMS0;
                automatic int data_ready_delay_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                // Call function to get unsized params sizes.
                axi4_rw_transaction_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, write_strobes_DIMS0, wdata_user_data_DIMS0, resp_DIMS0, resp_user_data_DIMS0, data_valid_delay_DIMS0, data_ready_delay_DIMS0, write_data_beats_delay_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    data_words = new [data_words_DIMS0];
                end
                else
                begin
                    data_words = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    write_strobes = new [1];  // Create dummy instead of a zero sized array
                end
                if (wdata_user_data_DIMS0 != 0)
                begin
                    wdata_user_data = new [wdata_user_data_DIMS0];
                end
                else
                begin
                    wdata_user_data = new [1];  // Create dummy instead of a zero sized array
                end
                if (resp_DIMS0 != 0)
                begin
                    resp = new [resp_DIMS0];
                end
                else
                begin
                    resp = new [1];  // Create dummy instead of a zero sized array
                end
                if (resp_user_data_DIMS0 != 0)
                begin
                    resp_user_data = new [resp_user_data_DIMS0];
                end
                else
                begin
                    resp_user_data = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_valid_delay_DIMS0 != 0)
                begin
                    data_valid_delay = new [data_valid_delay_DIMS0];
                end
                else
                begin
                    data_valid_delay = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_ready_delay_DIMS0 != 0)
                begin
                    data_ready_delay = new [data_ready_delay_DIMS0];
                end
                else
                begin
                    data_ready_delay = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    write_data_beats_delay = new [1];  // Create dummy instead of a zero sized array
                end
                // Call function to get the sized and unsized params
                axi4_rw_transaction_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, read_or_write, addr, prot, region, size, burst, lock, cache, qos, id, burst_length, addr_user_data, data_words, write_strobes, wdata_user_data, resp, resp_user_data, address_valid_delay, data_valid_delay, write_response_valid_delay, address_ready_delay, data_ready_delay, write_response_ready_delay, write_data_with_address, write_address_to_data_delay, write_data_to_address_delay, write_data_beats_delay, _unit_id, _using); // DPI call to imported task
                if (data_words_DIMS0 == 0)
                    data_words.delete;  // Delete each zero sized param
                if (write_strobes_DIMS0 == 0)
                    write_strobes.delete;  // Delete each zero sized param
                if (wdata_user_data_DIMS0 == 0)
                    wdata_user_data.delete;  // Delete each zero sized param
                if (resp_DIMS0 == 0)
                    resp.delete;  // Delete each zero sized param
                if (resp_user_data_DIMS0 == 0)
                    resp_user_data.delete;  // Delete each zero sized param
                if (data_valid_delay_DIMS0 == 0)
                    data_valid_delay.delete;  // Delete each zero sized param
                if (data_ready_delay_DIMS0 == 0)
                    data_ready_delay.delete;  // Delete each zero sized param
                if (write_data_beats_delay_DIMS0 == 0)
                    write_data_beats_delay.delete;  // Delete each zero sized param
            end // Block to create unsized data arrays
        end
    endtask

    task automatic dvc_activate_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi4_prot_e prot,
        ref int rresp_delays[255:0],
        ref bit [3:0] region,
        ref axi4_size_e size,
        ref axi4_burst_e burst,
        ref axi4_lock_e lock,
        ref axi4_cache_e cache,
        ref bit [3:0] qos,
        ref bit [((AXI4_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] burst_length,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_RDATA_WIDTH) - 1):0] data_words [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int address_valid_delay,
        input int _unit_id = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int resp_DIMS0;
                automatic int resp_user_data_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Call function to provide sized and unsized params.
                // In addition gets back updated sizes of unsized params.
                axi4_read_ActivatesActivatingActivate_SystemVerilog(_comms_semantic,_as_end, _trans_id, addr, prot, rresp_delays, region, size, burst, lock, cache, qos, id, burst_length, addr_user_data, data_words, data_words_DIMS0, resp, resp_DIMS0, resp_user_data, resp_user_data_DIMS0, addr_start_time, addr_end_time, data_start_time, data_start_time_DIMS0, data_end_time, data_end_time_DIMS0, address_valid_delay, _unit_id); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    data_words = new [data_words_DIMS0];
                end
                else
                begin
                    data_words = new [1];  // Create dummy instead of a zero sized array
                end
                if (resp_DIMS0 != 0)
                begin
                    resp = new [resp_DIMS0];
                end
                else
                begin
                    resp = new [1];  // Create dummy instead of a zero sized array
                end
                if (resp_user_data_DIMS0 != 0)
                begin
                    resp_user_data = new [resp_user_data_DIMS0];
                end
                else
                begin
                    resp_user_data = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    data_start_time = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    data_end_time = new [1];  // Create dummy instead of a zero sized array
                end
                // Call function to get the sized and unsized params
                axi4_read_ActivatesActivatingActivate_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, addr, prot, rresp_delays, region, size, burst, lock, cache, qos, id, burst_length, addr_user_data, data_words, resp, resp_user_data, addr_start_time, addr_end_time, data_start_time, data_end_time, address_valid_delay, _unit_id); // DPI call to imported task
                if (data_words_DIMS0 == 0)
                    data_words.delete;  // Delete each zero sized param
                if (resp_DIMS0 == 0)
                    resp.delete;  // Delete each zero sized param
                if (resp_user_data_DIMS0 == 0)
                    resp_user_data.delete;  // Delete each zero sized param
                if (data_start_time_DIMS0 == 0)
                    data_start_time.delete;  // Delete each zero sized param
                if (data_end_time_DIMS0 == 0)
                    data_end_time.delete;  // Delete each zero sized param
            end // Block to create unsized data arrays
        end
    endtask

    task automatic dvc_get_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        ref int rresp_delays[255:0],
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_RDATA_WIDTH) - 1):0] data_words [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output int address_valid_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int resp_DIMS0;
                automatic int resp_user_data_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Call function to get unsized params sizes.
                axi4_read_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, resp_DIMS0, resp_user_data_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    data_words = new [data_words_DIMS0];
                end
                else
                begin
                    data_words = new [1];  // Create dummy instead of a zero sized array
                end
                if (resp_DIMS0 != 0)
                begin
                    resp = new [resp_DIMS0];
                end
                else
                begin
                    resp = new [1];  // Create dummy instead of a zero sized array
                end
                if (resp_user_data_DIMS0 != 0)
                begin
                    resp_user_data = new [resp_user_data_DIMS0];
                end
                else
                begin
                    resp_user_data = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    data_start_time = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    data_end_time = new [1];  // Create dummy instead of a zero sized array
                end
                // Call function to get the sized and unsized params
                axi4_read_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, addr, prot, rresp_delays, region, size, burst, lock, cache, qos, id, burst_length, addr_user_data, data_words, resp, resp_user_data, addr_start_time, addr_end_time, data_start_time, data_end_time, address_valid_delay, _unit_id, _using); // DPI call to imported task
                if (data_words_DIMS0 == 0)
                    data_words.delete;  // Delete each zero sized param
                if (resp_DIMS0 == 0)
                    resp.delete;  // Delete each zero sized param
                if (resp_user_data_DIMS0 == 0)
                    resp_user_data.delete;  // Delete each zero sized param
                if (data_start_time_DIMS0 == 0)
                    data_start_time.delete;  // Delete each zero sized param
                if (data_end_time_DIMS0 == 0)
                    data_end_time.delete;  // Delete each zero sized param
            end // Block to create unsized data arrays
        end
    endtask

    task automatic dvc_activate_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi4_prot_e prot,
        ref int bresp_delay,
        ref bit [3:0] region,
        ref axi4_size_e size,
        ref axi4_burst_e burst,
        ref axi4_lock_e lock,
        ref axi4_cache_e cache,
        ref bit [3:0] qos,
        ref bit [((AXI4_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] burst_length,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        ref axi4_response_e resp,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref longint wr_resp_start_time,
        ref longint wr_resp_end_time,
        ref int address_valid_delay,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int wdata_user_data_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                // Call function to provide sized and unsized params.
                // In addition gets back updated sizes of unsized params.
                axi4_write_ActivatesActivatingActivate_SystemVerilog(_comms_semantic,_as_end, _trans_id, addr, prot, bresp_delay, region, size, burst, lock, cache, qos, id, burst_length, addr_user_data, data_words, data_words_DIMS0, write_strobes, write_strobes_DIMS0, wdata_user_data, wdata_user_data_DIMS0, resp, resp_user_data, addr_start_time, addr_end_time, data_start_time, data_start_time_DIMS0, data_end_time, data_end_time_DIMS0, wr_resp_start_time, wr_resp_end_time, address_valid_delay, write_address_to_data_delay, write_data_to_address_delay, write_data_beats_delay, write_data_beats_delay_DIMS0, _unit_id); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    data_words = new [data_words_DIMS0];
                end
                else
                begin
                    data_words = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    write_strobes = new [1];  // Create dummy instead of a zero sized array
                end
                if (wdata_user_data_DIMS0 != 0)
                begin
                    wdata_user_data = new [wdata_user_data_DIMS0];
                end
                else
                begin
                    wdata_user_data = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    data_start_time = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    data_end_time = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    write_data_beats_delay = new [1];  // Create dummy instead of a zero sized array
                end
                // Call function to get the sized and unsized params
                axi4_write_ActivatesActivatingActivate_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, addr, prot, bresp_delay, region, size, burst, lock, cache, qos, id, burst_length, addr_user_data, data_words, write_strobes, wdata_user_data, resp, resp_user_data, addr_start_time, addr_end_time, data_start_time, data_end_time, wr_resp_start_time, wr_resp_end_time, address_valid_delay, write_address_to_data_delay, write_data_to_address_delay, write_data_beats_delay, _unit_id); // DPI call to imported task
                if (data_words_DIMS0 == 0)
                    data_words.delete;  // Delete each zero sized param
                if (write_strobes_DIMS0 == 0)
                    write_strobes.delete;  // Delete each zero sized param
                if (wdata_user_data_DIMS0 == 0)
                    wdata_user_data.delete;  // Delete each zero sized param
                if (data_start_time_DIMS0 == 0)
                    data_start_time.delete;  // Delete each zero sized param
                if (data_end_time_DIMS0 == 0)
                    data_end_time.delete;  // Delete each zero sized param
                if (write_data_beats_delay_DIMS0 == 0)
                    write_data_beats_delay.delete;  // Delete each zero sized param
            end // Block to create unsized data arrays
        end
    endtask

    task automatic dvc_get_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output int bresp_delay,
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        output axi4_response_e resp,
        output bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output longint wr_resp_start_time,
        output longint wr_resp_end_time,
        output int address_valid_delay,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int wdata_user_data_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                // Call function to get unsized params sizes.
                axi4_write_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, write_strobes_DIMS0, wdata_user_data_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, write_data_beats_delay_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    data_words = new [data_words_DIMS0];
                end
                else
                begin
                    data_words = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    write_strobes = new [1];  // Create dummy instead of a zero sized array
                end
                if (wdata_user_data_DIMS0 != 0)
                begin
                    wdata_user_data = new [wdata_user_data_DIMS0];
                end
                else
                begin
                    wdata_user_data = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    data_start_time = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    data_end_time = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    write_data_beats_delay = new [1];  // Create dummy instead of a zero sized array
                end
                // Call function to get the sized and unsized params
                axi4_write_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, addr, prot, bresp_delay, region, size, burst, lock, cache, qos, id, burst_length, addr_user_data, data_words, write_strobes, wdata_user_data, resp, resp_user_data, addr_start_time, addr_end_time, data_start_time, data_end_time, wr_resp_start_time, wr_resp_end_time, address_valid_delay, write_address_to_data_delay, write_data_to_address_delay, write_data_beats_delay, _unit_id, _using); // DPI call to imported task
                if (data_words_DIMS0 == 0)
                    data_words.delete;  // Delete each zero sized param
                if (write_strobes_DIMS0 == 0)
                    write_strobes.delete;  // Delete each zero sized param
                if (wdata_user_data_DIMS0 == 0)
                    wdata_user_data.delete;  // Delete each zero sized param
                if (data_start_time_DIMS0 == 0)
                    data_start_time.delete;  // Delete each zero sized param
                if (data_end_time_DIMS0 == 0)
                    data_end_time.delete;  // Delete each zero sized param
                if (write_data_beats_delay_DIMS0 == 0)
                    write_data_beats_delay.delete;  // Delete each zero sized param
            end // Block to create unsized data arrays
        end
    endtask

    task automatic dvc_put_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int burst_length,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] user_data [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int write_data_beats_delay[],
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to provide sized and unsized params.
            axi4_write_data_burst_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, burst_length, data_words, write_strobes, user_data, data_start_time, data_end_time, write_data_beats_delay, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output int burst_length,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] user_data [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int write_data_beats_delay[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int user_data_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                // Call function to get unsized params sizes.
                axi4_write_data_burst_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, write_strobes_DIMS0, user_data_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, write_data_beats_delay_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    data_words = new [data_words_DIMS0];
                end
                else
                begin
                    data_words = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    write_strobes = new [1];  // Create dummy instead of a zero sized array
                end
                if (user_data_DIMS0 != 0)
                begin
                    user_data = new [user_data_DIMS0];
                end
                else
                begin
                    user_data = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    data_start_time = new [1];  // Create dummy instead of a zero sized array
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    data_end_time = new [1];  // Create dummy instead of a zero sized array
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    write_data_beats_delay = new [1];  // Create dummy instead of a zero sized array
                end
                // Call function to get the sized and unsized params
                axi4_write_data_burst_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, data_words, write_strobes, user_data, data_start_time, data_end_time, write_data_beats_delay, _unit_id, _using); // DPI call to imported task
                if (data_words_DIMS0 == 0)
                    data_words.delete;  // Delete each zero sized param
                if (write_strobes_DIMS0 == 0)
                    write_strobes.delete;  // Delete each zero sized param
                if (user_data_DIMS0 == 0)
                    user_data.delete;  // Delete each zero sized param
                if (data_start_time_DIMS0 == 0)
                    data_start_time.delete;  // Delete each zero sized param
                if (data_end_time_DIMS0 == 0)
                    data_end_time.delete;  // Delete each zero sized param
                if (write_data_beats_delay_DIMS0 == 0)
                    write_data_beats_delay.delete;  // Delete each zero sized param
            end // Block to create unsized data arrays
        end
    endtask

    task automatic dvc_put_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input axi4_prot_e prot,
        input bit [3:0] region,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input axi4_cache_e cache,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_addr_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, addr, prot, region, burst_length, size, burst, lock, cache, qos, id, addr_user, address_valid_delay, address_ready_delay, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, addr, prot, region, burst_length, size, burst, lock, cache, qos, id, addr_user, address_valid_delay, address_ready_delay, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_data_burst_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_data_burst_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int data_ready_delay,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, data, resp, last, id, user_data, data_ready_delay, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, data, resp, last, id, user_data, data_ready_delay, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input axi4_prot_e prot,
        input bit [3:0] region,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input axi4_cache_e cache,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_addr_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, addr, prot, region, burst_length, size, burst, lock, cache, qos, id, addr_user, address_valid_delay, address_ready_delay, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, addr, prot, region, burst_length, size, burst, lock, cache, qos, id, addr_user, address_valid_delay, address_ready_delay, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        input bit last,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int data_ready_delay,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, data, write_strobes, last, user_data, data_ready_delay, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        output bit last,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, data, write_strobes, last, user_data, data_ready_delay, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi4_response_e resp,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int write_response_ready_delay,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_resp_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, resp, id, user_data, write_response_ready_delay, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi4_response_e resp,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int write_response_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_resp_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, resp, id, user_data, write_response_ready_delay, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] region,
        input axi4_cache_e cache,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input axi4_prot_e prot,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_addr_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, addr, region, cache, burst_length, size, burst, lock, qos, id, user_data, prot, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] region,
        output axi4_cache_e cache,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output axi4_prot_e prot,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, addr, region, cache, burst_length, size, burst, lock, qos, id, user_data, prot, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_addr_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, data, resp, last, id, user_data, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, data, resp, last, id, user_data, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] region,
        input axi4_cache_e cache,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input axi4_prot_e prot,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_addr_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, addr, region, cache, burst_length, size, burst, lock, qos, id, user_data, prot, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] region,
        output axi4_cache_e cache,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output axi4_prot_e prot,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, addr, region, cache, burst_length, size, burst, lock, qos, id, user_data, prot, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_addr_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  strb,
        input bit last,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, data, strb, last, user_data, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  strb,
        output bit last,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, data, strb, last, user_data, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi4_response_e resp,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_resp_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, resp, id, user_data, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi4_response_e resp,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_resp_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, resp, id, user_data, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_resp_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_resp_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_unexpected_write_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input axi4_response_e resp,
        input bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_unexpected_write_response_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, id, resp, resp_user_data, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_unexpected_write_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output axi4_response_e resp,
        output bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_unexpected_write_response_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, id, resp, resp_user_data, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic dvc_put_unexpected_read_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_unexpected_read_response_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, data, resp, last, id, user_data, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic dvc_get_unexpected_read_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_unexpected_read_response_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, data, resp, last, id, user_data, _unit_id, _using); // DPI call to imported task
        end
    endtask

    //-------------------------------------------------------------------------------------
    // Task which blocks and outputs an error if the interface has not initialized properly
    //-------------------------------------------------------------------------------------

    task _initialized();
        if (_interface_ref == 0)
        begin
            $display("Error: %m - Questa Verification IP failed to initialise. Please check questa_mvc.log for details");
            wait(_interface_ref!=0);
        end
    endtask

endinterface

`endif // MODEL_TECH
`ifdef INCA
// *****************************************************************************
//
// Copyright 2007-2013 Mentor Graphics Corporation
// All Rights Reserved.
//
// THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION WHICH IS THE PROPERTY OF
// MENTOR GRAPHICS CORPORATION OR ITS LICENSORS AND IS SUBJECT TO LICENSE TERMS.
//
// *****************************************************************************
// SystemVerilog           Version: 20130911_Questa_10.2c
// *****************************************************************************

// Title: axi4
//

import QUESTA_MVC::questa_mvc_reporter;
import QUESTA_MVC::questa_mvc_item_comms_semantic;
import QUESTA_MVC::questa_mvc_edge;
import QUESTA_MVC::QUESTA_MVC_POSEDGE;
import QUESTA_MVC::QUESTA_MVC_NEGEDGE;
import QUESTA_MVC::QUESTA_MVC_ANYEDGE;
import QUESTA_MVC::QUESTA_MVC_0_TO_1_EDGE;
import QUESTA_MVC::QUESTA_MVC_1_TO_0_EDGE;

//------------------------------------------------------------------------------
//
// Interface:- axi4
//
//------------------------------------------------------------------------------
//  This interface contains all the wires and BFM configuration variables.
// 
// For all Configuration variables set/get/wait functions are available in the
// interface.
// 
// For e.g.
// 
// bit config_enable_slave_exclusive:
// 
// >   function void set_config_enable_slave_exclusive( bit arg1 )
// >
// >   function bit get_config_enable_slave_exclusive()
// >
// >   task wait_for_config_enable_slave_exclusive()
// 
// bit [255:0] config_enable_assertion:
// 
// >     task wait_for_config_enable_assertion()
// >     
// >     task wait_for_config_enable_assertion_index1( input int _this_dot_1 )
// >     
// >     function void set_config_enable_assertion( bit [255:0] arg2 )
// >     
// >     function set_config_enable_assertion_index1( int _this_dot_1, bit  arg3 )
// >     
// >     function bit [255:0]  get_config_enable_assertion()
// >     
// >     function bit get_config_enable_assertion_index1( int _this_dot_1 ) 
// >
// 
//------------------------------------------------------------------------------
(* cy_so="libaxi4_IN_SystemVerilog_MTI_full" *)
(* on_lib_load="axi4_IN_SystemVerilog_load" *)
interface mgc_common_axi4
    #(int AXI4_ADDRESS_WIDTH = 64, int AXI4_RDATA_WIDTH = 1024, int AXI4_WDATA_WIDTH = 1024, int AXI4_ID_WIDTH = 18, int AXI4_USER_WIDTH = 8, int AXI4_REGION_MAP_SIZE = 16)
    (input wire iACLK, input wire iARESETn);
    // Constant: AXI4_ADDRESS_WIDTH
    //
    // The width of the AWADDR and ARADDR signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2).
    //

    // Constant: AXI4_RDATA_WIDTH
    //
    // The width of the RDATA signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6).
    //

    // Constant: AXI4_WDATA_WIDTH
    //
    // The width of the WDATA signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.3).
    //

    // Constant: AXI4_ID_WIDTH
    //
    // The width of the AWID, ARID, RID and BID signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2).
    //

    // Constant: AXI4_USER_WIDTH
    //
    // The width of the AWUSER, ARUSER, WUSER, RUSER and BUSER signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.3).
    //

    // Constant: AXI4_REGION_MAP_SIZE
    //
    //  The number of address-decode entries in the region map (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2)
    // 
    // The address-decode function is done by the interconnect, generating a value for <mgc_axi4::AWREGION>/<mgc_axi4::ARREGION> from the transaction address. This parameter defines the size of the entries
    //  in the <mgc_axi4::config_region> region map array, where each entry defines a mapping from address-range to region value. The entry encodes these as a concatenation of lower-address bound, upper-address bound and region value.
    // 


    //------------------------------------------------------------------------------
    //
    // Wires for interface: axi4
    //
    //------------------------------------------------------------------------------

    // Wire: ACLK
    //
    //------------------------------------------------------------------------------
    //  The clock signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.1)
    // 
    //------------------------------------------------------------------------------
    wire ACLK;

    // Wire: ARESETn
    //
    // Note, no reference to X/Z, as they don't appear in emulation 
    //
    wire ARESETn;

    // Wire: AWVALID
    //
    //------------------------------------------------------------------------------
    //  The address-channel valid signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2, A3.2 and A3.3)
    // 
    //------------------------------------------------------------------------------
    wire AWVALID;

    // Wire: AWADDR
    //
    //------------------------------------------------------------------------------
    //  The write address signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_ADDRESS_WIDTH) - 1):0]  AWADDR;

    // Wire: AWPROT
    //
    //------------------------------------------------------------------------------
    //  The write-channel protection type (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [2:0] AWPROT;

    // Wire: AWREGION
    //
    //------------------------------------------------------------------------------
    //  The write-channel region signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [3:0] AWREGION;

    // Wire: AWLEN
    //
    //------------------------------------------------------------------------------
    //  The write-channel burst-length signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [7:0] AWLEN;

    // Wire: AWSIZE
    //
    //------------------------------------------------------------------------------
    //  The write-channel burst size signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [2:0] AWSIZE;

    // Wire: AWBURST
    //
    //------------------------------------------------------------------------------
    //  The write-channel burst type signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2.)
    // 
    //------------------------------------------------------------------------------
    wire [1:0] AWBURST;

    // Wire: AWLOCK
    //
    //------------------------------------------------------------------------------
    //  The write-channel lock type (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire AWLOCK;

    // Wire: AWCACHE
    //
    //------------------------------------------------------------------------------
    //  The write-channel cache type signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [3:0] AWCACHE;

    // Wire: AWQOS
    //
    //------------------------------------------------------------------------------
    //  The write-channel Quality-of-Service signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [3:0] AWQOS;

    // Wire: AWID
    //
    //------------------------------------------------------------------------------
    //  The write-channel master ID signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_ID_WIDTH) - 1):0]  AWID;

    // Wire: AWUSER
    //
    //------------------------------------------------------------------------------
    //  User-defined write-channel signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.3)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_USER_WIDTH) - 1):0]  AWUSER;

    // Wire: AWREADY
    //
    //------------------------------------------------------------------------------
    //  The write-channel handshake ready signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2 and A3.2)
    // 
    //------------------------------------------------------------------------------
    wire AWREADY;

    // Wire: ARVALID
    //
    //------------------------------------------------------------------------------
    //  The read address channel valid signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5 and A3.2)
    // 
    //------------------------------------------------------------------------------
    wire ARVALID;

    // Wire: ARADDR
    //
    //------------------------------------------------------------------------------
    //  The read address channel address signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_ADDRESS_WIDTH) - 1):0]  ARADDR;

    // Wire: ARPROT
    //
    //------------------------------------------------------------------------------
    //  The read address channel protection type signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [2:0] ARPROT;

    // Wire: ARREGION
    //
    //------------------------------------------------------------------------------
    //  The read address channel region signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [3:0] ARREGION;

    // Wire: ARLEN
    //
    //------------------------------------------------------------------------------
    //  The read address channel burst length signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [7:0] ARLEN;

    // Wire: ARSIZE
    //
    //------------------------------------------------------------------------------
    //  The read address channel burst size signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [2:0] ARSIZE;

    // Wire: ARBURST
    //
    //------------------------------------------------------------------------------
    //  The read address channel burst type signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [1:0] ARBURST;

    // Wire: ARLOCK
    //
    //------------------------------------------------------------------------------
    //  The read address channel lock type signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire ARLOCK;

    // Wire: ARCACHE
    //
    //------------------------------------------------------------------------------
    //  The read address channel cache type signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [3:0] ARCACHE;

    // Wire: ARQOS
    //
    //------------------------------------------------------------------------------
    //  The read address channel Quality-of-Service signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [3:0] ARQOS;

    // Wire: ARID
    //
    //------------------------------------------------------------------------------
    //  The read address channel master ID signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_ID_WIDTH) - 1):0]  ARID;

    // Wire: ARUSER
    //
    //------------------------------------------------------------------------------
    //  User-defined read address channel signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.3)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_USER_WIDTH) - 1):0]  ARUSER;

    // Wire: ARREADY
    //
    //------------------------------------------------------------------------------
    //  The read address channel handshake ready signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5 and A3.2)
    // 
    //------------------------------------------------------------------------------
    wire ARREADY;

    // Wire: RVALID
    //
    //------------------------------------------------------------------------------
    //  The read data channel handshake valid signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6 and A3.2)
    // 
    //------------------------------------------------------------------------------
    wire RVALID;

    // Wire: RDATA
    //
    //------------------------------------------------------------------------------
    //  The read data channel data signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_RDATA_WIDTH) - 1):0]  RDATA;

    // Wire: RRESP
    //
    //------------------------------------------------------------------------------
    //  The read data channel response signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6)
    // 
    //------------------------------------------------------------------------------
    wire [1:0] RRESP;

    // Wire: RLAST
    //
    //------------------------------------------------------------------------------
    //  The read data channel LAST signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6)
    // 
    //------------------------------------------------------------------------------
    wire RLAST;

    // Wire: RID
    //
    //------------------------------------------------------------------------------
    //  The read data channel master ID signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_ID_WIDTH) - 1):0]  RID;

    // Wire: RUSER
    //
    //------------------------------------------------------------------------------
    //  User-defined read data channel signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.3)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_USER_WIDTH) - 1):0]  RUSER;

    // Wire: RREADY
    //
    //------------------------------------------------------------------------------
    //  The read data channel handshake ready signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6)
    // 
    //------------------------------------------------------------------------------
    wire RREADY;

    // Wire: WVALID
    //
    //------------------------------------------------------------------------------
    //  The write data channel handshake valid signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.3)
    // 
    //------------------------------------------------------------------------------
    wire WVALID;

    // Wire: WDATA
    //
    //------------------------------------------------------------------------------
    //  The write data channel data signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.3)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_WDATA_WIDTH) - 1):0]  WDATA;

    // Wire: WSTRB
    //
    //------------------------------------------------------------------------------
    //  The write data channel strobe signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.3)
    // 
    //------------------------------------------------------------------------------
    wire [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  WSTRB;

    // Wire: WLAST
    //
    //------------------------------------------------------------------------------
    //  The write data channel LAST signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.3)
    // 
    //------------------------------------------------------------------------------
    wire WLAST;

    // Wire: WUSER
    //
    //------------------------------------------------------------------------------
    //  User-defined write data channel signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.3)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_USER_WIDTH) - 1):0]  WUSER;

    // Wire: WREADY
    //
    //------------------------------------------------------------------------------
    //  The write data channel handshake ready signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.3)
    // 
    //------------------------------------------------------------------------------
    wire WREADY;

    // Wire: BVALID
    //
    //------------------------------------------------------------------------------
    //  The write response channel handshake valid signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.4)
    // 
    //------------------------------------------------------------------------------
    wire BVALID;

    // Wire: BRESP
    //
    //------------------------------------------------------------------------------
    //  The write response channel response signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.4)
    // 
    //------------------------------------------------------------------------------
    wire [1:0] BRESP;

    // Wire: BID
    //
    //------------------------------------------------------------------------------
    //  The write response channel ID signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.4)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_ID_WIDTH) - 1):0]  BID;

    // Wire: BUSER
    //
    //------------------------------------------------------------------------------
    //  User-defined write response channel signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.4, A8.3)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_USER_WIDTH) - 1):0]  BUSER;

    // Wire: BREADY
    //
    //------------------------------------------------------------------------------
    //  The write response channel handshake ready signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.4)
    // 
    //------------------------------------------------------------------------------
    wire BREADY;

    // Propagate global signals onto interface wires
    assign ACLK = iACLK;
    assign ARESETn = iARESETn;

    //------------------------------------------------------------------------------
    // Global Variables - config
    //------------------------------------------------------------------------------

    // Variable:- config_interface_type
    //
    //  A configuration parameter (of type <axi4_interface_type_e>) defining the interface category: read/write, read only or write only (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.2).
    // 
    // The value defaults to <AXI4_READWRITE>.
    // 
    //
    axi4_interface_type_e config_interface_type;

    // Variable:- config_clk_init_value
    //
    //   The initial value of the clock signal (<ACLK>) generated by the <mgc_axi4> Questa Verification IP built-in clock generator (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.1). Defaults to 1'b0.
    // 
    //
    bit config_clk_init_value;

    // Variable:- config_clk_phase_shift
    //
    //  The number of simulator time-steps for which the initial value of the clock signal (<ACLK>) (when generated by the <mgc_axi4> Questa Verification IP built-in clock generator) shall be held.
    // 
    // By default, this is set to 5000, so that for the common case of simulating with 1 pico-second precision, the phase-shift is 5 nano-seconds. Users should use the
    // <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
    // See <Configuration of Time-Units> for background on configuration of time-units.
    // 
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    longint unsigned config_clk_phase_shift;

    // Variable:- config_clk_1st_time
    //
    //  The number of simulator time-steps for the first phase of the repeating clock signal (<ACLK>) generated by the <mgc_axi4> Questa Verification IP built-in clock generator.
    // 
    // By default, this is set to 5000, so that for the common case of simulating with 1 pico-second precision, the phase is 5 nano-seconds. Users should use the
    // <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
    // See <Configuration of Time-Units> for background on configuration of time-units.
    // 
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    longint unsigned config_clk_1st_time;

    // Variable:- config_clk_2nd_time
    //
    //  The number of simulator time-steps for the second phase of the repeating clock signal (<ACLK>) generated by the <mgc_axi4> Questa Verification IP built-in clock generator.
    // 
    // By default, this is set to 5000, so that for the common case of simulating with 1 pico-second precision, the phase is 5 nano-seconds. Users should use the
    // <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
    // See <Configuration of Time-Units> for background on configuration of time-units.
    // 
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    longint unsigned config_clk_2nd_time;

    // Variable:- config_setup_time
    //
    //  The setup-time, in units of simulator time-steps, for all signals. By default this is set to 0. Users should use the
    // <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
    // See <Configuration of Time-Units> for background on configuration of time-units.
    // 
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    longint unsigned config_setup_time;

    // Variable:- config_hold_time
    //
    //  The hold-time, in units of simulator time-steps, for all signals. By default this is set to 0. Users should use the
    // <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
    // See <Configuration of Time-Units> for background on configuration of time-units.
    // 
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    longint unsigned config_hold_time;

    // Variable:- config_burst_timeout_factor
    //
    //  The maximum number of clock-periods between phases.
    // 
    // This causes a timeout when an unreasonable time passes between transaction phases. It defaults to 10000 clock periods.
    // 
    //
    int unsigned config_burst_timeout_factor;

    // Variable:- config_max_transaction_time_factor
    //
    int unsigned config_max_transaction_time_factor;

    // Variable:- config_write_ctrl_first_ratio
    //
    // Data starts at same time as or after control phase.  Response follows data.
    //
    int config_write_ctrl_first_ratio;

    // Variable:- config_write_data_first_ratio
    //
    // control phase starts at same time as or after data phase.  Response follows data.
    //
    int config_write_data_first_ratio;

    // Variable:- config_reset_low_clocks
    //
    //  The number of clock-periods for which reset will be driven low (if the abstraction-level of the reset_source interface end is set to TLM-connected). This defaults to 5 clock-periods.
    // 
    //
    int config_reset_low_clocks;

    // Variable:- config_reset_hold_time
    //
    // The delay, as a number of simulator time-steps, after a rising clock edge before the reset signal (<ARESETn>) generated by the <mgc_axi4> Questa Verification IP built-in reset generator changes to inactive high.
    // By default this has the value 0. Users should use the <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
    //  See <Configuration of Time-Units> for background on configuration of time-units.
    // 
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    int config_reset_hold_time;

    // Variable:- config_enable_rlast
    //
    //  A configuration parameter controlling whether the optional <RLAST> signal is used, or not.
    // 
    // <RLAST> is an optional input to the master, because the length of a read burst is always known (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.3.5).
    // 
    //
    bit config_enable_rlast;

    // Variable:- config_enable_slave_exclusive
    //
    //  A configuration parameter controlling whether the slave supports exclusive accesses. (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.5)
    // 
    // By default this is set to true so that the slave will support exclusive accesses by responding with <AXI4_EXOKAY>.
    // 
    // The coverage collected by the covergroup <axi4_coverage::axi4_cvg> is affected by this parameter value setting.
    // 
    //
    bit config_enable_slave_exclusive;

    // Variable:- config_enable_burst_reserved_value
    //
    //  A configuration parameter controlling whether the <axi4_burst_e> reserved value <AXI4_RESERVED> is allowed as a legal value for the 'burst' parameter of <axi4_master_write>/<axi4_master_read>.
    // 
    // To enable this value, set the flag to 1(true) by e.g. config.m_bfm.set_config_enable_burst_reserved_value(1'b1). By default this has the value 0 (false).
    // 
    //
    bit config_enable_burst_reserved_value;

    // Variable:- config_enable_cache_value
    //
    //  An array of configuration parameters controlling whether individual reserved values of the <axi4_master_write::cache>/<axi4_master_read::cache> parameter (of type <axi4_cache_e>) are allowed as legal values of the AxCACHE signal.
    // 
    // To enable an individual reserved value, set the flag to 1 (true) by e.g. config.m_bfm.set_config_enable_cache_value_index1( <AXI4_CACHE_RSVD_12>, 1'b1). To enable all reserved values, do config.set_config_enable_cache_value('1); 
    // 
    // See Also:
    // The <axi4_payload_error_sequence::body()> function shows how this feature may be exercised. The following covergroups are used to collect coverage of these parameter values:
    // + <axi4_coverage::coverage_of_cache_rsvd_4_value>
    // + <axi4_coverage::coverage_of_cache_rsvd_5_value>
    // + <axi4_coverage::coverage_of_cache_rsvd_8_value>
    // + <axi4_coverage::coverage_of_cache_rsvd_9_value>
    // + <axi4_coverage::coverage_of_cache_rsvd_12_value>
    // + <axi4_coverage::coverage_of_cache_rsvd_13_value>
    // 
    // <Error Injection in AXI4> gives a fuller description of configurable error-injection.
    // 
    //
    bit [15:0] config_enable_cache_value;

    // Variable:- internal_dummy_variable
    //
    //  A variable required for internal technical reasons. Ignore it (changes to this will have no effect on behavior).
    // 
    //
    axi4_error_e internal_dummy_variable;

    // Variable:- config_axi4lite_interface
    //
    //  If user want to use QVIP BFM on the axi4lite interface, then this
    //  configuration variable should be set to true.
    // 
    //
    bit config_axi4lite_interface;

    // Variable:- config_axi4lite_tr_id
    //
    //  Configuration variable to set ID to a fixed value when QVIP BFM is configured as axi4lite
    // 
    //
    bit [((AXI4_ID_WIDTH) - 1):0]  config_axi4lite_tr_id;

    // Variable:- config_enable_all_assertions
    //
    //  Configuration parameter controlling whether the error messages(Assertions) issued from the QVIP are Enabled or Disabled.  
    //      By default, it is enabled.
    //   
    //
    bit config_enable_all_assertions;

    // Variable:- config_enable_assertion
    //
    //  An array of configuration parameters controlling whether specific error messages(Assertion) can be issued by the QVIP.
    //      By default, all errors are enabled. 
    //      To suppress a particular error, set the corresponding bit to 0 (false).
    //   
    //
    bit [255:0] config_enable_assertion;

    // Variable:- config_enable_error
    //
    //  This configuration variable is deprecated. Please use <config_enable_assertion> variable for this functionality.
    // An array of configuration parameters controlling whether specific error messages (of type <axi4_error_e>) can be issued by the Questa Verification IP. 
    // By default, all errors (excepting <AXI4_WRITE_DATA_BEFORE_ADDRESS>) are enabled. To suppress a particular error, set the corresponding bit to 0 (false) by e.g. config.m_bfm.set_config_enable_error_index1(<AXI4_WRITE_DATA_BEFORE_ADDRESS>, 0);
    // 
    //
    bit [255:0] config_enable_error;

    // Variable:- config_max_latency_AWVALID_assertion_to_AWREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <AWVALID> to the assertion of <AWREADY> (default 10000).
    // 
    // The error message <AXI4_AWREADY_NOT_ASSERTED_AFTER_AWVALID> will be issued if this period elapses from the assertion of <AWVALID>.
    // 
    //
    int unsigned config_max_latency_AWVALID_assertion_to_AWREADY;

    // Variable:- config_max_latency_ARVALID_assertion_to_ARREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <ARVALID> to the assertion of <ARREADY> (default 10000).
    // 
    // The error message <AXI4_ARREADY_NOT_ASSERTED_AFTER_ARVALID> will be issued if this period elapses from the assertion of <ARVALID>.
    // 
    //
    int unsigned config_max_latency_ARVALID_assertion_to_ARREADY;

    // Variable:- config_max_latency_RVALID_assertion_to_RREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <RVALID> to the assertion of <RREADY> (default 10000).
    // 
    // The error message <AXI4_RREADY_NOT_ASSERTED_AFTER_RVALID> will be issued if this period elapses from the assertion of <RVALID>.
    // 
    //
    int unsigned config_max_latency_RVALID_assertion_to_RREADY;

    // Variable:- config_max_latency_BVALID_assertion_to_BREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <BVALID> to the assertion of <BREADY> (default 10000).
    // 
    // The error message <AXI4_BREADY_NOT_ASSERTED_AFTER_BVALID> will be issued if this period elapses from the assertion of <BVALID>.
    // 
    //
    int unsigned config_max_latency_BVALID_assertion_to_BREADY;

    // Variable:- config_max_latency_WVALID_assertion_to_WREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <WVALID> to the assertion of <WREADY> (default 10000).
    // 
    // The error message <AXI4_WREADY_NOT_ASSERTED_AFTER_WVALID> will be issued if this period elapses from the assertion of <WVALID>.
    // 
    //
    int unsigned config_max_latency_WVALID_assertion_to_WREADY;

    // Variable:- config_enable_qos
    //
    //  A configuration parameter defining whether the master participates in the Quality-of-Service scheme  (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.1.2). 
    // 
    // This defaults to 'true' i.e. the master participates in the Quality-of-Service scheme. If a master does not participate, the <AWQOS>/<ARQOS> value used in write/read transactions must be b0000.
    // 
    //
    bit config_enable_qos;

    // Variable:- config_enable_region_support
    //
    //  A configuration parameter enabling region address decoding by the Questa Verification IP (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1).
    // 
    // When set to 'true', the Questa Verification IP will, during generation, perform an address decode function, using the <config_region> region map, and provide the
    //  <axi4_master_rw_transaction::region>, <axi4_master_write::region>, <axi4_master_write::region> parameter values (ignoring any value provided by the user); during recognition the Questa Verification IP will check the observed region value against the region map for correctness.
    // 
    // When set to 'false' (the default), the Questa Verification IP will not perform the decode function, and will pass the user-defined region parameter value to the slave; this supports error-injection (see <Error Injection in AXI4>).
    // 
    //
    bit config_enable_region_support;

    // Variable:- config_slave_regions
    //
    //  The number of regions supported by the slave end of this interface.
    // 
    // The system interconnect can provide an address decode of the address space into regions (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1), relieving the slave of the need to decode the address itself.   
    // 
    //  This defaults to <AXI4_REGION_MAP_SIZE>.
    // 
    //
    int config_slave_regions;

    // Variable:- config_region
    //
    //  An array of configurable system region map entries.
    // 
    // Each entry consists of a concatenation of the region lower-address boundary, upper-address boundary, region value and cachable/non-cacheable bit. The number of entries is given by <config_slave_regions>, and the size of the array by the configuration parameter <AXI4_REGION_MAP_SIZE> (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1 and A4.5).
    // 
    // When <config_enable_region_support> is set to true (1'b1), and no errors were detected in the region-map (<region_error_state>), constraints will be applied to enforce that the region parameter of <axi4_master_write>, <axi4_master_read>, <axi4_master_rw_transaction>, <axi4_master_write_addr_channel_phase> and <axi4_master_read_addr_channel_phase>) has the value defined in the region map for the given address. 
    // 
    // In addition, a constraint (for example, <axi4_master_write::exclusive_access_to_non_cacheable_address_region_constraint>) will be enforced to ensure that exclusive accesses can only be made to non-cacheable regions of the address map (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4 and A4.5). 
    // 
    // Here is example code for initializing the region map in SystemVerilog (for the case AXI4_ADDRESS_WIDTH = 32, AXI4_REGION_MAP_SIZE = 16). Note that the first entry in the array is at the end of the initializer!
    // 
    // (start code)
    //   typedef bit[AXI4_ADDRESS_WIDTH-1:0] Address;
    //   axi4_if.set_config_enable_region_support(1'b1);
    //   axi4_if.set_config_slave_regions(16);
    //   axi4_if.set_config_region(config_t::axi4_region_map_t'{
    //     // lower-bound address   upper-bound address    region cacheable
    //     {Address'(32'hf0000000), Address'(32'hffffffff),4'hf, 1'b0},
    //     {Address'(32'he0000000), Address'(32'hefffffff),4'he, 1'b0},
    //     {Address'(32'hd0000000), Address'(32'hdfffffff),4'hd, 1'b0},
    //     {Address'(32'hc0000000), Address'(32'hcfffffff),4'hc, 1'b0},
    //     {Address'(32'hb0000000), Address'(32'hbfffffff),4'hb, 1'b0},
    //     {Address'(32'ha0000000), Address'(32'hafffffff),4'ha, 1'b0},
    //     {Address'(32'h90000000), Address'(32'h9fffffff),4'h9, 1'b0},
    //     {Address'(32'h80000000), Address'(32'h8fffffff),4'h8, 1'b1},
    //     {Address'(32'h70000000), Address'(32'h7fffffff),4'h7, 1'b1},
    //     {Address'(32'h60000000), Address'(32'h6fffffff),4'h6, 1'b1},
    //     {Address'(32'h50000000), Address'(32'h5fffffff),4'h5, 1'b1},
    //     {Address'(32'h40000000), Address'(32'h4fffffff),4'h4, 1'b1},
    //     {Address'(32'h30000000), Address'(32'h3fffffff),4'h3, 1'b1},
    //     {Address'(32'h20000000), Address'(32'h2fffffff),4'h2, 1'b1},
    //     {Address'(32'h10000000), Address'(32'h1fffffff),4'h1, 1'b1},
    //     {Address'(32'h00000000), Address'(32'h0fffffff),4'h0, 1'b1}
    //   });
    // (end code)
    // 
    // Note the use of the axi4_region_map_t type defined in <axi4_vip_config>, to avoid conversion problems on some simulators.
    // 
    // 
    //
    bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  config_region;

    // Variable:- config_read_data_reordering_depth
    //
    //  A configuration parameter defining the read reordering depth of the slave end of the interface (see AMBA AXI and ACE Protocol Specification IHI0022D section A5.3.1).
    // 
    // Responses from the first <config_read_data_reordering_depth> outstanding read transactions, each with address <ARID> values different from any
    //  earlier outstanding read transaction(as seen by the slave) are expected, interleaved at random. A violation causes a <AXI4_READ_REORDERING_VIOLATION> error.
    // 
    // The default value of <config_read_data_reordering_depth> is (1 << AXI4_ID_WIDTH), so that the slave is expected to process all transactions in any order (up to uniqueness of <ARID>).
    // 
    // For a given <AXI4_ID_WIDTH> parameter value, the maximum possible value of <config_read_data_reordering_depth> is 2**AXI4_ID_WIDTH. The <AXI4_PARAM_READ_REORDERING_DEPTH_EXCEEDS_MAX_ID>
    //  error report will be issued if <config_read_data_reordering_depth> exceeds this value.
    // 
    // If the user-supplied value is 0, the <AXI4_PARAM_READ_REORDERING_DEPTH_EQUALS_ZERO> error will be issued, and the value will be set to 1.
    // 
    //
    int unsigned config_read_data_reordering_depth;

    // Variable:- config_slave_start_addr
    //
    //  A configuration parameter indicating start address for slave.
    // 
    //
    bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr;

    // Variable:- config_slave_end_addr
    //
    //  A configuration parameter indicating end address for slave.
    // 
    //
    bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr;

    // Variable:- config_slave_enabled_non_contiguous_address_spaces
    //
    // 
    //    This variable is used to configure the number of enabled non-contiguous address spaces for AXI4 Slaves in the system.
    //    By default, it is assumed that AXI4 slave posses only one contiguous address space. The default value of this configuration is 1.  
    //    If this configuration is set to (let's say 10), it indicates that the AXI4 slave in the system possess 10 non-contiguous address spaces.
    //    Default value is 1.
    //    Please note that this configuration shall come into effect only when the AXI4 slaves in the system support multiple non-contiguous address spaces. (i.e. config_slave_possess_multiple_non_contiguous_address_spaces = 0b1) 
    // 
    //
    int config_slave_enabled_non_contiguous_address_spaces;

    // Variable:- config_slave_possess_multiple_non_contiguous_address_spaces
    //
    // 
    //    This variable is used to configure whether AXI4 Slaves in the system possess multiple non-contiguous address space.
    //    If this configuration is set to False, it indicate that AXI4 slaves in the system possess single contiguous address space.
    //    If this configuration is set to True, it indicate that AXI4 slaves in the system possess multiple contiguous address spaces.
    //    Default value is False.
    // 
    //
    bit config_slave_possess_multiple_non_contiguous_address_spaces;

    // Variable:- config_slave_multiple_non_contiguous_start_address_range
    //
    // 
    //    This variable is used to configure the Start Addresses of all the non-contiguous address spaces for the Various AXI4 Slaves in the system.
    //    Address map for the for a particular non-contiguous address space in the slave - Start Address for that non-contiguous address space in the Slave
    // 
    //
    bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_start_address_range;

    // Variable:- config_slave_multiple_non_contiguous_end_address_range
    //
    // 
    //    This variable is used to configure the End Addresses of all the non-contiguous address spaces for the Various AXI4 Slaves in the system.
    //    Address map for the for a particular non-contiguous address space in the slave - End Address for that non-contiguous address space in the Slave
    // 
    //
    bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_end_address_range;

    // Variable:- config_protect_ready
    //
    //  A configuration parameter controlling whether the wave display will show transaction items representing the state of the <mgc_axi4::AWREADY>, <mgc_axi4::ARREADY>, <mgc_axi4::BREADY>, <mgc_axi4::WREADY> and <mgc_axi4::RREADY> signals. 
    // 
    // If set to 1'b0, the transaction items will be shown on the wave display. Since this display has a performance penalty, the default value of this parameter is 1'b1 (i.e. do not display).
    // 
    //
    bit config_protect_ready;

    // Variable:- config_max_outstanding_wr
    //
    int config_max_outstanding_wr;

    // Variable:- config_max_outstanding_rd
    //
    int config_max_outstanding_rd;

    // Variable:- config_num_outstanding_wr_phase
    //
    int config_num_outstanding_wr_phase;

    // Variable:- config_num_outstanding_rd_phase
    //
    int config_num_outstanding_rd_phase;

    // Variable:- config_enable_warnings
    //
    // A configuration parameter controlling whether warning messages are to be output.  This defaults to 1'b1 i.e. output warnings.
    //
    bit config_enable_warnings;

    // Variable:- config_enable_errors
    //
    //  This configuration variable is deprecated. Please use <config_enable_all_assertions> variable for this functionality.
    //    A configuration parameter controlling whether error messages are to be output.  This defaults to 1'b1 i.e. output error messages.
    // 
    //
    bit config_enable_errors;

    // Variable:- config_enable_exclusive_checks
    //
    // A configuration parameter controlling whether error messages related to exclusive accesses are to be output.  This defaults to 1'b1 i.e. output error messages.
    //
    bit config_enable_exclusive_checks;

    // Variable:- config_warn_on_slave_errors
    //
    //  A configuration parameter controlling whether an error message is to be issued in the case where the slave returns a response indicating an error. (This default to 1'b1 i.e. output error messages).
    // 
    // An error response (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.4) from the slave end occurs when
    // + the interconnect responds with <AXI4_DECERR> because it cannot locate a slave at the transaction address;
    // + the slave responds with <AXI4_SLVERR> because it wishes to signal an error condition to the master;
    // 
    // 
    //
    bit config_warn_on_slave_errors;

    // Variable:- config_error_on_deleted_valid_cycles
    //
    //  A configuration parameter controlling whether an error message will be issued when a valid transaction item is not recognized. 
    // 
    // When set to 1'b1 (the default), an error message will be issued.
    // 
    //
    bit config_error_on_deleted_valid_cycles;

    // Variable:- config_stats_enable
    //
    bit config_stats_enable;

    // Variable:- config_stats_enable_read_occupancy
    //
    bit config_stats_enable_read_occupancy;

    // Variable:- config_stats_enable_write_occupancy
    //
    bit config_stats_enable_write_occupancy;

    // Variable:- config_stats_enable_read_data_occupancy
    //
    bit config_stats_enable_read_data_occupancy;

    // Variable:- config_stats_enable_write_data_occupancy
    //
    bit config_stats_enable_write_data_occupancy;

    // Variable:- config_stats_enable_read_latency
    //
    bit config_stats_enable_read_latency;

    // Variable:- config_stats_enable_write_latency
    //
    bit config_stats_enable_write_latency;

    // Variable:- config_stats_enable_read_address_waits
    //
    bit config_stats_enable_read_address_waits;

    // Variable:- config_stats_enable_read_data_waits
    //
    bit config_stats_enable_read_data_waits;

    // Variable:- config_stats_enable_write_address_waits
    //
    bit config_stats_enable_write_address_waits;

    // Variable:- config_stats_enable_write_data_waits
    //
    bit config_stats_enable_write_data_waits;

    // Variable:- config_stats_enable_write_response_waits
    //
    bit config_stats_enable_write_response_waits;

    // Variable:- config_stats_enable_read_bandwidth
    //
    bit config_stats_enable_read_bandwidth;

    // Variable:- config_stats_enable_write_bandwidth
    //
    bit config_stats_enable_write_bandwidth;

    // Variable:- config_stats_read_occupancy_step
    //
    int config_stats_read_occupancy_step;

    // Variable:- config_stats_read_occupancy_multiple
    //
    int config_stats_read_occupancy_multiple;

    // Variable:- config_stats_write_occupancy_step
    //
    int config_stats_write_occupancy_step;

    // Variable:- config_stats_write_occupancy_multiple
    //
    int config_stats_write_occupancy_multiple;

    // Variable:- config_stats_read_data_occupancy_step
    //
    int config_stats_read_data_occupancy_step;

    // Variable:- config_stats_read_data_occupancy_multiple
    //
    int config_stats_read_data_occupancy_multiple;

    // Variable:- config_stats_write_data_occupancy_step
    //
    int config_stats_write_data_occupancy_step;

    // Variable:- config_stats_write_data_occupancy_multiple
    //
    int config_stats_write_data_occupancy_multiple;

    // Variable:- config_stats_read_bandwidth_step
    //
    int config_stats_read_bandwidth_step;

    // Variable:- config_stats_read_bandwidth_multiple
    //
    int config_stats_read_bandwidth_multiple;

    // Variable:- config_stats_write_bandwidth_step
    //
    int config_stats_write_bandwidth_step;

    // Variable:- config_stats_write_bandwidth_multiple
    //
    int config_stats_write_bandwidth_multiple;

    // Variable:- config_stats_read_latency_step
    //
    int config_stats_read_latency_step;

    // Variable:- config_stats_read_latency_multiple
    //
    int config_stats_read_latency_multiple;

    // Variable:- config_stats_write_latency_step
    //
    int config_stats_write_latency_step;

    // Variable:- config_stats_write_latency_multiple
    //
    int config_stats_write_latency_multiple;

    // Variable:- config_stats_read_address_waits_step
    //
    int config_stats_read_address_waits_step;

    // Variable:- config_stats_read_address_waits_multiple
    //
    int config_stats_read_address_waits_multiple;

    // Variable:- config_stats_read_data_waits_step
    //
    int config_stats_read_data_waits_step;

    // Variable:- config_stats_read_data_waits_multiple
    //
    int config_stats_read_data_waits_multiple;

    // Variable:- config_stats_write_address_waits_step
    //
    int config_stats_write_address_waits_step;

    // Variable:- config_stats_write_address_waits_multiple
    //
    int config_stats_write_address_waits_multiple;

    // Variable:- config_stats_write_data_waits_step
    //
    int config_stats_write_data_waits_step;

    // Variable:- config_stats_write_data_waits_multiple
    //
    int config_stats_write_data_waits_multiple;

    // Variable:- config_stats_write_response_waits_step
    //
    int config_stats_write_response_waits_step;

    // Variable:- config_stats_write_response_waits_multiple
    //
    int config_stats_write_response_waits_multiple;

    //------------------------------------------------------------------------------
    // Global Variables - status
    //------------------------------------------------------------------------------

    // Variable:- region_error_state
    //
    //  A read-only flag, internally set to true if there had been an error with the region specification provided by the user.
    // 
    // If true, behave as though <config_enable_region_support> is false. 
    // 
    // 
    //
    bit region_error_state;

    // Variable:- region_map_lb
    //
    //  An array showing the lower address bound for each region in the <config_region> region map. This is extracted from the user-supplied <config_region>, and is non-modifiable.
    // 
    // Although the information is already present in <config_region>, on certain simulators it was not usable within constraints, and had to be extracted into a separate array. 
    // 
    //
    longint unsigned region_map_lb [((AXI4_REGION_MAP_SIZE) - 1):0];

    // Variable:- region_map_ub
    //
    //  An array showing the upper address bound for each region in the <config_region> region map. This is extracted from the user-supplied <config_region>, and is non-modifiable.
    // 
    // Although the information is already present in <config_region>, on certain simulators it was not usable within constraints, and had to be extracted into a separate array. 
    // 
    //
    longint unsigned region_map_ub [((AXI4_REGION_MAP_SIZE) - 1):0];

    // Variable:- region_map_region
    //
    //  An array showing the regions in the <config_region> region map. This is extracted from the user-supplied <config_region>, and is non-modifiable.
    // 
    // Although the information is already present in <config_region>, on certain simulators it was not usable within constraints, and had to be extracted into a separate array. 
    // 
    //
    byte unsigned region_map_region [((AXI4_REGION_MAP_SIZE) - 1):0];

    // Variable:- cacheable
    //
    //  An array showing the cacheability of each region in the <config_region> region map. This is extracted from the user-supplied <config_region>, and is non-modifiable.
    // 
    // Although the information is already present in <config_region>, on certain simulators it was not usable within constraints, and had to be extracted into a separate array. 
    // 
    //
    byte unsigned cacheable [((AXI4_REGION_MAP_SIZE) - 1):0];

    // Variable:- master_end_tlm_status
    //
    //  A status variable indicating whether the master end of the interface is TLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    // Once the end is set as TLM-connected, it should not be changed.
    // 
    //
    bit master_end_tlm_status;

    // Variable:- master_end_wlm_status
    //
    //  A status variable indicating whether the master end of the interface is WLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    //
    bit master_end_wlm_status;

    // Variable:- slave_end_tlm_status
    //
    //  A status variable indicating whether the slave end of the interface is TLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    // Once the end is set as TLM-connected, it should not be changed.
    // 
    //
    bit slave_end_tlm_status;

    // Variable:- slave_end_wlm_status
    //
    //  A status variable indicating whether the slave end of the interface is WLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    //
    bit slave_end_wlm_status;

    // Variable:- clock_source_end_tlm_status
    //
    //  A status variable indicating whether the clock_source end of the interface is TLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    // Once the end is set as TLM-connected, it should not be changed.
    // 
    //
    bit clock_source_end_tlm_status;

    // Variable:- clock_source_end_wlm_status
    //
    //  A status variable indicating whether the clock_source end of the interface is WLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    //
    bit clock_source_end_wlm_status;

    // Variable:- reset_source_end_tlm_status
    //
    //  A status variable indicating whether the reset_source end of the interface is TLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    // Once the end is set as TLM-connected, it should not be changed.
    // 
    //
    bit reset_source_end_tlm_status;

    // Variable:- reset_source_end_wlm_status
    //
    //  A status variable indicating whether the reset_source end of the interface is WLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    //
    bit reset_source_end_wlm_status;

    // Variable:- stats_rw_transaction_last_duration
    //
    int stats_rw_transaction_last_duration;

    // Variable:- stats_read_active
    //
    bit stats_read_active;

    // Variable:- stats_read_occupancy_sw
    //
    int stats_read_occupancy_sw;

    // Variable:- stats_read_idle_sw
    //
    int stats_read_idle_sw;

    // Variable:- stats_read_occupancy_min
    //
    int stats_read_occupancy_min;

    // Variable:- stats_read_idle_min
    //
    int stats_read_idle_min;

    // Variable:- stats_read_occupancy_max
    //
    int stats_read_occupancy_max;

    // Variable:- stats_read_idle_max
    //
    int stats_read_idle_max;

    // Variable:- stats_read_occupancy_mean
    //
    int stats_read_occupancy_mean;

    // Variable:- stats_read_idle_mean
    //
    int stats_read_idle_mean;

    // Variable:- stats_read_last_duration
    //
    int stats_read_last_duration;

    // Variable:- stats_write_active
    //
    bit stats_write_active;

    // Variable:- stats_write_occupancy_sw
    //
    int stats_write_occupancy_sw;

    // Variable:- stats_write_idle_sw
    //
    int stats_write_idle_sw;

    // Variable:- stats_write_occupancy_min
    //
    int stats_write_occupancy_min;

    // Variable:- stats_write_idle_min
    //
    int stats_write_idle_min;

    // Variable:- stats_write_occupancy_max
    //
    int stats_write_occupancy_max;

    // Variable:- stats_write_idle_max
    //
    int stats_write_idle_max;

    // Variable:- stats_write_occupancy_mean
    //
    int stats_write_occupancy_mean;

    // Variable:- stats_write_idle_mean
    //
    int stats_write_idle_mean;

    // Variable:- stats_write_last_duration
    //
    int stats_write_last_duration;

    // Variable:- stats_read_data_occupancy_sw
    //
    int stats_read_data_occupancy_sw;

    // Variable:- stats_read_data_idle_sw
    //
    int stats_read_data_idle_sw;

    // Variable:- stats_read_data_occupancy_min
    //
    int stats_read_data_occupancy_min;

    // Variable:- stats_read_data_idle_min
    //
    int stats_read_data_idle_min;

    // Variable:- stats_read_data_occupancy_max
    //
    int stats_read_data_occupancy_max;

    // Variable:- stats_read_data_idle_max
    //
    int stats_read_data_idle_max;

    // Variable:- stats_read_data_occupancy_mean
    //
    int stats_read_data_occupancy_mean;

    // Variable:- stats_read_data_idle_mean
    //
    int stats_read_data_idle_mean;

    // Variable:- stats_write_data_occupancy_sw
    //
    int stats_write_data_occupancy_sw;

    // Variable:- stats_write_data_idle_sw
    //
    int stats_write_data_idle_sw;

    // Variable:- stats_write_data_occupancy_min
    //
    int stats_write_data_occupancy_min;

    // Variable:- stats_write_data_idle_min
    //
    int stats_write_data_idle_min;

    // Variable:- stats_write_data_occupancy_max
    //
    int stats_write_data_occupancy_max;

    // Variable:- stats_write_data_idle_max
    //
    int stats_write_data_idle_max;

    // Variable:- stats_write_data_occupancy_mean
    //
    int stats_write_data_occupancy_mean;

    // Variable:- stats_write_data_idle_mean
    //
    int stats_write_data_idle_mean;

    // Variable:- stats_read_bandwidth_sw
    //
    int stats_read_bandwidth_sw;

    // Variable:- stats_read_bandwidth_min
    //
    int stats_read_bandwidth_min;

    // Variable:- stats_read_bandwidth_max
    //
    int stats_read_bandwidth_max;

    // Variable:- stats_read_bandwidth_mean
    //
    int stats_read_bandwidth_mean;

    // Variable:- stats_write_bandwidth_sw
    //
    int stats_write_bandwidth_sw;

    // Variable:- stats_write_bandwidth_min
    //
    int stats_write_bandwidth_min;

    // Variable:- stats_write_bandwidth_max
    //
    int stats_write_bandwidth_max;

    // Variable:- stats_write_bandwidth_mean
    //
    int stats_write_bandwidth_mean;

    // Variable:- stats_read_address_data_latency_inst
    //
    int stats_read_address_data_latency_inst;

    // Variable:- stats_read_address_data_latency_sw
    //
    int stats_read_address_data_latency_sw;

    // Variable:- stats_read_address_data_latency_min
    //
    int stats_read_address_data_latency_min;

    // Variable:- stats_read_address_data_latency_max
    //
    int stats_read_address_data_latency_max;

    // Variable:- stats_read_address_data_latency_mean
    //
    int stats_read_address_data_latency_mean;

    // Variable:- stats_read_address_address_latency_inst
    //
    int stats_read_address_address_latency_inst;

    // Variable:- stats_read_address_address_latency_sw
    //
    int stats_read_address_address_latency_sw;

    // Variable:- stats_read_address_address_latency_min
    //
    int stats_read_address_address_latency_min;

    // Variable:- stats_read_address_address_latency_max
    //
    int stats_read_address_address_latency_max;

    // Variable:- stats_read_address_address_latency_mean
    //
    int stats_read_address_address_latency_mean;

    // Variable:- stats_write_address_response_latency_inst
    //
    int stats_write_address_response_latency_inst;

    // Variable:- stats_write_address_response_latency_sw
    //
    int stats_write_address_response_latency_sw;

    // Variable:- stats_write_address_response_latency_min
    //
    int stats_write_address_response_latency_min;

    // Variable:- stats_write_address_response_latency_max
    //
    int stats_write_address_response_latency_max;

    // Variable:- stats_write_address_response_latency_mean
    //
    int stats_write_address_response_latency_mean;

    // Variable:- stats_write_address_address_latency_inst
    //
    int stats_write_address_address_latency_inst;

    // Variable:- stats_write_address_address_latency_sw
    //
    int stats_write_address_address_latency_sw;

    // Variable:- stats_write_address_address_latency_min
    //
    int stats_write_address_address_latency_min;

    // Variable:- stats_write_address_address_latency_max
    //
    int stats_write_address_address_latency_max;

    // Variable:- stats_write_address_address_latency_mean
    //
    int stats_write_address_address_latency_mean;

    // Variable:- stats_read_address_waits_inst
    //
    int stats_read_address_waits_inst;

    // Variable:- stats_read_address_waits_sw
    //
    int stats_read_address_waits_sw;

    // Variable:- stats_read_address_waits_min
    //
    int stats_read_address_waits_min;

    // Variable:- stats_read_address_waits_max
    //
    int stats_read_address_waits_max;

    // Variable:- stats_read_address_waits_mean
    //
    int stats_read_address_waits_mean;

    // Variable:- stats_read_data_waits_inst
    //
    int stats_read_data_waits_inst;

    // Variable:- stats_read_data_waits_sw
    //
    int stats_read_data_waits_sw;

    // Variable:- stats_read_data_waits_min
    //
    int stats_read_data_waits_min;

    // Variable:- stats_read_data_waits_max
    //
    int stats_read_data_waits_max;

    // Variable:- stats_read_data_waits_mean
    //
    int stats_read_data_waits_mean;

    // Variable:- stats_write_address_waits_inst
    //
    int stats_write_address_waits_inst;

    // Variable:- stats_write_address_waits_sw
    //
    int stats_write_address_waits_sw;

    // Variable:- stats_write_address_waits_min
    //
    int stats_write_address_waits_min;

    // Variable:- stats_write_address_waits_max
    //
    int stats_write_address_waits_max;

    // Variable:- stats_write_address_waits_mean
    //
    int stats_write_address_waits_mean;

    // Variable:- stats_write_data_waits_inst
    //
    int stats_write_data_waits_inst;

    // Variable:- stats_write_data_waits_sw
    //
    int stats_write_data_waits_sw;

    // Variable:- stats_write_data_waits_min
    //
    int stats_write_data_waits_min;

    // Variable:- stats_write_data_waits_max
    //
    int stats_write_data_waits_max;

    // Variable:- stats_write_data_waits_mean
    //
    int stats_write_data_waits_mean;

    // Variable:- stats_write_response_waits_inst
    //
    int stats_write_response_waits_inst;

    // Variable:- stats_write_response_waits_sw
    //
    int stats_write_response_waits_sw;

    // Variable:- stats_write_response_waits_min
    //
    int stats_write_response_waits_min;

    // Variable:- stats_write_response_waits_max
    //
    int stats_write_response_waits_max;

    // Variable:- stats_write_response_waits_mean
    //
    int stats_write_response_waits_mean;

    // Variable:- reordering_depth_of_last_read_transaction
    //
    //  The read reordering depth at which the first response to the last read transaction arrived (see AMBA AXI and ACE Protocol Specification IHI0022D section A5.3.1)
    // 
    // For <config_read_data_reordering_depth> equal to 1, responses to read transactions must arrive in the order of issuing the read addresses,
    // and all responses for a transaction must have arrived before any response to a later transaction arrive.
    // When the <config_read_data_reordering_depth> is greater than 1, the first responses to read transactions must still arrive in the order of issuing the read addresses,
    // but responses to later transactions do not have to wait until all responses to earlier transactions have arrived.
    // Instead, up to <config_read_data_reordering_depth> transactions can be receiving responses.
    // 
    // when the first response to a read transaction is observed, the Questa Verification IP records the position of this transaction is the queue of unfinished transactions;
    // at the end of the transaction, this value is copied to <reordering_depth_of_last_read_transaction>, so allowing coverage of the depth of read reordering.
    // This variable is read-only, and its value is overwritten by the next read transaction to finish.
    // 
    //
    int reordering_depth_of_last_read_transaction;


    //------------------------------------------------------------------------------
    // Assertions
    //------------------------------------------------------------------------------
    // Documentation for assertions has been moved to <axi4_assertions.svh>.

    import "DPI-C" context axi4_get_axi4_master_end = function longint axi4_get_axi4_master_end();
    import "DPI-C" context axi4_get_axi4_slave_end = function longint axi4_get_axi4_slave_end();
    import "DPI-C" context axi4_get_axi4_clock_source_end = function longint axi4_get_axi4_clock_source_end();
    import "DPI-C" context axi4_get_axi4_reset_source_end = function longint axi4_get_axi4_reset_source_end();
    import "DPI-C" context axi4_get_axi4__monitor_end = function longint axi4_get_axi4__monitor_end();
    // Declare user visible wires variables, for non-continuous assignments.
    logic m_ACLK = 'z;
    logic m_ARESETn = 'z;
    logic m_AWVALID = 'z;
    logic [((AXI4_ADDRESS_WIDTH) - 1):0]  m_AWADDR = 'z;
    logic [2:0] m_AWPROT = 'z;
    logic [3:0] m_AWREGION = 'z;
    logic [7:0] m_AWLEN = 'z;
    logic [2:0] m_AWSIZE = 'z;
    logic [1:0] m_AWBURST = 'z;
    logic m_AWLOCK = 'z;
    logic [3:0] m_AWCACHE = 'z;
    logic [3:0] m_AWQOS = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  m_AWID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  m_AWUSER = 'z;
    logic m_AWREADY = 'z;
    logic m_ARVALID = 'z;
    logic [((AXI4_ADDRESS_WIDTH) - 1):0]  m_ARADDR = 'z;
    logic [2:0] m_ARPROT = 'z;
    logic [3:0] m_ARREGION = 'z;
    logic [7:0] m_ARLEN = 'z;
    logic [2:0] m_ARSIZE = 'z;
    logic [1:0] m_ARBURST = 'z;
    logic m_ARLOCK = 'z;
    logic [3:0] m_ARCACHE = 'z;
    logic [3:0] m_ARQOS = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  m_ARID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  m_ARUSER = 'z;
    logic m_ARREADY = 'z;
    logic m_RVALID = 'z;
    logic [((AXI4_RDATA_WIDTH) - 1):0]  m_RDATA = 'z;
    logic [1:0] m_RRESP = 'z;
    logic m_RLAST = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  m_RID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  m_RUSER = 'z;
    logic m_RREADY = 'z;
    logic m_WVALID = 'z;
    logic [((AXI4_WDATA_WIDTH) - 1):0]  m_WDATA = 'z;
    logic [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  m_WSTRB = 'z;
    logic m_WLAST = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  m_WUSER = 'z;
    logic m_WREADY = 'z;
    logic m_BVALID = 'z;
    logic [1:0] m_BRESP = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  m_BID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  m_BUSER = 'z;
    logic m_BREADY = 'z;

    // Forces a sweep through the wire change checkers at time 0 to get around process kick-off order unknowns
    bit _check_t0_values;
    always_comb _check_t0_values = 1;


    //------------------------------------------------------------------------------
    // Generic Interface Configuration Support
    //------------------------------------------------------------------------------

    import "DPI-C" context axi4_set_interface = function void axi4_set_interface
    (
        input int what,
        input int arg1,
        input int arg2,
        input int arg3,
        input int arg4,
        input int arg5,
        input int arg6,
        input int arg7,
        input int arg8,
        input int arg9,
        input int arg10
    );
    import "DPI-C" context axi4_get_interface = function int axi4_get_interface
    (
        input int what,
        input int arg1,
        input int arg2,
        input int arg3,
        input int arg4,
        input int arg5,
        input int arg6,
        input int arg7,
        input int arg8,
        input int arg9
    );
    //------------------------------------------------------------------------------
    // Functions to get the hierarchic name of this interface
    //------------------------------------------------------------------------------
    import "DPI-C" context axi4_get_full_name = function string axi4_get_full_name();

    //------------------------------------------------------------------------------
    // Abstraction level Support
    //------------------------------------------------------------------------------

    import "DPI-C" context axi4_set_master_end_abstraction_level = function void axi4_set_master_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi4_get_master_end_abstraction_level = function void axi4_get_master_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    import "DPI-C" context axi4_set_slave_end_abstraction_level = function void axi4_set_slave_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi4_get_slave_end_abstraction_level = function void axi4_get_slave_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    import "DPI-C" context axi4_set_clock_source_end_abstraction_level = function void axi4_set_clock_source_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi4_get_clock_source_end_abstraction_level = function void axi4_get_clock_source_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    import "DPI-C" context axi4_set_reset_source_end_abstraction_level = function void axi4_set_reset_source_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi4_get_reset_source_end_abstraction_level = function void axi4_get_reset_source_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );

    //------------------------------------------------------------------------------
    // Wire Level Interface Support
    //------------------------------------------------------------------------------
    logic internal_ACLK = 'z;
    logic internal_ARESETn = 'z;
    logic internal_AWVALID = 'z;
    logic [((AXI4_ADDRESS_WIDTH) - 1):0]  internal_AWADDR = 'z;
    logic [2:0] internal_AWPROT = 'z;
    logic [3:0] internal_AWREGION = 'z;
    logic [7:0] internal_AWLEN = 'z;
    logic [2:0] internal_AWSIZE = 'z;
    logic [1:0] internal_AWBURST = 'z;
    logic internal_AWLOCK = 'z;
    logic [3:0] internal_AWCACHE = 'z;
    logic [3:0] internal_AWQOS = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  internal_AWID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  internal_AWUSER = 'z;
    logic internal_AWREADY = 'z;
    logic internal_ARVALID = 'z;
    logic [((AXI4_ADDRESS_WIDTH) - 1):0]  internal_ARADDR = 'z;
    logic [2:0] internal_ARPROT = 'z;
    logic [3:0] internal_ARREGION = 'z;
    logic [7:0] internal_ARLEN = 'z;
    logic [2:0] internal_ARSIZE = 'z;
    logic [1:0] internal_ARBURST = 'z;
    logic internal_ARLOCK = 'z;
    logic [3:0] internal_ARCACHE = 'z;
    logic [3:0] internal_ARQOS = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  internal_ARID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  internal_ARUSER = 'z;
    logic internal_ARREADY = 'z;
    logic internal_RVALID = 'z;
    logic [((AXI4_RDATA_WIDTH) - 1):0]  internal_RDATA = 'z;
    logic [1:0] internal_RRESP = 'z;
    logic internal_RLAST = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  internal_RID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  internal_RUSER = 'z;
    logic internal_RREADY = 'z;
    logic internal_WVALID = 'z;
    logic [((AXI4_WDATA_WIDTH) - 1):0]  internal_WDATA = 'z;
    logic [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  internal_WSTRB = 'z;
    logic internal_WLAST = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  internal_WUSER = 'z;
    logic internal_WREADY = 'z;
    logic internal_BVALID = 'z;
    logic [1:0] internal_BRESP = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  internal_BID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  internal_BUSER = 'z;
    logic internal_BREADY = 'z;

    import "DPI-C" context function longint axi4_initialise_SystemVerilog
    (
        int usage_code,
        input int AXI4_ADDRESS_WIDTH,
        input int AXI4_RDATA_WIDTH,
        input int AXI4_WDATA_WIDTH,
        input int AXI4_ID_WIDTH,
        input int AXI4_USER_WIDTH,
        input int AXI4_REGION_MAP_SIZE
    );

    // Handle to the linkage
    (* elab_init *) longint _interface_ref =
                                axi4_initialise_SystemVerilog
                                (
                                    18102076,
                                    AXI4_ADDRESS_WIDTH,
                                    AXI4_RDATA_WIDTH,
                                    AXI4_WDATA_WIDTH,
                                    AXI4_ID_WIDTH,
                                    AXI4_USER_WIDTH,
                                    AXI4_REGION_MAP_SIZE
                                ); // DPI call to create transactor (called at elaboration time as initialiser)


    import "DPI-C" context function void axi4_set_ACLK_from_SystemVerilog
    (
        input bit ACLK_param
    );
    import "DPI-C" context function void axi4_propagate_ACLK_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ACLK_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ACLK_from_CY;
    export "DPI-C" function axi4_initialise_ACLK_from_CY;

    import "DPI-C" context function void axi4_set_ARESETn_from_SystemVerilog
    (
        input logic ARESETn_param
    );
    import "DPI-C" context function void axi4_propagate_ARESETn_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARESETn_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARESETn_from_CY;
    export "DPI-C" function axi4_initialise_ARESETn_from_CY;

    import "DPI-C" context function void axi4_set_AWVALID_from_SystemVerilog
    (
        input logic AWVALID_param
    );
    import "DPI-C" context function void axi4_propagate_AWVALID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWVALID_from_CY;
    export "DPI-C" function axi4_initialise_AWVALID_from_CY;

    import "DPI-C" context function void axi4_set_AWADDR_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  AWADDR_param
    );
    import "DPI-C" context function void axi4_propagate_AWADDR_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWADDR_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWADDR_from_CY_index1;
    export "DPI-C" function axi4_initialise_AWADDR_from_CY;

    import "DPI-C" context function void axi4_set_AWPROT_from_SystemVerilog
    (
        input logic [2:0] AWPROT_param
    );
    import "DPI-C" context function void axi4_propagate_AWPROT_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWPROT_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWPROT_from_CY;
    export "DPI-C" function axi4_initialise_AWPROT_from_CY;

    import "DPI-C" context function void axi4_set_AWREGION_from_SystemVerilog
    (
        input logic [3:0] AWREGION_param
    );
    import "DPI-C" context function void axi4_propagate_AWREGION_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWREGION_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWREGION_from_CY;
    export "DPI-C" function axi4_initialise_AWREGION_from_CY;

    import "DPI-C" context function void axi4_set_AWLEN_from_SystemVerilog
    (
        input logic [7:0] AWLEN_param
    );
    import "DPI-C" context function void axi4_propagate_AWLEN_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWLEN_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWLEN_from_CY;
    export "DPI-C" function axi4_initialise_AWLEN_from_CY;

    import "DPI-C" context function void axi4_set_AWSIZE_from_SystemVerilog
    (
        input logic [2:0] AWSIZE_param
    );
    import "DPI-C" context function void axi4_propagate_AWSIZE_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWSIZE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWSIZE_from_CY;
    export "DPI-C" function axi4_initialise_AWSIZE_from_CY;

    import "DPI-C" context function void axi4_set_AWBURST_from_SystemVerilog
    (
        input logic [1:0] AWBURST_param
    );
    import "DPI-C" context function void axi4_propagate_AWBURST_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWBURST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWBURST_from_CY;
    export "DPI-C" function axi4_initialise_AWBURST_from_CY;

    import "DPI-C" context function void axi4_set_AWLOCK_from_SystemVerilog
    (
        input logic AWLOCK_param
    );
    import "DPI-C" context function void axi4_propagate_AWLOCK_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWLOCK_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWLOCK_from_CY;
    export "DPI-C" function axi4_initialise_AWLOCK_from_CY;

    import "DPI-C" context function void axi4_set_AWCACHE_from_SystemVerilog
    (
        input logic [3:0] AWCACHE_param
    );
    import "DPI-C" context function void axi4_propagate_AWCACHE_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWCACHE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWCACHE_from_CY;
    export "DPI-C" function axi4_initialise_AWCACHE_from_CY;

    import "DPI-C" context function void axi4_set_AWQOS_from_SystemVerilog
    (
        input logic [3:0] AWQOS_param
    );
    import "DPI-C" context function void axi4_propagate_AWQOS_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWQOS_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWQOS_from_CY;
    export "DPI-C" function axi4_initialise_AWQOS_from_CY;

    import "DPI-C" context function void axi4_set_AWID_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  AWID_param
    );
    import "DPI-C" context function void axi4_propagate_AWID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWID_from_CY_index1;
    export "DPI-C" function axi4_initialise_AWID_from_CY;

    import "DPI-C" context function void axi4_set_AWUSER_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  AWUSER_param
    );
    import "DPI-C" context function void axi4_propagate_AWUSER_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWUSER_from_CY_index1;
    export "DPI-C" function axi4_initialise_AWUSER_from_CY;

    import "DPI-C" context function void axi4_set_AWREADY_from_SystemVerilog
    (
        input logic AWREADY_param
    );
    import "DPI-C" context function void axi4_propagate_AWREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWREADY_from_CY;
    export "DPI-C" function axi4_initialise_AWREADY_from_CY;

    import "DPI-C" context function void axi4_set_ARVALID_from_SystemVerilog
    (
        input logic ARVALID_param
    );
    import "DPI-C" context function void axi4_propagate_ARVALID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARVALID_from_CY;
    export "DPI-C" function axi4_initialise_ARVALID_from_CY;

    import "DPI-C" context function void axi4_set_ARADDR_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  ARADDR_param
    );
    import "DPI-C" context function void axi4_propagate_ARADDR_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARADDR_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARADDR_from_CY_index1;
    export "DPI-C" function axi4_initialise_ARADDR_from_CY;

    import "DPI-C" context function void axi4_set_ARPROT_from_SystemVerilog
    (
        input logic [2:0] ARPROT_param
    );
    import "DPI-C" context function void axi4_propagate_ARPROT_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARPROT_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARPROT_from_CY;
    export "DPI-C" function axi4_initialise_ARPROT_from_CY;

    import "DPI-C" context function void axi4_set_ARREGION_from_SystemVerilog
    (
        input logic [3:0] ARREGION_param
    );
    import "DPI-C" context function void axi4_propagate_ARREGION_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARREGION_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARREGION_from_CY;
    export "DPI-C" function axi4_initialise_ARREGION_from_CY;

    import "DPI-C" context function void axi4_set_ARLEN_from_SystemVerilog
    (
        input logic [7:0] ARLEN_param
    );
    import "DPI-C" context function void axi4_propagate_ARLEN_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARLEN_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARLEN_from_CY;
    export "DPI-C" function axi4_initialise_ARLEN_from_CY;

    import "DPI-C" context function void axi4_set_ARSIZE_from_SystemVerilog
    (
        input logic [2:0] ARSIZE_param
    );
    import "DPI-C" context function void axi4_propagate_ARSIZE_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARSIZE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARSIZE_from_CY;
    export "DPI-C" function axi4_initialise_ARSIZE_from_CY;

    import "DPI-C" context function void axi4_set_ARBURST_from_SystemVerilog
    (
        input logic [1:0] ARBURST_param
    );
    import "DPI-C" context function void axi4_propagate_ARBURST_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARBURST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARBURST_from_CY;
    export "DPI-C" function axi4_initialise_ARBURST_from_CY;

    import "DPI-C" context function void axi4_set_ARLOCK_from_SystemVerilog
    (
        input logic ARLOCK_param
    );
    import "DPI-C" context function void axi4_propagate_ARLOCK_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARLOCK_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARLOCK_from_CY;
    export "DPI-C" function axi4_initialise_ARLOCK_from_CY;

    import "DPI-C" context function void axi4_set_ARCACHE_from_SystemVerilog
    (
        input logic [3:0] ARCACHE_param
    );
    import "DPI-C" context function void axi4_propagate_ARCACHE_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARCACHE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARCACHE_from_CY;
    export "DPI-C" function axi4_initialise_ARCACHE_from_CY;

    import "DPI-C" context function void axi4_set_ARQOS_from_SystemVerilog
    (
        input logic [3:0] ARQOS_param
    );
    import "DPI-C" context function void axi4_propagate_ARQOS_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARQOS_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARQOS_from_CY;
    export "DPI-C" function axi4_initialise_ARQOS_from_CY;

    import "DPI-C" context function void axi4_set_ARID_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  ARID_param
    );
    import "DPI-C" context function void axi4_propagate_ARID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARID_from_CY_index1;
    export "DPI-C" function axi4_initialise_ARID_from_CY;

    import "DPI-C" context function void axi4_set_ARUSER_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  ARUSER_param
    );
    import "DPI-C" context function void axi4_propagate_ARUSER_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARUSER_from_CY_index1;
    export "DPI-C" function axi4_initialise_ARUSER_from_CY;

    import "DPI-C" context function void axi4_set_ARREADY_from_SystemVerilog
    (
        input logic ARREADY_param
    );
    import "DPI-C" context function void axi4_propagate_ARREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARREADY_from_CY;
    export "DPI-C" function axi4_initialise_ARREADY_from_CY;

    import "DPI-C" context function void axi4_set_RVALID_from_SystemVerilog
    (
        input logic RVALID_param
    );
    import "DPI-C" context function void axi4_propagate_RVALID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_RVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_RVALID_from_CY;
    export "DPI-C" function axi4_initialise_RVALID_from_CY;

    import "DPI-C" context function void axi4_set_RDATA_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  RDATA_param
    );
    import "DPI-C" context function void axi4_propagate_RDATA_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_RDATA_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_RDATA_from_CY_index1;
    export "DPI-C" function axi4_initialise_RDATA_from_CY;

    import "DPI-C" context function void axi4_set_RRESP_from_SystemVerilog
    (
        input logic [1:0] RRESP_param
    );
    import "DPI-C" context function void axi4_propagate_RRESP_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_RRESP_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_RRESP_from_CY;
    export "DPI-C" function axi4_initialise_RRESP_from_CY;

    import "DPI-C" context function void axi4_set_RLAST_from_SystemVerilog
    (
        input logic RLAST_param
    );
    import "DPI-C" context function void axi4_propagate_RLAST_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_RLAST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_RLAST_from_CY;
    export "DPI-C" function axi4_initialise_RLAST_from_CY;

    import "DPI-C" context function void axi4_set_RID_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  RID_param
    );
    import "DPI-C" context function void axi4_propagate_RID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_RID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_RID_from_CY_index1;
    export "DPI-C" function axi4_initialise_RID_from_CY;

    import "DPI-C" context function void axi4_set_RUSER_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  RUSER_param
    );
    import "DPI-C" context function void axi4_propagate_RUSER_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_RUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_RUSER_from_CY_index1;
    export "DPI-C" function axi4_initialise_RUSER_from_CY;

    import "DPI-C" context function void axi4_set_RREADY_from_SystemVerilog
    (
        input logic RREADY_param
    );
    import "DPI-C" context function void axi4_propagate_RREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_RREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_RREADY_from_CY;
    export "DPI-C" function axi4_initialise_RREADY_from_CY;

    import "DPI-C" context function void axi4_set_WVALID_from_SystemVerilog
    (
        input logic WVALID_param
    );
    import "DPI-C" context function void axi4_propagate_WVALID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_WVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_WVALID_from_CY;
    export "DPI-C" function axi4_initialise_WVALID_from_CY;

    import "DPI-C" context function void axi4_set_WDATA_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  WDATA_param
    );
    import "DPI-C" context function void axi4_propagate_WDATA_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_WDATA_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_WDATA_from_CY_index1;
    export "DPI-C" function axi4_initialise_WDATA_from_CY;

    import "DPI-C" context function void axi4_set_WSTRB_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  WSTRB_param
    );
    import "DPI-C" context function void axi4_propagate_WSTRB_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_WSTRB_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_WSTRB_from_CY_index1;
    export "DPI-C" function axi4_initialise_WSTRB_from_CY;

    import "DPI-C" context function void axi4_set_WLAST_from_SystemVerilog
    (
        input logic WLAST_param
    );
    import "DPI-C" context function void axi4_propagate_WLAST_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_WLAST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_WLAST_from_CY;
    export "DPI-C" function axi4_initialise_WLAST_from_CY;

    import "DPI-C" context function void axi4_set_WUSER_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  WUSER_param
    );
    import "DPI-C" context function void axi4_propagate_WUSER_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_WUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_WUSER_from_CY_index1;
    export "DPI-C" function axi4_initialise_WUSER_from_CY;

    import "DPI-C" context function void axi4_set_WREADY_from_SystemVerilog
    (
        input logic WREADY_param
    );
    import "DPI-C" context function void axi4_propagate_WREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_WREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_WREADY_from_CY;
    export "DPI-C" function axi4_initialise_WREADY_from_CY;

    import "DPI-C" context function void axi4_set_BVALID_from_SystemVerilog
    (
        input logic BVALID_param
    );
    import "DPI-C" context function void axi4_propagate_BVALID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_BVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_BVALID_from_CY;
    export "DPI-C" function axi4_initialise_BVALID_from_CY;

    import "DPI-C" context function void axi4_set_BRESP_from_SystemVerilog
    (
        input logic [1:0] BRESP_param
    );
    import "DPI-C" context function void axi4_propagate_BRESP_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_BRESP_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_BRESP_from_CY;
    export "DPI-C" function axi4_initialise_BRESP_from_CY;

    import "DPI-C" context function void axi4_set_BID_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  BID_param
    );
    import "DPI-C" context function void axi4_propagate_BID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_BID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_BID_from_CY_index1;
    export "DPI-C" function axi4_initialise_BID_from_CY;

    import "DPI-C" context function void axi4_set_BUSER_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  BUSER_param
    );
    import "DPI-C" context function void axi4_propagate_BUSER_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_BUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_BUSER_from_CY_index1;
    export "DPI-C" function axi4_initialise_BUSER_from_CY;

    import "DPI-C" context function void axi4_set_BREADY_from_SystemVerilog
    (
        input logic BREADY_param
    );
    import "DPI-C" context function void axi4_propagate_BREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_BREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_BREADY_from_CY;
    export "DPI-C" function axi4_initialise_BREADY_from_CY;

    import "DPI-C" context function void axi4_set_config_interface_type_from_SystemVerilog
    (
        input int config_interface_type_param
    );
    import "DPI-C" context function void axi4_propagate_config_interface_type_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_interface_type_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_interface_type_from_CY;

    import "DPI-C" context function void axi4_set_config_clk_init_value_from_SystemVerilog
    (
        input bit config_clk_init_value_param
    );
    import "DPI-C" context function void axi4_propagate_config_clk_init_value_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_clk_init_value_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_clk_init_value_from_CY;

    import "DPI-C" context function void axi4_set_config_clk_phase_shift_from_SystemVerilog
    (
        input longint unsigned config_clk_phase_shift_param
    );
    import "DPI-C" context function void axi4_propagate_config_clk_phase_shift_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_clk_phase_shift_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_clk_phase_shift_from_CY;

    import "DPI-C" context function void axi4_set_config_clk_1st_time_from_SystemVerilog
    (
        input longint unsigned config_clk_1st_time_param
    );
    import "DPI-C" context function void axi4_propagate_config_clk_1st_time_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_clk_1st_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_clk_1st_time_from_CY;

    import "DPI-C" context function void axi4_set_config_clk_2nd_time_from_SystemVerilog
    (
        input longint unsigned config_clk_2nd_time_param
    );
    import "DPI-C" context function void axi4_propagate_config_clk_2nd_time_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_clk_2nd_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_clk_2nd_time_from_CY;

    import "DPI-C" context function void axi4_set_config_setup_time_from_SystemVerilog
    (
        input longint unsigned config_setup_time_param
    );
    import "DPI-C" context function void axi4_propagate_config_setup_time_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_setup_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_setup_time_from_CY;

    import "DPI-C" context function void axi4_set_config_hold_time_from_SystemVerilog
    (
        input longint unsigned config_hold_time_param
    );
    import "DPI-C" context function void axi4_propagate_config_hold_time_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_hold_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_hold_time_from_CY;

    import "DPI-C" context function void axi4_set_config_burst_timeout_factor_from_SystemVerilog
    (
        input int unsigned config_burst_timeout_factor_param
    );
    import "DPI-C" context function void axi4_propagate_config_burst_timeout_factor_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_burst_timeout_factor_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_burst_timeout_factor_from_CY;

    import "DPI-C" context function void axi4_set_config_max_transaction_time_factor_from_SystemVerilog
    (
        input int unsigned config_max_transaction_time_factor_param
    );
    import "DPI-C" context function void axi4_propagate_config_max_transaction_time_factor_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_max_transaction_time_factor_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_transaction_time_factor_from_CY;

    import "DPI-C" context function void axi4_set_config_write_ctrl_first_ratio_from_SystemVerilog
    (
        input int config_write_ctrl_first_ratio_param
    );
    import "DPI-C" context function void axi4_propagate_config_write_ctrl_first_ratio_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_write_ctrl_first_ratio_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_write_ctrl_first_ratio_from_CY;

    import "DPI-C" context function void axi4_set_config_write_data_first_ratio_from_SystemVerilog
    (
        input int config_write_data_first_ratio_param
    );
    import "DPI-C" context function void axi4_propagate_config_write_data_first_ratio_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_write_data_first_ratio_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_write_data_first_ratio_from_CY;

    import "DPI-C" context function void axi4_set_config_reset_low_clocks_from_SystemVerilog
    (
        input int config_reset_low_clocks_param
    );
    import "DPI-C" context function void axi4_propagate_config_reset_low_clocks_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_reset_low_clocks_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_reset_low_clocks_from_CY;

    import "DPI-C" context function void axi4_set_config_reset_hold_time_from_SystemVerilog
    (
        input int config_reset_hold_time_param
    );
    import "DPI-C" context function void axi4_propagate_config_reset_hold_time_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_reset_hold_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_reset_hold_time_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_rlast_from_SystemVerilog
    (
        input bit config_enable_rlast_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_rlast_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_rlast_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_rlast_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_slave_exclusive_from_SystemVerilog
    (
        input bit config_enable_slave_exclusive_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_slave_exclusive_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_slave_exclusive_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_slave_exclusive_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_burst_reserved_value_from_SystemVerilog
    (
        input bit config_enable_burst_reserved_value_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_burst_reserved_value_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_burst_reserved_value_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_burst_reserved_value_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_cache_value_from_SystemVerilog
    (
        input bit [15:0] config_enable_cache_value_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_cache_value_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_cache_value_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_cache_value_from_CY;

    import "DPI-C" context function void axi4_set_internal_dummy_variable_from_SystemVerilog
    (
        input int internal_dummy_variable_param
    );
    import "DPI-C" context function void axi4_propagate_internal_dummy_variable_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_internal_dummy_variable_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_internal_dummy_variable_from_CY;

    import "DPI-C" context function void axi4_set_config_axi4lite_interface_from_SystemVerilog
    (
        input bit config_axi4lite_interface_param
    );
    import "DPI-C" context function void axi4_propagate_config_axi4lite_interface_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_axi4lite_interface_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_axi4lite_interface_from_CY;

    import "DPI-C" context function void axi4_set_config_axi4lite_tr_id_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input bit  config_axi4lite_tr_id_param
    );
    import "DPI-C" context function void axi4_propagate_config_axi4lite_tr_id_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_axi4lite_tr_id_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_axi4lite_tr_id_from_CY_index1;

    import "DPI-C" context function void axi4_set_config_enable_all_assertions_from_SystemVerilog
    (
        input bit config_enable_all_assertions_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_all_assertions_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_all_assertions_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_all_assertions_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_assertion_from_SystemVerilog
    (
        input bit [255:0] config_enable_assertion_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_assertion_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_assertion_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_assertion_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_error_from_SystemVerilog
    (
        input bit [255:0] config_enable_error_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_error_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_error_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_error_from_CY;

    import "DPI-C" context function void axi4_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param
    );
    import "DPI-C" context function void axi4_propagate_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_max_latency_AWVALID_assertion_to_AWREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_CY;

    import "DPI-C" context function void axi4_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param
    );
    import "DPI-C" context function void axi4_propagate_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_max_latency_ARVALID_assertion_to_ARREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_CY;

    import "DPI-C" context function void axi4_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_RVALID_assertion_to_RREADY_param
    );
    import "DPI-C" context function void axi4_propagate_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_max_latency_RVALID_assertion_to_RREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_latency_RVALID_assertion_to_RREADY_from_CY;

    import "DPI-C" context function void axi4_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_BVALID_assertion_to_BREADY_param
    );
    import "DPI-C" context function void axi4_propagate_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_max_latency_BVALID_assertion_to_BREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_latency_BVALID_assertion_to_BREADY_from_CY;

    import "DPI-C" context function void axi4_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_WVALID_assertion_to_WREADY_param
    );
    import "DPI-C" context function void axi4_propagate_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_max_latency_WVALID_assertion_to_WREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_latency_WVALID_assertion_to_WREADY_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_qos_from_SystemVerilog
    (
        input bit config_enable_qos_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_qos_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_qos_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_qos_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_region_support_from_SystemVerilog
    (
        input bit config_enable_region_support_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_region_support_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_region_support_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_region_support_from_CY;

    import "DPI-C" context function void axi4_set_config_slave_regions_from_SystemVerilog
    (
        input int config_slave_regions_param
    );
    import "DPI-C" context function void axi4_propagate_config_slave_regions_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_slave_regions_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_slave_regions_from_CY;

    import "DPI-C" context function void axi4_set_config_region_from_SystemVerilog_index2
    (
        input int unsigned _this_dot_1,
        input int unsigned _this_dot_2,
        input bit  config_region_param
    );
    import "DPI-C" context function void axi4_propagate_config_region_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_region_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_region_from_CY_index2;

    import "DPI-C" context function void axi4_get_region_error_state_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_region_error_state_from_CY;

    import "DPI-C" context function void axi4_get_region_map_lb_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_region_map_lb_from_CY_index1;

    import "DPI-C" context function void axi4_get_region_map_ub_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_region_map_ub_from_CY_index1;

    import "DPI-C" context function void axi4_get_region_map_region_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_region_map_region_from_CY_index1;

    import "DPI-C" context function void axi4_get_cacheable_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_cacheable_from_CY_index1;

    import "DPI-C" context function void axi4_set_config_read_data_reordering_depth_from_SystemVerilog
    (
        input int unsigned config_read_data_reordering_depth_param
    );
    import "DPI-C" context function void axi4_propagate_config_read_data_reordering_depth_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_read_data_reordering_depth_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_read_data_reordering_depth_from_CY;

    import "DPI-C" context function void axi4_set_config_slave_start_addr_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input bit  config_slave_start_addr_param
    );
    import "DPI-C" context function void axi4_propagate_config_slave_start_addr_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_slave_start_addr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_slave_start_addr_from_CY_index1;

    import "DPI-C" context function void axi4_set_config_slave_end_addr_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input bit  config_slave_end_addr_param
    );
    import "DPI-C" context function void axi4_propagate_config_slave_end_addr_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_slave_end_addr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_slave_end_addr_from_CY_index1;

    import "DPI-C" context function void axi4_set_config_slave_enabled_non_contiguous_address_spaces_from_SystemVerilog
    (
        input int config_slave_enabled_non_contiguous_address_spaces_param
    );
    import "DPI-C" context function void axi4_propagate_config_slave_enabled_non_contiguous_address_spaces_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_slave_enabled_non_contiguous_address_spaces_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_slave_enabled_non_contiguous_address_spaces_from_CY;

    import "DPI-C" context function void axi4_set_config_slave_possess_multiple_non_contiguous_address_spaces_from_SystemVerilog
    (
        input bit config_slave_possess_multiple_non_contiguous_address_spaces_param
    );
    import "DPI-C" context function void axi4_propagate_config_slave_possess_multiple_non_contiguous_address_spaces_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_slave_possess_multiple_non_contiguous_address_spaces_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_slave_possess_multiple_non_contiguous_address_spaces_from_CY;

    import "DPI-C" context function void axi4_set_config_slave_multiple_non_contiguous_start_address_range_from_SystemVerilog_index2
    (
        input int unsigned _this_dot_1,
        input int unsigned _this_dot_2,
        input bit  config_slave_multiple_non_contiguous_start_address_range_param
    );
    import "DPI-C" context function void axi4_propagate_config_slave_multiple_non_contiguous_start_address_range_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_slave_multiple_non_contiguous_start_address_range_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_slave_multiple_non_contiguous_start_address_range_from_CY_index2;

    import "DPI-C" context function void axi4_set_config_slave_multiple_non_contiguous_end_address_range_from_SystemVerilog_index2
    (
        input int unsigned _this_dot_1,
        input int unsigned _this_dot_2,
        input bit  config_slave_multiple_non_contiguous_end_address_range_param
    );
    import "DPI-C" context function void axi4_propagate_config_slave_multiple_non_contiguous_end_address_range_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_slave_multiple_non_contiguous_end_address_range_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_slave_multiple_non_contiguous_end_address_range_from_CY_index2;

    import "DPI-C" context function void axi4_set_config_protect_ready_from_SystemVerilog
    (
        input bit config_protect_ready_param
    );
    import "DPI-C" context function void axi4_propagate_config_protect_ready_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_protect_ready_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_protect_ready_from_CY;

    import "DPI-C" context function void axi4_get_master_end_tlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_master_end_tlm_status_from_CY;

    import "DPI-C" context function void axi4_get_master_end_wlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_master_end_wlm_status_from_CY;

    import "DPI-C" context function void axi4_get_slave_end_tlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_slave_end_tlm_status_from_CY;

    import "DPI-C" context function void axi4_get_slave_end_wlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_slave_end_wlm_status_from_CY;

    import "DPI-C" context function void axi4_get_clock_source_end_tlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_clock_source_end_tlm_status_from_CY;

    import "DPI-C" context function void axi4_get_clock_source_end_wlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_clock_source_end_wlm_status_from_CY;

    import "DPI-C" context function void axi4_get_reset_source_end_tlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_reset_source_end_tlm_status_from_CY;

    import "DPI-C" context function void axi4_get_reset_source_end_wlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_reset_source_end_wlm_status_from_CY;

    import "DPI-C" context function void axi4_set_config_max_outstanding_wr_from_SystemVerilog
    (
        input int config_max_outstanding_wr_param
    );
    import "DPI-C" context function void axi4_propagate_config_max_outstanding_wr_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_max_outstanding_wr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_outstanding_wr_from_CY;

    import "DPI-C" context function void axi4_set_config_max_outstanding_rd_from_SystemVerilog
    (
        input int config_max_outstanding_rd_param
    );
    import "DPI-C" context function void axi4_propagate_config_max_outstanding_rd_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_max_outstanding_rd_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_outstanding_rd_from_CY;

    import "DPI-C" context function void axi4_set_config_num_outstanding_wr_phase_from_SystemVerilog
    (
        input int config_num_outstanding_wr_phase_param
    );
    import "DPI-C" context function void axi4_propagate_config_num_outstanding_wr_phase_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_num_outstanding_wr_phase_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_num_outstanding_wr_phase_from_CY;

    import "DPI-C" context function void axi4_set_config_num_outstanding_rd_phase_from_SystemVerilog
    (
        input int config_num_outstanding_rd_phase_param
    );
    import "DPI-C" context function void axi4_propagate_config_num_outstanding_rd_phase_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_num_outstanding_rd_phase_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_num_outstanding_rd_phase_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_warnings_from_SystemVerilog
    (
        input bit config_enable_warnings_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_warnings_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_warnings_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_warnings_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_errors_from_SystemVerilog
    (
        input bit config_enable_errors_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_errors_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_errors_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_errors_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_exclusive_checks_from_SystemVerilog
    (
        input bit config_enable_exclusive_checks_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_exclusive_checks_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_exclusive_checks_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_exclusive_checks_from_CY;

    import "DPI-C" context function void axi4_set_config_warn_on_slave_errors_from_SystemVerilog
    (
        input bit config_warn_on_slave_errors_param
    );
    import "DPI-C" context function void axi4_propagate_config_warn_on_slave_errors_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_warn_on_slave_errors_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_warn_on_slave_errors_from_CY;

    import "DPI-C" context function void axi4_set_config_error_on_deleted_valid_cycles_from_SystemVerilog
    (
        input bit config_error_on_deleted_valid_cycles_param
    );
    import "DPI-C" context function void axi4_propagate_config_error_on_deleted_valid_cycles_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_error_on_deleted_valid_cycles_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_error_on_deleted_valid_cycles_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_from_SystemVerilog
    (
        input bit config_stats_enable_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_read_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_read_occupancy_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_read_occupancy_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_read_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_read_occupancy_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_write_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_write_occupancy_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_write_occupancy_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_write_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_write_occupancy_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_read_data_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_read_data_occupancy_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_read_data_occupancy_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_read_data_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_read_data_occupancy_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_write_data_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_write_data_occupancy_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_write_data_occupancy_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_write_data_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_write_data_occupancy_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_read_latency_from_SystemVerilog
    (
        input bit config_stats_enable_read_latency_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_read_latency_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_read_latency_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_read_latency_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_write_latency_from_SystemVerilog
    (
        input bit config_stats_enable_write_latency_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_write_latency_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_write_latency_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_write_latency_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_read_address_waits_from_SystemVerilog
    (
        input bit config_stats_enable_read_address_waits_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_read_address_waits_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_read_address_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_read_address_waits_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_read_data_waits_from_SystemVerilog
    (
        input bit config_stats_enable_read_data_waits_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_read_data_waits_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_read_data_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_read_data_waits_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_write_address_waits_from_SystemVerilog
    (
        input bit config_stats_enable_write_address_waits_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_write_address_waits_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_write_address_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_write_address_waits_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_write_data_waits_from_SystemVerilog
    (
        input bit config_stats_enable_write_data_waits_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_write_data_waits_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_write_data_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_write_data_waits_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_write_response_waits_from_SystemVerilog
    (
        input bit config_stats_enable_write_response_waits_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_write_response_waits_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_write_response_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_write_response_waits_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_read_bandwidth_from_SystemVerilog
    (
        input bit config_stats_enable_read_bandwidth_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_read_bandwidth_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_read_bandwidth_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_read_bandwidth_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_write_bandwidth_from_SystemVerilog
    (
        input bit config_stats_enable_write_bandwidth_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_write_bandwidth_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_write_bandwidth_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_write_bandwidth_from_CY;

    import "DPI-C" context function void axi4_get_stats_rw_transaction_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_rw_transaction_last_duration_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_occupancy_step_from_SystemVerilog
    (
        input int config_stats_read_occupancy_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_occupancy_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_occupancy_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_read_occupancy_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_occupancy_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_active_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_active_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_occupancy_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_idle_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_occupancy_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_idle_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_occupancy_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_idle_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_occupancy_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_idle_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_last_duration_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_occupancy_step_from_SystemVerilog
    (
        input int config_stats_write_occupancy_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_occupancy_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_occupancy_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_write_occupancy_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_occupancy_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_active_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_active_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_occupancy_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_idle_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_occupancy_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_idle_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_occupancy_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_idle_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_occupancy_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_idle_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_last_duration_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_data_occupancy_step_from_SystemVerilog
    (
        input int config_stats_read_data_occupancy_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_data_occupancy_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_data_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_data_occupancy_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_read_data_occupancy_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_data_occupancy_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_data_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_data_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_occupancy_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_idle_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_occupancy_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_idle_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_occupancy_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_idle_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_occupancy_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_idle_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_data_occupancy_step_from_SystemVerilog
    (
        input int config_stats_write_data_occupancy_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_data_occupancy_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_data_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_data_occupancy_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_write_data_occupancy_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_data_occupancy_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_data_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_data_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_occupancy_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_idle_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_occupancy_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_idle_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_occupancy_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_idle_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_occupancy_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_idle_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_bandwidth_step_from_SystemVerilog
    (
        input int config_stats_read_bandwidth_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_bandwidth_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_bandwidth_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_bandwidth_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_bandwidth_multiple_from_SystemVerilog
    (
        input int config_stats_read_bandwidth_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_bandwidth_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_bandwidth_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_bandwidth_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_bandwidth_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_bandwidth_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_bandwidth_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_bandwidth_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_bandwidth_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_bandwidth_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_bandwidth_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_bandwidth_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_bandwidth_step_from_SystemVerilog
    (
        input int config_stats_write_bandwidth_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_bandwidth_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_bandwidth_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_bandwidth_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_bandwidth_multiple_from_SystemVerilog
    (
        input int config_stats_write_bandwidth_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_bandwidth_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_bandwidth_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_bandwidth_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_bandwidth_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_bandwidth_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_bandwidth_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_bandwidth_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_bandwidth_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_bandwidth_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_bandwidth_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_bandwidth_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_latency_step_from_SystemVerilog
    (
        input int config_stats_read_latency_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_latency_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_latency_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_latency_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_latency_multiple_from_SystemVerilog
    (
        input int config_stats_read_latency_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_latency_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_latency_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_latency_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_data_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_data_latency_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_data_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_data_latency_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_data_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_data_latency_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_data_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_data_latency_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_data_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_data_latency_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_address_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_address_latency_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_address_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_address_latency_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_address_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_address_latency_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_address_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_address_latency_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_address_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_address_latency_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_latency_step_from_SystemVerilog
    (
        input int config_stats_write_latency_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_latency_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_latency_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_latency_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_latency_multiple_from_SystemVerilog
    (
        input int config_stats_write_latency_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_latency_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_latency_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_latency_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_response_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_response_latency_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_response_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_response_latency_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_response_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_response_latency_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_response_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_response_latency_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_response_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_response_latency_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_address_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_address_latency_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_address_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_address_latency_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_address_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_address_latency_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_address_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_address_latency_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_address_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_address_latency_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_address_waits_step_from_SystemVerilog
    (
        input int config_stats_read_address_waits_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_address_waits_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_address_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_address_waits_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_address_waits_multiple_from_SystemVerilog
    (
        input int config_stats_read_address_waits_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_address_waits_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_address_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_address_waits_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_waits_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_waits_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_waits_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_waits_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_waits_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_data_waits_step_from_SystemVerilog
    (
        input int config_stats_read_data_waits_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_data_waits_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_data_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_data_waits_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_data_waits_multiple_from_SystemVerilog
    (
        input int config_stats_read_data_waits_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_data_waits_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_data_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_data_waits_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_waits_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_waits_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_waits_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_waits_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_waits_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_address_waits_step_from_SystemVerilog
    (
        input int config_stats_write_address_waits_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_address_waits_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_address_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_address_waits_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_address_waits_multiple_from_SystemVerilog
    (
        input int config_stats_write_address_waits_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_address_waits_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_address_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_address_waits_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_waits_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_waits_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_waits_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_waits_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_waits_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_data_waits_step_from_SystemVerilog
    (
        input int config_stats_write_data_waits_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_data_waits_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_data_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_data_waits_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_data_waits_multiple_from_SystemVerilog
    (
        input int config_stats_write_data_waits_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_data_waits_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_data_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_data_waits_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_waits_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_waits_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_waits_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_waits_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_waits_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_response_waits_step_from_SystemVerilog
    (
        input int config_stats_write_response_waits_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_response_waits_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_response_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_response_waits_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_response_waits_multiple_from_SystemVerilog
    (
        input int config_stats_write_response_waits_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_response_waits_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_response_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_response_waits_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_response_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_response_waits_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_response_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_response_waits_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_response_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_response_waits_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_response_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_response_waits_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_response_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_response_waits_mean_from_CY;

    import "DPI-C" context function void axi4_get_reordering_depth_of_last_read_transaction_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_reordering_depth_of_last_read_transaction_from_CY;

    function void axi4_set_ACLK_from_CY( bit ACLK_param );
        internal_ACLK = ACLK_param;
    endfunction

    function void axi4_initialise_ACLK_from_CY();
        internal_ACLK = 'z;
        m_ACLK = 'z;
    endfunction

    function void axi4_set_ARESETn_from_CY( logic ARESETn_param );
        internal_ARESETn = ARESETn_param;
    endfunction

    function void axi4_initialise_ARESETn_from_CY();
        internal_ARESETn = 'z;
        m_ARESETn = 'z;
    endfunction

    function void axi4_set_AWVALID_from_CY( logic AWVALID_param );
        internal_AWVALID = AWVALID_param;
    endfunction

    function void axi4_initialise_AWVALID_from_CY();
        internal_AWVALID = 'z;
        m_AWVALID = 'z;
    endfunction

    function void axi4_set_AWADDR_from_CY_index1( int _this_dot_1, logic  AWADDR_param );
        internal_AWADDR[_this_dot_1] = AWADDR_param;
    endfunction

    function void axi4_initialise_AWADDR_from_CY();
        internal_AWADDR = 'z;
        m_AWADDR = 'z;
    endfunction

    function void axi4_set_AWPROT_from_CY( logic [2:0] AWPROT_param );
        internal_AWPROT = AWPROT_param;
    endfunction

    function void axi4_initialise_AWPROT_from_CY();
        internal_AWPROT = 'z;
        m_AWPROT = 'z;
    endfunction

    function void axi4_set_AWREGION_from_CY( logic [3:0] AWREGION_param );
        internal_AWREGION = AWREGION_param;
    endfunction

    function void axi4_initialise_AWREGION_from_CY();
        internal_AWREGION = 'z;
        m_AWREGION = 'z;
    endfunction

    function void axi4_set_AWLEN_from_CY( logic [7:0] AWLEN_param );
        internal_AWLEN = AWLEN_param;
    endfunction

    function void axi4_initialise_AWLEN_from_CY();
        internal_AWLEN = 'z;
        m_AWLEN = 'z;
    endfunction

    function void axi4_set_AWSIZE_from_CY( logic [2:0] AWSIZE_param );
        internal_AWSIZE = AWSIZE_param;
    endfunction

    function void axi4_initialise_AWSIZE_from_CY();
        internal_AWSIZE = 'z;
        m_AWSIZE = 'z;
    endfunction

    function void axi4_set_AWBURST_from_CY( logic [1:0] AWBURST_param );
        internal_AWBURST = AWBURST_param;
    endfunction

    function void axi4_initialise_AWBURST_from_CY();
        internal_AWBURST = 'z;
        m_AWBURST = 'z;
    endfunction

    function void axi4_set_AWLOCK_from_CY( logic AWLOCK_param );
        internal_AWLOCK = AWLOCK_param;
    endfunction

    function void axi4_initialise_AWLOCK_from_CY();
        internal_AWLOCK = 'z;
        m_AWLOCK = 'z;
    endfunction

    function void axi4_set_AWCACHE_from_CY( logic [3:0] AWCACHE_param );
        internal_AWCACHE = AWCACHE_param;
    endfunction

    function void axi4_initialise_AWCACHE_from_CY();
        internal_AWCACHE = 'z;
        m_AWCACHE = 'z;
    endfunction

    function void axi4_set_AWQOS_from_CY( logic [3:0] AWQOS_param );
        internal_AWQOS = AWQOS_param;
    endfunction

    function void axi4_initialise_AWQOS_from_CY();
        internal_AWQOS = 'z;
        m_AWQOS = 'z;
    endfunction

    function void axi4_set_AWID_from_CY_index1( int _this_dot_1, logic  AWID_param );
        internal_AWID[_this_dot_1] = AWID_param;
    endfunction

    function void axi4_initialise_AWID_from_CY();
        internal_AWID = 'z;
        m_AWID = 'z;
    endfunction

    function void axi4_set_AWUSER_from_CY_index1( int _this_dot_1, logic  AWUSER_param );
        internal_AWUSER[_this_dot_1] = AWUSER_param;
    endfunction

    function void axi4_initialise_AWUSER_from_CY();
        internal_AWUSER = 'z;
        m_AWUSER = 'z;
    endfunction

    function void axi4_set_AWREADY_from_CY( logic AWREADY_param );
        internal_AWREADY = AWREADY_param;
    endfunction

    function void axi4_initialise_AWREADY_from_CY();
        internal_AWREADY = 'z;
        m_AWREADY = 'z;
    endfunction

    function void axi4_set_ARVALID_from_CY( logic ARVALID_param );
        internal_ARVALID = ARVALID_param;
    endfunction

    function void axi4_initialise_ARVALID_from_CY();
        internal_ARVALID = 'z;
        m_ARVALID = 'z;
    endfunction

    function void axi4_set_ARADDR_from_CY_index1( int _this_dot_1, logic  ARADDR_param );
        internal_ARADDR[_this_dot_1] = ARADDR_param;
    endfunction

    function void axi4_initialise_ARADDR_from_CY();
        internal_ARADDR = 'z;
        m_ARADDR = 'z;
    endfunction

    function void axi4_set_ARPROT_from_CY( logic [2:0] ARPROT_param );
        internal_ARPROT = ARPROT_param;
    endfunction

    function void axi4_initialise_ARPROT_from_CY();
        internal_ARPROT = 'z;
        m_ARPROT = 'z;
    endfunction

    function void axi4_set_ARREGION_from_CY( logic [3:0] ARREGION_param );
        internal_ARREGION = ARREGION_param;
    endfunction

    function void axi4_initialise_ARREGION_from_CY();
        internal_ARREGION = 'z;
        m_ARREGION = 'z;
    endfunction

    function void axi4_set_ARLEN_from_CY( logic [7:0] ARLEN_param );
        internal_ARLEN = ARLEN_param;
    endfunction

    function void axi4_initialise_ARLEN_from_CY();
        internal_ARLEN = 'z;
        m_ARLEN = 'z;
    endfunction

    function void axi4_set_ARSIZE_from_CY( logic [2:0] ARSIZE_param );
        internal_ARSIZE = ARSIZE_param;
    endfunction

    function void axi4_initialise_ARSIZE_from_CY();
        internal_ARSIZE = 'z;
        m_ARSIZE = 'z;
    endfunction

    function void axi4_set_ARBURST_from_CY( logic [1:0] ARBURST_param );
        internal_ARBURST = ARBURST_param;
    endfunction

    function void axi4_initialise_ARBURST_from_CY();
        internal_ARBURST = 'z;
        m_ARBURST = 'z;
    endfunction

    function void axi4_set_ARLOCK_from_CY( logic ARLOCK_param );
        internal_ARLOCK = ARLOCK_param;
    endfunction

    function void axi4_initialise_ARLOCK_from_CY();
        internal_ARLOCK = 'z;
        m_ARLOCK = 'z;
    endfunction

    function void axi4_set_ARCACHE_from_CY( logic [3:0] ARCACHE_param );
        internal_ARCACHE = ARCACHE_param;
    endfunction

    function void axi4_initialise_ARCACHE_from_CY();
        internal_ARCACHE = 'z;
        m_ARCACHE = 'z;
    endfunction

    function void axi4_set_ARQOS_from_CY( logic [3:0] ARQOS_param );
        internal_ARQOS = ARQOS_param;
    endfunction

    function void axi4_initialise_ARQOS_from_CY();
        internal_ARQOS = 'z;
        m_ARQOS = 'z;
    endfunction

    function void axi4_set_ARID_from_CY_index1( int _this_dot_1, logic  ARID_param );
        internal_ARID[_this_dot_1] = ARID_param;
    endfunction

    function void axi4_initialise_ARID_from_CY();
        internal_ARID = 'z;
        m_ARID = 'z;
    endfunction

    function void axi4_set_ARUSER_from_CY_index1( int _this_dot_1, logic  ARUSER_param );
        internal_ARUSER[_this_dot_1] = ARUSER_param;
    endfunction

    function void axi4_initialise_ARUSER_from_CY();
        internal_ARUSER = 'z;
        m_ARUSER = 'z;
    endfunction

    function void axi4_set_ARREADY_from_CY( logic ARREADY_param );
        internal_ARREADY = ARREADY_param;
    endfunction

    function void axi4_initialise_ARREADY_from_CY();
        internal_ARREADY = 'z;
        m_ARREADY = 'z;
    endfunction

    function void axi4_set_RVALID_from_CY( logic RVALID_param );
        internal_RVALID = RVALID_param;
    endfunction

    function void axi4_initialise_RVALID_from_CY();
        internal_RVALID = 'z;
        m_RVALID = 'z;
    endfunction

    function void axi4_set_RDATA_from_CY_index1( int _this_dot_1, logic  RDATA_param );
        internal_RDATA[_this_dot_1] = RDATA_param;
    endfunction

    function void axi4_initialise_RDATA_from_CY();
        internal_RDATA = 'z;
        m_RDATA = 'z;
    endfunction

    function void axi4_set_RRESP_from_CY( logic [1:0] RRESP_param );
        internal_RRESP = RRESP_param;
    endfunction

    function void axi4_initialise_RRESP_from_CY();
        internal_RRESP = 'z;
        m_RRESP = 'z;
    endfunction

    function void axi4_set_RLAST_from_CY( logic RLAST_param );
        internal_RLAST = RLAST_param;
    endfunction

    function void axi4_initialise_RLAST_from_CY();
        internal_RLAST = 'z;
        m_RLAST = 'z;
    endfunction

    function void axi4_set_RID_from_CY_index1( int _this_dot_1, logic  RID_param );
        internal_RID[_this_dot_1] = RID_param;
    endfunction

    function void axi4_initialise_RID_from_CY();
        internal_RID = 'z;
        m_RID = 'z;
    endfunction

    function void axi4_set_RUSER_from_CY_index1( int _this_dot_1, logic  RUSER_param );
        internal_RUSER[_this_dot_1] = RUSER_param;
    endfunction

    function void axi4_initialise_RUSER_from_CY();
        internal_RUSER = 'z;
        m_RUSER = 'z;
    endfunction

    function void axi4_set_RREADY_from_CY( logic RREADY_param );
        internal_RREADY = RREADY_param;
    endfunction

    function void axi4_initialise_RREADY_from_CY();
        internal_RREADY = 'z;
        m_RREADY = 'z;
    endfunction

    function void axi4_set_WVALID_from_CY( logic WVALID_param );
        internal_WVALID = WVALID_param;
    endfunction

    function void axi4_initialise_WVALID_from_CY();
        internal_WVALID = 'z;
        m_WVALID = 'z;
    endfunction

    function void axi4_set_WDATA_from_CY_index1( int _this_dot_1, logic  WDATA_param );
        internal_WDATA[_this_dot_1] = WDATA_param;
    endfunction

    function void axi4_initialise_WDATA_from_CY();
        internal_WDATA = 'z;
        m_WDATA = 'z;
    endfunction

    function void axi4_set_WSTRB_from_CY_index1( int _this_dot_1, logic  WSTRB_param );
        internal_WSTRB[_this_dot_1] = WSTRB_param;
    endfunction

    function void axi4_initialise_WSTRB_from_CY();
        internal_WSTRB = 'z;
        m_WSTRB = 'z;
    endfunction

    function void axi4_set_WLAST_from_CY( logic WLAST_param );
        internal_WLAST = WLAST_param;
    endfunction

    function void axi4_initialise_WLAST_from_CY();
        internal_WLAST = 'z;
        m_WLAST = 'z;
    endfunction

    function void axi4_set_WUSER_from_CY_index1( int _this_dot_1, logic  WUSER_param );
        internal_WUSER[_this_dot_1] = WUSER_param;
    endfunction

    function void axi4_initialise_WUSER_from_CY();
        internal_WUSER = 'z;
        m_WUSER = 'z;
    endfunction

    function void axi4_set_WREADY_from_CY( logic WREADY_param );
        internal_WREADY = WREADY_param;
    endfunction

    function void axi4_initialise_WREADY_from_CY();
        internal_WREADY = 'z;
        m_WREADY = 'z;
    endfunction

    function void axi4_set_BVALID_from_CY( logic BVALID_param );
        internal_BVALID = BVALID_param;
    endfunction

    function void axi4_initialise_BVALID_from_CY();
        internal_BVALID = 'z;
        m_BVALID = 'z;
    endfunction

    function void axi4_set_BRESP_from_CY( logic [1:0] BRESP_param );
        internal_BRESP = BRESP_param;
    endfunction

    function void axi4_initialise_BRESP_from_CY();
        internal_BRESP = 'z;
        m_BRESP = 'z;
    endfunction

    function void axi4_set_BID_from_CY_index1( int _this_dot_1, logic  BID_param );
        internal_BID[_this_dot_1] = BID_param;
    endfunction

    function void axi4_initialise_BID_from_CY();
        internal_BID = 'z;
        m_BID = 'z;
    endfunction

    function void axi4_set_BUSER_from_CY_index1( int _this_dot_1, logic  BUSER_param );
        internal_BUSER[_this_dot_1] = BUSER_param;
    endfunction

    function void axi4_initialise_BUSER_from_CY();
        internal_BUSER = 'z;
        m_BUSER = 'z;
    endfunction

    function void axi4_set_BREADY_from_CY( logic BREADY_param );
        internal_BREADY = BREADY_param;
    endfunction

    function void axi4_initialise_BREADY_from_CY();
        internal_BREADY = 'z;
        m_BREADY = 'z;
    endfunction

    function void axi4_set_config_interface_type_from_CY(     int config_interface_type_param);
        config_interface_type = axi4_interface_type_e'( config_interface_type_param );
    endfunction

    function void axi4_set_config_clk_init_value_from_CY( bit config_clk_init_value_param );
        config_clk_init_value = config_clk_init_value_param;
    endfunction

    function void axi4_set_config_clk_phase_shift_from_CY( longint unsigned config_clk_phase_shift_param );
        config_clk_phase_shift = config_clk_phase_shift_param;
    endfunction

    function void axi4_set_config_clk_1st_time_from_CY( longint unsigned config_clk_1st_time_param );
        config_clk_1st_time = config_clk_1st_time_param;
    endfunction

    function void axi4_set_config_clk_2nd_time_from_CY( longint unsigned config_clk_2nd_time_param );
        config_clk_2nd_time = config_clk_2nd_time_param;
    endfunction

    function void axi4_set_config_setup_time_from_CY( longint unsigned config_setup_time_param );
        config_setup_time = config_setup_time_param;
    endfunction

    function void axi4_set_config_hold_time_from_CY( longint unsigned config_hold_time_param );
        config_hold_time = config_hold_time_param;
    endfunction

    function void axi4_set_config_burst_timeout_factor_from_CY( int unsigned config_burst_timeout_factor_param );
        config_burst_timeout_factor = config_burst_timeout_factor_param;
    endfunction

    function void axi4_set_config_max_transaction_time_factor_from_CY( int unsigned config_max_transaction_time_factor_param );
        config_max_transaction_time_factor = config_max_transaction_time_factor_param;
    endfunction

    function void axi4_set_config_write_ctrl_first_ratio_from_CY( int config_write_ctrl_first_ratio_param );
        config_write_ctrl_first_ratio = config_write_ctrl_first_ratio_param;
    endfunction

    function void axi4_set_config_write_data_first_ratio_from_CY( int config_write_data_first_ratio_param );
        config_write_data_first_ratio = config_write_data_first_ratio_param;
    endfunction

    function void axi4_set_config_reset_low_clocks_from_CY( int config_reset_low_clocks_param );
        config_reset_low_clocks = config_reset_low_clocks_param;
    endfunction

    function void axi4_set_config_reset_hold_time_from_CY( int config_reset_hold_time_param );
        config_reset_hold_time = config_reset_hold_time_param;
    endfunction

    function void axi4_set_config_enable_rlast_from_CY( bit config_enable_rlast_param );
        config_enable_rlast = config_enable_rlast_param;
    endfunction

    function void axi4_set_config_enable_slave_exclusive_from_CY( bit config_enable_slave_exclusive_param );
        config_enable_slave_exclusive = config_enable_slave_exclusive_param;
    endfunction

    function void axi4_set_config_enable_burst_reserved_value_from_CY( bit config_enable_burst_reserved_value_param );
        config_enable_burst_reserved_value = config_enable_burst_reserved_value_param;
    endfunction

    function void axi4_set_config_enable_cache_value_from_CY( bit [15:0] config_enable_cache_value_param );
        config_enable_cache_value = config_enable_cache_value_param;
    endfunction

    function void axi4_set_internal_dummy_variable_from_CY(     int internal_dummy_variable_param);
        internal_dummy_variable = axi4_error_e'( internal_dummy_variable_param );
    endfunction

    function void axi4_set_config_axi4lite_interface_from_CY( bit config_axi4lite_interface_param );
        config_axi4lite_interface = config_axi4lite_interface_param;
    endfunction

    function void axi4_set_config_axi4lite_tr_id_from_CY_index1( int _this_dot_1, bit  config_axi4lite_tr_id_param );
        config_axi4lite_tr_id[_this_dot_1] = config_axi4lite_tr_id_param;
    endfunction

    function void axi4_set_config_enable_all_assertions_from_CY( bit config_enable_all_assertions_param );
        config_enable_all_assertions = config_enable_all_assertions_param;
    endfunction

    function void axi4_set_config_enable_assertion_from_CY( bit [255:0] config_enable_assertion_param );
        config_enable_assertion = config_enable_assertion_param;
    endfunction

    function void axi4_set_config_enable_error_from_CY( bit [255:0] config_enable_error_param );
        config_enable_error = config_enable_error_param;
    endfunction

    function void axi4_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_CY( int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
        config_max_latency_AWVALID_assertion_to_AWREADY = config_max_latency_AWVALID_assertion_to_AWREADY_param;
    endfunction

    function void axi4_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_CY( int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
        config_max_latency_ARVALID_assertion_to_ARREADY = config_max_latency_ARVALID_assertion_to_ARREADY_param;
    endfunction

    function void axi4_set_config_max_latency_RVALID_assertion_to_RREADY_from_CY( int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
        config_max_latency_RVALID_assertion_to_RREADY = config_max_latency_RVALID_assertion_to_RREADY_param;
    endfunction

    function void axi4_set_config_max_latency_BVALID_assertion_to_BREADY_from_CY( int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
        config_max_latency_BVALID_assertion_to_BREADY = config_max_latency_BVALID_assertion_to_BREADY_param;
    endfunction

    function void axi4_set_config_max_latency_WVALID_assertion_to_WREADY_from_CY( int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
        config_max_latency_WVALID_assertion_to_WREADY = config_max_latency_WVALID_assertion_to_WREADY_param;
    endfunction

    function void axi4_set_config_enable_qos_from_CY( bit config_enable_qos_param );
        config_enable_qos = config_enable_qos_param;
    endfunction

    function void axi4_set_config_enable_region_support_from_CY( bit config_enable_region_support_param );
        config_enable_region_support = config_enable_region_support_param;
    endfunction

    function void axi4_set_config_slave_regions_from_CY( int config_slave_regions_param );
        config_slave_regions = config_slave_regions_param;
    endfunction

    function void axi4_set_config_region_from_CY_index2( int _this_dot_1, int _this_dot_2, bit  config_region_param );
        config_region[_this_dot_1][_this_dot_2] = config_region_param;
    endfunction

    function void axi4_set_region_error_state_from_CY( bit region_error_state_param );
        region_error_state = region_error_state_param;
    endfunction

    function void axi4_set_region_map_lb_from_CY_index1( int _this_dot_1, longint unsigned region_map_lb_param );
        region_map_lb[_this_dot_1] = region_map_lb_param;
    endfunction

    function void axi4_set_region_map_ub_from_CY_index1( int _this_dot_1, longint unsigned region_map_ub_param );
        region_map_ub[_this_dot_1] = region_map_ub_param;
    endfunction

    function void axi4_set_region_map_region_from_CY_index1( int _this_dot_1, byte unsigned region_map_region_param );
        region_map_region[_this_dot_1] = region_map_region_param;
    endfunction

    function void axi4_set_cacheable_from_CY_index1( int _this_dot_1, byte unsigned cacheable_param );
        cacheable[_this_dot_1] = cacheable_param;
    endfunction

    function void axi4_set_config_read_data_reordering_depth_from_CY( int unsigned config_read_data_reordering_depth_param );
        config_read_data_reordering_depth = config_read_data_reordering_depth_param;
    endfunction

    function void axi4_set_config_slave_start_addr_from_CY_index1( int _this_dot_1, bit  config_slave_start_addr_param );
        config_slave_start_addr[_this_dot_1] = config_slave_start_addr_param;
    endfunction

    function void axi4_set_config_slave_end_addr_from_CY_index1( int _this_dot_1, bit  config_slave_end_addr_param );
        config_slave_end_addr[_this_dot_1] = config_slave_end_addr_param;
    endfunction

    function void axi4_set_config_slave_enabled_non_contiguous_address_spaces_from_CY( int config_slave_enabled_non_contiguous_address_spaces_param );
        config_slave_enabled_non_contiguous_address_spaces = config_slave_enabled_non_contiguous_address_spaces_param;
    endfunction

    function void axi4_set_config_slave_possess_multiple_non_contiguous_address_spaces_from_CY( bit config_slave_possess_multiple_non_contiguous_address_spaces_param );
        config_slave_possess_multiple_non_contiguous_address_spaces = config_slave_possess_multiple_non_contiguous_address_spaces_param;
    endfunction

    function void axi4_set_config_slave_multiple_non_contiguous_start_address_range_from_CY_index2( int _this_dot_1, int _this_dot_2, bit  config_slave_multiple_non_contiguous_start_address_range_param );
        config_slave_multiple_non_contiguous_start_address_range[_this_dot_1][_this_dot_2] = config_slave_multiple_non_contiguous_start_address_range_param;
    endfunction

    function void axi4_set_config_slave_multiple_non_contiguous_end_address_range_from_CY_index2( int _this_dot_1, int _this_dot_2, bit  config_slave_multiple_non_contiguous_end_address_range_param );
        config_slave_multiple_non_contiguous_end_address_range[_this_dot_1][_this_dot_2] = config_slave_multiple_non_contiguous_end_address_range_param;
    endfunction

    function void axi4_set_config_protect_ready_from_CY( bit config_protect_ready_param );
        config_protect_ready = config_protect_ready_param;
    endfunction

    function void axi4_set_master_end_tlm_status_from_CY( bit master_end_tlm_status_param );
        master_end_tlm_status = master_end_tlm_status_param;
    endfunction

    function void axi4_set_master_end_wlm_status_from_CY( bit master_end_wlm_status_param );
        master_end_wlm_status = master_end_wlm_status_param;
    endfunction

    function void axi4_set_slave_end_tlm_status_from_CY( bit slave_end_tlm_status_param );
        slave_end_tlm_status = slave_end_tlm_status_param;
    endfunction

    function void axi4_set_slave_end_wlm_status_from_CY( bit slave_end_wlm_status_param );
        slave_end_wlm_status = slave_end_wlm_status_param;
    endfunction

    function void axi4_set_clock_source_end_tlm_status_from_CY( bit clock_source_end_tlm_status_param );
        clock_source_end_tlm_status = clock_source_end_tlm_status_param;
    endfunction

    function void axi4_set_clock_source_end_wlm_status_from_CY( bit clock_source_end_wlm_status_param );
        clock_source_end_wlm_status = clock_source_end_wlm_status_param;
    endfunction

    function void axi4_set_reset_source_end_tlm_status_from_CY( bit reset_source_end_tlm_status_param );
        reset_source_end_tlm_status = reset_source_end_tlm_status_param;
    endfunction

    function void axi4_set_reset_source_end_wlm_status_from_CY( bit reset_source_end_wlm_status_param );
        reset_source_end_wlm_status = reset_source_end_wlm_status_param;
    endfunction

    function void axi4_set_config_max_outstanding_wr_from_CY( int config_max_outstanding_wr_param );
        config_max_outstanding_wr = config_max_outstanding_wr_param;
    endfunction

    function void axi4_set_config_max_outstanding_rd_from_CY( int config_max_outstanding_rd_param );
        config_max_outstanding_rd = config_max_outstanding_rd_param;
    endfunction

    function void axi4_set_config_num_outstanding_wr_phase_from_CY( int config_num_outstanding_wr_phase_param );
        config_num_outstanding_wr_phase = config_num_outstanding_wr_phase_param;
    endfunction

    function void axi4_set_config_num_outstanding_rd_phase_from_CY( int config_num_outstanding_rd_phase_param );
        config_num_outstanding_rd_phase = config_num_outstanding_rd_phase_param;
    endfunction

    function void axi4_set_config_enable_warnings_from_CY( bit config_enable_warnings_param );
        config_enable_warnings = config_enable_warnings_param;
    endfunction

    function void axi4_set_config_enable_errors_from_CY( bit config_enable_errors_param );
        config_enable_errors = config_enable_errors_param;
    endfunction

    function void axi4_set_config_enable_exclusive_checks_from_CY( bit config_enable_exclusive_checks_param );
        config_enable_exclusive_checks = config_enable_exclusive_checks_param;
    endfunction

    function void axi4_set_config_warn_on_slave_errors_from_CY( bit config_warn_on_slave_errors_param );
        config_warn_on_slave_errors = config_warn_on_slave_errors_param;
    endfunction

    function void axi4_set_config_error_on_deleted_valid_cycles_from_CY( bit config_error_on_deleted_valid_cycles_param );
        config_error_on_deleted_valid_cycles = config_error_on_deleted_valid_cycles_param;
    endfunction

    function void axi4_set_config_stats_enable_from_CY( bit config_stats_enable_param );
        config_stats_enable = config_stats_enable_param;
    endfunction

    function void axi4_set_config_stats_enable_read_occupancy_from_CY( bit config_stats_enable_read_occupancy_param );
        config_stats_enable_read_occupancy = config_stats_enable_read_occupancy_param;
    endfunction

    function void axi4_set_config_stats_enable_write_occupancy_from_CY( bit config_stats_enable_write_occupancy_param );
        config_stats_enable_write_occupancy = config_stats_enable_write_occupancy_param;
    endfunction

    function void axi4_set_config_stats_enable_read_data_occupancy_from_CY( bit config_stats_enable_read_data_occupancy_param );
        config_stats_enable_read_data_occupancy = config_stats_enable_read_data_occupancy_param;
    endfunction

    function void axi4_set_config_stats_enable_write_data_occupancy_from_CY( bit config_stats_enable_write_data_occupancy_param );
        config_stats_enable_write_data_occupancy = config_stats_enable_write_data_occupancy_param;
    endfunction

    function void axi4_set_config_stats_enable_read_latency_from_CY( bit config_stats_enable_read_latency_param );
        config_stats_enable_read_latency = config_stats_enable_read_latency_param;
    endfunction

    function void axi4_set_config_stats_enable_write_latency_from_CY( bit config_stats_enable_write_latency_param );
        config_stats_enable_write_latency = config_stats_enable_write_latency_param;
    endfunction

    function void axi4_set_config_stats_enable_read_address_waits_from_CY( bit config_stats_enable_read_address_waits_param );
        config_stats_enable_read_address_waits = config_stats_enable_read_address_waits_param;
    endfunction

    function void axi4_set_config_stats_enable_read_data_waits_from_CY( bit config_stats_enable_read_data_waits_param );
        config_stats_enable_read_data_waits = config_stats_enable_read_data_waits_param;
    endfunction

    function void axi4_set_config_stats_enable_write_address_waits_from_CY( bit config_stats_enable_write_address_waits_param );
        config_stats_enable_write_address_waits = config_stats_enable_write_address_waits_param;
    endfunction

    function void axi4_set_config_stats_enable_write_data_waits_from_CY( bit config_stats_enable_write_data_waits_param );
        config_stats_enable_write_data_waits = config_stats_enable_write_data_waits_param;
    endfunction

    function void axi4_set_config_stats_enable_write_response_waits_from_CY( bit config_stats_enable_write_response_waits_param );
        config_stats_enable_write_response_waits = config_stats_enable_write_response_waits_param;
    endfunction

    function void axi4_set_config_stats_enable_read_bandwidth_from_CY( bit config_stats_enable_read_bandwidth_param );
        config_stats_enable_read_bandwidth = config_stats_enable_read_bandwidth_param;
    endfunction

    function void axi4_set_config_stats_enable_write_bandwidth_from_CY( bit config_stats_enable_write_bandwidth_param );
        config_stats_enable_write_bandwidth = config_stats_enable_write_bandwidth_param;
    endfunction

    function void axi4_set_stats_rw_transaction_last_duration_from_CY( int stats_rw_transaction_last_duration_param );
        stats_rw_transaction_last_duration = stats_rw_transaction_last_duration_param;
    endfunction

    function void axi4_set_config_stats_read_occupancy_step_from_CY( int config_stats_read_occupancy_step_param );
        config_stats_read_occupancy_step = config_stats_read_occupancy_step_param;
    endfunction

    function void axi4_set_config_stats_read_occupancy_multiple_from_CY( int config_stats_read_occupancy_multiple_param );
        config_stats_read_occupancy_multiple = config_stats_read_occupancy_multiple_param;
    endfunction

    function void axi4_set_stats_read_active_from_CY( bit stats_read_active_param );
        stats_read_active = stats_read_active_param;
    endfunction

    function void axi4_set_stats_read_occupancy_sw_from_CY( int stats_read_occupancy_sw_param );
        stats_read_occupancy_sw = stats_read_occupancy_sw_param;
    endfunction

    function void axi4_set_stats_read_idle_sw_from_CY( int stats_read_idle_sw_param );
        stats_read_idle_sw = stats_read_idle_sw_param;
    endfunction

    function void axi4_set_stats_read_occupancy_min_from_CY( int stats_read_occupancy_min_param );
        stats_read_occupancy_min = stats_read_occupancy_min_param;
    endfunction

    function void axi4_set_stats_read_idle_min_from_CY( int stats_read_idle_min_param );
        stats_read_idle_min = stats_read_idle_min_param;
    endfunction

    function void axi4_set_stats_read_occupancy_max_from_CY( int stats_read_occupancy_max_param );
        stats_read_occupancy_max = stats_read_occupancy_max_param;
    endfunction

    function void axi4_set_stats_read_idle_max_from_CY( int stats_read_idle_max_param );
        stats_read_idle_max = stats_read_idle_max_param;
    endfunction

    function void axi4_set_stats_read_occupancy_mean_from_CY( int stats_read_occupancy_mean_param );
        stats_read_occupancy_mean = stats_read_occupancy_mean_param;
    endfunction

    function void axi4_set_stats_read_idle_mean_from_CY( int stats_read_idle_mean_param );
        stats_read_idle_mean = stats_read_idle_mean_param;
    endfunction

    function void axi4_set_stats_read_last_duration_from_CY( int stats_read_last_duration_param );
        stats_read_last_duration = stats_read_last_duration_param;
    endfunction

    function void axi4_set_config_stats_write_occupancy_step_from_CY( int config_stats_write_occupancy_step_param );
        config_stats_write_occupancy_step = config_stats_write_occupancy_step_param;
    endfunction

    function void axi4_set_config_stats_write_occupancy_multiple_from_CY( int config_stats_write_occupancy_multiple_param );
        config_stats_write_occupancy_multiple = config_stats_write_occupancy_multiple_param;
    endfunction

    function void axi4_set_stats_write_active_from_CY( bit stats_write_active_param );
        stats_write_active = stats_write_active_param;
    endfunction

    function void axi4_set_stats_write_occupancy_sw_from_CY( int stats_write_occupancy_sw_param );
        stats_write_occupancy_sw = stats_write_occupancy_sw_param;
    endfunction

    function void axi4_set_stats_write_idle_sw_from_CY( int stats_write_idle_sw_param );
        stats_write_idle_sw = stats_write_idle_sw_param;
    endfunction

    function void axi4_set_stats_write_occupancy_min_from_CY( int stats_write_occupancy_min_param );
        stats_write_occupancy_min = stats_write_occupancy_min_param;
    endfunction

    function void axi4_set_stats_write_idle_min_from_CY( int stats_write_idle_min_param );
        stats_write_idle_min = stats_write_idle_min_param;
    endfunction

    function void axi4_set_stats_write_occupancy_max_from_CY( int stats_write_occupancy_max_param );
        stats_write_occupancy_max = stats_write_occupancy_max_param;
    endfunction

    function void axi4_set_stats_write_idle_max_from_CY( int stats_write_idle_max_param );
        stats_write_idle_max = stats_write_idle_max_param;
    endfunction

    function void axi4_set_stats_write_occupancy_mean_from_CY( int stats_write_occupancy_mean_param );
        stats_write_occupancy_mean = stats_write_occupancy_mean_param;
    endfunction

    function void axi4_set_stats_write_idle_mean_from_CY( int stats_write_idle_mean_param );
        stats_write_idle_mean = stats_write_idle_mean_param;
    endfunction

    function void axi4_set_stats_write_last_duration_from_CY( int stats_write_last_duration_param );
        stats_write_last_duration = stats_write_last_duration_param;
    endfunction

    function void axi4_set_config_stats_read_data_occupancy_step_from_CY( int config_stats_read_data_occupancy_step_param );
        config_stats_read_data_occupancy_step = config_stats_read_data_occupancy_step_param;
    endfunction

    function void axi4_set_config_stats_read_data_occupancy_multiple_from_CY( int config_stats_read_data_occupancy_multiple_param );
        config_stats_read_data_occupancy_multiple = config_stats_read_data_occupancy_multiple_param;
    endfunction

    function void axi4_set_stats_read_data_occupancy_sw_from_CY( int stats_read_data_occupancy_sw_param );
        stats_read_data_occupancy_sw = stats_read_data_occupancy_sw_param;
    endfunction

    function void axi4_set_stats_read_data_idle_sw_from_CY( int stats_read_data_idle_sw_param );
        stats_read_data_idle_sw = stats_read_data_idle_sw_param;
    endfunction

    function void axi4_set_stats_read_data_occupancy_min_from_CY( int stats_read_data_occupancy_min_param );
        stats_read_data_occupancy_min = stats_read_data_occupancy_min_param;
    endfunction

    function void axi4_set_stats_read_data_idle_min_from_CY( int stats_read_data_idle_min_param );
        stats_read_data_idle_min = stats_read_data_idle_min_param;
    endfunction

    function void axi4_set_stats_read_data_occupancy_max_from_CY( int stats_read_data_occupancy_max_param );
        stats_read_data_occupancy_max = stats_read_data_occupancy_max_param;
    endfunction

    function void axi4_set_stats_read_data_idle_max_from_CY( int stats_read_data_idle_max_param );
        stats_read_data_idle_max = stats_read_data_idle_max_param;
    endfunction

    function void axi4_set_stats_read_data_occupancy_mean_from_CY( int stats_read_data_occupancy_mean_param );
        stats_read_data_occupancy_mean = stats_read_data_occupancy_mean_param;
    endfunction

    function void axi4_set_stats_read_data_idle_mean_from_CY( int stats_read_data_idle_mean_param );
        stats_read_data_idle_mean = stats_read_data_idle_mean_param;
    endfunction

    function void axi4_set_config_stats_write_data_occupancy_step_from_CY( int config_stats_write_data_occupancy_step_param );
        config_stats_write_data_occupancy_step = config_stats_write_data_occupancy_step_param;
    endfunction

    function void axi4_set_config_stats_write_data_occupancy_multiple_from_CY( int config_stats_write_data_occupancy_multiple_param );
        config_stats_write_data_occupancy_multiple = config_stats_write_data_occupancy_multiple_param;
    endfunction

    function void axi4_set_stats_write_data_occupancy_sw_from_CY( int stats_write_data_occupancy_sw_param );
        stats_write_data_occupancy_sw = stats_write_data_occupancy_sw_param;
    endfunction

    function void axi4_set_stats_write_data_idle_sw_from_CY( int stats_write_data_idle_sw_param );
        stats_write_data_idle_sw = stats_write_data_idle_sw_param;
    endfunction

    function void axi4_set_stats_write_data_occupancy_min_from_CY( int stats_write_data_occupancy_min_param );
        stats_write_data_occupancy_min = stats_write_data_occupancy_min_param;
    endfunction

    function void axi4_set_stats_write_data_idle_min_from_CY( int stats_write_data_idle_min_param );
        stats_write_data_idle_min = stats_write_data_idle_min_param;
    endfunction

    function void axi4_set_stats_write_data_occupancy_max_from_CY( int stats_write_data_occupancy_max_param );
        stats_write_data_occupancy_max = stats_write_data_occupancy_max_param;
    endfunction

    function void axi4_set_stats_write_data_idle_max_from_CY( int stats_write_data_idle_max_param );
        stats_write_data_idle_max = stats_write_data_idle_max_param;
    endfunction

    function void axi4_set_stats_write_data_occupancy_mean_from_CY( int stats_write_data_occupancy_mean_param );
        stats_write_data_occupancy_mean = stats_write_data_occupancy_mean_param;
    endfunction

    function void axi4_set_stats_write_data_idle_mean_from_CY( int stats_write_data_idle_mean_param );
        stats_write_data_idle_mean = stats_write_data_idle_mean_param;
    endfunction

    function void axi4_set_config_stats_read_bandwidth_step_from_CY( int config_stats_read_bandwidth_step_param );
        config_stats_read_bandwidth_step = config_stats_read_bandwidth_step_param;
    endfunction

    function void axi4_set_config_stats_read_bandwidth_multiple_from_CY( int config_stats_read_bandwidth_multiple_param );
        config_stats_read_bandwidth_multiple = config_stats_read_bandwidth_multiple_param;
    endfunction

    function void axi4_set_stats_read_bandwidth_sw_from_CY( int stats_read_bandwidth_sw_param );
        stats_read_bandwidth_sw = stats_read_bandwidth_sw_param;
    endfunction

    function void axi4_set_stats_read_bandwidth_min_from_CY( int stats_read_bandwidth_min_param );
        stats_read_bandwidth_min = stats_read_bandwidth_min_param;
    endfunction

    function void axi4_set_stats_read_bandwidth_max_from_CY( int stats_read_bandwidth_max_param );
        stats_read_bandwidth_max = stats_read_bandwidth_max_param;
    endfunction

    function void axi4_set_stats_read_bandwidth_mean_from_CY( int stats_read_bandwidth_mean_param );
        stats_read_bandwidth_mean = stats_read_bandwidth_mean_param;
    endfunction

    function void axi4_set_config_stats_write_bandwidth_step_from_CY( int config_stats_write_bandwidth_step_param );
        config_stats_write_bandwidth_step = config_stats_write_bandwidth_step_param;
    endfunction

    function void axi4_set_config_stats_write_bandwidth_multiple_from_CY( int config_stats_write_bandwidth_multiple_param );
        config_stats_write_bandwidth_multiple = config_stats_write_bandwidth_multiple_param;
    endfunction

    function void axi4_set_stats_write_bandwidth_sw_from_CY( int stats_write_bandwidth_sw_param );
        stats_write_bandwidth_sw = stats_write_bandwidth_sw_param;
    endfunction

    function void axi4_set_stats_write_bandwidth_min_from_CY( int stats_write_bandwidth_min_param );
        stats_write_bandwidth_min = stats_write_bandwidth_min_param;
    endfunction

    function void axi4_set_stats_write_bandwidth_max_from_CY( int stats_write_bandwidth_max_param );
        stats_write_bandwidth_max = stats_write_bandwidth_max_param;
    endfunction

    function void axi4_set_stats_write_bandwidth_mean_from_CY( int stats_write_bandwidth_mean_param );
        stats_write_bandwidth_mean = stats_write_bandwidth_mean_param;
    endfunction

    function void axi4_set_config_stats_read_latency_step_from_CY( int config_stats_read_latency_step_param );
        config_stats_read_latency_step = config_stats_read_latency_step_param;
    endfunction

    function void axi4_set_config_stats_read_latency_multiple_from_CY( int config_stats_read_latency_multiple_param );
        config_stats_read_latency_multiple = config_stats_read_latency_multiple_param;
    endfunction

    function void axi4_set_stats_read_address_data_latency_inst_from_CY( int stats_read_address_data_latency_inst_param );
        stats_read_address_data_latency_inst = stats_read_address_data_latency_inst_param;
    endfunction

    function void axi4_set_stats_read_address_data_latency_sw_from_CY( int stats_read_address_data_latency_sw_param );
        stats_read_address_data_latency_sw = stats_read_address_data_latency_sw_param;
    endfunction

    function void axi4_set_stats_read_address_data_latency_min_from_CY( int stats_read_address_data_latency_min_param );
        stats_read_address_data_latency_min = stats_read_address_data_latency_min_param;
    endfunction

    function void axi4_set_stats_read_address_data_latency_max_from_CY( int stats_read_address_data_latency_max_param );
        stats_read_address_data_latency_max = stats_read_address_data_latency_max_param;
    endfunction

    function void axi4_set_stats_read_address_data_latency_mean_from_CY( int stats_read_address_data_latency_mean_param );
        stats_read_address_data_latency_mean = stats_read_address_data_latency_mean_param;
    endfunction

    function void axi4_set_stats_read_address_address_latency_inst_from_CY( int stats_read_address_address_latency_inst_param );
        stats_read_address_address_latency_inst = stats_read_address_address_latency_inst_param;
    endfunction

    function void axi4_set_stats_read_address_address_latency_sw_from_CY( int stats_read_address_address_latency_sw_param );
        stats_read_address_address_latency_sw = stats_read_address_address_latency_sw_param;
    endfunction

    function void axi4_set_stats_read_address_address_latency_min_from_CY( int stats_read_address_address_latency_min_param );
        stats_read_address_address_latency_min = stats_read_address_address_latency_min_param;
    endfunction

    function void axi4_set_stats_read_address_address_latency_max_from_CY( int stats_read_address_address_latency_max_param );
        stats_read_address_address_latency_max = stats_read_address_address_latency_max_param;
    endfunction

    function void axi4_set_stats_read_address_address_latency_mean_from_CY( int stats_read_address_address_latency_mean_param );
        stats_read_address_address_latency_mean = stats_read_address_address_latency_mean_param;
    endfunction

    function void axi4_set_config_stats_write_latency_step_from_CY( int config_stats_write_latency_step_param );
        config_stats_write_latency_step = config_stats_write_latency_step_param;
    endfunction

    function void axi4_set_config_stats_write_latency_multiple_from_CY( int config_stats_write_latency_multiple_param );
        config_stats_write_latency_multiple = config_stats_write_latency_multiple_param;
    endfunction

    function void axi4_set_stats_write_address_response_latency_inst_from_CY( int stats_write_address_response_latency_inst_param );
        stats_write_address_response_latency_inst = stats_write_address_response_latency_inst_param;
    endfunction

    function void axi4_set_stats_write_address_response_latency_sw_from_CY( int stats_write_address_response_latency_sw_param );
        stats_write_address_response_latency_sw = stats_write_address_response_latency_sw_param;
    endfunction

    function void axi4_set_stats_write_address_response_latency_min_from_CY( int stats_write_address_response_latency_min_param );
        stats_write_address_response_latency_min = stats_write_address_response_latency_min_param;
    endfunction

    function void axi4_set_stats_write_address_response_latency_max_from_CY( int stats_write_address_response_latency_max_param );
        stats_write_address_response_latency_max = stats_write_address_response_latency_max_param;
    endfunction

    function void axi4_set_stats_write_address_response_latency_mean_from_CY( int stats_write_address_response_latency_mean_param );
        stats_write_address_response_latency_mean = stats_write_address_response_latency_mean_param;
    endfunction

    function void axi4_set_stats_write_address_address_latency_inst_from_CY( int stats_write_address_address_latency_inst_param );
        stats_write_address_address_latency_inst = stats_write_address_address_latency_inst_param;
    endfunction

    function void axi4_set_stats_write_address_address_latency_sw_from_CY( int stats_write_address_address_latency_sw_param );
        stats_write_address_address_latency_sw = stats_write_address_address_latency_sw_param;
    endfunction

    function void axi4_set_stats_write_address_address_latency_min_from_CY( int stats_write_address_address_latency_min_param );
        stats_write_address_address_latency_min = stats_write_address_address_latency_min_param;
    endfunction

    function void axi4_set_stats_write_address_address_latency_max_from_CY( int stats_write_address_address_latency_max_param );
        stats_write_address_address_latency_max = stats_write_address_address_latency_max_param;
    endfunction

    function void axi4_set_stats_write_address_address_latency_mean_from_CY( int stats_write_address_address_latency_mean_param );
        stats_write_address_address_latency_mean = stats_write_address_address_latency_mean_param;
    endfunction

    function void axi4_set_config_stats_read_address_waits_step_from_CY( int config_stats_read_address_waits_step_param );
        config_stats_read_address_waits_step = config_stats_read_address_waits_step_param;
    endfunction

    function void axi4_set_config_stats_read_address_waits_multiple_from_CY( int config_stats_read_address_waits_multiple_param );
        config_stats_read_address_waits_multiple = config_stats_read_address_waits_multiple_param;
    endfunction

    function void axi4_set_stats_read_address_waits_inst_from_CY( int stats_read_address_waits_inst_param );
        stats_read_address_waits_inst = stats_read_address_waits_inst_param;
    endfunction

    function void axi4_set_stats_read_address_waits_sw_from_CY( int stats_read_address_waits_sw_param );
        stats_read_address_waits_sw = stats_read_address_waits_sw_param;
    endfunction

    function void axi4_set_stats_read_address_waits_min_from_CY( int stats_read_address_waits_min_param );
        stats_read_address_waits_min = stats_read_address_waits_min_param;
    endfunction

    function void axi4_set_stats_read_address_waits_max_from_CY( int stats_read_address_waits_max_param );
        stats_read_address_waits_max = stats_read_address_waits_max_param;
    endfunction

    function void axi4_set_stats_read_address_waits_mean_from_CY( int stats_read_address_waits_mean_param );
        stats_read_address_waits_mean = stats_read_address_waits_mean_param;
    endfunction

    function void axi4_set_config_stats_read_data_waits_step_from_CY( int config_stats_read_data_waits_step_param );
        config_stats_read_data_waits_step = config_stats_read_data_waits_step_param;
    endfunction

    function void axi4_set_config_stats_read_data_waits_multiple_from_CY( int config_stats_read_data_waits_multiple_param );
        config_stats_read_data_waits_multiple = config_stats_read_data_waits_multiple_param;
    endfunction

    function void axi4_set_stats_read_data_waits_inst_from_CY( int stats_read_data_waits_inst_param );
        stats_read_data_waits_inst = stats_read_data_waits_inst_param;
    endfunction

    function void axi4_set_stats_read_data_waits_sw_from_CY( int stats_read_data_waits_sw_param );
        stats_read_data_waits_sw = stats_read_data_waits_sw_param;
    endfunction

    function void axi4_set_stats_read_data_waits_min_from_CY( int stats_read_data_waits_min_param );
        stats_read_data_waits_min = stats_read_data_waits_min_param;
    endfunction

    function void axi4_set_stats_read_data_waits_max_from_CY( int stats_read_data_waits_max_param );
        stats_read_data_waits_max = stats_read_data_waits_max_param;
    endfunction

    function void axi4_set_stats_read_data_waits_mean_from_CY( int stats_read_data_waits_mean_param );
        stats_read_data_waits_mean = stats_read_data_waits_mean_param;
    endfunction

    function void axi4_set_config_stats_write_address_waits_step_from_CY( int config_stats_write_address_waits_step_param );
        config_stats_write_address_waits_step = config_stats_write_address_waits_step_param;
    endfunction

    function void axi4_set_config_stats_write_address_waits_multiple_from_CY( int config_stats_write_address_waits_multiple_param );
        config_stats_write_address_waits_multiple = config_stats_write_address_waits_multiple_param;
    endfunction

    function void axi4_set_stats_write_address_waits_inst_from_CY( int stats_write_address_waits_inst_param );
        stats_write_address_waits_inst = stats_write_address_waits_inst_param;
    endfunction

    function void axi4_set_stats_write_address_waits_sw_from_CY( int stats_write_address_waits_sw_param );
        stats_write_address_waits_sw = stats_write_address_waits_sw_param;
    endfunction

    function void axi4_set_stats_write_address_waits_min_from_CY( int stats_write_address_waits_min_param );
        stats_write_address_waits_min = stats_write_address_waits_min_param;
    endfunction

    function void axi4_set_stats_write_address_waits_max_from_CY( int stats_write_address_waits_max_param );
        stats_write_address_waits_max = stats_write_address_waits_max_param;
    endfunction

    function void axi4_set_stats_write_address_waits_mean_from_CY( int stats_write_address_waits_mean_param );
        stats_write_address_waits_mean = stats_write_address_waits_mean_param;
    endfunction

    function void axi4_set_config_stats_write_data_waits_step_from_CY( int config_stats_write_data_waits_step_param );
        config_stats_write_data_waits_step = config_stats_write_data_waits_step_param;
    endfunction

    function void axi4_set_config_stats_write_data_waits_multiple_from_CY( int config_stats_write_data_waits_multiple_param );
        config_stats_write_data_waits_multiple = config_stats_write_data_waits_multiple_param;
    endfunction

    function void axi4_set_stats_write_data_waits_inst_from_CY( int stats_write_data_waits_inst_param );
        stats_write_data_waits_inst = stats_write_data_waits_inst_param;
    endfunction

    function void axi4_set_stats_write_data_waits_sw_from_CY( int stats_write_data_waits_sw_param );
        stats_write_data_waits_sw = stats_write_data_waits_sw_param;
    endfunction

    function void axi4_set_stats_write_data_waits_min_from_CY( int stats_write_data_waits_min_param );
        stats_write_data_waits_min = stats_write_data_waits_min_param;
    endfunction

    function void axi4_set_stats_write_data_waits_max_from_CY( int stats_write_data_waits_max_param );
        stats_write_data_waits_max = stats_write_data_waits_max_param;
    endfunction

    function void axi4_set_stats_write_data_waits_mean_from_CY( int stats_write_data_waits_mean_param );
        stats_write_data_waits_mean = stats_write_data_waits_mean_param;
    endfunction

    function void axi4_set_config_stats_write_response_waits_step_from_CY( int config_stats_write_response_waits_step_param );
        config_stats_write_response_waits_step = config_stats_write_response_waits_step_param;
    endfunction

    function void axi4_set_config_stats_write_response_waits_multiple_from_CY( int config_stats_write_response_waits_multiple_param );
        config_stats_write_response_waits_multiple = config_stats_write_response_waits_multiple_param;
    endfunction

    function void axi4_set_stats_write_response_waits_inst_from_CY( int stats_write_response_waits_inst_param );
        stats_write_response_waits_inst = stats_write_response_waits_inst_param;
    endfunction

    function void axi4_set_stats_write_response_waits_sw_from_CY( int stats_write_response_waits_sw_param );
        stats_write_response_waits_sw = stats_write_response_waits_sw_param;
    endfunction

    function void axi4_set_stats_write_response_waits_min_from_CY( int stats_write_response_waits_min_param );
        stats_write_response_waits_min = stats_write_response_waits_min_param;
    endfunction

    function void axi4_set_stats_write_response_waits_max_from_CY( int stats_write_response_waits_max_param );
        stats_write_response_waits_max = stats_write_response_waits_max_param;
    endfunction

    function void axi4_set_stats_write_response_waits_mean_from_CY( int stats_write_response_waits_mean_param );
        stats_write_response_waits_mean = stats_write_response_waits_mean_param;
    endfunction

    function void axi4_set_reordering_depth_of_last_read_transaction_from_CY( int reordering_depth_of_last_read_transaction_param );
        reordering_depth_of_last_read_transaction = reordering_depth_of_last_read_transaction_param;
    endfunction

    //------------------------------------------------------------------------------
    // TLM Interface Support
    //------------------------------------------------------------------------------

    export "DPI-C" axi4_get_temp_static_rw_transaction_addr = function axi4_get_temp_static_rw_transaction_addr;
    export "DPI-C" axi4_set_temp_static_rw_transaction_addr = function axi4_set_temp_static_rw_transaction_addr;
    export "DPI-C" axi4_get_temp_static_rw_transaction_id = function axi4_get_temp_static_rw_transaction_id;
    export "DPI-C" axi4_set_temp_static_rw_transaction_id = function axi4_set_temp_static_rw_transaction_id;
    export "DPI-C" axi4_get_temp_static_rw_transaction_addr_user_data = function axi4_get_temp_static_rw_transaction_addr_user_data;
    export "DPI-C" axi4_set_temp_static_rw_transaction_addr_user_data = function axi4_set_temp_static_rw_transaction_addr_user_data;
    export "DPI-C" axi4_get_temp_static_rw_transaction_data_words = function axi4_get_temp_static_rw_transaction_data_words;
    export "DPI-C" axi4_set_temp_static_rw_transaction_data_words = function axi4_set_temp_static_rw_transaction_data_words;
    export "DPI-C" axi4_get_temp_static_rw_transaction_write_strobes = function axi4_get_temp_static_rw_transaction_write_strobes;
    export "DPI-C" axi4_set_temp_static_rw_transaction_write_strobes = function axi4_set_temp_static_rw_transaction_write_strobes;
    export "DPI-C" axi4_get_temp_static_rw_transaction_wdata_user_data = function axi4_get_temp_static_rw_transaction_wdata_user_data;
    export "DPI-C" axi4_set_temp_static_rw_transaction_wdata_user_data = function axi4_set_temp_static_rw_transaction_wdata_user_data;
    export "DPI-C" axi4_get_temp_static_rw_transaction_resp = function axi4_get_temp_static_rw_transaction_resp;
    export "DPI-C" axi4_set_temp_static_rw_transaction_resp = function axi4_set_temp_static_rw_transaction_resp;
    export "DPI-C" axi4_get_temp_static_rw_transaction_resp_user_data = function axi4_get_temp_static_rw_transaction_resp_user_data;
    export "DPI-C" axi4_set_temp_static_rw_transaction_resp_user_data = function axi4_set_temp_static_rw_transaction_resp_user_data;
    export "DPI-C" axi4_get_temp_static_rw_transaction_data_valid_delay = function axi4_get_temp_static_rw_transaction_data_valid_delay;
    export "DPI-C" axi4_set_temp_static_rw_transaction_data_valid_delay = function axi4_set_temp_static_rw_transaction_data_valid_delay;
    export "DPI-C" axi4_get_temp_static_rw_transaction_data_ready_delay = function axi4_get_temp_static_rw_transaction_data_ready_delay;
    export "DPI-C" axi4_set_temp_static_rw_transaction_data_ready_delay = function axi4_set_temp_static_rw_transaction_data_ready_delay;
    export "DPI-C" axi4_get_temp_static_rw_transaction_write_data_beats_delay = function axi4_get_temp_static_rw_transaction_write_data_beats_delay;
    export "DPI-C" axi4_set_temp_static_rw_transaction_write_data_beats_delay = function axi4_set_temp_static_rw_transaction_write_data_beats_delay;
    import "DPI-C" context axi4_rw_transaction_ActivatesActivatingActivate_SystemVerilog =
    task axi4_rw_transaction_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int read_or_write,
        inout int prot,
        inout bit [3:0] region,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout bit [3:0] qos,
        inout bit [7:0] burst_length,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int wdata_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int address_valid_delay,
        inout int data_valid_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_response_valid_delay,
        inout int address_ready_delay,
        inout int data_ready_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_response_ready_delay,
        inout bit write_data_with_address,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi4_rw_transaction_ActivatesActivatingActivate_open_SystemVerilog =
    task axi4_rw_transaction_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int read_or_write,
        inout int prot,
        inout bit [((4) - 1):0] region,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout bit [((4) - 1):0] qos,
        inout bit [((8) - 1):0] burst_length,
        inout int address_valid_delay,
        inout int write_response_valid_delay,
        inout int address_ready_delay,
        inout int write_response_ready_delay,
        inout bit write_data_with_address,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_rw_transaction_ReceivedReceivingReceive_SystemVerilog =
    task axi4_rw_transaction_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int wdata_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_valid_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_ready_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_rw_transaction_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_rw_transaction_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int read_or_write,
        output int prot,
        output bit [((4) - 1):0] region,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output bit [((4) - 1):0] qos,
        output bit [((8) - 1):0] burst_length,
        output int address_valid_delay,
        output int write_response_valid_delay,
        output int address_ready_delay,
        output int write_response_ready_delay,
        output bit write_data_with_address,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_read_addr = function axi4_get_temp_static_read_addr;
    export "DPI-C" axi4_set_temp_static_read_addr = function axi4_set_temp_static_read_addr;
    export "DPI-C" axi4_get_temp_static_read_rresp_delays = function axi4_get_temp_static_read_rresp_delays;
    export "DPI-C" axi4_set_temp_static_read_rresp_delays = function axi4_set_temp_static_read_rresp_delays;
    export "DPI-C" axi4_get_temp_static_read_id = function axi4_get_temp_static_read_id;
    export "DPI-C" axi4_set_temp_static_read_id = function axi4_set_temp_static_read_id;
    export "DPI-C" axi4_get_temp_static_read_addr_user_data = function axi4_get_temp_static_read_addr_user_data;
    export "DPI-C" axi4_set_temp_static_read_addr_user_data = function axi4_set_temp_static_read_addr_user_data;
    export "DPI-C" axi4_get_temp_static_read_data_words = function axi4_get_temp_static_read_data_words;
    export "DPI-C" axi4_set_temp_static_read_data_words = function axi4_set_temp_static_read_data_words;
    export "DPI-C" axi4_get_temp_static_read_resp = function axi4_get_temp_static_read_resp;
    export "DPI-C" axi4_set_temp_static_read_resp = function axi4_set_temp_static_read_resp;
    export "DPI-C" axi4_get_temp_static_read_resp_user_data = function axi4_get_temp_static_read_resp_user_data;
    export "DPI-C" axi4_set_temp_static_read_resp_user_data = function axi4_set_temp_static_read_resp_user_data;
    export "DPI-C" axi4_get_temp_static_read_data_start_time = function axi4_get_temp_static_read_data_start_time;
    export "DPI-C" axi4_set_temp_static_read_data_start_time = function axi4_set_temp_static_read_data_start_time;
    export "DPI-C" axi4_get_temp_static_read_data_end_time = function axi4_get_temp_static_read_data_end_time;
    export "DPI-C" axi4_set_temp_static_read_data_end_time = function axi4_set_temp_static_read_data_end_time;
    import "DPI-C" context axi4_read_ActivatesActivatingActivate_SystemVerilog =
    task axi4_read_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int prot,
        inout bit [3:0] region,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout bit [3:0] qos,
        inout bit [7:0] burst_length,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_ActivatesActivatingActivate_open_SystemVerilog =
    task axi4_read_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int prot,
        inout bit [((4) - 1):0] region,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout bit [((4) - 1):0] qos,
        inout bit [((8) - 1):0] burst_length,
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_read_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int prot,
        output bit [((4) - 1):0] region,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output bit [((4) - 1):0] qos,
        output bit [((8) - 1):0] burst_length,
        output longint addr_start_time,
        output longint addr_end_time,
        output int address_valid_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_write_addr = function axi4_get_temp_static_write_addr;
    export "DPI-C" axi4_set_temp_static_write_addr = function axi4_set_temp_static_write_addr;
    export "DPI-C" axi4_get_temp_static_write_id = function axi4_get_temp_static_write_id;
    export "DPI-C" axi4_set_temp_static_write_id = function axi4_set_temp_static_write_id;
    export "DPI-C" axi4_get_temp_static_write_addr_user_data = function axi4_get_temp_static_write_addr_user_data;
    export "DPI-C" axi4_set_temp_static_write_addr_user_data = function axi4_set_temp_static_write_addr_user_data;
    export "DPI-C" axi4_get_temp_static_write_data_words = function axi4_get_temp_static_write_data_words;
    export "DPI-C" axi4_set_temp_static_write_data_words = function axi4_set_temp_static_write_data_words;
    export "DPI-C" axi4_get_temp_static_write_write_strobes = function axi4_get_temp_static_write_write_strobes;
    export "DPI-C" axi4_set_temp_static_write_write_strobes = function axi4_set_temp_static_write_write_strobes;
    export "DPI-C" axi4_get_temp_static_write_wdata_user_data = function axi4_get_temp_static_write_wdata_user_data;
    export "DPI-C" axi4_set_temp_static_write_wdata_user_data = function axi4_set_temp_static_write_wdata_user_data;
    export "DPI-C" axi4_get_temp_static_write_resp_user_data = function axi4_get_temp_static_write_resp_user_data;
    export "DPI-C" axi4_set_temp_static_write_resp_user_data = function axi4_set_temp_static_write_resp_user_data;
    export "DPI-C" axi4_get_temp_static_write_data_start_time = function axi4_get_temp_static_write_data_start_time;
    export "DPI-C" axi4_set_temp_static_write_data_start_time = function axi4_set_temp_static_write_data_start_time;
    export "DPI-C" axi4_get_temp_static_write_data_end_time = function axi4_get_temp_static_write_data_end_time;
    export "DPI-C" axi4_set_temp_static_write_data_end_time = function axi4_set_temp_static_write_data_end_time;
    export "DPI-C" axi4_get_temp_static_write_write_data_beats_delay = function axi4_get_temp_static_write_write_data_beats_delay;
    export "DPI-C" axi4_set_temp_static_write_write_data_beats_delay = function axi4_set_temp_static_write_write_data_beats_delay;
    import "DPI-C" context axi4_write_ActivatesActivatingActivate_SystemVerilog =
    task axi4_write_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int prot,
        inout int bresp_delay,
        inout bit [3:0] region,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout bit [3:0] qos,
        inout bit [7:0] burst_length,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int wdata_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp,
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout longint wr_resp_start_time,
        inout longint wr_resp_end_time,
        inout int address_valid_delay,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi4_write_ActivatesActivatingActivate_open_SystemVerilog =
    task axi4_write_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int prot,
        inout int bresp_delay,
        inout bit [((4) - 1):0] region,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout bit [((4) - 1):0] qos,
        inout bit [((8) - 1):0] burst_length,
        inout int resp,
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout longint wr_resp_start_time,
        inout longint wr_resp_end_time,
        inout int address_valid_delay,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int wdata_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_write_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int prot,
        output int bresp_delay,
        output bit [((4) - 1):0] region,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output bit [((4) - 1):0] qos,
        output bit [((8) - 1):0] burst_length,
        output int resp,
        output longint addr_start_time,
        output longint addr_end_time,
        output longint wr_resp_start_time,
        output longint wr_resp_end_time,
        output int address_valid_delay,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_write_data_burst_data_words = function axi4_get_temp_static_write_data_burst_data_words;
    export "DPI-C" axi4_set_temp_static_write_data_burst_data_words = function axi4_set_temp_static_write_data_burst_data_words;
    export "DPI-C" axi4_get_temp_static_write_data_burst_write_strobes = function axi4_get_temp_static_write_data_burst_write_strobes;
    export "DPI-C" axi4_set_temp_static_write_data_burst_write_strobes = function axi4_set_temp_static_write_data_burst_write_strobes;
    export "DPI-C" axi4_get_temp_static_write_data_burst_user_data = function axi4_get_temp_static_write_data_burst_user_data;
    export "DPI-C" axi4_set_temp_static_write_data_burst_user_data = function axi4_set_temp_static_write_data_burst_user_data;
    export "DPI-C" axi4_get_temp_static_write_data_burst_data_start_time = function axi4_get_temp_static_write_data_burst_data_start_time;
    export "DPI-C" axi4_set_temp_static_write_data_burst_data_start_time = function axi4_set_temp_static_write_data_burst_data_start_time;
    export "DPI-C" axi4_get_temp_static_write_data_burst_data_end_time = function axi4_get_temp_static_write_data_burst_data_end_time;
    export "DPI-C" axi4_set_temp_static_write_data_burst_data_end_time = function axi4_set_temp_static_write_data_burst_data_end_time;
    export "DPI-C" axi4_get_temp_static_write_data_burst_write_data_beats_delay = function axi4_get_temp_static_write_data_burst_write_data_beats_delay;
    export "DPI-C" axi4_set_temp_static_write_data_burst_write_data_beats_delay = function axi4_set_temp_static_write_data_burst_write_data_beats_delay;
    import "DPI-C" context axi4_write_data_burst_SendSendingSent_SystemVerilog =
    task axi4_write_data_burst_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int burst_length,
        input int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi4_write_data_burst_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_data_burst_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_data_burst_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_write_data_burst_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int burst_length,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_read_addr_channel_phase_addr = function axi4_get_temp_static_read_addr_channel_phase_addr;
    export "DPI-C" axi4_set_temp_static_read_addr_channel_phase_addr = function axi4_set_temp_static_read_addr_channel_phase_addr;
    export "DPI-C" axi4_get_temp_static_read_addr_channel_phase_id = function axi4_get_temp_static_read_addr_channel_phase_id;
    export "DPI-C" axi4_set_temp_static_read_addr_channel_phase_id = function axi4_set_temp_static_read_addr_channel_phase_id;
    export "DPI-C" axi4_get_temp_static_read_addr_channel_phase_addr_user = function axi4_get_temp_static_read_addr_channel_phase_addr_user;
    export "DPI-C" axi4_set_temp_static_read_addr_channel_phase_addr_user = function axi4_set_temp_static_read_addr_channel_phase_addr_user;
    import "DPI-C" context axi4_read_addr_channel_phase_SendSendingSent_SystemVerilog =
    task axi4_read_addr_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int prot,
        input bit [3:0] region,
        input bit [7:0] burst_length,
        input int size,
        input int burst,
        input int lock,
        input int cache,
        input bit [3:0] qos,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_read_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int prot,
        output bit [((4) - 1):0] region,
        output bit [((8) - 1):0] burst_length,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output bit [((4) - 1):0] qos,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_data_burst_SendSendingSent_SystemVerilog =
    task axi4_read_data_burst_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_data_burst_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_data_burst_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_read_channel_phase_data = function axi4_get_temp_static_read_channel_phase_data;
    export "DPI-C" axi4_set_temp_static_read_channel_phase_data = function axi4_set_temp_static_read_channel_phase_data;
    export "DPI-C" axi4_get_temp_static_read_channel_phase_id = function axi4_get_temp_static_read_channel_phase_id;
    export "DPI-C" axi4_set_temp_static_read_channel_phase_id = function axi4_set_temp_static_read_channel_phase_id;
    export "DPI-C" axi4_get_temp_static_read_channel_phase_user_data = function axi4_get_temp_static_read_channel_phase_user_data;
    export "DPI-C" axi4_set_temp_static_read_channel_phase_user_data = function axi4_set_temp_static_read_channel_phase_user_data;
    import "DPI-C" context axi4_read_channel_phase_SendSendingSent_SystemVerilog =
    task axi4_read_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int resp,
        input bit last,
        input int data_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_channel_phase_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_read_channel_phase_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int resp,
        output bit last,
        output int data_ready_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_write_addr_channel_phase_addr = function axi4_get_temp_static_write_addr_channel_phase_addr;
    export "DPI-C" axi4_set_temp_static_write_addr_channel_phase_addr = function axi4_set_temp_static_write_addr_channel_phase_addr;
    export "DPI-C" axi4_get_temp_static_write_addr_channel_phase_id = function axi4_get_temp_static_write_addr_channel_phase_id;
    export "DPI-C" axi4_set_temp_static_write_addr_channel_phase_id = function axi4_set_temp_static_write_addr_channel_phase_id;
    export "DPI-C" axi4_get_temp_static_write_addr_channel_phase_addr_user = function axi4_get_temp_static_write_addr_channel_phase_addr_user;
    export "DPI-C" axi4_set_temp_static_write_addr_channel_phase_addr_user = function axi4_set_temp_static_write_addr_channel_phase_addr_user;
    import "DPI-C" context axi4_write_addr_channel_phase_SendSendingSent_SystemVerilog =
    task axi4_write_addr_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int prot,
        input bit [3:0] region,
        input bit [7:0] burst_length,
        input int size,
        input int burst,
        input int lock,
        input int cache,
        input bit [3:0] qos,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_write_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int prot,
        output bit [((4) - 1):0] region,
        output bit [((8) - 1):0] burst_length,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output bit [((4) - 1):0] qos,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_write_channel_phase_data = function axi4_get_temp_static_write_channel_phase_data;
    export "DPI-C" axi4_set_temp_static_write_channel_phase_data = function axi4_set_temp_static_write_channel_phase_data;
    export "DPI-C" axi4_get_temp_static_write_channel_phase_write_strobes = function axi4_get_temp_static_write_channel_phase_write_strobes;
    export "DPI-C" axi4_set_temp_static_write_channel_phase_write_strobes = function axi4_set_temp_static_write_channel_phase_write_strobes;
    export "DPI-C" axi4_get_temp_static_write_channel_phase_user_data = function axi4_get_temp_static_write_channel_phase_user_data;
    export "DPI-C" axi4_set_temp_static_write_channel_phase_user_data = function axi4_set_temp_static_write_channel_phase_user_data;
    import "DPI-C" context axi4_write_channel_phase_SendSendingSent_SystemVerilog =
    task axi4_write_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit last,
        input int data_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_channel_phase_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_write_channel_phase_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit last,
        output int data_ready_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_write_resp_channel_phase_id = function axi4_get_temp_static_write_resp_channel_phase_id;
    export "DPI-C" axi4_set_temp_static_write_resp_channel_phase_id = function axi4_set_temp_static_write_resp_channel_phase_id;
    export "DPI-C" axi4_get_temp_static_write_resp_channel_phase_user_data = function axi4_get_temp_static_write_resp_channel_phase_user_data;
    export "DPI-C" axi4_set_temp_static_write_resp_channel_phase_user_data = function axi4_set_temp_static_write_resp_channel_phase_user_data;
    import "DPI-C" context axi4_write_resp_channel_phase_SendSendingSent_SystemVerilog =
    task axi4_write_resp_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int resp,
        input int write_response_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_resp_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_resp_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_resp_channel_phase_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_write_resp_channel_phase_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int resp,
        output int write_response_ready_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_read_addr_channel_cycle_addr = function axi4_get_temp_static_read_addr_channel_cycle_addr;
    export "DPI-C" axi4_set_temp_static_read_addr_channel_cycle_addr = function axi4_set_temp_static_read_addr_channel_cycle_addr;
    export "DPI-C" axi4_get_temp_static_read_addr_channel_cycle_id = function axi4_get_temp_static_read_addr_channel_cycle_id;
    export "DPI-C" axi4_set_temp_static_read_addr_channel_cycle_id = function axi4_set_temp_static_read_addr_channel_cycle_id;
    export "DPI-C" axi4_get_temp_static_read_addr_channel_cycle_user_data = function axi4_get_temp_static_read_addr_channel_cycle_user_data;
    export "DPI-C" axi4_set_temp_static_read_addr_channel_cycle_user_data = function axi4_set_temp_static_read_addr_channel_cycle_user_data;
    import "DPI-C" context axi4_read_addr_channel_cycle_SendSendingSent_SystemVerilog =
    task axi4_read_addr_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [3:0] region,
        input int cache,
        input bit [7:0] burst_length,
        input int size,
        input int burst,
        input int lock,
        input bit [3:0] qos,
        input int prot,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_read_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((4) - 1):0] region,
        output int cache,
        output bit [((8) - 1):0] burst_length,
        output int size,
        output int burst,
        output int lock,
        output bit [((4) - 1):0] qos,
        output int prot,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_addr_channel_ready_SendSendingSent_SystemVerilog =
    task axi4_read_addr_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_read_channel_cycle_data = function axi4_get_temp_static_read_channel_cycle_data;
    export "DPI-C" axi4_set_temp_static_read_channel_cycle_data = function axi4_set_temp_static_read_channel_cycle_data;
    export "DPI-C" axi4_get_temp_static_read_channel_cycle_id = function axi4_get_temp_static_read_channel_cycle_id;
    export "DPI-C" axi4_set_temp_static_read_channel_cycle_id = function axi4_set_temp_static_read_channel_cycle_id;
    export "DPI-C" axi4_get_temp_static_read_channel_cycle_user_data = function axi4_get_temp_static_read_channel_cycle_user_data;
    export "DPI-C" axi4_set_temp_static_read_channel_cycle_user_data = function axi4_set_temp_static_read_channel_cycle_user_data;
    import "DPI-C" context axi4_read_channel_cycle_SendSendingSent_SystemVerilog =
    task axi4_read_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int resp,
        input bit last,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_read_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int resp,
        output bit last,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_channel_ready_SendSendingSent_SystemVerilog =
    task axi4_read_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_write_addr_channel_cycle_addr = function axi4_get_temp_static_write_addr_channel_cycle_addr;
    export "DPI-C" axi4_set_temp_static_write_addr_channel_cycle_addr = function axi4_set_temp_static_write_addr_channel_cycle_addr;
    export "DPI-C" axi4_get_temp_static_write_addr_channel_cycle_id = function axi4_get_temp_static_write_addr_channel_cycle_id;
    export "DPI-C" axi4_set_temp_static_write_addr_channel_cycle_id = function axi4_set_temp_static_write_addr_channel_cycle_id;
    export "DPI-C" axi4_get_temp_static_write_addr_channel_cycle_user_data = function axi4_get_temp_static_write_addr_channel_cycle_user_data;
    export "DPI-C" axi4_set_temp_static_write_addr_channel_cycle_user_data = function axi4_set_temp_static_write_addr_channel_cycle_user_data;
    import "DPI-C" context axi4_write_addr_channel_cycle_SendSendingSent_SystemVerilog =
    task axi4_write_addr_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [3:0] region,
        input int cache,
        input bit [7:0] burst_length,
        input int size,
        input int burst,
        input int lock,
        input bit [3:0] qos,
        input int prot,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_write_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((4) - 1):0] region,
        output int cache,
        output bit [((8) - 1):0] burst_length,
        output int size,
        output int burst,
        output int lock,
        output bit [((4) - 1):0] qos,
        output int prot,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_addr_channel_ready_SendSendingSent_SystemVerilog =
    task axi4_write_addr_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_write_channel_cycle_data = function axi4_get_temp_static_write_channel_cycle_data;
    export "DPI-C" axi4_set_temp_static_write_channel_cycle_data = function axi4_set_temp_static_write_channel_cycle_data;
    export "DPI-C" axi4_get_temp_static_write_channel_cycle_strb = function axi4_get_temp_static_write_channel_cycle_strb;
    export "DPI-C" axi4_set_temp_static_write_channel_cycle_strb = function axi4_set_temp_static_write_channel_cycle_strb;
    export "DPI-C" axi4_get_temp_static_write_channel_cycle_user_data = function axi4_get_temp_static_write_channel_cycle_user_data;
    export "DPI-C" axi4_set_temp_static_write_channel_cycle_user_data = function axi4_set_temp_static_write_channel_cycle_user_data;
    import "DPI-C" context axi4_write_channel_cycle_SendSendingSent_SystemVerilog =
    task axi4_write_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit last,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_write_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit last,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_channel_ready_SendSendingSent_SystemVerilog =
    task axi4_write_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_write_resp_channel_cycle_id = function axi4_get_temp_static_write_resp_channel_cycle_id;
    export "DPI-C" axi4_set_temp_static_write_resp_channel_cycle_id = function axi4_set_temp_static_write_resp_channel_cycle_id;
    export "DPI-C" axi4_get_temp_static_write_resp_channel_cycle_user_data = function axi4_get_temp_static_write_resp_channel_cycle_user_data;
    export "DPI-C" axi4_set_temp_static_write_resp_channel_cycle_user_data = function axi4_set_temp_static_write_resp_channel_cycle_user_data;
    import "DPI-C" context axi4_write_resp_channel_cycle_SendSendingSent_SystemVerilog =
    task axi4_write_resp_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int resp,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_resp_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_resp_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_resp_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_write_resp_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int resp,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_resp_channel_ready_SendSendingSent_SystemVerilog =
    task axi4_write_resp_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_resp_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_resp_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_unexpected_write_response_id = function axi4_get_temp_static_unexpected_write_response_id;
    export "DPI-C" axi4_set_temp_static_unexpected_write_response_id = function axi4_set_temp_static_unexpected_write_response_id;
    export "DPI-C" axi4_get_temp_static_unexpected_write_response_resp_user_data = function axi4_get_temp_static_unexpected_write_response_resp_user_data;
    export "DPI-C" axi4_set_temp_static_unexpected_write_response_resp_user_data = function axi4_set_temp_static_unexpected_write_response_resp_user_data;
    import "DPI-C" context axi4_unexpected_write_response_SendSendingSent_SystemVerilog =
    task axi4_unexpected_write_response_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int resp,
        input int _unit_id
    );
    import "DPI-C" context axi4_unexpected_write_response_ReceivedReceivingReceive_SystemVerilog =
    task axi4_unexpected_write_response_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_unexpected_write_response_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_unexpected_write_response_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int resp,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_unexpected_read_response_data = function axi4_get_temp_static_unexpected_read_response_data;
    export "DPI-C" axi4_set_temp_static_unexpected_read_response_data = function axi4_set_temp_static_unexpected_read_response_data;
    export "DPI-C" axi4_get_temp_static_unexpected_read_response_id = function axi4_get_temp_static_unexpected_read_response_id;
    export "DPI-C" axi4_set_temp_static_unexpected_read_response_id = function axi4_set_temp_static_unexpected_read_response_id;
    export "DPI-C" axi4_get_temp_static_unexpected_read_response_user_data = function axi4_get_temp_static_unexpected_read_response_user_data;
    export "DPI-C" axi4_set_temp_static_unexpected_read_response_user_data = function axi4_set_temp_static_unexpected_read_response_user_data;
    import "DPI-C" context axi4_unexpected_read_response_SendSendingSent_SystemVerilog =
    task axi4_unexpected_read_response_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int resp,
        input bit last,
        input int _unit_id
    );
    import "DPI-C" context axi4_unexpected_read_response_ReceivedReceivingReceive_SystemVerilog =
    task axi4_unexpected_read_response_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_unexpected_read_response_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_unexpected_read_response_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int resp,
        output bit last,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_end_of_timestep_VPI_SystemVerilog =
    task axi4_end_of_timestep_VPI_SystemVerilog();
    import "DPI-C" context function longint axi4_get_interface_handle();

    // Waiter task and control
    reg wait_for_control = 0;

    always @(posedge wait_for_control)
    begin
        disable wait_for;
        wait_for_control = 0;
    end

    export "DPI-C" axi4_wait_for = task wait_for;

    task wait_for();
        begin
            wait(0 == 1);
        end
    endtask

    // handle control
    longint last_handle = 0;

    longint last_start_time = 0;

    longint last_end_time = 0;

    export "DPI-C" axi4_set_last_handle_and_times = function set_last_handle_and_times;

    function void set_last_handle_and_times(longint _handle, longint _start, longint _end);
        last_handle = _handle;
        last_start_time = _start;
        last_end_time = _end;
    endfunction

    // Drive wires (from Cohesive) 
    assign ACLK = internal_ACLK;
    assign ARESETn = internal_ARESETn;
    assign AWVALID = internal_AWVALID;
    assign AWADDR = internal_AWADDR;
    assign AWPROT = internal_AWPROT;
    assign AWREGION = internal_AWREGION;
    assign AWLEN = internal_AWLEN;
    assign AWSIZE = internal_AWSIZE;
    assign AWBURST = internal_AWBURST;
    assign AWLOCK = internal_AWLOCK;
    assign AWCACHE = internal_AWCACHE;
    assign AWQOS = internal_AWQOS;
    assign AWID = internal_AWID;
    assign AWUSER = internal_AWUSER;
    assign AWREADY = internal_AWREADY;
    assign ARVALID = internal_ARVALID;
    assign ARADDR = internal_ARADDR;
    assign ARPROT = internal_ARPROT;
    assign ARREGION = internal_ARREGION;
    assign ARLEN = internal_ARLEN;
    assign ARSIZE = internal_ARSIZE;
    assign ARBURST = internal_ARBURST;
    assign ARLOCK = internal_ARLOCK;
    assign ARCACHE = internal_ARCACHE;
    assign ARQOS = internal_ARQOS;
    assign ARID = internal_ARID;
    assign ARUSER = internal_ARUSER;
    assign ARREADY = internal_ARREADY;
    assign RVALID = internal_RVALID;
    assign RDATA = internal_RDATA;
    assign RRESP = internal_RRESP;
    assign RLAST = internal_RLAST;
    assign RID = internal_RID;
    assign RUSER = internal_RUSER;
    assign RREADY = internal_RREADY;
    assign WVALID = internal_WVALID;
    assign WDATA = internal_WDATA;
    assign WSTRB = internal_WSTRB;
    assign WLAST = internal_WLAST;
    assign WUSER = internal_WUSER;
    assign WREADY = internal_WREADY;
    assign BVALID = internal_BVALID;
    assign BRESP = internal_BRESP;
    assign BID = internal_BID;
    assign BUSER = internal_BUSER;
    assign BREADY = internal_BREADY;
    // Drive wires (from User) 
    assign ACLK = m_ACLK;
    assign ARESETn = m_ARESETn;
    assign AWVALID = m_AWVALID;
    assign AWADDR = m_AWADDR;
    assign AWPROT = m_AWPROT;
    assign AWREGION = m_AWREGION;
    assign AWLEN = m_AWLEN;
    assign AWSIZE = m_AWSIZE;
    assign AWBURST = m_AWBURST;
    assign AWLOCK = m_AWLOCK;
    assign AWCACHE = m_AWCACHE;
    assign AWQOS = m_AWQOS;
    assign AWID = m_AWID;
    assign AWUSER = m_AWUSER;
    assign AWREADY = m_AWREADY;
    assign ARVALID = m_ARVALID;
    assign ARADDR = m_ARADDR;
    assign ARPROT = m_ARPROT;
    assign ARREGION = m_ARREGION;
    assign ARLEN = m_ARLEN;
    assign ARSIZE = m_ARSIZE;
    assign ARBURST = m_ARBURST;
    assign ARLOCK = m_ARLOCK;
    assign ARCACHE = m_ARCACHE;
    assign ARQOS = m_ARQOS;
    assign ARID = m_ARID;
    assign ARUSER = m_ARUSER;
    assign ARREADY = m_ARREADY;
    assign RVALID = m_RVALID;
    assign RDATA = m_RDATA;
    assign RRESP = m_RRESP;
    assign RLAST = m_RLAST;
    assign RID = m_RID;
    assign RUSER = m_RUSER;
    assign RREADY = m_RREADY;
    assign WVALID = m_WVALID;
    assign WDATA = m_WDATA;
    assign WSTRB = m_WSTRB;
    assign WLAST = m_WLAST;
    assign WUSER = m_WUSER;
    assign WREADY = m_WREADY;
    assign BVALID = m_BVALID;
    assign BRESP = m_BRESP;
    assign BID = m_BID;
    assign BUSER = m_BUSER;
    assign BREADY = m_BREADY;

    reg ACLK_changed = 0;
    reg ARESETn_changed = 0;
    reg AWVALID_changed = 0;
    reg AWADDR_changed = 0;
    reg AWPROT_changed = 0;
    reg AWREGION_changed = 0;
    reg AWLEN_changed = 0;
    reg AWSIZE_changed = 0;
    reg AWBURST_changed = 0;
    reg AWLOCK_changed = 0;
    reg AWCACHE_changed = 0;
    reg AWQOS_changed = 0;
    reg AWID_changed = 0;
    reg AWUSER_changed = 0;
    reg AWREADY_changed = 0;
    reg ARVALID_changed = 0;
    reg ARADDR_changed = 0;
    reg ARPROT_changed = 0;
    reg ARREGION_changed = 0;
    reg ARLEN_changed = 0;
    reg ARSIZE_changed = 0;
    reg ARBURST_changed = 0;
    reg ARLOCK_changed = 0;
    reg ARCACHE_changed = 0;
    reg ARQOS_changed = 0;
    reg ARID_changed = 0;
    reg ARUSER_changed = 0;
    reg ARREADY_changed = 0;
    reg RVALID_changed = 0;
    reg RDATA_changed = 0;
    reg RRESP_changed = 0;
    reg RLAST_changed = 0;
    reg RID_changed = 0;
    reg RUSER_changed = 0;
    reg RREADY_changed = 0;
    reg WVALID_changed = 0;
    reg WDATA_changed = 0;
    reg WSTRB_changed = 0;
    reg WLAST_changed = 0;
    reg WUSER_changed = 0;
    reg WREADY_changed = 0;
    reg BVALID_changed = 0;
    reg BRESP_changed = 0;
    reg BID_changed = 0;
    reg BUSER_changed = 0;
    reg BREADY_changed = 0;
    reg config_interface_type_changed = 0;
    reg config_clk_init_value_changed = 0;
    reg config_clk_phase_shift_changed = 0;
    reg config_clk_1st_time_changed = 0;
    reg config_clk_2nd_time_changed = 0;
    reg config_setup_time_changed = 0;
    reg config_hold_time_changed = 0;
    reg config_burst_timeout_factor_changed = 0;
    reg config_max_transaction_time_factor_changed = 0;
    reg config_write_ctrl_first_ratio_changed = 0;
    reg config_write_data_first_ratio_changed = 0;
    reg config_reset_low_clocks_changed = 0;
    reg config_reset_hold_time_changed = 0;
    reg config_enable_rlast_changed = 0;
    reg config_enable_slave_exclusive_changed = 0;
    reg config_enable_burst_reserved_value_changed = 0;
    reg config_enable_cache_value_changed = 0;
    reg internal_dummy_variable_changed = 0;
    reg config_axi4lite_interface_changed = 0;
    reg config_axi4lite_tr_id_changed = 0;
    reg config_enable_all_assertions_changed = 0;
    reg config_enable_assertion_changed = 0;
    reg config_enable_error_changed = 0;
    reg config_max_latency_AWVALID_assertion_to_AWREADY_changed = 0;
    reg config_max_latency_ARVALID_assertion_to_ARREADY_changed = 0;
    reg config_max_latency_RVALID_assertion_to_RREADY_changed = 0;
    reg config_max_latency_BVALID_assertion_to_BREADY_changed = 0;
    reg config_max_latency_WVALID_assertion_to_WREADY_changed = 0;
    reg config_enable_qos_changed = 0;
    reg config_enable_region_support_changed = 0;
    reg config_slave_regions_changed = 0;
    reg config_region_changed = 0;
    reg region_error_state_changed = 0;
    reg region_map_lb_changed = 0;
    reg region_map_ub_changed = 0;
    reg region_map_region_changed = 0;
    reg cacheable_changed = 0;
    reg config_read_data_reordering_depth_changed = 0;
    reg config_slave_start_addr_changed = 0;
    reg config_slave_end_addr_changed = 0;
    reg config_slave_enabled_non_contiguous_address_spaces_changed = 0;
    reg config_slave_possess_multiple_non_contiguous_address_spaces_changed = 0;
    reg config_slave_multiple_non_contiguous_start_address_range_changed = 0;
    reg config_slave_multiple_non_contiguous_end_address_range_changed = 0;
    reg config_protect_ready_changed = 0;
    reg master_end_tlm_status_changed = 0;
    reg master_end_wlm_status_changed = 0;
    reg slave_end_tlm_status_changed = 0;
    reg slave_end_wlm_status_changed = 0;
    reg clock_source_end_tlm_status_changed = 0;
    reg clock_source_end_wlm_status_changed = 0;
    reg reset_source_end_tlm_status_changed = 0;
    reg reset_source_end_wlm_status_changed = 0;
    reg config_max_outstanding_wr_changed = 0;
    reg config_max_outstanding_rd_changed = 0;
    reg config_num_outstanding_wr_phase_changed = 0;
    reg config_num_outstanding_rd_phase_changed = 0;
    reg config_enable_warnings_changed = 0;
    reg config_enable_errors_changed = 0;
    reg config_enable_exclusive_checks_changed = 0;
    reg config_warn_on_slave_errors_changed = 0;
    reg config_error_on_deleted_valid_cycles_changed = 0;
    reg config_stats_enable_changed = 0;
    reg config_stats_enable_read_occupancy_changed = 0;
    reg config_stats_enable_write_occupancy_changed = 0;
    reg config_stats_enable_read_data_occupancy_changed = 0;
    reg config_stats_enable_write_data_occupancy_changed = 0;
    reg config_stats_enable_read_latency_changed = 0;
    reg config_stats_enable_write_latency_changed = 0;
    reg config_stats_enable_read_address_waits_changed = 0;
    reg config_stats_enable_read_data_waits_changed = 0;
    reg config_stats_enable_write_address_waits_changed = 0;
    reg config_stats_enable_write_data_waits_changed = 0;
    reg config_stats_enable_write_response_waits_changed = 0;
    reg config_stats_enable_read_bandwidth_changed = 0;
    reg config_stats_enable_write_bandwidth_changed = 0;
    reg stats_rw_transaction_last_duration_changed = 0;
    reg config_stats_read_occupancy_step_changed = 0;
    reg config_stats_read_occupancy_multiple_changed = 0;
    reg stats_read_active_changed = 0;
    reg stats_read_occupancy_sw_changed = 0;
    reg stats_read_idle_sw_changed = 0;
    reg stats_read_occupancy_min_changed = 0;
    reg stats_read_idle_min_changed = 0;
    reg stats_read_occupancy_max_changed = 0;
    reg stats_read_idle_max_changed = 0;
    reg stats_read_occupancy_mean_changed = 0;
    reg stats_read_idle_mean_changed = 0;
    reg stats_read_last_duration_changed = 0;
    reg config_stats_write_occupancy_step_changed = 0;
    reg config_stats_write_occupancy_multiple_changed = 0;
    reg stats_write_active_changed = 0;
    reg stats_write_occupancy_sw_changed = 0;
    reg stats_write_idle_sw_changed = 0;
    reg stats_write_occupancy_min_changed = 0;
    reg stats_write_idle_min_changed = 0;
    reg stats_write_occupancy_max_changed = 0;
    reg stats_write_idle_max_changed = 0;
    reg stats_write_occupancy_mean_changed = 0;
    reg stats_write_idle_mean_changed = 0;
    reg stats_write_last_duration_changed = 0;
    reg config_stats_read_data_occupancy_step_changed = 0;
    reg config_stats_read_data_occupancy_multiple_changed = 0;
    reg stats_read_data_occupancy_sw_changed = 0;
    reg stats_read_data_idle_sw_changed = 0;
    reg stats_read_data_occupancy_min_changed = 0;
    reg stats_read_data_idle_min_changed = 0;
    reg stats_read_data_occupancy_max_changed = 0;
    reg stats_read_data_idle_max_changed = 0;
    reg stats_read_data_occupancy_mean_changed = 0;
    reg stats_read_data_idle_mean_changed = 0;
    reg config_stats_write_data_occupancy_step_changed = 0;
    reg config_stats_write_data_occupancy_multiple_changed = 0;
    reg stats_write_data_occupancy_sw_changed = 0;
    reg stats_write_data_idle_sw_changed = 0;
    reg stats_write_data_occupancy_min_changed = 0;
    reg stats_write_data_idle_min_changed = 0;
    reg stats_write_data_occupancy_max_changed = 0;
    reg stats_write_data_idle_max_changed = 0;
    reg stats_write_data_occupancy_mean_changed = 0;
    reg stats_write_data_idle_mean_changed = 0;
    reg config_stats_read_bandwidth_step_changed = 0;
    reg config_stats_read_bandwidth_multiple_changed = 0;
    reg stats_read_bandwidth_sw_changed = 0;
    reg stats_read_bandwidth_min_changed = 0;
    reg stats_read_bandwidth_max_changed = 0;
    reg stats_read_bandwidth_mean_changed = 0;
    reg config_stats_write_bandwidth_step_changed = 0;
    reg config_stats_write_bandwidth_multiple_changed = 0;
    reg stats_write_bandwidth_sw_changed = 0;
    reg stats_write_bandwidth_min_changed = 0;
    reg stats_write_bandwidth_max_changed = 0;
    reg stats_write_bandwidth_mean_changed = 0;
    reg config_stats_read_latency_step_changed = 0;
    reg config_stats_read_latency_multiple_changed = 0;
    reg stats_read_address_data_latency_inst_changed = 0;
    reg stats_read_address_data_latency_sw_changed = 0;
    reg stats_read_address_data_latency_min_changed = 0;
    reg stats_read_address_data_latency_max_changed = 0;
    reg stats_read_address_data_latency_mean_changed = 0;
    reg stats_read_address_address_latency_inst_changed = 0;
    reg stats_read_address_address_latency_sw_changed = 0;
    reg stats_read_address_address_latency_min_changed = 0;
    reg stats_read_address_address_latency_max_changed = 0;
    reg stats_read_address_address_latency_mean_changed = 0;
    reg config_stats_write_latency_step_changed = 0;
    reg config_stats_write_latency_multiple_changed = 0;
    reg stats_write_address_response_latency_inst_changed = 0;
    reg stats_write_address_response_latency_sw_changed = 0;
    reg stats_write_address_response_latency_min_changed = 0;
    reg stats_write_address_response_latency_max_changed = 0;
    reg stats_write_address_response_latency_mean_changed = 0;
    reg stats_write_address_address_latency_inst_changed = 0;
    reg stats_write_address_address_latency_sw_changed = 0;
    reg stats_write_address_address_latency_min_changed = 0;
    reg stats_write_address_address_latency_max_changed = 0;
    reg stats_write_address_address_latency_mean_changed = 0;
    reg config_stats_read_address_waits_step_changed = 0;
    reg config_stats_read_address_waits_multiple_changed = 0;
    reg stats_read_address_waits_inst_changed = 0;
    reg stats_read_address_waits_sw_changed = 0;
    reg stats_read_address_waits_min_changed = 0;
    reg stats_read_address_waits_max_changed = 0;
    reg stats_read_address_waits_mean_changed = 0;
    reg config_stats_read_data_waits_step_changed = 0;
    reg config_stats_read_data_waits_multiple_changed = 0;
    reg stats_read_data_waits_inst_changed = 0;
    reg stats_read_data_waits_sw_changed = 0;
    reg stats_read_data_waits_min_changed = 0;
    reg stats_read_data_waits_max_changed = 0;
    reg stats_read_data_waits_mean_changed = 0;
    reg config_stats_write_address_waits_step_changed = 0;
    reg config_stats_write_address_waits_multiple_changed = 0;
    reg stats_write_address_waits_inst_changed = 0;
    reg stats_write_address_waits_sw_changed = 0;
    reg stats_write_address_waits_min_changed = 0;
    reg stats_write_address_waits_max_changed = 0;
    reg stats_write_address_waits_mean_changed = 0;
    reg config_stats_write_data_waits_step_changed = 0;
    reg config_stats_write_data_waits_multiple_changed = 0;
    reg stats_write_data_waits_inst_changed = 0;
    reg stats_write_data_waits_sw_changed = 0;
    reg stats_write_data_waits_min_changed = 0;
    reg stats_write_data_waits_max_changed = 0;
    reg stats_write_data_waits_mean_changed = 0;
    reg config_stats_write_response_waits_step_changed = 0;
    reg config_stats_write_response_waits_multiple_changed = 0;
    reg stats_write_response_waits_inst_changed = 0;
    reg stats_write_response_waits_sw_changed = 0;
    reg stats_write_response_waits_min_changed = 0;
    reg stats_write_response_waits_max_changed = 0;
    reg stats_write_response_waits_mean_changed = 0;
    reg reordering_depth_of_last_read_transaction_changed = 0;

    reg end_of_timestep_control = 0;


    // SV wire change monitors

    function automatic void axi4_local_set_ACLK_from_SystemVerilog(  );
            axi4_set_ACLK_from_SystemVerilog(ACLK); // DPI call to imported task
        
        axi4_propagate_ACLK_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ACLK or posedge _check_t0_values )
    begin
        axi4_local_set_ACLK_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARESETn_from_SystemVerilog(  );
            axi4_set_ARESETn_from_SystemVerilog(ARESETn); // DPI call to imported task
        
        axi4_propagate_ARESETn_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARESETn or posedge _check_t0_values )
    begin
        axi4_local_set_ARESETn_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWVALID_from_SystemVerilog(  );
            axi4_set_AWVALID_from_SystemVerilog(AWVALID); // DPI call to imported task
        
        axi4_propagate_AWVALID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWVALID or posedge _check_t0_values )
    begin
        axi4_local_set_AWVALID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWADDR_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_ADDRESS_WIDTH ); _this_dot_1++)
        begin
            axi4_set_AWADDR_from_SystemVerilog_index1(_this_dot_1,AWADDR[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_AWADDR_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWADDR or posedge _check_t0_values )
    begin
        axi4_local_set_AWADDR_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWPROT_from_SystemVerilog(  );
            axi4_set_AWPROT_from_SystemVerilog(AWPROT); // DPI call to imported task
        
        axi4_propagate_AWPROT_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWPROT or posedge _check_t0_values )
    begin
        axi4_local_set_AWPROT_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWREGION_from_SystemVerilog(  );
            axi4_set_AWREGION_from_SystemVerilog(AWREGION); // DPI call to imported task
        
        axi4_propagate_AWREGION_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWREGION or posedge _check_t0_values )
    begin
        axi4_local_set_AWREGION_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWLEN_from_SystemVerilog(  );
            axi4_set_AWLEN_from_SystemVerilog(AWLEN); // DPI call to imported task
        
        axi4_propagate_AWLEN_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWLEN or posedge _check_t0_values )
    begin
        axi4_local_set_AWLEN_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWSIZE_from_SystemVerilog(  );
            axi4_set_AWSIZE_from_SystemVerilog(AWSIZE); // DPI call to imported task
        
        axi4_propagate_AWSIZE_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWSIZE or posedge _check_t0_values )
    begin
        axi4_local_set_AWSIZE_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWBURST_from_SystemVerilog(  );
            axi4_set_AWBURST_from_SystemVerilog(AWBURST); // DPI call to imported task
        
        axi4_propagate_AWBURST_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWBURST or posedge _check_t0_values )
    begin
        axi4_local_set_AWBURST_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWLOCK_from_SystemVerilog(  );
            axi4_set_AWLOCK_from_SystemVerilog(AWLOCK); // DPI call to imported task
        
        axi4_propagate_AWLOCK_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWLOCK or posedge _check_t0_values )
    begin
        axi4_local_set_AWLOCK_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWCACHE_from_SystemVerilog(  );
            axi4_set_AWCACHE_from_SystemVerilog(AWCACHE); // DPI call to imported task
        
        axi4_propagate_AWCACHE_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWCACHE or posedge _check_t0_values )
    begin
        axi4_local_set_AWCACHE_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWQOS_from_SystemVerilog(  );
            axi4_set_AWQOS_from_SystemVerilog(AWQOS); // DPI call to imported task
        
        axi4_propagate_AWQOS_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWQOS or posedge _check_t0_values )
    begin
        axi4_local_set_AWQOS_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWID_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_ID_WIDTH ); _this_dot_1++)
        begin
            axi4_set_AWID_from_SystemVerilog_index1(_this_dot_1,AWID[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_AWID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWID or posedge _check_t0_values )
    begin
        axi4_local_set_AWID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWUSER_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_USER_WIDTH ); _this_dot_1++)
        begin
            axi4_set_AWUSER_from_SystemVerilog_index1(_this_dot_1,AWUSER[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_AWUSER_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWUSER or posedge _check_t0_values )
    begin
        axi4_local_set_AWUSER_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWREADY_from_SystemVerilog(  );
            axi4_set_AWREADY_from_SystemVerilog(AWREADY); // DPI call to imported task
        
        axi4_propagate_AWREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWREADY or posedge _check_t0_values )
    begin
        axi4_local_set_AWREADY_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARVALID_from_SystemVerilog(  );
            axi4_set_ARVALID_from_SystemVerilog(ARVALID); // DPI call to imported task
        
        axi4_propagate_ARVALID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARVALID or posedge _check_t0_values )
    begin
        axi4_local_set_ARVALID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARADDR_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_ADDRESS_WIDTH ); _this_dot_1++)
        begin
            axi4_set_ARADDR_from_SystemVerilog_index1(_this_dot_1,ARADDR[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_ARADDR_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARADDR or posedge _check_t0_values )
    begin
        axi4_local_set_ARADDR_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARPROT_from_SystemVerilog(  );
            axi4_set_ARPROT_from_SystemVerilog(ARPROT); // DPI call to imported task
        
        axi4_propagate_ARPROT_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARPROT or posedge _check_t0_values )
    begin
        axi4_local_set_ARPROT_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARREGION_from_SystemVerilog(  );
            axi4_set_ARREGION_from_SystemVerilog(ARREGION); // DPI call to imported task
        
        axi4_propagate_ARREGION_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARREGION or posedge _check_t0_values )
    begin
        axi4_local_set_ARREGION_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARLEN_from_SystemVerilog(  );
            axi4_set_ARLEN_from_SystemVerilog(ARLEN); // DPI call to imported task
        
        axi4_propagate_ARLEN_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARLEN or posedge _check_t0_values )
    begin
        axi4_local_set_ARLEN_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARSIZE_from_SystemVerilog(  );
            axi4_set_ARSIZE_from_SystemVerilog(ARSIZE); // DPI call to imported task
        
        axi4_propagate_ARSIZE_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARSIZE or posedge _check_t0_values )
    begin
        axi4_local_set_ARSIZE_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARBURST_from_SystemVerilog(  );
            axi4_set_ARBURST_from_SystemVerilog(ARBURST); // DPI call to imported task
        
        axi4_propagate_ARBURST_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARBURST or posedge _check_t0_values )
    begin
        axi4_local_set_ARBURST_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARLOCK_from_SystemVerilog(  );
            axi4_set_ARLOCK_from_SystemVerilog(ARLOCK); // DPI call to imported task
        
        axi4_propagate_ARLOCK_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARLOCK or posedge _check_t0_values )
    begin
        axi4_local_set_ARLOCK_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARCACHE_from_SystemVerilog(  );
            axi4_set_ARCACHE_from_SystemVerilog(ARCACHE); // DPI call to imported task
        
        axi4_propagate_ARCACHE_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARCACHE or posedge _check_t0_values )
    begin
        axi4_local_set_ARCACHE_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARQOS_from_SystemVerilog(  );
            axi4_set_ARQOS_from_SystemVerilog(ARQOS); // DPI call to imported task
        
        axi4_propagate_ARQOS_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARQOS or posedge _check_t0_values )
    begin
        axi4_local_set_ARQOS_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARID_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_ID_WIDTH ); _this_dot_1++)
        begin
            axi4_set_ARID_from_SystemVerilog_index1(_this_dot_1,ARID[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_ARID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARID or posedge _check_t0_values )
    begin
        axi4_local_set_ARID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARUSER_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_USER_WIDTH ); _this_dot_1++)
        begin
            axi4_set_ARUSER_from_SystemVerilog_index1(_this_dot_1,ARUSER[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_ARUSER_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARUSER or posedge _check_t0_values )
    begin
        axi4_local_set_ARUSER_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARREADY_from_SystemVerilog(  );
            axi4_set_ARREADY_from_SystemVerilog(ARREADY); // DPI call to imported task
        
        axi4_propagate_ARREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARREADY or posedge _check_t0_values )
    begin
        axi4_local_set_ARREADY_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_RVALID_from_SystemVerilog(  );
            axi4_set_RVALID_from_SystemVerilog(RVALID); // DPI call to imported task
        
        axi4_propagate_RVALID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RVALID or posedge _check_t0_values )
    begin
        axi4_local_set_RVALID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_RDATA_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_RDATA_WIDTH ); _this_dot_1++)
        begin
            axi4_set_RDATA_from_SystemVerilog_index1(_this_dot_1,RDATA[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_RDATA_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RDATA or posedge _check_t0_values )
    begin
        axi4_local_set_RDATA_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_RRESP_from_SystemVerilog(  );
            axi4_set_RRESP_from_SystemVerilog(RRESP); // DPI call to imported task
        
        axi4_propagate_RRESP_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RRESP or posedge _check_t0_values )
    begin
        axi4_local_set_RRESP_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_RLAST_from_SystemVerilog(  );
            axi4_set_RLAST_from_SystemVerilog(RLAST); // DPI call to imported task
        
        axi4_propagate_RLAST_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RLAST or posedge _check_t0_values )
    begin
        axi4_local_set_RLAST_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_RID_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_ID_WIDTH ); _this_dot_1++)
        begin
            axi4_set_RID_from_SystemVerilog_index1(_this_dot_1,RID[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_RID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RID or posedge _check_t0_values )
    begin
        axi4_local_set_RID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_RUSER_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_USER_WIDTH ); _this_dot_1++)
        begin
            axi4_set_RUSER_from_SystemVerilog_index1(_this_dot_1,RUSER[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_RUSER_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RUSER or posedge _check_t0_values )
    begin
        axi4_local_set_RUSER_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_RREADY_from_SystemVerilog(  );
            axi4_set_RREADY_from_SystemVerilog(RREADY); // DPI call to imported task
        
        axi4_propagate_RREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RREADY or posedge _check_t0_values )
    begin
        axi4_local_set_RREADY_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_WVALID_from_SystemVerilog(  );
            axi4_set_WVALID_from_SystemVerilog(WVALID); // DPI call to imported task
        
        axi4_propagate_WVALID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WVALID or posedge _check_t0_values )
    begin
        axi4_local_set_WVALID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_WDATA_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_WDATA_WIDTH ); _this_dot_1++)
        begin
            axi4_set_WDATA_from_SystemVerilog_index1(_this_dot_1,WDATA[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_WDATA_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WDATA or posedge _check_t0_values )
    begin
        axi4_local_set_WDATA_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_WSTRB_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( (AXI4_WDATA_WIDTH / 8) ); _this_dot_1++)
        begin
            axi4_set_WSTRB_from_SystemVerilog_index1(_this_dot_1,WSTRB[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_WSTRB_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WSTRB or posedge _check_t0_values )
    begin
        axi4_local_set_WSTRB_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_WLAST_from_SystemVerilog(  );
            axi4_set_WLAST_from_SystemVerilog(WLAST); // DPI call to imported task
        
        axi4_propagate_WLAST_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WLAST or posedge _check_t0_values )
    begin
        axi4_local_set_WLAST_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_WUSER_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_USER_WIDTH ); _this_dot_1++)
        begin
            axi4_set_WUSER_from_SystemVerilog_index1(_this_dot_1,WUSER[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_WUSER_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WUSER or posedge _check_t0_values )
    begin
        axi4_local_set_WUSER_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_WREADY_from_SystemVerilog(  );
            axi4_set_WREADY_from_SystemVerilog(WREADY); // DPI call to imported task
        
        axi4_propagate_WREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WREADY or posedge _check_t0_values )
    begin
        axi4_local_set_WREADY_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_BVALID_from_SystemVerilog(  );
            axi4_set_BVALID_from_SystemVerilog(BVALID); // DPI call to imported task
        
        axi4_propagate_BVALID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( BVALID or posedge _check_t0_values )
    begin
        axi4_local_set_BVALID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_BRESP_from_SystemVerilog(  );
            axi4_set_BRESP_from_SystemVerilog(BRESP); // DPI call to imported task
        
        axi4_propagate_BRESP_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( BRESP or posedge _check_t0_values )
    begin
        axi4_local_set_BRESP_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_BID_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_ID_WIDTH ); _this_dot_1++)
        begin
            axi4_set_BID_from_SystemVerilog_index1(_this_dot_1,BID[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_BID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( BID or posedge _check_t0_values )
    begin
        axi4_local_set_BID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_BUSER_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_USER_WIDTH ); _this_dot_1++)
        begin
            axi4_set_BUSER_from_SystemVerilog_index1(_this_dot_1,BUSER[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_BUSER_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( BUSER or posedge _check_t0_values )
    begin
        axi4_local_set_BUSER_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_BREADY_from_SystemVerilog(  );
            axi4_set_BREADY_from_SystemVerilog(BREADY); // DPI call to imported task
        
        axi4_propagate_BREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( BREADY or posedge _check_t0_values )
    begin
        axi4_local_set_BREADY_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end


    // CY wire and variable changed flag monitors

    always @(posedge ACLK_changed or posedge _check_t0_values )
    begin
        while (ACLK_changed == 1'b1)
        begin
            axi4_get_ACLK_into_SystemVerilog(  ); // DPI call to imported task
            ACLK_changed = 1'b0;
            #0  #0 if ( ACLK !== internal_ACLK )
            begin
                axi4_local_set_ACLK_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARESETn_changed or posedge _check_t0_values )
    begin
        while (ARESETn_changed == 1'b1)
        begin
            axi4_get_ARESETn_into_SystemVerilog(  ); // DPI call to imported task
            ARESETn_changed = 1'b0;
            #0  #0 if ( ARESETn !== internal_ARESETn )
            begin
                axi4_local_set_ARESETn_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWVALID_changed or posedge _check_t0_values )
    begin
        while (AWVALID_changed == 1'b1)
        begin
            axi4_get_AWVALID_into_SystemVerilog(  ); // DPI call to imported task
            AWVALID_changed = 1'b0;
            #0  #0 if ( AWVALID !== internal_AWVALID )
            begin
                axi4_local_set_AWVALID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWADDR_changed or posedge _check_t0_values )
    begin
        while (AWADDR_changed == 1'b1)
        begin
            axi4_get_AWADDR_into_SystemVerilog(  ); // DPI call to imported task
            AWADDR_changed = 1'b0;
            #0  #0 if ( AWADDR !== internal_AWADDR )
            begin
                axi4_local_set_AWADDR_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWPROT_changed or posedge _check_t0_values )
    begin
        while (AWPROT_changed == 1'b1)
        begin
            axi4_get_AWPROT_into_SystemVerilog(  ); // DPI call to imported task
            AWPROT_changed = 1'b0;
            #0  #0 if ( AWPROT !== internal_AWPROT )
            begin
                axi4_local_set_AWPROT_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWREGION_changed or posedge _check_t0_values )
    begin
        while (AWREGION_changed == 1'b1)
        begin
            axi4_get_AWREGION_into_SystemVerilog(  ); // DPI call to imported task
            AWREGION_changed = 1'b0;
            #0  #0 if ( AWREGION !== internal_AWREGION )
            begin
                axi4_local_set_AWREGION_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWLEN_changed or posedge _check_t0_values )
    begin
        while (AWLEN_changed == 1'b1)
        begin
            axi4_get_AWLEN_into_SystemVerilog(  ); // DPI call to imported task
            AWLEN_changed = 1'b0;
            #0  #0 if ( AWLEN !== internal_AWLEN )
            begin
                axi4_local_set_AWLEN_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWSIZE_changed or posedge _check_t0_values )
    begin
        while (AWSIZE_changed == 1'b1)
        begin
            axi4_get_AWSIZE_into_SystemVerilog(  ); // DPI call to imported task
            AWSIZE_changed = 1'b0;
            #0  #0 if ( AWSIZE !== internal_AWSIZE )
            begin
                axi4_local_set_AWSIZE_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWBURST_changed or posedge _check_t0_values )
    begin
        while (AWBURST_changed == 1'b1)
        begin
            axi4_get_AWBURST_into_SystemVerilog(  ); // DPI call to imported task
            AWBURST_changed = 1'b0;
            #0  #0 if ( AWBURST !== internal_AWBURST )
            begin
                axi4_local_set_AWBURST_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWLOCK_changed or posedge _check_t0_values )
    begin
        while (AWLOCK_changed == 1'b1)
        begin
            axi4_get_AWLOCK_into_SystemVerilog(  ); // DPI call to imported task
            AWLOCK_changed = 1'b0;
            #0  #0 if ( AWLOCK !== internal_AWLOCK )
            begin
                axi4_local_set_AWLOCK_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWCACHE_changed or posedge _check_t0_values )
    begin
        while (AWCACHE_changed == 1'b1)
        begin
            axi4_get_AWCACHE_into_SystemVerilog(  ); // DPI call to imported task
            AWCACHE_changed = 1'b0;
            #0  #0 if ( AWCACHE !== internal_AWCACHE )
            begin
                axi4_local_set_AWCACHE_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWQOS_changed or posedge _check_t0_values )
    begin
        while (AWQOS_changed == 1'b1)
        begin
            axi4_get_AWQOS_into_SystemVerilog(  ); // DPI call to imported task
            AWQOS_changed = 1'b0;
            #0  #0 if ( AWQOS !== internal_AWQOS )
            begin
                axi4_local_set_AWQOS_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWID_changed or posedge _check_t0_values )
    begin
        while (AWID_changed == 1'b1)
        begin
            axi4_get_AWID_into_SystemVerilog(  ); // DPI call to imported task
            AWID_changed = 1'b0;
            #0  #0 if ( AWID !== internal_AWID )
            begin
                axi4_local_set_AWID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWUSER_changed or posedge _check_t0_values )
    begin
        while (AWUSER_changed == 1'b1)
        begin
            axi4_get_AWUSER_into_SystemVerilog(  ); // DPI call to imported task
            AWUSER_changed = 1'b0;
            #0  #0 if ( AWUSER !== internal_AWUSER )
            begin
                axi4_local_set_AWUSER_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWREADY_changed or posedge _check_t0_values )
    begin
        while (AWREADY_changed == 1'b1)
        begin
            axi4_get_AWREADY_into_SystemVerilog(  ); // DPI call to imported task
            AWREADY_changed = 1'b0;
            #0  #0 if ( AWREADY !== internal_AWREADY )
            begin
                axi4_local_set_AWREADY_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARVALID_changed or posedge _check_t0_values )
    begin
        while (ARVALID_changed == 1'b1)
        begin
            axi4_get_ARVALID_into_SystemVerilog(  ); // DPI call to imported task
            ARVALID_changed = 1'b0;
            #0  #0 if ( ARVALID !== internal_ARVALID )
            begin
                axi4_local_set_ARVALID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARADDR_changed or posedge _check_t0_values )
    begin
        while (ARADDR_changed == 1'b1)
        begin
            axi4_get_ARADDR_into_SystemVerilog(  ); // DPI call to imported task
            ARADDR_changed = 1'b0;
            #0  #0 if ( ARADDR !== internal_ARADDR )
            begin
                axi4_local_set_ARADDR_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARPROT_changed or posedge _check_t0_values )
    begin
        while (ARPROT_changed == 1'b1)
        begin
            axi4_get_ARPROT_into_SystemVerilog(  ); // DPI call to imported task
            ARPROT_changed = 1'b0;
            #0  #0 if ( ARPROT !== internal_ARPROT )
            begin
                axi4_local_set_ARPROT_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARREGION_changed or posedge _check_t0_values )
    begin
        while (ARREGION_changed == 1'b1)
        begin
            axi4_get_ARREGION_into_SystemVerilog(  ); // DPI call to imported task
            ARREGION_changed = 1'b0;
            #0  #0 if ( ARREGION !== internal_ARREGION )
            begin
                axi4_local_set_ARREGION_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARLEN_changed or posedge _check_t0_values )
    begin
        while (ARLEN_changed == 1'b1)
        begin
            axi4_get_ARLEN_into_SystemVerilog(  ); // DPI call to imported task
            ARLEN_changed = 1'b0;
            #0  #0 if ( ARLEN !== internal_ARLEN )
            begin
                axi4_local_set_ARLEN_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARSIZE_changed or posedge _check_t0_values )
    begin
        while (ARSIZE_changed == 1'b1)
        begin
            axi4_get_ARSIZE_into_SystemVerilog(  ); // DPI call to imported task
            ARSIZE_changed = 1'b0;
            #0  #0 if ( ARSIZE !== internal_ARSIZE )
            begin
                axi4_local_set_ARSIZE_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARBURST_changed or posedge _check_t0_values )
    begin
        while (ARBURST_changed == 1'b1)
        begin
            axi4_get_ARBURST_into_SystemVerilog(  ); // DPI call to imported task
            ARBURST_changed = 1'b0;
            #0  #0 if ( ARBURST !== internal_ARBURST )
            begin
                axi4_local_set_ARBURST_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARLOCK_changed or posedge _check_t0_values )
    begin
        while (ARLOCK_changed == 1'b1)
        begin
            axi4_get_ARLOCK_into_SystemVerilog(  ); // DPI call to imported task
            ARLOCK_changed = 1'b0;
            #0  #0 if ( ARLOCK !== internal_ARLOCK )
            begin
                axi4_local_set_ARLOCK_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARCACHE_changed or posedge _check_t0_values )
    begin
        while (ARCACHE_changed == 1'b1)
        begin
            axi4_get_ARCACHE_into_SystemVerilog(  ); // DPI call to imported task
            ARCACHE_changed = 1'b0;
            #0  #0 if ( ARCACHE !== internal_ARCACHE )
            begin
                axi4_local_set_ARCACHE_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARQOS_changed or posedge _check_t0_values )
    begin
        while (ARQOS_changed == 1'b1)
        begin
            axi4_get_ARQOS_into_SystemVerilog(  ); // DPI call to imported task
            ARQOS_changed = 1'b0;
            #0  #0 if ( ARQOS !== internal_ARQOS )
            begin
                axi4_local_set_ARQOS_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARID_changed or posedge _check_t0_values )
    begin
        while (ARID_changed == 1'b1)
        begin
            axi4_get_ARID_into_SystemVerilog(  ); // DPI call to imported task
            ARID_changed = 1'b0;
            #0  #0 if ( ARID !== internal_ARID )
            begin
                axi4_local_set_ARID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARUSER_changed or posedge _check_t0_values )
    begin
        while (ARUSER_changed == 1'b1)
        begin
            axi4_get_ARUSER_into_SystemVerilog(  ); // DPI call to imported task
            ARUSER_changed = 1'b0;
            #0  #0 if ( ARUSER !== internal_ARUSER )
            begin
                axi4_local_set_ARUSER_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARREADY_changed or posedge _check_t0_values )
    begin
        while (ARREADY_changed == 1'b1)
        begin
            axi4_get_ARREADY_into_SystemVerilog(  ); // DPI call to imported task
            ARREADY_changed = 1'b0;
            #0  #0 if ( ARREADY !== internal_ARREADY )
            begin
                axi4_local_set_ARREADY_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RVALID_changed or posedge _check_t0_values )
    begin
        while (RVALID_changed == 1'b1)
        begin
            axi4_get_RVALID_into_SystemVerilog(  ); // DPI call to imported task
            RVALID_changed = 1'b0;
            #0  #0 if ( RVALID !== internal_RVALID )
            begin
                axi4_local_set_RVALID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RDATA_changed or posedge _check_t0_values )
    begin
        while (RDATA_changed == 1'b1)
        begin
            axi4_get_RDATA_into_SystemVerilog(  ); // DPI call to imported task
            RDATA_changed = 1'b0;
            #0  #0 if ( RDATA !== internal_RDATA )
            begin
                axi4_local_set_RDATA_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RRESP_changed or posedge _check_t0_values )
    begin
        while (RRESP_changed == 1'b1)
        begin
            axi4_get_RRESP_into_SystemVerilog(  ); // DPI call to imported task
            RRESP_changed = 1'b0;
            #0  #0 if ( RRESP !== internal_RRESP )
            begin
                axi4_local_set_RRESP_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RLAST_changed or posedge _check_t0_values )
    begin
        while (RLAST_changed == 1'b1)
        begin
            axi4_get_RLAST_into_SystemVerilog(  ); // DPI call to imported task
            RLAST_changed = 1'b0;
            #0  #0 if ( RLAST !== internal_RLAST )
            begin
                axi4_local_set_RLAST_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RID_changed or posedge _check_t0_values )
    begin
        while (RID_changed == 1'b1)
        begin
            axi4_get_RID_into_SystemVerilog(  ); // DPI call to imported task
            RID_changed = 1'b0;
            #0  #0 if ( RID !== internal_RID )
            begin
                axi4_local_set_RID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RUSER_changed or posedge _check_t0_values )
    begin
        while (RUSER_changed == 1'b1)
        begin
            axi4_get_RUSER_into_SystemVerilog(  ); // DPI call to imported task
            RUSER_changed = 1'b0;
            #0  #0 if ( RUSER !== internal_RUSER )
            begin
                axi4_local_set_RUSER_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RREADY_changed or posedge _check_t0_values )
    begin
        while (RREADY_changed == 1'b1)
        begin
            axi4_get_RREADY_into_SystemVerilog(  ); // DPI call to imported task
            RREADY_changed = 1'b0;
            #0  #0 if ( RREADY !== internal_RREADY )
            begin
                axi4_local_set_RREADY_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WVALID_changed or posedge _check_t0_values )
    begin
        while (WVALID_changed == 1'b1)
        begin
            axi4_get_WVALID_into_SystemVerilog(  ); // DPI call to imported task
            WVALID_changed = 1'b0;
            #0  #0 if ( WVALID !== internal_WVALID )
            begin
                axi4_local_set_WVALID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WDATA_changed or posedge _check_t0_values )
    begin
        while (WDATA_changed == 1'b1)
        begin
            axi4_get_WDATA_into_SystemVerilog(  ); // DPI call to imported task
            WDATA_changed = 1'b0;
            #0  #0 if ( WDATA !== internal_WDATA )
            begin
                axi4_local_set_WDATA_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WSTRB_changed or posedge _check_t0_values )
    begin
        while (WSTRB_changed == 1'b1)
        begin
            axi4_get_WSTRB_into_SystemVerilog(  ); // DPI call to imported task
            WSTRB_changed = 1'b0;
            #0  #0 if ( WSTRB !== internal_WSTRB )
            begin
                axi4_local_set_WSTRB_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WLAST_changed or posedge _check_t0_values )
    begin
        while (WLAST_changed == 1'b1)
        begin
            axi4_get_WLAST_into_SystemVerilog(  ); // DPI call to imported task
            WLAST_changed = 1'b0;
            #0  #0 if ( WLAST !== internal_WLAST )
            begin
                axi4_local_set_WLAST_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WUSER_changed or posedge _check_t0_values )
    begin
        while (WUSER_changed == 1'b1)
        begin
            axi4_get_WUSER_into_SystemVerilog(  ); // DPI call to imported task
            WUSER_changed = 1'b0;
            #0  #0 if ( WUSER !== internal_WUSER )
            begin
                axi4_local_set_WUSER_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WREADY_changed or posedge _check_t0_values )
    begin
        while (WREADY_changed == 1'b1)
        begin
            axi4_get_WREADY_into_SystemVerilog(  ); // DPI call to imported task
            WREADY_changed = 1'b0;
            #0  #0 if ( WREADY !== internal_WREADY )
            begin
                axi4_local_set_WREADY_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge BVALID_changed or posedge _check_t0_values )
    begin
        while (BVALID_changed == 1'b1)
        begin
            axi4_get_BVALID_into_SystemVerilog(  ); // DPI call to imported task
            BVALID_changed = 1'b0;
            #0  #0 if ( BVALID !== internal_BVALID )
            begin
                axi4_local_set_BVALID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge BRESP_changed or posedge _check_t0_values )
    begin
        while (BRESP_changed == 1'b1)
        begin
            axi4_get_BRESP_into_SystemVerilog(  ); // DPI call to imported task
            BRESP_changed = 1'b0;
            #0  #0 if ( BRESP !== internal_BRESP )
            begin
                axi4_local_set_BRESP_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge BID_changed or posedge _check_t0_values )
    begin
        while (BID_changed == 1'b1)
        begin
            axi4_get_BID_into_SystemVerilog(  ); // DPI call to imported task
            BID_changed = 1'b0;
            #0  #0 if ( BID !== internal_BID )
            begin
                axi4_local_set_BID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge BUSER_changed or posedge _check_t0_values )
    begin
        while (BUSER_changed == 1'b1)
        begin
            axi4_get_BUSER_into_SystemVerilog(  ); // DPI call to imported task
            BUSER_changed = 1'b0;
            #0  #0 if ( BUSER !== internal_BUSER )
            begin
                axi4_local_set_BUSER_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge BREADY_changed or posedge _check_t0_values )
    begin
        while (BREADY_changed == 1'b1)
        begin
            axi4_get_BREADY_into_SystemVerilog(  ); // DPI call to imported task
            BREADY_changed = 1'b0;
            #0  #0 if ( BREADY !== internal_BREADY )
            begin
                axi4_local_set_BREADY_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge config_interface_type_changed or posedge _check_t0_values )
    begin
        if (config_interface_type_changed == 1'b1)
        begin
            axi4_get_config_interface_type_into_SystemVerilog(  ); // DPI call to imported task
            config_interface_type_changed = 1'b0;
        end
    end

    always @(posedge config_clk_init_value_changed or posedge _check_t0_values )
    begin
        if (config_clk_init_value_changed == 1'b1)
        begin
            axi4_get_config_clk_init_value_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_init_value_changed = 1'b0;
        end
    end

    always @(posedge config_clk_phase_shift_changed or posedge _check_t0_values )
    begin
        if (config_clk_phase_shift_changed == 1'b1)
        begin
            axi4_get_config_clk_phase_shift_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_phase_shift_changed = 1'b0;
        end
    end

    always @(posedge config_clk_1st_time_changed or posedge _check_t0_values )
    begin
        if (config_clk_1st_time_changed == 1'b1)
        begin
            axi4_get_config_clk_1st_time_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_1st_time_changed = 1'b0;
        end
    end

    always @(posedge config_clk_2nd_time_changed or posedge _check_t0_values )
    begin
        if (config_clk_2nd_time_changed == 1'b1)
        begin
            axi4_get_config_clk_2nd_time_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_2nd_time_changed = 1'b0;
        end
    end

    always @(posedge config_setup_time_changed or posedge _check_t0_values )
    begin
        if (config_setup_time_changed == 1'b1)
        begin
            axi4_get_config_setup_time_into_SystemVerilog(  ); // DPI call to imported task
            config_setup_time_changed = 1'b0;
        end
    end

    always @(posedge config_hold_time_changed or posedge _check_t0_values )
    begin
        if (config_hold_time_changed == 1'b1)
        begin
            axi4_get_config_hold_time_into_SystemVerilog(  ); // DPI call to imported task
            config_hold_time_changed = 1'b0;
        end
    end

    always @(posedge config_burst_timeout_factor_changed or posedge _check_t0_values )
    begin
        if (config_burst_timeout_factor_changed == 1'b1)
        begin
            axi4_get_config_burst_timeout_factor_into_SystemVerilog(  ); // DPI call to imported task
            config_burst_timeout_factor_changed = 1'b0;
        end
    end

    always @(posedge config_max_transaction_time_factor_changed or posedge _check_t0_values )
    begin
        if (config_max_transaction_time_factor_changed == 1'b1)
        begin
            axi4_get_config_max_transaction_time_factor_into_SystemVerilog(  ); // DPI call to imported task
            config_max_transaction_time_factor_changed = 1'b0;
        end
    end

    always @(posedge config_write_ctrl_first_ratio_changed or posedge _check_t0_values )
    begin
        if (config_write_ctrl_first_ratio_changed == 1'b1)
        begin
            axi4_get_config_write_ctrl_first_ratio_into_SystemVerilog(  ); // DPI call to imported task
            config_write_ctrl_first_ratio_changed = 1'b0;
        end
    end

    always @(posedge config_write_data_first_ratio_changed or posedge _check_t0_values )
    begin
        if (config_write_data_first_ratio_changed == 1'b1)
        begin
            axi4_get_config_write_data_first_ratio_into_SystemVerilog(  ); // DPI call to imported task
            config_write_data_first_ratio_changed = 1'b0;
        end
    end

    always @(posedge config_reset_low_clocks_changed or posedge _check_t0_values )
    begin
        if (config_reset_low_clocks_changed == 1'b1)
        begin
            axi4_get_config_reset_low_clocks_into_SystemVerilog(  ); // DPI call to imported task
            config_reset_low_clocks_changed = 1'b0;
        end
    end

    always @(posedge config_reset_hold_time_changed or posedge _check_t0_values )
    begin
        if (config_reset_hold_time_changed == 1'b1)
        begin
            axi4_get_config_reset_hold_time_into_SystemVerilog(  ); // DPI call to imported task
            config_reset_hold_time_changed = 1'b0;
        end
    end

    always @(posedge config_enable_rlast_changed or posedge _check_t0_values )
    begin
        if (config_enable_rlast_changed == 1'b1)
        begin
            axi4_get_config_enable_rlast_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_rlast_changed = 1'b0;
        end
    end

    always @(posedge config_enable_slave_exclusive_changed or posedge _check_t0_values )
    begin
        if (config_enable_slave_exclusive_changed == 1'b1)
        begin
            axi4_get_config_enable_slave_exclusive_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_slave_exclusive_changed = 1'b0;
        end
    end

    always @(posedge config_enable_burst_reserved_value_changed or posedge _check_t0_values )
    begin
        if (config_enable_burst_reserved_value_changed == 1'b1)
        begin
            axi4_get_config_enable_burst_reserved_value_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_burst_reserved_value_changed = 1'b0;
        end
    end

    always @(posedge config_enable_cache_value_changed or posedge _check_t0_values )
    begin
        if (config_enable_cache_value_changed == 1'b1)
        begin
            axi4_get_config_enable_cache_value_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_cache_value_changed = 1'b0;
        end
    end

    always @(posedge internal_dummy_variable_changed or posedge _check_t0_values )
    begin
        if (internal_dummy_variable_changed == 1'b1)
        begin
            axi4_get_internal_dummy_variable_into_SystemVerilog(  ); // DPI call to imported task
            internal_dummy_variable_changed = 1'b0;
        end
    end

    always @(posedge config_axi4lite_interface_changed or posedge _check_t0_values )
    begin
        if (config_axi4lite_interface_changed == 1'b1)
        begin
            axi4_get_config_axi4lite_interface_into_SystemVerilog(  ); // DPI call to imported task
            config_axi4lite_interface_changed = 1'b0;
        end
    end

    always @(posedge config_axi4lite_tr_id_changed or posedge _check_t0_values )
    begin
        if (config_axi4lite_tr_id_changed == 1'b1)
        begin
            axi4_get_config_axi4lite_tr_id_into_SystemVerilog(  ); // DPI call to imported task
            config_axi4lite_tr_id_changed = 1'b0;
        end
    end

    always @(posedge config_enable_all_assertions_changed or posedge _check_t0_values )
    begin
        if (config_enable_all_assertions_changed == 1'b1)
        begin
            axi4_get_config_enable_all_assertions_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_all_assertions_changed = 1'b0;
        end
    end

    always @(posedge config_enable_assertion_changed or posedge _check_t0_values )
    begin
        if (config_enable_assertion_changed == 1'b1)
        begin
            axi4_get_config_enable_assertion_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_assertion_changed = 1'b0;
        end
    end

    always @(posedge config_enable_error_changed or posedge _check_t0_values )
    begin
        if (config_enable_error_changed == 1'b1)
        begin
            axi4_get_config_enable_error_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_error_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_AWVALID_assertion_to_AWREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_AWVALID_assertion_to_AWREADY_changed == 1'b1)
        begin
            axi4_get_config_max_latency_AWVALID_assertion_to_AWREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_AWVALID_assertion_to_AWREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_ARVALID_assertion_to_ARREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_ARVALID_assertion_to_ARREADY_changed == 1'b1)
        begin
            axi4_get_config_max_latency_ARVALID_assertion_to_ARREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_ARVALID_assertion_to_ARREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_RVALID_assertion_to_RREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_RVALID_assertion_to_RREADY_changed == 1'b1)
        begin
            axi4_get_config_max_latency_RVALID_assertion_to_RREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_RVALID_assertion_to_RREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_BVALID_assertion_to_BREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_BVALID_assertion_to_BREADY_changed == 1'b1)
        begin
            axi4_get_config_max_latency_BVALID_assertion_to_BREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_BVALID_assertion_to_BREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_WVALID_assertion_to_WREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_WVALID_assertion_to_WREADY_changed == 1'b1)
        begin
            axi4_get_config_max_latency_WVALID_assertion_to_WREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_WVALID_assertion_to_WREADY_changed = 1'b0;
        end
    end

    always @(posedge config_enable_qos_changed or posedge _check_t0_values )
    begin
        if (config_enable_qos_changed == 1'b1)
        begin
            axi4_get_config_enable_qos_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_qos_changed = 1'b0;
        end
    end

    always @(posedge config_enable_region_support_changed or posedge _check_t0_values )
    begin
        if (config_enable_region_support_changed == 1'b1)
        begin
            axi4_get_config_enable_region_support_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_region_support_changed = 1'b0;
        end
    end

    always @(posedge config_slave_regions_changed or posedge _check_t0_values )
    begin
        if (config_slave_regions_changed == 1'b1)
        begin
            axi4_get_config_slave_regions_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_regions_changed = 1'b0;
        end
    end

    always @(posedge config_region_changed or posedge _check_t0_values )
    begin
        if (config_region_changed == 1'b1)
        begin
            axi4_get_config_region_into_SystemVerilog(  ); // DPI call to imported task
            config_region_changed = 1'b0;
        end
    end

    always @(posedge region_error_state_changed or posedge _check_t0_values )
    begin
        if (region_error_state_changed == 1'b1)
        begin
            axi4_get_region_error_state_into_SystemVerilog(  ); // DPI call to imported task
            region_error_state_changed = 1'b0;
        end
    end

    always @(posedge region_map_lb_changed or posedge _check_t0_values )
    begin
        if (region_map_lb_changed == 1'b1)
        begin
            axi4_get_region_map_lb_into_SystemVerilog(  ); // DPI call to imported task
            region_map_lb_changed = 1'b0;
        end
    end

    always @(posedge region_map_ub_changed or posedge _check_t0_values )
    begin
        if (region_map_ub_changed == 1'b1)
        begin
            axi4_get_region_map_ub_into_SystemVerilog(  ); // DPI call to imported task
            region_map_ub_changed = 1'b0;
        end
    end

    always @(posedge region_map_region_changed or posedge _check_t0_values )
    begin
        if (region_map_region_changed == 1'b1)
        begin
            axi4_get_region_map_region_into_SystemVerilog(  ); // DPI call to imported task
            region_map_region_changed = 1'b0;
        end
    end

    always @(posedge cacheable_changed or posedge _check_t0_values )
    begin
        if (cacheable_changed == 1'b1)
        begin
            axi4_get_cacheable_into_SystemVerilog(  ); // DPI call to imported task
            cacheable_changed = 1'b0;
        end
    end

    always @(posedge config_read_data_reordering_depth_changed or posedge _check_t0_values )
    begin
        if (config_read_data_reordering_depth_changed == 1'b1)
        begin
            axi4_get_config_read_data_reordering_depth_into_SystemVerilog(  ); // DPI call to imported task
            config_read_data_reordering_depth_changed = 1'b0;
        end
    end

    always @(posedge config_slave_start_addr_changed or posedge _check_t0_values )
    begin
        if (config_slave_start_addr_changed == 1'b1)
        begin
            axi4_get_config_slave_start_addr_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_start_addr_changed = 1'b0;
        end
    end

    always @(posedge config_slave_end_addr_changed or posedge _check_t0_values )
    begin
        if (config_slave_end_addr_changed == 1'b1)
        begin
            axi4_get_config_slave_end_addr_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_end_addr_changed = 1'b0;
        end
    end

    always @(posedge config_slave_enabled_non_contiguous_address_spaces_changed or posedge _check_t0_values )
    begin
        if (config_slave_enabled_non_contiguous_address_spaces_changed == 1'b1)
        begin
            axi4_get_config_slave_enabled_non_contiguous_address_spaces_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_enabled_non_contiguous_address_spaces_changed = 1'b0;
        end
    end

    always @(posedge config_slave_possess_multiple_non_contiguous_address_spaces_changed or posedge _check_t0_values )
    begin
        if (config_slave_possess_multiple_non_contiguous_address_spaces_changed == 1'b1)
        begin
            axi4_get_config_slave_possess_multiple_non_contiguous_address_spaces_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_possess_multiple_non_contiguous_address_spaces_changed = 1'b0;
        end
    end

    always @(posedge config_slave_multiple_non_contiguous_start_address_range_changed or posedge _check_t0_values )
    begin
        if (config_slave_multiple_non_contiguous_start_address_range_changed == 1'b1)
        begin
            axi4_get_config_slave_multiple_non_contiguous_start_address_range_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_multiple_non_contiguous_start_address_range_changed = 1'b0;
        end
    end

    always @(posedge config_slave_multiple_non_contiguous_end_address_range_changed or posedge _check_t0_values )
    begin
        if (config_slave_multiple_non_contiguous_end_address_range_changed == 1'b1)
        begin
            axi4_get_config_slave_multiple_non_contiguous_end_address_range_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_multiple_non_contiguous_end_address_range_changed = 1'b0;
        end
    end

    always @(posedge config_protect_ready_changed or posedge _check_t0_values )
    begin
        if (config_protect_ready_changed == 1'b1)
        begin
            axi4_get_config_protect_ready_into_SystemVerilog(  ); // DPI call to imported task
            config_protect_ready_changed = 1'b0;
        end
    end

    always @(posedge master_end_tlm_status_changed or posedge _check_t0_values )
    begin
        if (master_end_tlm_status_changed == 1'b1)
        begin
            axi4_get_master_end_tlm_status_into_SystemVerilog(  ); // DPI call to imported task
            master_end_tlm_status_changed = 1'b0;
        end
    end

    always @(posedge master_end_wlm_status_changed or posedge _check_t0_values )
    begin
        if (master_end_wlm_status_changed == 1'b1)
        begin
            axi4_get_master_end_wlm_status_into_SystemVerilog(  ); // DPI call to imported task
            master_end_wlm_status_changed = 1'b0;
        end
    end

    always @(posedge slave_end_tlm_status_changed or posedge _check_t0_values )
    begin
        if (slave_end_tlm_status_changed == 1'b1)
        begin
            axi4_get_slave_end_tlm_status_into_SystemVerilog(  ); // DPI call to imported task
            slave_end_tlm_status_changed = 1'b0;
        end
    end

    always @(posedge slave_end_wlm_status_changed or posedge _check_t0_values )
    begin
        if (slave_end_wlm_status_changed == 1'b1)
        begin
            axi4_get_slave_end_wlm_status_into_SystemVerilog(  ); // DPI call to imported task
            slave_end_wlm_status_changed = 1'b0;
        end
    end

    always @(posedge clock_source_end_tlm_status_changed or posedge _check_t0_values )
    begin
        if (clock_source_end_tlm_status_changed == 1'b1)
        begin
            axi4_get_clock_source_end_tlm_status_into_SystemVerilog(  ); // DPI call to imported task
            clock_source_end_tlm_status_changed = 1'b0;
        end
    end

    always @(posedge clock_source_end_wlm_status_changed or posedge _check_t0_values )
    begin
        if (clock_source_end_wlm_status_changed == 1'b1)
        begin
            axi4_get_clock_source_end_wlm_status_into_SystemVerilog(  ); // DPI call to imported task
            clock_source_end_wlm_status_changed = 1'b0;
        end
    end

    always @(posedge reset_source_end_tlm_status_changed or posedge _check_t0_values )
    begin
        if (reset_source_end_tlm_status_changed == 1'b1)
        begin
            axi4_get_reset_source_end_tlm_status_into_SystemVerilog(  ); // DPI call to imported task
            reset_source_end_tlm_status_changed = 1'b0;
        end
    end

    always @(posedge reset_source_end_wlm_status_changed or posedge _check_t0_values )
    begin
        if (reset_source_end_wlm_status_changed == 1'b1)
        begin
            axi4_get_reset_source_end_wlm_status_into_SystemVerilog(  ); // DPI call to imported task
            reset_source_end_wlm_status_changed = 1'b0;
        end
    end

    always @(posedge config_max_outstanding_wr_changed or posedge _check_t0_values )
    begin
        if (config_max_outstanding_wr_changed == 1'b1)
        begin
            axi4_get_config_max_outstanding_wr_into_SystemVerilog(  ); // DPI call to imported task
            config_max_outstanding_wr_changed = 1'b0;
        end
    end

    always @(posedge config_max_outstanding_rd_changed or posedge _check_t0_values )
    begin
        if (config_max_outstanding_rd_changed == 1'b1)
        begin
            axi4_get_config_max_outstanding_rd_into_SystemVerilog(  ); // DPI call to imported task
            config_max_outstanding_rd_changed = 1'b0;
        end
    end

    always @(posedge config_num_outstanding_wr_phase_changed or posedge _check_t0_values )
    begin
        if (config_num_outstanding_wr_phase_changed == 1'b1)
        begin
            axi4_get_config_num_outstanding_wr_phase_into_SystemVerilog(  ); // DPI call to imported task
            config_num_outstanding_wr_phase_changed = 1'b0;
        end
    end

    always @(posedge config_num_outstanding_rd_phase_changed or posedge _check_t0_values )
    begin
        if (config_num_outstanding_rd_phase_changed == 1'b1)
        begin
            axi4_get_config_num_outstanding_rd_phase_into_SystemVerilog(  ); // DPI call to imported task
            config_num_outstanding_rd_phase_changed = 1'b0;
        end
    end

    always @(posedge config_enable_warnings_changed or posedge _check_t0_values )
    begin
        if (config_enable_warnings_changed == 1'b1)
        begin
            axi4_get_config_enable_warnings_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_warnings_changed = 1'b0;
        end
    end

    always @(posedge config_enable_errors_changed or posedge _check_t0_values )
    begin
        if (config_enable_errors_changed == 1'b1)
        begin
            axi4_get_config_enable_errors_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_errors_changed = 1'b0;
        end
    end

    always @(posedge config_enable_exclusive_checks_changed or posedge _check_t0_values )
    begin
        if (config_enable_exclusive_checks_changed == 1'b1)
        begin
            axi4_get_config_enable_exclusive_checks_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_exclusive_checks_changed = 1'b0;
        end
    end

    always @(posedge config_warn_on_slave_errors_changed or posedge _check_t0_values )
    begin
        if (config_warn_on_slave_errors_changed == 1'b1)
        begin
            axi4_get_config_warn_on_slave_errors_into_SystemVerilog(  ); // DPI call to imported task
            config_warn_on_slave_errors_changed = 1'b0;
        end
    end

    always @(posedge config_error_on_deleted_valid_cycles_changed or posedge _check_t0_values )
    begin
        if (config_error_on_deleted_valid_cycles_changed == 1'b1)
        begin
            axi4_get_config_error_on_deleted_valid_cycles_into_SystemVerilog(  ); // DPI call to imported task
            config_error_on_deleted_valid_cycles_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_occupancy_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_read_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_occupancy_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_write_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_data_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_data_occupancy_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_read_data_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_data_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_data_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_data_occupancy_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_write_data_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_data_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_latency_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_latency_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_read_latency_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_latency_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_latency_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_latency_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_write_latency_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_latency_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_address_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_address_waits_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_read_address_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_address_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_data_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_data_waits_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_read_data_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_data_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_address_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_address_waits_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_write_address_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_address_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_data_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_data_waits_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_write_data_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_data_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_response_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_response_waits_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_write_response_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_response_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_bandwidth_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_bandwidth_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_read_bandwidth_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_bandwidth_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_bandwidth_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_bandwidth_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_write_bandwidth_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_bandwidth_changed = 1'b0;
        end
    end

    always @(posedge stats_rw_transaction_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_rw_transaction_last_duration_changed == 1'b1)
        begin
            axi4_get_stats_rw_transaction_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_rw_transaction_last_duration_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_occupancy_step_changed == 1'b1)
        begin
            axi4_get_config_stats_read_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_occupancy_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_read_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_active_changed or posedge _check_t0_values )
    begin
        if (stats_read_active_changed == 1'b1)
        begin
            axi4_get_stats_read_active_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_active_changed = 1'b0;
        end
    end

    always @(posedge stats_read_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_occupancy_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_idle_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_occupancy_min_changed == 1'b1)
        begin
            axi4_get_stats_read_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_idle_min_changed == 1'b1)
        begin
            axi4_get_stats_read_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_occupancy_max_changed == 1'b1)
        begin
            axi4_get_stats_read_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_idle_max_changed == 1'b1)
        begin
            axi4_get_stats_read_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_occupancy_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_read_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_idle_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_read_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_read_last_duration_changed == 1'b1)
        begin
            axi4_get_stats_read_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_last_duration_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_occupancy_step_changed == 1'b1)
        begin
            axi4_get_config_stats_write_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_occupancy_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_write_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_active_changed or posedge _check_t0_values )
    begin
        if (stats_write_active_changed == 1'b1)
        begin
            axi4_get_stats_write_active_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_active_changed = 1'b0;
        end
    end

    always @(posedge stats_write_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_occupancy_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_idle_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_occupancy_min_changed == 1'b1)
        begin
            axi4_get_stats_write_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_idle_min_changed == 1'b1)
        begin
            axi4_get_stats_write_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_occupancy_max_changed == 1'b1)
        begin
            axi4_get_stats_write_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_idle_max_changed == 1'b1)
        begin
            axi4_get_stats_write_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_occupancy_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_write_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_idle_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_write_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_write_last_duration_changed == 1'b1)
        begin
            axi4_get_stats_write_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_last_duration_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_occupancy_step_changed == 1'b1)
        begin
            axi4_get_config_stats_read_data_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_occupancy_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_read_data_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_data_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_data_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_min_changed == 1'b1)
        begin
            axi4_get_stats_read_data_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_min_changed == 1'b1)
        begin
            axi4_get_stats_read_data_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_max_changed == 1'b1)
        begin
            axi4_get_stats_read_data_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_max_changed == 1'b1)
        begin
            axi4_get_stats_read_data_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_data_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_data_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_occupancy_step_changed == 1'b1)
        begin
            axi4_get_config_stats_write_data_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_occupancy_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_write_data_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_data_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_data_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_min_changed == 1'b1)
        begin
            axi4_get_stats_write_data_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_min_changed == 1'b1)
        begin
            axi4_get_stats_write_data_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_max_changed == 1'b1)
        begin
            axi4_get_stats_write_data_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_max_changed == 1'b1)
        begin
            axi4_get_stats_write_data_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_data_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_data_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_bandwidth_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_bandwidth_step_changed == 1'b1)
        begin
            axi4_get_config_stats_read_bandwidth_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_bandwidth_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_bandwidth_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_bandwidth_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_read_bandwidth_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_bandwidth_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_bandwidth_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_min_changed == 1'b1)
        begin
            axi4_get_stats_read_bandwidth_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_max_changed == 1'b1)
        begin
            axi4_get_stats_read_bandwidth_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_bandwidth_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_bandwidth_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_bandwidth_step_changed == 1'b1)
        begin
            axi4_get_config_stats_write_bandwidth_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_bandwidth_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_bandwidth_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_bandwidth_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_write_bandwidth_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_bandwidth_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_bandwidth_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_min_changed == 1'b1)
        begin
            axi4_get_stats_write_bandwidth_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_max_changed == 1'b1)
        begin
            axi4_get_stats_write_bandwidth_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_bandwidth_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_latency_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_latency_step_changed == 1'b1)
        begin
            axi4_get_config_stats_read_latency_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_latency_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_latency_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_latency_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_read_latency_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_latency_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_inst_changed == 1'b1)
        begin
            axi4_get_stats_read_address_data_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_address_data_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_min_changed == 1'b1)
        begin
            axi4_get_stats_read_address_data_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_max_changed == 1'b1)
        begin
            axi4_get_stats_read_address_data_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_address_data_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_inst_changed == 1'b1)
        begin
            axi4_get_stats_read_address_address_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_address_address_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_min_changed == 1'b1)
        begin
            axi4_get_stats_read_address_address_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_max_changed == 1'b1)
        begin
            axi4_get_stats_read_address_address_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_address_address_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_latency_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_latency_step_changed == 1'b1)
        begin
            axi4_get_config_stats_write_latency_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_latency_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_latency_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_latency_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_write_latency_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_latency_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_response_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_response_latency_inst_changed == 1'b1)
        begin
            axi4_get_stats_write_address_response_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_response_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_response_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_response_latency_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_address_response_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_response_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_response_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_response_latency_min_changed == 1'b1)
        begin
            axi4_get_stats_write_address_response_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_response_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_response_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_response_latency_max_changed == 1'b1)
        begin
            axi4_get_stats_write_address_response_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_response_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_response_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_response_latency_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_address_response_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_response_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_inst_changed == 1'b1)
        begin
            axi4_get_stats_write_address_address_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_address_address_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_min_changed == 1'b1)
        begin
            axi4_get_stats_write_address_address_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_max_changed == 1'b1)
        begin
            axi4_get_stats_write_address_address_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_address_address_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_address_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_address_waits_step_changed == 1'b1)
        begin
            axi4_get_config_stats_read_address_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_address_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_address_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_address_waits_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_read_address_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_address_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_inst_changed == 1'b1)
        begin
            axi4_get_stats_read_address_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_address_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_min_changed == 1'b1)
        begin
            axi4_get_stats_read_address_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_max_changed == 1'b1)
        begin
            axi4_get_stats_read_address_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_address_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_waits_step_changed == 1'b1)
        begin
            axi4_get_config_stats_read_data_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_waits_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_read_data_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_inst_changed == 1'b1)
        begin
            axi4_get_stats_read_data_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_data_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_min_changed == 1'b1)
        begin
            axi4_get_stats_read_data_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_max_changed == 1'b1)
        begin
            axi4_get_stats_read_data_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_data_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_address_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_address_waits_step_changed == 1'b1)
        begin
            axi4_get_config_stats_write_address_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_address_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_address_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_address_waits_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_write_address_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_address_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_inst_changed == 1'b1)
        begin
            axi4_get_stats_write_address_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_address_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_min_changed == 1'b1)
        begin
            axi4_get_stats_write_address_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_max_changed == 1'b1)
        begin
            axi4_get_stats_write_address_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_address_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_waits_step_changed == 1'b1)
        begin
            axi4_get_config_stats_write_data_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_waits_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_write_data_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_inst_changed == 1'b1)
        begin
            axi4_get_stats_write_data_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_data_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_min_changed == 1'b1)
        begin
            axi4_get_stats_write_data_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_max_changed == 1'b1)
        begin
            axi4_get_stats_write_data_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_data_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_response_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_response_waits_step_changed == 1'b1)
        begin
            axi4_get_config_stats_write_response_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_response_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_response_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_response_waits_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_write_response_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_response_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_inst_changed == 1'b1)
        begin
            axi4_get_stats_write_response_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_response_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_min_changed == 1'b1)
        begin
            axi4_get_stats_write_response_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_max_changed == 1'b1)
        begin
            axi4_get_stats_write_response_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_response_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge reordering_depth_of_last_read_transaction_changed or posedge _check_t0_values )
    begin
        if (reordering_depth_of_last_read_transaction_changed == 1'b1)
        begin
            axi4_get_reordering_depth_of_last_read_transaction_into_SystemVerilog(  ); // DPI call to imported task
            reordering_depth_of_last_read_transaction_changed = 1'b0;
        end
    end


    function longint do_get_last_handle();
        return last_handle;
    endfunction


    function longint do_get_last_start_time();
        return last_start_time;
    endfunction


    function longint do_get_last_end_time();
        return last_end_time;
    endfunction


        bit report_available;

        // Function for getting a message from QUESTA_MVC. Returns 1 if a message was returned, 0 otherwise.
        import "DPI-C" questa_mvc_sv_get_report =  function bit get_report( input longint recipient,
                                     output string category,     output string objectName,
                                     output string instanceName, output string error_no,
                                     output string typ,          output string mess );
        questa_mvc_reporter endPoint[longint];
        initial report_available = 0;

        always @report_available
        begin
            longint recipient;
            string category;
            string objectName;
            string instanceName;
            string severity;
            string mess;
            string error_no;

            if ( endPoint.first( recipient ) )
              begin
                do
                  begin
                      while ( get_report( recipient, category, objectName, instanceName, error_no, severity, mess ) )
                        begin
                          endPoint[recipient].report_message( category, "axi4", 0, objectName, instanceName, error_no, severity, mess );
                        end
                  end
                while (endPoint.next(recipient));
              end
            report_available = 0;
        end

        import "DPI-C" context questa_mvc_register_end_point = function void questa_mvc_register_end_point( input longint as_end, input string name );

        // A function for registering a reporter to capture any reports coming from as_end
        function automatic void register_end_point( input longint as_end, input questa_mvc_reporter rep = null );
            if ( rep != null )
              begin
                if ( ( rep.name == "" ) || ( rep.name == "NULL" ) )
                  begin
                    $display("Error: %m: Reporter passed to register_end_point has a reserved name. Neither an empty string nor the string 'NULL' can be used.");
                  end
                else
                  begin
                    questa_mvc_register_end_point( as_end, rep.name );
                    endPoint[as_end] = rep;
                  end
              end
            else
              begin
                questa_mvc_register_end_point( as_end, "NULL" );
                endPoint.delete( as_end );
              end
        endfunction

    //------------------------------------------------------------------------------
    // Tasks for registering reports
    //------------------------------------------------------------------------------
    function void do_register_interface_reporter( input questa_mvc_reporter _rep = null );
        register_end_point( _interface_ref, _rep );
    endfunction

    function void do_register_master_reporter
    (
        input questa_mvc_reporter rep = null
    );
        register_end_point( axi4_get_axi4_master_end(), rep );
    endfunction

    function void do_register_slave_reporter
    (
        input questa_mvc_reporter rep = null
    );
        register_end_point( axi4_get_axi4_slave_end(), rep );
    endfunction

    function void do_register_clock_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
        register_end_point( axi4_get_axi4_clock_source_end(), rep );
    endfunction

    function void do_register_reset_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
        register_end_point( axi4_get_axi4_reset_source_end(), rep );
    endfunction


    // Start end_of_timestep timer
    initial
    forever
    begin
        wait_end_of_timestep();
    end


    bit non_blocking_end_of_timestep_control = 0;

    export "DPI-C" axi4_wait_end_of_timestep = task wait_end_of_timestep;

    task wait_end_of_timestep();
        begin
            wait(non_blocking_end_of_timestep_control == 1);
            axi4_end_of_timestep_VPI_SystemVerilog();
            non_blocking_end_of_timestep_control = 0;
        end
    endtask

    always @( posedge end_of_timestep_control or posedge _check_t0_values )
    begin
        if ( end_of_timestep_control == 1 )
        begin
            non_blocking_end_of_timestep_control <= 1;
            end_of_timestep_control = 0;
        end
    end

    //------------------------------------------------------------------------------
    // Tasks to wait for a number of specified edges on a wire
    //------------------------------------------------------------------------------

    task automatic do_wait_for_ACLK( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ACLK);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ACLK);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ACLK);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ACLK === 0 );
                    @( ACLK );
                end
                while ( ACLK !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ACLK === 1 );
                    @( ACLK );
                end
                while ( ACLK !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARESETn( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARESETn);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARESETn);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARESETn);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARESETn === 0 );
                    @( ARESETn );
                end
                while ( ARESETn !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARESETn === 1 );
                    @( ARESETn );
                end
                while ( ARESETn !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWVALID === 0 );
                    @( AWVALID );
                end
                while ( AWVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWVALID === 1 );
                    @( AWVALID );
                end
                while ( AWVALID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWADDR( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWADDR);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWADDR);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWADDR);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWADDR === 0 );
                    @( AWADDR );
                end
                while ( AWADDR !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWADDR === 1 );
                    @( AWADDR );
                end
                while ( AWADDR !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWADDR[_this_dot_1] === 0 );
                    @( AWADDR[_this_dot_1] );
                end
                while ( AWADDR[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWADDR[_this_dot_1] === 1 );
                    @( AWADDR[_this_dot_1] );
                end
                while ( AWADDR[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWPROT( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWPROT);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWPROT);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWPROT);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWPROT === 0 );
                    @( AWPROT );
                end
                while ( AWPROT !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWPROT === 1 );
                    @( AWPROT );
                end
                while ( AWPROT !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWPROT[_this_dot_1] === 0 );
                    @( AWPROT[_this_dot_1] );
                end
                while ( AWPROT[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWPROT[_this_dot_1] === 1 );
                    @( AWPROT[_this_dot_1] );
                end
                while ( AWPROT[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWREGION( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWREGION);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWREGION);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWREGION);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWREGION === 0 );
                    @( AWREGION );
                end
                while ( AWREGION !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWREGION === 1 );
                    @( AWREGION );
                end
                while ( AWREGION !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWREGION_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWREGION[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWREGION[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWREGION[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWREGION[_this_dot_1] === 0 );
                    @( AWREGION[_this_dot_1] );
                end
                while ( AWREGION[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWREGION[_this_dot_1] === 1 );
                    @( AWREGION[_this_dot_1] );
                end
                while ( AWREGION[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWLEN( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWLEN);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWLEN);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWLEN);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWLEN === 0 );
                    @( AWLEN );
                end
                while ( AWLEN !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWLEN === 1 );
                    @( AWLEN );
                end
                while ( AWLEN !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWLEN[_this_dot_1] === 0 );
                    @( AWLEN[_this_dot_1] );
                end
                while ( AWLEN[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWLEN[_this_dot_1] === 1 );
                    @( AWLEN[_this_dot_1] );
                end
                while ( AWLEN[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWSIZE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWSIZE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWSIZE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWSIZE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWSIZE === 0 );
                    @( AWSIZE );
                end
                while ( AWSIZE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWSIZE === 1 );
                    @( AWSIZE );
                end
                while ( AWSIZE !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWSIZE[_this_dot_1] === 0 );
                    @( AWSIZE[_this_dot_1] );
                end
                while ( AWSIZE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWSIZE[_this_dot_1] === 1 );
                    @( AWSIZE[_this_dot_1] );
                end
                while ( AWSIZE[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWBURST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWBURST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWBURST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWBURST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWBURST === 0 );
                    @( AWBURST );
                end
                while ( AWBURST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWBURST === 1 );
                    @( AWBURST );
                end
                while ( AWBURST !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWBURST[_this_dot_1] === 0 );
                    @( AWBURST[_this_dot_1] );
                end
                while ( AWBURST[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWBURST[_this_dot_1] === 1 );
                    @( AWBURST[_this_dot_1] );
                end
                while ( AWBURST[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWLOCK( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWLOCK);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWLOCK);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWLOCK);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWLOCK === 0 );
                    @( AWLOCK );
                end
                while ( AWLOCK !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWLOCK === 1 );
                    @( AWLOCK );
                end
                while ( AWLOCK !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWCACHE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWCACHE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWCACHE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWCACHE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWCACHE === 0 );
                    @( AWCACHE );
                end
                while ( AWCACHE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWCACHE === 1 );
                    @( AWCACHE );
                end
                while ( AWCACHE !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWCACHE[_this_dot_1] === 0 );
                    @( AWCACHE[_this_dot_1] );
                end
                while ( AWCACHE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWCACHE[_this_dot_1] === 1 );
                    @( AWCACHE[_this_dot_1] );
                end
                while ( AWCACHE[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWQOS( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWQOS);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWQOS);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWQOS);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWQOS === 0 );
                    @( AWQOS );
                end
                while ( AWQOS !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWQOS === 1 );
                    @( AWQOS );
                end
                while ( AWQOS !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWQOS_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWQOS[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWQOS[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWQOS[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWQOS[_this_dot_1] === 0 );
                    @( AWQOS[_this_dot_1] );
                end
                while ( AWQOS[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWQOS[_this_dot_1] === 1 );
                    @( AWQOS[_this_dot_1] );
                end
                while ( AWQOS[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWID === 0 );
                    @( AWID );
                end
                while ( AWID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWID === 1 );
                    @( AWID );
                end
                while ( AWID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWID[_this_dot_1] === 0 );
                    @( AWID[_this_dot_1] );
                end
                while ( AWID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWID[_this_dot_1] === 1 );
                    @( AWID[_this_dot_1] );
                end
                while ( AWID[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWUSER === 0 );
                    @( AWUSER );
                end
                while ( AWUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWUSER === 1 );
                    @( AWUSER );
                end
                while ( AWUSER !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWUSER[_this_dot_1] === 0 );
                    @( AWUSER[_this_dot_1] );
                end
                while ( AWUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWUSER[_this_dot_1] === 1 );
                    @( AWUSER[_this_dot_1] );
                end
                while ( AWUSER[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWREADY === 0 );
                    @( AWREADY );
                end
                while ( AWREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWREADY === 1 );
                    @( AWREADY );
                end
                while ( AWREADY !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARVALID === 0 );
                    @( ARVALID );
                end
                while ( ARVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARVALID === 1 );
                    @( ARVALID );
                end
                while ( ARVALID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARADDR( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARADDR);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARADDR);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARADDR);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARADDR === 0 );
                    @( ARADDR );
                end
                while ( ARADDR !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARADDR === 1 );
                    @( ARADDR );
                end
                while ( ARADDR !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARADDR[_this_dot_1] === 0 );
                    @( ARADDR[_this_dot_1] );
                end
                while ( ARADDR[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARADDR[_this_dot_1] === 1 );
                    @( ARADDR[_this_dot_1] );
                end
                while ( ARADDR[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARPROT( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARPROT);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARPROT);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARPROT);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARPROT === 0 );
                    @( ARPROT );
                end
                while ( ARPROT !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARPROT === 1 );
                    @( ARPROT );
                end
                while ( ARPROT !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARPROT[_this_dot_1] === 0 );
                    @( ARPROT[_this_dot_1] );
                end
                while ( ARPROT[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARPROT[_this_dot_1] === 1 );
                    @( ARPROT[_this_dot_1] );
                end
                while ( ARPROT[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARREGION( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARREGION);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARREGION);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARREGION);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARREGION === 0 );
                    @( ARREGION );
                end
                while ( ARREGION !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARREGION === 1 );
                    @( ARREGION );
                end
                while ( ARREGION !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARREGION_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARREGION[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARREGION[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARREGION[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARREGION[_this_dot_1] === 0 );
                    @( ARREGION[_this_dot_1] );
                end
                while ( ARREGION[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARREGION[_this_dot_1] === 1 );
                    @( ARREGION[_this_dot_1] );
                end
                while ( ARREGION[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARLEN( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARLEN);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARLEN);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARLEN);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARLEN === 0 );
                    @( ARLEN );
                end
                while ( ARLEN !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARLEN === 1 );
                    @( ARLEN );
                end
                while ( ARLEN !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARLEN[_this_dot_1] === 0 );
                    @( ARLEN[_this_dot_1] );
                end
                while ( ARLEN[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARLEN[_this_dot_1] === 1 );
                    @( ARLEN[_this_dot_1] );
                end
                while ( ARLEN[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARSIZE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARSIZE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARSIZE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARSIZE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARSIZE === 0 );
                    @( ARSIZE );
                end
                while ( ARSIZE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARSIZE === 1 );
                    @( ARSIZE );
                end
                while ( ARSIZE !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARSIZE[_this_dot_1] === 0 );
                    @( ARSIZE[_this_dot_1] );
                end
                while ( ARSIZE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARSIZE[_this_dot_1] === 1 );
                    @( ARSIZE[_this_dot_1] );
                end
                while ( ARSIZE[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARBURST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARBURST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARBURST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARBURST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARBURST === 0 );
                    @( ARBURST );
                end
                while ( ARBURST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARBURST === 1 );
                    @( ARBURST );
                end
                while ( ARBURST !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARBURST[_this_dot_1] === 0 );
                    @( ARBURST[_this_dot_1] );
                end
                while ( ARBURST[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARBURST[_this_dot_1] === 1 );
                    @( ARBURST[_this_dot_1] );
                end
                while ( ARBURST[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARLOCK( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARLOCK);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARLOCK);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARLOCK);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARLOCK === 0 );
                    @( ARLOCK );
                end
                while ( ARLOCK !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARLOCK === 1 );
                    @( ARLOCK );
                end
                while ( ARLOCK !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARCACHE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARCACHE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARCACHE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARCACHE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARCACHE === 0 );
                    @( ARCACHE );
                end
                while ( ARCACHE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARCACHE === 1 );
                    @( ARCACHE );
                end
                while ( ARCACHE !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARCACHE[_this_dot_1] === 0 );
                    @( ARCACHE[_this_dot_1] );
                end
                while ( ARCACHE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARCACHE[_this_dot_1] === 1 );
                    @( ARCACHE[_this_dot_1] );
                end
                while ( ARCACHE[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARQOS( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARQOS);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARQOS);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARQOS);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARQOS === 0 );
                    @( ARQOS );
                end
                while ( ARQOS !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARQOS === 1 );
                    @( ARQOS );
                end
                while ( ARQOS !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARQOS_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARQOS[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARQOS[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARQOS[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARQOS[_this_dot_1] === 0 );
                    @( ARQOS[_this_dot_1] );
                end
                while ( ARQOS[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARQOS[_this_dot_1] === 1 );
                    @( ARQOS[_this_dot_1] );
                end
                while ( ARQOS[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARID === 0 );
                    @( ARID );
                end
                while ( ARID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARID === 1 );
                    @( ARID );
                end
                while ( ARID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARID[_this_dot_1] === 0 );
                    @( ARID[_this_dot_1] );
                end
                while ( ARID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARID[_this_dot_1] === 1 );
                    @( ARID[_this_dot_1] );
                end
                while ( ARID[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARUSER === 0 );
                    @( ARUSER );
                end
                while ( ARUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARUSER === 1 );
                    @( ARUSER );
                end
                while ( ARUSER !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARUSER[_this_dot_1] === 0 );
                    @( ARUSER[_this_dot_1] );
                end
                while ( ARUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARUSER[_this_dot_1] === 1 );
                    @( ARUSER[_this_dot_1] );
                end
                while ( ARUSER[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARREADY === 0 );
                    @( ARREADY );
                end
                while ( ARREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARREADY === 1 );
                    @( ARREADY );
                end
                while ( ARREADY !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RVALID === 0 );
                    @( RVALID );
                end
                while ( RVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RVALID === 1 );
                    @( RVALID );
                end
                while ( RVALID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RDATA( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RDATA);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RDATA);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RDATA);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RDATA === 0 );
                    @( RDATA );
                end
                while ( RDATA !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RDATA === 1 );
                    @( RDATA );
                end
                while ( RDATA !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RDATA[_this_dot_1] === 0 );
                    @( RDATA[_this_dot_1] );
                end
                while ( RDATA[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RDATA[_this_dot_1] === 1 );
                    @( RDATA[_this_dot_1] );
                end
                while ( RDATA[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RRESP( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RRESP);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RRESP);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RRESP);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RRESP === 0 );
                    @( RRESP );
                end
                while ( RRESP !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RRESP === 1 );
                    @( RRESP );
                end
                while ( RRESP !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RRESP[_this_dot_1] === 0 );
                    @( RRESP[_this_dot_1] );
                end
                while ( RRESP[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RRESP[_this_dot_1] === 1 );
                    @( RRESP[_this_dot_1] );
                end
                while ( RRESP[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RLAST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RLAST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RLAST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RLAST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RLAST === 0 );
                    @( RLAST );
                end
                while ( RLAST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RLAST === 1 );
                    @( RLAST );
                end
                while ( RLAST !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RID === 0 );
                    @( RID );
                end
                while ( RID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RID === 1 );
                    @( RID );
                end
                while ( RID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RID[_this_dot_1] === 0 );
                    @( RID[_this_dot_1] );
                end
                while ( RID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RID[_this_dot_1] === 1 );
                    @( RID[_this_dot_1] );
                end
                while ( RID[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RUSER === 0 );
                    @( RUSER );
                end
                while ( RUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RUSER === 1 );
                    @( RUSER );
                end
                while ( RUSER !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RUSER[_this_dot_1] === 0 );
                    @( RUSER[_this_dot_1] );
                end
                while ( RUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RUSER[_this_dot_1] === 1 );
                    @( RUSER[_this_dot_1] );
                end
                while ( RUSER[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RREADY === 0 );
                    @( RREADY );
                end
                while ( RREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RREADY === 1 );
                    @( RREADY );
                end
                while ( RREADY !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WVALID === 0 );
                    @( WVALID );
                end
                while ( WVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WVALID === 1 );
                    @( WVALID );
                end
                while ( WVALID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WDATA( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WDATA);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WDATA);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WDATA);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WDATA === 0 );
                    @( WDATA );
                end
                while ( WDATA !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WDATA === 1 );
                    @( WDATA );
                end
                while ( WDATA !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WDATA[_this_dot_1] === 0 );
                    @( WDATA[_this_dot_1] );
                end
                while ( WDATA[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WDATA[_this_dot_1] === 1 );
                    @( WDATA[_this_dot_1] );
                end
                while ( WDATA[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WSTRB( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WSTRB);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WSTRB);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WSTRB);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WSTRB === 0 );
                    @( WSTRB );
                end
                while ( WSTRB !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WSTRB === 1 );
                    @( WSTRB );
                end
                while ( WSTRB !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WSTRB_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WSTRB[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WSTRB[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WSTRB[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WSTRB[_this_dot_1] === 0 );
                    @( WSTRB[_this_dot_1] );
                end
                while ( WSTRB[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WSTRB[_this_dot_1] === 1 );
                    @( WSTRB[_this_dot_1] );
                end
                while ( WSTRB[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WLAST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WLAST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WLAST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WLAST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WLAST === 0 );
                    @( WLAST );
                end
                while ( WLAST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WLAST === 1 );
                    @( WLAST );
                end
                while ( WLAST !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WUSER === 0 );
                    @( WUSER );
                end
                while ( WUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WUSER === 1 );
                    @( WUSER );
                end
                while ( WUSER !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WUSER[_this_dot_1] === 0 );
                    @( WUSER[_this_dot_1] );
                end
                while ( WUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WUSER[_this_dot_1] === 1 );
                    @( WUSER[_this_dot_1] );
                end
                while ( WUSER[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WREADY === 0 );
                    @( WREADY );
                end
                while ( WREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WREADY === 1 );
                    @( WREADY );
                end
                while ( WREADY !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BVALID === 0 );
                    @( BVALID );
                end
                while ( BVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BVALID === 1 );
                    @( BVALID );
                end
                while ( BVALID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BRESP( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BRESP);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BRESP);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BRESP);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BRESP === 0 );
                    @( BRESP );
                end
                while ( BRESP !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BRESP === 1 );
                    @( BRESP );
                end
                while ( BRESP !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BRESP[_this_dot_1] === 0 );
                    @( BRESP[_this_dot_1] );
                end
                while ( BRESP[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BRESP[_this_dot_1] === 1 );
                    @( BRESP[_this_dot_1] );
                end
                while ( BRESP[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BID === 0 );
                    @( BID );
                end
                while ( BID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BID === 1 );
                    @( BID );
                end
                while ( BID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BID[_this_dot_1] === 0 );
                    @( BID[_this_dot_1] );
                end
                while ( BID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BID[_this_dot_1] === 1 );
                    @( BID[_this_dot_1] );
                end
                while ( BID[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BUSER === 0 );
                    @( BUSER );
                end
                while ( BUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BUSER === 1 );
                    @( BUSER );
                end
                while ( BUSER !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BUSER[_this_dot_1] === 0 );
                    @( BUSER[_this_dot_1] );
                end
                while ( BUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BUSER[_this_dot_1] === 1 );
                    @( BUSER[_this_dot_1] );
                end
                while ( BUSER[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BREADY === 0 );
                    @( BREADY );
                end
                while ( BREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BREADY === 1 );
                    @( BREADY );
                end
                while ( BREADY !== 0 );
            end
        end
    endtask

    //------------------------------------------------------------------------------
    // Tasks/functions to set/get wires
    //------------------------------------------------------------------------------

    task automatic do_set_ACLK( logic ACLK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ACLK = ACLK_param;
        else
            m_ACLK <= ACLK_param;
    endtask

    function automatic logic do_get_ACLK(  );
        return ACLK;
    endfunction

    task automatic do_set_ARESETn( logic ARESETn_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARESETn = ARESETn_param;
        else
            m_ARESETn <= ARESETn_param;
    endtask

    function automatic logic do_get_ARESETn(  );
        return ARESETn;
    endfunction

    task automatic do_set_AWVALID( logic AWVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWVALID = AWVALID_param;
        else
            m_AWVALID <= AWVALID_param;
    endtask

    function automatic logic do_get_AWVALID(  );
        return AWVALID;
    endfunction

    task automatic do_set_AWADDR( logic [((AXI4_ADDRESS_WIDTH) - 1):0]  AWADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWADDR = AWADDR_param;
        else
            m_AWADDR <= AWADDR_param;
    endtask

    task automatic do_set_AWADDR_index1( int _this_dot_1, logic  AWADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWADDR[_this_dot_1] = AWADDR_param;
        else
            m_AWADDR[_this_dot_1] <= AWADDR_param;
    endtask

    function automatic logic [((AXI4_ADDRESS_WIDTH) - 1):0]   do_get_AWADDR(  );
        return AWADDR;
    endfunction

    function automatic logic   do_get_AWADDR_index1( int _this_dot_1 );
        return AWADDR[_this_dot_1];
    endfunction

    task automatic do_set_AWPROT( logic [2:0] AWPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWPROT = AWPROT_param;
        else
            m_AWPROT <= AWPROT_param;
    endtask

    task automatic do_set_AWPROT_index1( int _this_dot_1, logic  AWPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWPROT[_this_dot_1] = AWPROT_param;
        else
            m_AWPROT[_this_dot_1] <= AWPROT_param;
    endtask

    function automatic logic [2:0]  do_get_AWPROT(  );
        return AWPROT;
    endfunction

    function automatic logic   do_get_AWPROT_index1( int _this_dot_1 );
        return AWPROT[_this_dot_1];
    endfunction

    task automatic do_set_AWREGION( logic [3:0] AWREGION_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWREGION = AWREGION_param;
        else
            m_AWREGION <= AWREGION_param;
    endtask

    task automatic do_set_AWREGION_index1( int _this_dot_1, logic  AWREGION_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWREGION[_this_dot_1] = AWREGION_param;
        else
            m_AWREGION[_this_dot_1] <= AWREGION_param;
    endtask

    function automatic logic [3:0]  do_get_AWREGION(  );
        return AWREGION;
    endfunction

    function automatic logic   do_get_AWREGION_index1( int _this_dot_1 );
        return AWREGION[_this_dot_1];
    endfunction

    task automatic do_set_AWLEN( logic [7:0] AWLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWLEN = AWLEN_param;
        else
            m_AWLEN <= AWLEN_param;
    endtask

    task automatic do_set_AWLEN_index1( int _this_dot_1, logic  AWLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWLEN[_this_dot_1] = AWLEN_param;
        else
            m_AWLEN[_this_dot_1] <= AWLEN_param;
    endtask

    function automatic logic [7:0]  do_get_AWLEN(  );
        return AWLEN;
    endfunction

    function automatic logic   do_get_AWLEN_index1( int _this_dot_1 );
        return AWLEN[_this_dot_1];
    endfunction

    task automatic do_set_AWSIZE( logic [2:0] AWSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWSIZE = AWSIZE_param;
        else
            m_AWSIZE <= AWSIZE_param;
    endtask

    task automatic do_set_AWSIZE_index1( int _this_dot_1, logic  AWSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWSIZE[_this_dot_1] = AWSIZE_param;
        else
            m_AWSIZE[_this_dot_1] <= AWSIZE_param;
    endtask

    function automatic logic [2:0]  do_get_AWSIZE(  );
        return AWSIZE;
    endfunction

    function automatic logic   do_get_AWSIZE_index1( int _this_dot_1 );
        return AWSIZE[_this_dot_1];
    endfunction

    task automatic do_set_AWBURST( logic [1:0] AWBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWBURST = AWBURST_param;
        else
            m_AWBURST <= AWBURST_param;
    endtask

    task automatic do_set_AWBURST_index1( int _this_dot_1, logic  AWBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWBURST[_this_dot_1] = AWBURST_param;
        else
            m_AWBURST[_this_dot_1] <= AWBURST_param;
    endtask

    function automatic logic [1:0]  do_get_AWBURST(  );
        return AWBURST;
    endfunction

    function automatic logic   do_get_AWBURST_index1( int _this_dot_1 );
        return AWBURST[_this_dot_1];
    endfunction

    task automatic do_set_AWLOCK( logic AWLOCK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWLOCK = AWLOCK_param;
        else
            m_AWLOCK <= AWLOCK_param;
    endtask

    function automatic logic do_get_AWLOCK(  );
        return AWLOCK;
    endfunction

    task automatic do_set_AWCACHE( logic [3:0] AWCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWCACHE = AWCACHE_param;
        else
            m_AWCACHE <= AWCACHE_param;
    endtask

    task automatic do_set_AWCACHE_index1( int _this_dot_1, logic  AWCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWCACHE[_this_dot_1] = AWCACHE_param;
        else
            m_AWCACHE[_this_dot_1] <= AWCACHE_param;
    endtask

    function automatic logic [3:0]  do_get_AWCACHE(  );
        return AWCACHE;
    endfunction

    function automatic logic   do_get_AWCACHE_index1( int _this_dot_1 );
        return AWCACHE[_this_dot_1];
    endfunction

    task automatic do_set_AWQOS( logic [3:0] AWQOS_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWQOS = AWQOS_param;
        else
            m_AWQOS <= AWQOS_param;
    endtask

    task automatic do_set_AWQOS_index1( int _this_dot_1, logic  AWQOS_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWQOS[_this_dot_1] = AWQOS_param;
        else
            m_AWQOS[_this_dot_1] <= AWQOS_param;
    endtask

    function automatic logic [3:0]  do_get_AWQOS(  );
        return AWQOS;
    endfunction

    function automatic logic   do_get_AWQOS_index1( int _this_dot_1 );
        return AWQOS[_this_dot_1];
    endfunction

    task automatic do_set_AWID( logic [((AXI4_ID_WIDTH) - 1):0]  AWID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWID = AWID_param;
        else
            m_AWID <= AWID_param;
    endtask

    task automatic do_set_AWID_index1( int _this_dot_1, logic  AWID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWID[_this_dot_1] = AWID_param;
        else
            m_AWID[_this_dot_1] <= AWID_param;
    endtask

    function automatic logic [((AXI4_ID_WIDTH) - 1):0]   do_get_AWID(  );
        return AWID;
    endfunction

    function automatic logic   do_get_AWID_index1( int _this_dot_1 );
        return AWID[_this_dot_1];
    endfunction

    task automatic do_set_AWUSER( logic [((AXI4_USER_WIDTH) - 1):0]  AWUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWUSER = AWUSER_param;
        else
            m_AWUSER <= AWUSER_param;
    endtask

    task automatic do_set_AWUSER_index1( int _this_dot_1, logic  AWUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWUSER[_this_dot_1] = AWUSER_param;
        else
            m_AWUSER[_this_dot_1] <= AWUSER_param;
    endtask

    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   do_get_AWUSER(  );
        return AWUSER;
    endfunction

    function automatic logic   do_get_AWUSER_index1( int _this_dot_1 );
        return AWUSER[_this_dot_1];
    endfunction

    task automatic do_set_AWREADY( logic AWREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWREADY = AWREADY_param;
        else
            m_AWREADY <= AWREADY_param;
    endtask

    function automatic logic do_get_AWREADY(  );
        return AWREADY;
    endfunction

    task automatic do_set_ARVALID( logic ARVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARVALID = ARVALID_param;
        else
            m_ARVALID <= ARVALID_param;
    endtask

    function automatic logic do_get_ARVALID(  );
        return ARVALID;
    endfunction

    task automatic do_set_ARADDR( logic [((AXI4_ADDRESS_WIDTH) - 1):0]  ARADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARADDR = ARADDR_param;
        else
            m_ARADDR <= ARADDR_param;
    endtask

    task automatic do_set_ARADDR_index1( int _this_dot_1, logic  ARADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARADDR[_this_dot_1] = ARADDR_param;
        else
            m_ARADDR[_this_dot_1] <= ARADDR_param;
    endtask

    function automatic logic [((AXI4_ADDRESS_WIDTH) - 1):0]   do_get_ARADDR(  );
        return ARADDR;
    endfunction

    function automatic logic   do_get_ARADDR_index1( int _this_dot_1 );
        return ARADDR[_this_dot_1];
    endfunction

    task automatic do_set_ARPROT( logic [2:0] ARPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARPROT = ARPROT_param;
        else
            m_ARPROT <= ARPROT_param;
    endtask

    task automatic do_set_ARPROT_index1( int _this_dot_1, logic  ARPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARPROT[_this_dot_1] = ARPROT_param;
        else
            m_ARPROT[_this_dot_1] <= ARPROT_param;
    endtask

    function automatic logic [2:0]  do_get_ARPROT(  );
        return ARPROT;
    endfunction

    function automatic logic   do_get_ARPROT_index1( int _this_dot_1 );
        return ARPROT[_this_dot_1];
    endfunction

    task automatic do_set_ARREGION( logic [3:0] ARREGION_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARREGION = ARREGION_param;
        else
            m_ARREGION <= ARREGION_param;
    endtask

    task automatic do_set_ARREGION_index1( int _this_dot_1, logic  ARREGION_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARREGION[_this_dot_1] = ARREGION_param;
        else
            m_ARREGION[_this_dot_1] <= ARREGION_param;
    endtask

    function automatic logic [3:0]  do_get_ARREGION(  );
        return ARREGION;
    endfunction

    function automatic logic   do_get_ARREGION_index1( int _this_dot_1 );
        return ARREGION[_this_dot_1];
    endfunction

    task automatic do_set_ARLEN( logic [7:0] ARLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARLEN = ARLEN_param;
        else
            m_ARLEN <= ARLEN_param;
    endtask

    task automatic do_set_ARLEN_index1( int _this_dot_1, logic  ARLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARLEN[_this_dot_1] = ARLEN_param;
        else
            m_ARLEN[_this_dot_1] <= ARLEN_param;
    endtask

    function automatic logic [7:0]  do_get_ARLEN(  );
        return ARLEN;
    endfunction

    function automatic logic   do_get_ARLEN_index1( int _this_dot_1 );
        return ARLEN[_this_dot_1];
    endfunction

    task automatic do_set_ARSIZE( logic [2:0] ARSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARSIZE = ARSIZE_param;
        else
            m_ARSIZE <= ARSIZE_param;
    endtask

    task automatic do_set_ARSIZE_index1( int _this_dot_1, logic  ARSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARSIZE[_this_dot_1] = ARSIZE_param;
        else
            m_ARSIZE[_this_dot_1] <= ARSIZE_param;
    endtask

    function automatic logic [2:0]  do_get_ARSIZE(  );
        return ARSIZE;
    endfunction

    function automatic logic   do_get_ARSIZE_index1( int _this_dot_1 );
        return ARSIZE[_this_dot_1];
    endfunction

    task automatic do_set_ARBURST( logic [1:0] ARBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARBURST = ARBURST_param;
        else
            m_ARBURST <= ARBURST_param;
    endtask

    task automatic do_set_ARBURST_index1( int _this_dot_1, logic  ARBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARBURST[_this_dot_1] = ARBURST_param;
        else
            m_ARBURST[_this_dot_1] <= ARBURST_param;
    endtask

    function automatic logic [1:0]  do_get_ARBURST(  );
        return ARBURST;
    endfunction

    function automatic logic   do_get_ARBURST_index1( int _this_dot_1 );
        return ARBURST[_this_dot_1];
    endfunction

    task automatic do_set_ARLOCK( logic ARLOCK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARLOCK = ARLOCK_param;
        else
            m_ARLOCK <= ARLOCK_param;
    endtask

    function automatic logic do_get_ARLOCK(  );
        return ARLOCK;
    endfunction

    task automatic do_set_ARCACHE( logic [3:0] ARCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARCACHE = ARCACHE_param;
        else
            m_ARCACHE <= ARCACHE_param;
    endtask

    task automatic do_set_ARCACHE_index1( int _this_dot_1, logic  ARCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARCACHE[_this_dot_1] = ARCACHE_param;
        else
            m_ARCACHE[_this_dot_1] <= ARCACHE_param;
    endtask

    function automatic logic [3:0]  do_get_ARCACHE(  );
        return ARCACHE;
    endfunction

    function automatic logic   do_get_ARCACHE_index1( int _this_dot_1 );
        return ARCACHE[_this_dot_1];
    endfunction

    task automatic do_set_ARQOS( logic [3:0] ARQOS_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARQOS = ARQOS_param;
        else
            m_ARQOS <= ARQOS_param;
    endtask

    task automatic do_set_ARQOS_index1( int _this_dot_1, logic  ARQOS_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARQOS[_this_dot_1] = ARQOS_param;
        else
            m_ARQOS[_this_dot_1] <= ARQOS_param;
    endtask

    function automatic logic [3:0]  do_get_ARQOS(  );
        return ARQOS;
    endfunction

    function automatic logic   do_get_ARQOS_index1( int _this_dot_1 );
        return ARQOS[_this_dot_1];
    endfunction

    task automatic do_set_ARID( logic [((AXI4_ID_WIDTH) - 1):0]  ARID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARID = ARID_param;
        else
            m_ARID <= ARID_param;
    endtask

    task automatic do_set_ARID_index1( int _this_dot_1, logic  ARID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARID[_this_dot_1] = ARID_param;
        else
            m_ARID[_this_dot_1] <= ARID_param;
    endtask

    function automatic logic [((AXI4_ID_WIDTH) - 1):0]   do_get_ARID(  );
        return ARID;
    endfunction

    function automatic logic   do_get_ARID_index1( int _this_dot_1 );
        return ARID[_this_dot_1];
    endfunction

    task automatic do_set_ARUSER( logic [((AXI4_USER_WIDTH) - 1):0]  ARUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARUSER = ARUSER_param;
        else
            m_ARUSER <= ARUSER_param;
    endtask

    task automatic do_set_ARUSER_index1( int _this_dot_1, logic  ARUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARUSER[_this_dot_1] = ARUSER_param;
        else
            m_ARUSER[_this_dot_1] <= ARUSER_param;
    endtask

    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   do_get_ARUSER(  );
        return ARUSER;
    endfunction

    function automatic logic   do_get_ARUSER_index1( int _this_dot_1 );
        return ARUSER[_this_dot_1];
    endfunction

    task automatic do_set_ARREADY( logic ARREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARREADY = ARREADY_param;
        else
            m_ARREADY <= ARREADY_param;
    endtask

    function automatic logic do_get_ARREADY(  );
        return ARREADY;
    endfunction

    task automatic do_set_RVALID( logic RVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RVALID = RVALID_param;
        else
            m_RVALID <= RVALID_param;
    endtask

    function automatic logic do_get_RVALID(  );
        return RVALID;
    endfunction

    task automatic do_set_RDATA( logic [((AXI4_RDATA_WIDTH) - 1):0]  RDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RDATA = RDATA_param;
        else
            m_RDATA <= RDATA_param;
    endtask

    task automatic do_set_RDATA_index1( int _this_dot_1, logic  RDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RDATA[_this_dot_1] = RDATA_param;
        else
            m_RDATA[_this_dot_1] <= RDATA_param;
    endtask

    function automatic logic [((AXI4_RDATA_WIDTH) - 1):0]   do_get_RDATA(  );
        return RDATA;
    endfunction

    function automatic logic   do_get_RDATA_index1( int _this_dot_1 );
        return RDATA[_this_dot_1];
    endfunction

    task automatic do_set_RRESP( logic [1:0] RRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RRESP = RRESP_param;
        else
            m_RRESP <= RRESP_param;
    endtask

    task automatic do_set_RRESP_index1( int _this_dot_1, logic  RRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RRESP[_this_dot_1] = RRESP_param;
        else
            m_RRESP[_this_dot_1] <= RRESP_param;
    endtask

    function automatic logic [1:0]  do_get_RRESP(  );
        return RRESP;
    endfunction

    function automatic logic   do_get_RRESP_index1( int _this_dot_1 );
        return RRESP[_this_dot_1];
    endfunction

    task automatic do_set_RLAST( logic RLAST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RLAST = RLAST_param;
        else
            m_RLAST <= RLAST_param;
    endtask

    function automatic logic do_get_RLAST(  );
        return RLAST;
    endfunction

    task automatic do_set_RID( logic [((AXI4_ID_WIDTH) - 1):0]  RID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RID = RID_param;
        else
            m_RID <= RID_param;
    endtask

    task automatic do_set_RID_index1( int _this_dot_1, logic  RID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RID[_this_dot_1] = RID_param;
        else
            m_RID[_this_dot_1] <= RID_param;
    endtask

    function automatic logic [((AXI4_ID_WIDTH) - 1):0]   do_get_RID(  );
        return RID;
    endfunction

    function automatic logic   do_get_RID_index1( int _this_dot_1 );
        return RID[_this_dot_1];
    endfunction

    task automatic do_set_RUSER( logic [((AXI4_USER_WIDTH) - 1):0]  RUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RUSER = RUSER_param;
        else
            m_RUSER <= RUSER_param;
    endtask

    task automatic do_set_RUSER_index1( int _this_dot_1, logic  RUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RUSER[_this_dot_1] = RUSER_param;
        else
            m_RUSER[_this_dot_1] <= RUSER_param;
    endtask

    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   do_get_RUSER(  );
        return RUSER;
    endfunction

    function automatic logic   do_get_RUSER_index1( int _this_dot_1 );
        return RUSER[_this_dot_1];
    endfunction

    task automatic do_set_RREADY( logic RREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RREADY = RREADY_param;
        else
            m_RREADY <= RREADY_param;
    endtask

    function automatic logic do_get_RREADY(  );
        return RREADY;
    endfunction

    task automatic do_set_WVALID( logic WVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WVALID = WVALID_param;
        else
            m_WVALID <= WVALID_param;
    endtask

    function automatic logic do_get_WVALID(  );
        return WVALID;
    endfunction

    task automatic do_set_WDATA( logic [((AXI4_WDATA_WIDTH) - 1):0]  WDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WDATA = WDATA_param;
        else
            m_WDATA <= WDATA_param;
    endtask

    task automatic do_set_WDATA_index1( int _this_dot_1, logic  WDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WDATA[_this_dot_1] = WDATA_param;
        else
            m_WDATA[_this_dot_1] <= WDATA_param;
    endtask

    function automatic logic [((AXI4_WDATA_WIDTH) - 1):0]   do_get_WDATA(  );
        return WDATA;
    endfunction

    function automatic logic   do_get_WDATA_index1( int _this_dot_1 );
        return WDATA[_this_dot_1];
    endfunction

    task automatic do_set_WSTRB( logic [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  WSTRB_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WSTRB = WSTRB_param;
        else
            m_WSTRB <= WSTRB_param;
    endtask

    task automatic do_set_WSTRB_index1( int _this_dot_1, logic  WSTRB_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WSTRB[_this_dot_1] = WSTRB_param;
        else
            m_WSTRB[_this_dot_1] <= WSTRB_param;
    endtask

    function automatic logic [(((AXI4_WDATA_WIDTH / 8)) - 1):0]   do_get_WSTRB(  );
        return WSTRB;
    endfunction

    function automatic logic   do_get_WSTRB_index1( int _this_dot_1 );
        return WSTRB[_this_dot_1];
    endfunction

    task automatic do_set_WLAST( logic WLAST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WLAST = WLAST_param;
        else
            m_WLAST <= WLAST_param;
    endtask

    function automatic logic do_get_WLAST(  );
        return WLAST;
    endfunction

    task automatic do_set_WUSER( logic [((AXI4_USER_WIDTH) - 1):0]  WUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WUSER = WUSER_param;
        else
            m_WUSER <= WUSER_param;
    endtask

    task automatic do_set_WUSER_index1( int _this_dot_1, logic  WUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WUSER[_this_dot_1] = WUSER_param;
        else
            m_WUSER[_this_dot_1] <= WUSER_param;
    endtask

    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   do_get_WUSER(  );
        return WUSER;
    endfunction

    function automatic logic   do_get_WUSER_index1( int _this_dot_1 );
        return WUSER[_this_dot_1];
    endfunction

    task automatic do_set_WREADY( logic WREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WREADY = WREADY_param;
        else
            m_WREADY <= WREADY_param;
    endtask

    function automatic logic do_get_WREADY(  );
        return WREADY;
    endfunction

    task automatic do_set_BVALID( logic BVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BVALID = BVALID_param;
        else
            m_BVALID <= BVALID_param;
    endtask

    function automatic logic do_get_BVALID(  );
        return BVALID;
    endfunction

    task automatic do_set_BRESP( logic [1:0] BRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BRESP = BRESP_param;
        else
            m_BRESP <= BRESP_param;
    endtask

    task automatic do_set_BRESP_index1( int _this_dot_1, logic  BRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BRESP[_this_dot_1] = BRESP_param;
        else
            m_BRESP[_this_dot_1] <= BRESP_param;
    endtask

    function automatic logic [1:0]  do_get_BRESP(  );
        return BRESP;
    endfunction

    function automatic logic   do_get_BRESP_index1( int _this_dot_1 );
        return BRESP[_this_dot_1];
    endfunction

    task automatic do_set_BID( logic [((AXI4_ID_WIDTH) - 1):0]  BID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BID = BID_param;
        else
            m_BID <= BID_param;
    endtask

    task automatic do_set_BID_index1( int _this_dot_1, logic  BID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BID[_this_dot_1] = BID_param;
        else
            m_BID[_this_dot_1] <= BID_param;
    endtask

    function automatic logic [((AXI4_ID_WIDTH) - 1):0]   do_get_BID(  );
        return BID;
    endfunction

    function automatic logic   do_get_BID_index1( int _this_dot_1 );
        return BID[_this_dot_1];
    endfunction

    task automatic do_set_BUSER( logic [((AXI4_USER_WIDTH) - 1):0]  BUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BUSER = BUSER_param;
        else
            m_BUSER <= BUSER_param;
    endtask

    task automatic do_set_BUSER_index1( int _this_dot_1, logic  BUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BUSER[_this_dot_1] = BUSER_param;
        else
            m_BUSER[_this_dot_1] <= BUSER_param;
    endtask

    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   do_get_BUSER(  );
        return BUSER;
    endfunction

    function automatic logic   do_get_BUSER_index1( int _this_dot_1 );
        return BUSER[_this_dot_1];
    endfunction

    task automatic do_set_BREADY( logic BREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BREADY = BREADY_param;
        else
            m_BREADY <= BREADY_param;
    endtask

    function automatic logic do_get_BREADY(  );
        return BREADY;
    endfunction

    //------------------------------------------------------------------------------
    // Tasks to wait for a change to a global variable with read access
    //------------------------------------------------------------------------------

    task automatic do_wait_for_config_interface_type(  );
        begin
            axi4_interface_type_e _temp_config_interface_type;
            _temp_config_interface_type = config_interface_type;
            wait( _temp_config_interface_type != config_interface_type );
        end
    endtask

    task automatic do_wait_for_config_clk_init_value(  );
        begin
            bit _temp_config_clk_init_value;
            _temp_config_clk_init_value = config_clk_init_value;
            wait( _temp_config_clk_init_value != config_clk_init_value );
        end
    endtask

    task automatic do_wait_for_config_clk_phase_shift(  );
        begin
            longint unsigned _temp_config_clk_phase_shift;
            _temp_config_clk_phase_shift = config_clk_phase_shift;
            wait( _temp_config_clk_phase_shift != config_clk_phase_shift );
        end
    endtask

    task automatic do_wait_for_config_clk_1st_time(  );
        begin
            longint unsigned _temp_config_clk_1st_time;
            _temp_config_clk_1st_time = config_clk_1st_time;
            wait( _temp_config_clk_1st_time != config_clk_1st_time );
        end
    endtask

    task automatic do_wait_for_config_clk_2nd_time(  );
        begin
            longint unsigned _temp_config_clk_2nd_time;
            _temp_config_clk_2nd_time = config_clk_2nd_time;
            wait( _temp_config_clk_2nd_time != config_clk_2nd_time );
        end
    endtask

    task automatic do_wait_for_config_setup_time(  );
        begin
            longint unsigned _temp_config_setup_time;
            _temp_config_setup_time = config_setup_time;
            wait( _temp_config_setup_time != config_setup_time );
        end
    endtask

    task automatic do_wait_for_config_hold_time(  );
        begin
            longint unsigned _temp_config_hold_time;
            _temp_config_hold_time = config_hold_time;
            wait( _temp_config_hold_time != config_hold_time );
        end
    endtask

    task automatic do_wait_for_config_burst_timeout_factor(  );
        begin
            int unsigned _temp_config_burst_timeout_factor;
            _temp_config_burst_timeout_factor = config_burst_timeout_factor;
            wait( _temp_config_burst_timeout_factor != config_burst_timeout_factor );
        end
    endtask

    task automatic do_wait_for_config_max_transaction_time_factor(  );
        begin
            int unsigned _temp_config_max_transaction_time_factor;
            _temp_config_max_transaction_time_factor = config_max_transaction_time_factor;
            wait( _temp_config_max_transaction_time_factor != config_max_transaction_time_factor );
        end
    endtask

    task automatic do_wait_for_config_write_ctrl_first_ratio(  );
        begin
            int _temp_config_write_ctrl_first_ratio;
            _temp_config_write_ctrl_first_ratio = config_write_ctrl_first_ratio;
            wait( _temp_config_write_ctrl_first_ratio != config_write_ctrl_first_ratio );
        end
    endtask

    task automatic do_wait_for_config_write_data_first_ratio(  );
        begin
            int _temp_config_write_data_first_ratio;
            _temp_config_write_data_first_ratio = config_write_data_first_ratio;
            wait( _temp_config_write_data_first_ratio != config_write_data_first_ratio );
        end
    endtask

    task automatic do_wait_for_config_reset_low_clocks(  );
        begin
            int _temp_config_reset_low_clocks;
            _temp_config_reset_low_clocks = config_reset_low_clocks;
            wait( _temp_config_reset_low_clocks != config_reset_low_clocks );
        end
    endtask

    task automatic do_wait_for_config_reset_hold_time(  );
        begin
            int _temp_config_reset_hold_time;
            _temp_config_reset_hold_time = config_reset_hold_time;
            wait( _temp_config_reset_hold_time != config_reset_hold_time );
        end
    endtask

    task automatic do_wait_for_config_enable_rlast(  );
        begin
            bit _temp_config_enable_rlast;
            _temp_config_enable_rlast = config_enable_rlast;
            wait( _temp_config_enable_rlast != config_enable_rlast );
        end
    endtask

    task automatic do_wait_for_config_enable_slave_exclusive(  );
        begin
            bit _temp_config_enable_slave_exclusive;
            _temp_config_enable_slave_exclusive = config_enable_slave_exclusive;
            wait( _temp_config_enable_slave_exclusive != config_enable_slave_exclusive );
        end
    endtask

    task automatic do_wait_for_config_enable_burst_reserved_value(  );
        begin
            bit _temp_config_enable_burst_reserved_value;
            _temp_config_enable_burst_reserved_value = config_enable_burst_reserved_value;
            wait( _temp_config_enable_burst_reserved_value != config_enable_burst_reserved_value );
        end
    endtask

    task automatic do_wait_for_config_enable_cache_value(  );
        begin
            bit [15:0] _temp_config_enable_cache_value;
            _temp_config_enable_cache_value = config_enable_cache_value;
            wait( _temp_config_enable_cache_value != config_enable_cache_value );
        end
    endtask

    task automatic do_wait_for_config_enable_cache_value_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_enable_cache_value;
            _temp_config_enable_cache_value = config_enable_cache_value[_this_dot_1];
            wait( _temp_config_enable_cache_value != config_enable_cache_value[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_internal_dummy_variable(  );
        begin
            axi4_error_e _temp_internal_dummy_variable;
            _temp_internal_dummy_variable = internal_dummy_variable;
            wait( _temp_internal_dummy_variable != internal_dummy_variable );
        end
    endtask

    task automatic do_wait_for_config_axi4lite_interface(  );
        begin
            bit _temp_config_axi4lite_interface;
            _temp_config_axi4lite_interface = config_axi4lite_interface;
            wait( _temp_config_axi4lite_interface != config_axi4lite_interface );
        end
    endtask

    task automatic do_wait_for_config_axi4lite_tr_id(  );
        begin
            bit [((AXI4_ID_WIDTH) - 1):0]  _temp_config_axi4lite_tr_id;
            _temp_config_axi4lite_tr_id = config_axi4lite_tr_id;
            wait( _temp_config_axi4lite_tr_id != config_axi4lite_tr_id );
        end
    endtask

    task automatic do_wait_for_config_axi4lite_tr_id_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_axi4lite_tr_id;
            _temp_config_axi4lite_tr_id = config_axi4lite_tr_id[_this_dot_1];
            wait( _temp_config_axi4lite_tr_id != config_axi4lite_tr_id[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_enable_all_assertions(  );
        begin
            bit _temp_config_enable_all_assertions;
            _temp_config_enable_all_assertions = config_enable_all_assertions;
            wait( _temp_config_enable_all_assertions != config_enable_all_assertions );
        end
    endtask

    task automatic do_wait_for_config_enable_assertion(  );
        begin
            bit [255:0] _temp_config_enable_assertion;
            _temp_config_enable_assertion = config_enable_assertion;
            wait( _temp_config_enable_assertion != config_enable_assertion );
        end
    endtask

    task automatic do_wait_for_config_enable_assertion_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_enable_assertion;
            _temp_config_enable_assertion = config_enable_assertion[_this_dot_1];
            wait( _temp_config_enable_assertion != config_enable_assertion[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_enable_error(  );
        begin
            bit [255:0] _temp_config_enable_error;
            _temp_config_enable_error = config_enable_error;
            wait( _temp_config_enable_error != config_enable_error );
        end
    endtask

    task automatic do_wait_for_config_enable_error_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_enable_error;
            _temp_config_enable_error = config_enable_error[_this_dot_1];
            wait( _temp_config_enable_error != config_enable_error[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_max_latency_AWVALID_assertion_to_AWREADY(  );
        begin
            int unsigned _temp_config_max_latency_AWVALID_assertion_to_AWREADY;
            _temp_config_max_latency_AWVALID_assertion_to_AWREADY = config_max_latency_AWVALID_assertion_to_AWREADY;
            wait( _temp_config_max_latency_AWVALID_assertion_to_AWREADY != config_max_latency_AWVALID_assertion_to_AWREADY );
        end
    endtask

    task automatic do_wait_for_config_max_latency_ARVALID_assertion_to_ARREADY(  );
        begin
            int unsigned _temp_config_max_latency_ARVALID_assertion_to_ARREADY;
            _temp_config_max_latency_ARVALID_assertion_to_ARREADY = config_max_latency_ARVALID_assertion_to_ARREADY;
            wait( _temp_config_max_latency_ARVALID_assertion_to_ARREADY != config_max_latency_ARVALID_assertion_to_ARREADY );
        end
    endtask

    task automatic do_wait_for_config_max_latency_RVALID_assertion_to_RREADY(  );
        begin
            int unsigned _temp_config_max_latency_RVALID_assertion_to_RREADY;
            _temp_config_max_latency_RVALID_assertion_to_RREADY = config_max_latency_RVALID_assertion_to_RREADY;
            wait( _temp_config_max_latency_RVALID_assertion_to_RREADY != config_max_latency_RVALID_assertion_to_RREADY );
        end
    endtask

    task automatic do_wait_for_config_max_latency_BVALID_assertion_to_BREADY(  );
        begin
            int unsigned _temp_config_max_latency_BVALID_assertion_to_BREADY;
            _temp_config_max_latency_BVALID_assertion_to_BREADY = config_max_latency_BVALID_assertion_to_BREADY;
            wait( _temp_config_max_latency_BVALID_assertion_to_BREADY != config_max_latency_BVALID_assertion_to_BREADY );
        end
    endtask

    task automatic do_wait_for_config_max_latency_WVALID_assertion_to_WREADY(  );
        begin
            int unsigned _temp_config_max_latency_WVALID_assertion_to_WREADY;
            _temp_config_max_latency_WVALID_assertion_to_WREADY = config_max_latency_WVALID_assertion_to_WREADY;
            wait( _temp_config_max_latency_WVALID_assertion_to_WREADY != config_max_latency_WVALID_assertion_to_WREADY );
        end
    endtask

    task automatic do_wait_for_config_enable_qos(  );
        begin
            bit _temp_config_enable_qos;
            _temp_config_enable_qos = config_enable_qos;
            wait( _temp_config_enable_qos != config_enable_qos );
        end
    endtask

    task automatic do_wait_for_config_enable_region_support(  );
        begin
            bit _temp_config_enable_region_support;
            _temp_config_enable_region_support = config_enable_region_support;
            wait( _temp_config_enable_region_support != config_enable_region_support );
        end
    endtask

    task automatic do_wait_for_config_slave_regions(  );
        begin
            int _temp_config_slave_regions;
            _temp_config_slave_regions = config_slave_regions;
            wait( _temp_config_slave_regions != config_slave_regions );
        end
    endtask

    task automatic do_wait_for_config_region(  );
        begin
            bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  _temp_config_region;
            _temp_config_region = config_region;
            wait( _temp_config_region != config_region );
        end
    endtask

    task automatic do_wait_for_config_region_index1( input int _this_dot_1 );
        begin
            bit [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  _temp_config_region;
            _temp_config_region = config_region[_this_dot_1];
            wait( _temp_config_region != config_region[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_region_index2( input int _this_dot_1, input int _this_dot_2 );
        begin
            bit  _temp_config_region;
            _temp_config_region = config_region[_this_dot_1][_this_dot_2];
            wait( _temp_config_region != config_region[_this_dot_1][_this_dot_2] );
        end
    endtask

    task automatic do_wait_for_region_error_state(  );
        begin
            bit _temp_region_error_state;
            _temp_region_error_state = region_error_state;
            wait( _temp_region_error_state != region_error_state );
        end
    endtask

    task automatic do_wait_for_region_map_lb(  );
        begin
            longint unsigned _temp_region_map_lb [((AXI4_REGION_MAP_SIZE) - 1):0];
            _temp_region_map_lb = region_map_lb;
            wait( _temp_region_map_lb != region_map_lb );
        end
    endtask

    task automatic do_wait_for_region_map_lb_index1( input int _this_dot_1 );
        begin
            longint unsigned _temp_region_map_lb;
            _temp_region_map_lb = region_map_lb[_this_dot_1];
            wait( _temp_region_map_lb != region_map_lb[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_region_map_ub(  );
        begin
            longint unsigned _temp_region_map_ub [((AXI4_REGION_MAP_SIZE) - 1):0];
            _temp_region_map_ub = region_map_ub;
            wait( _temp_region_map_ub != region_map_ub );
        end
    endtask

    task automatic do_wait_for_region_map_ub_index1( input int _this_dot_1 );
        begin
            longint unsigned _temp_region_map_ub;
            _temp_region_map_ub = region_map_ub[_this_dot_1];
            wait( _temp_region_map_ub != region_map_ub[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_region_map_region(  );
        begin
            byte unsigned _temp_region_map_region [((AXI4_REGION_MAP_SIZE) - 1):0];
            _temp_region_map_region = region_map_region;
            wait( _temp_region_map_region != region_map_region );
        end
    endtask

    task automatic do_wait_for_region_map_region_index1( input int _this_dot_1 );
        begin
            byte unsigned _temp_region_map_region;
            _temp_region_map_region = region_map_region[_this_dot_1];
            wait( _temp_region_map_region != region_map_region[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_cacheable(  );
        begin
            byte unsigned _temp_cacheable [((AXI4_REGION_MAP_SIZE) - 1):0];
            _temp_cacheable = cacheable;
            wait( _temp_cacheable != cacheable );
        end
    endtask

    task automatic do_wait_for_cacheable_index1( input int _this_dot_1 );
        begin
            byte unsigned _temp_cacheable;
            _temp_cacheable = cacheable[_this_dot_1];
            wait( _temp_cacheable != cacheable[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_read_data_reordering_depth(  );
        begin
            int unsigned _temp_config_read_data_reordering_depth;
            _temp_config_read_data_reordering_depth = config_read_data_reordering_depth;
            wait( _temp_config_read_data_reordering_depth != config_read_data_reordering_depth );
        end
    endtask

    task automatic do_wait_for_config_slave_start_addr(  );
        begin
            bit [((AXI4_ADDRESS_WIDTH) - 1):0]  _temp_config_slave_start_addr;
            _temp_config_slave_start_addr = config_slave_start_addr;
            wait( _temp_config_slave_start_addr != config_slave_start_addr );
        end
    endtask

    task automatic do_wait_for_config_slave_start_addr_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_slave_start_addr;
            _temp_config_slave_start_addr = config_slave_start_addr[_this_dot_1];
            wait( _temp_config_slave_start_addr != config_slave_start_addr[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_slave_end_addr(  );
        begin
            bit [((AXI4_ADDRESS_WIDTH) - 1):0]  _temp_config_slave_end_addr;
            _temp_config_slave_end_addr = config_slave_end_addr;
            wait( _temp_config_slave_end_addr != config_slave_end_addr );
        end
    endtask

    task automatic do_wait_for_config_slave_end_addr_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_slave_end_addr;
            _temp_config_slave_end_addr = config_slave_end_addr[_this_dot_1];
            wait( _temp_config_slave_end_addr != config_slave_end_addr[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_slave_enabled_non_contiguous_address_spaces(  );
        begin
            int _temp_config_slave_enabled_non_contiguous_address_spaces;
            _temp_config_slave_enabled_non_contiguous_address_spaces = config_slave_enabled_non_contiguous_address_spaces;
            wait( _temp_config_slave_enabled_non_contiguous_address_spaces != config_slave_enabled_non_contiguous_address_spaces );
        end
    endtask

    task automatic do_wait_for_config_slave_possess_multiple_non_contiguous_address_spaces(  );
        begin
            bit _temp_config_slave_possess_multiple_non_contiguous_address_spaces;
            _temp_config_slave_possess_multiple_non_contiguous_address_spaces = config_slave_possess_multiple_non_contiguous_address_spaces;
            wait( _temp_config_slave_possess_multiple_non_contiguous_address_spaces != config_slave_possess_multiple_non_contiguous_address_spaces );
        end
    endtask

    task automatic do_wait_for_config_slave_multiple_non_contiguous_start_address_range(  );
        begin
            bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  _temp_config_slave_multiple_non_contiguous_start_address_range;
            _temp_config_slave_multiple_non_contiguous_start_address_range = config_slave_multiple_non_contiguous_start_address_range;
            wait( _temp_config_slave_multiple_non_contiguous_start_address_range != config_slave_multiple_non_contiguous_start_address_range );
        end
    endtask

    task automatic do_wait_for_config_slave_multiple_non_contiguous_start_address_range_index1( input int _this_dot_1 );
        begin
            bit [((AXI4_ADDRESS_WIDTH) - 1):0]  _temp_config_slave_multiple_non_contiguous_start_address_range;
            _temp_config_slave_multiple_non_contiguous_start_address_range = config_slave_multiple_non_contiguous_start_address_range[_this_dot_1];
            wait( _temp_config_slave_multiple_non_contiguous_start_address_range != config_slave_multiple_non_contiguous_start_address_range[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_slave_multiple_non_contiguous_start_address_range_index2( input int _this_dot_1, input int _this_dot_2 );
        begin
            bit  _temp_config_slave_multiple_non_contiguous_start_address_range;
            _temp_config_slave_multiple_non_contiguous_start_address_range = config_slave_multiple_non_contiguous_start_address_range[_this_dot_1][_this_dot_2];
            wait( _temp_config_slave_multiple_non_contiguous_start_address_range != config_slave_multiple_non_contiguous_start_address_range[_this_dot_1][_this_dot_2] );
        end
    endtask

    task automatic do_wait_for_config_slave_multiple_non_contiguous_end_address_range(  );
        begin
            bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  _temp_config_slave_multiple_non_contiguous_end_address_range;
            _temp_config_slave_multiple_non_contiguous_end_address_range = config_slave_multiple_non_contiguous_end_address_range;
            wait( _temp_config_slave_multiple_non_contiguous_end_address_range != config_slave_multiple_non_contiguous_end_address_range );
        end
    endtask

    task automatic do_wait_for_config_slave_multiple_non_contiguous_end_address_range_index1( input int _this_dot_1 );
        begin
            bit [((AXI4_ADDRESS_WIDTH) - 1):0]  _temp_config_slave_multiple_non_contiguous_end_address_range;
            _temp_config_slave_multiple_non_contiguous_end_address_range = config_slave_multiple_non_contiguous_end_address_range[_this_dot_1];
            wait( _temp_config_slave_multiple_non_contiguous_end_address_range != config_slave_multiple_non_contiguous_end_address_range[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_slave_multiple_non_contiguous_end_address_range_index2( input int _this_dot_1, input int _this_dot_2 );
        begin
            bit  _temp_config_slave_multiple_non_contiguous_end_address_range;
            _temp_config_slave_multiple_non_contiguous_end_address_range = config_slave_multiple_non_contiguous_end_address_range[_this_dot_1][_this_dot_2];
            wait( _temp_config_slave_multiple_non_contiguous_end_address_range != config_slave_multiple_non_contiguous_end_address_range[_this_dot_1][_this_dot_2] );
        end
    endtask

    task automatic do_wait_for_config_protect_ready(  );
        begin
            bit _temp_config_protect_ready;
            _temp_config_protect_ready = config_protect_ready;
            wait( _temp_config_protect_ready != config_protect_ready );
        end
    endtask

    task automatic do_wait_for_master_end_tlm_status(  );
        begin
            bit _temp_master_end_tlm_status;
            _temp_master_end_tlm_status = master_end_tlm_status;
            wait( _temp_master_end_tlm_status != master_end_tlm_status );
        end
    endtask

    task automatic do_wait_for_master_end_wlm_status(  );
        begin
            bit _temp_master_end_wlm_status;
            _temp_master_end_wlm_status = master_end_wlm_status;
            wait( _temp_master_end_wlm_status != master_end_wlm_status );
        end
    endtask

    task automatic do_wait_for_slave_end_tlm_status(  );
        begin
            bit _temp_slave_end_tlm_status;
            _temp_slave_end_tlm_status = slave_end_tlm_status;
            wait( _temp_slave_end_tlm_status != slave_end_tlm_status );
        end
    endtask

    task automatic do_wait_for_slave_end_wlm_status(  );
        begin
            bit _temp_slave_end_wlm_status;
            _temp_slave_end_wlm_status = slave_end_wlm_status;
            wait( _temp_slave_end_wlm_status != slave_end_wlm_status );
        end
    endtask

    task automatic do_wait_for_clock_source_end_tlm_status(  );
        begin
            bit _temp_clock_source_end_tlm_status;
            _temp_clock_source_end_tlm_status = clock_source_end_tlm_status;
            wait( _temp_clock_source_end_tlm_status != clock_source_end_tlm_status );
        end
    endtask

    task automatic do_wait_for_clock_source_end_wlm_status(  );
        begin
            bit _temp_clock_source_end_wlm_status;
            _temp_clock_source_end_wlm_status = clock_source_end_wlm_status;
            wait( _temp_clock_source_end_wlm_status != clock_source_end_wlm_status );
        end
    endtask

    task automatic do_wait_for_reset_source_end_tlm_status(  );
        begin
            bit _temp_reset_source_end_tlm_status;
            _temp_reset_source_end_tlm_status = reset_source_end_tlm_status;
            wait( _temp_reset_source_end_tlm_status != reset_source_end_tlm_status );
        end
    endtask

    task automatic do_wait_for_reset_source_end_wlm_status(  );
        begin
            bit _temp_reset_source_end_wlm_status;
            _temp_reset_source_end_wlm_status = reset_source_end_wlm_status;
            wait( _temp_reset_source_end_wlm_status != reset_source_end_wlm_status );
        end
    endtask

    task automatic do_wait_for_config_max_outstanding_wr(  );
        begin
            int _temp_config_max_outstanding_wr;
            _temp_config_max_outstanding_wr = config_max_outstanding_wr;
            wait( _temp_config_max_outstanding_wr != config_max_outstanding_wr );
        end
    endtask

    task automatic do_wait_for_config_max_outstanding_rd(  );
        begin
            int _temp_config_max_outstanding_rd;
            _temp_config_max_outstanding_rd = config_max_outstanding_rd;
            wait( _temp_config_max_outstanding_rd != config_max_outstanding_rd );
        end
    endtask

    task automatic do_wait_for_config_num_outstanding_wr_phase(  );
        begin
            int _temp_config_num_outstanding_wr_phase;
            _temp_config_num_outstanding_wr_phase = config_num_outstanding_wr_phase;
            wait( _temp_config_num_outstanding_wr_phase != config_num_outstanding_wr_phase );
        end
    endtask

    task automatic do_wait_for_config_num_outstanding_rd_phase(  );
        begin
            int _temp_config_num_outstanding_rd_phase;
            _temp_config_num_outstanding_rd_phase = config_num_outstanding_rd_phase;
            wait( _temp_config_num_outstanding_rd_phase != config_num_outstanding_rd_phase );
        end
    endtask

    task automatic do_wait_for_config_enable_warnings(  );
        begin
            bit _temp_config_enable_warnings;
            _temp_config_enable_warnings = config_enable_warnings;
            wait( _temp_config_enable_warnings != config_enable_warnings );
        end
    endtask

    task automatic do_wait_for_config_enable_errors(  );
        begin
            bit _temp_config_enable_errors;
            _temp_config_enable_errors = config_enable_errors;
            wait( _temp_config_enable_errors != config_enable_errors );
        end
    endtask

    task automatic do_wait_for_config_enable_exclusive_checks(  );
        begin
            bit _temp_config_enable_exclusive_checks;
            _temp_config_enable_exclusive_checks = config_enable_exclusive_checks;
            wait( _temp_config_enable_exclusive_checks != config_enable_exclusive_checks );
        end
    endtask

    task automatic do_wait_for_config_warn_on_slave_errors(  );
        begin
            bit _temp_config_warn_on_slave_errors;
            _temp_config_warn_on_slave_errors = config_warn_on_slave_errors;
            wait( _temp_config_warn_on_slave_errors != config_warn_on_slave_errors );
        end
    endtask

    task automatic do_wait_for_config_error_on_deleted_valid_cycles(  );
        begin
            bit _temp_config_error_on_deleted_valid_cycles;
            _temp_config_error_on_deleted_valid_cycles = config_error_on_deleted_valid_cycles;
            wait( _temp_config_error_on_deleted_valid_cycles != config_error_on_deleted_valid_cycles );
        end
    endtask

    task automatic do_wait_for_config_stats_enable(  );
        begin
            bit _temp_config_stats_enable;
            _temp_config_stats_enable = config_stats_enable;
            wait( _temp_config_stats_enable != config_stats_enable );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_occupancy(  );
        begin
            bit _temp_config_stats_enable_read_occupancy;
            _temp_config_stats_enable_read_occupancy = config_stats_enable_read_occupancy;
            wait( _temp_config_stats_enable_read_occupancy != config_stats_enable_read_occupancy );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_occupancy(  );
        begin
            bit _temp_config_stats_enable_write_occupancy;
            _temp_config_stats_enable_write_occupancy = config_stats_enable_write_occupancy;
            wait( _temp_config_stats_enable_write_occupancy != config_stats_enable_write_occupancy );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_data_occupancy(  );
        begin
            bit _temp_config_stats_enable_read_data_occupancy;
            _temp_config_stats_enable_read_data_occupancy = config_stats_enable_read_data_occupancy;
            wait( _temp_config_stats_enable_read_data_occupancy != config_stats_enable_read_data_occupancy );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_data_occupancy(  );
        begin
            bit _temp_config_stats_enable_write_data_occupancy;
            _temp_config_stats_enable_write_data_occupancy = config_stats_enable_write_data_occupancy;
            wait( _temp_config_stats_enable_write_data_occupancy != config_stats_enable_write_data_occupancy );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_latency(  );
        begin
            bit _temp_config_stats_enable_read_latency;
            _temp_config_stats_enable_read_latency = config_stats_enable_read_latency;
            wait( _temp_config_stats_enable_read_latency != config_stats_enable_read_latency );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_latency(  );
        begin
            bit _temp_config_stats_enable_write_latency;
            _temp_config_stats_enable_write_latency = config_stats_enable_write_latency;
            wait( _temp_config_stats_enable_write_latency != config_stats_enable_write_latency );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_address_waits(  );
        begin
            bit _temp_config_stats_enable_read_address_waits;
            _temp_config_stats_enable_read_address_waits = config_stats_enable_read_address_waits;
            wait( _temp_config_stats_enable_read_address_waits != config_stats_enable_read_address_waits );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_data_waits(  );
        begin
            bit _temp_config_stats_enable_read_data_waits;
            _temp_config_stats_enable_read_data_waits = config_stats_enable_read_data_waits;
            wait( _temp_config_stats_enable_read_data_waits != config_stats_enable_read_data_waits );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_address_waits(  );
        begin
            bit _temp_config_stats_enable_write_address_waits;
            _temp_config_stats_enable_write_address_waits = config_stats_enable_write_address_waits;
            wait( _temp_config_stats_enable_write_address_waits != config_stats_enable_write_address_waits );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_data_waits(  );
        begin
            bit _temp_config_stats_enable_write_data_waits;
            _temp_config_stats_enable_write_data_waits = config_stats_enable_write_data_waits;
            wait( _temp_config_stats_enable_write_data_waits != config_stats_enable_write_data_waits );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_response_waits(  );
        begin
            bit _temp_config_stats_enable_write_response_waits;
            _temp_config_stats_enable_write_response_waits = config_stats_enable_write_response_waits;
            wait( _temp_config_stats_enable_write_response_waits != config_stats_enable_write_response_waits );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_bandwidth(  );
        begin
            bit _temp_config_stats_enable_read_bandwidth;
            _temp_config_stats_enable_read_bandwidth = config_stats_enable_read_bandwidth;
            wait( _temp_config_stats_enable_read_bandwidth != config_stats_enable_read_bandwidth );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_bandwidth(  );
        begin
            bit _temp_config_stats_enable_write_bandwidth;
            _temp_config_stats_enable_write_bandwidth = config_stats_enable_write_bandwidth;
            wait( _temp_config_stats_enable_write_bandwidth != config_stats_enable_write_bandwidth );
        end
    endtask

    task automatic do_wait_for_stats_rw_transaction_last_duration(  );
        begin
            int _temp_stats_rw_transaction_last_duration;
            _temp_stats_rw_transaction_last_duration = stats_rw_transaction_last_duration;
            wait( _temp_stats_rw_transaction_last_duration != stats_rw_transaction_last_duration );
        end
    endtask

    task automatic do_wait_for_config_stats_read_occupancy_step(  );
        begin
            int _temp_config_stats_read_occupancy_step;
            _temp_config_stats_read_occupancy_step = config_stats_read_occupancy_step;
            wait( _temp_config_stats_read_occupancy_step != config_stats_read_occupancy_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_occupancy_multiple(  );
        begin
            int _temp_config_stats_read_occupancy_multiple;
            _temp_config_stats_read_occupancy_multiple = config_stats_read_occupancy_multiple;
            wait( _temp_config_stats_read_occupancy_multiple != config_stats_read_occupancy_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_active(  );
        begin
            bit _temp_stats_read_active;
            _temp_stats_read_active = stats_read_active;
            wait( _temp_stats_read_active != stats_read_active );
        end
    endtask

    task automatic do_wait_for_stats_read_occupancy_sw(  );
        begin
            int _temp_stats_read_occupancy_sw;
            _temp_stats_read_occupancy_sw = stats_read_occupancy_sw;
            wait( _temp_stats_read_occupancy_sw != stats_read_occupancy_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_idle_sw(  );
        begin
            int _temp_stats_read_idle_sw;
            _temp_stats_read_idle_sw = stats_read_idle_sw;
            wait( _temp_stats_read_idle_sw != stats_read_idle_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_occupancy_min(  );
        begin
            int _temp_stats_read_occupancy_min;
            _temp_stats_read_occupancy_min = stats_read_occupancy_min;
            wait( _temp_stats_read_occupancy_min != stats_read_occupancy_min );
        end
    endtask

    task automatic do_wait_for_stats_read_idle_min(  );
        begin
            int _temp_stats_read_idle_min;
            _temp_stats_read_idle_min = stats_read_idle_min;
            wait( _temp_stats_read_idle_min != stats_read_idle_min );
        end
    endtask

    task automatic do_wait_for_stats_read_occupancy_max(  );
        begin
            int _temp_stats_read_occupancy_max;
            _temp_stats_read_occupancy_max = stats_read_occupancy_max;
            wait( _temp_stats_read_occupancy_max != stats_read_occupancy_max );
        end
    endtask

    task automatic do_wait_for_stats_read_idle_max(  );
        begin
            int _temp_stats_read_idle_max;
            _temp_stats_read_idle_max = stats_read_idle_max;
            wait( _temp_stats_read_idle_max != stats_read_idle_max );
        end
    endtask

    task automatic do_wait_for_stats_read_occupancy_mean(  );
        begin
            int _temp_stats_read_occupancy_mean;
            _temp_stats_read_occupancy_mean = stats_read_occupancy_mean;
            wait( _temp_stats_read_occupancy_mean != stats_read_occupancy_mean );
        end
    endtask

    task automatic do_wait_for_stats_read_idle_mean(  );
        begin
            int _temp_stats_read_idle_mean;
            _temp_stats_read_idle_mean = stats_read_idle_mean;
            wait( _temp_stats_read_idle_mean != stats_read_idle_mean );
        end
    endtask

    task automatic do_wait_for_stats_read_last_duration(  );
        begin
            int _temp_stats_read_last_duration;
            _temp_stats_read_last_duration = stats_read_last_duration;
            wait( _temp_stats_read_last_duration != stats_read_last_duration );
        end
    endtask

    task automatic do_wait_for_config_stats_write_occupancy_step(  );
        begin
            int _temp_config_stats_write_occupancy_step;
            _temp_config_stats_write_occupancy_step = config_stats_write_occupancy_step;
            wait( _temp_config_stats_write_occupancy_step != config_stats_write_occupancy_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_occupancy_multiple(  );
        begin
            int _temp_config_stats_write_occupancy_multiple;
            _temp_config_stats_write_occupancy_multiple = config_stats_write_occupancy_multiple;
            wait( _temp_config_stats_write_occupancy_multiple != config_stats_write_occupancy_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_active(  );
        begin
            bit _temp_stats_write_active;
            _temp_stats_write_active = stats_write_active;
            wait( _temp_stats_write_active != stats_write_active );
        end
    endtask

    task automatic do_wait_for_stats_write_occupancy_sw(  );
        begin
            int _temp_stats_write_occupancy_sw;
            _temp_stats_write_occupancy_sw = stats_write_occupancy_sw;
            wait( _temp_stats_write_occupancy_sw != stats_write_occupancy_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_idle_sw(  );
        begin
            int _temp_stats_write_idle_sw;
            _temp_stats_write_idle_sw = stats_write_idle_sw;
            wait( _temp_stats_write_idle_sw != stats_write_idle_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_occupancy_min(  );
        begin
            int _temp_stats_write_occupancy_min;
            _temp_stats_write_occupancy_min = stats_write_occupancy_min;
            wait( _temp_stats_write_occupancy_min != stats_write_occupancy_min );
        end
    endtask

    task automatic do_wait_for_stats_write_idle_min(  );
        begin
            int _temp_stats_write_idle_min;
            _temp_stats_write_idle_min = stats_write_idle_min;
            wait( _temp_stats_write_idle_min != stats_write_idle_min );
        end
    endtask

    task automatic do_wait_for_stats_write_occupancy_max(  );
        begin
            int _temp_stats_write_occupancy_max;
            _temp_stats_write_occupancy_max = stats_write_occupancy_max;
            wait( _temp_stats_write_occupancy_max != stats_write_occupancy_max );
        end
    endtask

    task automatic do_wait_for_stats_write_idle_max(  );
        begin
            int _temp_stats_write_idle_max;
            _temp_stats_write_idle_max = stats_write_idle_max;
            wait( _temp_stats_write_idle_max != stats_write_idle_max );
        end
    endtask

    task automatic do_wait_for_stats_write_occupancy_mean(  );
        begin
            int _temp_stats_write_occupancy_mean;
            _temp_stats_write_occupancy_mean = stats_write_occupancy_mean;
            wait( _temp_stats_write_occupancy_mean != stats_write_occupancy_mean );
        end
    endtask

    task automatic do_wait_for_stats_write_idle_mean(  );
        begin
            int _temp_stats_write_idle_mean;
            _temp_stats_write_idle_mean = stats_write_idle_mean;
            wait( _temp_stats_write_idle_mean != stats_write_idle_mean );
        end
    endtask

    task automatic do_wait_for_stats_write_last_duration(  );
        begin
            int _temp_stats_write_last_duration;
            _temp_stats_write_last_duration = stats_write_last_duration;
            wait( _temp_stats_write_last_duration != stats_write_last_duration );
        end
    endtask

    task automatic do_wait_for_config_stats_read_data_occupancy_step(  );
        begin
            int _temp_config_stats_read_data_occupancy_step;
            _temp_config_stats_read_data_occupancy_step = config_stats_read_data_occupancy_step;
            wait( _temp_config_stats_read_data_occupancy_step != config_stats_read_data_occupancy_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_data_occupancy_multiple(  );
        begin
            int _temp_config_stats_read_data_occupancy_multiple;
            _temp_config_stats_read_data_occupancy_multiple = config_stats_read_data_occupancy_multiple;
            wait( _temp_config_stats_read_data_occupancy_multiple != config_stats_read_data_occupancy_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_data_occupancy_sw(  );
        begin
            int _temp_stats_read_data_occupancy_sw;
            _temp_stats_read_data_occupancy_sw = stats_read_data_occupancy_sw;
            wait( _temp_stats_read_data_occupancy_sw != stats_read_data_occupancy_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_data_idle_sw(  );
        begin
            int _temp_stats_read_data_idle_sw;
            _temp_stats_read_data_idle_sw = stats_read_data_idle_sw;
            wait( _temp_stats_read_data_idle_sw != stats_read_data_idle_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_data_occupancy_min(  );
        begin
            int _temp_stats_read_data_occupancy_min;
            _temp_stats_read_data_occupancy_min = stats_read_data_occupancy_min;
            wait( _temp_stats_read_data_occupancy_min != stats_read_data_occupancy_min );
        end
    endtask

    task automatic do_wait_for_stats_read_data_idle_min(  );
        begin
            int _temp_stats_read_data_idle_min;
            _temp_stats_read_data_idle_min = stats_read_data_idle_min;
            wait( _temp_stats_read_data_idle_min != stats_read_data_idle_min );
        end
    endtask

    task automatic do_wait_for_stats_read_data_occupancy_max(  );
        begin
            int _temp_stats_read_data_occupancy_max;
            _temp_stats_read_data_occupancy_max = stats_read_data_occupancy_max;
            wait( _temp_stats_read_data_occupancy_max != stats_read_data_occupancy_max );
        end
    endtask

    task automatic do_wait_for_stats_read_data_idle_max(  );
        begin
            int _temp_stats_read_data_idle_max;
            _temp_stats_read_data_idle_max = stats_read_data_idle_max;
            wait( _temp_stats_read_data_idle_max != stats_read_data_idle_max );
        end
    endtask

    task automatic do_wait_for_stats_read_data_occupancy_mean(  );
        begin
            int _temp_stats_read_data_occupancy_mean;
            _temp_stats_read_data_occupancy_mean = stats_read_data_occupancy_mean;
            wait( _temp_stats_read_data_occupancy_mean != stats_read_data_occupancy_mean );
        end
    endtask

    task automatic do_wait_for_stats_read_data_idle_mean(  );
        begin
            int _temp_stats_read_data_idle_mean;
            _temp_stats_read_data_idle_mean = stats_read_data_idle_mean;
            wait( _temp_stats_read_data_idle_mean != stats_read_data_idle_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_data_occupancy_step(  );
        begin
            int _temp_config_stats_write_data_occupancy_step;
            _temp_config_stats_write_data_occupancy_step = config_stats_write_data_occupancy_step;
            wait( _temp_config_stats_write_data_occupancy_step != config_stats_write_data_occupancy_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_data_occupancy_multiple(  );
        begin
            int _temp_config_stats_write_data_occupancy_multiple;
            _temp_config_stats_write_data_occupancy_multiple = config_stats_write_data_occupancy_multiple;
            wait( _temp_config_stats_write_data_occupancy_multiple != config_stats_write_data_occupancy_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_data_occupancy_sw(  );
        begin
            int _temp_stats_write_data_occupancy_sw;
            _temp_stats_write_data_occupancy_sw = stats_write_data_occupancy_sw;
            wait( _temp_stats_write_data_occupancy_sw != stats_write_data_occupancy_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_data_idle_sw(  );
        begin
            int _temp_stats_write_data_idle_sw;
            _temp_stats_write_data_idle_sw = stats_write_data_idle_sw;
            wait( _temp_stats_write_data_idle_sw != stats_write_data_idle_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_data_occupancy_min(  );
        begin
            int _temp_stats_write_data_occupancy_min;
            _temp_stats_write_data_occupancy_min = stats_write_data_occupancy_min;
            wait( _temp_stats_write_data_occupancy_min != stats_write_data_occupancy_min );
        end
    endtask

    task automatic do_wait_for_stats_write_data_idle_min(  );
        begin
            int _temp_stats_write_data_idle_min;
            _temp_stats_write_data_idle_min = stats_write_data_idle_min;
            wait( _temp_stats_write_data_idle_min != stats_write_data_idle_min );
        end
    endtask

    task automatic do_wait_for_stats_write_data_occupancy_max(  );
        begin
            int _temp_stats_write_data_occupancy_max;
            _temp_stats_write_data_occupancy_max = stats_write_data_occupancy_max;
            wait( _temp_stats_write_data_occupancy_max != stats_write_data_occupancy_max );
        end
    endtask

    task automatic do_wait_for_stats_write_data_idle_max(  );
        begin
            int _temp_stats_write_data_idle_max;
            _temp_stats_write_data_idle_max = stats_write_data_idle_max;
            wait( _temp_stats_write_data_idle_max != stats_write_data_idle_max );
        end
    endtask

    task automatic do_wait_for_stats_write_data_occupancy_mean(  );
        begin
            int _temp_stats_write_data_occupancy_mean;
            _temp_stats_write_data_occupancy_mean = stats_write_data_occupancy_mean;
            wait( _temp_stats_write_data_occupancy_mean != stats_write_data_occupancy_mean );
        end
    endtask

    task automatic do_wait_for_stats_write_data_idle_mean(  );
        begin
            int _temp_stats_write_data_idle_mean;
            _temp_stats_write_data_idle_mean = stats_write_data_idle_mean;
            wait( _temp_stats_write_data_idle_mean != stats_write_data_idle_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_read_bandwidth_step(  );
        begin
            int _temp_config_stats_read_bandwidth_step;
            _temp_config_stats_read_bandwidth_step = config_stats_read_bandwidth_step;
            wait( _temp_config_stats_read_bandwidth_step != config_stats_read_bandwidth_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_bandwidth_multiple(  );
        begin
            int _temp_config_stats_read_bandwidth_multiple;
            _temp_config_stats_read_bandwidth_multiple = config_stats_read_bandwidth_multiple;
            wait( _temp_config_stats_read_bandwidth_multiple != config_stats_read_bandwidth_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_bandwidth_sw(  );
        begin
            int _temp_stats_read_bandwidth_sw;
            _temp_stats_read_bandwidth_sw = stats_read_bandwidth_sw;
            wait( _temp_stats_read_bandwidth_sw != stats_read_bandwidth_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_bandwidth_min(  );
        begin
            int _temp_stats_read_bandwidth_min;
            _temp_stats_read_bandwidth_min = stats_read_bandwidth_min;
            wait( _temp_stats_read_bandwidth_min != stats_read_bandwidth_min );
        end
    endtask

    task automatic do_wait_for_stats_read_bandwidth_max(  );
        begin
            int _temp_stats_read_bandwidth_max;
            _temp_stats_read_bandwidth_max = stats_read_bandwidth_max;
            wait( _temp_stats_read_bandwidth_max != stats_read_bandwidth_max );
        end
    endtask

    task automatic do_wait_for_stats_read_bandwidth_mean(  );
        begin
            int _temp_stats_read_bandwidth_mean;
            _temp_stats_read_bandwidth_mean = stats_read_bandwidth_mean;
            wait( _temp_stats_read_bandwidth_mean != stats_read_bandwidth_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_bandwidth_step(  );
        begin
            int _temp_config_stats_write_bandwidth_step;
            _temp_config_stats_write_bandwidth_step = config_stats_write_bandwidth_step;
            wait( _temp_config_stats_write_bandwidth_step != config_stats_write_bandwidth_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_bandwidth_multiple(  );
        begin
            int _temp_config_stats_write_bandwidth_multiple;
            _temp_config_stats_write_bandwidth_multiple = config_stats_write_bandwidth_multiple;
            wait( _temp_config_stats_write_bandwidth_multiple != config_stats_write_bandwidth_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_bandwidth_sw(  );
        begin
            int _temp_stats_write_bandwidth_sw;
            _temp_stats_write_bandwidth_sw = stats_write_bandwidth_sw;
            wait( _temp_stats_write_bandwidth_sw != stats_write_bandwidth_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_bandwidth_min(  );
        begin
            int _temp_stats_write_bandwidth_min;
            _temp_stats_write_bandwidth_min = stats_write_bandwidth_min;
            wait( _temp_stats_write_bandwidth_min != stats_write_bandwidth_min );
        end
    endtask

    task automatic do_wait_for_stats_write_bandwidth_max(  );
        begin
            int _temp_stats_write_bandwidth_max;
            _temp_stats_write_bandwidth_max = stats_write_bandwidth_max;
            wait( _temp_stats_write_bandwidth_max != stats_write_bandwidth_max );
        end
    endtask

    task automatic do_wait_for_stats_write_bandwidth_mean(  );
        begin
            int _temp_stats_write_bandwidth_mean;
            _temp_stats_write_bandwidth_mean = stats_write_bandwidth_mean;
            wait( _temp_stats_write_bandwidth_mean != stats_write_bandwidth_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_read_latency_step(  );
        begin
            int _temp_config_stats_read_latency_step;
            _temp_config_stats_read_latency_step = config_stats_read_latency_step;
            wait( _temp_config_stats_read_latency_step != config_stats_read_latency_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_latency_multiple(  );
        begin
            int _temp_config_stats_read_latency_multiple;
            _temp_config_stats_read_latency_multiple = config_stats_read_latency_multiple;
            wait( _temp_config_stats_read_latency_multiple != config_stats_read_latency_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_address_data_latency_inst(  );
        begin
            int _temp_stats_read_address_data_latency_inst;
            _temp_stats_read_address_data_latency_inst = stats_read_address_data_latency_inst;
            wait( _temp_stats_read_address_data_latency_inst != stats_read_address_data_latency_inst );
        end
    endtask

    task automatic do_wait_for_stats_read_address_data_latency_sw(  );
        begin
            int _temp_stats_read_address_data_latency_sw;
            _temp_stats_read_address_data_latency_sw = stats_read_address_data_latency_sw;
            wait( _temp_stats_read_address_data_latency_sw != stats_read_address_data_latency_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_address_data_latency_min(  );
        begin
            int _temp_stats_read_address_data_latency_min;
            _temp_stats_read_address_data_latency_min = stats_read_address_data_latency_min;
            wait( _temp_stats_read_address_data_latency_min != stats_read_address_data_latency_min );
        end
    endtask

    task automatic do_wait_for_stats_read_address_data_latency_max(  );
        begin
            int _temp_stats_read_address_data_latency_max;
            _temp_stats_read_address_data_latency_max = stats_read_address_data_latency_max;
            wait( _temp_stats_read_address_data_latency_max != stats_read_address_data_latency_max );
        end
    endtask

    task automatic do_wait_for_stats_read_address_data_latency_mean(  );
        begin
            int _temp_stats_read_address_data_latency_mean;
            _temp_stats_read_address_data_latency_mean = stats_read_address_data_latency_mean;
            wait( _temp_stats_read_address_data_latency_mean != stats_read_address_data_latency_mean );
        end
    endtask

    task automatic do_wait_for_stats_read_address_address_latency_inst(  );
        begin
            int _temp_stats_read_address_address_latency_inst;
            _temp_stats_read_address_address_latency_inst = stats_read_address_address_latency_inst;
            wait( _temp_stats_read_address_address_latency_inst != stats_read_address_address_latency_inst );
        end
    endtask

    task automatic do_wait_for_stats_read_address_address_latency_sw(  );
        begin
            int _temp_stats_read_address_address_latency_sw;
            _temp_stats_read_address_address_latency_sw = stats_read_address_address_latency_sw;
            wait( _temp_stats_read_address_address_latency_sw != stats_read_address_address_latency_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_address_address_latency_min(  );
        begin
            int _temp_stats_read_address_address_latency_min;
            _temp_stats_read_address_address_latency_min = stats_read_address_address_latency_min;
            wait( _temp_stats_read_address_address_latency_min != stats_read_address_address_latency_min );
        end
    endtask

    task automatic do_wait_for_stats_read_address_address_latency_max(  );
        begin
            int _temp_stats_read_address_address_latency_max;
            _temp_stats_read_address_address_latency_max = stats_read_address_address_latency_max;
            wait( _temp_stats_read_address_address_latency_max != stats_read_address_address_latency_max );
        end
    endtask

    task automatic do_wait_for_stats_read_address_address_latency_mean(  );
        begin
            int _temp_stats_read_address_address_latency_mean;
            _temp_stats_read_address_address_latency_mean = stats_read_address_address_latency_mean;
            wait( _temp_stats_read_address_address_latency_mean != stats_read_address_address_latency_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_latency_step(  );
        begin
            int _temp_config_stats_write_latency_step;
            _temp_config_stats_write_latency_step = config_stats_write_latency_step;
            wait( _temp_config_stats_write_latency_step != config_stats_write_latency_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_latency_multiple(  );
        begin
            int _temp_config_stats_write_latency_multiple;
            _temp_config_stats_write_latency_multiple = config_stats_write_latency_multiple;
            wait( _temp_config_stats_write_latency_multiple != config_stats_write_latency_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_address_response_latency_inst(  );
        begin
            int _temp_stats_write_address_response_latency_inst;
            _temp_stats_write_address_response_latency_inst = stats_write_address_response_latency_inst;
            wait( _temp_stats_write_address_response_latency_inst != stats_write_address_response_latency_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_address_response_latency_sw(  );
        begin
            int _temp_stats_write_address_response_latency_sw;
            _temp_stats_write_address_response_latency_sw = stats_write_address_response_latency_sw;
            wait( _temp_stats_write_address_response_latency_sw != stats_write_address_response_latency_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_address_response_latency_min(  );
        begin
            int _temp_stats_write_address_response_latency_min;
            _temp_stats_write_address_response_latency_min = stats_write_address_response_latency_min;
            wait( _temp_stats_write_address_response_latency_min != stats_write_address_response_latency_min );
        end
    endtask

    task automatic do_wait_for_stats_write_address_response_latency_max(  );
        begin
            int _temp_stats_write_address_response_latency_max;
            _temp_stats_write_address_response_latency_max = stats_write_address_response_latency_max;
            wait( _temp_stats_write_address_response_latency_max != stats_write_address_response_latency_max );
        end
    endtask

    task automatic do_wait_for_stats_write_address_response_latency_mean(  );
        begin
            int _temp_stats_write_address_response_latency_mean;
            _temp_stats_write_address_response_latency_mean = stats_write_address_response_latency_mean;
            wait( _temp_stats_write_address_response_latency_mean != stats_write_address_response_latency_mean );
        end
    endtask

    task automatic do_wait_for_stats_write_address_address_latency_inst(  );
        begin
            int _temp_stats_write_address_address_latency_inst;
            _temp_stats_write_address_address_latency_inst = stats_write_address_address_latency_inst;
            wait( _temp_stats_write_address_address_latency_inst != stats_write_address_address_latency_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_address_address_latency_sw(  );
        begin
            int _temp_stats_write_address_address_latency_sw;
            _temp_stats_write_address_address_latency_sw = stats_write_address_address_latency_sw;
            wait( _temp_stats_write_address_address_latency_sw != stats_write_address_address_latency_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_address_address_latency_min(  );
        begin
            int _temp_stats_write_address_address_latency_min;
            _temp_stats_write_address_address_latency_min = stats_write_address_address_latency_min;
            wait( _temp_stats_write_address_address_latency_min != stats_write_address_address_latency_min );
        end
    endtask

    task automatic do_wait_for_stats_write_address_address_latency_max(  );
        begin
            int _temp_stats_write_address_address_latency_max;
            _temp_stats_write_address_address_latency_max = stats_write_address_address_latency_max;
            wait( _temp_stats_write_address_address_latency_max != stats_write_address_address_latency_max );
        end
    endtask

    task automatic do_wait_for_stats_write_address_address_latency_mean(  );
        begin
            int _temp_stats_write_address_address_latency_mean;
            _temp_stats_write_address_address_latency_mean = stats_write_address_address_latency_mean;
            wait( _temp_stats_write_address_address_latency_mean != stats_write_address_address_latency_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_read_address_waits_step(  );
        begin
            int _temp_config_stats_read_address_waits_step;
            _temp_config_stats_read_address_waits_step = config_stats_read_address_waits_step;
            wait( _temp_config_stats_read_address_waits_step != config_stats_read_address_waits_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_address_waits_multiple(  );
        begin
            int _temp_config_stats_read_address_waits_multiple;
            _temp_config_stats_read_address_waits_multiple = config_stats_read_address_waits_multiple;
            wait( _temp_config_stats_read_address_waits_multiple != config_stats_read_address_waits_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_inst(  );
        begin
            int _temp_stats_read_address_waits_inst;
            _temp_stats_read_address_waits_inst = stats_read_address_waits_inst;
            wait( _temp_stats_read_address_waits_inst != stats_read_address_waits_inst );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_sw(  );
        begin
            int _temp_stats_read_address_waits_sw;
            _temp_stats_read_address_waits_sw = stats_read_address_waits_sw;
            wait( _temp_stats_read_address_waits_sw != stats_read_address_waits_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_min(  );
        begin
            int _temp_stats_read_address_waits_min;
            _temp_stats_read_address_waits_min = stats_read_address_waits_min;
            wait( _temp_stats_read_address_waits_min != stats_read_address_waits_min );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_max(  );
        begin
            int _temp_stats_read_address_waits_max;
            _temp_stats_read_address_waits_max = stats_read_address_waits_max;
            wait( _temp_stats_read_address_waits_max != stats_read_address_waits_max );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_mean(  );
        begin
            int _temp_stats_read_address_waits_mean;
            _temp_stats_read_address_waits_mean = stats_read_address_waits_mean;
            wait( _temp_stats_read_address_waits_mean != stats_read_address_waits_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_read_data_waits_step(  );
        begin
            int _temp_config_stats_read_data_waits_step;
            _temp_config_stats_read_data_waits_step = config_stats_read_data_waits_step;
            wait( _temp_config_stats_read_data_waits_step != config_stats_read_data_waits_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_data_waits_multiple(  );
        begin
            int _temp_config_stats_read_data_waits_multiple;
            _temp_config_stats_read_data_waits_multiple = config_stats_read_data_waits_multiple;
            wait( _temp_config_stats_read_data_waits_multiple != config_stats_read_data_waits_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_inst(  );
        begin
            int _temp_stats_read_data_waits_inst;
            _temp_stats_read_data_waits_inst = stats_read_data_waits_inst;
            wait( _temp_stats_read_data_waits_inst != stats_read_data_waits_inst );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_sw(  );
        begin
            int _temp_stats_read_data_waits_sw;
            _temp_stats_read_data_waits_sw = stats_read_data_waits_sw;
            wait( _temp_stats_read_data_waits_sw != stats_read_data_waits_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_min(  );
        begin
            int _temp_stats_read_data_waits_min;
            _temp_stats_read_data_waits_min = stats_read_data_waits_min;
            wait( _temp_stats_read_data_waits_min != stats_read_data_waits_min );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_max(  );
        begin
            int _temp_stats_read_data_waits_max;
            _temp_stats_read_data_waits_max = stats_read_data_waits_max;
            wait( _temp_stats_read_data_waits_max != stats_read_data_waits_max );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_mean(  );
        begin
            int _temp_stats_read_data_waits_mean;
            _temp_stats_read_data_waits_mean = stats_read_data_waits_mean;
            wait( _temp_stats_read_data_waits_mean != stats_read_data_waits_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_address_waits_step(  );
        begin
            int _temp_config_stats_write_address_waits_step;
            _temp_config_stats_write_address_waits_step = config_stats_write_address_waits_step;
            wait( _temp_config_stats_write_address_waits_step != config_stats_write_address_waits_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_address_waits_multiple(  );
        begin
            int _temp_config_stats_write_address_waits_multiple;
            _temp_config_stats_write_address_waits_multiple = config_stats_write_address_waits_multiple;
            wait( _temp_config_stats_write_address_waits_multiple != config_stats_write_address_waits_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_inst(  );
        begin
            int _temp_stats_write_address_waits_inst;
            _temp_stats_write_address_waits_inst = stats_write_address_waits_inst;
            wait( _temp_stats_write_address_waits_inst != stats_write_address_waits_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_sw(  );
        begin
            int _temp_stats_write_address_waits_sw;
            _temp_stats_write_address_waits_sw = stats_write_address_waits_sw;
            wait( _temp_stats_write_address_waits_sw != stats_write_address_waits_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_min(  );
        begin
            int _temp_stats_write_address_waits_min;
            _temp_stats_write_address_waits_min = stats_write_address_waits_min;
            wait( _temp_stats_write_address_waits_min != stats_write_address_waits_min );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_max(  );
        begin
            int _temp_stats_write_address_waits_max;
            _temp_stats_write_address_waits_max = stats_write_address_waits_max;
            wait( _temp_stats_write_address_waits_max != stats_write_address_waits_max );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_mean(  );
        begin
            int _temp_stats_write_address_waits_mean;
            _temp_stats_write_address_waits_mean = stats_write_address_waits_mean;
            wait( _temp_stats_write_address_waits_mean != stats_write_address_waits_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_data_waits_step(  );
        begin
            int _temp_config_stats_write_data_waits_step;
            _temp_config_stats_write_data_waits_step = config_stats_write_data_waits_step;
            wait( _temp_config_stats_write_data_waits_step != config_stats_write_data_waits_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_data_waits_multiple(  );
        begin
            int _temp_config_stats_write_data_waits_multiple;
            _temp_config_stats_write_data_waits_multiple = config_stats_write_data_waits_multiple;
            wait( _temp_config_stats_write_data_waits_multiple != config_stats_write_data_waits_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_inst(  );
        begin
            int _temp_stats_write_data_waits_inst;
            _temp_stats_write_data_waits_inst = stats_write_data_waits_inst;
            wait( _temp_stats_write_data_waits_inst != stats_write_data_waits_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_sw(  );
        begin
            int _temp_stats_write_data_waits_sw;
            _temp_stats_write_data_waits_sw = stats_write_data_waits_sw;
            wait( _temp_stats_write_data_waits_sw != stats_write_data_waits_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_min(  );
        begin
            int _temp_stats_write_data_waits_min;
            _temp_stats_write_data_waits_min = stats_write_data_waits_min;
            wait( _temp_stats_write_data_waits_min != stats_write_data_waits_min );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_max(  );
        begin
            int _temp_stats_write_data_waits_max;
            _temp_stats_write_data_waits_max = stats_write_data_waits_max;
            wait( _temp_stats_write_data_waits_max != stats_write_data_waits_max );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_mean(  );
        begin
            int _temp_stats_write_data_waits_mean;
            _temp_stats_write_data_waits_mean = stats_write_data_waits_mean;
            wait( _temp_stats_write_data_waits_mean != stats_write_data_waits_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_response_waits_step(  );
        begin
            int _temp_config_stats_write_response_waits_step;
            _temp_config_stats_write_response_waits_step = config_stats_write_response_waits_step;
            wait( _temp_config_stats_write_response_waits_step != config_stats_write_response_waits_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_response_waits_multiple(  );
        begin
            int _temp_config_stats_write_response_waits_multiple;
            _temp_config_stats_write_response_waits_multiple = config_stats_write_response_waits_multiple;
            wait( _temp_config_stats_write_response_waits_multiple != config_stats_write_response_waits_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_inst(  );
        begin
            int _temp_stats_write_response_waits_inst;
            _temp_stats_write_response_waits_inst = stats_write_response_waits_inst;
            wait( _temp_stats_write_response_waits_inst != stats_write_response_waits_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_sw(  );
        begin
            int _temp_stats_write_response_waits_sw;
            _temp_stats_write_response_waits_sw = stats_write_response_waits_sw;
            wait( _temp_stats_write_response_waits_sw != stats_write_response_waits_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_min(  );
        begin
            int _temp_stats_write_response_waits_min;
            _temp_stats_write_response_waits_min = stats_write_response_waits_min;
            wait( _temp_stats_write_response_waits_min != stats_write_response_waits_min );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_max(  );
        begin
            int _temp_stats_write_response_waits_max;
            _temp_stats_write_response_waits_max = stats_write_response_waits_max;
            wait( _temp_stats_write_response_waits_max != stats_write_response_waits_max );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_mean(  );
        begin
            int _temp_stats_write_response_waits_mean;
            _temp_stats_write_response_waits_mean = stats_write_response_waits_mean;
            wait( _temp_stats_write_response_waits_mean != stats_write_response_waits_mean );
        end
    endtask

    task automatic do_wait_for_reordering_depth_of_last_read_transaction(  );
        begin
            int _temp_reordering_depth_of_last_read_transaction;
            _temp_reordering_depth_of_last_read_transaction = reordering_depth_of_last_read_transaction;
            wait( _temp_reordering_depth_of_last_read_transaction != reordering_depth_of_last_read_transaction );
        end
    endtask


    //------------------------------------------------------------------------------
    // Functions to set global variables with write access
    //------------------------------------------------------------------------------

    function automatic void do_set_config_interface_type( axi4_interface_type_e config_interface_type_param );
        config_interface_type = config_interface_type_param;
    endfunction

    function automatic void do_set_config_clk_init_value( bit config_clk_init_value_param );
        config_clk_init_value = config_clk_init_value_param;
    endfunction

    function automatic void do_set_config_clk_phase_shift( longint unsigned config_clk_phase_shift_param );
        config_clk_phase_shift = config_clk_phase_shift_param;
    endfunction

    function automatic void do_set_config_clk_1st_time( longint unsigned config_clk_1st_time_param );
        config_clk_1st_time = config_clk_1st_time_param;
    endfunction

    function automatic void do_set_config_clk_2nd_time( longint unsigned config_clk_2nd_time_param );
        config_clk_2nd_time = config_clk_2nd_time_param;
    endfunction

    function automatic void do_set_config_setup_time( longint unsigned config_setup_time_param );
        config_setup_time = config_setup_time_param;
    endfunction

    function automatic void do_set_config_hold_time( longint unsigned config_hold_time_param );
        config_hold_time = config_hold_time_param;
    endfunction

    function automatic void do_set_config_burst_timeout_factor( int unsigned config_burst_timeout_factor_param );
        config_burst_timeout_factor = config_burst_timeout_factor_param;
    endfunction

    function automatic void do_set_config_max_transaction_time_factor( int unsigned config_max_transaction_time_factor_param );
        config_max_transaction_time_factor = config_max_transaction_time_factor_param;
    endfunction

    function automatic void do_set_config_write_ctrl_first_ratio( int config_write_ctrl_first_ratio_param );
        config_write_ctrl_first_ratio = config_write_ctrl_first_ratio_param;
    endfunction

    function automatic void do_set_config_write_data_first_ratio( int config_write_data_first_ratio_param );
        config_write_data_first_ratio = config_write_data_first_ratio_param;
    endfunction

    function automatic void do_set_config_reset_low_clocks( int config_reset_low_clocks_param );
        config_reset_low_clocks = config_reset_low_clocks_param;
    endfunction

    function automatic void do_set_config_reset_hold_time( int config_reset_hold_time_param );
        config_reset_hold_time = config_reset_hold_time_param;
    endfunction

    function automatic void do_set_config_enable_rlast( bit config_enable_rlast_param );
        config_enable_rlast = config_enable_rlast_param;
    endfunction

    function automatic void do_set_config_enable_slave_exclusive( bit config_enable_slave_exclusive_param );
        config_enable_slave_exclusive = config_enable_slave_exclusive_param;
    endfunction

    function automatic void do_set_config_enable_burst_reserved_value( bit config_enable_burst_reserved_value_param );
        config_enable_burst_reserved_value = config_enable_burst_reserved_value_param;
    endfunction

    function automatic void do_set_config_enable_cache_value( bit [15:0] config_enable_cache_value_param );
        config_enable_cache_value = config_enable_cache_value_param;
    endfunction

    function automatic void do_set_config_enable_cache_value_index1( int _this_dot_1, bit  config_enable_cache_value_param );
        config_enable_cache_value[_this_dot_1] = config_enable_cache_value_param;
    endfunction

    function automatic void do_set_internal_dummy_variable( axi4_error_e internal_dummy_variable_param );
        internal_dummy_variable = internal_dummy_variable_param;
    endfunction

    function automatic void do_set_config_axi4lite_interface( bit config_axi4lite_interface_param );
        config_axi4lite_interface = config_axi4lite_interface_param;
    endfunction

    function automatic void do_set_config_axi4lite_tr_id( bit [((AXI4_ID_WIDTH) - 1):0]  config_axi4lite_tr_id_param );
        config_axi4lite_tr_id = config_axi4lite_tr_id_param;
    endfunction

    function automatic void do_set_config_axi4lite_tr_id_index1( int _this_dot_1, bit  config_axi4lite_tr_id_param );
        config_axi4lite_tr_id[_this_dot_1] = config_axi4lite_tr_id_param;
    endfunction

    function automatic void do_set_config_enable_all_assertions( bit config_enable_all_assertions_param );
        config_enable_all_assertions = config_enable_all_assertions_param;
    endfunction

    function automatic void do_set_config_enable_assertion( bit [255:0] config_enable_assertion_param );
        config_enable_assertion = config_enable_assertion_param;
    endfunction

    function automatic void do_set_config_enable_assertion_index1( int _this_dot_1, bit  config_enable_assertion_param );
        config_enable_assertion[_this_dot_1] = config_enable_assertion_param;
    endfunction

    function automatic void do_set_config_enable_error( bit [255:0] config_enable_error_param );
        config_enable_error = config_enable_error_param;
    endfunction

    function automatic void do_set_config_enable_error_index1( int _this_dot_1, bit  config_enable_error_param );
        config_enable_error[_this_dot_1] = config_enable_error_param;
    endfunction

    function automatic void do_set_config_max_latency_AWVALID_assertion_to_AWREADY( int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
        config_max_latency_AWVALID_assertion_to_AWREADY = config_max_latency_AWVALID_assertion_to_AWREADY_param;
    endfunction

    function automatic void do_set_config_max_latency_ARVALID_assertion_to_ARREADY( int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
        config_max_latency_ARVALID_assertion_to_ARREADY = config_max_latency_ARVALID_assertion_to_ARREADY_param;
    endfunction

    function automatic void do_set_config_max_latency_RVALID_assertion_to_RREADY( int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
        config_max_latency_RVALID_assertion_to_RREADY = config_max_latency_RVALID_assertion_to_RREADY_param;
    endfunction

    function automatic void do_set_config_max_latency_BVALID_assertion_to_BREADY( int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
        config_max_latency_BVALID_assertion_to_BREADY = config_max_latency_BVALID_assertion_to_BREADY_param;
    endfunction

    function automatic void do_set_config_max_latency_WVALID_assertion_to_WREADY( int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
        config_max_latency_WVALID_assertion_to_WREADY = config_max_latency_WVALID_assertion_to_WREADY_param;
    endfunction

    function automatic void do_set_config_enable_qos( bit config_enable_qos_param );
        config_enable_qos = config_enable_qos_param;
    endfunction

    function automatic void do_set_config_enable_region_support( bit config_enable_region_support_param );
        config_enable_region_support = config_enable_region_support_param;
    endfunction

    function automatic void do_set_config_slave_regions( int config_slave_regions_param );
        config_slave_regions = config_slave_regions_param;
    endfunction

    function automatic void do_set_config_region( bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  config_region_param );
        config_region = config_region_param;
    endfunction

    function automatic void do_set_config_region_index1( int _this_dot_1, bit [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  config_region_param );
        config_region[_this_dot_1] = config_region_param;
    endfunction

    function automatic void do_set_config_region_index2( int _this_dot_1, int _this_dot_2, bit  config_region_param );
        config_region[_this_dot_1][_this_dot_2] = config_region_param;
    endfunction

    function automatic void do_set_config_read_data_reordering_depth( int unsigned config_read_data_reordering_depth_param );
        config_read_data_reordering_depth = config_read_data_reordering_depth_param;
    endfunction

    function automatic void do_set_config_slave_start_addr( bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param );
        config_slave_start_addr = config_slave_start_addr_param;
    endfunction

    function automatic void do_set_config_slave_start_addr_index1( int _this_dot_1, bit  config_slave_start_addr_param );
        config_slave_start_addr[_this_dot_1] = config_slave_start_addr_param;
    endfunction

    function automatic void do_set_config_slave_end_addr( bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param );
        config_slave_end_addr = config_slave_end_addr_param;
    endfunction

    function automatic void do_set_config_slave_end_addr_index1( int _this_dot_1, bit  config_slave_end_addr_param );
        config_slave_end_addr[_this_dot_1] = config_slave_end_addr_param;
    endfunction

    function automatic void do_set_config_slave_enabled_non_contiguous_address_spaces( int config_slave_enabled_non_contiguous_address_spaces_param );
        config_slave_enabled_non_contiguous_address_spaces = config_slave_enabled_non_contiguous_address_spaces_param;
    endfunction

    function automatic void do_set_config_slave_possess_multiple_non_contiguous_address_spaces( bit config_slave_possess_multiple_non_contiguous_address_spaces_param );
        config_slave_possess_multiple_non_contiguous_address_spaces = config_slave_possess_multiple_non_contiguous_address_spaces_param;
    endfunction

    function automatic void do_set_config_slave_multiple_non_contiguous_start_address_range( bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_start_address_range_param );
        config_slave_multiple_non_contiguous_start_address_range = config_slave_multiple_non_contiguous_start_address_range_param;
    endfunction

    function automatic void do_set_config_slave_multiple_non_contiguous_start_address_range_index1( int _this_dot_1, bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_start_address_range_param );
        config_slave_multiple_non_contiguous_start_address_range[_this_dot_1] = config_slave_multiple_non_contiguous_start_address_range_param;
    endfunction

    function automatic void do_set_config_slave_multiple_non_contiguous_start_address_range_index2( int _this_dot_1, int _this_dot_2, bit  config_slave_multiple_non_contiguous_start_address_range_param );
        config_slave_multiple_non_contiguous_start_address_range[_this_dot_1][_this_dot_2] = config_slave_multiple_non_contiguous_start_address_range_param;
    endfunction

    function automatic void do_set_config_slave_multiple_non_contiguous_end_address_range( bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_end_address_range_param );
        config_slave_multiple_non_contiguous_end_address_range = config_slave_multiple_non_contiguous_end_address_range_param;
    endfunction

    function automatic void do_set_config_slave_multiple_non_contiguous_end_address_range_index1( int _this_dot_1, bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_end_address_range_param );
        config_slave_multiple_non_contiguous_end_address_range[_this_dot_1] = config_slave_multiple_non_contiguous_end_address_range_param;
    endfunction

    function automatic void do_set_config_slave_multiple_non_contiguous_end_address_range_index2( int _this_dot_1, int _this_dot_2, bit  config_slave_multiple_non_contiguous_end_address_range_param );
        config_slave_multiple_non_contiguous_end_address_range[_this_dot_1][_this_dot_2] = config_slave_multiple_non_contiguous_end_address_range_param;
    endfunction

    function automatic void do_set_config_protect_ready( bit config_protect_ready_param );
        config_protect_ready = config_protect_ready_param;
    endfunction

    function automatic void do_set_config_max_outstanding_wr( int config_max_outstanding_wr_param );
        config_max_outstanding_wr = config_max_outstanding_wr_param;
    endfunction

    function automatic void do_set_config_max_outstanding_rd( int config_max_outstanding_rd_param );
        config_max_outstanding_rd = config_max_outstanding_rd_param;
    endfunction

    function automatic void do_set_config_num_outstanding_wr_phase( int config_num_outstanding_wr_phase_param );
        config_num_outstanding_wr_phase = config_num_outstanding_wr_phase_param;
    endfunction

    function automatic void do_set_config_num_outstanding_rd_phase( int config_num_outstanding_rd_phase_param );
        config_num_outstanding_rd_phase = config_num_outstanding_rd_phase_param;
    endfunction

    function automatic void do_set_config_enable_warnings( bit config_enable_warnings_param );
        config_enable_warnings = config_enable_warnings_param;
    endfunction

    function automatic void do_set_config_enable_errors( bit config_enable_errors_param );
        config_enable_errors = config_enable_errors_param;
    endfunction

    function automatic void do_set_config_enable_exclusive_checks( bit config_enable_exclusive_checks_param );
        config_enable_exclusive_checks = config_enable_exclusive_checks_param;
    endfunction

    function automatic void do_set_config_warn_on_slave_errors( bit config_warn_on_slave_errors_param );
        config_warn_on_slave_errors = config_warn_on_slave_errors_param;
    endfunction

    function automatic void do_set_config_error_on_deleted_valid_cycles( bit config_error_on_deleted_valid_cycles_param );
        config_error_on_deleted_valid_cycles = config_error_on_deleted_valid_cycles_param;
    endfunction

    function automatic void do_set_config_stats_enable( bit config_stats_enable_param );
        config_stats_enable = config_stats_enable_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_occupancy( bit config_stats_enable_read_occupancy_param );
        config_stats_enable_read_occupancy = config_stats_enable_read_occupancy_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_occupancy( bit config_stats_enable_write_occupancy_param );
        config_stats_enable_write_occupancy = config_stats_enable_write_occupancy_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_data_occupancy( bit config_stats_enable_read_data_occupancy_param );
        config_stats_enable_read_data_occupancy = config_stats_enable_read_data_occupancy_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_data_occupancy( bit config_stats_enable_write_data_occupancy_param );
        config_stats_enable_write_data_occupancy = config_stats_enable_write_data_occupancy_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_latency( bit config_stats_enable_read_latency_param );
        config_stats_enable_read_latency = config_stats_enable_read_latency_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_latency( bit config_stats_enable_write_latency_param );
        config_stats_enable_write_latency = config_stats_enable_write_latency_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_address_waits( bit config_stats_enable_read_address_waits_param );
        config_stats_enable_read_address_waits = config_stats_enable_read_address_waits_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_data_waits( bit config_stats_enable_read_data_waits_param );
        config_stats_enable_read_data_waits = config_stats_enable_read_data_waits_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_address_waits( bit config_stats_enable_write_address_waits_param );
        config_stats_enable_write_address_waits = config_stats_enable_write_address_waits_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_data_waits( bit config_stats_enable_write_data_waits_param );
        config_stats_enable_write_data_waits = config_stats_enable_write_data_waits_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_response_waits( bit config_stats_enable_write_response_waits_param );
        config_stats_enable_write_response_waits = config_stats_enable_write_response_waits_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_bandwidth( bit config_stats_enable_read_bandwidth_param );
        config_stats_enable_read_bandwidth = config_stats_enable_read_bandwidth_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_bandwidth( bit config_stats_enable_write_bandwidth_param );
        config_stats_enable_write_bandwidth = config_stats_enable_write_bandwidth_param;
    endfunction

    function automatic void do_set_config_stats_read_occupancy_step( int config_stats_read_occupancy_step_param );
        config_stats_read_occupancy_step = config_stats_read_occupancy_step_param;
    endfunction

    function automatic void do_set_config_stats_read_occupancy_multiple( int config_stats_read_occupancy_multiple_param );
        config_stats_read_occupancy_multiple = config_stats_read_occupancy_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_occupancy_step( int config_stats_write_occupancy_step_param );
        config_stats_write_occupancy_step = config_stats_write_occupancy_step_param;
    endfunction

    function automatic void do_set_config_stats_write_occupancy_multiple( int config_stats_write_occupancy_multiple_param );
        config_stats_write_occupancy_multiple = config_stats_write_occupancy_multiple_param;
    endfunction

    function automatic void do_set_config_stats_read_data_occupancy_step( int config_stats_read_data_occupancy_step_param );
        config_stats_read_data_occupancy_step = config_stats_read_data_occupancy_step_param;
    endfunction

    function automatic void do_set_config_stats_read_data_occupancy_multiple( int config_stats_read_data_occupancy_multiple_param );
        config_stats_read_data_occupancy_multiple = config_stats_read_data_occupancy_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_data_occupancy_step( int config_stats_write_data_occupancy_step_param );
        config_stats_write_data_occupancy_step = config_stats_write_data_occupancy_step_param;
    endfunction

    function automatic void do_set_config_stats_write_data_occupancy_multiple( int config_stats_write_data_occupancy_multiple_param );
        config_stats_write_data_occupancy_multiple = config_stats_write_data_occupancy_multiple_param;
    endfunction

    function automatic void do_set_config_stats_read_bandwidth_step( int config_stats_read_bandwidth_step_param );
        config_stats_read_bandwidth_step = config_stats_read_bandwidth_step_param;
    endfunction

    function automatic void do_set_config_stats_read_bandwidth_multiple( int config_stats_read_bandwidth_multiple_param );
        config_stats_read_bandwidth_multiple = config_stats_read_bandwidth_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_bandwidth_step( int config_stats_write_bandwidth_step_param );
        config_stats_write_bandwidth_step = config_stats_write_bandwidth_step_param;
    endfunction

    function automatic void do_set_config_stats_write_bandwidth_multiple( int config_stats_write_bandwidth_multiple_param );
        config_stats_write_bandwidth_multiple = config_stats_write_bandwidth_multiple_param;
    endfunction

    function automatic void do_set_config_stats_read_latency_step( int config_stats_read_latency_step_param );
        config_stats_read_latency_step = config_stats_read_latency_step_param;
    endfunction

    function automatic void do_set_config_stats_read_latency_multiple( int config_stats_read_latency_multiple_param );
        config_stats_read_latency_multiple = config_stats_read_latency_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_latency_step( int config_stats_write_latency_step_param );
        config_stats_write_latency_step = config_stats_write_latency_step_param;
    endfunction

    function automatic void do_set_config_stats_write_latency_multiple( int config_stats_write_latency_multiple_param );
        config_stats_write_latency_multiple = config_stats_write_latency_multiple_param;
    endfunction

    function automatic void do_set_config_stats_read_address_waits_step( int config_stats_read_address_waits_step_param );
        config_stats_read_address_waits_step = config_stats_read_address_waits_step_param;
    endfunction

    function automatic void do_set_config_stats_read_address_waits_multiple( int config_stats_read_address_waits_multiple_param );
        config_stats_read_address_waits_multiple = config_stats_read_address_waits_multiple_param;
    endfunction

    function automatic void do_set_config_stats_read_data_waits_step( int config_stats_read_data_waits_step_param );
        config_stats_read_data_waits_step = config_stats_read_data_waits_step_param;
    endfunction

    function automatic void do_set_config_stats_read_data_waits_multiple( int config_stats_read_data_waits_multiple_param );
        config_stats_read_data_waits_multiple = config_stats_read_data_waits_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_address_waits_step( int config_stats_write_address_waits_step_param );
        config_stats_write_address_waits_step = config_stats_write_address_waits_step_param;
    endfunction

    function automatic void do_set_config_stats_write_address_waits_multiple( int config_stats_write_address_waits_multiple_param );
        config_stats_write_address_waits_multiple = config_stats_write_address_waits_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_data_waits_step( int config_stats_write_data_waits_step_param );
        config_stats_write_data_waits_step = config_stats_write_data_waits_step_param;
    endfunction

    function automatic void do_set_config_stats_write_data_waits_multiple( int config_stats_write_data_waits_multiple_param );
        config_stats_write_data_waits_multiple = config_stats_write_data_waits_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_response_waits_step( int config_stats_write_response_waits_step_param );
        config_stats_write_response_waits_step = config_stats_write_response_waits_step_param;
    endfunction

    function automatic void do_set_config_stats_write_response_waits_multiple( int config_stats_write_response_waits_multiple_param );
        config_stats_write_response_waits_multiple = config_stats_write_response_waits_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Functions to get global variables with read access
    //------------------------------------------------------------------------------

    function automatic axi4_interface_type_e do_get_config_interface_type(  );
        return config_interface_type;
    endfunction

    function automatic bit do_get_config_clk_init_value(  );
        return config_clk_init_value;
    endfunction

    function automatic longint unsigned do_get_config_clk_phase_shift(  );
        return config_clk_phase_shift;
    endfunction

    function automatic longint unsigned do_get_config_clk_1st_time(  );
        return config_clk_1st_time;
    endfunction

    function automatic longint unsigned do_get_config_clk_2nd_time(  );
        return config_clk_2nd_time;
    endfunction

    function automatic longint unsigned do_get_config_setup_time(  );
        return config_setup_time;
    endfunction

    function automatic longint unsigned do_get_config_hold_time(  );
        return config_hold_time;
    endfunction

    function automatic int unsigned do_get_config_burst_timeout_factor(  );
        return config_burst_timeout_factor;
    endfunction

    function automatic int unsigned do_get_config_max_transaction_time_factor(  );
        return config_max_transaction_time_factor;
    endfunction

    function automatic int do_get_config_write_ctrl_first_ratio(  );
        return config_write_ctrl_first_ratio;
    endfunction

    function automatic int do_get_config_write_data_first_ratio(  );
        return config_write_data_first_ratio;
    endfunction

    function automatic int do_get_config_reset_low_clocks(  );
        return config_reset_low_clocks;
    endfunction

    function automatic int do_get_config_reset_hold_time(  );
        return config_reset_hold_time;
    endfunction

    function automatic bit do_get_config_enable_rlast(  );
        return config_enable_rlast;
    endfunction

    function automatic bit do_get_config_enable_slave_exclusive(  );
        return config_enable_slave_exclusive;
    endfunction

    function automatic bit do_get_config_enable_burst_reserved_value(  );
        return config_enable_burst_reserved_value;
    endfunction

    function automatic bit [15:0]  do_get_config_enable_cache_value(  );
        return config_enable_cache_value;
    endfunction

    function automatic bit   do_get_config_enable_cache_value_index1( int _this_dot_1 );
        return config_enable_cache_value[_this_dot_1];
    endfunction

    function automatic axi4_error_e do_get_internal_dummy_variable(  );
        return internal_dummy_variable;
    endfunction

    function automatic bit do_get_config_axi4lite_interface(  );
        return config_axi4lite_interface;
    endfunction

    function automatic bit [((AXI4_ID_WIDTH) - 1):0]   do_get_config_axi4lite_tr_id(  );
        return config_axi4lite_tr_id;
    endfunction

    function automatic bit   do_get_config_axi4lite_tr_id_index1( int _this_dot_1 );
        return config_axi4lite_tr_id[_this_dot_1];
    endfunction

    function automatic bit do_get_config_enable_all_assertions(  );
        return config_enable_all_assertions;
    endfunction

    function automatic bit [255:0]  do_get_config_enable_assertion(  );
        return config_enable_assertion;
    endfunction

    function automatic bit   do_get_config_enable_assertion_index1( int _this_dot_1 );
        return config_enable_assertion[_this_dot_1];
    endfunction

    function automatic bit [255:0]  do_get_config_enable_error(  );
        return config_enable_error;
    endfunction

    function automatic bit   do_get_config_enable_error_index1( int _this_dot_1 );
        return config_enable_error[_this_dot_1];
    endfunction

    function automatic int unsigned do_get_config_max_latency_AWVALID_assertion_to_AWREADY(  );
        return config_max_latency_AWVALID_assertion_to_AWREADY;
    endfunction

    function automatic int unsigned do_get_config_max_latency_ARVALID_assertion_to_ARREADY(  );
        return config_max_latency_ARVALID_assertion_to_ARREADY;
    endfunction

    function automatic int unsigned do_get_config_max_latency_RVALID_assertion_to_RREADY(  );
        return config_max_latency_RVALID_assertion_to_RREADY;
    endfunction

    function automatic int unsigned do_get_config_max_latency_BVALID_assertion_to_BREADY(  );
        return config_max_latency_BVALID_assertion_to_BREADY;
    endfunction

    function automatic int unsigned do_get_config_max_latency_WVALID_assertion_to_WREADY(  );
        return config_max_latency_WVALID_assertion_to_WREADY;
    endfunction

    function automatic bit do_get_config_enable_qos(  );
        return config_enable_qos;
    endfunction

    function automatic bit do_get_config_enable_region_support(  );
        return config_enable_region_support;
    endfunction

    function automatic int do_get_config_slave_regions(  );
        return config_slave_regions;
    endfunction

    function automatic bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]   do_get_config_region(  );
        return config_region;
    endfunction

    function automatic bit [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]   do_get_config_region_index1( int _this_dot_1 );
        return config_region[_this_dot_1];
    endfunction

    function automatic bit   do_get_config_region_index2( int _this_dot_1, int _this_dot_2 );
        return config_region[_this_dot_1][_this_dot_2];
    endfunction

    function automatic bit do_get_region_error_state(  );
        return region_error_state;
    endfunction

    typedef longint unsigned _region_map_lb_t [((AXI4_REGION_MAP_SIZE) - 1):0];
    function automatic _region_map_lb_t do_get_region_map_lb(  );
        return region_map_lb;
    endfunction

    function automatic longint unsigned do_get_region_map_lb_index1( int _this_dot_1 );
        return region_map_lb[_this_dot_1];
    endfunction

    typedef longint unsigned _region_map_ub_t [((AXI4_REGION_MAP_SIZE) - 1):0];
    function automatic _region_map_ub_t do_get_region_map_ub(  );
        return region_map_ub;
    endfunction

    function automatic longint unsigned do_get_region_map_ub_index1( int _this_dot_1 );
        return region_map_ub[_this_dot_1];
    endfunction

    typedef byte unsigned _region_map_region_t [((AXI4_REGION_MAP_SIZE) - 1):0];
    function automatic _region_map_region_t do_get_region_map_region(  );
        return region_map_region;
    endfunction

    function automatic byte unsigned do_get_region_map_region_index1( int _this_dot_1 );
        return region_map_region[_this_dot_1];
    endfunction

    typedef byte unsigned _cacheable_t [((AXI4_REGION_MAP_SIZE) - 1):0];
    function automatic _cacheable_t do_get_cacheable(  );
        return cacheable;
    endfunction

    function automatic byte unsigned do_get_cacheable_index1( int _this_dot_1 );
        return cacheable[_this_dot_1];
    endfunction

    function automatic int unsigned do_get_config_read_data_reordering_depth(  );
        return config_read_data_reordering_depth;
    endfunction

    function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   do_get_config_slave_start_addr(  );
        return config_slave_start_addr;
    endfunction

    function automatic bit   do_get_config_slave_start_addr_index1( int _this_dot_1 );
        return config_slave_start_addr[_this_dot_1];
    endfunction

    function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   do_get_config_slave_end_addr(  );
        return config_slave_end_addr;
    endfunction

    function automatic bit   do_get_config_slave_end_addr_index1( int _this_dot_1 );
        return config_slave_end_addr[_this_dot_1];
    endfunction

    function automatic int do_get_config_slave_enabled_non_contiguous_address_spaces(  );
        return config_slave_enabled_non_contiguous_address_spaces;
    endfunction

    function automatic bit do_get_config_slave_possess_multiple_non_contiguous_address_spaces(  );
        return config_slave_possess_multiple_non_contiguous_address_spaces;
    endfunction

    function automatic bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]   do_get_config_slave_multiple_non_contiguous_start_address_range(  );
        return config_slave_multiple_non_contiguous_start_address_range;
    endfunction

    function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   do_get_config_slave_multiple_non_contiguous_start_address_range_index1( int _this_dot_1 );
        return config_slave_multiple_non_contiguous_start_address_range[_this_dot_1];
    endfunction

    function automatic bit   do_get_config_slave_multiple_non_contiguous_start_address_range_index2( int _this_dot_1, int _this_dot_2 );
        return config_slave_multiple_non_contiguous_start_address_range[_this_dot_1][_this_dot_2];
    endfunction

    function automatic bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]   do_get_config_slave_multiple_non_contiguous_end_address_range(  );
        return config_slave_multiple_non_contiguous_end_address_range;
    endfunction

    function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   do_get_config_slave_multiple_non_contiguous_end_address_range_index1( int _this_dot_1 );
        return config_slave_multiple_non_contiguous_end_address_range[_this_dot_1];
    endfunction

    function automatic bit   do_get_config_slave_multiple_non_contiguous_end_address_range_index2( int _this_dot_1, int _this_dot_2 );
        return config_slave_multiple_non_contiguous_end_address_range[_this_dot_1][_this_dot_2];
    endfunction

    function automatic bit do_get_config_protect_ready(  );
        return config_protect_ready;
    endfunction

    function automatic bit do_get_master_end_tlm_status(  );
        return master_end_tlm_status;
    endfunction

    function automatic bit do_get_master_end_wlm_status(  );
        return master_end_wlm_status;
    endfunction

    function automatic bit do_get_slave_end_tlm_status(  );
        return slave_end_tlm_status;
    endfunction

    function automatic bit do_get_slave_end_wlm_status(  );
        return slave_end_wlm_status;
    endfunction

    function automatic bit do_get_clock_source_end_tlm_status(  );
        return clock_source_end_tlm_status;
    endfunction

    function automatic bit do_get_clock_source_end_wlm_status(  );
        return clock_source_end_wlm_status;
    endfunction

    function automatic bit do_get_reset_source_end_tlm_status(  );
        return reset_source_end_tlm_status;
    endfunction

    function automatic bit do_get_reset_source_end_wlm_status(  );
        return reset_source_end_wlm_status;
    endfunction

    function automatic int do_get_config_max_outstanding_wr(  );
        return config_max_outstanding_wr;
    endfunction

    function automatic int do_get_config_max_outstanding_rd(  );
        return config_max_outstanding_rd;
    endfunction

    function automatic int do_get_config_num_outstanding_wr_phase(  );
        return config_num_outstanding_wr_phase;
    endfunction

    function automatic int do_get_config_num_outstanding_rd_phase(  );
        return config_num_outstanding_rd_phase;
    endfunction

    function automatic bit do_get_config_enable_warnings(  );
        return config_enable_warnings;
    endfunction

    function automatic bit do_get_config_enable_errors(  );
        return config_enable_errors;
    endfunction

    function automatic bit do_get_config_enable_exclusive_checks(  );
        return config_enable_exclusive_checks;
    endfunction

    function automatic bit do_get_config_warn_on_slave_errors(  );
        return config_warn_on_slave_errors;
    endfunction

    function automatic bit do_get_config_error_on_deleted_valid_cycles(  );
        return config_error_on_deleted_valid_cycles;
    endfunction

    function automatic bit do_get_config_stats_enable(  );
        return config_stats_enable;
    endfunction

    function automatic bit do_get_config_stats_enable_read_occupancy(  );
        return config_stats_enable_read_occupancy;
    endfunction

    function automatic bit do_get_config_stats_enable_write_occupancy(  );
        return config_stats_enable_write_occupancy;
    endfunction

    function automatic bit do_get_config_stats_enable_read_data_occupancy(  );
        return config_stats_enable_read_data_occupancy;
    endfunction

    function automatic bit do_get_config_stats_enable_write_data_occupancy(  );
        return config_stats_enable_write_data_occupancy;
    endfunction

    function automatic bit do_get_config_stats_enable_read_latency(  );
        return config_stats_enable_read_latency;
    endfunction

    function automatic bit do_get_config_stats_enable_write_latency(  );
        return config_stats_enable_write_latency;
    endfunction

    function automatic bit do_get_config_stats_enable_read_address_waits(  );
        return config_stats_enable_read_address_waits;
    endfunction

    function automatic bit do_get_config_stats_enable_read_data_waits(  );
        return config_stats_enable_read_data_waits;
    endfunction

    function automatic bit do_get_config_stats_enable_write_address_waits(  );
        return config_stats_enable_write_address_waits;
    endfunction

    function automatic bit do_get_config_stats_enable_write_data_waits(  );
        return config_stats_enable_write_data_waits;
    endfunction

    function automatic bit do_get_config_stats_enable_write_response_waits(  );
        return config_stats_enable_write_response_waits;
    endfunction

    function automatic bit do_get_config_stats_enable_read_bandwidth(  );
        return config_stats_enable_read_bandwidth;
    endfunction

    function automatic bit do_get_config_stats_enable_write_bandwidth(  );
        return config_stats_enable_write_bandwidth;
    endfunction

    function automatic int do_get_stats_rw_transaction_last_duration(  );
        return stats_rw_transaction_last_duration;
    endfunction

    function automatic int do_get_config_stats_read_occupancy_step(  );
        return config_stats_read_occupancy_step;
    endfunction

    function automatic int do_get_config_stats_read_occupancy_multiple(  );
        return config_stats_read_occupancy_multiple;
    endfunction

    function automatic bit do_get_stats_read_active(  );
        return stats_read_active;
    endfunction

    function automatic int do_get_stats_read_occupancy_sw(  );
        return stats_read_occupancy_sw;
    endfunction

    function automatic int do_get_stats_read_idle_sw(  );
        return stats_read_idle_sw;
    endfunction

    function automatic int do_get_stats_read_occupancy_min(  );
        return stats_read_occupancy_min;
    endfunction

    function automatic int do_get_stats_read_idle_min(  );
        return stats_read_idle_min;
    endfunction

    function automatic int do_get_stats_read_occupancy_max(  );
        return stats_read_occupancy_max;
    endfunction

    function automatic int do_get_stats_read_idle_max(  );
        return stats_read_idle_max;
    endfunction

    function automatic int do_get_stats_read_occupancy_mean(  );
        return stats_read_occupancy_mean;
    endfunction

    function automatic int do_get_stats_read_idle_mean(  );
        return stats_read_idle_mean;
    endfunction

    function automatic int do_get_stats_read_last_duration(  );
        return stats_read_last_duration;
    endfunction

    function automatic int do_get_config_stats_write_occupancy_step(  );
        return config_stats_write_occupancy_step;
    endfunction

    function automatic int do_get_config_stats_write_occupancy_multiple(  );
        return config_stats_write_occupancy_multiple;
    endfunction

    function automatic bit do_get_stats_write_active(  );
        return stats_write_active;
    endfunction

    function automatic int do_get_stats_write_occupancy_sw(  );
        return stats_write_occupancy_sw;
    endfunction

    function automatic int do_get_stats_write_idle_sw(  );
        return stats_write_idle_sw;
    endfunction

    function automatic int do_get_stats_write_occupancy_min(  );
        return stats_write_occupancy_min;
    endfunction

    function automatic int do_get_stats_write_idle_min(  );
        return stats_write_idle_min;
    endfunction

    function automatic int do_get_stats_write_occupancy_max(  );
        return stats_write_occupancy_max;
    endfunction

    function automatic int do_get_stats_write_idle_max(  );
        return stats_write_idle_max;
    endfunction

    function automatic int do_get_stats_write_occupancy_mean(  );
        return stats_write_occupancy_mean;
    endfunction

    function automatic int do_get_stats_write_idle_mean(  );
        return stats_write_idle_mean;
    endfunction

    function automatic int do_get_stats_write_last_duration(  );
        return stats_write_last_duration;
    endfunction

    function automatic int do_get_config_stats_read_data_occupancy_step(  );
        return config_stats_read_data_occupancy_step;
    endfunction

    function automatic int do_get_config_stats_read_data_occupancy_multiple(  );
        return config_stats_read_data_occupancy_multiple;
    endfunction

    function automatic int do_get_stats_read_data_occupancy_sw(  );
        return stats_read_data_occupancy_sw;
    endfunction

    function automatic int do_get_stats_read_data_idle_sw(  );
        return stats_read_data_idle_sw;
    endfunction

    function automatic int do_get_stats_read_data_occupancy_min(  );
        return stats_read_data_occupancy_min;
    endfunction

    function automatic int do_get_stats_read_data_idle_min(  );
        return stats_read_data_idle_min;
    endfunction

    function automatic int do_get_stats_read_data_occupancy_max(  );
        return stats_read_data_occupancy_max;
    endfunction

    function automatic int do_get_stats_read_data_idle_max(  );
        return stats_read_data_idle_max;
    endfunction

    function automatic int do_get_stats_read_data_occupancy_mean(  );
        return stats_read_data_occupancy_mean;
    endfunction

    function automatic int do_get_stats_read_data_idle_mean(  );
        return stats_read_data_idle_mean;
    endfunction

    function automatic int do_get_config_stats_write_data_occupancy_step(  );
        return config_stats_write_data_occupancy_step;
    endfunction

    function automatic int do_get_config_stats_write_data_occupancy_multiple(  );
        return config_stats_write_data_occupancy_multiple;
    endfunction

    function automatic int do_get_stats_write_data_occupancy_sw(  );
        return stats_write_data_occupancy_sw;
    endfunction

    function automatic int do_get_stats_write_data_idle_sw(  );
        return stats_write_data_idle_sw;
    endfunction

    function automatic int do_get_stats_write_data_occupancy_min(  );
        return stats_write_data_occupancy_min;
    endfunction

    function automatic int do_get_stats_write_data_idle_min(  );
        return stats_write_data_idle_min;
    endfunction

    function automatic int do_get_stats_write_data_occupancy_max(  );
        return stats_write_data_occupancy_max;
    endfunction

    function automatic int do_get_stats_write_data_idle_max(  );
        return stats_write_data_idle_max;
    endfunction

    function automatic int do_get_stats_write_data_occupancy_mean(  );
        return stats_write_data_occupancy_mean;
    endfunction

    function automatic int do_get_stats_write_data_idle_mean(  );
        return stats_write_data_idle_mean;
    endfunction

    function automatic int do_get_config_stats_read_bandwidth_step(  );
        return config_stats_read_bandwidth_step;
    endfunction

    function automatic int do_get_config_stats_read_bandwidth_multiple(  );
        return config_stats_read_bandwidth_multiple;
    endfunction

    function automatic int do_get_stats_read_bandwidth_sw(  );
        return stats_read_bandwidth_sw;
    endfunction

    function automatic int do_get_stats_read_bandwidth_min(  );
        return stats_read_bandwidth_min;
    endfunction

    function automatic int do_get_stats_read_bandwidth_max(  );
        return stats_read_bandwidth_max;
    endfunction

    function automatic int do_get_stats_read_bandwidth_mean(  );
        return stats_read_bandwidth_mean;
    endfunction

    function automatic int do_get_config_stats_write_bandwidth_step(  );
        return config_stats_write_bandwidth_step;
    endfunction

    function automatic int do_get_config_stats_write_bandwidth_multiple(  );
        return config_stats_write_bandwidth_multiple;
    endfunction

    function automatic int do_get_stats_write_bandwidth_sw(  );
        return stats_write_bandwidth_sw;
    endfunction

    function automatic int do_get_stats_write_bandwidth_min(  );
        return stats_write_bandwidth_min;
    endfunction

    function automatic int do_get_stats_write_bandwidth_max(  );
        return stats_write_bandwidth_max;
    endfunction

    function automatic int do_get_stats_write_bandwidth_mean(  );
        return stats_write_bandwidth_mean;
    endfunction

    function automatic int do_get_config_stats_read_latency_step(  );
        return config_stats_read_latency_step;
    endfunction

    function automatic int do_get_config_stats_read_latency_multiple(  );
        return config_stats_read_latency_multiple;
    endfunction

    function automatic int do_get_stats_read_address_data_latency_inst(  );
        return stats_read_address_data_latency_inst;
    endfunction

    function automatic int do_get_stats_read_address_data_latency_sw(  );
        return stats_read_address_data_latency_sw;
    endfunction

    function automatic int do_get_stats_read_address_data_latency_min(  );
        return stats_read_address_data_latency_min;
    endfunction

    function automatic int do_get_stats_read_address_data_latency_max(  );
        return stats_read_address_data_latency_max;
    endfunction

    function automatic int do_get_stats_read_address_data_latency_mean(  );
        return stats_read_address_data_latency_mean;
    endfunction

    function automatic int do_get_stats_read_address_address_latency_inst(  );
        return stats_read_address_address_latency_inst;
    endfunction

    function automatic int do_get_stats_read_address_address_latency_sw(  );
        return stats_read_address_address_latency_sw;
    endfunction

    function automatic int do_get_stats_read_address_address_latency_min(  );
        return stats_read_address_address_latency_min;
    endfunction

    function automatic int do_get_stats_read_address_address_latency_max(  );
        return stats_read_address_address_latency_max;
    endfunction

    function automatic int do_get_stats_read_address_address_latency_mean(  );
        return stats_read_address_address_latency_mean;
    endfunction

    function automatic int do_get_config_stats_write_latency_step(  );
        return config_stats_write_latency_step;
    endfunction

    function automatic int do_get_config_stats_write_latency_multiple(  );
        return config_stats_write_latency_multiple;
    endfunction

    function automatic int do_get_stats_write_address_response_latency_inst(  );
        return stats_write_address_response_latency_inst;
    endfunction

    function automatic int do_get_stats_write_address_response_latency_sw(  );
        return stats_write_address_response_latency_sw;
    endfunction

    function automatic int do_get_stats_write_address_response_latency_min(  );
        return stats_write_address_response_latency_min;
    endfunction

    function automatic int do_get_stats_write_address_response_latency_max(  );
        return stats_write_address_response_latency_max;
    endfunction

    function automatic int do_get_stats_write_address_response_latency_mean(  );
        return stats_write_address_response_latency_mean;
    endfunction

    function automatic int do_get_stats_write_address_address_latency_inst(  );
        return stats_write_address_address_latency_inst;
    endfunction

    function automatic int do_get_stats_write_address_address_latency_sw(  );
        return stats_write_address_address_latency_sw;
    endfunction

    function automatic int do_get_stats_write_address_address_latency_min(  );
        return stats_write_address_address_latency_min;
    endfunction

    function automatic int do_get_stats_write_address_address_latency_max(  );
        return stats_write_address_address_latency_max;
    endfunction

    function automatic int do_get_stats_write_address_address_latency_mean(  );
        return stats_write_address_address_latency_mean;
    endfunction

    function automatic int do_get_config_stats_read_address_waits_step(  );
        return config_stats_read_address_waits_step;
    endfunction

    function automatic int do_get_config_stats_read_address_waits_multiple(  );
        return config_stats_read_address_waits_multiple;
    endfunction

    function automatic int do_get_stats_read_address_waits_inst(  );
        return stats_read_address_waits_inst;
    endfunction

    function automatic int do_get_stats_read_address_waits_sw(  );
        return stats_read_address_waits_sw;
    endfunction

    function automatic int do_get_stats_read_address_waits_min(  );
        return stats_read_address_waits_min;
    endfunction

    function automatic int do_get_stats_read_address_waits_max(  );
        return stats_read_address_waits_max;
    endfunction

    function automatic int do_get_stats_read_address_waits_mean(  );
        return stats_read_address_waits_mean;
    endfunction

    function automatic int do_get_config_stats_read_data_waits_step(  );
        return config_stats_read_data_waits_step;
    endfunction

    function automatic int do_get_config_stats_read_data_waits_multiple(  );
        return config_stats_read_data_waits_multiple;
    endfunction

    function automatic int do_get_stats_read_data_waits_inst(  );
        return stats_read_data_waits_inst;
    endfunction

    function automatic int do_get_stats_read_data_waits_sw(  );
        return stats_read_data_waits_sw;
    endfunction

    function automatic int do_get_stats_read_data_waits_min(  );
        return stats_read_data_waits_min;
    endfunction

    function automatic int do_get_stats_read_data_waits_max(  );
        return stats_read_data_waits_max;
    endfunction

    function automatic int do_get_stats_read_data_waits_mean(  );
        return stats_read_data_waits_mean;
    endfunction

    function automatic int do_get_config_stats_write_address_waits_step(  );
        return config_stats_write_address_waits_step;
    endfunction

    function automatic int do_get_config_stats_write_address_waits_multiple(  );
        return config_stats_write_address_waits_multiple;
    endfunction

    function automatic int do_get_stats_write_address_waits_inst(  );
        return stats_write_address_waits_inst;
    endfunction

    function automatic int do_get_stats_write_address_waits_sw(  );
        return stats_write_address_waits_sw;
    endfunction

    function automatic int do_get_stats_write_address_waits_min(  );
        return stats_write_address_waits_min;
    endfunction

    function automatic int do_get_stats_write_address_waits_max(  );
        return stats_write_address_waits_max;
    endfunction

    function automatic int do_get_stats_write_address_waits_mean(  );
        return stats_write_address_waits_mean;
    endfunction

    function automatic int do_get_config_stats_write_data_waits_step(  );
        return config_stats_write_data_waits_step;
    endfunction

    function automatic int do_get_config_stats_write_data_waits_multiple(  );
        return config_stats_write_data_waits_multiple;
    endfunction

    function automatic int do_get_stats_write_data_waits_inst(  );
        return stats_write_data_waits_inst;
    endfunction

    function automatic int do_get_stats_write_data_waits_sw(  );
        return stats_write_data_waits_sw;
    endfunction

    function automatic int do_get_stats_write_data_waits_min(  );
        return stats_write_data_waits_min;
    endfunction

    function automatic int do_get_stats_write_data_waits_max(  );
        return stats_write_data_waits_max;
    endfunction

    function automatic int do_get_stats_write_data_waits_mean(  );
        return stats_write_data_waits_mean;
    endfunction

    function automatic int do_get_config_stats_write_response_waits_step(  );
        return config_stats_write_response_waits_step;
    endfunction

    function automatic int do_get_config_stats_write_response_waits_multiple(  );
        return config_stats_write_response_waits_multiple;
    endfunction

    function automatic int do_get_stats_write_response_waits_inst(  );
        return stats_write_response_waits_inst;
    endfunction

    function automatic int do_get_stats_write_response_waits_sw(  );
        return stats_write_response_waits_sw;
    endfunction

    function automatic int do_get_stats_write_response_waits_min(  );
        return stats_write_response_waits_min;
    endfunction

    function automatic int do_get_stats_write_response_waits_max(  );
        return stats_write_response_waits_max;
    endfunction

    function automatic int do_get_stats_write_response_waits_mean(  );
        return stats_write_response_waits_mean;
    endfunction

    function automatic int do_get_reordering_depth_of_last_read_transaction(  );
        return reordering_depth_of_last_read_transaction;
    endfunction


    //------------------------------------------------------------------------------
    // Interface end access functions
    //------------------------------------------------------------------------------

    function longint do_get_axi4_master_end();
        return axi4_get_axi4_master_end();
    endfunction

    function longint do_get_axi4_slave_end();
        return axi4_get_axi4_slave_end();
    endfunction

    function longint do_get_axi4_clock_source_end();
        return axi4_get_axi4_clock_source_end();
    endfunction

    function longint do_get_axi4_reset_source_end();
        return axi4_get_axi4_reset_source_end();
    endfunction

    function longint do_get_axi4__monitor_end();
        return axi4_get_axi4__monitor_end();
    endfunction

    //------------------------------------------------------------------------------
    // Functions to set/get generic interface configuration
    //------------------------------------------------------------------------------

    function void do_set_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0,
        input int arg10 = 0
    );
        axi4_set_interface( what, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10 );
    endfunction

    function int do_get_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0
    );
        return axi4_get_interface( what, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 );
    endfunction

    //------------------------------------------------------------------------------
    // Functions to get the hierarchic name of this interface
    //------------------------------------------------------------------------------
    function string do_get_full_name();
        return axi4_get_full_name();
    endfunction

    //------------------------------------------------------------------------------
    // Functions to set/get the abstraction levels of interface ends
    //------------------------------------------------------------------------------

    function void do_axi4_set_master_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi4_set_master_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi4_get_master_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi4_get_master_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi4_set_slave_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi4_set_slave_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi4_get_slave_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi4_get_slave_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi4_set_clock_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi4_set_clock_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi4_get_clock_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi4_get_clock_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi4_set_reset_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi4_set_reset_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi4_get_reset_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi4_get_reset_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

// Variable monitors

    function automatic void axi4_local_set_config_interface_type_from_SystemVerilog( ref axi4_interface_type_e config_interface_type_param );
        int tmp_config_interface_type;
        tmp_config_interface_type = int'( config_interface_type );
            axi4_set_config_interface_type_from_SystemVerilog(
            tmp_config_interface_type
            ); // DPI call to imported task
        
            axi4_propagate_config_interface_type_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_interface_type_from_SystemVerilog( config_interface_type );
            end
        end
    end

    function automatic void axi4_local_set_config_clk_init_value_from_SystemVerilog( ref bit config_clk_init_value_param );
            axi4_set_config_clk_init_value_from_SystemVerilog(config_clk_init_value); // DPI call to imported task
        
            axi4_propagate_config_clk_init_value_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_clk_init_value_from_SystemVerilog( config_clk_init_value );
            end
        end
    end

    function automatic void axi4_local_set_config_clk_phase_shift_from_SystemVerilog( ref longint unsigned config_clk_phase_shift_param );
            axi4_set_config_clk_phase_shift_from_SystemVerilog(config_clk_phase_shift); // DPI call to imported task
        
            axi4_propagate_config_clk_phase_shift_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_clk_phase_shift_from_SystemVerilog( config_clk_phase_shift );
            end
        end
    end

    function automatic void axi4_local_set_config_clk_1st_time_from_SystemVerilog( ref longint unsigned config_clk_1st_time_param );
            axi4_set_config_clk_1st_time_from_SystemVerilog(config_clk_1st_time); // DPI call to imported task
        
            axi4_propagate_config_clk_1st_time_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_clk_1st_time_from_SystemVerilog( config_clk_1st_time );
            end
        end
    end

    function automatic void axi4_local_set_config_clk_2nd_time_from_SystemVerilog( ref longint unsigned config_clk_2nd_time_param );
            axi4_set_config_clk_2nd_time_from_SystemVerilog(config_clk_2nd_time); // DPI call to imported task
        
            axi4_propagate_config_clk_2nd_time_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_clk_2nd_time_from_SystemVerilog( config_clk_2nd_time );
            end
        end
    end

    function automatic void axi4_local_set_config_setup_time_from_SystemVerilog( ref longint unsigned config_setup_time_param );
            axi4_set_config_setup_time_from_SystemVerilog(config_setup_time); // DPI call to imported task
        
            axi4_propagate_config_setup_time_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_setup_time_from_SystemVerilog( config_setup_time );
            end
        end
    end

    function automatic void axi4_local_set_config_hold_time_from_SystemVerilog( ref longint unsigned config_hold_time_param );
            axi4_set_config_hold_time_from_SystemVerilog(config_hold_time); // DPI call to imported task
        
            axi4_propagate_config_hold_time_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_hold_time_from_SystemVerilog( config_hold_time );
            end
        end
    end

    function automatic void axi4_local_set_config_burst_timeout_factor_from_SystemVerilog( ref int unsigned config_burst_timeout_factor_param );
            axi4_set_config_burst_timeout_factor_from_SystemVerilog(config_burst_timeout_factor); // DPI call to imported task
        
            axi4_propagate_config_burst_timeout_factor_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_burst_timeout_factor_from_SystemVerilog( config_burst_timeout_factor );
            end
        end
    end

    function automatic void axi4_local_set_config_max_transaction_time_factor_from_SystemVerilog( ref int unsigned config_max_transaction_time_factor_param );
            axi4_set_config_max_transaction_time_factor_from_SystemVerilog(config_max_transaction_time_factor); // DPI call to imported task
        
            axi4_propagate_config_max_transaction_time_factor_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_transaction_time_factor_from_SystemVerilog( config_max_transaction_time_factor );
            end
        end
    end

    function automatic void axi4_local_set_config_write_ctrl_first_ratio_from_SystemVerilog( ref int config_write_ctrl_first_ratio_param );
            axi4_set_config_write_ctrl_first_ratio_from_SystemVerilog(config_write_ctrl_first_ratio); // DPI call to imported task
        
            axi4_propagate_config_write_ctrl_first_ratio_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_write_ctrl_first_ratio_from_SystemVerilog( config_write_ctrl_first_ratio );
            end
        end
    end

    function automatic void axi4_local_set_config_write_data_first_ratio_from_SystemVerilog( ref int config_write_data_first_ratio_param );
            axi4_set_config_write_data_first_ratio_from_SystemVerilog(config_write_data_first_ratio); // DPI call to imported task
        
            axi4_propagate_config_write_data_first_ratio_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_write_data_first_ratio_from_SystemVerilog( config_write_data_first_ratio );
            end
        end
    end

    function automatic void axi4_local_set_config_reset_low_clocks_from_SystemVerilog( ref int config_reset_low_clocks_param );
            axi4_set_config_reset_low_clocks_from_SystemVerilog(config_reset_low_clocks); // DPI call to imported task
        
            axi4_propagate_config_reset_low_clocks_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_reset_low_clocks_from_SystemVerilog( config_reset_low_clocks );
            end
        end
    end

    function automatic void axi4_local_set_config_reset_hold_time_from_SystemVerilog( ref int config_reset_hold_time_param );
            axi4_set_config_reset_hold_time_from_SystemVerilog(config_reset_hold_time); // DPI call to imported task
        
            axi4_propagate_config_reset_hold_time_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_reset_hold_time_from_SystemVerilog( config_reset_hold_time );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_rlast_from_SystemVerilog( ref bit config_enable_rlast_param );
            axi4_set_config_enable_rlast_from_SystemVerilog(config_enable_rlast); // DPI call to imported task
        
            axi4_propagate_config_enable_rlast_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_rlast_from_SystemVerilog( config_enable_rlast );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_slave_exclusive_from_SystemVerilog( ref bit config_enable_slave_exclusive_param );
            axi4_set_config_enable_slave_exclusive_from_SystemVerilog(config_enable_slave_exclusive); // DPI call to imported task
        
            axi4_propagate_config_enable_slave_exclusive_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_slave_exclusive_from_SystemVerilog( config_enable_slave_exclusive );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_burst_reserved_value_from_SystemVerilog( ref bit config_enable_burst_reserved_value_param );
            axi4_set_config_enable_burst_reserved_value_from_SystemVerilog(config_enable_burst_reserved_value); // DPI call to imported task
        
            axi4_propagate_config_enable_burst_reserved_value_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_burst_reserved_value_from_SystemVerilog( config_enable_burst_reserved_value );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_cache_value_from_SystemVerilog( ref bit [15:0] config_enable_cache_value_param );
            axi4_set_config_enable_cache_value_from_SystemVerilog(config_enable_cache_value); // DPI call to imported task
        
            axi4_propagate_config_enable_cache_value_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_cache_value_from_SystemVerilog( config_enable_cache_value );
            end
        end
    end

    function automatic void axi4_local_set_internal_dummy_variable_from_SystemVerilog( ref axi4_error_e internal_dummy_variable_param );
        int tmp_internal_dummy_variable;
        tmp_internal_dummy_variable = int'( internal_dummy_variable );
            axi4_set_internal_dummy_variable_from_SystemVerilog(
            tmp_internal_dummy_variable
            ); // DPI call to imported task
        
            axi4_propagate_internal_dummy_variable_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_internal_dummy_variable_from_SystemVerilog( internal_dummy_variable );
            end
        end
    end

    function automatic void axi4_local_set_config_axi4lite_interface_from_SystemVerilog( ref bit config_axi4lite_interface_param );
            axi4_set_config_axi4lite_interface_from_SystemVerilog(config_axi4lite_interface); // DPI call to imported task
        
            axi4_propagate_config_axi4lite_interface_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_axi4lite_interface_from_SystemVerilog( config_axi4lite_interface );
            end
        end
    end

    function automatic void axi4_local_set_config_axi4lite_tr_id_from_SystemVerilog( ref bit [((AXI4_ID_WIDTH) - 1):0]  config_axi4lite_tr_id_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_ID_WIDTH ); _this_dot_1++)
        begin
            axi4_set_config_axi4lite_tr_id_from_SystemVerilog_index1(_this_dot_1,config_axi4lite_tr_id[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
            axi4_propagate_config_axi4lite_tr_id_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_axi4lite_tr_id_from_SystemVerilog( config_axi4lite_tr_id );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_all_assertions_from_SystemVerilog( ref bit config_enable_all_assertions_param );
            axi4_set_config_enable_all_assertions_from_SystemVerilog(config_enable_all_assertions); // DPI call to imported task
        
            axi4_propagate_config_enable_all_assertions_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_all_assertions_from_SystemVerilog( config_enable_all_assertions );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_assertion_from_SystemVerilog( ref bit [255:0] config_enable_assertion_param );
            axi4_set_config_enable_assertion_from_SystemVerilog(config_enable_assertion); // DPI call to imported task
        
            axi4_propagate_config_enable_assertion_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_assertion_from_SystemVerilog( config_enable_assertion );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_error_from_SystemVerilog( ref bit [255:0] config_enable_error_param );
            axi4_set_config_enable_error_from_SystemVerilog(config_enable_error); // DPI call to imported task
        
            axi4_propagate_config_enable_error_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_error_from_SystemVerilog( config_enable_error );
            end
        end
    end

    function automatic void axi4_local_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog( ref int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
            axi4_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog(config_max_latency_AWVALID_assertion_to_AWREADY); // DPI call to imported task
        
            axi4_propagate_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog( config_max_latency_AWVALID_assertion_to_AWREADY );
            end
        end
    end

    function automatic void axi4_local_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog( ref int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
            axi4_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog(config_max_latency_ARVALID_assertion_to_ARREADY); // DPI call to imported task
        
            axi4_propagate_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog( config_max_latency_ARVALID_assertion_to_ARREADY );
            end
        end
    end

    function automatic void axi4_local_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog( ref int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
            axi4_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog(config_max_latency_RVALID_assertion_to_RREADY); // DPI call to imported task
        
            axi4_propagate_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog( config_max_latency_RVALID_assertion_to_RREADY );
            end
        end
    end

    function automatic void axi4_local_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog( ref int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
            axi4_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog(config_max_latency_BVALID_assertion_to_BREADY); // DPI call to imported task
        
            axi4_propagate_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog( config_max_latency_BVALID_assertion_to_BREADY );
            end
        end
    end

    function automatic void axi4_local_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog( ref int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
            axi4_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog(config_max_latency_WVALID_assertion_to_WREADY); // DPI call to imported task
        
            axi4_propagate_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog( config_max_latency_WVALID_assertion_to_WREADY );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_qos_from_SystemVerilog( ref bit config_enable_qos_param );
            axi4_set_config_enable_qos_from_SystemVerilog(config_enable_qos); // DPI call to imported task
        
            axi4_propagate_config_enable_qos_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_qos_from_SystemVerilog( config_enable_qos );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_region_support_from_SystemVerilog( ref bit config_enable_region_support_param );
            axi4_set_config_enable_region_support_from_SystemVerilog(config_enable_region_support); // DPI call to imported task
        
            axi4_propagate_config_enable_region_support_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_region_support_from_SystemVerilog( config_enable_region_support );
            end
        end
    end

    function automatic void axi4_local_set_config_slave_regions_from_SystemVerilog( ref int config_slave_regions_param );
            axi4_set_config_slave_regions_from_SystemVerilog(config_slave_regions); // DPI call to imported task
        
            axi4_propagate_config_slave_regions_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_slave_regions_from_SystemVerilog( config_slave_regions );
            end
        end
    end

    function automatic void axi4_local_set_config_region_from_SystemVerilog( ref bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  config_region_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_REGION_MAP_SIZE ); _this_dot_1++)
        begin
        begin
        for (int _this_dot_2= 0; _this_dot_2 < ( 2 * AXI4_ADDRESS_WIDTH + 4 + 1 ); _this_dot_2++)
        begin
            axi4_set_config_region_from_SystemVerilog_index2(_this_dot_1,_this_dot_2,config_region[_this_dot_1][_this_dot_2]); // DPI call to imported task
        
        end
        end/* 1 */ 
        end
        end/* 2 */ 
            axi4_propagate_config_region_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_region_from_SystemVerilog( config_region );
            end
        end
    end

    function automatic void axi4_local_set_config_read_data_reordering_depth_from_SystemVerilog( ref int unsigned config_read_data_reordering_depth_param );
            axi4_set_config_read_data_reordering_depth_from_SystemVerilog(config_read_data_reordering_depth); // DPI call to imported task
        
            axi4_propagate_config_read_data_reordering_depth_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_read_data_reordering_depth_from_SystemVerilog( config_read_data_reordering_depth );
            end
        end
    end

    function automatic void axi4_local_set_config_slave_start_addr_from_SystemVerilog( ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_ADDRESS_WIDTH ); _this_dot_1++)
        begin
            axi4_set_config_slave_start_addr_from_SystemVerilog_index1(_this_dot_1,config_slave_start_addr[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
            axi4_propagate_config_slave_start_addr_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_slave_start_addr_from_SystemVerilog( config_slave_start_addr );
            end
        end
    end

    function automatic void axi4_local_set_config_slave_end_addr_from_SystemVerilog( ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_ADDRESS_WIDTH ); _this_dot_1++)
        begin
            axi4_set_config_slave_end_addr_from_SystemVerilog_index1(_this_dot_1,config_slave_end_addr[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
            axi4_propagate_config_slave_end_addr_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_slave_end_addr_from_SystemVerilog( config_slave_end_addr );
            end
        end
    end

    function automatic void axi4_local_set_config_slave_enabled_non_contiguous_address_spaces_from_SystemVerilog( ref int config_slave_enabled_non_contiguous_address_spaces_param );
            axi4_set_config_slave_enabled_non_contiguous_address_spaces_from_SystemVerilog(config_slave_enabled_non_contiguous_address_spaces); // DPI call to imported task
        
            axi4_propagate_config_slave_enabled_non_contiguous_address_spaces_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_slave_enabled_non_contiguous_address_spaces_from_SystemVerilog( config_slave_enabled_non_contiguous_address_spaces );
            end
        end
    end

    function automatic void axi4_local_set_config_slave_possess_multiple_non_contiguous_address_spaces_from_SystemVerilog( ref bit config_slave_possess_multiple_non_contiguous_address_spaces_param );
            axi4_set_config_slave_possess_multiple_non_contiguous_address_spaces_from_SystemVerilog(config_slave_possess_multiple_non_contiguous_address_spaces); // DPI call to imported task
        
            axi4_propagate_config_slave_possess_multiple_non_contiguous_address_spaces_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_slave_possess_multiple_non_contiguous_address_spaces_from_SystemVerilog( config_slave_possess_multiple_non_contiguous_address_spaces );
            end
        end
    end

    function automatic void axi4_local_set_config_slave_multiple_non_contiguous_start_address_range_from_SystemVerilog( ref bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_start_address_range_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( 256 ); _this_dot_1++)
        begin
        begin
        for (int _this_dot_2= 0; _this_dot_2 < ( AXI4_ADDRESS_WIDTH ); _this_dot_2++)
        begin
            axi4_set_config_slave_multiple_non_contiguous_start_address_range_from_SystemVerilog_index2(_this_dot_1,_this_dot_2,config_slave_multiple_non_contiguous_start_address_range[_this_dot_1][_this_dot_2]); // DPI call to imported task
        
        end
        end/* 1 */ 
        end
        end/* 2 */ 
            axi4_propagate_config_slave_multiple_non_contiguous_start_address_range_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_slave_multiple_non_contiguous_start_address_range_from_SystemVerilog( config_slave_multiple_non_contiguous_start_address_range );
            end
        end
    end

    function automatic void axi4_local_set_config_slave_multiple_non_contiguous_end_address_range_from_SystemVerilog( ref bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_end_address_range_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( 256 ); _this_dot_1++)
        begin
        begin
        for (int _this_dot_2= 0; _this_dot_2 < ( AXI4_ADDRESS_WIDTH ); _this_dot_2++)
        begin
            axi4_set_config_slave_multiple_non_contiguous_end_address_range_from_SystemVerilog_index2(_this_dot_1,_this_dot_2,config_slave_multiple_non_contiguous_end_address_range[_this_dot_1][_this_dot_2]); // DPI call to imported task
        
        end
        end/* 1 */ 
        end
        end/* 2 */ 
            axi4_propagate_config_slave_multiple_non_contiguous_end_address_range_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_slave_multiple_non_contiguous_end_address_range_from_SystemVerilog( config_slave_multiple_non_contiguous_end_address_range );
            end
        end
    end

    function automatic void axi4_local_set_config_protect_ready_from_SystemVerilog( ref bit config_protect_ready_param );
            axi4_set_config_protect_ready_from_SystemVerilog(config_protect_ready); // DPI call to imported task
        
            axi4_propagate_config_protect_ready_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_protect_ready_from_SystemVerilog( config_protect_ready );
            end
        end
    end

    function automatic void axi4_local_set_config_max_outstanding_wr_from_SystemVerilog( ref int config_max_outstanding_wr_param );
            axi4_set_config_max_outstanding_wr_from_SystemVerilog(config_max_outstanding_wr); // DPI call to imported task
        
            axi4_propagate_config_max_outstanding_wr_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_outstanding_wr_from_SystemVerilog( config_max_outstanding_wr );
            end
        end
    end

    function automatic void axi4_local_set_config_max_outstanding_rd_from_SystemVerilog( ref int config_max_outstanding_rd_param );
            axi4_set_config_max_outstanding_rd_from_SystemVerilog(config_max_outstanding_rd); // DPI call to imported task
        
            axi4_propagate_config_max_outstanding_rd_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_outstanding_rd_from_SystemVerilog( config_max_outstanding_rd );
            end
        end
    end

    function automatic void axi4_local_set_config_num_outstanding_wr_phase_from_SystemVerilog( ref int config_num_outstanding_wr_phase_param );
            axi4_set_config_num_outstanding_wr_phase_from_SystemVerilog(config_num_outstanding_wr_phase); // DPI call to imported task
        
            axi4_propagate_config_num_outstanding_wr_phase_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_num_outstanding_wr_phase_from_SystemVerilog( config_num_outstanding_wr_phase );
            end
        end
    end

    function automatic void axi4_local_set_config_num_outstanding_rd_phase_from_SystemVerilog( ref int config_num_outstanding_rd_phase_param );
            axi4_set_config_num_outstanding_rd_phase_from_SystemVerilog(config_num_outstanding_rd_phase); // DPI call to imported task
        
            axi4_propagate_config_num_outstanding_rd_phase_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_num_outstanding_rd_phase_from_SystemVerilog( config_num_outstanding_rd_phase );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_warnings_from_SystemVerilog( ref bit config_enable_warnings_param );
            axi4_set_config_enable_warnings_from_SystemVerilog(config_enable_warnings); // DPI call to imported task
        
            axi4_propagate_config_enable_warnings_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_warnings_from_SystemVerilog( config_enable_warnings );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_errors_from_SystemVerilog( ref bit config_enable_errors_param );
            axi4_set_config_enable_errors_from_SystemVerilog(config_enable_errors); // DPI call to imported task
        
            axi4_propagate_config_enable_errors_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_errors_from_SystemVerilog( config_enable_errors );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_exclusive_checks_from_SystemVerilog( ref bit config_enable_exclusive_checks_param );
            axi4_set_config_enable_exclusive_checks_from_SystemVerilog(config_enable_exclusive_checks); // DPI call to imported task
        
            axi4_propagate_config_enable_exclusive_checks_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_exclusive_checks_from_SystemVerilog( config_enable_exclusive_checks );
            end
        end
    end

    function automatic void axi4_local_set_config_warn_on_slave_errors_from_SystemVerilog( ref bit config_warn_on_slave_errors_param );
            axi4_set_config_warn_on_slave_errors_from_SystemVerilog(config_warn_on_slave_errors); // DPI call to imported task
        
            axi4_propagate_config_warn_on_slave_errors_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_warn_on_slave_errors_from_SystemVerilog( config_warn_on_slave_errors );
            end
        end
    end

    function automatic void axi4_local_set_config_error_on_deleted_valid_cycles_from_SystemVerilog( ref bit config_error_on_deleted_valid_cycles_param );
            axi4_set_config_error_on_deleted_valid_cycles_from_SystemVerilog(config_error_on_deleted_valid_cycles); // DPI call to imported task
        
            axi4_propagate_config_error_on_deleted_valid_cycles_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_error_on_deleted_valid_cycles_from_SystemVerilog( config_error_on_deleted_valid_cycles );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_from_SystemVerilog( ref bit config_stats_enable_param );
            axi4_set_config_stats_enable_from_SystemVerilog(config_stats_enable); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_from_SystemVerilog( config_stats_enable );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_read_occupancy_from_SystemVerilog( ref bit config_stats_enable_read_occupancy_param );
            axi4_set_config_stats_enable_read_occupancy_from_SystemVerilog(config_stats_enable_read_occupancy); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_read_occupancy_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_read_occupancy_from_SystemVerilog( config_stats_enable_read_occupancy );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_write_occupancy_from_SystemVerilog( ref bit config_stats_enable_write_occupancy_param );
            axi4_set_config_stats_enable_write_occupancy_from_SystemVerilog(config_stats_enable_write_occupancy); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_write_occupancy_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_write_occupancy_from_SystemVerilog( config_stats_enable_write_occupancy );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_read_data_occupancy_from_SystemVerilog( ref bit config_stats_enable_read_data_occupancy_param );
            axi4_set_config_stats_enable_read_data_occupancy_from_SystemVerilog(config_stats_enable_read_data_occupancy); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_read_data_occupancy_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_read_data_occupancy_from_SystemVerilog( config_stats_enable_read_data_occupancy );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_write_data_occupancy_from_SystemVerilog( ref bit config_stats_enable_write_data_occupancy_param );
            axi4_set_config_stats_enable_write_data_occupancy_from_SystemVerilog(config_stats_enable_write_data_occupancy); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_write_data_occupancy_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_write_data_occupancy_from_SystemVerilog( config_stats_enable_write_data_occupancy );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_read_latency_from_SystemVerilog( ref bit config_stats_enable_read_latency_param );
            axi4_set_config_stats_enable_read_latency_from_SystemVerilog(config_stats_enable_read_latency); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_read_latency_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_read_latency_from_SystemVerilog( config_stats_enable_read_latency );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_write_latency_from_SystemVerilog( ref bit config_stats_enable_write_latency_param );
            axi4_set_config_stats_enable_write_latency_from_SystemVerilog(config_stats_enable_write_latency); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_write_latency_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_write_latency_from_SystemVerilog( config_stats_enable_write_latency );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_read_address_waits_from_SystemVerilog( ref bit config_stats_enable_read_address_waits_param );
            axi4_set_config_stats_enable_read_address_waits_from_SystemVerilog(config_stats_enable_read_address_waits); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_read_address_waits_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_read_address_waits_from_SystemVerilog( config_stats_enable_read_address_waits );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_read_data_waits_from_SystemVerilog( ref bit config_stats_enable_read_data_waits_param );
            axi4_set_config_stats_enable_read_data_waits_from_SystemVerilog(config_stats_enable_read_data_waits); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_read_data_waits_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_read_data_waits_from_SystemVerilog( config_stats_enable_read_data_waits );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_write_address_waits_from_SystemVerilog( ref bit config_stats_enable_write_address_waits_param );
            axi4_set_config_stats_enable_write_address_waits_from_SystemVerilog(config_stats_enable_write_address_waits); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_write_address_waits_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_write_address_waits_from_SystemVerilog( config_stats_enable_write_address_waits );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_write_data_waits_from_SystemVerilog( ref bit config_stats_enable_write_data_waits_param );
            axi4_set_config_stats_enable_write_data_waits_from_SystemVerilog(config_stats_enable_write_data_waits); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_write_data_waits_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_write_data_waits_from_SystemVerilog( config_stats_enable_write_data_waits );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_write_response_waits_from_SystemVerilog( ref bit config_stats_enable_write_response_waits_param );
            axi4_set_config_stats_enable_write_response_waits_from_SystemVerilog(config_stats_enable_write_response_waits); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_write_response_waits_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_write_response_waits_from_SystemVerilog( config_stats_enable_write_response_waits );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_read_bandwidth_from_SystemVerilog( ref bit config_stats_enable_read_bandwidth_param );
            axi4_set_config_stats_enable_read_bandwidth_from_SystemVerilog(config_stats_enable_read_bandwidth); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_read_bandwidth_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_read_bandwidth_from_SystemVerilog( config_stats_enable_read_bandwidth );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_write_bandwidth_from_SystemVerilog( ref bit config_stats_enable_write_bandwidth_param );
            axi4_set_config_stats_enable_write_bandwidth_from_SystemVerilog(config_stats_enable_write_bandwidth); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_write_bandwidth_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_write_bandwidth_from_SystemVerilog( config_stats_enable_write_bandwidth );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_occupancy_step_from_SystemVerilog( ref int config_stats_read_occupancy_step_param );
            axi4_set_config_stats_read_occupancy_step_from_SystemVerilog(config_stats_read_occupancy_step); // DPI call to imported task
        
            axi4_propagate_config_stats_read_occupancy_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_occupancy_step_from_SystemVerilog( config_stats_read_occupancy_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_occupancy_multiple_from_SystemVerilog( ref int config_stats_read_occupancy_multiple_param );
            axi4_set_config_stats_read_occupancy_multiple_from_SystemVerilog(config_stats_read_occupancy_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_read_occupancy_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_occupancy_multiple_from_SystemVerilog( config_stats_read_occupancy_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_occupancy_step_from_SystemVerilog( ref int config_stats_write_occupancy_step_param );
            axi4_set_config_stats_write_occupancy_step_from_SystemVerilog(config_stats_write_occupancy_step); // DPI call to imported task
        
            axi4_propagate_config_stats_write_occupancy_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_occupancy_step_from_SystemVerilog( config_stats_write_occupancy_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_occupancy_multiple_from_SystemVerilog( ref int config_stats_write_occupancy_multiple_param );
            axi4_set_config_stats_write_occupancy_multiple_from_SystemVerilog(config_stats_write_occupancy_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_write_occupancy_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_occupancy_multiple_from_SystemVerilog( config_stats_write_occupancy_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_data_occupancy_step_from_SystemVerilog( ref int config_stats_read_data_occupancy_step_param );
            axi4_set_config_stats_read_data_occupancy_step_from_SystemVerilog(config_stats_read_data_occupancy_step); // DPI call to imported task
        
            axi4_propagate_config_stats_read_data_occupancy_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_data_occupancy_step_from_SystemVerilog( config_stats_read_data_occupancy_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog( ref int config_stats_read_data_occupancy_multiple_param );
            axi4_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog(config_stats_read_data_occupancy_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_read_data_occupancy_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog( config_stats_read_data_occupancy_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_data_occupancy_step_from_SystemVerilog( ref int config_stats_write_data_occupancy_step_param );
            axi4_set_config_stats_write_data_occupancy_step_from_SystemVerilog(config_stats_write_data_occupancy_step); // DPI call to imported task
        
            axi4_propagate_config_stats_write_data_occupancy_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_data_occupancy_step_from_SystemVerilog( config_stats_write_data_occupancy_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog( ref int config_stats_write_data_occupancy_multiple_param );
            axi4_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog(config_stats_write_data_occupancy_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_write_data_occupancy_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog( config_stats_write_data_occupancy_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_bandwidth_step_from_SystemVerilog( ref int config_stats_read_bandwidth_step_param );
            axi4_set_config_stats_read_bandwidth_step_from_SystemVerilog(config_stats_read_bandwidth_step); // DPI call to imported task
        
            axi4_propagate_config_stats_read_bandwidth_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_bandwidth_step_from_SystemVerilog( config_stats_read_bandwidth_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_bandwidth_multiple_from_SystemVerilog( ref int config_stats_read_bandwidth_multiple_param );
            axi4_set_config_stats_read_bandwidth_multiple_from_SystemVerilog(config_stats_read_bandwidth_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_read_bandwidth_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_bandwidth_multiple_from_SystemVerilog( config_stats_read_bandwidth_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_bandwidth_step_from_SystemVerilog( ref int config_stats_write_bandwidth_step_param );
            axi4_set_config_stats_write_bandwidth_step_from_SystemVerilog(config_stats_write_bandwidth_step); // DPI call to imported task
        
            axi4_propagate_config_stats_write_bandwidth_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_bandwidth_step_from_SystemVerilog( config_stats_write_bandwidth_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_bandwidth_multiple_from_SystemVerilog( ref int config_stats_write_bandwidth_multiple_param );
            axi4_set_config_stats_write_bandwidth_multiple_from_SystemVerilog(config_stats_write_bandwidth_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_write_bandwidth_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_bandwidth_multiple_from_SystemVerilog( config_stats_write_bandwidth_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_latency_step_from_SystemVerilog( ref int config_stats_read_latency_step_param );
            axi4_set_config_stats_read_latency_step_from_SystemVerilog(config_stats_read_latency_step); // DPI call to imported task
        
            axi4_propagate_config_stats_read_latency_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_latency_step_from_SystemVerilog( config_stats_read_latency_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_latency_multiple_from_SystemVerilog( ref int config_stats_read_latency_multiple_param );
            axi4_set_config_stats_read_latency_multiple_from_SystemVerilog(config_stats_read_latency_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_read_latency_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_latency_multiple_from_SystemVerilog( config_stats_read_latency_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_latency_step_from_SystemVerilog( ref int config_stats_write_latency_step_param );
            axi4_set_config_stats_write_latency_step_from_SystemVerilog(config_stats_write_latency_step); // DPI call to imported task
        
            axi4_propagate_config_stats_write_latency_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_latency_step_from_SystemVerilog( config_stats_write_latency_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_latency_multiple_from_SystemVerilog( ref int config_stats_write_latency_multiple_param );
            axi4_set_config_stats_write_latency_multiple_from_SystemVerilog(config_stats_write_latency_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_write_latency_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_latency_multiple_from_SystemVerilog( config_stats_write_latency_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_address_waits_step_from_SystemVerilog( ref int config_stats_read_address_waits_step_param );
            axi4_set_config_stats_read_address_waits_step_from_SystemVerilog(config_stats_read_address_waits_step); // DPI call to imported task
        
            axi4_propagate_config_stats_read_address_waits_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_address_waits_step_from_SystemVerilog( config_stats_read_address_waits_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_address_waits_multiple_from_SystemVerilog( ref int config_stats_read_address_waits_multiple_param );
            axi4_set_config_stats_read_address_waits_multiple_from_SystemVerilog(config_stats_read_address_waits_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_read_address_waits_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_address_waits_multiple_from_SystemVerilog( config_stats_read_address_waits_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_data_waits_step_from_SystemVerilog( ref int config_stats_read_data_waits_step_param );
            axi4_set_config_stats_read_data_waits_step_from_SystemVerilog(config_stats_read_data_waits_step); // DPI call to imported task
        
            axi4_propagate_config_stats_read_data_waits_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_data_waits_step_from_SystemVerilog( config_stats_read_data_waits_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_data_waits_multiple_from_SystemVerilog( ref int config_stats_read_data_waits_multiple_param );
            axi4_set_config_stats_read_data_waits_multiple_from_SystemVerilog(config_stats_read_data_waits_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_read_data_waits_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_data_waits_multiple_from_SystemVerilog( config_stats_read_data_waits_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_address_waits_step_from_SystemVerilog( ref int config_stats_write_address_waits_step_param );
            axi4_set_config_stats_write_address_waits_step_from_SystemVerilog(config_stats_write_address_waits_step); // DPI call to imported task
        
            axi4_propagate_config_stats_write_address_waits_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_address_waits_step_from_SystemVerilog( config_stats_write_address_waits_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_address_waits_multiple_from_SystemVerilog( ref int config_stats_write_address_waits_multiple_param );
            axi4_set_config_stats_write_address_waits_multiple_from_SystemVerilog(config_stats_write_address_waits_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_write_address_waits_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_address_waits_multiple_from_SystemVerilog( config_stats_write_address_waits_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_data_waits_step_from_SystemVerilog( ref int config_stats_write_data_waits_step_param );
            axi4_set_config_stats_write_data_waits_step_from_SystemVerilog(config_stats_write_data_waits_step); // DPI call to imported task
        
            axi4_propagate_config_stats_write_data_waits_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_data_waits_step_from_SystemVerilog( config_stats_write_data_waits_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_data_waits_multiple_from_SystemVerilog( ref int config_stats_write_data_waits_multiple_param );
            axi4_set_config_stats_write_data_waits_multiple_from_SystemVerilog(config_stats_write_data_waits_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_write_data_waits_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_data_waits_multiple_from_SystemVerilog( config_stats_write_data_waits_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_response_waits_step_from_SystemVerilog( ref int config_stats_write_response_waits_step_param );
            axi4_set_config_stats_write_response_waits_step_from_SystemVerilog(config_stats_write_response_waits_step); // DPI call to imported task
        
            axi4_propagate_config_stats_write_response_waits_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_response_waits_step_from_SystemVerilog( config_stats_write_response_waits_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_response_waits_multiple_from_SystemVerilog( ref int config_stats_write_response_waits_multiple_param );
            axi4_set_config_stats_write_response_waits_multiple_from_SystemVerilog(config_stats_write_response_waits_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_write_response_waits_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_response_waits_multiple_from_SystemVerilog( config_stats_write_response_waits_multiple );
            end
        end
    end

    //------------------------------------------------------------------------------
    // Transaction interface
    //------------------------------------------------------------------------------

    bit [((AXI4_ADDRESS_WIDTH) - 1):0]  temp_static_rw_transaction_addr;
    function void axi4_get_temp_static_rw_transaction_addr( input int _d1, output bit  _value );
        _value = temp_static_rw_transaction_addr[_d1];
    endfunction
    function void axi4_set_temp_static_rw_transaction_addr( input int _d1, input bit  _value );
        temp_static_rw_transaction_addr[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_rw_transaction_id;
    function void axi4_get_temp_static_rw_transaction_id( input int _d1, output bit  _value );
        _value = temp_static_rw_transaction_id[_d1];
    endfunction
    function void axi4_set_temp_static_rw_transaction_id( input int _d1, input bit  _value );
        temp_static_rw_transaction_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_rw_transaction_addr_user_data;
    function void axi4_get_temp_static_rw_transaction_addr_user_data( input int _d1, output bit  _value );
        _value = temp_static_rw_transaction_addr_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_rw_transaction_addr_user_data( input int _d1, input bit  _value );
        temp_static_rw_transaction_addr_user_data[_d1] = _value;
    endfunction
    bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] temp_static_rw_transaction_data_words [];
    function void axi4_get_temp_static_rw_transaction_data_words( input int _d1, input int _d2, output bit _value );
        _value = temp_static_rw_transaction_data_words[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_rw_transaction_data_words( input int _d1, input int _d2, input bit _value );
        temp_static_rw_transaction_data_words[_d1][_d2] = _value;
    endfunction
    bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] temp_static_rw_transaction_write_strobes [];
    function void axi4_get_temp_static_rw_transaction_write_strobes( input int _d1, input int _d2, output bit _value );
        _value = temp_static_rw_transaction_write_strobes[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_rw_transaction_write_strobes( input int _d1, input int _d2, input bit _value );
        temp_static_rw_transaction_write_strobes[_d1][_d2] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0] temp_static_rw_transaction_wdata_user_data [];
    function void axi4_get_temp_static_rw_transaction_wdata_user_data( input int _d1, input int _d2, output bit _value );
        _value = temp_static_rw_transaction_wdata_user_data[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_rw_transaction_wdata_user_data( input int _d1, input int _d2, input bit _value );
        temp_static_rw_transaction_wdata_user_data[_d1][_d2] = _value;
    endfunction
    int temp_static_rw_transaction_resp[];
    function void axi4_get_temp_static_rw_transaction_resp( input int _d1, output int _value );
        _value = temp_static_rw_transaction_resp[_d1];
    endfunction
    function void axi4_set_temp_static_rw_transaction_resp( input int _d1, input int _value );
        temp_static_rw_transaction_resp[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0] temp_static_rw_transaction_resp_user_data [];
    function void axi4_get_temp_static_rw_transaction_resp_user_data( input int _d1, input int _d2, output bit _value );
        _value = temp_static_rw_transaction_resp_user_data[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_rw_transaction_resp_user_data( input int _d1, input int _d2, input bit _value );
        temp_static_rw_transaction_resp_user_data[_d1][_d2] = _value;
    endfunction
    int temp_static_rw_transaction_data_valid_delay[];
    function void axi4_get_temp_static_rw_transaction_data_valid_delay( input int _d1, output int _value );
        _value = temp_static_rw_transaction_data_valid_delay[_d1];
    endfunction
    function void axi4_set_temp_static_rw_transaction_data_valid_delay( input int _d1, input int _value );
        temp_static_rw_transaction_data_valid_delay[_d1] = _value;
    endfunction
    int temp_static_rw_transaction_data_ready_delay[];
    function void axi4_get_temp_static_rw_transaction_data_ready_delay( input int _d1, output int _value );
        _value = temp_static_rw_transaction_data_ready_delay[_d1];
    endfunction
    function void axi4_set_temp_static_rw_transaction_data_ready_delay( input int _d1, input int _value );
        temp_static_rw_transaction_data_ready_delay[_d1] = _value;
    endfunction
    int temp_static_rw_transaction_write_data_beats_delay[];
    function void axi4_get_temp_static_rw_transaction_write_data_beats_delay( input int _d1, output int _value );
        _value = temp_static_rw_transaction_write_data_beats_delay[_d1];
    endfunction
    function void axi4_set_temp_static_rw_transaction_write_data_beats_delay( input int _d1, input int _value );
        temp_static_rw_transaction_write_data_beats_delay[_d1] = _value;
    endfunction
    bit [((AXI4_ADDRESS_WIDTH) - 1):0]  temp_static_read_addr;
    function void axi4_get_temp_static_read_addr( input int _d1, output bit  _value );
        _value = temp_static_read_addr[_d1];
    endfunction
    function void axi4_set_temp_static_read_addr( input int _d1, input bit  _value );
        temp_static_read_addr[_d1] = _value;
    endfunction
    int temp_static_read_rresp_delays[255:0];
    function void axi4_get_temp_static_read_rresp_delays( input int _d1, output int _value );
        _value = temp_static_read_rresp_delays[_d1];
    endfunction
    function void axi4_set_temp_static_read_rresp_delays( input int _d1, input int _value );
        temp_static_read_rresp_delays[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_read_id;
    function void axi4_get_temp_static_read_id( input int _d1, output bit  _value );
        _value = temp_static_read_id[_d1];
    endfunction
    function void axi4_set_temp_static_read_id( input int _d1, input bit  _value );
        temp_static_read_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_read_addr_user_data;
    function void axi4_get_temp_static_read_addr_user_data( input int _d1, output bit  _value );
        _value = temp_static_read_addr_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_read_addr_user_data( input int _d1, input bit  _value );
        temp_static_read_addr_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_RDATA_WIDTH) - 1):0] temp_static_read_data_words [];
    function void axi4_get_temp_static_read_data_words( input int _d1, input int _d2, output bit _value );
        _value = temp_static_read_data_words[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_read_data_words( input int _d1, input int _d2, input bit _value );
        temp_static_read_data_words[_d1][_d2] = _value;
    endfunction
    int temp_static_read_resp[];
    function void axi4_get_temp_static_read_resp( input int _d1, output int _value );
        _value = temp_static_read_resp[_d1];
    endfunction
    function void axi4_set_temp_static_read_resp( input int _d1, input int _value );
        temp_static_read_resp[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0] temp_static_read_resp_user_data [];
    function void axi4_get_temp_static_read_resp_user_data( input int _d1, input int _d2, output bit _value );
        _value = temp_static_read_resp_user_data[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_read_resp_user_data( input int _d1, input int _d2, input bit _value );
        temp_static_read_resp_user_data[_d1][_d2] = _value;
    endfunction
    longint temp_static_read_data_start_time[];
    function void axi4_get_temp_static_read_data_start_time( input int _d1, output longint _value );
        _value = temp_static_read_data_start_time[_d1];
    endfunction
    function void axi4_set_temp_static_read_data_start_time( input int _d1, input longint _value );
        temp_static_read_data_start_time[_d1] = _value;
    endfunction
    longint temp_static_read_data_end_time[];
    function void axi4_get_temp_static_read_data_end_time( input int _d1, output longint _value );
        _value = temp_static_read_data_end_time[_d1];
    endfunction
    function void axi4_set_temp_static_read_data_end_time( input int _d1, input longint _value );
        temp_static_read_data_end_time[_d1] = _value;
    endfunction
    bit [((AXI4_ADDRESS_WIDTH) - 1):0]  temp_static_write_addr;
    function void axi4_get_temp_static_write_addr( input int _d1, output bit  _value );
        _value = temp_static_write_addr[_d1];
    endfunction
    function void axi4_set_temp_static_write_addr( input int _d1, input bit  _value );
        temp_static_write_addr[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_write_id;
    function void axi4_get_temp_static_write_id( input int _d1, output bit  _value );
        _value = temp_static_write_id[_d1];
    endfunction
    function void axi4_set_temp_static_write_id( input int _d1, input bit  _value );
        temp_static_write_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_write_addr_user_data;
    function void axi4_get_temp_static_write_addr_user_data( input int _d1, output bit  _value );
        _value = temp_static_write_addr_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_write_addr_user_data( input int _d1, input bit  _value );
        temp_static_write_addr_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_WDATA_WIDTH) - 1):0] temp_static_write_data_words [];
    function void axi4_get_temp_static_write_data_words( input int _d1, input int _d2, output bit _value );
        _value = temp_static_write_data_words[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_write_data_words( input int _d1, input int _d2, input bit _value );
        temp_static_write_data_words[_d1][_d2] = _value;
    endfunction
    bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] temp_static_write_write_strobes [];
    function void axi4_get_temp_static_write_write_strobes( input int _d1, input int _d2, output bit _value );
        _value = temp_static_write_write_strobes[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_write_write_strobes( input int _d1, input int _d2, input bit _value );
        temp_static_write_write_strobes[_d1][_d2] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0] temp_static_write_wdata_user_data [];
    function void axi4_get_temp_static_write_wdata_user_data( input int _d1, input int _d2, output bit _value );
        _value = temp_static_write_wdata_user_data[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_write_wdata_user_data( input int _d1, input int _d2, input bit _value );
        temp_static_write_wdata_user_data[_d1][_d2] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_write_resp_user_data;
    function void axi4_get_temp_static_write_resp_user_data( input int _d1, output bit  _value );
        _value = temp_static_write_resp_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_write_resp_user_data( input int _d1, input bit  _value );
        temp_static_write_resp_user_data[_d1] = _value;
    endfunction
    longint temp_static_write_data_start_time[];
    function void axi4_get_temp_static_write_data_start_time( input int _d1, output longint _value );
        _value = temp_static_write_data_start_time[_d1];
    endfunction
    function void axi4_set_temp_static_write_data_start_time( input int _d1, input longint _value );
        temp_static_write_data_start_time[_d1] = _value;
    endfunction
    longint temp_static_write_data_end_time[];
    function void axi4_get_temp_static_write_data_end_time( input int _d1, output longint _value );
        _value = temp_static_write_data_end_time[_d1];
    endfunction
    function void axi4_set_temp_static_write_data_end_time( input int _d1, input longint _value );
        temp_static_write_data_end_time[_d1] = _value;
    endfunction
    int temp_static_write_write_data_beats_delay[];
    function void axi4_get_temp_static_write_write_data_beats_delay( input int _d1, output int _value );
        _value = temp_static_write_write_data_beats_delay[_d1];
    endfunction
    function void axi4_set_temp_static_write_write_data_beats_delay( input int _d1, input int _value );
        temp_static_write_write_data_beats_delay[_d1] = _value;
    endfunction
    bit [((AXI4_WDATA_WIDTH) - 1):0] temp_static_write_data_burst_data_words [];
    function void axi4_get_temp_static_write_data_burst_data_words( input int _d1, input int _d2, output bit _value );
        _value = temp_static_write_data_burst_data_words[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_write_data_burst_data_words( input int _d1, input int _d2, input bit _value );
        temp_static_write_data_burst_data_words[_d1][_d2] = _value;
    endfunction
    bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] temp_static_write_data_burst_write_strobes [];
    function void axi4_get_temp_static_write_data_burst_write_strobes( input int _d1, input int _d2, output bit _value );
        _value = temp_static_write_data_burst_write_strobes[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_write_data_burst_write_strobes( input int _d1, input int _d2, input bit _value );
        temp_static_write_data_burst_write_strobes[_d1][_d2] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0] temp_static_write_data_burst_user_data [];
    function void axi4_get_temp_static_write_data_burst_user_data( input int _d1, input int _d2, output bit _value );
        _value = temp_static_write_data_burst_user_data[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_write_data_burst_user_data( input int _d1, input int _d2, input bit _value );
        temp_static_write_data_burst_user_data[_d1][_d2] = _value;
    endfunction
    longint temp_static_write_data_burst_data_start_time[];
    function void axi4_get_temp_static_write_data_burst_data_start_time( input int _d1, output longint _value );
        _value = temp_static_write_data_burst_data_start_time[_d1];
    endfunction
    function void axi4_set_temp_static_write_data_burst_data_start_time( input int _d1, input longint _value );
        temp_static_write_data_burst_data_start_time[_d1] = _value;
    endfunction
    longint temp_static_write_data_burst_data_end_time[];
    function void axi4_get_temp_static_write_data_burst_data_end_time( input int _d1, output longint _value );
        _value = temp_static_write_data_burst_data_end_time[_d1];
    endfunction
    function void axi4_set_temp_static_write_data_burst_data_end_time( input int _d1, input longint _value );
        temp_static_write_data_burst_data_end_time[_d1] = _value;
    endfunction
    int temp_static_write_data_burst_write_data_beats_delay[];
    function void axi4_get_temp_static_write_data_burst_write_data_beats_delay( input int _d1, output int _value );
        _value = temp_static_write_data_burst_write_data_beats_delay[_d1];
    endfunction
    function void axi4_set_temp_static_write_data_burst_write_data_beats_delay( input int _d1, input int _value );
        temp_static_write_data_burst_write_data_beats_delay[_d1] = _value;
    endfunction
    bit [((AXI4_ADDRESS_WIDTH) - 1):0]  temp_static_read_addr_channel_phase_addr;
    function void axi4_get_temp_static_read_addr_channel_phase_addr( input int _d1, output bit  _value );
        _value = temp_static_read_addr_channel_phase_addr[_d1];
    endfunction
    function void axi4_set_temp_static_read_addr_channel_phase_addr( input int _d1, input bit  _value );
        temp_static_read_addr_channel_phase_addr[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_read_addr_channel_phase_id;
    function void axi4_get_temp_static_read_addr_channel_phase_id( input int _d1, output bit  _value );
        _value = temp_static_read_addr_channel_phase_id[_d1];
    endfunction
    function void axi4_set_temp_static_read_addr_channel_phase_id( input int _d1, input bit  _value );
        temp_static_read_addr_channel_phase_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_read_addr_channel_phase_addr_user;
    function void axi4_get_temp_static_read_addr_channel_phase_addr_user( input int _d1, output bit  _value );
        _value = temp_static_read_addr_channel_phase_addr_user[_d1];
    endfunction
    function void axi4_set_temp_static_read_addr_channel_phase_addr_user( input int _d1, input bit  _value );
        temp_static_read_addr_channel_phase_addr_user[_d1] = _value;
    endfunction
    bit [((AXI4_RDATA_WIDTH) - 1):0]  temp_static_read_channel_phase_data;
    function void axi4_get_temp_static_read_channel_phase_data( input int _d1, output bit  _value );
        _value = temp_static_read_channel_phase_data[_d1];
    endfunction
    function void axi4_set_temp_static_read_channel_phase_data( input int _d1, input bit  _value );
        temp_static_read_channel_phase_data[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_read_channel_phase_id;
    function void axi4_get_temp_static_read_channel_phase_id( input int _d1, output bit  _value );
        _value = temp_static_read_channel_phase_id[_d1];
    endfunction
    function void axi4_set_temp_static_read_channel_phase_id( input int _d1, input bit  _value );
        temp_static_read_channel_phase_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_read_channel_phase_user_data;
    function void axi4_get_temp_static_read_channel_phase_user_data( input int _d1, output bit  _value );
        _value = temp_static_read_channel_phase_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_read_channel_phase_user_data( input int _d1, input bit  _value );
        temp_static_read_channel_phase_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_ADDRESS_WIDTH) - 1):0]  temp_static_write_addr_channel_phase_addr;
    function void axi4_get_temp_static_write_addr_channel_phase_addr( input int _d1, output bit  _value );
        _value = temp_static_write_addr_channel_phase_addr[_d1];
    endfunction
    function void axi4_set_temp_static_write_addr_channel_phase_addr( input int _d1, input bit  _value );
        temp_static_write_addr_channel_phase_addr[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_write_addr_channel_phase_id;
    function void axi4_get_temp_static_write_addr_channel_phase_id( input int _d1, output bit  _value );
        _value = temp_static_write_addr_channel_phase_id[_d1];
    endfunction
    function void axi4_set_temp_static_write_addr_channel_phase_id( input int _d1, input bit  _value );
        temp_static_write_addr_channel_phase_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_write_addr_channel_phase_addr_user;
    function void axi4_get_temp_static_write_addr_channel_phase_addr_user( input int _d1, output bit  _value );
        _value = temp_static_write_addr_channel_phase_addr_user[_d1];
    endfunction
    function void axi4_set_temp_static_write_addr_channel_phase_addr_user( input int _d1, input bit  _value );
        temp_static_write_addr_channel_phase_addr_user[_d1] = _value;
    endfunction
    bit [((AXI4_WDATA_WIDTH) - 1):0]  temp_static_write_channel_phase_data;
    function void axi4_get_temp_static_write_channel_phase_data( input int _d1, output bit  _value );
        _value = temp_static_write_channel_phase_data[_d1];
    endfunction
    function void axi4_set_temp_static_write_channel_phase_data( input int _d1, input bit  _value );
        temp_static_write_channel_phase_data[_d1] = _value;
    endfunction
    bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  temp_static_write_channel_phase_write_strobes;
    function void axi4_get_temp_static_write_channel_phase_write_strobes( input int _d1, output bit  _value );
        _value = temp_static_write_channel_phase_write_strobes[_d1];
    endfunction
    function void axi4_set_temp_static_write_channel_phase_write_strobes( input int _d1, input bit  _value );
        temp_static_write_channel_phase_write_strobes[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_write_channel_phase_user_data;
    function void axi4_get_temp_static_write_channel_phase_user_data( input int _d1, output bit  _value );
        _value = temp_static_write_channel_phase_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_write_channel_phase_user_data( input int _d1, input bit  _value );
        temp_static_write_channel_phase_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_write_resp_channel_phase_id;
    function void axi4_get_temp_static_write_resp_channel_phase_id( input int _d1, output bit  _value );
        _value = temp_static_write_resp_channel_phase_id[_d1];
    endfunction
    function void axi4_set_temp_static_write_resp_channel_phase_id( input int _d1, input bit  _value );
        temp_static_write_resp_channel_phase_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_write_resp_channel_phase_user_data;
    function void axi4_get_temp_static_write_resp_channel_phase_user_data( input int _d1, output bit  _value );
        _value = temp_static_write_resp_channel_phase_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_write_resp_channel_phase_user_data( input int _d1, input bit  _value );
        temp_static_write_resp_channel_phase_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_ADDRESS_WIDTH) - 1):0]  temp_static_read_addr_channel_cycle_addr;
    function void axi4_get_temp_static_read_addr_channel_cycle_addr( input int _d1, output bit  _value );
        _value = temp_static_read_addr_channel_cycle_addr[_d1];
    endfunction
    function void axi4_set_temp_static_read_addr_channel_cycle_addr( input int _d1, input bit  _value );
        temp_static_read_addr_channel_cycle_addr[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_read_addr_channel_cycle_id;
    function void axi4_get_temp_static_read_addr_channel_cycle_id( input int _d1, output bit  _value );
        _value = temp_static_read_addr_channel_cycle_id[_d1];
    endfunction
    function void axi4_set_temp_static_read_addr_channel_cycle_id( input int _d1, input bit  _value );
        temp_static_read_addr_channel_cycle_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_read_addr_channel_cycle_user_data;
    function void axi4_get_temp_static_read_addr_channel_cycle_user_data( input int _d1, output bit  _value );
        _value = temp_static_read_addr_channel_cycle_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_read_addr_channel_cycle_user_data( input int _d1, input bit  _value );
        temp_static_read_addr_channel_cycle_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_RDATA_WIDTH) - 1):0]  temp_static_read_channel_cycle_data;
    function void axi4_get_temp_static_read_channel_cycle_data( input int _d1, output bit  _value );
        _value = temp_static_read_channel_cycle_data[_d1];
    endfunction
    function void axi4_set_temp_static_read_channel_cycle_data( input int _d1, input bit  _value );
        temp_static_read_channel_cycle_data[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_read_channel_cycle_id;
    function void axi4_get_temp_static_read_channel_cycle_id( input int _d1, output bit  _value );
        _value = temp_static_read_channel_cycle_id[_d1];
    endfunction
    function void axi4_set_temp_static_read_channel_cycle_id( input int _d1, input bit  _value );
        temp_static_read_channel_cycle_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_read_channel_cycle_user_data;
    function void axi4_get_temp_static_read_channel_cycle_user_data( input int _d1, output bit  _value );
        _value = temp_static_read_channel_cycle_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_read_channel_cycle_user_data( input int _d1, input bit  _value );
        temp_static_read_channel_cycle_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_ADDRESS_WIDTH) - 1):0]  temp_static_write_addr_channel_cycle_addr;
    function void axi4_get_temp_static_write_addr_channel_cycle_addr( input int _d1, output bit  _value );
        _value = temp_static_write_addr_channel_cycle_addr[_d1];
    endfunction
    function void axi4_set_temp_static_write_addr_channel_cycle_addr( input int _d1, input bit  _value );
        temp_static_write_addr_channel_cycle_addr[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_write_addr_channel_cycle_id;
    function void axi4_get_temp_static_write_addr_channel_cycle_id( input int _d1, output bit  _value );
        _value = temp_static_write_addr_channel_cycle_id[_d1];
    endfunction
    function void axi4_set_temp_static_write_addr_channel_cycle_id( input int _d1, input bit  _value );
        temp_static_write_addr_channel_cycle_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_write_addr_channel_cycle_user_data;
    function void axi4_get_temp_static_write_addr_channel_cycle_user_data( input int _d1, output bit  _value );
        _value = temp_static_write_addr_channel_cycle_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_write_addr_channel_cycle_user_data( input int _d1, input bit  _value );
        temp_static_write_addr_channel_cycle_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_WDATA_WIDTH) - 1):0]  temp_static_write_channel_cycle_data;
    function void axi4_get_temp_static_write_channel_cycle_data( input int _d1, output bit  _value );
        _value = temp_static_write_channel_cycle_data[_d1];
    endfunction
    function void axi4_set_temp_static_write_channel_cycle_data( input int _d1, input bit  _value );
        temp_static_write_channel_cycle_data[_d1] = _value;
    endfunction
    bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  temp_static_write_channel_cycle_strb;
    function void axi4_get_temp_static_write_channel_cycle_strb( input int _d1, output bit  _value );
        _value = temp_static_write_channel_cycle_strb[_d1];
    endfunction
    function void axi4_set_temp_static_write_channel_cycle_strb( input int _d1, input bit  _value );
        temp_static_write_channel_cycle_strb[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_write_channel_cycle_user_data;
    function void axi4_get_temp_static_write_channel_cycle_user_data( input int _d1, output bit  _value );
        _value = temp_static_write_channel_cycle_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_write_channel_cycle_user_data( input int _d1, input bit  _value );
        temp_static_write_channel_cycle_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_write_resp_channel_cycle_id;
    function void axi4_get_temp_static_write_resp_channel_cycle_id( input int _d1, output bit  _value );
        _value = temp_static_write_resp_channel_cycle_id[_d1];
    endfunction
    function void axi4_set_temp_static_write_resp_channel_cycle_id( input int _d1, input bit  _value );
        temp_static_write_resp_channel_cycle_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_write_resp_channel_cycle_user_data;
    function void axi4_get_temp_static_write_resp_channel_cycle_user_data( input int _d1, output bit  _value );
        _value = temp_static_write_resp_channel_cycle_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_write_resp_channel_cycle_user_data( input int _d1, input bit  _value );
        temp_static_write_resp_channel_cycle_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_unexpected_write_response_id;
    function void axi4_get_temp_static_unexpected_write_response_id( input int _d1, output bit  _value );
        _value = temp_static_unexpected_write_response_id[_d1];
    endfunction
    function void axi4_set_temp_static_unexpected_write_response_id( input int _d1, input bit  _value );
        temp_static_unexpected_write_response_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_unexpected_write_response_resp_user_data;
    function void axi4_get_temp_static_unexpected_write_response_resp_user_data( input int _d1, output bit  _value );
        _value = temp_static_unexpected_write_response_resp_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_unexpected_write_response_resp_user_data( input int _d1, input bit  _value );
        temp_static_unexpected_write_response_resp_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_RDATA_WIDTH) - 1):0]  temp_static_unexpected_read_response_data;
    function void axi4_get_temp_static_unexpected_read_response_data( input int _d1, output bit  _value );
        _value = temp_static_unexpected_read_response_data[_d1];
    endfunction
    function void axi4_set_temp_static_unexpected_read_response_data( input int _d1, input bit  _value );
        temp_static_unexpected_read_response_data[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_unexpected_read_response_id;
    function void axi4_get_temp_static_unexpected_read_response_id( input int _d1, output bit  _value );
        _value = temp_static_unexpected_read_response_id[_d1];
    endfunction
    function void axi4_set_temp_static_unexpected_read_response_id( input int _d1, input bit  _value );
        temp_static_unexpected_read_response_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_unexpected_read_response_user_data;
    function void axi4_get_temp_static_unexpected_read_response_user_data( input int _d1, output bit  _value );
        _value = temp_static_unexpected_read_response_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_unexpected_read_response_user_data( input int _d1, input bit  _value );
        temp_static_unexpected_read_response_user_data[_d1] = _value;
    endfunction
    task automatic do_dvc_activate_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref axi4_rw_e read_or_write,
        ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi4_prot_e prot,
        ref bit [3:0] region,
        ref axi4_size_e size,
        ref axi4_burst_e burst,
        ref axi4_lock_e lock,
        ref axi4_cache_e cache,
        ref bit [3:0] qos,
        ref bit [((AXI4_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] burst_length,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        ref int address_valid_delay,
        ref int data_valid_delay[],
        ref int write_response_valid_delay,
        ref int address_ready_delay,
        ref int data_ready_delay[],
        ref int write_response_ready_delay,
        ref bit write_data_with_address,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0
    );
        begin
            int _trans_id;
            int tmp_read_or_write;
            int tmp_prot;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_resp[];
            tmp_read_or_write = int'( read_or_write );
            tmp_prot = int'( prot );
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );
            begin
            tmp_resp = new [resp.size()];
            for (int _i_1= 0; _i_1 < ( resp.size() ); _i_1++)
            begin
            tmp_resp[_i_1] = int'( resp[_i_1] );
            
            end
            end/* 1 */ 

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int wdata_user_data_DIMS0;
                automatic int resp_DIMS0;
                automatic int resp_user_data_DIMS0;
                automatic int data_valid_delay_DIMS0;
                automatic int data_ready_delay_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_rw_transaction_addr = addr;
                temp_static_rw_transaction_id = id;
                temp_static_rw_transaction_addr_user_data = addr_user_data;
                data_words_DIMS0 = data_words.size();
                temp_static_rw_transaction_data_words = data_words;
                write_strobes_DIMS0 = write_strobes.size();
                temp_static_rw_transaction_write_strobes = write_strobes;
                wdata_user_data_DIMS0 = wdata_user_data.size();
                temp_static_rw_transaction_wdata_user_data = wdata_user_data;
                resp_DIMS0 = resp.size();
                temp_static_rw_transaction_resp = tmp_resp;
                resp_user_data_DIMS0 = resp_user_data.size();
                temp_static_rw_transaction_resp_user_data = resp_user_data;
                data_valid_delay_DIMS0 = data_valid_delay.size();
                temp_static_rw_transaction_data_valid_delay = data_valid_delay;
                data_ready_delay_DIMS0 = data_ready_delay.size();
                temp_static_rw_transaction_data_ready_delay = data_ready_delay;
                write_data_beats_delay_DIMS0 = write_data_beats_delay.size();
                temp_static_rw_transaction_write_data_beats_delay = write_data_beats_delay;
                // Call function to provide sized params and ingoing unsized params sizes.
                // In addition gets back updated sizes of unsized params.
                axi4_rw_transaction_ActivatesActivatingActivate_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_read_or_write, tmp_prot, region, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, burst_length, data_words_DIMS0, write_strobes_DIMS0, wdata_user_data_DIMS0, resp_DIMS0, resp_user_data_DIMS0, address_valid_delay, data_valid_delay_DIMS0, write_response_valid_delay, address_ready_delay, data_ready_delay_DIMS0, write_response_ready_delay, write_data_with_address, write_address_to_data_delay, write_data_to_address_delay, write_data_beats_delay_DIMS0, _unit_id); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_write_strobes.delete();
                end
                if (wdata_user_data_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_wdata_user_data = new [wdata_user_data_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_wdata_user_data.delete();
                end
                if (resp_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_resp = new [resp_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_resp.delete();
                end
                if (resp_user_data_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_resp_user_data = new [resp_user_data_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_resp_user_data.delete();
                end
                if (data_valid_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_valid_delay = new [data_valid_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_valid_delay.delete();
                end
                if (data_ready_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_ready_delay = new [data_ready_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_ready_delay.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_write_data_beats_delay.delete();
                end
                // Call function to get the sized params
                axi4_rw_transaction_ActivatesActivatingActivate_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_read_or_write, tmp_prot, region, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, burst_length, address_valid_delay, write_response_valid_delay, address_ready_delay, write_response_ready_delay, write_data_with_address, write_address_to_data_delay, write_data_to_address_delay, _unit_id); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_rw_transaction_addr;
                id = temp_static_rw_transaction_id;
                addr_user_data = temp_static_rw_transaction_addr_user_data;
                data_words = temp_static_rw_transaction_data_words;
                temp_static_rw_transaction_data_words.delete();
                write_strobes = temp_static_rw_transaction_write_strobes;
                temp_static_rw_transaction_write_strobes.delete();
                wdata_user_data = temp_static_rw_transaction_wdata_user_data;
                temp_static_rw_transaction_wdata_user_data.delete();
                tmp_resp = temp_static_rw_transaction_resp;
                temp_static_rw_transaction_resp.delete();
                resp_user_data = temp_static_rw_transaction_resp_user_data;
                temp_static_rw_transaction_resp_user_data.delete();
                data_valid_delay = temp_static_rw_transaction_data_valid_delay;
                temp_static_rw_transaction_data_valid_delay.delete();
                data_ready_delay = temp_static_rw_transaction_data_ready_delay;
                temp_static_rw_transaction_data_ready_delay.delete();
                write_data_beats_delay = temp_static_rw_transaction_write_data_beats_delay;
                temp_static_rw_transaction_write_data_beats_delay.delete();
            end // Block to create unsized data arrays
            read_or_write = axi4_rw_e'( tmp_read_or_write );
            prot = axi4_prot_e'( tmp_prot );
            size = axi4_size_e'( tmp_size );
            burst = axi4_burst_e'( tmp_burst );
            lock = axi4_lock_e'( tmp_lock );
            cache = axi4_cache_e'( tmp_cache );
            begin
            resp = new [tmp_resp.size()];
            for (int _i_1= 0; _i_1 < ( tmp_resp.size() ); _i_1++)
            begin
            resp[_i_1] = axi4_response_e'( tmp_resp[_i_1] );
            
            end
            end/* 1 */ 
        end
    endtask

    task automatic do_dvc_get_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi4_rw_e read_or_write,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        output int address_valid_delay,
        ref int data_valid_delay[],
        output int write_response_valid_delay,
        output int address_ready_delay,
        ref int data_ready_delay[],
        output int write_response_ready_delay,
        output bit write_data_with_address,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_read_or_write;
            int tmp_prot;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_resp[];

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int wdata_user_data_DIMS0;
                automatic int resp_DIMS0;
                automatic int resp_user_data_DIMS0;
                automatic int data_valid_delay_DIMS0;
                automatic int data_ready_delay_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                // Call function to get unsized params sizes.
                axi4_rw_transaction_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, write_strobes_DIMS0, wdata_user_data_DIMS0, resp_DIMS0, resp_user_data_DIMS0, data_valid_delay_DIMS0, data_ready_delay_DIMS0, write_data_beats_delay_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_write_strobes.delete();
                end
                if (wdata_user_data_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_wdata_user_data = new [wdata_user_data_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_wdata_user_data.delete();
                end
                if (resp_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_resp = new [resp_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_resp.delete();
                end
                if (resp_user_data_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_resp_user_data = new [resp_user_data_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_resp_user_data.delete();
                end
                if (data_valid_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_valid_delay = new [data_valid_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_valid_delay.delete();
                end
                if (data_ready_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_ready_delay = new [data_ready_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_ready_delay.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_write_data_beats_delay.delete();
                end
                // Call function to get the sized params
                axi4_rw_transaction_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_read_or_write, tmp_prot, region, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, burst_length, address_valid_delay, write_response_valid_delay, address_ready_delay, write_response_ready_delay, write_data_with_address, write_address_to_data_delay, write_data_to_address_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_rw_transaction_addr;
                id = temp_static_rw_transaction_id;
                addr_user_data = temp_static_rw_transaction_addr_user_data;
                data_words = temp_static_rw_transaction_data_words;
                temp_static_rw_transaction_data_words.delete();
                write_strobes = temp_static_rw_transaction_write_strobes;
                temp_static_rw_transaction_write_strobes.delete();
                wdata_user_data = temp_static_rw_transaction_wdata_user_data;
                temp_static_rw_transaction_wdata_user_data.delete();
                tmp_resp = temp_static_rw_transaction_resp;
                temp_static_rw_transaction_resp.delete();
                resp_user_data = temp_static_rw_transaction_resp_user_data;
                temp_static_rw_transaction_resp_user_data.delete();
                data_valid_delay = temp_static_rw_transaction_data_valid_delay;
                temp_static_rw_transaction_data_valid_delay.delete();
                data_ready_delay = temp_static_rw_transaction_data_ready_delay;
                temp_static_rw_transaction_data_ready_delay.delete();
                write_data_beats_delay = temp_static_rw_transaction_write_data_beats_delay;
                temp_static_rw_transaction_write_data_beats_delay.delete();
            end // Block to create unsized data arrays
            read_or_write = axi4_rw_e'( tmp_read_or_write );
            prot = axi4_prot_e'( tmp_prot );
            size = axi4_size_e'( tmp_size );
            burst = axi4_burst_e'( tmp_burst );
            lock = axi4_lock_e'( tmp_lock );
            cache = axi4_cache_e'( tmp_cache );
            begin
            resp = new [tmp_resp.size()];
            for (int _i_1= 0; _i_1 < ( tmp_resp.size() ); _i_1++)
            begin
            resp[_i_1] = axi4_response_e'( tmp_resp[_i_1] );
            
            end
            end/* 1 */ 
        end
    endtask

    task automatic do_dvc_activate_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi4_prot_e prot,
        ref int rresp_delays[255:0],
        ref bit [3:0] region,
        ref axi4_size_e size,
        ref axi4_burst_e burst,
        ref axi4_lock_e lock,
        ref axi4_cache_e cache,
        ref bit [3:0] qos,
        ref bit [((AXI4_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] burst_length,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_RDATA_WIDTH) - 1):0] data_words [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int address_valid_delay,
        input int _unit_id = 0
    );
        begin
            int _trans_id;
            int tmp_prot;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_resp[];
            tmp_prot = int'( prot );
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );
            begin
            tmp_resp = new [resp.size()];
            for (int _i_1= 0; _i_1 < ( resp.size() ); _i_1++)
            begin
            tmp_resp[_i_1] = int'( resp[_i_1] );
            
            end
            end/* 1 */ 

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int resp_DIMS0;
                automatic int resp_user_data_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_read_addr = addr;
                temp_static_read_rresp_delays = rresp_delays;
                temp_static_read_id = id;
                temp_static_read_addr_user_data = addr_user_data;
                data_words_DIMS0 = data_words.size();
                temp_static_read_data_words = data_words;
                resp_DIMS0 = resp.size();
                temp_static_read_resp = tmp_resp;
                resp_user_data_DIMS0 = resp_user_data.size();
                temp_static_read_resp_user_data = resp_user_data;
                data_start_time_DIMS0 = data_start_time.size();
                temp_static_read_data_start_time = data_start_time;
                data_end_time_DIMS0 = data_end_time.size();
                temp_static_read_data_end_time = data_end_time;
                // Call function to provide sized params and ingoing unsized params sizes.
                // In addition gets back updated sizes of unsized params.
                axi4_read_ActivatesActivatingActivate_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_prot, region, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, burst_length, data_words_DIMS0, resp_DIMS0, resp_user_data_DIMS0, addr_start_time, addr_end_time, data_start_time_DIMS0, data_end_time_DIMS0, address_valid_delay, _unit_id); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_read_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_read_data_words.delete();
                end
                if (resp_DIMS0 != 0)
                begin
                    temp_static_read_resp = new [resp_DIMS0];
                end
                else
                begin
                    temp_static_read_resp.delete();
                end
                if (resp_user_data_DIMS0 != 0)
                begin
                    temp_static_read_resp_user_data = new [resp_user_data_DIMS0];
                end
                else
                begin
                    temp_static_read_resp_user_data.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_read_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_read_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_read_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_read_data_end_time.delete();
                end
                // Call function to get the sized params
                axi4_read_ActivatesActivatingActivate_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_prot, region, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, burst_length, addr_start_time, addr_end_time, address_valid_delay, _unit_id); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_read_addr;
                rresp_delays = temp_static_read_rresp_delays;
                id = temp_static_read_id;
                addr_user_data = temp_static_read_addr_user_data;
                data_words = temp_static_read_data_words;
                temp_static_read_data_words.delete();
                tmp_resp = temp_static_read_resp;
                temp_static_read_resp.delete();
                resp_user_data = temp_static_read_resp_user_data;
                temp_static_read_resp_user_data.delete();
                data_start_time = temp_static_read_data_start_time;
                temp_static_read_data_start_time.delete();
                data_end_time = temp_static_read_data_end_time;
                temp_static_read_data_end_time.delete();
            end // Block to create unsized data arrays
            prot = axi4_prot_e'( tmp_prot );
            size = axi4_size_e'( tmp_size );
            burst = axi4_burst_e'( tmp_burst );
            lock = axi4_lock_e'( tmp_lock );
            cache = axi4_cache_e'( tmp_cache );
            begin
            resp = new [tmp_resp.size()];
            for (int _i_1= 0; _i_1 < ( tmp_resp.size() ); _i_1++)
            begin
            resp[_i_1] = axi4_response_e'( tmp_resp[_i_1] );
            
            end
            end/* 1 */ 
        end
    endtask

    task automatic do_dvc_get_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        ref int rresp_delays[255:0],
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_RDATA_WIDTH) - 1):0] data_words [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output int address_valid_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_prot;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_resp[];

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int resp_DIMS0;
                automatic int resp_user_data_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Call function to get unsized params sizes.
                axi4_read_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, resp_DIMS0, resp_user_data_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_read_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_read_data_words.delete();
                end
                if (resp_DIMS0 != 0)
                begin
                    temp_static_read_resp = new [resp_DIMS0];
                end
                else
                begin
                    temp_static_read_resp.delete();
                end
                if (resp_user_data_DIMS0 != 0)
                begin
                    temp_static_read_resp_user_data = new [resp_user_data_DIMS0];
                end
                else
                begin
                    temp_static_read_resp_user_data.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_read_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_read_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_read_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_read_data_end_time.delete();
                end
                // Call function to get the sized params
                axi4_read_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_prot, region, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, burst_length, addr_start_time, addr_end_time, address_valid_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_read_addr;
                rresp_delays = temp_static_read_rresp_delays;
                id = temp_static_read_id;
                addr_user_data = temp_static_read_addr_user_data;
                data_words = temp_static_read_data_words;
                temp_static_read_data_words.delete();
                tmp_resp = temp_static_read_resp;
                temp_static_read_resp.delete();
                resp_user_data = temp_static_read_resp_user_data;
                temp_static_read_resp_user_data.delete();
                data_start_time = temp_static_read_data_start_time;
                temp_static_read_data_start_time.delete();
                data_end_time = temp_static_read_data_end_time;
                temp_static_read_data_end_time.delete();
            end // Block to create unsized data arrays
            prot = axi4_prot_e'( tmp_prot );
            size = axi4_size_e'( tmp_size );
            burst = axi4_burst_e'( tmp_burst );
            lock = axi4_lock_e'( tmp_lock );
            cache = axi4_cache_e'( tmp_cache );
            begin
            resp = new [tmp_resp.size()];
            for (int _i_1= 0; _i_1 < ( tmp_resp.size() ); _i_1++)
            begin
            resp[_i_1] = axi4_response_e'( tmp_resp[_i_1] );
            
            end
            end/* 1 */ 
        end
    endtask

    task automatic do_dvc_activate_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi4_prot_e prot,
        ref int bresp_delay,
        ref bit [3:0] region,
        ref axi4_size_e size,
        ref axi4_burst_e burst,
        ref axi4_lock_e lock,
        ref axi4_cache_e cache,
        ref bit [3:0] qos,
        ref bit [((AXI4_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] burst_length,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        ref axi4_response_e resp,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref longint wr_resp_start_time,
        ref longint wr_resp_end_time,
        ref int address_valid_delay,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0
    );
        begin
            int _trans_id;
            int tmp_prot;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_resp;
            tmp_prot = int'( prot );
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int wdata_user_data_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_addr = addr;
                temp_static_write_id = id;
                temp_static_write_addr_user_data = addr_user_data;
                data_words_DIMS0 = data_words.size();
                temp_static_write_data_words = data_words;
                write_strobes_DIMS0 = write_strobes.size();
                temp_static_write_write_strobes = write_strobes;
                wdata_user_data_DIMS0 = wdata_user_data.size();
                temp_static_write_wdata_user_data = wdata_user_data;
                temp_static_write_resp_user_data = resp_user_data;
                data_start_time_DIMS0 = data_start_time.size();
                temp_static_write_data_start_time = data_start_time;
                data_end_time_DIMS0 = data_end_time.size();
                temp_static_write_data_end_time = data_end_time;
                write_data_beats_delay_DIMS0 = write_data_beats_delay.size();
                temp_static_write_write_data_beats_delay = write_data_beats_delay;
                // Call function to provide sized params and ingoing unsized params sizes.
                // In addition gets back updated sizes of unsized params.
                axi4_write_ActivatesActivatingActivate_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_prot, bresp_delay, region, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, burst_length, data_words_DIMS0, write_strobes_DIMS0, wdata_user_data_DIMS0, tmp_resp, addr_start_time, addr_end_time, data_start_time_DIMS0, data_end_time_DIMS0, wr_resp_start_time, wr_resp_end_time, address_valid_delay, write_address_to_data_delay, write_data_to_address_delay, write_data_beats_delay_DIMS0, _unit_id); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_write_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_write_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_write_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_write_write_strobes.delete();
                end
                if (wdata_user_data_DIMS0 != 0)
                begin
                    temp_static_write_wdata_user_data = new [wdata_user_data_DIMS0];
                end
                else
                begin
                    temp_static_write_wdata_user_data.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_write_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_write_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_write_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_write_data_end_time.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_write_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_write_write_data_beats_delay.delete();
                end
                // Call function to get the sized params
                axi4_write_ActivatesActivatingActivate_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_prot, bresp_delay, region, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, burst_length, tmp_resp, addr_start_time, addr_end_time, wr_resp_start_time, wr_resp_end_time, address_valid_delay, write_address_to_data_delay, write_data_to_address_delay, _unit_id); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_write_addr;
                id = temp_static_write_id;
                addr_user_data = temp_static_write_addr_user_data;
                data_words = temp_static_write_data_words;
                temp_static_write_data_words.delete();
                write_strobes = temp_static_write_write_strobes;
                temp_static_write_write_strobes.delete();
                wdata_user_data = temp_static_write_wdata_user_data;
                temp_static_write_wdata_user_data.delete();
                resp_user_data = temp_static_write_resp_user_data;
                data_start_time = temp_static_write_data_start_time;
                temp_static_write_data_start_time.delete();
                data_end_time = temp_static_write_data_end_time;
                temp_static_write_data_end_time.delete();
                write_data_beats_delay = temp_static_write_write_data_beats_delay;
                temp_static_write_write_data_beats_delay.delete();
            end // Block to create unsized data arrays
            prot = axi4_prot_e'( tmp_prot );
            size = axi4_size_e'( tmp_size );
            burst = axi4_burst_e'( tmp_burst );
            lock = axi4_lock_e'( tmp_lock );
            cache = axi4_cache_e'( tmp_cache );
            resp = axi4_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_get_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output int bresp_delay,
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        output axi4_response_e resp,
        output bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output longint wr_resp_start_time,
        output longint wr_resp_end_time,
        output int address_valid_delay,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_prot;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int wdata_user_data_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                // Call function to get unsized params sizes.
                axi4_write_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, write_strobes_DIMS0, wdata_user_data_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, write_data_beats_delay_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_write_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_write_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_write_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_write_write_strobes.delete();
                end
                if (wdata_user_data_DIMS0 != 0)
                begin
                    temp_static_write_wdata_user_data = new [wdata_user_data_DIMS0];
                end
                else
                begin
                    temp_static_write_wdata_user_data.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_write_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_write_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_write_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_write_data_end_time.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_write_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_write_write_data_beats_delay.delete();
                end
                // Call function to get the sized params
                axi4_write_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_prot, bresp_delay, region, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, burst_length, tmp_resp, addr_start_time, addr_end_time, wr_resp_start_time, wr_resp_end_time, address_valid_delay, write_address_to_data_delay, write_data_to_address_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_write_addr;
                id = temp_static_write_id;
                addr_user_data = temp_static_write_addr_user_data;
                data_words = temp_static_write_data_words;
                temp_static_write_data_words.delete();
                write_strobes = temp_static_write_write_strobes;
                temp_static_write_write_strobes.delete();
                wdata_user_data = temp_static_write_wdata_user_data;
                temp_static_write_wdata_user_data.delete();
                resp_user_data = temp_static_write_resp_user_data;
                data_start_time = temp_static_write_data_start_time;
                temp_static_write_data_start_time.delete();
                data_end_time = temp_static_write_data_end_time;
                temp_static_write_data_end_time.delete();
                write_data_beats_delay = temp_static_write_write_data_beats_delay;
                temp_static_write_write_data_beats_delay.delete();
            end // Block to create unsized data arrays
            prot = axi4_prot_e'( tmp_prot );
            size = axi4_size_e'( tmp_size );
            burst = axi4_burst_e'( tmp_burst );
            lock = axi4_lock_e'( tmp_lock );
            cache = axi4_cache_e'( tmp_cache );
            resp = axi4_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int burst_length,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] user_data [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int write_data_beats_delay[],
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int user_data_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                data_words_DIMS0 = data_words.size();
                temp_static_write_data_burst_data_words = data_words;
                write_strobes_DIMS0 = write_strobes.size();
                temp_static_write_data_burst_write_strobes = write_strobes;
                user_data_DIMS0 = user_data.size();
                temp_static_write_data_burst_user_data = user_data;
                data_start_time_DIMS0 = data_start_time.size();
                temp_static_write_data_burst_data_start_time = data_start_time;
                data_end_time_DIMS0 = data_end_time.size();
                temp_static_write_data_burst_data_end_time = data_end_time;
                write_data_beats_delay_DIMS0 = write_data_beats_delay.size();
                temp_static_write_data_burst_write_data_beats_delay = write_data_beats_delay;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_write_data_burst_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, burst_length, data_words_DIMS0, write_strobes_DIMS0, user_data_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, write_data_beats_delay_DIMS0, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
                temp_static_write_data_burst_data_words.delete();
                temp_static_write_data_burst_write_strobes.delete();
                temp_static_write_data_burst_user_data.delete();
                temp_static_write_data_burst_data_start_time.delete();
                temp_static_write_data_burst_data_end_time.delete();
                temp_static_write_data_burst_write_data_beats_delay.delete();
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output int burst_length,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] user_data [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int write_data_beats_delay[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int user_data_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                // Call function to get unsized params sizes.
                axi4_write_data_burst_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, write_strobes_DIMS0, user_data_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, write_data_beats_delay_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_write_strobes.delete();
                end
                if (user_data_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_user_data = new [user_data_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_user_data.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_data_end_time.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_write_data_beats_delay.delete();
                end
                // Call function to get the sized params
                axi4_write_data_burst_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data_words = temp_static_write_data_burst_data_words;
                temp_static_write_data_burst_data_words.delete();
                write_strobes = temp_static_write_data_burst_write_strobes;
                temp_static_write_data_burst_write_strobes.delete();
                user_data = temp_static_write_data_burst_user_data;
                temp_static_write_data_burst_user_data.delete();
                data_start_time = temp_static_write_data_burst_data_start_time;
                temp_static_write_data_burst_data_start_time.delete();
                data_end_time = temp_static_write_data_burst_data_end_time;
                temp_static_write_data_burst_data_end_time.delete();
                write_data_beats_delay = temp_static_write_data_burst_write_data_beats_delay;
                temp_static_write_data_burst_write_data_beats_delay.delete();
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_put_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input axi4_prot_e prot,
        input bit [3:0] region,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input axi4_cache_e cache,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
        begin
            int tmp_prot;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            tmp_prot = int'( prot );
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_read_addr_channel_phase_addr = addr;
                temp_static_read_addr_channel_phase_id = id;
                temp_static_read_addr_channel_phase_addr_user = addr_user;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_read_addr_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, tmp_prot, region, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, address_valid_delay, address_ready_delay, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_prot;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_read_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_read_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_prot, region, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, address_valid_delay, address_ready_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_read_addr_channel_phase_addr;
                id = temp_static_read_addr_channel_phase_id;
                addr_user = temp_static_read_addr_channel_phase_addr_user;
            end // Block to create unsized data arrays
            prot = axi4_prot_e'( tmp_prot );
            size = axi4_size_e'( tmp_size );
            burst = axi4_burst_e'( tmp_burst );
            lock = axi4_lock_e'( tmp_lock );
            cache = axi4_cache_e'( tmp_cache );
        end
    endtask

    task automatic do_dvc_put_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_data_burst_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_data_burst_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_put_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int data_ready_delay,
        input int _unit_id = 0
    );
        begin
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_read_channel_phase_data = data;
                temp_static_read_channel_phase_id = id;
                temp_static_read_channel_phase_user_data = user_data;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_read_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, tmp_resp, last, data_ready_delay, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_read_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_read_channel_phase_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_resp, last, data_ready_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data = temp_static_read_channel_phase_data;
                id = temp_static_read_channel_phase_id;
                user_data = temp_static_read_channel_phase_user_data;
            end // Block to create unsized data arrays
            resp = axi4_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input axi4_prot_e prot,
        input bit [3:0] region,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input axi4_cache_e cache,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
        begin
            int tmp_prot;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            tmp_prot = int'( prot );
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_addr_channel_phase_addr = addr;
                temp_static_write_addr_channel_phase_id = id;
                temp_static_write_addr_channel_phase_addr_user = addr_user;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_write_addr_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, tmp_prot, region, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, address_valid_delay, address_ready_delay, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_prot;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_write_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_write_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_prot, region, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, address_valid_delay, address_ready_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_write_addr_channel_phase_addr;
                id = temp_static_write_addr_channel_phase_id;
                addr_user = temp_static_write_addr_channel_phase_addr_user;
            end // Block to create unsized data arrays
            prot = axi4_prot_e'( tmp_prot );
            size = axi4_size_e'( tmp_size );
            burst = axi4_burst_e'( tmp_burst );
            lock = axi4_lock_e'( tmp_lock );
            cache = axi4_cache_e'( tmp_cache );
        end
    endtask

    task automatic do_dvc_put_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        input bit last,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int data_ready_delay,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_channel_phase_data = data;
                temp_static_write_channel_phase_write_strobes = write_strobes;
                temp_static_write_channel_phase_user_data = user_data;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_write_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, last, data_ready_delay, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        output bit last,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_write_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_write_channel_phase_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, last, data_ready_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data = temp_static_write_channel_phase_data;
                write_strobes = temp_static_write_channel_phase_write_strobes;
                user_data = temp_static_write_channel_phase_user_data;
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_put_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi4_response_e resp,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int write_response_ready_delay,
        input int _unit_id = 0
    );
        begin
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_resp_channel_phase_id = id;
                temp_static_write_resp_channel_phase_user_data = user_data;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_write_resp_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, tmp_resp, write_response_ready_delay, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi4_response_e resp,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int write_response_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_write_resp_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_write_resp_channel_phase_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_resp, write_response_ready_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                id = temp_static_write_resp_channel_phase_id;
                user_data = temp_static_write_resp_channel_phase_user_data;
            end // Block to create unsized data arrays
            resp = axi4_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] region,
        input axi4_cache_e cache,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input axi4_prot_e prot,
        input int _unit_id = 0
    );
        begin
            int tmp_cache;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_prot;
            tmp_cache = int'( cache );
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_prot = int'( prot );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_read_addr_channel_cycle_addr = addr;
                temp_static_read_addr_channel_cycle_id = id;
                temp_static_read_addr_channel_cycle_user_data = user_data;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_read_addr_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, region, tmp_cache, burst_length, tmp_size, tmp_burst, tmp_lock, qos, tmp_prot, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] region,
        output axi4_cache_e cache,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output axi4_prot_e prot,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_cache;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_prot;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_read_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_read_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, region, tmp_cache, burst_length, tmp_size, tmp_burst, tmp_lock, qos, tmp_prot, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_read_addr_channel_cycle_addr;
                id = temp_static_read_addr_channel_cycle_id;
                user_data = temp_static_read_addr_channel_cycle_user_data;
            end // Block to create unsized data arrays
            cache = axi4_cache_e'( tmp_cache );
            size = axi4_size_e'( tmp_size );
            burst = axi4_burst_e'( tmp_burst );
            lock = axi4_lock_e'( tmp_lock );
            prot = axi4_prot_e'( tmp_prot );
        end
    endtask

    task automatic do_dvc_put_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_addr_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_put_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
        begin
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_read_channel_cycle_data = data;
                temp_static_read_channel_cycle_id = id;
                temp_static_read_channel_cycle_user_data = user_data;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_read_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, tmp_resp, last, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_read_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_read_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_resp, last, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data = temp_static_read_channel_cycle_data;
                id = temp_static_read_channel_cycle_id;
                user_data = temp_static_read_channel_cycle_user_data;
            end // Block to create unsized data arrays
            resp = axi4_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_put_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] region,
        input axi4_cache_e cache,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input axi4_prot_e prot,
        input int _unit_id = 0
    );
        begin
            int tmp_cache;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_prot;
            tmp_cache = int'( cache );
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_prot = int'( prot );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_addr_channel_cycle_addr = addr;
                temp_static_write_addr_channel_cycle_id = id;
                temp_static_write_addr_channel_cycle_user_data = user_data;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_write_addr_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, region, tmp_cache, burst_length, tmp_size, tmp_burst, tmp_lock, qos, tmp_prot, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] region,
        output axi4_cache_e cache,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output axi4_prot_e prot,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_cache;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_prot;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_write_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_write_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, region, tmp_cache, burst_length, tmp_size, tmp_burst, tmp_lock, qos, tmp_prot, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_write_addr_channel_cycle_addr;
                id = temp_static_write_addr_channel_cycle_id;
                user_data = temp_static_write_addr_channel_cycle_user_data;
            end // Block to create unsized data arrays
            cache = axi4_cache_e'( tmp_cache );
            size = axi4_size_e'( tmp_size );
            burst = axi4_burst_e'( tmp_burst );
            lock = axi4_lock_e'( tmp_lock );
            prot = axi4_prot_e'( tmp_prot );
        end
    endtask

    task automatic do_dvc_put_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_addr_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_put_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  strb,
        input bit last,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_channel_cycle_data = data;
                temp_static_write_channel_cycle_strb = strb;
                temp_static_write_channel_cycle_user_data = user_data;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_write_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, last, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  strb,
        output bit last,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_write_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_write_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, last, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data = temp_static_write_channel_cycle_data;
                strb = temp_static_write_channel_cycle_strb;
                user_data = temp_static_write_channel_cycle_user_data;
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_put_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_put_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi4_response_e resp,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
        begin
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_resp_channel_cycle_id = id;
                temp_static_write_resp_channel_cycle_user_data = user_data;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_write_resp_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, tmp_resp, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi4_response_e resp,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_write_resp_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_write_resp_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_resp, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                id = temp_static_write_resp_channel_cycle_id;
                user_data = temp_static_write_resp_channel_cycle_user_data;
            end // Block to create unsized data arrays
            resp = axi4_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_resp_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_resp_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_put_unexpected_write_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input axi4_response_e resp,
        input bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        input int _unit_id = 0
    );
        begin
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_unexpected_write_response_id = id;
                temp_static_unexpected_write_response_resp_user_data = resp_user_data;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_unexpected_write_response_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, tmp_resp, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_unexpected_write_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output axi4_response_e resp,
        output bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_unexpected_write_response_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_unexpected_write_response_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_resp, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                id = temp_static_unexpected_write_response_id;
                resp_user_data = temp_static_unexpected_write_response_resp_user_data;
            end // Block to create unsized data arrays
            resp = axi4_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_unexpected_read_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
        begin
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_unexpected_read_response_data = data;
                temp_static_unexpected_read_response_id = id;
                temp_static_unexpected_read_response_user_data = user_data;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_unexpected_read_response_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, tmp_resp, last, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_unexpected_read_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_unexpected_read_response_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_unexpected_read_response_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_resp, last, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data = temp_static_unexpected_read_response_data;
                id = temp_static_unexpected_read_response_id;
                user_data = temp_static_unexpected_read_response_user_data;
            end // Block to create unsized data arrays
            resp = axi4_response_e'( tmp_resp );
        end
    endtask

    //-------------------------------------------------------------------------------------
    // Task which blocks and outputs an error if the interface has not initialized properly
    //-------------------------------------------------------------------------------------

    task _initialized();
        if (_interface_ref == 0)
        begin
            $display("Error: %m - Questa Verification IP failed to initialise. Please check questa_mvc.log for details");
            wait(_interface_ref!=0);
        end
    endtask

    //-------------------------------------------------------------------------------------
    // Function to get interface handle (internal use only)
    //-------------------------------------------------------------------------------------

    function longint _get_interface_handle();
        _get_interface_handle = axi4_get_interface_handle();
    endfunction

//------------------------------------------------------------------------------
//
// Class which implements interface defined by axi4_interface_class
//
//------------------------------------------------------------------------------
class axi4_implementation_class #(int AXI4_ADDRESS_WIDTH = 64, int AXI4_RDATA_WIDTH = 1024, int AXI4_WDATA_WIDTH = 1024, int AXI4_ID_WIDTH = 18, int AXI4_USER_WIDTH = 8, int AXI4_REGION_MAP_SIZE = 16)
    extends axi4_interface_class #(AXI4_ADDRESS_WIDTH, AXI4_RDATA_WIDTH, AXI4_WDATA_WIDTH, AXI4_ID_WIDTH, AXI4_USER_WIDTH, AXI4_REGION_MAP_SIZE);

    //------------------------------------------------------------------------------
    // Tasks to wait for a number of specified edges on a wire
    //------------------------------------------------------------------------------
    task automatic wait_for_ACLK( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ACLK( which_edge, count );
    endtask

    task automatic wait_for_ARESETn( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARESETn( which_edge, count );
    endtask

    task automatic wait_for_AWVALID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWVALID( which_edge, count );
    endtask

    task automatic wait_for_AWADDR( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWADDR( which_edge, count );
    endtask

    task automatic wait_for_AWADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWADDR_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWPROT( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWPROT( which_edge, count );
    endtask

    task automatic wait_for_AWPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWPROT_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWREGION( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWREGION( which_edge, count );
    endtask

    task automatic wait_for_AWREGION_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWREGION_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWLEN( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWLEN( which_edge, count );
    endtask

    task automatic wait_for_AWLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWLEN_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWSIZE( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWSIZE( which_edge, count );
    endtask

    task automatic wait_for_AWSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWSIZE_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWBURST( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWBURST( which_edge, count );
    endtask

    task automatic wait_for_AWBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWBURST_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWLOCK( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWLOCK( which_edge, count );
    endtask

    task automatic wait_for_AWCACHE( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWCACHE( which_edge, count );
    endtask

    task automatic wait_for_AWCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWCACHE_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWQOS( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWQOS( which_edge, count );
    endtask

    task automatic wait_for_AWQOS_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWQOS_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWID( which_edge, count );
    endtask

    task automatic wait_for_AWID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWID_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWUSER( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWUSER( which_edge, count );
    endtask

    task automatic wait_for_AWUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWUSER_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWREADY( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWREADY( which_edge, count );
    endtask

    task automatic wait_for_ARVALID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARVALID( which_edge, count );
    endtask

    task automatic wait_for_ARADDR( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARADDR( which_edge, count );
    endtask

    task automatic wait_for_ARADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARADDR_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARPROT( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARPROT( which_edge, count );
    endtask

    task automatic wait_for_ARPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARPROT_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARREGION( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARREGION( which_edge, count );
    endtask

    task automatic wait_for_ARREGION_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARREGION_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARLEN( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARLEN( which_edge, count );
    endtask

    task automatic wait_for_ARLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARLEN_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARSIZE( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARSIZE( which_edge, count );
    endtask

    task automatic wait_for_ARSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARSIZE_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARBURST( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARBURST( which_edge, count );
    endtask

    task automatic wait_for_ARBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARBURST_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARLOCK( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARLOCK( which_edge, count );
    endtask

    task automatic wait_for_ARCACHE( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARCACHE( which_edge, count );
    endtask

    task automatic wait_for_ARCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARCACHE_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARQOS( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARQOS( which_edge, count );
    endtask

    task automatic wait_for_ARQOS_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARQOS_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARID( which_edge, count );
    endtask

    task automatic wait_for_ARID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARID_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARUSER( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARUSER( which_edge, count );
    endtask

    task automatic wait_for_ARUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARUSER_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARREADY( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARREADY( which_edge, count );
    endtask

    task automatic wait_for_RVALID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RVALID( which_edge, count );
    endtask

    task automatic wait_for_RDATA( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RDATA( which_edge, count );
    endtask

    task automatic wait_for_RDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RDATA_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_RRESP( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RRESP( which_edge, count );
    endtask

    task automatic wait_for_RRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RRESP_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_RLAST( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RLAST( which_edge, count );
    endtask

    task automatic wait_for_RID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RID( which_edge, count );
    endtask

    task automatic wait_for_RID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RID_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_RUSER( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RUSER( which_edge, count );
    endtask

    task automatic wait_for_RUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RUSER_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_RREADY( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RREADY( which_edge, count );
    endtask

    task automatic wait_for_WVALID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WVALID( which_edge, count );
    endtask

    task automatic wait_for_WDATA( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WDATA( which_edge, count );
    endtask

    task automatic wait_for_WDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WDATA_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_WSTRB( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WSTRB( which_edge, count );
    endtask

    task automatic wait_for_WSTRB_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WSTRB_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_WLAST( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WLAST( which_edge, count );
    endtask

    task automatic wait_for_WUSER( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WUSER( which_edge, count );
    endtask

    task automatic wait_for_WUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WUSER_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_WREADY( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WREADY( which_edge, count );
    endtask

    task automatic wait_for_BVALID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BVALID( which_edge, count );
    endtask

    task automatic wait_for_BRESP( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BRESP( which_edge, count );
    endtask

    task automatic wait_for_BRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BRESP_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_BID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BID( which_edge, count );
    endtask

    task automatic wait_for_BID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BID_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_BUSER( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BUSER( which_edge, count );
    endtask

    task automatic wait_for_BUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BUSER_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_BREADY( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BREADY( which_edge, count );
    endtask


    //------------------------------------------------------------------------------
    // Tasks/functions to set/get wires
    //------------------------------------------------------------------------------
    task automatic set_ACLK( logic ACLK_param = 'z, bit non_blocking = 1'b0 );
        do_set_ACLK( ACLK_param, non_blocking );
    endtask

    function automatic logic get_ACLK(  );
        return do_get_ACLK(  );
    endfunction


    task automatic set_ARESETn( logic ARESETn_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARESETn( ARESETn_param, non_blocking );
    endtask

    function automatic logic get_ARESETn(  );
        return do_get_ARESETn(  );
    endfunction


    task automatic set_AWVALID( logic AWVALID_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWVALID( AWVALID_param, non_blocking );
    endtask

    function automatic logic get_AWVALID(  );
        return do_get_AWVALID(  );
    endfunction


    task automatic set_AWADDR( logic [((AXI4_ADDRESS_WIDTH) - 1):0]  AWADDR_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWADDR( AWADDR_param, non_blocking );
    endtask

    task automatic set_AWADDR_index1( int _this_dot_1, logic  AWADDR_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWADDR_index1( _this_dot_1, AWADDR_param, non_blocking );
    endtask

    function automatic logic [((AXI4_ADDRESS_WIDTH) - 1):0]   get_AWADDR(  );
        return do_get_AWADDR(  );
    endfunction

    function automatic logic   get_AWADDR_index1( int _this_dot_1 );
        return do_get_AWADDR_index1( _this_dot_1 );
    endfunction


    task automatic set_AWPROT( logic [2:0] AWPROT_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWPROT( AWPROT_param, non_blocking );
    endtask

    task automatic set_AWPROT_index1( int _this_dot_1, logic  AWPROT_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWPROT_index1( _this_dot_1, AWPROT_param, non_blocking );
    endtask

    function automatic logic [2:0]  get_AWPROT(  );
        return do_get_AWPROT(  );
    endfunction

    function automatic logic   get_AWPROT_index1( int _this_dot_1 );
        return do_get_AWPROT_index1( _this_dot_1 );
    endfunction


    task automatic set_AWREGION( logic [3:0] AWREGION_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWREGION( AWREGION_param, non_blocking );
    endtask

    task automatic set_AWREGION_index1( int _this_dot_1, logic  AWREGION_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWREGION_index1( _this_dot_1, AWREGION_param, non_blocking );
    endtask

    function automatic logic [3:0]  get_AWREGION(  );
        return do_get_AWREGION(  );
    endfunction

    function automatic logic   get_AWREGION_index1( int _this_dot_1 );
        return do_get_AWREGION_index1( _this_dot_1 );
    endfunction


    task automatic set_AWLEN( logic [7:0] AWLEN_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWLEN( AWLEN_param, non_blocking );
    endtask

    task automatic set_AWLEN_index1( int _this_dot_1, logic  AWLEN_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWLEN_index1( _this_dot_1, AWLEN_param, non_blocking );
    endtask

    function automatic logic [7:0]  get_AWLEN(  );
        return do_get_AWLEN(  );
    endfunction

    function automatic logic   get_AWLEN_index1( int _this_dot_1 );
        return do_get_AWLEN_index1( _this_dot_1 );
    endfunction


    task automatic set_AWSIZE( logic [2:0] AWSIZE_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWSIZE( AWSIZE_param, non_blocking );
    endtask

    task automatic set_AWSIZE_index1( int _this_dot_1, logic  AWSIZE_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWSIZE_index1( _this_dot_1, AWSIZE_param, non_blocking );
    endtask

    function automatic logic [2:0]  get_AWSIZE(  );
        return do_get_AWSIZE(  );
    endfunction

    function automatic logic   get_AWSIZE_index1( int _this_dot_1 );
        return do_get_AWSIZE_index1( _this_dot_1 );
    endfunction


    task automatic set_AWBURST( logic [1:0] AWBURST_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWBURST( AWBURST_param, non_blocking );
    endtask

    task automatic set_AWBURST_index1( int _this_dot_1, logic  AWBURST_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWBURST_index1( _this_dot_1, AWBURST_param, non_blocking );
    endtask

    function automatic logic [1:0]  get_AWBURST(  );
        return do_get_AWBURST(  );
    endfunction

    function automatic logic   get_AWBURST_index1( int _this_dot_1 );
        return do_get_AWBURST_index1( _this_dot_1 );
    endfunction


    task automatic set_AWLOCK( logic AWLOCK_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWLOCK( AWLOCK_param, non_blocking );
    endtask

    function automatic logic get_AWLOCK(  );
        return do_get_AWLOCK(  );
    endfunction


    task automatic set_AWCACHE( logic [3:0] AWCACHE_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWCACHE( AWCACHE_param, non_blocking );
    endtask

    task automatic set_AWCACHE_index1( int _this_dot_1, logic  AWCACHE_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWCACHE_index1( _this_dot_1, AWCACHE_param, non_blocking );
    endtask

    function automatic logic [3:0]  get_AWCACHE(  );
        return do_get_AWCACHE(  );
    endfunction

    function automatic logic   get_AWCACHE_index1( int _this_dot_1 );
        return do_get_AWCACHE_index1( _this_dot_1 );
    endfunction


    task automatic set_AWQOS( logic [3:0] AWQOS_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWQOS( AWQOS_param, non_blocking );
    endtask

    task automatic set_AWQOS_index1( int _this_dot_1, logic  AWQOS_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWQOS_index1( _this_dot_1, AWQOS_param, non_blocking );
    endtask

    function automatic logic [3:0]  get_AWQOS(  );
        return do_get_AWQOS(  );
    endfunction

    function automatic logic   get_AWQOS_index1( int _this_dot_1 );
        return do_get_AWQOS_index1( _this_dot_1 );
    endfunction


    task automatic set_AWID( logic [((AXI4_ID_WIDTH) - 1):0]  AWID_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWID( AWID_param, non_blocking );
    endtask

    task automatic set_AWID_index1( int _this_dot_1, logic  AWID_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWID_index1( _this_dot_1, AWID_param, non_blocking );
    endtask

    function automatic logic [((AXI4_ID_WIDTH) - 1):0]   get_AWID(  );
        return do_get_AWID(  );
    endfunction

    function automatic logic   get_AWID_index1( int _this_dot_1 );
        return do_get_AWID_index1( _this_dot_1 );
    endfunction


    task automatic set_AWUSER( logic [((AXI4_USER_WIDTH) - 1):0]  AWUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWUSER( AWUSER_param, non_blocking );
    endtask

    task automatic set_AWUSER_index1( int _this_dot_1, logic  AWUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWUSER_index1( _this_dot_1, AWUSER_param, non_blocking );
    endtask

    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   get_AWUSER(  );
        return do_get_AWUSER(  );
    endfunction

    function automatic logic   get_AWUSER_index1( int _this_dot_1 );
        return do_get_AWUSER_index1( _this_dot_1 );
    endfunction


    task automatic set_AWREADY( logic AWREADY_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWREADY( AWREADY_param, non_blocking );
    endtask

    function automatic logic get_AWREADY(  );
        return do_get_AWREADY(  );
    endfunction


    task automatic set_ARVALID( logic ARVALID_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARVALID( ARVALID_param, non_blocking );
    endtask

    function automatic logic get_ARVALID(  );
        return do_get_ARVALID(  );
    endfunction


    task automatic set_ARADDR( logic [((AXI4_ADDRESS_WIDTH) - 1):0]  ARADDR_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARADDR( ARADDR_param, non_blocking );
    endtask

    task automatic set_ARADDR_index1( int _this_dot_1, logic  ARADDR_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARADDR_index1( _this_dot_1, ARADDR_param, non_blocking );
    endtask

    function automatic logic [((AXI4_ADDRESS_WIDTH) - 1):0]   get_ARADDR(  );
        return do_get_ARADDR(  );
    endfunction

    function automatic logic   get_ARADDR_index1( int _this_dot_1 );
        return do_get_ARADDR_index1( _this_dot_1 );
    endfunction


    task automatic set_ARPROT( logic [2:0] ARPROT_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARPROT( ARPROT_param, non_blocking );
    endtask

    task automatic set_ARPROT_index1( int _this_dot_1, logic  ARPROT_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARPROT_index1( _this_dot_1, ARPROT_param, non_blocking );
    endtask

    function automatic logic [2:0]  get_ARPROT(  );
        return do_get_ARPROT(  );
    endfunction

    function automatic logic   get_ARPROT_index1( int _this_dot_1 );
        return do_get_ARPROT_index1( _this_dot_1 );
    endfunction


    task automatic set_ARREGION( logic [3:0] ARREGION_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARREGION( ARREGION_param, non_blocking );
    endtask

    task automatic set_ARREGION_index1( int _this_dot_1, logic  ARREGION_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARREGION_index1( _this_dot_1, ARREGION_param, non_blocking );
    endtask

    function automatic logic [3:0]  get_ARREGION(  );
        return do_get_ARREGION(  );
    endfunction

    function automatic logic   get_ARREGION_index1( int _this_dot_1 );
        return do_get_ARREGION_index1( _this_dot_1 );
    endfunction


    task automatic set_ARLEN( logic [7:0] ARLEN_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARLEN( ARLEN_param, non_blocking );
    endtask

    task automatic set_ARLEN_index1( int _this_dot_1, logic  ARLEN_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARLEN_index1( _this_dot_1, ARLEN_param, non_blocking );
    endtask

    function automatic logic [7:0]  get_ARLEN(  );
        return do_get_ARLEN(  );
    endfunction

    function automatic logic   get_ARLEN_index1( int _this_dot_1 );
        return do_get_ARLEN_index1( _this_dot_1 );
    endfunction


    task automatic set_ARSIZE( logic [2:0] ARSIZE_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARSIZE( ARSIZE_param, non_blocking );
    endtask

    task automatic set_ARSIZE_index1( int _this_dot_1, logic  ARSIZE_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARSIZE_index1( _this_dot_1, ARSIZE_param, non_blocking );
    endtask

    function automatic logic [2:0]  get_ARSIZE(  );
        return do_get_ARSIZE(  );
    endfunction

    function automatic logic   get_ARSIZE_index1( int _this_dot_1 );
        return do_get_ARSIZE_index1( _this_dot_1 );
    endfunction


    task automatic set_ARBURST( logic [1:0] ARBURST_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARBURST( ARBURST_param, non_blocking );
    endtask

    task automatic set_ARBURST_index1( int _this_dot_1, logic  ARBURST_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARBURST_index1( _this_dot_1, ARBURST_param, non_blocking );
    endtask

    function automatic logic [1:0]  get_ARBURST(  );
        return do_get_ARBURST(  );
    endfunction

    function automatic logic   get_ARBURST_index1( int _this_dot_1 );
        return do_get_ARBURST_index1( _this_dot_1 );
    endfunction


    task automatic set_ARLOCK( logic ARLOCK_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARLOCK( ARLOCK_param, non_blocking );
    endtask

    function automatic logic get_ARLOCK(  );
        return do_get_ARLOCK(  );
    endfunction


    task automatic set_ARCACHE( logic [3:0] ARCACHE_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARCACHE( ARCACHE_param, non_blocking );
    endtask

    task automatic set_ARCACHE_index1( int _this_dot_1, logic  ARCACHE_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARCACHE_index1( _this_dot_1, ARCACHE_param, non_blocking );
    endtask

    function automatic logic [3:0]  get_ARCACHE(  );
        return do_get_ARCACHE(  );
    endfunction

    function automatic logic   get_ARCACHE_index1( int _this_dot_1 );
        return do_get_ARCACHE_index1( _this_dot_1 );
    endfunction


    task automatic set_ARQOS( logic [3:0] ARQOS_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARQOS( ARQOS_param, non_blocking );
    endtask

    task automatic set_ARQOS_index1( int _this_dot_1, logic  ARQOS_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARQOS_index1( _this_dot_1, ARQOS_param, non_blocking );
    endtask

    function automatic logic [3:0]  get_ARQOS(  );
        return do_get_ARQOS(  );
    endfunction

    function automatic logic   get_ARQOS_index1( int _this_dot_1 );
        return do_get_ARQOS_index1( _this_dot_1 );
    endfunction


    task automatic set_ARID( logic [((AXI4_ID_WIDTH) - 1):0]  ARID_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARID( ARID_param, non_blocking );
    endtask

    task automatic set_ARID_index1( int _this_dot_1, logic  ARID_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARID_index1( _this_dot_1, ARID_param, non_blocking );
    endtask

    function automatic logic [((AXI4_ID_WIDTH) - 1):0]   get_ARID(  );
        return do_get_ARID(  );
    endfunction

    function automatic logic   get_ARID_index1( int _this_dot_1 );
        return do_get_ARID_index1( _this_dot_1 );
    endfunction


    task automatic set_ARUSER( logic [((AXI4_USER_WIDTH) - 1):0]  ARUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARUSER( ARUSER_param, non_blocking );
    endtask

    task automatic set_ARUSER_index1( int _this_dot_1, logic  ARUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARUSER_index1( _this_dot_1, ARUSER_param, non_blocking );
    endtask

    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   get_ARUSER(  );
        return do_get_ARUSER(  );
    endfunction

    function automatic logic   get_ARUSER_index1( int _this_dot_1 );
        return do_get_ARUSER_index1( _this_dot_1 );
    endfunction


    task automatic set_ARREADY( logic ARREADY_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARREADY( ARREADY_param, non_blocking );
    endtask

    function automatic logic get_ARREADY(  );
        return do_get_ARREADY(  );
    endfunction


    task automatic set_RVALID( logic RVALID_param = 'z, bit non_blocking = 1'b0 );
        do_set_RVALID( RVALID_param, non_blocking );
    endtask

    function automatic logic get_RVALID(  );
        return do_get_RVALID(  );
    endfunction


    task automatic set_RDATA( logic [((AXI4_RDATA_WIDTH) - 1):0]  RDATA_param = 'z, bit non_blocking = 1'b0 );
        do_set_RDATA( RDATA_param, non_blocking );
    endtask

    task automatic set_RDATA_index1( int _this_dot_1, logic  RDATA_param = 'z, bit non_blocking = 1'b0 );
        do_set_RDATA_index1( _this_dot_1, RDATA_param, non_blocking );
    endtask

    function automatic logic [((AXI4_RDATA_WIDTH) - 1):0]   get_RDATA(  );
        return do_get_RDATA(  );
    endfunction

    function automatic logic   get_RDATA_index1( int _this_dot_1 );
        return do_get_RDATA_index1( _this_dot_1 );
    endfunction


    task automatic set_RRESP( logic [1:0] RRESP_param = 'z, bit non_blocking = 1'b0 );
        do_set_RRESP( RRESP_param, non_blocking );
    endtask

    task automatic set_RRESP_index1( int _this_dot_1, logic  RRESP_param = 'z, bit non_blocking = 1'b0 );
        do_set_RRESP_index1( _this_dot_1, RRESP_param, non_blocking );
    endtask

    function automatic logic [1:0]  get_RRESP(  );
        return do_get_RRESP(  );
    endfunction

    function automatic logic   get_RRESP_index1( int _this_dot_1 );
        return do_get_RRESP_index1( _this_dot_1 );
    endfunction


    task automatic set_RLAST( logic RLAST_param = 'z, bit non_blocking = 1'b0 );
        do_set_RLAST( RLAST_param, non_blocking );
    endtask

    function automatic logic get_RLAST(  );
        return do_get_RLAST(  );
    endfunction


    task automatic set_RID( logic [((AXI4_ID_WIDTH) - 1):0]  RID_param = 'z, bit non_blocking = 1'b0 );
        do_set_RID( RID_param, non_blocking );
    endtask

    task automatic set_RID_index1( int _this_dot_1, logic  RID_param = 'z, bit non_blocking = 1'b0 );
        do_set_RID_index1( _this_dot_1, RID_param, non_blocking );
    endtask

    function automatic logic [((AXI4_ID_WIDTH) - 1):0]   get_RID(  );
        return do_get_RID(  );
    endfunction

    function automatic logic   get_RID_index1( int _this_dot_1 );
        return do_get_RID_index1( _this_dot_1 );
    endfunction


    task automatic set_RUSER( logic [((AXI4_USER_WIDTH) - 1):0]  RUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_RUSER( RUSER_param, non_blocking );
    endtask

    task automatic set_RUSER_index1( int _this_dot_1, logic  RUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_RUSER_index1( _this_dot_1, RUSER_param, non_blocking );
    endtask

    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   get_RUSER(  );
        return do_get_RUSER(  );
    endfunction

    function automatic logic   get_RUSER_index1( int _this_dot_1 );
        return do_get_RUSER_index1( _this_dot_1 );
    endfunction


    task automatic set_RREADY( logic RREADY_param = 'z, bit non_blocking = 1'b0 );
        do_set_RREADY( RREADY_param, non_blocking );
    endtask

    function automatic logic get_RREADY(  );
        return do_get_RREADY(  );
    endfunction


    task automatic set_WVALID( logic WVALID_param = 'z, bit non_blocking = 1'b0 );
        do_set_WVALID( WVALID_param, non_blocking );
    endtask

    function automatic logic get_WVALID(  );
        return do_get_WVALID(  );
    endfunction


    task automatic set_WDATA( logic [((AXI4_WDATA_WIDTH) - 1):0]  WDATA_param = 'z, bit non_blocking = 1'b0 );
        do_set_WDATA( WDATA_param, non_blocking );
    endtask

    task automatic set_WDATA_index1( int _this_dot_1, logic  WDATA_param = 'z, bit non_blocking = 1'b0 );
        do_set_WDATA_index1( _this_dot_1, WDATA_param, non_blocking );
    endtask

    function automatic logic [((AXI4_WDATA_WIDTH) - 1):0]   get_WDATA(  );
        return do_get_WDATA(  );
    endfunction

    function automatic logic   get_WDATA_index1( int _this_dot_1 );
        return do_get_WDATA_index1( _this_dot_1 );
    endfunction


    task automatic set_WSTRB( logic [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  WSTRB_param = 'z, bit non_blocking = 1'b0 );
        do_set_WSTRB( WSTRB_param, non_blocking );
    endtask

    task automatic set_WSTRB_index1( int _this_dot_1, logic  WSTRB_param = 'z, bit non_blocking = 1'b0 );
        do_set_WSTRB_index1( _this_dot_1, WSTRB_param, non_blocking );
    endtask

    function automatic logic [(((AXI4_WDATA_WIDTH / 8)) - 1):0]   get_WSTRB(  );
        return do_get_WSTRB(  );
    endfunction

    function automatic logic   get_WSTRB_index1( int _this_dot_1 );
        return do_get_WSTRB_index1( _this_dot_1 );
    endfunction


    task automatic set_WLAST( logic WLAST_param = 'z, bit non_blocking = 1'b0 );
        do_set_WLAST( WLAST_param, non_blocking );
    endtask

    function automatic logic get_WLAST(  );
        return do_get_WLAST(  );
    endfunction


    task automatic set_WUSER( logic [((AXI4_USER_WIDTH) - 1):0]  WUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_WUSER( WUSER_param, non_blocking );
    endtask

    task automatic set_WUSER_index1( int _this_dot_1, logic  WUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_WUSER_index1( _this_dot_1, WUSER_param, non_blocking );
    endtask

    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   get_WUSER(  );
        return do_get_WUSER(  );
    endfunction

    function automatic logic   get_WUSER_index1( int _this_dot_1 );
        return do_get_WUSER_index1( _this_dot_1 );
    endfunction


    task automatic set_WREADY( logic WREADY_param = 'z, bit non_blocking = 1'b0 );
        do_set_WREADY( WREADY_param, non_blocking );
    endtask

    function automatic logic get_WREADY(  );
        return do_get_WREADY(  );
    endfunction


    task automatic set_BVALID( logic BVALID_param = 'z, bit non_blocking = 1'b0 );
        do_set_BVALID( BVALID_param, non_blocking );
    endtask

    function automatic logic get_BVALID(  );
        return do_get_BVALID(  );
    endfunction


    task automatic set_BRESP( logic [1:0] BRESP_param = 'z, bit non_blocking = 1'b0 );
        do_set_BRESP( BRESP_param, non_blocking );
    endtask

    task automatic set_BRESP_index1( int _this_dot_1, logic  BRESP_param = 'z, bit non_blocking = 1'b0 );
        do_set_BRESP_index1( _this_dot_1, BRESP_param, non_blocking );
    endtask

    function automatic logic [1:0]  get_BRESP(  );
        return do_get_BRESP(  );
    endfunction

    function automatic logic   get_BRESP_index1( int _this_dot_1 );
        return do_get_BRESP_index1( _this_dot_1 );
    endfunction


    task automatic set_BID( logic [((AXI4_ID_WIDTH) - 1):0]  BID_param = 'z, bit non_blocking = 1'b0 );
        do_set_BID( BID_param, non_blocking );
    endtask

    task automatic set_BID_index1( int _this_dot_1, logic  BID_param = 'z, bit non_blocking = 1'b0 );
        do_set_BID_index1( _this_dot_1, BID_param, non_blocking );
    endtask

    function automatic logic [((AXI4_ID_WIDTH) - 1):0]   get_BID(  );
        return do_get_BID(  );
    endfunction

    function automatic logic   get_BID_index1( int _this_dot_1 );
        return do_get_BID_index1( _this_dot_1 );
    endfunction


    task automatic set_BUSER( logic [((AXI4_USER_WIDTH) - 1):0]  BUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_BUSER( BUSER_param, non_blocking );
    endtask

    task automatic set_BUSER_index1( int _this_dot_1, logic  BUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_BUSER_index1( _this_dot_1, BUSER_param, non_blocking );
    endtask

    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   get_BUSER(  );
        return do_get_BUSER(  );
    endfunction

    function automatic logic   get_BUSER_index1( int _this_dot_1 );
        return do_get_BUSER_index1( _this_dot_1 );
    endfunction


    task automatic set_BREADY( logic BREADY_param = 'z, bit non_blocking = 1'b0 );
        do_set_BREADY( BREADY_param, non_blocking );
    endtask

    function automatic logic get_BREADY(  );
        return do_get_BREADY(  );
    endfunction



    //------------------------------------------------------------------------------
    // Tasks to wait for a change to a global variable with read access
    //------------------------------------------------------------------------------
    task automatic wait_for_config_interface_type(  );
        do_wait_for_config_interface_type(  );
    endtask

    task automatic wait_for_config_clk_init_value(  );
        do_wait_for_config_clk_init_value(  );
    endtask

    task automatic wait_for_config_clk_phase_shift(  );
        do_wait_for_config_clk_phase_shift(  );
    endtask

    task automatic wait_for_config_clk_1st_time(  );
        do_wait_for_config_clk_1st_time(  );
    endtask

    task automatic wait_for_config_clk_2nd_time(  );
        do_wait_for_config_clk_2nd_time(  );
    endtask

    task automatic wait_for_config_setup_time(  );
        do_wait_for_config_setup_time(  );
    endtask

    task automatic wait_for_config_hold_time(  );
        do_wait_for_config_hold_time(  );
    endtask

    task automatic wait_for_config_burst_timeout_factor(  );
        do_wait_for_config_burst_timeout_factor(  );
    endtask

    task automatic wait_for_config_max_transaction_time_factor(  );
        do_wait_for_config_max_transaction_time_factor(  );
    endtask

    task automatic wait_for_config_write_ctrl_first_ratio(  );
        do_wait_for_config_write_ctrl_first_ratio(  );
    endtask

    task automatic wait_for_config_write_data_first_ratio(  );
        do_wait_for_config_write_data_first_ratio(  );
    endtask

    task automatic wait_for_config_reset_low_clocks(  );
        do_wait_for_config_reset_low_clocks(  );
    endtask

    task automatic wait_for_config_reset_hold_time(  );
        do_wait_for_config_reset_hold_time(  );
    endtask

    task automatic wait_for_config_enable_rlast(  );
        do_wait_for_config_enable_rlast(  );
    endtask

    task automatic wait_for_config_enable_slave_exclusive(  );
        do_wait_for_config_enable_slave_exclusive(  );
    endtask

    task automatic wait_for_config_enable_burst_reserved_value(  );
        do_wait_for_config_enable_burst_reserved_value(  );
    endtask

    task automatic wait_for_config_enable_cache_value(  );
        do_wait_for_config_enable_cache_value(  );
    endtask

    task automatic wait_for_config_enable_cache_value_index1( input int _this_dot_1 );
        do_wait_for_config_enable_cache_value_index1( _this_dot_1 );
    endtask

    task automatic wait_for_internal_dummy_variable(  );
        do_wait_for_internal_dummy_variable(  );
    endtask

    task automatic wait_for_config_axi4lite_interface(  );
        do_wait_for_config_axi4lite_interface(  );
    endtask

    task automatic wait_for_config_axi4lite_tr_id(  );
        do_wait_for_config_axi4lite_tr_id(  );
    endtask

    task automatic wait_for_config_axi4lite_tr_id_index1( input int _this_dot_1 );
        do_wait_for_config_axi4lite_tr_id_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_enable_all_assertions(  );
        do_wait_for_config_enable_all_assertions(  );
    endtask

    task automatic wait_for_config_enable_assertion(  );
        do_wait_for_config_enable_assertion(  );
    endtask

    task automatic wait_for_config_enable_assertion_index1( input int _this_dot_1 );
        do_wait_for_config_enable_assertion_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_enable_error(  );
        do_wait_for_config_enable_error(  );
    endtask

    task automatic wait_for_config_enable_error_index1( input int _this_dot_1 );
        do_wait_for_config_enable_error_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_max_latency_AWVALID_assertion_to_AWREADY(  );
        do_wait_for_config_max_latency_AWVALID_assertion_to_AWREADY(  );
    endtask

    task automatic wait_for_config_max_latency_ARVALID_assertion_to_ARREADY(  );
        do_wait_for_config_max_latency_ARVALID_assertion_to_ARREADY(  );
    endtask

    task automatic wait_for_config_max_latency_RVALID_assertion_to_RREADY(  );
        do_wait_for_config_max_latency_RVALID_assertion_to_RREADY(  );
    endtask

    task automatic wait_for_config_max_latency_BVALID_assertion_to_BREADY(  );
        do_wait_for_config_max_latency_BVALID_assertion_to_BREADY(  );
    endtask

    task automatic wait_for_config_max_latency_WVALID_assertion_to_WREADY(  );
        do_wait_for_config_max_latency_WVALID_assertion_to_WREADY(  );
    endtask

    task automatic wait_for_config_enable_qos(  );
        do_wait_for_config_enable_qos(  );
    endtask

    task automatic wait_for_config_enable_region_support(  );
        do_wait_for_config_enable_region_support(  );
    endtask

    task automatic wait_for_config_slave_regions(  );
        do_wait_for_config_slave_regions(  );
    endtask

    task automatic wait_for_config_region(  );
        do_wait_for_config_region(  );
    endtask

    task automatic wait_for_config_region_index1( input int _this_dot_1 );
        do_wait_for_config_region_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_region_index2( input int _this_dot_1, input int _this_dot_2 );
        do_wait_for_config_region_index2( _this_dot_1, _this_dot_2 );
    endtask

    task automatic wait_for_region_error_state(  );
        do_wait_for_region_error_state(  );
    endtask

    task automatic wait_for_region_map_lb(  );
        do_wait_for_region_map_lb(  );
    endtask

    task automatic wait_for_region_map_lb_index1( input int _this_dot_1 );
        do_wait_for_region_map_lb_index1( _this_dot_1 );
    endtask

    task automatic wait_for_region_map_ub(  );
        do_wait_for_region_map_ub(  );
    endtask

    task automatic wait_for_region_map_ub_index1( input int _this_dot_1 );
        do_wait_for_region_map_ub_index1( _this_dot_1 );
    endtask

    task automatic wait_for_region_map_region(  );
        do_wait_for_region_map_region(  );
    endtask

    task automatic wait_for_region_map_region_index1( input int _this_dot_1 );
        do_wait_for_region_map_region_index1( _this_dot_1 );
    endtask

    task automatic wait_for_cacheable(  );
        do_wait_for_cacheable(  );
    endtask

    task automatic wait_for_cacheable_index1( input int _this_dot_1 );
        do_wait_for_cacheable_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_read_data_reordering_depth(  );
        do_wait_for_config_read_data_reordering_depth(  );
    endtask

    task automatic wait_for_config_slave_start_addr(  );
        do_wait_for_config_slave_start_addr(  );
    endtask

    task automatic wait_for_config_slave_start_addr_index1( input int _this_dot_1 );
        do_wait_for_config_slave_start_addr_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_slave_end_addr(  );
        do_wait_for_config_slave_end_addr(  );
    endtask

    task automatic wait_for_config_slave_end_addr_index1( input int _this_dot_1 );
        do_wait_for_config_slave_end_addr_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_slave_enabled_non_contiguous_address_spaces(  );
        do_wait_for_config_slave_enabled_non_contiguous_address_spaces(  );
    endtask

    task automatic wait_for_config_slave_possess_multiple_non_contiguous_address_spaces(  );
        do_wait_for_config_slave_possess_multiple_non_contiguous_address_spaces(  );
    endtask

    task automatic wait_for_config_slave_multiple_non_contiguous_start_address_range(  );
        do_wait_for_config_slave_multiple_non_contiguous_start_address_range(  );
    endtask

    task automatic wait_for_config_slave_multiple_non_contiguous_start_address_range_index1( input int _this_dot_1 );
        do_wait_for_config_slave_multiple_non_contiguous_start_address_range_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_slave_multiple_non_contiguous_start_address_range_index2( input int _this_dot_1, input int _this_dot_2 );
        do_wait_for_config_slave_multiple_non_contiguous_start_address_range_index2( _this_dot_1, _this_dot_2 );
    endtask

    task automatic wait_for_config_slave_multiple_non_contiguous_end_address_range(  );
        do_wait_for_config_slave_multiple_non_contiguous_end_address_range(  );
    endtask

    task automatic wait_for_config_slave_multiple_non_contiguous_end_address_range_index1( input int _this_dot_1 );
        do_wait_for_config_slave_multiple_non_contiguous_end_address_range_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_slave_multiple_non_contiguous_end_address_range_index2( input int _this_dot_1, input int _this_dot_2 );
        do_wait_for_config_slave_multiple_non_contiguous_end_address_range_index2( _this_dot_1, _this_dot_2 );
    endtask

    task automatic wait_for_config_protect_ready(  );
        do_wait_for_config_protect_ready(  );
    endtask

    task automatic wait_for_master_end_tlm_status(  );
        do_wait_for_master_end_tlm_status(  );
    endtask

    task automatic wait_for_master_end_wlm_status(  );
        do_wait_for_master_end_wlm_status(  );
    endtask

    task automatic wait_for_slave_end_tlm_status(  );
        do_wait_for_slave_end_tlm_status(  );
    endtask

    task automatic wait_for_slave_end_wlm_status(  );
        do_wait_for_slave_end_wlm_status(  );
    endtask

    task automatic wait_for_clock_source_end_tlm_status(  );
        do_wait_for_clock_source_end_tlm_status(  );
    endtask

    task automatic wait_for_clock_source_end_wlm_status(  );
        do_wait_for_clock_source_end_wlm_status(  );
    endtask

    task automatic wait_for_reset_source_end_tlm_status(  );
        do_wait_for_reset_source_end_tlm_status(  );
    endtask

    task automatic wait_for_reset_source_end_wlm_status(  );
        do_wait_for_reset_source_end_wlm_status(  );
    endtask

    task automatic wait_for_config_max_outstanding_wr(  );
        do_wait_for_config_max_outstanding_wr(  );
    endtask

    task automatic wait_for_config_max_outstanding_rd(  );
        do_wait_for_config_max_outstanding_rd(  );
    endtask

    task automatic wait_for_config_num_outstanding_wr_phase(  );
        do_wait_for_config_num_outstanding_wr_phase(  );
    endtask

    task automatic wait_for_config_num_outstanding_rd_phase(  );
        do_wait_for_config_num_outstanding_rd_phase(  );
    endtask

    task automatic wait_for_config_enable_warnings(  );
        do_wait_for_config_enable_warnings(  );
    endtask

    task automatic wait_for_config_enable_errors(  );
        do_wait_for_config_enable_errors(  );
    endtask

    task automatic wait_for_config_enable_exclusive_checks(  );
        do_wait_for_config_enable_exclusive_checks(  );
    endtask

    task automatic wait_for_config_warn_on_slave_errors(  );
        do_wait_for_config_warn_on_slave_errors(  );
    endtask

    task automatic wait_for_config_error_on_deleted_valid_cycles(  );
        do_wait_for_config_error_on_deleted_valid_cycles(  );
    endtask

    task automatic wait_for_config_stats_enable(  );
        do_wait_for_config_stats_enable(  );
    endtask

    task automatic wait_for_config_stats_enable_read_occupancy(  );
        do_wait_for_config_stats_enable_read_occupancy(  );
    endtask

    task automatic wait_for_config_stats_enable_write_occupancy(  );
        do_wait_for_config_stats_enable_write_occupancy(  );
    endtask

    task automatic wait_for_config_stats_enable_read_data_occupancy(  );
        do_wait_for_config_stats_enable_read_data_occupancy(  );
    endtask

    task automatic wait_for_config_stats_enable_write_data_occupancy(  );
        do_wait_for_config_stats_enable_write_data_occupancy(  );
    endtask

    task automatic wait_for_config_stats_enable_read_latency(  );
        do_wait_for_config_stats_enable_read_latency(  );
    endtask

    task automatic wait_for_config_stats_enable_write_latency(  );
        do_wait_for_config_stats_enable_write_latency(  );
    endtask

    task automatic wait_for_config_stats_enable_read_address_waits(  );
        do_wait_for_config_stats_enable_read_address_waits(  );
    endtask

    task automatic wait_for_config_stats_enable_read_data_waits(  );
        do_wait_for_config_stats_enable_read_data_waits(  );
    endtask

    task automatic wait_for_config_stats_enable_write_address_waits(  );
        do_wait_for_config_stats_enable_write_address_waits(  );
    endtask

    task automatic wait_for_config_stats_enable_write_data_waits(  );
        do_wait_for_config_stats_enable_write_data_waits(  );
    endtask

    task automatic wait_for_config_stats_enable_write_response_waits(  );
        do_wait_for_config_stats_enable_write_response_waits(  );
    endtask

    task automatic wait_for_config_stats_enable_read_bandwidth(  );
        do_wait_for_config_stats_enable_read_bandwidth(  );
    endtask

    task automatic wait_for_config_stats_enable_write_bandwidth(  );
        do_wait_for_config_stats_enable_write_bandwidth(  );
    endtask

    task automatic wait_for_stats_rw_transaction_last_duration(  );
        do_wait_for_stats_rw_transaction_last_duration(  );
    endtask

    task automatic wait_for_config_stats_read_occupancy_step(  );
        do_wait_for_config_stats_read_occupancy_step(  );
    endtask

    task automatic wait_for_config_stats_read_occupancy_multiple(  );
        do_wait_for_config_stats_read_occupancy_multiple(  );
    endtask

    task automatic wait_for_stats_read_active(  );
        do_wait_for_stats_read_active(  );
    endtask

    task automatic wait_for_stats_read_occupancy_sw(  );
        do_wait_for_stats_read_occupancy_sw(  );
    endtask

    task automatic wait_for_stats_read_idle_sw(  );
        do_wait_for_stats_read_idle_sw(  );
    endtask

    task automatic wait_for_stats_read_occupancy_min(  );
        do_wait_for_stats_read_occupancy_min(  );
    endtask

    task automatic wait_for_stats_read_idle_min(  );
        do_wait_for_stats_read_idle_min(  );
    endtask

    task automatic wait_for_stats_read_occupancy_max(  );
        do_wait_for_stats_read_occupancy_max(  );
    endtask

    task automatic wait_for_stats_read_idle_max(  );
        do_wait_for_stats_read_idle_max(  );
    endtask

    task automatic wait_for_stats_read_occupancy_mean(  );
        do_wait_for_stats_read_occupancy_mean(  );
    endtask

    task automatic wait_for_stats_read_idle_mean(  );
        do_wait_for_stats_read_idle_mean(  );
    endtask

    task automatic wait_for_stats_read_last_duration(  );
        do_wait_for_stats_read_last_duration(  );
    endtask

    task automatic wait_for_config_stats_write_occupancy_step(  );
        do_wait_for_config_stats_write_occupancy_step(  );
    endtask

    task automatic wait_for_config_stats_write_occupancy_multiple(  );
        do_wait_for_config_stats_write_occupancy_multiple(  );
    endtask

    task automatic wait_for_stats_write_active(  );
        do_wait_for_stats_write_active(  );
    endtask

    task automatic wait_for_stats_write_occupancy_sw(  );
        do_wait_for_stats_write_occupancy_sw(  );
    endtask

    task automatic wait_for_stats_write_idle_sw(  );
        do_wait_for_stats_write_idle_sw(  );
    endtask

    task automatic wait_for_stats_write_occupancy_min(  );
        do_wait_for_stats_write_occupancy_min(  );
    endtask

    task automatic wait_for_stats_write_idle_min(  );
        do_wait_for_stats_write_idle_min(  );
    endtask

    task automatic wait_for_stats_write_occupancy_max(  );
        do_wait_for_stats_write_occupancy_max(  );
    endtask

    task automatic wait_for_stats_write_idle_max(  );
        do_wait_for_stats_write_idle_max(  );
    endtask

    task automatic wait_for_stats_write_occupancy_mean(  );
        do_wait_for_stats_write_occupancy_mean(  );
    endtask

    task automatic wait_for_stats_write_idle_mean(  );
        do_wait_for_stats_write_idle_mean(  );
    endtask

    task automatic wait_for_stats_write_last_duration(  );
        do_wait_for_stats_write_last_duration(  );
    endtask

    task automatic wait_for_config_stats_read_data_occupancy_step(  );
        do_wait_for_config_stats_read_data_occupancy_step(  );
    endtask

    task automatic wait_for_config_stats_read_data_occupancy_multiple(  );
        do_wait_for_config_stats_read_data_occupancy_multiple(  );
    endtask

    task automatic wait_for_stats_read_data_occupancy_sw(  );
        do_wait_for_stats_read_data_occupancy_sw(  );
    endtask

    task automatic wait_for_stats_read_data_idle_sw(  );
        do_wait_for_stats_read_data_idle_sw(  );
    endtask

    task automatic wait_for_stats_read_data_occupancy_min(  );
        do_wait_for_stats_read_data_occupancy_min(  );
    endtask

    task automatic wait_for_stats_read_data_idle_min(  );
        do_wait_for_stats_read_data_idle_min(  );
    endtask

    task automatic wait_for_stats_read_data_occupancy_max(  );
        do_wait_for_stats_read_data_occupancy_max(  );
    endtask

    task automatic wait_for_stats_read_data_idle_max(  );
        do_wait_for_stats_read_data_idle_max(  );
    endtask

    task automatic wait_for_stats_read_data_occupancy_mean(  );
        do_wait_for_stats_read_data_occupancy_mean(  );
    endtask

    task automatic wait_for_stats_read_data_idle_mean(  );
        do_wait_for_stats_read_data_idle_mean(  );
    endtask

    task automatic wait_for_config_stats_write_data_occupancy_step(  );
        do_wait_for_config_stats_write_data_occupancy_step(  );
    endtask

    task automatic wait_for_config_stats_write_data_occupancy_multiple(  );
        do_wait_for_config_stats_write_data_occupancy_multiple(  );
    endtask

    task automatic wait_for_stats_write_data_occupancy_sw(  );
        do_wait_for_stats_write_data_occupancy_sw(  );
    endtask

    task automatic wait_for_stats_write_data_idle_sw(  );
        do_wait_for_stats_write_data_idle_sw(  );
    endtask

    task automatic wait_for_stats_write_data_occupancy_min(  );
        do_wait_for_stats_write_data_occupancy_min(  );
    endtask

    task automatic wait_for_stats_write_data_idle_min(  );
        do_wait_for_stats_write_data_idle_min(  );
    endtask

    task automatic wait_for_stats_write_data_occupancy_max(  );
        do_wait_for_stats_write_data_occupancy_max(  );
    endtask

    task automatic wait_for_stats_write_data_idle_max(  );
        do_wait_for_stats_write_data_idle_max(  );
    endtask

    task automatic wait_for_stats_write_data_occupancy_mean(  );
        do_wait_for_stats_write_data_occupancy_mean(  );
    endtask

    task automatic wait_for_stats_write_data_idle_mean(  );
        do_wait_for_stats_write_data_idle_mean(  );
    endtask

    task automatic wait_for_config_stats_read_bandwidth_step(  );
        do_wait_for_config_stats_read_bandwidth_step(  );
    endtask

    task automatic wait_for_config_stats_read_bandwidth_multiple(  );
        do_wait_for_config_stats_read_bandwidth_multiple(  );
    endtask

    task automatic wait_for_stats_read_bandwidth_sw(  );
        do_wait_for_stats_read_bandwidth_sw(  );
    endtask

    task automatic wait_for_stats_read_bandwidth_min(  );
        do_wait_for_stats_read_bandwidth_min(  );
    endtask

    task automatic wait_for_stats_read_bandwidth_max(  );
        do_wait_for_stats_read_bandwidth_max(  );
    endtask

    task automatic wait_for_stats_read_bandwidth_mean(  );
        do_wait_for_stats_read_bandwidth_mean(  );
    endtask

    task automatic wait_for_config_stats_write_bandwidth_step(  );
        do_wait_for_config_stats_write_bandwidth_step(  );
    endtask

    task automatic wait_for_config_stats_write_bandwidth_multiple(  );
        do_wait_for_config_stats_write_bandwidth_multiple(  );
    endtask

    task automatic wait_for_stats_write_bandwidth_sw(  );
        do_wait_for_stats_write_bandwidth_sw(  );
    endtask

    task automatic wait_for_stats_write_bandwidth_min(  );
        do_wait_for_stats_write_bandwidth_min(  );
    endtask

    task automatic wait_for_stats_write_bandwidth_max(  );
        do_wait_for_stats_write_bandwidth_max(  );
    endtask

    task automatic wait_for_stats_write_bandwidth_mean(  );
        do_wait_for_stats_write_bandwidth_mean(  );
    endtask

    task automatic wait_for_config_stats_read_latency_step(  );
        do_wait_for_config_stats_read_latency_step(  );
    endtask

    task automatic wait_for_config_stats_read_latency_multiple(  );
        do_wait_for_config_stats_read_latency_multiple(  );
    endtask

    task automatic wait_for_stats_read_address_data_latency_inst(  );
        do_wait_for_stats_read_address_data_latency_inst(  );
    endtask

    task automatic wait_for_stats_read_address_data_latency_sw(  );
        do_wait_for_stats_read_address_data_latency_sw(  );
    endtask

    task automatic wait_for_stats_read_address_data_latency_min(  );
        do_wait_for_stats_read_address_data_latency_min(  );
    endtask

    task automatic wait_for_stats_read_address_data_latency_max(  );
        do_wait_for_stats_read_address_data_latency_max(  );
    endtask

    task automatic wait_for_stats_read_address_data_latency_mean(  );
        do_wait_for_stats_read_address_data_latency_mean(  );
    endtask

    task automatic wait_for_stats_read_address_address_latency_inst(  );
        do_wait_for_stats_read_address_address_latency_inst(  );
    endtask

    task automatic wait_for_stats_read_address_address_latency_sw(  );
        do_wait_for_stats_read_address_address_latency_sw(  );
    endtask

    task automatic wait_for_stats_read_address_address_latency_min(  );
        do_wait_for_stats_read_address_address_latency_min(  );
    endtask

    task automatic wait_for_stats_read_address_address_latency_max(  );
        do_wait_for_stats_read_address_address_latency_max(  );
    endtask

    task automatic wait_for_stats_read_address_address_latency_mean(  );
        do_wait_for_stats_read_address_address_latency_mean(  );
    endtask

    task automatic wait_for_config_stats_write_latency_step(  );
        do_wait_for_config_stats_write_latency_step(  );
    endtask

    task automatic wait_for_config_stats_write_latency_multiple(  );
        do_wait_for_config_stats_write_latency_multiple(  );
    endtask

    task automatic wait_for_stats_write_address_response_latency_inst(  );
        do_wait_for_stats_write_address_response_latency_inst(  );
    endtask

    task automatic wait_for_stats_write_address_response_latency_sw(  );
        do_wait_for_stats_write_address_response_latency_sw(  );
    endtask

    task automatic wait_for_stats_write_address_response_latency_min(  );
        do_wait_for_stats_write_address_response_latency_min(  );
    endtask

    task automatic wait_for_stats_write_address_response_latency_max(  );
        do_wait_for_stats_write_address_response_latency_max(  );
    endtask

    task automatic wait_for_stats_write_address_response_latency_mean(  );
        do_wait_for_stats_write_address_response_latency_mean(  );
    endtask

    task automatic wait_for_stats_write_address_address_latency_inst(  );
        do_wait_for_stats_write_address_address_latency_inst(  );
    endtask

    task automatic wait_for_stats_write_address_address_latency_sw(  );
        do_wait_for_stats_write_address_address_latency_sw(  );
    endtask

    task automatic wait_for_stats_write_address_address_latency_min(  );
        do_wait_for_stats_write_address_address_latency_min(  );
    endtask

    task automatic wait_for_stats_write_address_address_latency_max(  );
        do_wait_for_stats_write_address_address_latency_max(  );
    endtask

    task automatic wait_for_stats_write_address_address_latency_mean(  );
        do_wait_for_stats_write_address_address_latency_mean(  );
    endtask

    task automatic wait_for_config_stats_read_address_waits_step(  );
        do_wait_for_config_stats_read_address_waits_step(  );
    endtask

    task automatic wait_for_config_stats_read_address_waits_multiple(  );
        do_wait_for_config_stats_read_address_waits_multiple(  );
    endtask

    task automatic wait_for_stats_read_address_waits_inst(  );
        do_wait_for_stats_read_address_waits_inst(  );
    endtask

    task automatic wait_for_stats_read_address_waits_sw(  );
        do_wait_for_stats_read_address_waits_sw(  );
    endtask

    task automatic wait_for_stats_read_address_waits_min(  );
        do_wait_for_stats_read_address_waits_min(  );
    endtask

    task automatic wait_for_stats_read_address_waits_max(  );
        do_wait_for_stats_read_address_waits_max(  );
    endtask

    task automatic wait_for_stats_read_address_waits_mean(  );
        do_wait_for_stats_read_address_waits_mean(  );
    endtask

    task automatic wait_for_config_stats_read_data_waits_step(  );
        do_wait_for_config_stats_read_data_waits_step(  );
    endtask

    task automatic wait_for_config_stats_read_data_waits_multiple(  );
        do_wait_for_config_stats_read_data_waits_multiple(  );
    endtask

    task automatic wait_for_stats_read_data_waits_inst(  );
        do_wait_for_stats_read_data_waits_inst(  );
    endtask

    task automatic wait_for_stats_read_data_waits_sw(  );
        do_wait_for_stats_read_data_waits_sw(  );
    endtask

    task automatic wait_for_stats_read_data_waits_min(  );
        do_wait_for_stats_read_data_waits_min(  );
    endtask

    task automatic wait_for_stats_read_data_waits_max(  );
        do_wait_for_stats_read_data_waits_max(  );
    endtask

    task automatic wait_for_stats_read_data_waits_mean(  );
        do_wait_for_stats_read_data_waits_mean(  );
    endtask

    task automatic wait_for_config_stats_write_address_waits_step(  );
        do_wait_for_config_stats_write_address_waits_step(  );
    endtask

    task automatic wait_for_config_stats_write_address_waits_multiple(  );
        do_wait_for_config_stats_write_address_waits_multiple(  );
    endtask

    task automatic wait_for_stats_write_address_waits_inst(  );
        do_wait_for_stats_write_address_waits_inst(  );
    endtask

    task automatic wait_for_stats_write_address_waits_sw(  );
        do_wait_for_stats_write_address_waits_sw(  );
    endtask

    task automatic wait_for_stats_write_address_waits_min(  );
        do_wait_for_stats_write_address_waits_min(  );
    endtask

    task automatic wait_for_stats_write_address_waits_max(  );
        do_wait_for_stats_write_address_waits_max(  );
    endtask

    task automatic wait_for_stats_write_address_waits_mean(  );
        do_wait_for_stats_write_address_waits_mean(  );
    endtask

    task automatic wait_for_config_stats_write_data_waits_step(  );
        do_wait_for_config_stats_write_data_waits_step(  );
    endtask

    task automatic wait_for_config_stats_write_data_waits_multiple(  );
        do_wait_for_config_stats_write_data_waits_multiple(  );
    endtask

    task automatic wait_for_stats_write_data_waits_inst(  );
        do_wait_for_stats_write_data_waits_inst(  );
    endtask

    task automatic wait_for_stats_write_data_waits_sw(  );
        do_wait_for_stats_write_data_waits_sw(  );
    endtask

    task automatic wait_for_stats_write_data_waits_min(  );
        do_wait_for_stats_write_data_waits_min(  );
    endtask

    task automatic wait_for_stats_write_data_waits_max(  );
        do_wait_for_stats_write_data_waits_max(  );
    endtask

    task automatic wait_for_stats_write_data_waits_mean(  );
        do_wait_for_stats_write_data_waits_mean(  );
    endtask

    task automatic wait_for_config_stats_write_response_waits_step(  );
        do_wait_for_config_stats_write_response_waits_step(  );
    endtask

    task automatic wait_for_config_stats_write_response_waits_multiple(  );
        do_wait_for_config_stats_write_response_waits_multiple(  );
    endtask

    task automatic wait_for_stats_write_response_waits_inst(  );
        do_wait_for_stats_write_response_waits_inst(  );
    endtask

    task automatic wait_for_stats_write_response_waits_sw(  );
        do_wait_for_stats_write_response_waits_sw(  );
    endtask

    task automatic wait_for_stats_write_response_waits_min(  );
        do_wait_for_stats_write_response_waits_min(  );
    endtask

    task automatic wait_for_stats_write_response_waits_max(  );
        do_wait_for_stats_write_response_waits_max(  );
    endtask

    task automatic wait_for_stats_write_response_waits_mean(  );
        do_wait_for_stats_write_response_waits_mean(  );
    endtask

    task automatic wait_for_reordering_depth_of_last_read_transaction(  );
        do_wait_for_reordering_depth_of_last_read_transaction(  );
    endtask


    //------------------------------------------------------------------------------
    // Functions to set global variables with write access
    //------------------------------------------------------------------------------
    function automatic void set_config_interface_type( axi4_interface_type_e config_interface_type_param );
        do_set_config_interface_type( config_interface_type_param );
    endfunction

    function automatic void set_config_clk_init_value( bit config_clk_init_value_param );
        do_set_config_clk_init_value( config_clk_init_value_param );
    endfunction

    function automatic void set_config_clk_phase_shift( longint unsigned config_clk_phase_shift_param );
        do_set_config_clk_phase_shift( config_clk_phase_shift_param );
    endfunction

    function automatic void set_config_clk_1st_time( longint unsigned config_clk_1st_time_param );
        do_set_config_clk_1st_time( config_clk_1st_time_param );
    endfunction

    function automatic void set_config_clk_2nd_time( longint unsigned config_clk_2nd_time_param );
        do_set_config_clk_2nd_time( config_clk_2nd_time_param );
    endfunction

    function automatic void set_config_setup_time( longint unsigned config_setup_time_param );
        do_set_config_setup_time( config_setup_time_param );
    endfunction

    function automatic void set_config_hold_time( longint unsigned config_hold_time_param );
        do_set_config_hold_time( config_hold_time_param );
    endfunction

    function automatic void set_config_burst_timeout_factor( int unsigned config_burst_timeout_factor_param );
        do_set_config_burst_timeout_factor( config_burst_timeout_factor_param );
    endfunction

    function automatic void set_config_max_transaction_time_factor( int unsigned config_max_transaction_time_factor_param );
        do_set_config_max_transaction_time_factor( config_max_transaction_time_factor_param );
    endfunction

    function automatic void set_config_write_ctrl_first_ratio( int config_write_ctrl_first_ratio_param );
        do_set_config_write_ctrl_first_ratio( config_write_ctrl_first_ratio_param );
    endfunction

    function automatic void set_config_write_data_first_ratio( int config_write_data_first_ratio_param );
        do_set_config_write_data_first_ratio( config_write_data_first_ratio_param );
    endfunction

    function automatic void set_config_reset_low_clocks( int config_reset_low_clocks_param );
        do_set_config_reset_low_clocks( config_reset_low_clocks_param );
    endfunction

    function automatic void set_config_reset_hold_time( int config_reset_hold_time_param );
        do_set_config_reset_hold_time( config_reset_hold_time_param );
    endfunction

    function automatic void set_config_enable_rlast( bit config_enable_rlast_param );
        do_set_config_enable_rlast( config_enable_rlast_param );
    endfunction

    function automatic void set_config_enable_slave_exclusive( bit config_enable_slave_exclusive_param );
        do_set_config_enable_slave_exclusive( config_enable_slave_exclusive_param );
    endfunction

    function automatic void set_config_enable_burst_reserved_value( bit config_enable_burst_reserved_value_param );
        do_set_config_enable_burst_reserved_value( config_enable_burst_reserved_value_param );
    endfunction

    function automatic void set_config_enable_cache_value( bit [15:0] config_enable_cache_value_param );
        do_set_config_enable_cache_value( config_enable_cache_value_param );
    endfunction

    function automatic void set_config_enable_cache_value_index1( int _this_dot_1, bit  config_enable_cache_value_param );
        do_set_config_enable_cache_value_index1( _this_dot_1, config_enable_cache_value_param );
    endfunction

    function automatic void set_internal_dummy_variable( axi4_error_e internal_dummy_variable_param );
        do_set_internal_dummy_variable( internal_dummy_variable_param );
    endfunction

    function automatic void set_config_axi4lite_interface( bit config_axi4lite_interface_param );
        do_set_config_axi4lite_interface( config_axi4lite_interface_param );
    endfunction

    function automatic void set_config_axi4lite_tr_id( bit [((AXI4_ID_WIDTH) - 1):0]  config_axi4lite_tr_id_param );
        do_set_config_axi4lite_tr_id( config_axi4lite_tr_id_param );
    endfunction

    function automatic void set_config_axi4lite_tr_id_index1( int _this_dot_1, bit  config_axi4lite_tr_id_param );
        do_set_config_axi4lite_tr_id_index1( _this_dot_1, config_axi4lite_tr_id_param );
    endfunction

    function automatic void set_config_enable_all_assertions( bit config_enable_all_assertions_param );
        do_set_config_enable_all_assertions( config_enable_all_assertions_param );
    endfunction

    function automatic void set_config_enable_assertion( bit [255:0] config_enable_assertion_param );
        do_set_config_enable_assertion( config_enable_assertion_param );
    endfunction

    function automatic void set_config_enable_assertion_index1( int _this_dot_1, bit  config_enable_assertion_param );
        do_set_config_enable_assertion_index1( _this_dot_1, config_enable_assertion_param );
    endfunction

    function automatic void set_config_enable_error( bit [255:0] config_enable_error_param );
        do_set_config_enable_error( config_enable_error_param );
    endfunction

    function automatic void set_config_enable_error_index1( int _this_dot_1, bit  config_enable_error_param );
        do_set_config_enable_error_index1( _this_dot_1, config_enable_error_param );
    endfunction

    function automatic void set_config_max_latency_AWVALID_assertion_to_AWREADY( int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
        do_set_config_max_latency_AWVALID_assertion_to_AWREADY( config_max_latency_AWVALID_assertion_to_AWREADY_param );
    endfunction

    function automatic void set_config_max_latency_ARVALID_assertion_to_ARREADY( int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
        do_set_config_max_latency_ARVALID_assertion_to_ARREADY( config_max_latency_ARVALID_assertion_to_ARREADY_param );
    endfunction

    function automatic void set_config_max_latency_RVALID_assertion_to_RREADY( int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
        do_set_config_max_latency_RVALID_assertion_to_RREADY( config_max_latency_RVALID_assertion_to_RREADY_param );
    endfunction

    function automatic void set_config_max_latency_BVALID_assertion_to_BREADY( int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
        do_set_config_max_latency_BVALID_assertion_to_BREADY( config_max_latency_BVALID_assertion_to_BREADY_param );
    endfunction

    function automatic void set_config_max_latency_WVALID_assertion_to_WREADY( int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
        do_set_config_max_latency_WVALID_assertion_to_WREADY( config_max_latency_WVALID_assertion_to_WREADY_param );
    endfunction

    function automatic void set_config_enable_qos( bit config_enable_qos_param );
        do_set_config_enable_qos( config_enable_qos_param );
    endfunction

    function automatic void set_config_enable_region_support( bit config_enable_region_support_param );
        do_set_config_enable_region_support( config_enable_region_support_param );
    endfunction

    function automatic void set_config_slave_regions( int config_slave_regions_param );
        do_set_config_slave_regions( config_slave_regions_param );
    endfunction

    function automatic void set_config_region( bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  config_region_param );
        do_set_config_region( config_region_param );
    endfunction

    function automatic void set_config_region_index1( int _this_dot_1, bit [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  config_region_param );
        do_set_config_region_index1( _this_dot_1, config_region_param );
    endfunction

    function automatic void set_config_region_index2( int _this_dot_1, int _this_dot_2, bit  config_region_param );
        do_set_config_region_index2( _this_dot_1, _this_dot_2, config_region_param );
    endfunction

    function automatic void set_config_read_data_reordering_depth( int unsigned config_read_data_reordering_depth_param );
        do_set_config_read_data_reordering_depth( config_read_data_reordering_depth_param );
    endfunction

    function automatic void set_config_slave_start_addr( bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param );
        do_set_config_slave_start_addr( config_slave_start_addr_param );
    endfunction

    function automatic void set_config_slave_start_addr_index1( int _this_dot_1, bit  config_slave_start_addr_param );
        do_set_config_slave_start_addr_index1( _this_dot_1, config_slave_start_addr_param );
    endfunction

    function automatic void set_config_slave_end_addr( bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param );
        do_set_config_slave_end_addr( config_slave_end_addr_param );
    endfunction

    function automatic void set_config_slave_end_addr_index1( int _this_dot_1, bit  config_slave_end_addr_param );
        do_set_config_slave_end_addr_index1( _this_dot_1, config_slave_end_addr_param );
    endfunction

    function automatic void set_config_slave_enabled_non_contiguous_address_spaces( int config_slave_enabled_non_contiguous_address_spaces_param );
        do_set_config_slave_enabled_non_contiguous_address_spaces( config_slave_enabled_non_contiguous_address_spaces_param );
    endfunction

    function automatic void set_config_slave_possess_multiple_non_contiguous_address_spaces( bit config_slave_possess_multiple_non_contiguous_address_spaces_param );
        do_set_config_slave_possess_multiple_non_contiguous_address_spaces( config_slave_possess_multiple_non_contiguous_address_spaces_param );
    endfunction

    function automatic void set_config_slave_multiple_non_contiguous_start_address_range( bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_start_address_range_param );
        do_set_config_slave_multiple_non_contiguous_start_address_range( config_slave_multiple_non_contiguous_start_address_range_param );
    endfunction

    function automatic void set_config_slave_multiple_non_contiguous_start_address_range_index1( int _this_dot_1, bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_start_address_range_param );
        do_set_config_slave_multiple_non_contiguous_start_address_range_index1( _this_dot_1, config_slave_multiple_non_contiguous_start_address_range_param );
    endfunction

    function automatic void set_config_slave_multiple_non_contiguous_start_address_range_index2( int _this_dot_1, int _this_dot_2, bit  config_slave_multiple_non_contiguous_start_address_range_param );
        do_set_config_slave_multiple_non_contiguous_start_address_range_index2( _this_dot_1, _this_dot_2, config_slave_multiple_non_contiguous_start_address_range_param );
    endfunction

    function automatic void set_config_slave_multiple_non_contiguous_end_address_range( bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_end_address_range_param );
        do_set_config_slave_multiple_non_contiguous_end_address_range( config_slave_multiple_non_contiguous_end_address_range_param );
    endfunction

    function automatic void set_config_slave_multiple_non_contiguous_end_address_range_index1( int _this_dot_1, bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_end_address_range_param );
        do_set_config_slave_multiple_non_contiguous_end_address_range_index1( _this_dot_1, config_slave_multiple_non_contiguous_end_address_range_param );
    endfunction

    function automatic void set_config_slave_multiple_non_contiguous_end_address_range_index2( int _this_dot_1, int _this_dot_2, bit  config_slave_multiple_non_contiguous_end_address_range_param );
        do_set_config_slave_multiple_non_contiguous_end_address_range_index2( _this_dot_1, _this_dot_2, config_slave_multiple_non_contiguous_end_address_range_param );
    endfunction

    function automatic void set_config_protect_ready( bit config_protect_ready_param );
        do_set_config_protect_ready( config_protect_ready_param );
    endfunction

    function automatic void set_config_max_outstanding_wr( int config_max_outstanding_wr_param );
        do_set_config_max_outstanding_wr( config_max_outstanding_wr_param );
    endfunction

    function automatic void set_config_max_outstanding_rd( int config_max_outstanding_rd_param );
        do_set_config_max_outstanding_rd( config_max_outstanding_rd_param );
    endfunction

    function automatic void set_config_num_outstanding_wr_phase( int config_num_outstanding_wr_phase_param );
        do_set_config_num_outstanding_wr_phase( config_num_outstanding_wr_phase_param );
    endfunction

    function automatic void set_config_num_outstanding_rd_phase( int config_num_outstanding_rd_phase_param );
        do_set_config_num_outstanding_rd_phase( config_num_outstanding_rd_phase_param );
    endfunction

    function automatic void set_config_enable_warnings( bit config_enable_warnings_param );
        do_set_config_enable_warnings( config_enable_warnings_param );
    endfunction

    function automatic void set_config_enable_errors( bit config_enable_errors_param );
        do_set_config_enable_errors( config_enable_errors_param );
    endfunction

    function automatic void set_config_enable_exclusive_checks( bit config_enable_exclusive_checks_param );
        do_set_config_enable_exclusive_checks( config_enable_exclusive_checks_param );
    endfunction

    function automatic void set_config_warn_on_slave_errors( bit config_warn_on_slave_errors_param );
        do_set_config_warn_on_slave_errors( config_warn_on_slave_errors_param );
    endfunction

    function automatic void set_config_error_on_deleted_valid_cycles( bit config_error_on_deleted_valid_cycles_param );
        do_set_config_error_on_deleted_valid_cycles( config_error_on_deleted_valid_cycles_param );
    endfunction

    function automatic void set_config_stats_enable( bit config_stats_enable_param );
        do_set_config_stats_enable( config_stats_enable_param );
    endfunction

    function automatic void set_config_stats_enable_read_occupancy( bit config_stats_enable_read_occupancy_param );
        do_set_config_stats_enable_read_occupancy( config_stats_enable_read_occupancy_param );
    endfunction

    function automatic void set_config_stats_enable_write_occupancy( bit config_stats_enable_write_occupancy_param );
        do_set_config_stats_enable_write_occupancy( config_stats_enable_write_occupancy_param );
    endfunction

    function automatic void set_config_stats_enable_read_data_occupancy( bit config_stats_enable_read_data_occupancy_param );
        do_set_config_stats_enable_read_data_occupancy( config_stats_enable_read_data_occupancy_param );
    endfunction

    function automatic void set_config_stats_enable_write_data_occupancy( bit config_stats_enable_write_data_occupancy_param );
        do_set_config_stats_enable_write_data_occupancy( config_stats_enable_write_data_occupancy_param );
    endfunction

    function automatic void set_config_stats_enable_read_latency( bit config_stats_enable_read_latency_param );
        do_set_config_stats_enable_read_latency( config_stats_enable_read_latency_param );
    endfunction

    function automatic void set_config_stats_enable_write_latency( bit config_stats_enable_write_latency_param );
        do_set_config_stats_enable_write_latency( config_stats_enable_write_latency_param );
    endfunction

    function automatic void set_config_stats_enable_read_address_waits( bit config_stats_enable_read_address_waits_param );
        do_set_config_stats_enable_read_address_waits( config_stats_enable_read_address_waits_param );
    endfunction

    function automatic void set_config_stats_enable_read_data_waits( bit config_stats_enable_read_data_waits_param );
        do_set_config_stats_enable_read_data_waits( config_stats_enable_read_data_waits_param );
    endfunction

    function automatic void set_config_stats_enable_write_address_waits( bit config_stats_enable_write_address_waits_param );
        do_set_config_stats_enable_write_address_waits( config_stats_enable_write_address_waits_param );
    endfunction

    function automatic void set_config_stats_enable_write_data_waits( bit config_stats_enable_write_data_waits_param );
        do_set_config_stats_enable_write_data_waits( config_stats_enable_write_data_waits_param );
    endfunction

    function automatic void set_config_stats_enable_write_response_waits( bit config_stats_enable_write_response_waits_param );
        do_set_config_stats_enable_write_response_waits( config_stats_enable_write_response_waits_param );
    endfunction

    function automatic void set_config_stats_enable_read_bandwidth( bit config_stats_enable_read_bandwidth_param );
        do_set_config_stats_enable_read_bandwidth( config_stats_enable_read_bandwidth_param );
    endfunction

    function automatic void set_config_stats_enable_write_bandwidth( bit config_stats_enable_write_bandwidth_param );
        do_set_config_stats_enable_write_bandwidth( config_stats_enable_write_bandwidth_param );
    endfunction

    function automatic void set_config_stats_read_occupancy_step( int config_stats_read_occupancy_step_param );
        do_set_config_stats_read_occupancy_step( config_stats_read_occupancy_step_param );
    endfunction

    function automatic void set_config_stats_read_occupancy_multiple( int config_stats_read_occupancy_multiple_param );
        do_set_config_stats_read_occupancy_multiple( config_stats_read_occupancy_multiple_param );
    endfunction

    function automatic void set_config_stats_write_occupancy_step( int config_stats_write_occupancy_step_param );
        do_set_config_stats_write_occupancy_step( config_stats_write_occupancy_step_param );
    endfunction

    function automatic void set_config_stats_write_occupancy_multiple( int config_stats_write_occupancy_multiple_param );
        do_set_config_stats_write_occupancy_multiple( config_stats_write_occupancy_multiple_param );
    endfunction

    function automatic void set_config_stats_read_data_occupancy_step( int config_stats_read_data_occupancy_step_param );
        do_set_config_stats_read_data_occupancy_step( config_stats_read_data_occupancy_step_param );
    endfunction

    function automatic void set_config_stats_read_data_occupancy_multiple( int config_stats_read_data_occupancy_multiple_param );
        do_set_config_stats_read_data_occupancy_multiple( config_stats_read_data_occupancy_multiple_param );
    endfunction

    function automatic void set_config_stats_write_data_occupancy_step( int config_stats_write_data_occupancy_step_param );
        do_set_config_stats_write_data_occupancy_step( config_stats_write_data_occupancy_step_param );
    endfunction

    function automatic void set_config_stats_write_data_occupancy_multiple( int config_stats_write_data_occupancy_multiple_param );
        do_set_config_stats_write_data_occupancy_multiple( config_stats_write_data_occupancy_multiple_param );
    endfunction

    function automatic void set_config_stats_read_bandwidth_step( int config_stats_read_bandwidth_step_param );
        do_set_config_stats_read_bandwidth_step( config_stats_read_bandwidth_step_param );
    endfunction

    function automatic void set_config_stats_read_bandwidth_multiple( int config_stats_read_bandwidth_multiple_param );
        do_set_config_stats_read_bandwidth_multiple( config_stats_read_bandwidth_multiple_param );
    endfunction

    function automatic void set_config_stats_write_bandwidth_step( int config_stats_write_bandwidth_step_param );
        do_set_config_stats_write_bandwidth_step( config_stats_write_bandwidth_step_param );
    endfunction

    function automatic void set_config_stats_write_bandwidth_multiple( int config_stats_write_bandwidth_multiple_param );
        do_set_config_stats_write_bandwidth_multiple( config_stats_write_bandwidth_multiple_param );
    endfunction

    function automatic void set_config_stats_read_latency_step( int config_stats_read_latency_step_param );
        do_set_config_stats_read_latency_step( config_stats_read_latency_step_param );
    endfunction

    function automatic void set_config_stats_read_latency_multiple( int config_stats_read_latency_multiple_param );
        do_set_config_stats_read_latency_multiple( config_stats_read_latency_multiple_param );
    endfunction

    function automatic void set_config_stats_write_latency_step( int config_stats_write_latency_step_param );
        do_set_config_stats_write_latency_step( config_stats_write_latency_step_param );
    endfunction

    function automatic void set_config_stats_write_latency_multiple( int config_stats_write_latency_multiple_param );
        do_set_config_stats_write_latency_multiple( config_stats_write_latency_multiple_param );
    endfunction

    function automatic void set_config_stats_read_address_waits_step( int config_stats_read_address_waits_step_param );
        do_set_config_stats_read_address_waits_step( config_stats_read_address_waits_step_param );
    endfunction

    function automatic void set_config_stats_read_address_waits_multiple( int config_stats_read_address_waits_multiple_param );
        do_set_config_stats_read_address_waits_multiple( config_stats_read_address_waits_multiple_param );
    endfunction

    function automatic void set_config_stats_read_data_waits_step( int config_stats_read_data_waits_step_param );
        do_set_config_stats_read_data_waits_step( config_stats_read_data_waits_step_param );
    endfunction

    function automatic void set_config_stats_read_data_waits_multiple( int config_stats_read_data_waits_multiple_param );
        do_set_config_stats_read_data_waits_multiple( config_stats_read_data_waits_multiple_param );
    endfunction

    function automatic void set_config_stats_write_address_waits_step( int config_stats_write_address_waits_step_param );
        do_set_config_stats_write_address_waits_step( config_stats_write_address_waits_step_param );
    endfunction

    function automatic void set_config_stats_write_address_waits_multiple( int config_stats_write_address_waits_multiple_param );
        do_set_config_stats_write_address_waits_multiple( config_stats_write_address_waits_multiple_param );
    endfunction

    function automatic void set_config_stats_write_data_waits_step( int config_stats_write_data_waits_step_param );
        do_set_config_stats_write_data_waits_step( config_stats_write_data_waits_step_param );
    endfunction

    function automatic void set_config_stats_write_data_waits_multiple( int config_stats_write_data_waits_multiple_param );
        do_set_config_stats_write_data_waits_multiple( config_stats_write_data_waits_multiple_param );
    endfunction

    function automatic void set_config_stats_write_response_waits_step( int config_stats_write_response_waits_step_param );
        do_set_config_stats_write_response_waits_step( config_stats_write_response_waits_step_param );
    endfunction

    function automatic void set_config_stats_write_response_waits_multiple( int config_stats_write_response_waits_multiple_param );
        do_set_config_stats_write_response_waits_multiple( config_stats_write_response_waits_multiple_param );
    endfunction


    //------------------------------------------------------------------------------
    // Functions to get global variables with read access
    //------------------------------------------------------------------------------
    function automatic axi4_interface_type_e get_config_interface_type(  );
        return do_get_config_interface_type(  );
    endfunction

    function automatic bit get_config_clk_init_value(  );
        return do_get_config_clk_init_value(  );
    endfunction

    function automatic longint unsigned get_config_clk_phase_shift(  );
        return do_get_config_clk_phase_shift(  );
    endfunction

    function automatic longint unsigned get_config_clk_1st_time(  );
        return do_get_config_clk_1st_time(  );
    endfunction

    function automatic longint unsigned get_config_clk_2nd_time(  );
        return do_get_config_clk_2nd_time(  );
    endfunction

    function automatic longint unsigned get_config_setup_time(  );
        return do_get_config_setup_time(  );
    endfunction

    function automatic longint unsigned get_config_hold_time(  );
        return do_get_config_hold_time(  );
    endfunction

    function automatic int unsigned get_config_burst_timeout_factor(  );
        return do_get_config_burst_timeout_factor(  );
    endfunction

    function automatic int unsigned get_config_max_transaction_time_factor(  );
        return do_get_config_max_transaction_time_factor(  );
    endfunction

    function automatic int get_config_write_ctrl_first_ratio(  );
        return do_get_config_write_ctrl_first_ratio(  );
    endfunction

    function automatic int get_config_write_data_first_ratio(  );
        return do_get_config_write_data_first_ratio(  );
    endfunction

    function automatic int get_config_reset_low_clocks(  );
        return do_get_config_reset_low_clocks(  );
    endfunction

    function automatic int get_config_reset_hold_time(  );
        return do_get_config_reset_hold_time(  );
    endfunction

    function automatic bit get_config_enable_rlast(  );
        return do_get_config_enable_rlast(  );
    endfunction

    function automatic bit get_config_enable_slave_exclusive(  );
        return do_get_config_enable_slave_exclusive(  );
    endfunction

    function automatic bit get_config_enable_burst_reserved_value(  );
        return do_get_config_enable_burst_reserved_value(  );
    endfunction

    function automatic bit [15:0]  get_config_enable_cache_value(  );
        return do_get_config_enable_cache_value(  );
    endfunction

    function automatic bit   get_config_enable_cache_value_index1( int _this_dot_1 );
        return do_get_config_enable_cache_value_index1( _this_dot_1 );
    endfunction

    function automatic axi4_error_e get_internal_dummy_variable(  );
        return do_get_internal_dummy_variable(  );
    endfunction

    function automatic bit get_config_axi4lite_interface(  );
        return do_get_config_axi4lite_interface(  );
    endfunction

    function automatic bit [((AXI4_ID_WIDTH) - 1):0]   get_config_axi4lite_tr_id(  );
        return do_get_config_axi4lite_tr_id(  );
    endfunction

    function automatic bit   get_config_axi4lite_tr_id_index1( int _this_dot_1 );
        return do_get_config_axi4lite_tr_id_index1( _this_dot_1 );
    endfunction

    function automatic bit get_config_enable_all_assertions(  );
        return do_get_config_enable_all_assertions(  );
    endfunction

    function automatic bit [255:0]  get_config_enable_assertion(  );
        return do_get_config_enable_assertion(  );
    endfunction

    function automatic bit   get_config_enable_assertion_index1( int _this_dot_1 );
        return do_get_config_enable_assertion_index1( _this_dot_1 );
    endfunction

    function automatic bit [255:0]  get_config_enable_error(  );
        return do_get_config_enable_error(  );
    endfunction

    function automatic bit   get_config_enable_error_index1( int _this_dot_1 );
        return do_get_config_enable_error_index1( _this_dot_1 );
    endfunction

    function automatic int unsigned get_config_max_latency_AWVALID_assertion_to_AWREADY(  );
        return do_get_config_max_latency_AWVALID_assertion_to_AWREADY(  );
    endfunction

    function automatic int unsigned get_config_max_latency_ARVALID_assertion_to_ARREADY(  );
        return do_get_config_max_latency_ARVALID_assertion_to_ARREADY(  );
    endfunction

    function automatic int unsigned get_config_max_latency_RVALID_assertion_to_RREADY(  );
        return do_get_config_max_latency_RVALID_assertion_to_RREADY(  );
    endfunction

    function automatic int unsigned get_config_max_latency_BVALID_assertion_to_BREADY(  );
        return do_get_config_max_latency_BVALID_assertion_to_BREADY(  );
    endfunction

    function automatic int unsigned get_config_max_latency_WVALID_assertion_to_WREADY(  );
        return do_get_config_max_latency_WVALID_assertion_to_WREADY(  );
    endfunction

    function automatic bit get_config_enable_qos(  );
        return do_get_config_enable_qos(  );
    endfunction

    function automatic bit get_config_enable_region_support(  );
        return do_get_config_enable_region_support(  );
    endfunction

    function automatic int get_config_slave_regions(  );
        return do_get_config_slave_regions(  );
    endfunction

    function automatic bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]   get_config_region(  );
        return do_get_config_region(  );
    endfunction

    function automatic bit [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]   get_config_region_index1( int _this_dot_1 );
        return do_get_config_region_index1( _this_dot_1 );
    endfunction

    function automatic bit   get_config_region_index2( int _this_dot_1, int _this_dot_2 );
        return do_get_config_region_index2( _this_dot_1, _this_dot_2 );
    endfunction

    function automatic bit get_region_error_state(  );
        return do_get_region_error_state(  );
    endfunction

    function automatic _region_map_lb_t get_region_map_lb(  );
        return do_get_region_map_lb(  );
    endfunction

    function automatic longint unsigned get_region_map_lb_index1( int _this_dot_1 );
        return do_get_region_map_lb_index1( _this_dot_1 );
    endfunction

    function automatic _region_map_ub_t get_region_map_ub(  );
        return do_get_region_map_ub(  );
    endfunction

    function automatic longint unsigned get_region_map_ub_index1( int _this_dot_1 );
        return do_get_region_map_ub_index1( _this_dot_1 );
    endfunction

    function automatic _region_map_region_t get_region_map_region(  );
        return do_get_region_map_region(  );
    endfunction

    function automatic byte unsigned get_region_map_region_index1( int _this_dot_1 );
        return do_get_region_map_region_index1( _this_dot_1 );
    endfunction

    function automatic _cacheable_t get_cacheable(  );
        return do_get_cacheable(  );
    endfunction

    function automatic byte unsigned get_cacheable_index1( int _this_dot_1 );
        return do_get_cacheable_index1( _this_dot_1 );
    endfunction

    function automatic int unsigned get_config_read_data_reordering_depth(  );
        return do_get_config_read_data_reordering_depth(  );
    endfunction

    function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_start_addr(  );
        return do_get_config_slave_start_addr(  );
    endfunction

    function automatic bit   get_config_slave_start_addr_index1( int _this_dot_1 );
        return do_get_config_slave_start_addr_index1( _this_dot_1 );
    endfunction

    function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_end_addr(  );
        return do_get_config_slave_end_addr(  );
    endfunction

    function automatic bit   get_config_slave_end_addr_index1( int _this_dot_1 );
        return do_get_config_slave_end_addr_index1( _this_dot_1 );
    endfunction

    function automatic int get_config_slave_enabled_non_contiguous_address_spaces(  );
        return do_get_config_slave_enabled_non_contiguous_address_spaces(  );
    endfunction

    function automatic bit get_config_slave_possess_multiple_non_contiguous_address_spaces(  );
        return do_get_config_slave_possess_multiple_non_contiguous_address_spaces(  );
    endfunction

    function automatic bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_multiple_non_contiguous_start_address_range(  );
        return do_get_config_slave_multiple_non_contiguous_start_address_range(  );
    endfunction

    function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_multiple_non_contiguous_start_address_range_index1( int _this_dot_1 );
        return do_get_config_slave_multiple_non_contiguous_start_address_range_index1( _this_dot_1 );
    endfunction

    function automatic bit   get_config_slave_multiple_non_contiguous_start_address_range_index2( int _this_dot_1, int _this_dot_2 );
        return do_get_config_slave_multiple_non_contiguous_start_address_range_index2( _this_dot_1, _this_dot_2 );
    endfunction

    function automatic bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_multiple_non_contiguous_end_address_range(  );
        return do_get_config_slave_multiple_non_contiguous_end_address_range(  );
    endfunction

    function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_multiple_non_contiguous_end_address_range_index1( int _this_dot_1 );
        return do_get_config_slave_multiple_non_contiguous_end_address_range_index1( _this_dot_1 );
    endfunction

    function automatic bit   get_config_slave_multiple_non_contiguous_end_address_range_index2( int _this_dot_1, int _this_dot_2 );
        return do_get_config_slave_multiple_non_contiguous_end_address_range_index2( _this_dot_1, _this_dot_2 );
    endfunction

    function automatic bit get_config_protect_ready(  );
        return do_get_config_protect_ready(  );
    endfunction

    function automatic bit get_master_end_tlm_status(  );
        return do_get_master_end_tlm_status(  );
    endfunction

    function automatic bit get_master_end_wlm_status(  );
        return do_get_master_end_wlm_status(  );
    endfunction

    function automatic bit get_slave_end_tlm_status(  );
        return do_get_slave_end_tlm_status(  );
    endfunction

    function automatic bit get_slave_end_wlm_status(  );
        return do_get_slave_end_wlm_status(  );
    endfunction

    function automatic bit get_clock_source_end_tlm_status(  );
        return do_get_clock_source_end_tlm_status(  );
    endfunction

    function automatic bit get_clock_source_end_wlm_status(  );
        return do_get_clock_source_end_wlm_status(  );
    endfunction

    function automatic bit get_reset_source_end_tlm_status(  );
        return do_get_reset_source_end_tlm_status(  );
    endfunction

    function automatic bit get_reset_source_end_wlm_status(  );
        return do_get_reset_source_end_wlm_status(  );
    endfunction

    function automatic int get_config_max_outstanding_wr(  );
        return do_get_config_max_outstanding_wr(  );
    endfunction

    function automatic int get_config_max_outstanding_rd(  );
        return do_get_config_max_outstanding_rd(  );
    endfunction

    function automatic int get_config_num_outstanding_wr_phase(  );
        return do_get_config_num_outstanding_wr_phase(  );
    endfunction

    function automatic int get_config_num_outstanding_rd_phase(  );
        return do_get_config_num_outstanding_rd_phase(  );
    endfunction

    function automatic bit get_config_enable_warnings(  );
        return do_get_config_enable_warnings(  );
    endfunction

    function automatic bit get_config_enable_errors(  );
        return do_get_config_enable_errors(  );
    endfunction

    function automatic bit get_config_enable_exclusive_checks(  );
        return do_get_config_enable_exclusive_checks(  );
    endfunction

    function automatic bit get_config_warn_on_slave_errors(  );
        return do_get_config_warn_on_slave_errors(  );
    endfunction

    function automatic bit get_config_error_on_deleted_valid_cycles(  );
        return do_get_config_error_on_deleted_valid_cycles(  );
    endfunction

    function automatic bit get_config_stats_enable(  );
        return do_get_config_stats_enable(  );
    endfunction

    function automatic bit get_config_stats_enable_read_occupancy(  );
        return do_get_config_stats_enable_read_occupancy(  );
    endfunction

    function automatic bit get_config_stats_enable_write_occupancy(  );
        return do_get_config_stats_enable_write_occupancy(  );
    endfunction

    function automatic bit get_config_stats_enable_read_data_occupancy(  );
        return do_get_config_stats_enable_read_data_occupancy(  );
    endfunction

    function automatic bit get_config_stats_enable_write_data_occupancy(  );
        return do_get_config_stats_enable_write_data_occupancy(  );
    endfunction

    function automatic bit get_config_stats_enable_read_latency(  );
        return do_get_config_stats_enable_read_latency(  );
    endfunction

    function automatic bit get_config_stats_enable_write_latency(  );
        return do_get_config_stats_enable_write_latency(  );
    endfunction

    function automatic bit get_config_stats_enable_read_address_waits(  );
        return do_get_config_stats_enable_read_address_waits(  );
    endfunction

    function automatic bit get_config_stats_enable_read_data_waits(  );
        return do_get_config_stats_enable_read_data_waits(  );
    endfunction

    function automatic bit get_config_stats_enable_write_address_waits(  );
        return do_get_config_stats_enable_write_address_waits(  );
    endfunction

    function automatic bit get_config_stats_enable_write_data_waits(  );
        return do_get_config_stats_enable_write_data_waits(  );
    endfunction

    function automatic bit get_config_stats_enable_write_response_waits(  );
        return do_get_config_stats_enable_write_response_waits(  );
    endfunction

    function automatic bit get_config_stats_enable_read_bandwidth(  );
        return do_get_config_stats_enable_read_bandwidth(  );
    endfunction

    function automatic bit get_config_stats_enable_write_bandwidth(  );
        return do_get_config_stats_enable_write_bandwidth(  );
    endfunction

    function automatic int get_stats_rw_transaction_last_duration(  );
        return do_get_stats_rw_transaction_last_duration(  );
    endfunction

    function automatic int get_config_stats_read_occupancy_step(  );
        return do_get_config_stats_read_occupancy_step(  );
    endfunction

    function automatic int get_config_stats_read_occupancy_multiple(  );
        return do_get_config_stats_read_occupancy_multiple(  );
    endfunction

    function automatic bit get_stats_read_active(  );
        return do_get_stats_read_active(  );
    endfunction

    function automatic int get_stats_read_occupancy_sw(  );
        return do_get_stats_read_occupancy_sw(  );
    endfunction

    function automatic int get_stats_read_idle_sw(  );
        return do_get_stats_read_idle_sw(  );
    endfunction

    function automatic int get_stats_read_occupancy_min(  );
        return do_get_stats_read_occupancy_min(  );
    endfunction

    function automatic int get_stats_read_idle_min(  );
        return do_get_stats_read_idle_min(  );
    endfunction

    function automatic int get_stats_read_occupancy_max(  );
        return do_get_stats_read_occupancy_max(  );
    endfunction

    function automatic int get_stats_read_idle_max(  );
        return do_get_stats_read_idle_max(  );
    endfunction

    function automatic int get_stats_read_occupancy_mean(  );
        return do_get_stats_read_occupancy_mean(  );
    endfunction

    function automatic int get_stats_read_idle_mean(  );
        return do_get_stats_read_idle_mean(  );
    endfunction

    function automatic int get_stats_read_last_duration(  );
        return do_get_stats_read_last_duration(  );
    endfunction

    function automatic int get_config_stats_write_occupancy_step(  );
        return do_get_config_stats_write_occupancy_step(  );
    endfunction

    function automatic int get_config_stats_write_occupancy_multiple(  );
        return do_get_config_stats_write_occupancy_multiple(  );
    endfunction

    function automatic bit get_stats_write_active(  );
        return do_get_stats_write_active(  );
    endfunction

    function automatic int get_stats_write_occupancy_sw(  );
        return do_get_stats_write_occupancy_sw(  );
    endfunction

    function automatic int get_stats_write_idle_sw(  );
        return do_get_stats_write_idle_sw(  );
    endfunction

    function automatic int get_stats_write_occupancy_min(  );
        return do_get_stats_write_occupancy_min(  );
    endfunction

    function automatic int get_stats_write_idle_min(  );
        return do_get_stats_write_idle_min(  );
    endfunction

    function automatic int get_stats_write_occupancy_max(  );
        return do_get_stats_write_occupancy_max(  );
    endfunction

    function automatic int get_stats_write_idle_max(  );
        return do_get_stats_write_idle_max(  );
    endfunction

    function automatic int get_stats_write_occupancy_mean(  );
        return do_get_stats_write_occupancy_mean(  );
    endfunction

    function automatic int get_stats_write_idle_mean(  );
        return do_get_stats_write_idle_mean(  );
    endfunction

    function automatic int get_stats_write_last_duration(  );
        return do_get_stats_write_last_duration(  );
    endfunction

    function automatic int get_config_stats_read_data_occupancy_step(  );
        return do_get_config_stats_read_data_occupancy_step(  );
    endfunction

    function automatic int get_config_stats_read_data_occupancy_multiple(  );
        return do_get_config_stats_read_data_occupancy_multiple(  );
    endfunction

    function automatic int get_stats_read_data_occupancy_sw(  );
        return do_get_stats_read_data_occupancy_sw(  );
    endfunction

    function automatic int get_stats_read_data_idle_sw(  );
        return do_get_stats_read_data_idle_sw(  );
    endfunction

    function automatic int get_stats_read_data_occupancy_min(  );
        return do_get_stats_read_data_occupancy_min(  );
    endfunction

    function automatic int get_stats_read_data_idle_min(  );
        return do_get_stats_read_data_idle_min(  );
    endfunction

    function automatic int get_stats_read_data_occupancy_max(  );
        return do_get_stats_read_data_occupancy_max(  );
    endfunction

    function automatic int get_stats_read_data_idle_max(  );
        return do_get_stats_read_data_idle_max(  );
    endfunction

    function automatic int get_stats_read_data_occupancy_mean(  );
        return do_get_stats_read_data_occupancy_mean(  );
    endfunction

    function automatic int get_stats_read_data_idle_mean(  );
        return do_get_stats_read_data_idle_mean(  );
    endfunction

    function automatic int get_config_stats_write_data_occupancy_step(  );
        return do_get_config_stats_write_data_occupancy_step(  );
    endfunction

    function automatic int get_config_stats_write_data_occupancy_multiple(  );
        return do_get_config_stats_write_data_occupancy_multiple(  );
    endfunction

    function automatic int get_stats_write_data_occupancy_sw(  );
        return do_get_stats_write_data_occupancy_sw(  );
    endfunction

    function automatic int get_stats_write_data_idle_sw(  );
        return do_get_stats_write_data_idle_sw(  );
    endfunction

    function automatic int get_stats_write_data_occupancy_min(  );
        return do_get_stats_write_data_occupancy_min(  );
    endfunction

    function automatic int get_stats_write_data_idle_min(  );
        return do_get_stats_write_data_idle_min(  );
    endfunction

    function automatic int get_stats_write_data_occupancy_max(  );
        return do_get_stats_write_data_occupancy_max(  );
    endfunction

    function automatic int get_stats_write_data_idle_max(  );
        return do_get_stats_write_data_idle_max(  );
    endfunction

    function automatic int get_stats_write_data_occupancy_mean(  );
        return do_get_stats_write_data_occupancy_mean(  );
    endfunction

    function automatic int get_stats_write_data_idle_mean(  );
        return do_get_stats_write_data_idle_mean(  );
    endfunction

    function automatic int get_config_stats_read_bandwidth_step(  );
        return do_get_config_stats_read_bandwidth_step(  );
    endfunction

    function automatic int get_config_stats_read_bandwidth_multiple(  );
        return do_get_config_stats_read_bandwidth_multiple(  );
    endfunction

    function automatic int get_stats_read_bandwidth_sw(  );
        return do_get_stats_read_bandwidth_sw(  );
    endfunction

    function automatic int get_stats_read_bandwidth_min(  );
        return do_get_stats_read_bandwidth_min(  );
    endfunction

    function automatic int get_stats_read_bandwidth_max(  );
        return do_get_stats_read_bandwidth_max(  );
    endfunction

    function automatic int get_stats_read_bandwidth_mean(  );
        return do_get_stats_read_bandwidth_mean(  );
    endfunction

    function automatic int get_config_stats_write_bandwidth_step(  );
        return do_get_config_stats_write_bandwidth_step(  );
    endfunction

    function automatic int get_config_stats_write_bandwidth_multiple(  );
        return do_get_config_stats_write_bandwidth_multiple(  );
    endfunction

    function automatic int get_stats_write_bandwidth_sw(  );
        return do_get_stats_write_bandwidth_sw(  );
    endfunction

    function automatic int get_stats_write_bandwidth_min(  );
        return do_get_stats_write_bandwidth_min(  );
    endfunction

    function automatic int get_stats_write_bandwidth_max(  );
        return do_get_stats_write_bandwidth_max(  );
    endfunction

    function automatic int get_stats_write_bandwidth_mean(  );
        return do_get_stats_write_bandwidth_mean(  );
    endfunction

    function automatic int get_config_stats_read_latency_step(  );
        return do_get_config_stats_read_latency_step(  );
    endfunction

    function automatic int get_config_stats_read_latency_multiple(  );
        return do_get_config_stats_read_latency_multiple(  );
    endfunction

    function automatic int get_stats_read_address_data_latency_inst(  );
        return do_get_stats_read_address_data_latency_inst(  );
    endfunction

    function automatic int get_stats_read_address_data_latency_sw(  );
        return do_get_stats_read_address_data_latency_sw(  );
    endfunction

    function automatic int get_stats_read_address_data_latency_min(  );
        return do_get_stats_read_address_data_latency_min(  );
    endfunction

    function automatic int get_stats_read_address_data_latency_max(  );
        return do_get_stats_read_address_data_latency_max(  );
    endfunction

    function automatic int get_stats_read_address_data_latency_mean(  );
        return do_get_stats_read_address_data_latency_mean(  );
    endfunction

    function automatic int get_stats_read_address_address_latency_inst(  );
        return do_get_stats_read_address_address_latency_inst(  );
    endfunction

    function automatic int get_stats_read_address_address_latency_sw(  );
        return do_get_stats_read_address_address_latency_sw(  );
    endfunction

    function automatic int get_stats_read_address_address_latency_min(  );
        return do_get_stats_read_address_address_latency_min(  );
    endfunction

    function automatic int get_stats_read_address_address_latency_max(  );
        return do_get_stats_read_address_address_latency_max(  );
    endfunction

    function automatic int get_stats_read_address_address_latency_mean(  );
        return do_get_stats_read_address_address_latency_mean(  );
    endfunction

    function automatic int get_config_stats_write_latency_step(  );
        return do_get_config_stats_write_latency_step(  );
    endfunction

    function automatic int get_config_stats_write_latency_multiple(  );
        return do_get_config_stats_write_latency_multiple(  );
    endfunction

    function automatic int get_stats_write_address_response_latency_inst(  );
        return do_get_stats_write_address_response_latency_inst(  );
    endfunction

    function automatic int get_stats_write_address_response_latency_sw(  );
        return do_get_stats_write_address_response_latency_sw(  );
    endfunction

    function automatic int get_stats_write_address_response_latency_min(  );
        return do_get_stats_write_address_response_latency_min(  );
    endfunction

    function automatic int get_stats_write_address_response_latency_max(  );
        return do_get_stats_write_address_response_latency_max(  );
    endfunction

    function automatic int get_stats_write_address_response_latency_mean(  );
        return do_get_stats_write_address_response_latency_mean(  );
    endfunction

    function automatic int get_stats_write_address_address_latency_inst(  );
        return do_get_stats_write_address_address_latency_inst(  );
    endfunction

    function automatic int get_stats_write_address_address_latency_sw(  );
        return do_get_stats_write_address_address_latency_sw(  );
    endfunction

    function automatic int get_stats_write_address_address_latency_min(  );
        return do_get_stats_write_address_address_latency_min(  );
    endfunction

    function automatic int get_stats_write_address_address_latency_max(  );
        return do_get_stats_write_address_address_latency_max(  );
    endfunction

    function automatic int get_stats_write_address_address_latency_mean(  );
        return do_get_stats_write_address_address_latency_mean(  );
    endfunction

    function automatic int get_config_stats_read_address_waits_step(  );
        return do_get_config_stats_read_address_waits_step(  );
    endfunction

    function automatic int get_config_stats_read_address_waits_multiple(  );
        return do_get_config_stats_read_address_waits_multiple(  );
    endfunction

    function automatic int get_stats_read_address_waits_inst(  );
        return do_get_stats_read_address_waits_inst(  );
    endfunction

    function automatic int get_stats_read_address_waits_sw(  );
        return do_get_stats_read_address_waits_sw(  );
    endfunction

    function automatic int get_stats_read_address_waits_min(  );
        return do_get_stats_read_address_waits_min(  );
    endfunction

    function automatic int get_stats_read_address_waits_max(  );
        return do_get_stats_read_address_waits_max(  );
    endfunction

    function automatic int get_stats_read_address_waits_mean(  );
        return do_get_stats_read_address_waits_mean(  );
    endfunction

    function automatic int get_config_stats_read_data_waits_step(  );
        return do_get_config_stats_read_data_waits_step(  );
    endfunction

    function automatic int get_config_stats_read_data_waits_multiple(  );
        return do_get_config_stats_read_data_waits_multiple(  );
    endfunction

    function automatic int get_stats_read_data_waits_inst(  );
        return do_get_stats_read_data_waits_inst(  );
    endfunction

    function automatic int get_stats_read_data_waits_sw(  );
        return do_get_stats_read_data_waits_sw(  );
    endfunction

    function automatic int get_stats_read_data_waits_min(  );
        return do_get_stats_read_data_waits_min(  );
    endfunction

    function automatic int get_stats_read_data_waits_max(  );
        return do_get_stats_read_data_waits_max(  );
    endfunction

    function automatic int get_stats_read_data_waits_mean(  );
        return do_get_stats_read_data_waits_mean(  );
    endfunction

    function automatic int get_config_stats_write_address_waits_step(  );
        return do_get_config_stats_write_address_waits_step(  );
    endfunction

    function automatic int get_config_stats_write_address_waits_multiple(  );
        return do_get_config_stats_write_address_waits_multiple(  );
    endfunction

    function automatic int get_stats_write_address_waits_inst(  );
        return do_get_stats_write_address_waits_inst(  );
    endfunction

    function automatic int get_stats_write_address_waits_sw(  );
        return do_get_stats_write_address_waits_sw(  );
    endfunction

    function automatic int get_stats_write_address_waits_min(  );
        return do_get_stats_write_address_waits_min(  );
    endfunction

    function automatic int get_stats_write_address_waits_max(  );
        return do_get_stats_write_address_waits_max(  );
    endfunction

    function automatic int get_stats_write_address_waits_mean(  );
        return do_get_stats_write_address_waits_mean(  );
    endfunction

    function automatic int get_config_stats_write_data_waits_step(  );
        return do_get_config_stats_write_data_waits_step(  );
    endfunction

    function automatic int get_config_stats_write_data_waits_multiple(  );
        return do_get_config_stats_write_data_waits_multiple(  );
    endfunction

    function automatic int get_stats_write_data_waits_inst(  );
        return do_get_stats_write_data_waits_inst(  );
    endfunction

    function automatic int get_stats_write_data_waits_sw(  );
        return do_get_stats_write_data_waits_sw(  );
    endfunction

    function automatic int get_stats_write_data_waits_min(  );
        return do_get_stats_write_data_waits_min(  );
    endfunction

    function automatic int get_stats_write_data_waits_max(  );
        return do_get_stats_write_data_waits_max(  );
    endfunction

    function automatic int get_stats_write_data_waits_mean(  );
        return do_get_stats_write_data_waits_mean(  );
    endfunction

    function automatic int get_config_stats_write_response_waits_step(  );
        return do_get_config_stats_write_response_waits_step(  );
    endfunction

    function automatic int get_config_stats_write_response_waits_multiple(  );
        return do_get_config_stats_write_response_waits_multiple(  );
    endfunction

    function automatic int get_stats_write_response_waits_inst(  );
        return do_get_stats_write_response_waits_inst(  );
    endfunction

    function automatic int get_stats_write_response_waits_sw(  );
        return do_get_stats_write_response_waits_sw(  );
    endfunction

    function automatic int get_stats_write_response_waits_min(  );
        return do_get_stats_write_response_waits_min(  );
    endfunction

    function automatic int get_stats_write_response_waits_max(  );
        return do_get_stats_write_response_waits_max(  );
    endfunction

    function automatic int get_stats_write_response_waits_mean(  );
        return do_get_stats_write_response_waits_mean(  );
    endfunction

    function automatic int get_reordering_depth_of_last_read_transaction(  );
        return do_get_reordering_depth_of_last_read_transaction(  );
    endfunction


    //------------------------------------------------------------------------------
    // Function to get last database handle
    //------------------------------------------------------------------------------

    function longint get_last_handle();
        return do_get_last_handle();
    endfunction

    //------------------------------------------------------------------------------
    // Function to get last start time
    //------------------------------------------------------------------------------

    function longint get_last_start_time();
        return do_get_last_start_time();
    endfunction

    //------------------------------------------------------------------------------
    // Function to get last end time
    //------------------------------------------------------------------------------

    function longint get_last_end_time();
        return do_get_last_end_time();
    endfunction


    //------------------------------------------------------------------------------
    // Functions to set/get generic interface configuration
    //------------------------------------------------------------------------------

    function void set_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0,
        input int arg10 = 0
    );
        do_set_interface( what, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10 );
    endfunction

    function int get_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0
    );
        return do_get_interface( what, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 );
    endfunction

    //------------------------------------------------------------------------------
    // Functions to get the hierarchic name of this interface
    //------------------------------------------------------------------------------
    function string get_full_name();
        return do_get_full_name();
    endfunction

    //------------------------------------------------------------------------------
    // Functions to set/get the abstraction levels of interface ends
    //------------------------------------------------------------------------------
    function void axi4_set_master_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        do_axi4_set_master_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi4_get_master_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        do_axi4_get_master_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi4_set_slave_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        do_axi4_set_slave_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi4_get_slave_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        do_axi4_get_slave_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi4_set_clock_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        do_axi4_set_clock_source_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi4_get_clock_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        do_axi4_get_clock_source_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi4_set_reset_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        do_axi4_set_reset_source_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi4_get_reset_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        do_axi4_get_reset_source_abstraction_level( wire_level, TLM_level );
    endfunction


    //------------------------------------------------------------------------------
    // Interface end access functions
    //------------------------------------------------------------------------------

    function longint get_axi4_master_end();
        return do_get_axi4_master_end();
    endfunction

    function longint get_axi4_slave_end();
        return do_get_axi4_slave_end();
    endfunction

    function longint get_axi4_clock_source_end();
        return do_get_axi4_clock_source_end();
    endfunction

    function longint get_axi4_reset_source_end();
        return do_get_axi4_reset_source_end();
    endfunction

    function longint get_axi4__monitor_end();
        return do_get_axi4__monitor_end();
    endfunction


    //------------------------------------------------------------------------------
    // Transaction interface
    //------------------------------------------------------------------------------
    task automatic dvc_activate_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref axi4_rw_e read_or_write,
        ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi4_prot_e prot,
        ref bit [3:0] region,
        ref axi4_size_e size,
        ref axi4_burst_e burst,
        ref axi4_lock_e lock,
        ref axi4_cache_e cache,
        ref bit [3:0] qos,
        ref bit [((AXI4_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] burst_length,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        ref int address_valid_delay,
        ref int data_valid_delay[],
        ref int write_response_valid_delay,
        ref int address_ready_delay,
        ref int data_ready_delay[],
        ref int write_response_ready_delay,
        ref bit write_data_with_address,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0
    );
        do_dvc_activate_rw_transaction(_comms_semantic, _as_end,read_or_write,addr,prot,region,size,burst,lock,cache,qos,id,burst_length,addr_user_data,data_words,write_strobes,wdata_user_data,resp,resp_user_data,address_valid_delay,data_valid_delay,write_response_valid_delay,address_ready_delay,data_ready_delay,write_response_ready_delay,write_data_with_address,write_address_to_data_delay,write_data_to_address_delay,write_data_beats_delay,_unit_id);
    endtask

    task automatic dvc_get_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi4_rw_e read_or_write,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        output int address_valid_delay,
        ref int data_valid_delay[],
        output int write_response_valid_delay,
        output int address_ready_delay,
        ref int data_ready_delay[],
        output int write_response_ready_delay,
        output bit write_data_with_address,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_rw_transaction(_comms_semantic, _as_end,read_or_write,addr,prot,region,size,burst,lock,cache,qos,id,burst_length,addr_user_data,data_words,write_strobes,wdata_user_data,resp,resp_user_data,address_valid_delay,data_valid_delay,write_response_valid_delay,address_ready_delay,data_ready_delay,write_response_ready_delay,write_data_with_address,write_address_to_data_delay,write_data_to_address_delay,write_data_beats_delay,_unit_id,_using);
    endtask

    task automatic dvc_activate_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi4_prot_e prot,
        ref int rresp_delays[255:0],
        ref bit [3:0] region,
        ref axi4_size_e size,
        ref axi4_burst_e burst,
        ref axi4_lock_e lock,
        ref axi4_cache_e cache,
        ref bit [3:0] qos,
        ref bit [((AXI4_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] burst_length,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_RDATA_WIDTH) - 1):0] data_words [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int address_valid_delay,
        input int _unit_id = 0
    );
        do_dvc_activate_read(_comms_semantic, _as_end,addr,prot,rresp_delays,region,size,burst,lock,cache,qos,id,burst_length,addr_user_data,data_words,resp,resp_user_data,addr_start_time,addr_end_time,data_start_time,data_end_time,address_valid_delay,_unit_id);
    endtask

    task automatic dvc_get_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        ref int rresp_delays[255:0],
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_RDATA_WIDTH) - 1):0] data_words [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output int address_valid_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read(_comms_semantic, _as_end,addr,prot,rresp_delays,region,size,burst,lock,cache,qos,id,burst_length,addr_user_data,data_words,resp,resp_user_data,addr_start_time,addr_end_time,data_start_time,data_end_time,address_valid_delay,_unit_id,_using);
    endtask

    task automatic dvc_activate_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi4_prot_e prot,
        ref int bresp_delay,
        ref bit [3:0] region,
        ref axi4_size_e size,
        ref axi4_burst_e burst,
        ref axi4_lock_e lock,
        ref axi4_cache_e cache,
        ref bit [3:0] qos,
        ref bit [((AXI4_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] burst_length,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        ref axi4_response_e resp,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref longint wr_resp_start_time,
        ref longint wr_resp_end_time,
        ref int address_valid_delay,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0
    );
        do_dvc_activate_write(_comms_semantic, _as_end,addr,prot,bresp_delay,region,size,burst,lock,cache,qos,id,burst_length,addr_user_data,data_words,write_strobes,wdata_user_data,resp,resp_user_data,addr_start_time,addr_end_time,data_start_time,data_end_time,wr_resp_start_time,wr_resp_end_time,address_valid_delay,write_address_to_data_delay,write_data_to_address_delay,write_data_beats_delay,_unit_id);
    endtask

    task automatic dvc_get_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output int bresp_delay,
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        output axi4_response_e resp,
        output bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output longint wr_resp_start_time,
        output longint wr_resp_end_time,
        output int address_valid_delay,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write(_comms_semantic, _as_end,addr,prot,bresp_delay,region,size,burst,lock,cache,qos,id,burst_length,addr_user_data,data_words,write_strobes,wdata_user_data,resp,resp_user_data,addr_start_time,addr_end_time,data_start_time,data_end_time,wr_resp_start_time,wr_resp_end_time,address_valid_delay,write_address_to_data_delay,write_data_to_address_delay,write_data_beats_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int burst_length,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] user_data [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int write_data_beats_delay[],
        input int _unit_id = 0
    );
        do_dvc_put_write_data_burst(_comms_semantic, _as_end,burst_length,data_words,write_strobes,user_data,data_start_time,data_end_time,write_data_beats_delay,_unit_id);
    endtask

    task automatic dvc_get_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output int burst_length,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] user_data [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int write_data_beats_delay[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_data_burst(_comms_semantic, _as_end,burst_length,data_words,write_strobes,user_data,data_start_time,data_end_time,write_data_beats_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input axi4_prot_e prot,
        input bit [3:0] region,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input axi4_cache_e cache,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
        do_dvc_put_read_addr_channel_phase(_comms_semantic, _as_end,addr,prot,region,burst_length,size,burst,lock,cache,qos,id,addr_user,address_valid_delay,address_ready_delay,_unit_id);
    endtask

    task automatic dvc_get_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_addr_channel_phase(_comms_semantic, _as_end,addr,prot,region,burst_length,size,burst,lock,cache,qos,id,addr_user,address_valid_delay,address_ready_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int _unit_id = 0
    );
        do_dvc_put_read_data_burst(_comms_semantic, _as_end,_unit_id);
    endtask

    task automatic dvc_get_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_data_burst(_comms_semantic, _as_end,_unit_id,_using);
    endtask

    task automatic dvc_put_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int data_ready_delay,
        input int _unit_id = 0
    );
        do_dvc_put_read_channel_phase(_comms_semantic, _as_end,data,resp,last,id,user_data,data_ready_delay,_unit_id);
    endtask

    task automatic dvc_get_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_channel_phase(_comms_semantic, _as_end,data,resp,last,id,user_data,data_ready_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input axi4_prot_e prot,
        input bit [3:0] region,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input axi4_cache_e cache,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
        do_dvc_put_write_addr_channel_phase(_comms_semantic, _as_end,addr,prot,region,burst_length,size,burst,lock,cache,qos,id,addr_user,address_valid_delay,address_ready_delay,_unit_id);
    endtask

    task automatic dvc_get_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_addr_channel_phase(_comms_semantic, _as_end,addr,prot,region,burst_length,size,burst,lock,cache,qos,id,addr_user,address_valid_delay,address_ready_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        input bit last,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int data_ready_delay,
        input int _unit_id = 0
    );
        do_dvc_put_write_channel_phase(_comms_semantic, _as_end,data,write_strobes,last,user_data,data_ready_delay,_unit_id);
    endtask

    task automatic dvc_get_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        output bit last,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_channel_phase(_comms_semantic, _as_end,data,write_strobes,last,user_data,data_ready_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi4_response_e resp,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int write_response_ready_delay,
        input int _unit_id = 0
    );
        do_dvc_put_write_resp_channel_phase(_comms_semantic, _as_end,resp,id,user_data,write_response_ready_delay,_unit_id);
    endtask

    task automatic dvc_get_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi4_response_e resp,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int write_response_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_resp_channel_phase(_comms_semantic, _as_end,resp,id,user_data,write_response_ready_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] region,
        input axi4_cache_e cache,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input axi4_prot_e prot,
        input int _unit_id = 0
    );
        do_dvc_put_read_addr_channel_cycle(_comms_semantic, _as_end,addr,region,cache,burst_length,size,burst,lock,qos,id,user_data,prot,_unit_id);
    endtask

    task automatic dvc_get_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] region,
        output axi4_cache_e cache,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output axi4_prot_e prot,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_addr_channel_cycle(_comms_semantic, _as_end,addr,region,cache,burst_length,size,burst,lock,qos,id,user_data,prot,_unit_id,_using);
    endtask

    task automatic dvc_put_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        do_dvc_put_read_addr_channel_ready(_comms_semantic, _as_end,ready,_unit_id);
    endtask

    task automatic dvc_get_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_addr_channel_ready(_comms_semantic, _as_end,ready,_unit_id,_using);
    endtask

    task automatic dvc_put_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
        do_dvc_put_read_channel_cycle(_comms_semantic, _as_end,data,resp,last,id,user_data,_unit_id);
    endtask

    task automatic dvc_get_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_channel_cycle(_comms_semantic, _as_end,data,resp,last,id,user_data,_unit_id,_using);
    endtask

    task automatic dvc_put_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        do_dvc_put_read_channel_ready(_comms_semantic, _as_end,ready,_unit_id);
    endtask

    task automatic dvc_get_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_channel_ready(_comms_semantic, _as_end,ready,_unit_id,_using);
    endtask

    task automatic dvc_put_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] region,
        input axi4_cache_e cache,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input axi4_prot_e prot,
        input int _unit_id = 0
    );
        do_dvc_put_write_addr_channel_cycle(_comms_semantic, _as_end,addr,region,cache,burst_length,size,burst,lock,qos,id,user_data,prot,_unit_id);
    endtask

    task automatic dvc_get_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] region,
        output axi4_cache_e cache,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output axi4_prot_e prot,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_addr_channel_cycle(_comms_semantic, _as_end,addr,region,cache,burst_length,size,burst,lock,qos,id,user_data,prot,_unit_id,_using);
    endtask

    task automatic dvc_put_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        do_dvc_put_write_addr_channel_ready(_comms_semantic, _as_end,ready,_unit_id);
    endtask

    task automatic dvc_get_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_addr_channel_ready(_comms_semantic, _as_end,ready,_unit_id,_using);
    endtask

    task automatic dvc_put_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  strb,
        input bit last,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
        do_dvc_put_write_channel_cycle(_comms_semantic, _as_end,data,strb,last,user_data,_unit_id);
    endtask

    task automatic dvc_get_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  strb,
        output bit last,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_channel_cycle(_comms_semantic, _as_end,data,strb,last,user_data,_unit_id,_using);
    endtask

    task automatic dvc_put_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        do_dvc_put_write_channel_ready(_comms_semantic, _as_end,ready,_unit_id);
    endtask

    task automatic dvc_get_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_channel_ready(_comms_semantic, _as_end,ready,_unit_id,_using);
    endtask

    task automatic dvc_put_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi4_response_e resp,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
        do_dvc_put_write_resp_channel_cycle(_comms_semantic, _as_end,resp,id,user_data,_unit_id);
    endtask

    task automatic dvc_get_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi4_response_e resp,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_resp_channel_cycle(_comms_semantic, _as_end,resp,id,user_data,_unit_id,_using);
    endtask

    task automatic dvc_put_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        do_dvc_put_write_resp_channel_ready(_comms_semantic, _as_end,ready,_unit_id);
    endtask

    task automatic dvc_get_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_resp_channel_ready(_comms_semantic, _as_end,ready,_unit_id,_using);
    endtask

    task automatic dvc_put_unexpected_write_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input axi4_response_e resp,
        input bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        input int _unit_id = 0
    );
        do_dvc_put_unexpected_write_response(_comms_semantic, _as_end,id,resp,resp_user_data,_unit_id);
    endtask

    task automatic dvc_get_unexpected_write_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output axi4_response_e resp,
        output bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_unexpected_write_response(_comms_semantic, _as_end,id,resp,resp_user_data,_unit_id,_using);
    endtask

    task automatic dvc_put_unexpected_read_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
        do_dvc_put_unexpected_read_response(_comms_semantic, _as_end,data,resp,last,id,user_data,_unit_id);
    endtask

    task automatic dvc_get_unexpected_read_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_unexpected_read_response(_comms_semantic, _as_end,data,resp,last,id,user_data,_unit_id,_using);
    endtask

    //------------------------------------------------------------------------------
    // Functions to register reports for the interface and interface-ends.
    //------------------------------------------------------------------------------
    //------------------------------------------------------------------------------
    // Tasks for registering reports
    //------------------------------------------------------------------------------
    function void register_interface_reporter( input questa_mvc_reporter _rep = null );
        register_end_point( _interface_ref, _rep );
    endfunction

    function void register_master_reporter
    (
        input questa_mvc_reporter rep = null
    );
        do_register_master_reporter( rep );
    endfunction

    function void register_slave_reporter
    (
        input questa_mvc_reporter rep = null
    );
        do_register_slave_reporter( rep );
    endfunction

    function void register_clock_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
        do_register_clock_source_reporter( rep );
    endfunction

    function void register_reset_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
        do_register_reset_source_reporter( rep );
    endfunction

endclass

    (* elab_init *) axi4_implementation_class #(AXI4_ADDRESS_WIDTH, AXI4_RDATA_WIDTH, AXI4_WDATA_WIDTH, AXI4_ID_WIDTH, AXI4_USER_WIDTH, AXI4_REGION_MAP_SIZE) this_interface_class = new();

    //------------------------------------------------------------------------------
    //
    // FUNCTION: get_interface_class
    //     Return a handle to the <axi4_interface_class> API for this interface
    //
    //------------------------------------------------------------------------------
    function axi4_interface_class #(AXI4_ADDRESS_WIDTH, AXI4_RDATA_WIDTH, AXI4_WDATA_WIDTH, AXI4_ID_WIDTH, AXI4_USER_WIDTH, AXI4_REGION_MAP_SIZE) get_interface_class();
        return this_interface_class;
    endfunction

endinterface

`endif // INCA
`ifdef VCS
// *****************************************************************************
//
// Copyright 2007-2013 Mentor Graphics Corporation
// All Rights Reserved.
//
// THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION WHICH IS THE PROPERTY OF
// MENTOR GRAPHICS CORPORATION OR ITS LICENSORS AND IS SUBJECT TO LICENSE TERMS.
//
// *****************************************************************************
// SystemVerilog           Version: 20130911_Questa_10.2c
// *****************************************************************************

// Title: axi4
//

import QUESTA_MVC::questa_mvc_reporter;
import QUESTA_MVC::questa_mvc_item_comms_semantic;
import QUESTA_MVC::questa_mvc_edge;
import QUESTA_MVC::QUESTA_MVC_POSEDGE;
import QUESTA_MVC::QUESTA_MVC_NEGEDGE;
import QUESTA_MVC::QUESTA_MVC_ANYEDGE;
import QUESTA_MVC::QUESTA_MVC_0_TO_1_EDGE;
import QUESTA_MVC::QUESTA_MVC_1_TO_0_EDGE;

//------------------------------------------------------------------------------
//
// Interface:- axi4
//
//------------------------------------------------------------------------------
//  This interface contains all the wires and BFM configuration variables.
// 
// For all Configuration variables set/get/wait functions are available in the
// interface.
// 
// For e.g.
// 
// bit config_enable_slave_exclusive:
// 
// >   function void set_config_enable_slave_exclusive( bit arg1 )
// >
// >   function bit get_config_enable_slave_exclusive()
// >
// >   task wait_for_config_enable_slave_exclusive()
// 
// bit [255:0] config_enable_assertion:
// 
// >     task wait_for_config_enable_assertion()
// >     
// >     task wait_for_config_enable_assertion_index1( input int _this_dot_1 )
// >     
// >     function void set_config_enable_assertion( bit [255:0] arg2 )
// >     
// >     function set_config_enable_assertion_index1( int _this_dot_1, bit  arg3 )
// >     
// >     function bit [255:0]  get_config_enable_assertion()
// >     
// >     function bit get_config_enable_assertion_index1( int _this_dot_1 ) 
// >
// 
//------------------------------------------------------------------------------
(* cy_so="libaxi4_IN_SystemVerilog_MTI_full" *)
(* on_lib_load="axi4_IN_SystemVerilog_load" *)
interface mgc_common_axi4
    #(int AXI4_ADDRESS_WIDTH = 64, int AXI4_RDATA_WIDTH = 1024, int AXI4_WDATA_WIDTH = 1024, int AXI4_ID_WIDTH = 18, int AXI4_USER_WIDTH = 8, int AXI4_REGION_MAP_SIZE = 16)
    (input wire iACLK, input wire iARESETn);
    // Constant: AXI4_ADDRESS_WIDTH
    //
    // The width of the AWADDR and ARADDR signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2).
    //

    // Constant: AXI4_RDATA_WIDTH
    //
    // The width of the RDATA signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6).
    //

    // Constant: AXI4_WDATA_WIDTH
    //
    // The width of the WDATA signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.3).
    //

    // Constant: AXI4_ID_WIDTH
    //
    // The width of the AWID, ARID, RID and BID signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2).
    //

    // Constant: AXI4_USER_WIDTH
    //
    // The width of the AWUSER, ARUSER, WUSER, RUSER and BUSER signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.3).
    //

    // Constant: AXI4_REGION_MAP_SIZE
    //
    //  The number of address-decode entries in the region map (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2)
    // 
    // The address-decode function is done by the interconnect, generating a value for <mgc_axi4::AWREGION>/<mgc_axi4::ARREGION> from the transaction address. This parameter defines the size of the entries
    //  in the <mgc_axi4::config_region> region map array, where each entry defines a mapping from address-range to region value. The entry encodes these as a concatenation of lower-address bound, upper-address bound and region value.
    // 


    //------------------------------------------------------------------------------
    //
    // Wires for interface: axi4
    //
    //------------------------------------------------------------------------------

    // Wire: ACLK
    //
    //------------------------------------------------------------------------------
    //  The clock signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.1)
    // 
    //------------------------------------------------------------------------------
    wire ACLK;

    // Wire: ARESETn
    //
    // Note, no reference to X/Z, as they don't appear in emulation 
    //
    wire ARESETn;

    // Wire: AWVALID
    //
    //------------------------------------------------------------------------------
    //  The address-channel valid signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2, A3.2 and A3.3)
    // 
    //------------------------------------------------------------------------------
    wire AWVALID;

    // Wire: AWADDR
    //
    //------------------------------------------------------------------------------
    //  The write address signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_ADDRESS_WIDTH) - 1):0]  AWADDR;

    // Wire: AWPROT
    //
    //------------------------------------------------------------------------------
    //  The write-channel protection type (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [2:0] AWPROT;

    // Wire: AWREGION
    //
    //------------------------------------------------------------------------------
    //  The write-channel region signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [3:0] AWREGION;

    // Wire: AWLEN
    //
    //------------------------------------------------------------------------------
    //  The write-channel burst-length signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [7:0] AWLEN;

    // Wire: AWSIZE
    //
    //------------------------------------------------------------------------------
    //  The write-channel burst size signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [2:0] AWSIZE;

    // Wire: AWBURST
    //
    //------------------------------------------------------------------------------
    //  The write-channel burst type signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2.)
    // 
    //------------------------------------------------------------------------------
    wire [1:0] AWBURST;

    // Wire: AWLOCK
    //
    //------------------------------------------------------------------------------
    //  The write-channel lock type (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire AWLOCK;

    // Wire: AWCACHE
    //
    //------------------------------------------------------------------------------
    //  The write-channel cache type signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [3:0] AWCACHE;

    // Wire: AWQOS
    //
    //------------------------------------------------------------------------------
    //  The write-channel Quality-of-Service signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [3:0] AWQOS;

    // Wire: AWID
    //
    //------------------------------------------------------------------------------
    //  The write-channel master ID signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_ID_WIDTH) - 1):0]  AWID;

    // Wire: AWUSER
    //
    //------------------------------------------------------------------------------
    //  User-defined write-channel signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.3)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_USER_WIDTH) - 1):0]  AWUSER;

    // Wire: AWREADY
    //
    //------------------------------------------------------------------------------
    //  The write-channel handshake ready signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.2 and A3.2)
    // 
    //------------------------------------------------------------------------------
    wire AWREADY;

    // Wire: ARVALID
    //
    //------------------------------------------------------------------------------
    //  The read address channel valid signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5 and A3.2)
    // 
    //------------------------------------------------------------------------------
    wire ARVALID;

    // Wire: ARADDR
    //
    //------------------------------------------------------------------------------
    //  The read address channel address signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_ADDRESS_WIDTH) - 1):0]  ARADDR;

    // Wire: ARPROT
    //
    //------------------------------------------------------------------------------
    //  The read address channel protection type signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [2:0] ARPROT;

    // Wire: ARREGION
    //
    //------------------------------------------------------------------------------
    //  The read address channel region signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [3:0] ARREGION;

    // Wire: ARLEN
    //
    //------------------------------------------------------------------------------
    //  The read address channel burst length signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [7:0] ARLEN;

    // Wire: ARSIZE
    //
    //------------------------------------------------------------------------------
    //  The read address channel burst size signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [2:0] ARSIZE;

    // Wire: ARBURST
    //
    //------------------------------------------------------------------------------
    //  The read address channel burst type signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [1:0] ARBURST;

    // Wire: ARLOCK
    //
    //------------------------------------------------------------------------------
    //  The read address channel lock type signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire ARLOCK;

    // Wire: ARCACHE
    //
    //------------------------------------------------------------------------------
    //  The read address channel cache type signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [3:0] ARCACHE;

    // Wire: ARQOS
    //
    //------------------------------------------------------------------------------
    //  The read address channel Quality-of-Service signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [3:0] ARQOS;

    // Wire: ARID
    //
    //------------------------------------------------------------------------------
    //  The read address channel master ID signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_ID_WIDTH) - 1):0]  ARID;

    // Wire: ARUSER
    //
    //------------------------------------------------------------------------------
    //  User-defined read address channel signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.3)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_USER_WIDTH) - 1):0]  ARUSER;

    // Wire: ARREADY
    //
    //------------------------------------------------------------------------------
    //  The read address channel handshake ready signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.5 and A3.2)
    // 
    //------------------------------------------------------------------------------
    wire ARREADY;

    // Wire: RVALID
    //
    //------------------------------------------------------------------------------
    //  The read data channel handshake valid signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6 and A3.2)
    // 
    //------------------------------------------------------------------------------
    wire RVALID;

    // Wire: RDATA
    //
    //------------------------------------------------------------------------------
    //  The read data channel data signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_RDATA_WIDTH) - 1):0]  RDATA;

    // Wire: RRESP
    //
    //------------------------------------------------------------------------------
    //  The read data channel response signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6)
    // 
    //------------------------------------------------------------------------------
    wire [1:0] RRESP;

    // Wire: RLAST
    //
    //------------------------------------------------------------------------------
    //  The read data channel LAST signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6)
    // 
    //------------------------------------------------------------------------------
    wire RLAST;

    // Wire: RID
    //
    //------------------------------------------------------------------------------
    //  The read data channel master ID signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_ID_WIDTH) - 1):0]  RID;

    // Wire: RUSER
    //
    //------------------------------------------------------------------------------
    //  User-defined read data channel signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.3)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_USER_WIDTH) - 1):0]  RUSER;

    // Wire: RREADY
    //
    //------------------------------------------------------------------------------
    //  The read data channel handshake ready signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.6)
    // 
    //------------------------------------------------------------------------------
    wire RREADY;

    // Wire: WVALID
    //
    //------------------------------------------------------------------------------
    //  The write data channel handshake valid signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.3)
    // 
    //------------------------------------------------------------------------------
    wire WVALID;

    // Wire: WDATA
    //
    //------------------------------------------------------------------------------
    //  The write data channel data signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.3)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_WDATA_WIDTH) - 1):0]  WDATA;

    // Wire: WSTRB
    //
    //------------------------------------------------------------------------------
    //  The write data channel strobe signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.3)
    // 
    //------------------------------------------------------------------------------
    wire [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  WSTRB;

    // Wire: WLAST
    //
    //------------------------------------------------------------------------------
    //  The write data channel LAST signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.3)
    // 
    //------------------------------------------------------------------------------
    wire WLAST;

    // Wire: WUSER
    //
    //------------------------------------------------------------------------------
    //  User-defined write data channel signals (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.3)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_USER_WIDTH) - 1):0]  WUSER;

    // Wire: WREADY
    //
    //------------------------------------------------------------------------------
    //  The write data channel handshake ready signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.3)
    // 
    //------------------------------------------------------------------------------
    wire WREADY;

    // Wire: BVALID
    //
    //------------------------------------------------------------------------------
    //  The write response channel handshake valid signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.4)
    // 
    //------------------------------------------------------------------------------
    wire BVALID;

    // Wire: BRESP
    //
    //------------------------------------------------------------------------------
    //  The write response channel response signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.4)
    // 
    //------------------------------------------------------------------------------
    wire [1:0] BRESP;

    // Wire: BID
    //
    //------------------------------------------------------------------------------
    //  The write response channel ID signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.4)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_ID_WIDTH) - 1):0]  BID;

    // Wire: BUSER
    //
    //------------------------------------------------------------------------------
    //  User-defined write response channel signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.4, A8.3)
    // 
    //------------------------------------------------------------------------------
    wire [((AXI4_USER_WIDTH) - 1):0]  BUSER;

    // Wire: BREADY
    //
    //------------------------------------------------------------------------------
    //  The write response channel handshake ready signal (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.4)
    // 
    //------------------------------------------------------------------------------
    wire BREADY;

    // Propagate global signals onto interface wires
    assign ACLK = iACLK;
    assign ARESETn = iARESETn;

    //------------------------------------------------------------------------------
    // Global Variables - config
    //------------------------------------------------------------------------------

    // Variable:- config_interface_type
    //
    //  A configuration parameter (of type <axi4_interface_type_e>) defining the interface category: read/write, read only or write only (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.2).
    // 
    // The value defaults to <AXI4_READWRITE>.
    // 
    //
    axi4_interface_type_e config_interface_type;

    // Variable:- config_clk_init_value
    //
    //   The initial value of the clock signal (<ACLK>) generated by the <mgc_axi4> Questa Verification IP built-in clock generator (see AMBA AXI and ACE Protocol Specification IHI0022D section A2.1). Defaults to 1'b0.
    // 
    //
    bit config_clk_init_value;

    // Variable:- config_clk_phase_shift
    //
    //  The number of simulator time-steps for which the initial value of the clock signal (<ACLK>) (when generated by the <mgc_axi4> Questa Verification IP built-in clock generator) shall be held.
    // 
    // By default, this is set to 5000, so that for the common case of simulating with 1 pico-second precision, the phase-shift is 5 nano-seconds. Users should use the
    // <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
    // See <Configuration of Time-Units> for background on configuration of time-units.
    // 
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    longint unsigned config_clk_phase_shift;

    // Variable:- config_clk_1st_time
    //
    //  The number of simulator time-steps for the first phase of the repeating clock signal (<ACLK>) generated by the <mgc_axi4> Questa Verification IP built-in clock generator.
    // 
    // By default, this is set to 5000, so that for the common case of simulating with 1 pico-second precision, the phase is 5 nano-seconds. Users should use the
    // <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
    // See <Configuration of Time-Units> for background on configuration of time-units.
    // 
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    longint unsigned config_clk_1st_time;

    // Variable:- config_clk_2nd_time
    //
    //  The number of simulator time-steps for the second phase of the repeating clock signal (<ACLK>) generated by the <mgc_axi4> Questa Verification IP built-in clock generator.
    // 
    // By default, this is set to 5000, so that for the common case of simulating with 1 pico-second precision, the phase is 5 nano-seconds. Users should use the
    // <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
    // See <Configuration of Time-Units> for background on configuration of time-units.
    // 
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    longint unsigned config_clk_2nd_time;

    // Variable:- config_setup_time
    //
    //  The setup-time, in units of simulator time-steps, for all signals. By default this is set to 0. Users should use the
    // <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
    // See <Configuration of Time-Units> for background on configuration of time-units.
    // 
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    longint unsigned config_setup_time;

    // Variable:- config_hold_time
    //
    //  The hold-time, in units of simulator time-steps, for all signals. By default this is set to 0. Users should use the
    // <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
    // See <Configuration of Time-Units> for background on configuration of time-units.
    // 
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    longint unsigned config_hold_time;

    // Variable:- config_burst_timeout_factor
    //
    //  The maximum number of clock-periods between phases.
    // 
    // This causes a timeout when an unreasonable time passes between transaction phases. It defaults to 10000 clock periods.
    // 
    //
    int unsigned config_burst_timeout_factor;

    // Variable:- config_max_transaction_time_factor
    //
    int unsigned config_max_transaction_time_factor;

    // Variable:- config_write_ctrl_first_ratio
    //
    // Data starts at same time as or after control phase.  Response follows data.
    //
    int config_write_ctrl_first_ratio;

    // Variable:- config_write_data_first_ratio
    //
    // control phase starts at same time as or after data phase.  Response follows data.
    //
    int config_write_data_first_ratio;

    // Variable:- config_reset_low_clocks
    //
    //  The number of clock-periods for which reset will be driven low (if the abstraction-level of the reset_source interface end is set to TLM-connected). This defaults to 5 clock-periods.
    // 
    //
    int config_reset_low_clocks;

    // Variable:- config_reset_hold_time
    //
    // The delay, as a number of simulator time-steps, after a rising clock edge before the reset signal (<ARESETn>) generated by the <mgc_axi4> Questa Verification IP built-in reset generator changes to inactive high.
    // By default this has the value 0. Users should use the <questa_mvc_sv_convert_to_precision> function to set this to the preferred time-interval.
    //  See <Configuration of Time-Units> for background on configuration of time-units.
    // 
    //
    // Note - This configuration variable is used in an expression involving time precision; to ensure its value is correct, use <questa_mvc_sv_convert_to_precision>.
    //
    int config_reset_hold_time;

    // Variable:- config_enable_rlast
    //
    //  A configuration parameter controlling whether the optional <RLAST> signal is used, or not.
    // 
    // <RLAST> is an optional input to the master, because the length of a read burst is always known (see AMBA AXI and ACE Protocol Specification IHI0022D section A10.3.5).
    // 
    //
    bit config_enable_rlast;

    // Variable:- config_enable_slave_exclusive
    //
    //  A configuration parameter controlling whether the slave supports exclusive accesses. (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.5)
    // 
    // By default this is set to true so that the slave will support exclusive accesses by responding with <AXI4_EXOKAY>.
    // 
    // The coverage collected by the covergroup <axi4_coverage::axi4_cvg> is affected by this parameter value setting.
    // 
    //
    bit config_enable_slave_exclusive;

    // Variable:- config_enable_burst_reserved_value
    //
    //  A configuration parameter controlling whether the <axi4_burst_e> reserved value <AXI4_RESERVED> is allowed as a legal value for the 'burst' parameter of <axi4_master_write>/<axi4_master_read>.
    // 
    // To enable this value, set the flag to 1(true) by e.g. config.m_bfm.set_config_enable_burst_reserved_value(1'b1). By default this has the value 0 (false).
    // 
    //
    bit config_enable_burst_reserved_value;

    // Variable:- config_enable_cache_value
    //
    //  An array of configuration parameters controlling whether individual reserved values of the <axi4_master_write::cache>/<axi4_master_read::cache> parameter (of type <axi4_cache_e>) are allowed as legal values of the AxCACHE signal.
    // 
    // To enable an individual reserved value, set the flag to 1 (true) by e.g. config.m_bfm.set_config_enable_cache_value_index1( <AXI4_CACHE_RSVD_12>, 1'b1). To enable all reserved values, do config.set_config_enable_cache_value('1); 
    // 
    // See Also:
    // The <axi4_payload_error_sequence::body()> function shows how this feature may be exercised. The following covergroups are used to collect coverage of these parameter values:
    // + <axi4_coverage::coverage_of_cache_rsvd_4_value>
    // + <axi4_coverage::coverage_of_cache_rsvd_5_value>
    // + <axi4_coverage::coverage_of_cache_rsvd_8_value>
    // + <axi4_coverage::coverage_of_cache_rsvd_9_value>
    // + <axi4_coverage::coverage_of_cache_rsvd_12_value>
    // + <axi4_coverage::coverage_of_cache_rsvd_13_value>
    // 
    // <Error Injection in AXI4> gives a fuller description of configurable error-injection.
    // 
    //
    bit [15:0] config_enable_cache_value;

    // Variable:- internal_dummy_variable
    //
    //  A variable required for internal technical reasons. Ignore it (changes to this will have no effect on behavior).
    // 
    //
    axi4_error_e internal_dummy_variable;

    // Variable:- config_axi4lite_interface
    //
    //  If user want to use QVIP BFM on the axi4lite interface, then this
    //  configuration variable should be set to true.
    // 
    //
    bit config_axi4lite_interface;

    // Variable:- config_axi4lite_tr_id
    //
    //  Configuration variable to set ID to a fixed value when QVIP BFM is configured as axi4lite
    // 
    //
    bit [((AXI4_ID_WIDTH) - 1):0]  config_axi4lite_tr_id;

    // Variable:- config_enable_all_assertions
    //
    //  Configuration parameter controlling whether the error messages(Assertions) issued from the QVIP are Enabled or Disabled.  
    //      By default, it is enabled.
    //   
    //
    bit config_enable_all_assertions;

    // Variable:- config_enable_assertion
    //
    //  An array of configuration parameters controlling whether specific error messages(Assertion) can be issued by the QVIP.
    //      By default, all errors are enabled. 
    //      To suppress a particular error, set the corresponding bit to 0 (false).
    //   
    //
    bit [255:0] config_enable_assertion;

    // Variable:- config_enable_error
    //
    //  This configuration variable is deprecated. Please use <config_enable_assertion> variable for this functionality.
    // An array of configuration parameters controlling whether specific error messages (of type <axi4_error_e>) can be issued by the Questa Verification IP. 
    // By default, all errors (excepting <AXI4_WRITE_DATA_BEFORE_ADDRESS>) are enabled. To suppress a particular error, set the corresponding bit to 0 (false) by e.g. config.m_bfm.set_config_enable_error_index1(<AXI4_WRITE_DATA_BEFORE_ADDRESS>, 0);
    // 
    //
    bit [255:0] config_enable_error;

    // Variable:- config_max_latency_AWVALID_assertion_to_AWREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <AWVALID> to the assertion of <AWREADY> (default 10000).
    // 
    // The error message <AXI4_AWREADY_NOT_ASSERTED_AFTER_AWVALID> will be issued if this period elapses from the assertion of <AWVALID>.
    // 
    //
    int unsigned config_max_latency_AWVALID_assertion_to_AWREADY;

    // Variable:- config_max_latency_ARVALID_assertion_to_ARREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <ARVALID> to the assertion of <ARREADY> (default 10000).
    // 
    // The error message <AXI4_ARREADY_NOT_ASSERTED_AFTER_ARVALID> will be issued if this period elapses from the assertion of <ARVALID>.
    // 
    //
    int unsigned config_max_latency_ARVALID_assertion_to_ARREADY;

    // Variable:- config_max_latency_RVALID_assertion_to_RREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <RVALID> to the assertion of <RREADY> (default 10000).
    // 
    // The error message <AXI4_RREADY_NOT_ASSERTED_AFTER_RVALID> will be issued if this period elapses from the assertion of <RVALID>.
    // 
    //
    int unsigned config_max_latency_RVALID_assertion_to_RREADY;

    // Variable:- config_max_latency_BVALID_assertion_to_BREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <BVALID> to the assertion of <BREADY> (default 10000).
    // 
    // The error message <AXI4_BREADY_NOT_ASSERTED_AFTER_BVALID> will be issued if this period elapses from the assertion of <BVALID>.
    // 
    //
    int unsigned config_max_latency_BVALID_assertion_to_BREADY;

    // Variable:- config_max_latency_WVALID_assertion_to_WREADY
    //
    //  A configuration parameter defining the timeout (in clock periods) from the assertion of <WVALID> to the assertion of <WREADY> (default 10000).
    // 
    // The error message <AXI4_WREADY_NOT_ASSERTED_AFTER_WVALID> will be issued if this period elapses from the assertion of <WVALID>.
    // 
    //
    int unsigned config_max_latency_WVALID_assertion_to_WREADY;

    // Variable:- config_enable_qos
    //
    //  A configuration parameter defining whether the master participates in the Quality-of-Service scheme  (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.1.2). 
    // 
    // This defaults to 'true' i.e. the master participates in the Quality-of-Service scheme. If a master does not participate, the <AWQOS>/<ARQOS> value used in write/read transactions must be b0000.
    // 
    //
    bit config_enable_qos;

    // Variable:- config_enable_region_support
    //
    //  A configuration parameter enabling region address decoding by the Questa Verification IP (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1).
    // 
    // When set to 'true', the Questa Verification IP will, during generation, perform an address decode function, using the <config_region> region map, and provide the
    //  <axi4_master_rw_transaction::region>, <axi4_master_write::region>, <axi4_master_write::region> parameter values (ignoring any value provided by the user); during recognition the Questa Verification IP will check the observed region value against the region map for correctness.
    // 
    // When set to 'false' (the default), the Questa Verification IP will not perform the decode function, and will pass the user-defined region parameter value to the slave; this supports error-injection (see <Error Injection in AXI4>).
    // 
    //
    bit config_enable_region_support;

    // Variable:- config_slave_regions
    //
    //  The number of regions supported by the slave end of this interface.
    // 
    // The system interconnect can provide an address decode of the address space into regions (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1), relieving the slave of the need to decode the address itself.   
    // 
    //  This defaults to <AXI4_REGION_MAP_SIZE>.
    // 
    //
    int config_slave_regions;

    // Variable:- config_region
    //
    //  An array of configurable system region map entries.
    // 
    // Each entry consists of a concatenation of the region lower-address boundary, upper-address boundary, region value and cachable/non-cacheable bit. The number of entries is given by <config_slave_regions>, and the size of the array by the configuration parameter <AXI4_REGION_MAP_SIZE> (see AMBA AXI and ACE Protocol Specification IHI0022D section A8.2.1 and A4.5).
    // 
    // When <config_enable_region_support> is set to true (1'b1), and no errors were detected in the region-map (<region_error_state>), constraints will be applied to enforce that the region parameter of <axi4_master_write>, <axi4_master_read>, <axi4_master_rw_transaction>, <axi4_master_write_addr_channel_phase> and <axi4_master_read_addr_channel_phase>) has the value defined in the region map for the given address. 
    // 
    // In addition, a constraint (for example, <axi4_master_write::exclusive_access_to_non_cacheable_address_region_constraint>) will be enforced to ensure that exclusive accesses can only be made to non-cacheable regions of the address map (see AMBA AXI and ACE Protocol Specification IHI0022D section A7.2.4 and A4.5). 
    // 
    // Here is example code for initializing the region map in SystemVerilog (for the case AXI4_ADDRESS_WIDTH = 32, AXI4_REGION_MAP_SIZE = 16). Note that the first entry in the array is at the end of the initializer!
    // 
    // (start code)
    //   typedef bit[AXI4_ADDRESS_WIDTH-1:0] Address;
    //   axi4_if.set_config_enable_region_support(1'b1);
    //   axi4_if.set_config_slave_regions(16);
    //   axi4_if.set_config_region(config_t::axi4_region_map_t'{
    //     // lower-bound address   upper-bound address    region cacheable
    //     {Address'(32'hf0000000), Address'(32'hffffffff),4'hf, 1'b0},
    //     {Address'(32'he0000000), Address'(32'hefffffff),4'he, 1'b0},
    //     {Address'(32'hd0000000), Address'(32'hdfffffff),4'hd, 1'b0},
    //     {Address'(32'hc0000000), Address'(32'hcfffffff),4'hc, 1'b0},
    //     {Address'(32'hb0000000), Address'(32'hbfffffff),4'hb, 1'b0},
    //     {Address'(32'ha0000000), Address'(32'hafffffff),4'ha, 1'b0},
    //     {Address'(32'h90000000), Address'(32'h9fffffff),4'h9, 1'b0},
    //     {Address'(32'h80000000), Address'(32'h8fffffff),4'h8, 1'b1},
    //     {Address'(32'h70000000), Address'(32'h7fffffff),4'h7, 1'b1},
    //     {Address'(32'h60000000), Address'(32'h6fffffff),4'h6, 1'b1},
    //     {Address'(32'h50000000), Address'(32'h5fffffff),4'h5, 1'b1},
    //     {Address'(32'h40000000), Address'(32'h4fffffff),4'h4, 1'b1},
    //     {Address'(32'h30000000), Address'(32'h3fffffff),4'h3, 1'b1},
    //     {Address'(32'h20000000), Address'(32'h2fffffff),4'h2, 1'b1},
    //     {Address'(32'h10000000), Address'(32'h1fffffff),4'h1, 1'b1},
    //     {Address'(32'h00000000), Address'(32'h0fffffff),4'h0, 1'b1}
    //   });
    // (end code)
    // 
    // Note the use of the axi4_region_map_t type defined in <axi4_vip_config>, to avoid conversion problems on some simulators.
    // 
    // 
    //
    bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  config_region;

    // Variable:- config_read_data_reordering_depth
    //
    //  A configuration parameter defining the read reordering depth of the slave end of the interface (see AMBA AXI and ACE Protocol Specification IHI0022D section A5.3.1).
    // 
    // Responses from the first <config_read_data_reordering_depth> outstanding read transactions, each with address <ARID> values different from any
    //  earlier outstanding read transaction(as seen by the slave) are expected, interleaved at random. A violation causes a <AXI4_READ_REORDERING_VIOLATION> error.
    // 
    // The default value of <config_read_data_reordering_depth> is (1 << AXI4_ID_WIDTH), so that the slave is expected to process all transactions in any order (up to uniqueness of <ARID>).
    // 
    // For a given <AXI4_ID_WIDTH> parameter value, the maximum possible value of <config_read_data_reordering_depth> is 2**AXI4_ID_WIDTH. The <AXI4_PARAM_READ_REORDERING_DEPTH_EXCEEDS_MAX_ID>
    //  error report will be issued if <config_read_data_reordering_depth> exceeds this value.
    // 
    // If the user-supplied value is 0, the <AXI4_PARAM_READ_REORDERING_DEPTH_EQUALS_ZERO> error will be issued, and the value will be set to 1.
    // 
    //
    int unsigned config_read_data_reordering_depth;

    // Variable:- config_slave_start_addr
    //
    //  A configuration parameter indicating start address for slave.
    // 
    //
    bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr;

    // Variable:- config_slave_end_addr
    //
    //  A configuration parameter indicating end address for slave.
    // 
    //
    bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr;

    // Variable:- config_slave_enabled_non_contiguous_address_spaces
    //
    // 
    //    This variable is used to configure the number of enabled non-contiguous address spaces for AXI4 Slaves in the system.
    //    By default, it is assumed that AXI4 slave posses only one contiguous address space. The default value of this configuration is 1.  
    //    If this configuration is set to (let's say 10), it indicates that the AXI4 slave in the system possess 10 non-contiguous address spaces.
    //    Default value is 1.
    //    Please note that this configuration shall come into effect only when the AXI4 slaves in the system support multiple non-contiguous address spaces. (i.e. config_slave_possess_multiple_non_contiguous_address_spaces = 0b1) 
    // 
    //
    int config_slave_enabled_non_contiguous_address_spaces;

    // Variable:- config_slave_possess_multiple_non_contiguous_address_spaces
    //
    // 
    //    This variable is used to configure whether AXI4 Slaves in the system possess multiple non-contiguous address space.
    //    If this configuration is set to False, it indicate that AXI4 slaves in the system possess single contiguous address space.
    //    If this configuration is set to True, it indicate that AXI4 slaves in the system possess multiple contiguous address spaces.
    //    Default value is False.
    // 
    //
    bit config_slave_possess_multiple_non_contiguous_address_spaces;

    // Variable:- config_slave_multiple_non_contiguous_start_address_range
    //
    // 
    //    This variable is used to configure the Start Addresses of all the non-contiguous address spaces for the Various AXI4 Slaves in the system.
    //    Address map for the for a particular non-contiguous address space in the slave - Start Address for that non-contiguous address space in the Slave
    // 
    //
    bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_start_address_range;

    // Variable:- config_slave_multiple_non_contiguous_end_address_range
    //
    // 
    //    This variable is used to configure the End Addresses of all the non-contiguous address spaces for the Various AXI4 Slaves in the system.
    //    Address map for the for a particular non-contiguous address space in the slave - End Address for that non-contiguous address space in the Slave
    // 
    //
    bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_end_address_range;

    // Variable:- config_protect_ready
    //
    //  A configuration parameter controlling whether the wave display will show transaction items representing the state of the <mgc_axi4::AWREADY>, <mgc_axi4::ARREADY>, <mgc_axi4::BREADY>, <mgc_axi4::WREADY> and <mgc_axi4::RREADY> signals. 
    // 
    // If set to 1'b0, the transaction items will be shown on the wave display. Since this display has a performance penalty, the default value of this parameter is 1'b1 (i.e. do not display).
    // 
    //
    bit config_protect_ready;

    // Variable:- config_max_outstanding_wr
    //
    int config_max_outstanding_wr;

    // Variable:- config_max_outstanding_rd
    //
    int config_max_outstanding_rd;

    // Variable:- config_num_outstanding_wr_phase
    //
    int config_num_outstanding_wr_phase;

    // Variable:- config_num_outstanding_rd_phase
    //
    int config_num_outstanding_rd_phase;

    // Variable:- config_enable_warnings
    //
    // A configuration parameter controlling whether warning messages are to be output.  This defaults to 1'b1 i.e. output warnings.
    //
    bit config_enable_warnings;

    // Variable:- config_enable_errors
    //
    //  This configuration variable is deprecated. Please use <config_enable_all_assertions> variable for this functionality.
    //    A configuration parameter controlling whether error messages are to be output.  This defaults to 1'b1 i.e. output error messages.
    // 
    //
    bit config_enable_errors;

    // Variable:- config_enable_exclusive_checks
    //
    // A configuration parameter controlling whether error messages related to exclusive accesses are to be output.  This defaults to 1'b1 i.e. output error messages.
    //
    bit config_enable_exclusive_checks;

    // Variable:- config_warn_on_slave_errors
    //
    //  A configuration parameter controlling whether an error message is to be issued in the case where the slave returns a response indicating an error. (This default to 1'b1 i.e. output error messages).
    // 
    // An error response (see AMBA AXI and ACE Protocol Specification IHI0022D section A3.4.4) from the slave end occurs when
    // + the interconnect responds with <AXI4_DECERR> because it cannot locate a slave at the transaction address;
    // + the slave responds with <AXI4_SLVERR> because it wishes to signal an error condition to the master;
    // 
    // 
    //
    bit config_warn_on_slave_errors;

    // Variable:- config_error_on_deleted_valid_cycles
    //
    //  A configuration parameter controlling whether an error message will be issued when a valid transaction item is not recognized. 
    // 
    // When set to 1'b1 (the default), an error message will be issued.
    // 
    //
    bit config_error_on_deleted_valid_cycles;

    // Variable:- config_stats_enable
    //
    bit config_stats_enable;

    // Variable:- config_stats_enable_read_occupancy
    //
    bit config_stats_enable_read_occupancy;

    // Variable:- config_stats_enable_write_occupancy
    //
    bit config_stats_enable_write_occupancy;

    // Variable:- config_stats_enable_read_data_occupancy
    //
    bit config_stats_enable_read_data_occupancy;

    // Variable:- config_stats_enable_write_data_occupancy
    //
    bit config_stats_enable_write_data_occupancy;

    // Variable:- config_stats_enable_read_latency
    //
    bit config_stats_enable_read_latency;

    // Variable:- config_stats_enable_write_latency
    //
    bit config_stats_enable_write_latency;

    // Variable:- config_stats_enable_read_address_waits
    //
    bit config_stats_enable_read_address_waits;

    // Variable:- config_stats_enable_read_data_waits
    //
    bit config_stats_enable_read_data_waits;

    // Variable:- config_stats_enable_write_address_waits
    //
    bit config_stats_enable_write_address_waits;

    // Variable:- config_stats_enable_write_data_waits
    //
    bit config_stats_enable_write_data_waits;

    // Variable:- config_stats_enable_write_response_waits
    //
    bit config_stats_enable_write_response_waits;

    // Variable:- config_stats_enable_read_bandwidth
    //
    bit config_stats_enable_read_bandwidth;

    // Variable:- config_stats_enable_write_bandwidth
    //
    bit config_stats_enable_write_bandwidth;

    // Variable:- config_stats_read_occupancy_step
    //
    int config_stats_read_occupancy_step;

    // Variable:- config_stats_read_occupancy_multiple
    //
    int config_stats_read_occupancy_multiple;

    // Variable:- config_stats_write_occupancy_step
    //
    int config_stats_write_occupancy_step;

    // Variable:- config_stats_write_occupancy_multiple
    //
    int config_stats_write_occupancy_multiple;

    // Variable:- config_stats_read_data_occupancy_step
    //
    int config_stats_read_data_occupancy_step;

    // Variable:- config_stats_read_data_occupancy_multiple
    //
    int config_stats_read_data_occupancy_multiple;

    // Variable:- config_stats_write_data_occupancy_step
    //
    int config_stats_write_data_occupancy_step;

    // Variable:- config_stats_write_data_occupancy_multiple
    //
    int config_stats_write_data_occupancy_multiple;

    // Variable:- config_stats_read_bandwidth_step
    //
    int config_stats_read_bandwidth_step;

    // Variable:- config_stats_read_bandwidth_multiple
    //
    int config_stats_read_bandwidth_multiple;

    // Variable:- config_stats_write_bandwidth_step
    //
    int config_stats_write_bandwidth_step;

    // Variable:- config_stats_write_bandwidth_multiple
    //
    int config_stats_write_bandwidth_multiple;

    // Variable:- config_stats_read_latency_step
    //
    int config_stats_read_latency_step;

    // Variable:- config_stats_read_latency_multiple
    //
    int config_stats_read_latency_multiple;

    // Variable:- config_stats_write_latency_step
    //
    int config_stats_write_latency_step;

    // Variable:- config_stats_write_latency_multiple
    //
    int config_stats_write_latency_multiple;

    // Variable:- config_stats_read_address_waits_step
    //
    int config_stats_read_address_waits_step;

    // Variable:- config_stats_read_address_waits_multiple
    //
    int config_stats_read_address_waits_multiple;

    // Variable:- config_stats_read_data_waits_step
    //
    int config_stats_read_data_waits_step;

    // Variable:- config_stats_read_data_waits_multiple
    //
    int config_stats_read_data_waits_multiple;

    // Variable:- config_stats_write_address_waits_step
    //
    int config_stats_write_address_waits_step;

    // Variable:- config_stats_write_address_waits_multiple
    //
    int config_stats_write_address_waits_multiple;

    // Variable:- config_stats_write_data_waits_step
    //
    int config_stats_write_data_waits_step;

    // Variable:- config_stats_write_data_waits_multiple
    //
    int config_stats_write_data_waits_multiple;

    // Variable:- config_stats_write_response_waits_step
    //
    int config_stats_write_response_waits_step;

    // Variable:- config_stats_write_response_waits_multiple
    //
    int config_stats_write_response_waits_multiple;

    //------------------------------------------------------------------------------
    // Global Variables - status
    //------------------------------------------------------------------------------

    // Variable:- region_error_state
    //
    //  A read-only flag, internally set to true if there had been an error with the region specification provided by the user.
    // 
    // If true, behave as though <config_enable_region_support> is false. 
    // 
    // 
    //
    bit region_error_state;

    // Variable:- region_map_lb
    //
    //  An array showing the lower address bound for each region in the <config_region> region map. This is extracted from the user-supplied <config_region>, and is non-modifiable.
    // 
    // Although the information is already present in <config_region>, on certain simulators it was not usable within constraints, and had to be extracted into a separate array. 
    // 
    //
    longint unsigned region_map_lb [((AXI4_REGION_MAP_SIZE) - 1):0];

    // Variable:- region_map_ub
    //
    //  An array showing the upper address bound for each region in the <config_region> region map. This is extracted from the user-supplied <config_region>, and is non-modifiable.
    // 
    // Although the information is already present in <config_region>, on certain simulators it was not usable within constraints, and had to be extracted into a separate array. 
    // 
    //
    longint unsigned region_map_ub [((AXI4_REGION_MAP_SIZE) - 1):0];

    // Variable:- region_map_region
    //
    //  An array showing the regions in the <config_region> region map. This is extracted from the user-supplied <config_region>, and is non-modifiable.
    // 
    // Although the information is already present in <config_region>, on certain simulators it was not usable within constraints, and had to be extracted into a separate array. 
    // 
    //
    byte unsigned region_map_region [((AXI4_REGION_MAP_SIZE) - 1):0];

    // Variable:- cacheable
    //
    //  An array showing the cacheability of each region in the <config_region> region map. This is extracted from the user-supplied <config_region>, and is non-modifiable.
    // 
    // Although the information is already present in <config_region>, on certain simulators it was not usable within constraints, and had to be extracted into a separate array. 
    // 
    //
    byte unsigned cacheable [((AXI4_REGION_MAP_SIZE) - 1):0];

    // Variable:- master_end_tlm_status
    //
    //  A status variable indicating whether the master end of the interface is TLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    // Once the end is set as TLM-connected, it should not be changed.
    // 
    //
    bit master_end_tlm_status;

    // Variable:- master_end_wlm_status
    //
    //  A status variable indicating whether the master end of the interface is WLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    //
    bit master_end_wlm_status;

    // Variable:- slave_end_tlm_status
    //
    //  A status variable indicating whether the slave end of the interface is TLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    // Once the end is set as TLM-connected, it should not be changed.
    // 
    //
    bit slave_end_tlm_status;

    // Variable:- slave_end_wlm_status
    //
    //  A status variable indicating whether the slave end of the interface is WLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    //
    bit slave_end_wlm_status;

    // Variable:- clock_source_end_tlm_status
    //
    //  A status variable indicating whether the clock_source end of the interface is TLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    // Once the end is set as TLM-connected, it should not be changed.
    // 
    //
    bit clock_source_end_tlm_status;

    // Variable:- clock_source_end_wlm_status
    //
    //  A status variable indicating whether the clock_source end of the interface is WLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    //
    bit clock_source_end_wlm_status;

    // Variable:- reset_source_end_tlm_status
    //
    //  A status variable indicating whether the reset_source end of the interface is TLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    // Once the end is set as TLM-connected, it should not be changed.
    // 
    //
    bit reset_source_end_tlm_status;

    // Variable:- reset_source_end_wlm_status
    //
    //  A status variable indicating whether the reset_source end of the interface is WLM-connected (see <Abstraction Levels of Interface Ends>).
    // 
    //
    bit reset_source_end_wlm_status;

    // Variable:- stats_rw_transaction_last_duration
    //
    int stats_rw_transaction_last_duration;

    // Variable:- stats_read_active
    //
    bit stats_read_active;

    // Variable:- stats_read_occupancy_sw
    //
    int stats_read_occupancy_sw;

    // Variable:- stats_read_idle_sw
    //
    int stats_read_idle_sw;

    // Variable:- stats_read_occupancy_min
    //
    int stats_read_occupancy_min;

    // Variable:- stats_read_idle_min
    //
    int stats_read_idle_min;

    // Variable:- stats_read_occupancy_max
    //
    int stats_read_occupancy_max;

    // Variable:- stats_read_idle_max
    //
    int stats_read_idle_max;

    // Variable:- stats_read_occupancy_mean
    //
    int stats_read_occupancy_mean;

    // Variable:- stats_read_idle_mean
    //
    int stats_read_idle_mean;

    // Variable:- stats_read_last_duration
    //
    int stats_read_last_duration;

    // Variable:- stats_write_active
    //
    bit stats_write_active;

    // Variable:- stats_write_occupancy_sw
    //
    int stats_write_occupancy_sw;

    // Variable:- stats_write_idle_sw
    //
    int stats_write_idle_sw;

    // Variable:- stats_write_occupancy_min
    //
    int stats_write_occupancy_min;

    // Variable:- stats_write_idle_min
    //
    int stats_write_idle_min;

    // Variable:- stats_write_occupancy_max
    //
    int stats_write_occupancy_max;

    // Variable:- stats_write_idle_max
    //
    int stats_write_idle_max;

    // Variable:- stats_write_occupancy_mean
    //
    int stats_write_occupancy_mean;

    // Variable:- stats_write_idle_mean
    //
    int stats_write_idle_mean;

    // Variable:- stats_write_last_duration
    //
    int stats_write_last_duration;

    // Variable:- stats_read_data_occupancy_sw
    //
    int stats_read_data_occupancy_sw;

    // Variable:- stats_read_data_idle_sw
    //
    int stats_read_data_idle_sw;

    // Variable:- stats_read_data_occupancy_min
    //
    int stats_read_data_occupancy_min;

    // Variable:- stats_read_data_idle_min
    //
    int stats_read_data_idle_min;

    // Variable:- stats_read_data_occupancy_max
    //
    int stats_read_data_occupancy_max;

    // Variable:- stats_read_data_idle_max
    //
    int stats_read_data_idle_max;

    // Variable:- stats_read_data_occupancy_mean
    //
    int stats_read_data_occupancy_mean;

    // Variable:- stats_read_data_idle_mean
    //
    int stats_read_data_idle_mean;

    // Variable:- stats_write_data_occupancy_sw
    //
    int stats_write_data_occupancy_sw;

    // Variable:- stats_write_data_idle_sw
    //
    int stats_write_data_idle_sw;

    // Variable:- stats_write_data_occupancy_min
    //
    int stats_write_data_occupancy_min;

    // Variable:- stats_write_data_idle_min
    //
    int stats_write_data_idle_min;

    // Variable:- stats_write_data_occupancy_max
    //
    int stats_write_data_occupancy_max;

    // Variable:- stats_write_data_idle_max
    //
    int stats_write_data_idle_max;

    // Variable:- stats_write_data_occupancy_mean
    //
    int stats_write_data_occupancy_mean;

    // Variable:- stats_write_data_idle_mean
    //
    int stats_write_data_idle_mean;

    // Variable:- stats_read_bandwidth_sw
    //
    int stats_read_bandwidth_sw;

    // Variable:- stats_read_bandwidth_min
    //
    int stats_read_bandwidth_min;

    // Variable:- stats_read_bandwidth_max
    //
    int stats_read_bandwidth_max;

    // Variable:- stats_read_bandwidth_mean
    //
    int stats_read_bandwidth_mean;

    // Variable:- stats_write_bandwidth_sw
    //
    int stats_write_bandwidth_sw;

    // Variable:- stats_write_bandwidth_min
    //
    int stats_write_bandwidth_min;

    // Variable:- stats_write_bandwidth_max
    //
    int stats_write_bandwidth_max;

    // Variable:- stats_write_bandwidth_mean
    //
    int stats_write_bandwidth_mean;

    // Variable:- stats_read_address_data_latency_inst
    //
    int stats_read_address_data_latency_inst;

    // Variable:- stats_read_address_data_latency_sw
    //
    int stats_read_address_data_latency_sw;

    // Variable:- stats_read_address_data_latency_min
    //
    int stats_read_address_data_latency_min;

    // Variable:- stats_read_address_data_latency_max
    //
    int stats_read_address_data_latency_max;

    // Variable:- stats_read_address_data_latency_mean
    //
    int stats_read_address_data_latency_mean;

    // Variable:- stats_read_address_address_latency_inst
    //
    int stats_read_address_address_latency_inst;

    // Variable:- stats_read_address_address_latency_sw
    //
    int stats_read_address_address_latency_sw;

    // Variable:- stats_read_address_address_latency_min
    //
    int stats_read_address_address_latency_min;

    // Variable:- stats_read_address_address_latency_max
    //
    int stats_read_address_address_latency_max;

    // Variable:- stats_read_address_address_latency_mean
    //
    int stats_read_address_address_latency_mean;

    // Variable:- stats_write_address_response_latency_inst
    //
    int stats_write_address_response_latency_inst;

    // Variable:- stats_write_address_response_latency_sw
    //
    int stats_write_address_response_latency_sw;

    // Variable:- stats_write_address_response_latency_min
    //
    int stats_write_address_response_latency_min;

    // Variable:- stats_write_address_response_latency_max
    //
    int stats_write_address_response_latency_max;

    // Variable:- stats_write_address_response_latency_mean
    //
    int stats_write_address_response_latency_mean;

    // Variable:- stats_write_address_address_latency_inst
    //
    int stats_write_address_address_latency_inst;

    // Variable:- stats_write_address_address_latency_sw
    //
    int stats_write_address_address_latency_sw;

    // Variable:- stats_write_address_address_latency_min
    //
    int stats_write_address_address_latency_min;

    // Variable:- stats_write_address_address_latency_max
    //
    int stats_write_address_address_latency_max;

    // Variable:- stats_write_address_address_latency_mean
    //
    int stats_write_address_address_latency_mean;

    // Variable:- stats_read_address_waits_inst
    //
    int stats_read_address_waits_inst;

    // Variable:- stats_read_address_waits_sw
    //
    int stats_read_address_waits_sw;

    // Variable:- stats_read_address_waits_min
    //
    int stats_read_address_waits_min;

    // Variable:- stats_read_address_waits_max
    //
    int stats_read_address_waits_max;

    // Variable:- stats_read_address_waits_mean
    //
    int stats_read_address_waits_mean;

    // Variable:- stats_read_data_waits_inst
    //
    int stats_read_data_waits_inst;

    // Variable:- stats_read_data_waits_sw
    //
    int stats_read_data_waits_sw;

    // Variable:- stats_read_data_waits_min
    //
    int stats_read_data_waits_min;

    // Variable:- stats_read_data_waits_max
    //
    int stats_read_data_waits_max;

    // Variable:- stats_read_data_waits_mean
    //
    int stats_read_data_waits_mean;

    // Variable:- stats_write_address_waits_inst
    //
    int stats_write_address_waits_inst;

    // Variable:- stats_write_address_waits_sw
    //
    int stats_write_address_waits_sw;

    // Variable:- stats_write_address_waits_min
    //
    int stats_write_address_waits_min;

    // Variable:- stats_write_address_waits_max
    //
    int stats_write_address_waits_max;

    // Variable:- stats_write_address_waits_mean
    //
    int stats_write_address_waits_mean;

    // Variable:- stats_write_data_waits_inst
    //
    int stats_write_data_waits_inst;

    // Variable:- stats_write_data_waits_sw
    //
    int stats_write_data_waits_sw;

    // Variable:- stats_write_data_waits_min
    //
    int stats_write_data_waits_min;

    // Variable:- stats_write_data_waits_max
    //
    int stats_write_data_waits_max;

    // Variable:- stats_write_data_waits_mean
    //
    int stats_write_data_waits_mean;

    // Variable:- stats_write_response_waits_inst
    //
    int stats_write_response_waits_inst;

    // Variable:- stats_write_response_waits_sw
    //
    int stats_write_response_waits_sw;

    // Variable:- stats_write_response_waits_min
    //
    int stats_write_response_waits_min;

    // Variable:- stats_write_response_waits_max
    //
    int stats_write_response_waits_max;

    // Variable:- stats_write_response_waits_mean
    //
    int stats_write_response_waits_mean;

    // Variable:- reordering_depth_of_last_read_transaction
    //
    //  The read reordering depth at which the first response to the last read transaction arrived (see AMBA AXI and ACE Protocol Specification IHI0022D section A5.3.1)
    // 
    // For <config_read_data_reordering_depth> equal to 1, responses to read transactions must arrive in the order of issuing the read addresses,
    // and all responses for a transaction must have arrived before any response to a later transaction arrive.
    // When the <config_read_data_reordering_depth> is greater than 1, the first responses to read transactions must still arrive in the order of issuing the read addresses,
    // but responses to later transactions do not have to wait until all responses to earlier transactions have arrived.
    // Instead, up to <config_read_data_reordering_depth> transactions can be receiving responses.
    // 
    // when the first response to a read transaction is observed, the Questa Verification IP records the position of this transaction is the queue of unfinished transactions;
    // at the end of the transaction, this value is copied to <reordering_depth_of_last_read_transaction>, so allowing coverage of the depth of read reordering.
    // This variable is read-only, and its value is overwritten by the next read transaction to finish.
    // 
    //
    int reordering_depth_of_last_read_transaction;


    //------------------------------------------------------------------------------
    // Assertions
    //------------------------------------------------------------------------------
    // Documentation for assertions has been moved to <axi4_assertions.svh>.

    import "DPI-C" context axi4_get_axi4_master_end = function longint axi4_get_axi4_master_end();
    import "DPI-C" context axi4_get_axi4_slave_end = function longint axi4_get_axi4_slave_end();
    import "DPI-C" context axi4_get_axi4_clock_source_end = function longint axi4_get_axi4_clock_source_end();
    import "DPI-C" context axi4_get_axi4_reset_source_end = function longint axi4_get_axi4_reset_source_end();
    import "DPI-C" context axi4_get_axi4__monitor_end = function longint axi4_get_axi4__monitor_end();
    // Declare user visible wires variables, for non-continuous assignments.
    logic m_ACLK = 'z;
    logic m_ARESETn = 'z;
    logic m_AWVALID = 'z;
    logic [((AXI4_ADDRESS_WIDTH) - 1):0]  m_AWADDR = 'z;
    logic [2:0] m_AWPROT = 'z;
    logic [3:0] m_AWREGION = 'z;
    logic [7:0] m_AWLEN = 'z;
    logic [2:0] m_AWSIZE = 'z;
    logic [1:0] m_AWBURST = 'z;
    logic m_AWLOCK = 'z;
    logic [3:0] m_AWCACHE = 'z;
    logic [3:0] m_AWQOS = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  m_AWID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  m_AWUSER = 'z;
    logic m_AWREADY = 'z;
    logic m_ARVALID = 'z;
    logic [((AXI4_ADDRESS_WIDTH) - 1):0]  m_ARADDR = 'z;
    logic [2:0] m_ARPROT = 'z;
    logic [3:0] m_ARREGION = 'z;
    logic [7:0] m_ARLEN = 'z;
    logic [2:0] m_ARSIZE = 'z;
    logic [1:0] m_ARBURST = 'z;
    logic m_ARLOCK = 'z;
    logic [3:0] m_ARCACHE = 'z;
    logic [3:0] m_ARQOS = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  m_ARID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  m_ARUSER = 'z;
    logic m_ARREADY = 'z;
    logic m_RVALID = 'z;
    logic [((AXI4_RDATA_WIDTH) - 1):0]  m_RDATA = 'z;
    logic [1:0] m_RRESP = 'z;
    logic m_RLAST = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  m_RID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  m_RUSER = 'z;
    logic m_RREADY = 'z;
    logic m_WVALID = 'z;
    logic [((AXI4_WDATA_WIDTH) - 1):0]  m_WDATA = 'z;
    logic [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  m_WSTRB = 'z;
    logic m_WLAST = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  m_WUSER = 'z;
    logic m_WREADY = 'z;
    logic m_BVALID = 'z;
    logic [1:0] m_BRESP = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  m_BID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  m_BUSER = 'z;
    logic m_BREADY = 'z;

    // Forces a sweep through the wire change checkers at time 0 to get around process kick-off order unknowns
    bit _check_t0_values;
    always_comb _check_t0_values = 1;


    //------------------------------------------------------------------------------
    // Generic Interface Configuration Support
    //------------------------------------------------------------------------------

    import "DPI-C" context axi4_set_interface = function void axi4_set_interface
    (
        input int what,
        input int arg1,
        input int arg2,
        input int arg3,
        input int arg4,
        input int arg5,
        input int arg6,
        input int arg7,
        input int arg8,
        input int arg9,
        input int arg10
    );
    import "DPI-C" context axi4_get_interface = function int axi4_get_interface
    (
        input int what,
        input int arg1,
        input int arg2,
        input int arg3,
        input int arg4,
        input int arg5,
        input int arg6,
        input int arg7,
        input int arg8,
        input int arg9
    );
    //------------------------------------------------------------------------------
    // Functions to get the hierarchic name of this interface
    //------------------------------------------------------------------------------
    import "DPI-C" context axi4_get_full_name = function string axi4_get_full_name();

    //------------------------------------------------------------------------------
    // Abstraction level Support
    //------------------------------------------------------------------------------

    import "DPI-C" context axi4_set_master_end_abstraction_level = function void axi4_set_master_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi4_get_master_end_abstraction_level = function void axi4_get_master_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    import "DPI-C" context axi4_set_slave_end_abstraction_level = function void axi4_set_slave_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi4_get_slave_end_abstraction_level = function void axi4_get_slave_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    import "DPI-C" context axi4_set_clock_source_end_abstraction_level = function void axi4_set_clock_source_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi4_get_clock_source_end_abstraction_level = function void axi4_get_clock_source_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
    import "DPI-C" context axi4_set_reset_source_end_abstraction_level = function void axi4_set_reset_source_end_abstraction_level
    (
        input bit         wire_level,
        input bit         TLM_level
    );
    import "DPI-C" context axi4_get_reset_source_end_abstraction_level = function void axi4_get_reset_source_end_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );

    //------------------------------------------------------------------------------
    // Wire Level Interface Support
    //------------------------------------------------------------------------------
    logic internal_ACLK = 'z;
    logic internal_ARESETn = 'z;
    logic internal_AWVALID = 'z;
    logic [((AXI4_ADDRESS_WIDTH) - 1):0]  internal_AWADDR = 'z;
    logic [2:0] internal_AWPROT = 'z;
    logic [3:0] internal_AWREGION = 'z;
    logic [7:0] internal_AWLEN = 'z;
    logic [2:0] internal_AWSIZE = 'z;
    logic [1:0] internal_AWBURST = 'z;
    logic internal_AWLOCK = 'z;
    logic [3:0] internal_AWCACHE = 'z;
    logic [3:0] internal_AWQOS = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  internal_AWID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  internal_AWUSER = 'z;
    logic internal_AWREADY = 'z;
    logic internal_ARVALID = 'z;
    logic [((AXI4_ADDRESS_WIDTH) - 1):0]  internal_ARADDR = 'z;
    logic [2:0] internal_ARPROT = 'z;
    logic [3:0] internal_ARREGION = 'z;
    logic [7:0] internal_ARLEN = 'z;
    logic [2:0] internal_ARSIZE = 'z;
    logic [1:0] internal_ARBURST = 'z;
    logic internal_ARLOCK = 'z;
    logic [3:0] internal_ARCACHE = 'z;
    logic [3:0] internal_ARQOS = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  internal_ARID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  internal_ARUSER = 'z;
    logic internal_ARREADY = 'z;
    logic internal_RVALID = 'z;
    logic [((AXI4_RDATA_WIDTH) - 1):0]  internal_RDATA = 'z;
    logic [1:0] internal_RRESP = 'z;
    logic internal_RLAST = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  internal_RID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  internal_RUSER = 'z;
    logic internal_RREADY = 'z;
    logic internal_WVALID = 'z;
    logic [((AXI4_WDATA_WIDTH) - 1):0]  internal_WDATA = 'z;
    logic [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  internal_WSTRB = 'z;
    logic internal_WLAST = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  internal_WUSER = 'z;
    logic internal_WREADY = 'z;
    logic internal_BVALID = 'z;
    logic [1:0] internal_BRESP = 'z;
    logic [((AXI4_ID_WIDTH) - 1):0]  internal_BID = 'z;
    logic [((AXI4_USER_WIDTH) - 1):0]  internal_BUSER = 'z;
    logic internal_BREADY = 'z;

    import "DPI-C" context function longint axi4_initialise_SystemVerilog
    (
        int usage_code,
        input int AXI4_ADDRESS_WIDTH,
        input int AXI4_RDATA_WIDTH,
        input int AXI4_WDATA_WIDTH,
        input int AXI4_ID_WIDTH,
        input int AXI4_USER_WIDTH,
        input int AXI4_REGION_MAP_SIZE
    );

    // Handle to the linkage
    (* elab_init *) longint _interface_ref =
                                axi4_initialise_SystemVerilog
                                (
                                    18102076,
                                    AXI4_ADDRESS_WIDTH,
                                    AXI4_RDATA_WIDTH,
                                    AXI4_WDATA_WIDTH,
                                    AXI4_ID_WIDTH,
                                    AXI4_USER_WIDTH,
                                    AXI4_REGION_MAP_SIZE
                                ); // DPI call to create transactor (called at elaboration time as initialiser)


    import "DPI-C" context function void axi4_set_ACLK_from_SystemVerilog
    (
        input bit ACLK_param
    );
    import "DPI-C" context function void axi4_propagate_ACLK_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ACLK_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ACLK_from_CY;
    export "DPI-C" function axi4_initialise_ACLK_from_CY;

    import "DPI-C" context function void axi4_set_ARESETn_from_SystemVerilog
    (
        input logic ARESETn_param
    );
    import "DPI-C" context function void axi4_propagate_ARESETn_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARESETn_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARESETn_from_CY;
    export "DPI-C" function axi4_initialise_ARESETn_from_CY;

    import "DPI-C" context function void axi4_set_AWVALID_from_SystemVerilog
    (
        input logic AWVALID_param
    );
    import "DPI-C" context function void axi4_propagate_AWVALID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWVALID_from_CY;
    export "DPI-C" function axi4_initialise_AWVALID_from_CY;

    import "DPI-C" context function void axi4_set_AWADDR_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  AWADDR_param
    );
    import "DPI-C" context function void axi4_propagate_AWADDR_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWADDR_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWADDR_from_CY_index1;
    export "DPI-C" function axi4_initialise_AWADDR_from_CY;

    import "DPI-C" context function void axi4_set_AWPROT_from_SystemVerilog
    (
        input logic [2:0] AWPROT_param
    );
    import "DPI-C" context function void axi4_propagate_AWPROT_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWPROT_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWPROT_from_CY;
    export "DPI-C" function axi4_initialise_AWPROT_from_CY;

    import "DPI-C" context function void axi4_set_AWREGION_from_SystemVerilog
    (
        input logic [3:0] AWREGION_param
    );
    import "DPI-C" context function void axi4_propagate_AWREGION_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWREGION_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWREGION_from_CY;
    export "DPI-C" function axi4_initialise_AWREGION_from_CY;

    import "DPI-C" context function void axi4_set_AWLEN_from_SystemVerilog
    (
        input logic [7:0] AWLEN_param
    );
    import "DPI-C" context function void axi4_propagate_AWLEN_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWLEN_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWLEN_from_CY;
    export "DPI-C" function axi4_initialise_AWLEN_from_CY;

    import "DPI-C" context function void axi4_set_AWSIZE_from_SystemVerilog
    (
        input logic [2:0] AWSIZE_param
    );
    import "DPI-C" context function void axi4_propagate_AWSIZE_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWSIZE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWSIZE_from_CY;
    export "DPI-C" function axi4_initialise_AWSIZE_from_CY;

    import "DPI-C" context function void axi4_set_AWBURST_from_SystemVerilog
    (
        input logic [1:0] AWBURST_param
    );
    import "DPI-C" context function void axi4_propagate_AWBURST_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWBURST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWBURST_from_CY;
    export "DPI-C" function axi4_initialise_AWBURST_from_CY;

    import "DPI-C" context function void axi4_set_AWLOCK_from_SystemVerilog
    (
        input logic AWLOCK_param
    );
    import "DPI-C" context function void axi4_propagate_AWLOCK_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWLOCK_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWLOCK_from_CY;
    export "DPI-C" function axi4_initialise_AWLOCK_from_CY;

    import "DPI-C" context function void axi4_set_AWCACHE_from_SystemVerilog
    (
        input logic [3:0] AWCACHE_param
    );
    import "DPI-C" context function void axi4_propagate_AWCACHE_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWCACHE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWCACHE_from_CY;
    export "DPI-C" function axi4_initialise_AWCACHE_from_CY;

    import "DPI-C" context function void axi4_set_AWQOS_from_SystemVerilog
    (
        input logic [3:0] AWQOS_param
    );
    import "DPI-C" context function void axi4_propagate_AWQOS_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWQOS_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWQOS_from_CY;
    export "DPI-C" function axi4_initialise_AWQOS_from_CY;

    import "DPI-C" context function void axi4_set_AWID_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  AWID_param
    );
    import "DPI-C" context function void axi4_propagate_AWID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWID_from_CY_index1;
    export "DPI-C" function axi4_initialise_AWID_from_CY;

    import "DPI-C" context function void axi4_set_AWUSER_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  AWUSER_param
    );
    import "DPI-C" context function void axi4_propagate_AWUSER_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWUSER_from_CY_index1;
    export "DPI-C" function axi4_initialise_AWUSER_from_CY;

    import "DPI-C" context function void axi4_set_AWREADY_from_SystemVerilog
    (
        input logic AWREADY_param
    );
    import "DPI-C" context function void axi4_propagate_AWREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_AWREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_AWREADY_from_CY;
    export "DPI-C" function axi4_initialise_AWREADY_from_CY;

    import "DPI-C" context function void axi4_set_ARVALID_from_SystemVerilog
    (
        input logic ARVALID_param
    );
    import "DPI-C" context function void axi4_propagate_ARVALID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARVALID_from_CY;
    export "DPI-C" function axi4_initialise_ARVALID_from_CY;

    import "DPI-C" context function void axi4_set_ARADDR_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  ARADDR_param
    );
    import "DPI-C" context function void axi4_propagate_ARADDR_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARADDR_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARADDR_from_CY_index1;
    export "DPI-C" function axi4_initialise_ARADDR_from_CY;

    import "DPI-C" context function void axi4_set_ARPROT_from_SystemVerilog
    (
        input logic [2:0] ARPROT_param
    );
    import "DPI-C" context function void axi4_propagate_ARPROT_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARPROT_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARPROT_from_CY;
    export "DPI-C" function axi4_initialise_ARPROT_from_CY;

    import "DPI-C" context function void axi4_set_ARREGION_from_SystemVerilog
    (
        input logic [3:0] ARREGION_param
    );
    import "DPI-C" context function void axi4_propagate_ARREGION_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARREGION_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARREGION_from_CY;
    export "DPI-C" function axi4_initialise_ARREGION_from_CY;

    import "DPI-C" context function void axi4_set_ARLEN_from_SystemVerilog
    (
        input logic [7:0] ARLEN_param
    );
    import "DPI-C" context function void axi4_propagate_ARLEN_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARLEN_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARLEN_from_CY;
    export "DPI-C" function axi4_initialise_ARLEN_from_CY;

    import "DPI-C" context function void axi4_set_ARSIZE_from_SystemVerilog
    (
        input logic [2:0] ARSIZE_param
    );
    import "DPI-C" context function void axi4_propagate_ARSIZE_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARSIZE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARSIZE_from_CY;
    export "DPI-C" function axi4_initialise_ARSIZE_from_CY;

    import "DPI-C" context function void axi4_set_ARBURST_from_SystemVerilog
    (
        input logic [1:0] ARBURST_param
    );
    import "DPI-C" context function void axi4_propagate_ARBURST_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARBURST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARBURST_from_CY;
    export "DPI-C" function axi4_initialise_ARBURST_from_CY;

    import "DPI-C" context function void axi4_set_ARLOCK_from_SystemVerilog
    (
        input logic ARLOCK_param
    );
    import "DPI-C" context function void axi4_propagate_ARLOCK_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARLOCK_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARLOCK_from_CY;
    export "DPI-C" function axi4_initialise_ARLOCK_from_CY;

    import "DPI-C" context function void axi4_set_ARCACHE_from_SystemVerilog
    (
        input logic [3:0] ARCACHE_param
    );
    import "DPI-C" context function void axi4_propagate_ARCACHE_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARCACHE_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARCACHE_from_CY;
    export "DPI-C" function axi4_initialise_ARCACHE_from_CY;

    import "DPI-C" context function void axi4_set_ARQOS_from_SystemVerilog
    (
        input logic [3:0] ARQOS_param
    );
    import "DPI-C" context function void axi4_propagate_ARQOS_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARQOS_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARQOS_from_CY;
    export "DPI-C" function axi4_initialise_ARQOS_from_CY;

    import "DPI-C" context function void axi4_set_ARID_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  ARID_param
    );
    import "DPI-C" context function void axi4_propagate_ARID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARID_from_CY_index1;
    export "DPI-C" function axi4_initialise_ARID_from_CY;

    import "DPI-C" context function void axi4_set_ARUSER_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  ARUSER_param
    );
    import "DPI-C" context function void axi4_propagate_ARUSER_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARUSER_from_CY_index1;
    export "DPI-C" function axi4_initialise_ARUSER_from_CY;

    import "DPI-C" context function void axi4_set_ARREADY_from_SystemVerilog
    (
        input logic ARREADY_param
    );
    import "DPI-C" context function void axi4_propagate_ARREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_ARREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_ARREADY_from_CY;
    export "DPI-C" function axi4_initialise_ARREADY_from_CY;

    import "DPI-C" context function void axi4_set_RVALID_from_SystemVerilog
    (
        input logic RVALID_param
    );
    import "DPI-C" context function void axi4_propagate_RVALID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_RVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_RVALID_from_CY;
    export "DPI-C" function axi4_initialise_RVALID_from_CY;

    import "DPI-C" context function void axi4_set_RDATA_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  RDATA_param
    );
    import "DPI-C" context function void axi4_propagate_RDATA_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_RDATA_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_RDATA_from_CY_index1;
    export "DPI-C" function axi4_initialise_RDATA_from_CY;

    import "DPI-C" context function void axi4_set_RRESP_from_SystemVerilog
    (
        input logic [1:0] RRESP_param
    );
    import "DPI-C" context function void axi4_propagate_RRESP_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_RRESP_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_RRESP_from_CY;
    export "DPI-C" function axi4_initialise_RRESP_from_CY;

    import "DPI-C" context function void axi4_set_RLAST_from_SystemVerilog
    (
        input logic RLAST_param
    );
    import "DPI-C" context function void axi4_propagate_RLAST_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_RLAST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_RLAST_from_CY;
    export "DPI-C" function axi4_initialise_RLAST_from_CY;

    import "DPI-C" context function void axi4_set_RID_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  RID_param
    );
    import "DPI-C" context function void axi4_propagate_RID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_RID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_RID_from_CY_index1;
    export "DPI-C" function axi4_initialise_RID_from_CY;

    import "DPI-C" context function void axi4_set_RUSER_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  RUSER_param
    );
    import "DPI-C" context function void axi4_propagate_RUSER_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_RUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_RUSER_from_CY_index1;
    export "DPI-C" function axi4_initialise_RUSER_from_CY;

    import "DPI-C" context function void axi4_set_RREADY_from_SystemVerilog
    (
        input logic RREADY_param
    );
    import "DPI-C" context function void axi4_propagate_RREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_RREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_RREADY_from_CY;
    export "DPI-C" function axi4_initialise_RREADY_from_CY;

    import "DPI-C" context function void axi4_set_WVALID_from_SystemVerilog
    (
        input logic WVALID_param
    );
    import "DPI-C" context function void axi4_propagate_WVALID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_WVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_WVALID_from_CY;
    export "DPI-C" function axi4_initialise_WVALID_from_CY;

    import "DPI-C" context function void axi4_set_WDATA_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  WDATA_param
    );
    import "DPI-C" context function void axi4_propagate_WDATA_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_WDATA_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_WDATA_from_CY_index1;
    export "DPI-C" function axi4_initialise_WDATA_from_CY;

    import "DPI-C" context function void axi4_set_WSTRB_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  WSTRB_param
    );
    import "DPI-C" context function void axi4_propagate_WSTRB_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_WSTRB_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_WSTRB_from_CY_index1;
    export "DPI-C" function axi4_initialise_WSTRB_from_CY;

    import "DPI-C" context function void axi4_set_WLAST_from_SystemVerilog
    (
        input logic WLAST_param
    );
    import "DPI-C" context function void axi4_propagate_WLAST_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_WLAST_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_WLAST_from_CY;
    export "DPI-C" function axi4_initialise_WLAST_from_CY;

    import "DPI-C" context function void axi4_set_WUSER_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  WUSER_param
    );
    import "DPI-C" context function void axi4_propagate_WUSER_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_WUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_WUSER_from_CY_index1;
    export "DPI-C" function axi4_initialise_WUSER_from_CY;

    import "DPI-C" context function void axi4_set_WREADY_from_SystemVerilog
    (
        input logic WREADY_param
    );
    import "DPI-C" context function void axi4_propagate_WREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_WREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_WREADY_from_CY;
    export "DPI-C" function axi4_initialise_WREADY_from_CY;

    import "DPI-C" context function void axi4_set_BVALID_from_SystemVerilog
    (
        input logic BVALID_param
    );
    import "DPI-C" context function void axi4_propagate_BVALID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_BVALID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_BVALID_from_CY;
    export "DPI-C" function axi4_initialise_BVALID_from_CY;

    import "DPI-C" context function void axi4_set_BRESP_from_SystemVerilog
    (
        input logic [1:0] BRESP_param
    );
    import "DPI-C" context function void axi4_propagate_BRESP_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_BRESP_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_BRESP_from_CY;
    export "DPI-C" function axi4_initialise_BRESP_from_CY;

    import "DPI-C" context function void axi4_set_BID_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  BID_param
    );
    import "DPI-C" context function void axi4_propagate_BID_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_BID_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_BID_from_CY_index1;
    export "DPI-C" function axi4_initialise_BID_from_CY;

    import "DPI-C" context function void axi4_set_BUSER_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input logic  BUSER_param
    );
    import "DPI-C" context function void axi4_propagate_BUSER_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_BUSER_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_BUSER_from_CY_index1;
    export "DPI-C" function axi4_initialise_BUSER_from_CY;

    import "DPI-C" context function void axi4_set_BREADY_from_SystemVerilog
    (
        input logic BREADY_param
    );
    import "DPI-C" context function void axi4_propagate_BREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_BREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_BREADY_from_CY;
    export "DPI-C" function axi4_initialise_BREADY_from_CY;

    import "DPI-C" context function void axi4_set_config_interface_type_from_SystemVerilog
    (
        input int config_interface_type_param
    );
    import "DPI-C" context function void axi4_propagate_config_interface_type_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_interface_type_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_interface_type_from_CY;

    import "DPI-C" context function void axi4_set_config_clk_init_value_from_SystemVerilog
    (
        input bit config_clk_init_value_param
    );
    import "DPI-C" context function void axi4_propagate_config_clk_init_value_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_clk_init_value_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_clk_init_value_from_CY;

    import "DPI-C" context function void axi4_set_config_clk_phase_shift_from_SystemVerilog
    (
        input longint unsigned config_clk_phase_shift_param
    );
    import "DPI-C" context function void axi4_propagate_config_clk_phase_shift_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_clk_phase_shift_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_clk_phase_shift_from_CY;

    import "DPI-C" context function void axi4_set_config_clk_1st_time_from_SystemVerilog
    (
        input longint unsigned config_clk_1st_time_param
    );
    import "DPI-C" context function void axi4_propagate_config_clk_1st_time_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_clk_1st_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_clk_1st_time_from_CY;

    import "DPI-C" context function void axi4_set_config_clk_2nd_time_from_SystemVerilog
    (
        input longint unsigned config_clk_2nd_time_param
    );
    import "DPI-C" context function void axi4_propagate_config_clk_2nd_time_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_clk_2nd_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_clk_2nd_time_from_CY;

    import "DPI-C" context function void axi4_set_config_setup_time_from_SystemVerilog
    (
        input longint unsigned config_setup_time_param
    );
    import "DPI-C" context function void axi4_propagate_config_setup_time_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_setup_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_setup_time_from_CY;

    import "DPI-C" context function void axi4_set_config_hold_time_from_SystemVerilog
    (
        input longint unsigned config_hold_time_param
    );
    import "DPI-C" context function void axi4_propagate_config_hold_time_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_hold_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_hold_time_from_CY;

    import "DPI-C" context function void axi4_set_config_burst_timeout_factor_from_SystemVerilog
    (
        input int unsigned config_burst_timeout_factor_param
    );
    import "DPI-C" context function void axi4_propagate_config_burst_timeout_factor_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_burst_timeout_factor_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_burst_timeout_factor_from_CY;

    import "DPI-C" context function void axi4_set_config_max_transaction_time_factor_from_SystemVerilog
    (
        input int unsigned config_max_transaction_time_factor_param
    );
    import "DPI-C" context function void axi4_propagate_config_max_transaction_time_factor_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_max_transaction_time_factor_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_transaction_time_factor_from_CY;

    import "DPI-C" context function void axi4_set_config_write_ctrl_first_ratio_from_SystemVerilog
    (
        input int config_write_ctrl_first_ratio_param
    );
    import "DPI-C" context function void axi4_propagate_config_write_ctrl_first_ratio_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_write_ctrl_first_ratio_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_write_ctrl_first_ratio_from_CY;

    import "DPI-C" context function void axi4_set_config_write_data_first_ratio_from_SystemVerilog
    (
        input int config_write_data_first_ratio_param
    );
    import "DPI-C" context function void axi4_propagate_config_write_data_first_ratio_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_write_data_first_ratio_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_write_data_first_ratio_from_CY;

    import "DPI-C" context function void axi4_set_config_reset_low_clocks_from_SystemVerilog
    (
        input int config_reset_low_clocks_param
    );
    import "DPI-C" context function void axi4_propagate_config_reset_low_clocks_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_reset_low_clocks_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_reset_low_clocks_from_CY;

    import "DPI-C" context function void axi4_set_config_reset_hold_time_from_SystemVerilog
    (
        input int config_reset_hold_time_param
    );
    import "DPI-C" context function void axi4_propagate_config_reset_hold_time_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_reset_hold_time_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_reset_hold_time_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_rlast_from_SystemVerilog
    (
        input bit config_enable_rlast_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_rlast_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_rlast_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_rlast_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_slave_exclusive_from_SystemVerilog
    (
        input bit config_enable_slave_exclusive_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_slave_exclusive_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_slave_exclusive_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_slave_exclusive_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_burst_reserved_value_from_SystemVerilog
    (
        input bit config_enable_burst_reserved_value_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_burst_reserved_value_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_burst_reserved_value_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_burst_reserved_value_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_cache_value_from_SystemVerilog
    (
        input bit [15:0] config_enable_cache_value_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_cache_value_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_cache_value_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_cache_value_from_CY;

    import "DPI-C" context function void axi4_set_internal_dummy_variable_from_SystemVerilog
    (
        input int internal_dummy_variable_param
    );
    import "DPI-C" context function void axi4_propagate_internal_dummy_variable_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_internal_dummy_variable_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_internal_dummy_variable_from_CY;

    import "DPI-C" context function void axi4_set_config_axi4lite_interface_from_SystemVerilog
    (
        input bit config_axi4lite_interface_param
    );
    import "DPI-C" context function void axi4_propagate_config_axi4lite_interface_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_axi4lite_interface_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_axi4lite_interface_from_CY;

    import "DPI-C" context function void axi4_set_config_axi4lite_tr_id_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input bit  config_axi4lite_tr_id_param
    );
    import "DPI-C" context function void axi4_propagate_config_axi4lite_tr_id_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_axi4lite_tr_id_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_axi4lite_tr_id_from_CY_index1;

    import "DPI-C" context function void axi4_set_config_enable_all_assertions_from_SystemVerilog
    (
        input bit config_enable_all_assertions_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_all_assertions_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_all_assertions_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_all_assertions_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_assertion_from_SystemVerilog
    (
        input bit [255:0] config_enable_assertion_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_assertion_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_assertion_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_assertion_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_error_from_SystemVerilog
    (
        input bit [255:0] config_enable_error_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_error_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_error_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_error_from_CY;

    import "DPI-C" context function void axi4_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param
    );
    import "DPI-C" context function void axi4_propagate_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_max_latency_AWVALID_assertion_to_AWREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_CY;

    import "DPI-C" context function void axi4_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param
    );
    import "DPI-C" context function void axi4_propagate_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_max_latency_ARVALID_assertion_to_ARREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_CY;

    import "DPI-C" context function void axi4_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_RVALID_assertion_to_RREADY_param
    );
    import "DPI-C" context function void axi4_propagate_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_max_latency_RVALID_assertion_to_RREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_latency_RVALID_assertion_to_RREADY_from_CY;

    import "DPI-C" context function void axi4_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_BVALID_assertion_to_BREADY_param
    );
    import "DPI-C" context function void axi4_propagate_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_max_latency_BVALID_assertion_to_BREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_latency_BVALID_assertion_to_BREADY_from_CY;

    import "DPI-C" context function void axi4_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog
    (
        input int unsigned config_max_latency_WVALID_assertion_to_WREADY_param
    );
    import "DPI-C" context function void axi4_propagate_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_max_latency_WVALID_assertion_to_WREADY_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_latency_WVALID_assertion_to_WREADY_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_qos_from_SystemVerilog
    (
        input bit config_enable_qos_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_qos_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_qos_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_qos_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_region_support_from_SystemVerilog
    (
        input bit config_enable_region_support_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_region_support_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_region_support_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_region_support_from_CY;

    import "DPI-C" context function void axi4_set_config_slave_regions_from_SystemVerilog
    (
        input int config_slave_regions_param
    );
    import "DPI-C" context function void axi4_propagate_config_slave_regions_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_slave_regions_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_slave_regions_from_CY;

    import "DPI-C" context function void axi4_set_config_region_from_SystemVerilog_index2
    (
        input int unsigned _this_dot_1,
        input int unsigned _this_dot_2,
        input bit  config_region_param
    );
    import "DPI-C" context function void axi4_propagate_config_region_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_region_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_region_from_CY_index2;

    import "DPI-C" context function void axi4_get_region_error_state_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_region_error_state_from_CY;

    import "DPI-C" context function void axi4_get_region_map_lb_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_region_map_lb_from_CY_index1;

    import "DPI-C" context function void axi4_get_region_map_ub_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_region_map_ub_from_CY_index1;

    import "DPI-C" context function void axi4_get_region_map_region_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_region_map_region_from_CY_index1;

    import "DPI-C" context function void axi4_get_cacheable_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_cacheable_from_CY_index1;

    import "DPI-C" context function void axi4_set_config_read_data_reordering_depth_from_SystemVerilog
    (
        input int unsigned config_read_data_reordering_depth_param
    );
    import "DPI-C" context function void axi4_propagate_config_read_data_reordering_depth_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_read_data_reordering_depth_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_read_data_reordering_depth_from_CY;

    import "DPI-C" context function void axi4_set_config_slave_start_addr_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input bit  config_slave_start_addr_param
    );
    import "DPI-C" context function void axi4_propagate_config_slave_start_addr_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_slave_start_addr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_slave_start_addr_from_CY_index1;

    import "DPI-C" context function void axi4_set_config_slave_end_addr_from_SystemVerilog_index1
    (
        input int unsigned _this_dot_1,
        input bit  config_slave_end_addr_param
    );
    import "DPI-C" context function void axi4_propagate_config_slave_end_addr_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_slave_end_addr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_slave_end_addr_from_CY_index1;

    import "DPI-C" context function void axi4_set_config_slave_enabled_non_contiguous_address_spaces_from_SystemVerilog
    (
        input int config_slave_enabled_non_contiguous_address_spaces_param
    );
    import "DPI-C" context function void axi4_propagate_config_slave_enabled_non_contiguous_address_spaces_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_slave_enabled_non_contiguous_address_spaces_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_slave_enabled_non_contiguous_address_spaces_from_CY;

    import "DPI-C" context function void axi4_set_config_slave_possess_multiple_non_contiguous_address_spaces_from_SystemVerilog
    (
        input bit config_slave_possess_multiple_non_contiguous_address_spaces_param
    );
    import "DPI-C" context function void axi4_propagate_config_slave_possess_multiple_non_contiguous_address_spaces_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_slave_possess_multiple_non_contiguous_address_spaces_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_slave_possess_multiple_non_contiguous_address_spaces_from_CY;

    import "DPI-C" context function void axi4_set_config_slave_multiple_non_contiguous_start_address_range_from_SystemVerilog_index2
    (
        input int unsigned _this_dot_1,
        input int unsigned _this_dot_2,
        input bit  config_slave_multiple_non_contiguous_start_address_range_param
    );
    import "DPI-C" context function void axi4_propagate_config_slave_multiple_non_contiguous_start_address_range_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_slave_multiple_non_contiguous_start_address_range_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_slave_multiple_non_contiguous_start_address_range_from_CY_index2;

    import "DPI-C" context function void axi4_set_config_slave_multiple_non_contiguous_end_address_range_from_SystemVerilog_index2
    (
        input int unsigned _this_dot_1,
        input int unsigned _this_dot_2,
        input bit  config_slave_multiple_non_contiguous_end_address_range_param
    );
    import "DPI-C" context function void axi4_propagate_config_slave_multiple_non_contiguous_end_address_range_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_slave_multiple_non_contiguous_end_address_range_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_slave_multiple_non_contiguous_end_address_range_from_CY_index2;

    import "DPI-C" context function void axi4_set_config_protect_ready_from_SystemVerilog
    (
        input bit config_protect_ready_param
    );
    import "DPI-C" context function void axi4_propagate_config_protect_ready_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_protect_ready_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_protect_ready_from_CY;

    import "DPI-C" context function void axi4_get_master_end_tlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_master_end_tlm_status_from_CY;

    import "DPI-C" context function void axi4_get_master_end_wlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_master_end_wlm_status_from_CY;

    import "DPI-C" context function void axi4_get_slave_end_tlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_slave_end_tlm_status_from_CY;

    import "DPI-C" context function void axi4_get_slave_end_wlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_slave_end_wlm_status_from_CY;

    import "DPI-C" context function void axi4_get_clock_source_end_tlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_clock_source_end_tlm_status_from_CY;

    import "DPI-C" context function void axi4_get_clock_source_end_wlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_clock_source_end_wlm_status_from_CY;

    import "DPI-C" context function void axi4_get_reset_source_end_tlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_reset_source_end_tlm_status_from_CY;

    import "DPI-C" context function void axi4_get_reset_source_end_wlm_status_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_reset_source_end_wlm_status_from_CY;

    import "DPI-C" context function void axi4_set_config_max_outstanding_wr_from_SystemVerilog
    (
        input int config_max_outstanding_wr_param
    );
    import "DPI-C" context function void axi4_propagate_config_max_outstanding_wr_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_max_outstanding_wr_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_outstanding_wr_from_CY;

    import "DPI-C" context function void axi4_set_config_max_outstanding_rd_from_SystemVerilog
    (
        input int config_max_outstanding_rd_param
    );
    import "DPI-C" context function void axi4_propagate_config_max_outstanding_rd_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_max_outstanding_rd_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_max_outstanding_rd_from_CY;

    import "DPI-C" context function void axi4_set_config_num_outstanding_wr_phase_from_SystemVerilog
    (
        input int config_num_outstanding_wr_phase_param
    );
    import "DPI-C" context function void axi4_propagate_config_num_outstanding_wr_phase_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_num_outstanding_wr_phase_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_num_outstanding_wr_phase_from_CY;

    import "DPI-C" context function void axi4_set_config_num_outstanding_rd_phase_from_SystemVerilog
    (
        input int config_num_outstanding_rd_phase_param
    );
    import "DPI-C" context function void axi4_propagate_config_num_outstanding_rd_phase_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_num_outstanding_rd_phase_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_num_outstanding_rd_phase_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_warnings_from_SystemVerilog
    (
        input bit config_enable_warnings_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_warnings_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_warnings_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_warnings_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_errors_from_SystemVerilog
    (
        input bit config_enable_errors_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_errors_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_errors_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_errors_from_CY;

    import "DPI-C" context function void axi4_set_config_enable_exclusive_checks_from_SystemVerilog
    (
        input bit config_enable_exclusive_checks_param
    );
    import "DPI-C" context function void axi4_propagate_config_enable_exclusive_checks_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_enable_exclusive_checks_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_enable_exclusive_checks_from_CY;

    import "DPI-C" context function void axi4_set_config_warn_on_slave_errors_from_SystemVerilog
    (
        input bit config_warn_on_slave_errors_param
    );
    import "DPI-C" context function void axi4_propagate_config_warn_on_slave_errors_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_warn_on_slave_errors_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_warn_on_slave_errors_from_CY;

    import "DPI-C" context function void axi4_set_config_error_on_deleted_valid_cycles_from_SystemVerilog
    (
        input bit config_error_on_deleted_valid_cycles_param
    );
    import "DPI-C" context function void axi4_propagate_config_error_on_deleted_valid_cycles_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_error_on_deleted_valid_cycles_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_error_on_deleted_valid_cycles_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_from_SystemVerilog
    (
        input bit config_stats_enable_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_read_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_read_occupancy_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_read_occupancy_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_read_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_read_occupancy_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_write_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_write_occupancy_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_write_occupancy_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_write_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_write_occupancy_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_read_data_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_read_data_occupancy_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_read_data_occupancy_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_read_data_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_read_data_occupancy_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_write_data_occupancy_from_SystemVerilog
    (
        input bit config_stats_enable_write_data_occupancy_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_write_data_occupancy_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_write_data_occupancy_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_write_data_occupancy_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_read_latency_from_SystemVerilog
    (
        input bit config_stats_enable_read_latency_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_read_latency_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_read_latency_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_read_latency_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_write_latency_from_SystemVerilog
    (
        input bit config_stats_enable_write_latency_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_write_latency_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_write_latency_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_write_latency_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_read_address_waits_from_SystemVerilog
    (
        input bit config_stats_enable_read_address_waits_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_read_address_waits_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_read_address_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_read_address_waits_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_read_data_waits_from_SystemVerilog
    (
        input bit config_stats_enable_read_data_waits_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_read_data_waits_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_read_data_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_read_data_waits_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_write_address_waits_from_SystemVerilog
    (
        input bit config_stats_enable_write_address_waits_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_write_address_waits_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_write_address_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_write_address_waits_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_write_data_waits_from_SystemVerilog
    (
        input bit config_stats_enable_write_data_waits_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_write_data_waits_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_write_data_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_write_data_waits_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_write_response_waits_from_SystemVerilog
    (
        input bit config_stats_enable_write_response_waits_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_write_response_waits_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_write_response_waits_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_write_response_waits_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_read_bandwidth_from_SystemVerilog
    (
        input bit config_stats_enable_read_bandwidth_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_read_bandwidth_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_read_bandwidth_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_read_bandwidth_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_enable_write_bandwidth_from_SystemVerilog
    (
        input bit config_stats_enable_write_bandwidth_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_enable_write_bandwidth_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_enable_write_bandwidth_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_enable_write_bandwidth_from_CY;

    import "DPI-C" context function void axi4_get_stats_rw_transaction_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_rw_transaction_last_duration_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_occupancy_step_from_SystemVerilog
    (
        input int config_stats_read_occupancy_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_occupancy_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_occupancy_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_read_occupancy_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_occupancy_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_active_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_active_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_occupancy_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_idle_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_occupancy_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_idle_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_occupancy_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_idle_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_occupancy_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_idle_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_last_duration_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_occupancy_step_from_SystemVerilog
    (
        input int config_stats_write_occupancy_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_occupancy_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_occupancy_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_write_occupancy_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_occupancy_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_active_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_active_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_occupancy_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_idle_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_occupancy_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_idle_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_occupancy_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_idle_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_occupancy_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_idle_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_last_duration_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_last_duration_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_data_occupancy_step_from_SystemVerilog
    (
        input int config_stats_read_data_occupancy_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_data_occupancy_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_data_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_data_occupancy_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_read_data_occupancy_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_data_occupancy_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_data_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_data_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_occupancy_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_idle_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_occupancy_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_idle_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_occupancy_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_idle_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_occupancy_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_idle_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_data_occupancy_step_from_SystemVerilog
    (
        input int config_stats_write_data_occupancy_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_data_occupancy_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_data_occupancy_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_data_occupancy_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog
    (
        input int config_stats_write_data_occupancy_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_data_occupancy_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_data_occupancy_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_data_occupancy_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_occupancy_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_occupancy_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_idle_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_idle_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_occupancy_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_occupancy_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_idle_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_idle_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_occupancy_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_occupancy_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_idle_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_idle_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_occupancy_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_occupancy_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_idle_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_idle_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_bandwidth_step_from_SystemVerilog
    (
        input int config_stats_read_bandwidth_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_bandwidth_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_bandwidth_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_bandwidth_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_bandwidth_multiple_from_SystemVerilog
    (
        input int config_stats_read_bandwidth_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_bandwidth_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_bandwidth_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_bandwidth_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_bandwidth_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_bandwidth_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_bandwidth_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_bandwidth_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_bandwidth_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_bandwidth_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_bandwidth_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_bandwidth_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_bandwidth_step_from_SystemVerilog
    (
        input int config_stats_write_bandwidth_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_bandwidth_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_bandwidth_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_bandwidth_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_bandwidth_multiple_from_SystemVerilog
    (
        input int config_stats_write_bandwidth_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_bandwidth_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_bandwidth_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_bandwidth_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_bandwidth_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_bandwidth_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_bandwidth_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_bandwidth_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_bandwidth_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_bandwidth_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_bandwidth_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_bandwidth_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_latency_step_from_SystemVerilog
    (
        input int config_stats_read_latency_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_latency_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_latency_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_latency_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_latency_multiple_from_SystemVerilog
    (
        input int config_stats_read_latency_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_latency_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_latency_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_latency_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_data_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_data_latency_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_data_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_data_latency_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_data_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_data_latency_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_data_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_data_latency_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_data_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_data_latency_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_address_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_address_latency_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_address_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_address_latency_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_address_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_address_latency_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_address_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_address_latency_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_address_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_address_latency_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_latency_step_from_SystemVerilog
    (
        input int config_stats_write_latency_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_latency_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_latency_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_latency_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_latency_multiple_from_SystemVerilog
    (
        input int config_stats_write_latency_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_latency_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_latency_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_latency_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_response_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_response_latency_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_response_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_response_latency_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_response_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_response_latency_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_response_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_response_latency_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_response_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_response_latency_mean_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_address_latency_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_address_latency_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_address_latency_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_address_latency_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_address_latency_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_address_latency_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_address_latency_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_address_latency_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_address_latency_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_address_latency_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_address_waits_step_from_SystemVerilog
    (
        input int config_stats_read_address_waits_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_address_waits_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_address_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_address_waits_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_address_waits_multiple_from_SystemVerilog
    (
        input int config_stats_read_address_waits_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_address_waits_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_address_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_address_waits_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_waits_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_waits_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_waits_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_waits_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_address_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_address_waits_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_data_waits_step_from_SystemVerilog
    (
        input int config_stats_read_data_waits_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_data_waits_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_data_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_data_waits_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_read_data_waits_multiple_from_SystemVerilog
    (
        input int config_stats_read_data_waits_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_read_data_waits_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_read_data_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_read_data_waits_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_waits_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_waits_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_waits_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_waits_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_read_data_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_read_data_waits_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_address_waits_step_from_SystemVerilog
    (
        input int config_stats_write_address_waits_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_address_waits_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_address_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_address_waits_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_address_waits_multiple_from_SystemVerilog
    (
        input int config_stats_write_address_waits_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_address_waits_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_address_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_address_waits_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_waits_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_waits_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_waits_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_waits_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_address_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_address_waits_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_data_waits_step_from_SystemVerilog
    (
        input int config_stats_write_data_waits_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_data_waits_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_data_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_data_waits_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_data_waits_multiple_from_SystemVerilog
    (
        input int config_stats_write_data_waits_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_data_waits_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_data_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_data_waits_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_waits_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_waits_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_waits_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_waits_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_data_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_data_waits_mean_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_response_waits_step_from_SystemVerilog
    (
        input int config_stats_write_response_waits_step_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_response_waits_step_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_response_waits_step_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_response_waits_step_from_CY;

    import "DPI-C" context function void axi4_set_config_stats_write_response_waits_multiple_from_SystemVerilog
    (
        input int config_stats_write_response_waits_multiple_param
    );
    import "DPI-C" context function void axi4_propagate_config_stats_write_response_waits_multiple_from_SystemVerilog
    (
    );
    import "DPI-C" context function void axi4_get_config_stats_write_response_waits_multiple_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_config_stats_write_response_waits_multiple_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_response_waits_inst_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_response_waits_inst_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_response_waits_sw_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_response_waits_sw_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_response_waits_min_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_response_waits_min_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_response_waits_max_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_response_waits_max_from_CY;

    import "DPI-C" context function void axi4_get_stats_write_response_waits_mean_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_stats_write_response_waits_mean_from_CY;

    import "DPI-C" context function void axi4_get_reordering_depth_of_last_read_transaction_into_SystemVerilog
    (

    );
    export "DPI-C" function axi4_set_reordering_depth_of_last_read_transaction_from_CY;

    function void axi4_set_ACLK_from_CY( bit ACLK_param );
        internal_ACLK = ACLK_param;
    endfunction

    function void axi4_initialise_ACLK_from_CY();
        internal_ACLK = 'z;
        m_ACLK = 'z;
    endfunction

    function void axi4_set_ARESETn_from_CY( logic ARESETn_param );
        internal_ARESETn = ARESETn_param;
    endfunction

    function void axi4_initialise_ARESETn_from_CY();
        internal_ARESETn = 'z;
        m_ARESETn = 'z;
    endfunction

    function void axi4_set_AWVALID_from_CY( logic AWVALID_param );
        internal_AWVALID = AWVALID_param;
    endfunction

    function void axi4_initialise_AWVALID_from_CY();
        internal_AWVALID = 'z;
        m_AWVALID = 'z;
    endfunction

    function void axi4_set_AWADDR_from_CY_index1( int _this_dot_1, logic  AWADDR_param );
        internal_AWADDR[_this_dot_1] = AWADDR_param;
    endfunction

    function void axi4_initialise_AWADDR_from_CY();
        internal_AWADDR = 'z;
        m_AWADDR = 'z;
    endfunction

    function void axi4_set_AWPROT_from_CY( logic [2:0] AWPROT_param );
        internal_AWPROT = AWPROT_param;
    endfunction

    function void axi4_initialise_AWPROT_from_CY();
        internal_AWPROT = 'z;
        m_AWPROT = 'z;
    endfunction

    function void axi4_set_AWREGION_from_CY( logic [3:0] AWREGION_param );
        internal_AWREGION = AWREGION_param;
    endfunction

    function void axi4_initialise_AWREGION_from_CY();
        internal_AWREGION = 'z;
        m_AWREGION = 'z;
    endfunction

    function void axi4_set_AWLEN_from_CY( logic [7:0] AWLEN_param );
        internal_AWLEN = AWLEN_param;
    endfunction

    function void axi4_initialise_AWLEN_from_CY();
        internal_AWLEN = 'z;
        m_AWLEN = 'z;
    endfunction

    function void axi4_set_AWSIZE_from_CY( logic [2:0] AWSIZE_param );
        internal_AWSIZE = AWSIZE_param;
    endfunction

    function void axi4_initialise_AWSIZE_from_CY();
        internal_AWSIZE = 'z;
        m_AWSIZE = 'z;
    endfunction

    function void axi4_set_AWBURST_from_CY( logic [1:0] AWBURST_param );
        internal_AWBURST = AWBURST_param;
    endfunction

    function void axi4_initialise_AWBURST_from_CY();
        internal_AWBURST = 'z;
        m_AWBURST = 'z;
    endfunction

    function void axi4_set_AWLOCK_from_CY( logic AWLOCK_param );
        internal_AWLOCK = AWLOCK_param;
    endfunction

    function void axi4_initialise_AWLOCK_from_CY();
        internal_AWLOCK = 'z;
        m_AWLOCK = 'z;
    endfunction

    function void axi4_set_AWCACHE_from_CY( logic [3:0] AWCACHE_param );
        internal_AWCACHE = AWCACHE_param;
    endfunction

    function void axi4_initialise_AWCACHE_from_CY();
        internal_AWCACHE = 'z;
        m_AWCACHE = 'z;
    endfunction

    function void axi4_set_AWQOS_from_CY( logic [3:0] AWQOS_param );
        internal_AWQOS = AWQOS_param;
    endfunction

    function void axi4_initialise_AWQOS_from_CY();
        internal_AWQOS = 'z;
        m_AWQOS = 'z;
    endfunction

    function void axi4_set_AWID_from_CY_index1( int _this_dot_1, logic  AWID_param );
        internal_AWID[_this_dot_1] = AWID_param;
    endfunction

    function void axi4_initialise_AWID_from_CY();
        internal_AWID = 'z;
        m_AWID = 'z;
    endfunction

    function void axi4_set_AWUSER_from_CY_index1( int _this_dot_1, logic  AWUSER_param );
        internal_AWUSER[_this_dot_1] = AWUSER_param;
    endfunction

    function void axi4_initialise_AWUSER_from_CY();
        internal_AWUSER = 'z;
        m_AWUSER = 'z;
    endfunction

    function void axi4_set_AWREADY_from_CY( logic AWREADY_param );
        internal_AWREADY = AWREADY_param;
    endfunction

    function void axi4_initialise_AWREADY_from_CY();
        internal_AWREADY = 'z;
        m_AWREADY = 'z;
    endfunction

    function void axi4_set_ARVALID_from_CY( logic ARVALID_param );
        internal_ARVALID = ARVALID_param;
    endfunction

    function void axi4_initialise_ARVALID_from_CY();
        internal_ARVALID = 'z;
        m_ARVALID = 'z;
    endfunction

    function void axi4_set_ARADDR_from_CY_index1( int _this_dot_1, logic  ARADDR_param );
        internal_ARADDR[_this_dot_1] = ARADDR_param;
    endfunction

    function void axi4_initialise_ARADDR_from_CY();
        internal_ARADDR = 'z;
        m_ARADDR = 'z;
    endfunction

    function void axi4_set_ARPROT_from_CY( logic [2:0] ARPROT_param );
        internal_ARPROT = ARPROT_param;
    endfunction

    function void axi4_initialise_ARPROT_from_CY();
        internal_ARPROT = 'z;
        m_ARPROT = 'z;
    endfunction

    function void axi4_set_ARREGION_from_CY( logic [3:0] ARREGION_param );
        internal_ARREGION = ARREGION_param;
    endfunction

    function void axi4_initialise_ARREGION_from_CY();
        internal_ARREGION = 'z;
        m_ARREGION = 'z;
    endfunction

    function void axi4_set_ARLEN_from_CY( logic [7:0] ARLEN_param );
        internal_ARLEN = ARLEN_param;
    endfunction

    function void axi4_initialise_ARLEN_from_CY();
        internal_ARLEN = 'z;
        m_ARLEN = 'z;
    endfunction

    function void axi4_set_ARSIZE_from_CY( logic [2:0] ARSIZE_param );
        internal_ARSIZE = ARSIZE_param;
    endfunction

    function void axi4_initialise_ARSIZE_from_CY();
        internal_ARSIZE = 'z;
        m_ARSIZE = 'z;
    endfunction

    function void axi4_set_ARBURST_from_CY( logic [1:0] ARBURST_param );
        internal_ARBURST = ARBURST_param;
    endfunction

    function void axi4_initialise_ARBURST_from_CY();
        internal_ARBURST = 'z;
        m_ARBURST = 'z;
    endfunction

    function void axi4_set_ARLOCK_from_CY( logic ARLOCK_param );
        internal_ARLOCK = ARLOCK_param;
    endfunction

    function void axi4_initialise_ARLOCK_from_CY();
        internal_ARLOCK = 'z;
        m_ARLOCK = 'z;
    endfunction

    function void axi4_set_ARCACHE_from_CY( logic [3:0] ARCACHE_param );
        internal_ARCACHE = ARCACHE_param;
    endfunction

    function void axi4_initialise_ARCACHE_from_CY();
        internal_ARCACHE = 'z;
        m_ARCACHE = 'z;
    endfunction

    function void axi4_set_ARQOS_from_CY( logic [3:0] ARQOS_param );
        internal_ARQOS = ARQOS_param;
    endfunction

    function void axi4_initialise_ARQOS_from_CY();
        internal_ARQOS = 'z;
        m_ARQOS = 'z;
    endfunction

    function void axi4_set_ARID_from_CY_index1( int _this_dot_1, logic  ARID_param );
        internal_ARID[_this_dot_1] = ARID_param;
    endfunction

    function void axi4_initialise_ARID_from_CY();
        internal_ARID = 'z;
        m_ARID = 'z;
    endfunction

    function void axi4_set_ARUSER_from_CY_index1( int _this_dot_1, logic  ARUSER_param );
        internal_ARUSER[_this_dot_1] = ARUSER_param;
    endfunction

    function void axi4_initialise_ARUSER_from_CY();
        internal_ARUSER = 'z;
        m_ARUSER = 'z;
    endfunction

    function void axi4_set_ARREADY_from_CY( logic ARREADY_param );
        internal_ARREADY = ARREADY_param;
    endfunction

    function void axi4_initialise_ARREADY_from_CY();
        internal_ARREADY = 'z;
        m_ARREADY = 'z;
    endfunction

    function void axi4_set_RVALID_from_CY( logic RVALID_param );
        internal_RVALID = RVALID_param;
    endfunction

    function void axi4_initialise_RVALID_from_CY();
        internal_RVALID = 'z;
        m_RVALID = 'z;
    endfunction

    function void axi4_set_RDATA_from_CY_index1( int _this_dot_1, logic  RDATA_param );
        internal_RDATA[_this_dot_1] = RDATA_param;
    endfunction

    function void axi4_initialise_RDATA_from_CY();
        internal_RDATA = 'z;
        m_RDATA = 'z;
    endfunction

    function void axi4_set_RRESP_from_CY( logic [1:0] RRESP_param );
        internal_RRESP = RRESP_param;
    endfunction

    function void axi4_initialise_RRESP_from_CY();
        internal_RRESP = 'z;
        m_RRESP = 'z;
    endfunction

    function void axi4_set_RLAST_from_CY( logic RLAST_param );
        internal_RLAST = RLAST_param;
    endfunction

    function void axi4_initialise_RLAST_from_CY();
        internal_RLAST = 'z;
        m_RLAST = 'z;
    endfunction

    function void axi4_set_RID_from_CY_index1( int _this_dot_1, logic  RID_param );
        internal_RID[_this_dot_1] = RID_param;
    endfunction

    function void axi4_initialise_RID_from_CY();
        internal_RID = 'z;
        m_RID = 'z;
    endfunction

    function void axi4_set_RUSER_from_CY_index1( int _this_dot_1, logic  RUSER_param );
        internal_RUSER[_this_dot_1] = RUSER_param;
    endfunction

    function void axi4_initialise_RUSER_from_CY();
        internal_RUSER = 'z;
        m_RUSER = 'z;
    endfunction

    function void axi4_set_RREADY_from_CY( logic RREADY_param );
        internal_RREADY = RREADY_param;
    endfunction

    function void axi4_initialise_RREADY_from_CY();
        internal_RREADY = 'z;
        m_RREADY = 'z;
    endfunction

    function void axi4_set_WVALID_from_CY( logic WVALID_param );
        internal_WVALID = WVALID_param;
    endfunction

    function void axi4_initialise_WVALID_from_CY();
        internal_WVALID = 'z;
        m_WVALID = 'z;
    endfunction

    function void axi4_set_WDATA_from_CY_index1( int _this_dot_1, logic  WDATA_param );
        internal_WDATA[_this_dot_1] = WDATA_param;
    endfunction

    function void axi4_initialise_WDATA_from_CY();
        internal_WDATA = 'z;
        m_WDATA = 'z;
    endfunction

    function void axi4_set_WSTRB_from_CY_index1( int _this_dot_1, logic  WSTRB_param );
        internal_WSTRB[_this_dot_1] = WSTRB_param;
    endfunction

    function void axi4_initialise_WSTRB_from_CY();
        internal_WSTRB = 'z;
        m_WSTRB = 'z;
    endfunction

    function void axi4_set_WLAST_from_CY( logic WLAST_param );
        internal_WLAST = WLAST_param;
    endfunction

    function void axi4_initialise_WLAST_from_CY();
        internal_WLAST = 'z;
        m_WLAST = 'z;
    endfunction

    function void axi4_set_WUSER_from_CY_index1( int _this_dot_1, logic  WUSER_param );
        internal_WUSER[_this_dot_1] = WUSER_param;
    endfunction

    function void axi4_initialise_WUSER_from_CY();
        internal_WUSER = 'z;
        m_WUSER = 'z;
    endfunction

    function void axi4_set_WREADY_from_CY( logic WREADY_param );
        internal_WREADY = WREADY_param;
    endfunction

    function void axi4_initialise_WREADY_from_CY();
        internal_WREADY = 'z;
        m_WREADY = 'z;
    endfunction

    function void axi4_set_BVALID_from_CY( logic BVALID_param );
        internal_BVALID = BVALID_param;
    endfunction

    function void axi4_initialise_BVALID_from_CY();
        internal_BVALID = 'z;
        m_BVALID = 'z;
    endfunction

    function void axi4_set_BRESP_from_CY( logic [1:0] BRESP_param );
        internal_BRESP = BRESP_param;
    endfunction

    function void axi4_initialise_BRESP_from_CY();
        internal_BRESP = 'z;
        m_BRESP = 'z;
    endfunction

    function void axi4_set_BID_from_CY_index1( int _this_dot_1, logic  BID_param );
        internal_BID[_this_dot_1] = BID_param;
    endfunction

    function void axi4_initialise_BID_from_CY();
        internal_BID = 'z;
        m_BID = 'z;
    endfunction

    function void axi4_set_BUSER_from_CY_index1( int _this_dot_1, logic  BUSER_param );
        internal_BUSER[_this_dot_1] = BUSER_param;
    endfunction

    function void axi4_initialise_BUSER_from_CY();
        internal_BUSER = 'z;
        m_BUSER = 'z;
    endfunction

    function void axi4_set_BREADY_from_CY( logic BREADY_param );
        internal_BREADY = BREADY_param;
    endfunction

    function void axi4_initialise_BREADY_from_CY();
        internal_BREADY = 'z;
        m_BREADY = 'z;
    endfunction

    function void axi4_set_config_interface_type_from_CY(     int config_interface_type_param);
        config_interface_type = axi4_interface_type_e'( config_interface_type_param );
    endfunction

    function void axi4_set_config_clk_init_value_from_CY( bit config_clk_init_value_param );
        config_clk_init_value = config_clk_init_value_param;
    endfunction

    function void axi4_set_config_clk_phase_shift_from_CY( longint unsigned config_clk_phase_shift_param );
        config_clk_phase_shift = config_clk_phase_shift_param;
    endfunction

    function void axi4_set_config_clk_1st_time_from_CY( longint unsigned config_clk_1st_time_param );
        config_clk_1st_time = config_clk_1st_time_param;
    endfunction

    function void axi4_set_config_clk_2nd_time_from_CY( longint unsigned config_clk_2nd_time_param );
        config_clk_2nd_time = config_clk_2nd_time_param;
    endfunction

    function void axi4_set_config_setup_time_from_CY( longint unsigned config_setup_time_param );
        config_setup_time = config_setup_time_param;
    endfunction

    function void axi4_set_config_hold_time_from_CY( longint unsigned config_hold_time_param );
        config_hold_time = config_hold_time_param;
    endfunction

    function void axi4_set_config_burst_timeout_factor_from_CY( int unsigned config_burst_timeout_factor_param );
        config_burst_timeout_factor = config_burst_timeout_factor_param;
    endfunction

    function void axi4_set_config_max_transaction_time_factor_from_CY( int unsigned config_max_transaction_time_factor_param );
        config_max_transaction_time_factor = config_max_transaction_time_factor_param;
    endfunction

    function void axi4_set_config_write_ctrl_first_ratio_from_CY( int config_write_ctrl_first_ratio_param );
        config_write_ctrl_first_ratio = config_write_ctrl_first_ratio_param;
    endfunction

    function void axi4_set_config_write_data_first_ratio_from_CY( int config_write_data_first_ratio_param );
        config_write_data_first_ratio = config_write_data_first_ratio_param;
    endfunction

    function void axi4_set_config_reset_low_clocks_from_CY( int config_reset_low_clocks_param );
        config_reset_low_clocks = config_reset_low_clocks_param;
    endfunction

    function void axi4_set_config_reset_hold_time_from_CY( int config_reset_hold_time_param );
        config_reset_hold_time = config_reset_hold_time_param;
    endfunction

    function void axi4_set_config_enable_rlast_from_CY( bit config_enable_rlast_param );
        config_enable_rlast = config_enable_rlast_param;
    endfunction

    function void axi4_set_config_enable_slave_exclusive_from_CY( bit config_enable_slave_exclusive_param );
        config_enable_slave_exclusive = config_enable_slave_exclusive_param;
    endfunction

    function void axi4_set_config_enable_burst_reserved_value_from_CY( bit config_enable_burst_reserved_value_param );
        config_enable_burst_reserved_value = config_enable_burst_reserved_value_param;
    endfunction

    function void axi4_set_config_enable_cache_value_from_CY( bit [15:0] config_enable_cache_value_param );
        config_enable_cache_value = config_enable_cache_value_param;
    endfunction

    function void axi4_set_internal_dummy_variable_from_CY(     int internal_dummy_variable_param);
        internal_dummy_variable = axi4_error_e'( internal_dummy_variable_param );
    endfunction

    function void axi4_set_config_axi4lite_interface_from_CY( bit config_axi4lite_interface_param );
        config_axi4lite_interface = config_axi4lite_interface_param;
    endfunction

    function void axi4_set_config_axi4lite_tr_id_from_CY_index1( int _this_dot_1, bit  config_axi4lite_tr_id_param );
        config_axi4lite_tr_id[_this_dot_1] = config_axi4lite_tr_id_param;
    endfunction

    function void axi4_set_config_enable_all_assertions_from_CY( bit config_enable_all_assertions_param );
        config_enable_all_assertions = config_enable_all_assertions_param;
    endfunction

    function void axi4_set_config_enable_assertion_from_CY( bit [255:0] config_enable_assertion_param );
        config_enable_assertion = config_enable_assertion_param;
    endfunction

    function void axi4_set_config_enable_error_from_CY( bit [255:0] config_enable_error_param );
        config_enable_error = config_enable_error_param;
    endfunction

    function void axi4_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_CY( int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
        config_max_latency_AWVALID_assertion_to_AWREADY = config_max_latency_AWVALID_assertion_to_AWREADY_param;
    endfunction

    function void axi4_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_CY( int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
        config_max_latency_ARVALID_assertion_to_ARREADY = config_max_latency_ARVALID_assertion_to_ARREADY_param;
    endfunction

    function void axi4_set_config_max_latency_RVALID_assertion_to_RREADY_from_CY( int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
        config_max_latency_RVALID_assertion_to_RREADY = config_max_latency_RVALID_assertion_to_RREADY_param;
    endfunction

    function void axi4_set_config_max_latency_BVALID_assertion_to_BREADY_from_CY( int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
        config_max_latency_BVALID_assertion_to_BREADY = config_max_latency_BVALID_assertion_to_BREADY_param;
    endfunction

    function void axi4_set_config_max_latency_WVALID_assertion_to_WREADY_from_CY( int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
        config_max_latency_WVALID_assertion_to_WREADY = config_max_latency_WVALID_assertion_to_WREADY_param;
    endfunction

    function void axi4_set_config_enable_qos_from_CY( bit config_enable_qos_param );
        config_enable_qos = config_enable_qos_param;
    endfunction

    function void axi4_set_config_enable_region_support_from_CY( bit config_enable_region_support_param );
        config_enable_region_support = config_enable_region_support_param;
    endfunction

    function void axi4_set_config_slave_regions_from_CY( int config_slave_regions_param );
        config_slave_regions = config_slave_regions_param;
    endfunction

    function void axi4_set_config_region_from_CY_index2( int _this_dot_1, int _this_dot_2, bit  config_region_param );
        config_region[_this_dot_1][_this_dot_2] = config_region_param;
    endfunction

    function void axi4_set_region_error_state_from_CY( bit region_error_state_param );
        region_error_state = region_error_state_param;
    endfunction

    function void axi4_set_region_map_lb_from_CY_index1( int _this_dot_1, longint unsigned region_map_lb_param );
        region_map_lb[_this_dot_1] = region_map_lb_param;
    endfunction

    function void axi4_set_region_map_ub_from_CY_index1( int _this_dot_1, longint unsigned region_map_ub_param );
        region_map_ub[_this_dot_1] = region_map_ub_param;
    endfunction

    function void axi4_set_region_map_region_from_CY_index1( int _this_dot_1, byte unsigned region_map_region_param );
        region_map_region[_this_dot_1] = region_map_region_param;
    endfunction

    function void axi4_set_cacheable_from_CY_index1( int _this_dot_1, byte unsigned cacheable_param );
        cacheable[_this_dot_1] = cacheable_param;
    endfunction

    function void axi4_set_config_read_data_reordering_depth_from_CY( int unsigned config_read_data_reordering_depth_param );
        config_read_data_reordering_depth = config_read_data_reordering_depth_param;
    endfunction

    function void axi4_set_config_slave_start_addr_from_CY_index1( int _this_dot_1, bit  config_slave_start_addr_param );
        config_slave_start_addr[_this_dot_1] = config_slave_start_addr_param;
    endfunction

    function void axi4_set_config_slave_end_addr_from_CY_index1( int _this_dot_1, bit  config_slave_end_addr_param );
        config_slave_end_addr[_this_dot_1] = config_slave_end_addr_param;
    endfunction

    function void axi4_set_config_slave_enabled_non_contiguous_address_spaces_from_CY( int config_slave_enabled_non_contiguous_address_spaces_param );
        config_slave_enabled_non_contiguous_address_spaces = config_slave_enabled_non_contiguous_address_spaces_param;
    endfunction

    function void axi4_set_config_slave_possess_multiple_non_contiguous_address_spaces_from_CY( bit config_slave_possess_multiple_non_contiguous_address_spaces_param );
        config_slave_possess_multiple_non_contiguous_address_spaces = config_slave_possess_multiple_non_contiguous_address_spaces_param;
    endfunction

    function void axi4_set_config_slave_multiple_non_contiguous_start_address_range_from_CY_index2( int _this_dot_1, int _this_dot_2, bit  config_slave_multiple_non_contiguous_start_address_range_param );
        config_slave_multiple_non_contiguous_start_address_range[_this_dot_1][_this_dot_2] = config_slave_multiple_non_contiguous_start_address_range_param;
    endfunction

    function void axi4_set_config_slave_multiple_non_contiguous_end_address_range_from_CY_index2( int _this_dot_1, int _this_dot_2, bit  config_slave_multiple_non_contiguous_end_address_range_param );
        config_slave_multiple_non_contiguous_end_address_range[_this_dot_1][_this_dot_2] = config_slave_multiple_non_contiguous_end_address_range_param;
    endfunction

    function void axi4_set_config_protect_ready_from_CY( bit config_protect_ready_param );
        config_protect_ready = config_protect_ready_param;
    endfunction

    function void axi4_set_master_end_tlm_status_from_CY( bit master_end_tlm_status_param );
        master_end_tlm_status = master_end_tlm_status_param;
    endfunction

    function void axi4_set_master_end_wlm_status_from_CY( bit master_end_wlm_status_param );
        master_end_wlm_status = master_end_wlm_status_param;
    endfunction

    function void axi4_set_slave_end_tlm_status_from_CY( bit slave_end_tlm_status_param );
        slave_end_tlm_status = slave_end_tlm_status_param;
    endfunction

    function void axi4_set_slave_end_wlm_status_from_CY( bit slave_end_wlm_status_param );
        slave_end_wlm_status = slave_end_wlm_status_param;
    endfunction

    function void axi4_set_clock_source_end_tlm_status_from_CY( bit clock_source_end_tlm_status_param );
        clock_source_end_tlm_status = clock_source_end_tlm_status_param;
    endfunction

    function void axi4_set_clock_source_end_wlm_status_from_CY( bit clock_source_end_wlm_status_param );
        clock_source_end_wlm_status = clock_source_end_wlm_status_param;
    endfunction

    function void axi4_set_reset_source_end_tlm_status_from_CY( bit reset_source_end_tlm_status_param );
        reset_source_end_tlm_status = reset_source_end_tlm_status_param;
    endfunction

    function void axi4_set_reset_source_end_wlm_status_from_CY( bit reset_source_end_wlm_status_param );
        reset_source_end_wlm_status = reset_source_end_wlm_status_param;
    endfunction

    function void axi4_set_config_max_outstanding_wr_from_CY( int config_max_outstanding_wr_param );
        config_max_outstanding_wr = config_max_outstanding_wr_param;
    endfunction

    function void axi4_set_config_max_outstanding_rd_from_CY( int config_max_outstanding_rd_param );
        config_max_outstanding_rd = config_max_outstanding_rd_param;
    endfunction

    function void axi4_set_config_num_outstanding_wr_phase_from_CY( int config_num_outstanding_wr_phase_param );
        config_num_outstanding_wr_phase = config_num_outstanding_wr_phase_param;
    endfunction

    function void axi4_set_config_num_outstanding_rd_phase_from_CY( int config_num_outstanding_rd_phase_param );
        config_num_outstanding_rd_phase = config_num_outstanding_rd_phase_param;
    endfunction

    function void axi4_set_config_enable_warnings_from_CY( bit config_enable_warnings_param );
        config_enable_warnings = config_enable_warnings_param;
    endfunction

    function void axi4_set_config_enable_errors_from_CY( bit config_enable_errors_param );
        config_enable_errors = config_enable_errors_param;
    endfunction

    function void axi4_set_config_enable_exclusive_checks_from_CY( bit config_enable_exclusive_checks_param );
        config_enable_exclusive_checks = config_enable_exclusive_checks_param;
    endfunction

    function void axi4_set_config_warn_on_slave_errors_from_CY( bit config_warn_on_slave_errors_param );
        config_warn_on_slave_errors = config_warn_on_slave_errors_param;
    endfunction

    function void axi4_set_config_error_on_deleted_valid_cycles_from_CY( bit config_error_on_deleted_valid_cycles_param );
        config_error_on_deleted_valid_cycles = config_error_on_deleted_valid_cycles_param;
    endfunction

    function void axi4_set_config_stats_enable_from_CY( bit config_stats_enable_param );
        config_stats_enable = config_stats_enable_param;
    endfunction

    function void axi4_set_config_stats_enable_read_occupancy_from_CY( bit config_stats_enable_read_occupancy_param );
        config_stats_enable_read_occupancy = config_stats_enable_read_occupancy_param;
    endfunction

    function void axi4_set_config_stats_enable_write_occupancy_from_CY( bit config_stats_enable_write_occupancy_param );
        config_stats_enable_write_occupancy = config_stats_enable_write_occupancy_param;
    endfunction

    function void axi4_set_config_stats_enable_read_data_occupancy_from_CY( bit config_stats_enable_read_data_occupancy_param );
        config_stats_enable_read_data_occupancy = config_stats_enable_read_data_occupancy_param;
    endfunction

    function void axi4_set_config_stats_enable_write_data_occupancy_from_CY( bit config_stats_enable_write_data_occupancy_param );
        config_stats_enable_write_data_occupancy = config_stats_enable_write_data_occupancy_param;
    endfunction

    function void axi4_set_config_stats_enable_read_latency_from_CY( bit config_stats_enable_read_latency_param );
        config_stats_enable_read_latency = config_stats_enable_read_latency_param;
    endfunction

    function void axi4_set_config_stats_enable_write_latency_from_CY( bit config_stats_enable_write_latency_param );
        config_stats_enable_write_latency = config_stats_enable_write_latency_param;
    endfunction

    function void axi4_set_config_stats_enable_read_address_waits_from_CY( bit config_stats_enable_read_address_waits_param );
        config_stats_enable_read_address_waits = config_stats_enable_read_address_waits_param;
    endfunction

    function void axi4_set_config_stats_enable_read_data_waits_from_CY( bit config_stats_enable_read_data_waits_param );
        config_stats_enable_read_data_waits = config_stats_enable_read_data_waits_param;
    endfunction

    function void axi4_set_config_stats_enable_write_address_waits_from_CY( bit config_stats_enable_write_address_waits_param );
        config_stats_enable_write_address_waits = config_stats_enable_write_address_waits_param;
    endfunction

    function void axi4_set_config_stats_enable_write_data_waits_from_CY( bit config_stats_enable_write_data_waits_param );
        config_stats_enable_write_data_waits = config_stats_enable_write_data_waits_param;
    endfunction

    function void axi4_set_config_stats_enable_write_response_waits_from_CY( bit config_stats_enable_write_response_waits_param );
        config_stats_enable_write_response_waits = config_stats_enable_write_response_waits_param;
    endfunction

    function void axi4_set_config_stats_enable_read_bandwidth_from_CY( bit config_stats_enable_read_bandwidth_param );
        config_stats_enable_read_bandwidth = config_stats_enable_read_bandwidth_param;
    endfunction

    function void axi4_set_config_stats_enable_write_bandwidth_from_CY( bit config_stats_enable_write_bandwidth_param );
        config_stats_enable_write_bandwidth = config_stats_enable_write_bandwidth_param;
    endfunction

    function void axi4_set_stats_rw_transaction_last_duration_from_CY( int stats_rw_transaction_last_duration_param );
        stats_rw_transaction_last_duration = stats_rw_transaction_last_duration_param;
    endfunction

    function void axi4_set_config_stats_read_occupancy_step_from_CY( int config_stats_read_occupancy_step_param );
        config_stats_read_occupancy_step = config_stats_read_occupancy_step_param;
    endfunction

    function void axi4_set_config_stats_read_occupancy_multiple_from_CY( int config_stats_read_occupancy_multiple_param );
        config_stats_read_occupancy_multiple = config_stats_read_occupancy_multiple_param;
    endfunction

    function void axi4_set_stats_read_active_from_CY( bit stats_read_active_param );
        stats_read_active = stats_read_active_param;
    endfunction

    function void axi4_set_stats_read_occupancy_sw_from_CY( int stats_read_occupancy_sw_param );
        stats_read_occupancy_sw = stats_read_occupancy_sw_param;
    endfunction

    function void axi4_set_stats_read_idle_sw_from_CY( int stats_read_idle_sw_param );
        stats_read_idle_sw = stats_read_idle_sw_param;
    endfunction

    function void axi4_set_stats_read_occupancy_min_from_CY( int stats_read_occupancy_min_param );
        stats_read_occupancy_min = stats_read_occupancy_min_param;
    endfunction

    function void axi4_set_stats_read_idle_min_from_CY( int stats_read_idle_min_param );
        stats_read_idle_min = stats_read_idle_min_param;
    endfunction

    function void axi4_set_stats_read_occupancy_max_from_CY( int stats_read_occupancy_max_param );
        stats_read_occupancy_max = stats_read_occupancy_max_param;
    endfunction

    function void axi4_set_stats_read_idle_max_from_CY( int stats_read_idle_max_param );
        stats_read_idle_max = stats_read_idle_max_param;
    endfunction

    function void axi4_set_stats_read_occupancy_mean_from_CY( int stats_read_occupancy_mean_param );
        stats_read_occupancy_mean = stats_read_occupancy_mean_param;
    endfunction

    function void axi4_set_stats_read_idle_mean_from_CY( int stats_read_idle_mean_param );
        stats_read_idle_mean = stats_read_idle_mean_param;
    endfunction

    function void axi4_set_stats_read_last_duration_from_CY( int stats_read_last_duration_param );
        stats_read_last_duration = stats_read_last_duration_param;
    endfunction

    function void axi4_set_config_stats_write_occupancy_step_from_CY( int config_stats_write_occupancy_step_param );
        config_stats_write_occupancy_step = config_stats_write_occupancy_step_param;
    endfunction

    function void axi4_set_config_stats_write_occupancy_multiple_from_CY( int config_stats_write_occupancy_multiple_param );
        config_stats_write_occupancy_multiple = config_stats_write_occupancy_multiple_param;
    endfunction

    function void axi4_set_stats_write_active_from_CY( bit stats_write_active_param );
        stats_write_active = stats_write_active_param;
    endfunction

    function void axi4_set_stats_write_occupancy_sw_from_CY( int stats_write_occupancy_sw_param );
        stats_write_occupancy_sw = stats_write_occupancy_sw_param;
    endfunction

    function void axi4_set_stats_write_idle_sw_from_CY( int stats_write_idle_sw_param );
        stats_write_idle_sw = stats_write_idle_sw_param;
    endfunction

    function void axi4_set_stats_write_occupancy_min_from_CY( int stats_write_occupancy_min_param );
        stats_write_occupancy_min = stats_write_occupancy_min_param;
    endfunction

    function void axi4_set_stats_write_idle_min_from_CY( int stats_write_idle_min_param );
        stats_write_idle_min = stats_write_idle_min_param;
    endfunction

    function void axi4_set_stats_write_occupancy_max_from_CY( int stats_write_occupancy_max_param );
        stats_write_occupancy_max = stats_write_occupancy_max_param;
    endfunction

    function void axi4_set_stats_write_idle_max_from_CY( int stats_write_idle_max_param );
        stats_write_idle_max = stats_write_idle_max_param;
    endfunction

    function void axi4_set_stats_write_occupancy_mean_from_CY( int stats_write_occupancy_mean_param );
        stats_write_occupancy_mean = stats_write_occupancy_mean_param;
    endfunction

    function void axi4_set_stats_write_idle_mean_from_CY( int stats_write_idle_mean_param );
        stats_write_idle_mean = stats_write_idle_mean_param;
    endfunction

    function void axi4_set_stats_write_last_duration_from_CY( int stats_write_last_duration_param );
        stats_write_last_duration = stats_write_last_duration_param;
    endfunction

    function void axi4_set_config_stats_read_data_occupancy_step_from_CY( int config_stats_read_data_occupancy_step_param );
        config_stats_read_data_occupancy_step = config_stats_read_data_occupancy_step_param;
    endfunction

    function void axi4_set_config_stats_read_data_occupancy_multiple_from_CY( int config_stats_read_data_occupancy_multiple_param );
        config_stats_read_data_occupancy_multiple = config_stats_read_data_occupancy_multiple_param;
    endfunction

    function void axi4_set_stats_read_data_occupancy_sw_from_CY( int stats_read_data_occupancy_sw_param );
        stats_read_data_occupancy_sw = stats_read_data_occupancy_sw_param;
    endfunction

    function void axi4_set_stats_read_data_idle_sw_from_CY( int stats_read_data_idle_sw_param );
        stats_read_data_idle_sw = stats_read_data_idle_sw_param;
    endfunction

    function void axi4_set_stats_read_data_occupancy_min_from_CY( int stats_read_data_occupancy_min_param );
        stats_read_data_occupancy_min = stats_read_data_occupancy_min_param;
    endfunction

    function void axi4_set_stats_read_data_idle_min_from_CY( int stats_read_data_idle_min_param );
        stats_read_data_idle_min = stats_read_data_idle_min_param;
    endfunction

    function void axi4_set_stats_read_data_occupancy_max_from_CY( int stats_read_data_occupancy_max_param );
        stats_read_data_occupancy_max = stats_read_data_occupancy_max_param;
    endfunction

    function void axi4_set_stats_read_data_idle_max_from_CY( int stats_read_data_idle_max_param );
        stats_read_data_idle_max = stats_read_data_idle_max_param;
    endfunction

    function void axi4_set_stats_read_data_occupancy_mean_from_CY( int stats_read_data_occupancy_mean_param );
        stats_read_data_occupancy_mean = stats_read_data_occupancy_mean_param;
    endfunction

    function void axi4_set_stats_read_data_idle_mean_from_CY( int stats_read_data_idle_mean_param );
        stats_read_data_idle_mean = stats_read_data_idle_mean_param;
    endfunction

    function void axi4_set_config_stats_write_data_occupancy_step_from_CY( int config_stats_write_data_occupancy_step_param );
        config_stats_write_data_occupancy_step = config_stats_write_data_occupancy_step_param;
    endfunction

    function void axi4_set_config_stats_write_data_occupancy_multiple_from_CY( int config_stats_write_data_occupancy_multiple_param );
        config_stats_write_data_occupancy_multiple = config_stats_write_data_occupancy_multiple_param;
    endfunction

    function void axi4_set_stats_write_data_occupancy_sw_from_CY( int stats_write_data_occupancy_sw_param );
        stats_write_data_occupancy_sw = stats_write_data_occupancy_sw_param;
    endfunction

    function void axi4_set_stats_write_data_idle_sw_from_CY( int stats_write_data_idle_sw_param );
        stats_write_data_idle_sw = stats_write_data_idle_sw_param;
    endfunction

    function void axi4_set_stats_write_data_occupancy_min_from_CY( int stats_write_data_occupancy_min_param );
        stats_write_data_occupancy_min = stats_write_data_occupancy_min_param;
    endfunction

    function void axi4_set_stats_write_data_idle_min_from_CY( int stats_write_data_idle_min_param );
        stats_write_data_idle_min = stats_write_data_idle_min_param;
    endfunction

    function void axi4_set_stats_write_data_occupancy_max_from_CY( int stats_write_data_occupancy_max_param );
        stats_write_data_occupancy_max = stats_write_data_occupancy_max_param;
    endfunction

    function void axi4_set_stats_write_data_idle_max_from_CY( int stats_write_data_idle_max_param );
        stats_write_data_idle_max = stats_write_data_idle_max_param;
    endfunction

    function void axi4_set_stats_write_data_occupancy_mean_from_CY( int stats_write_data_occupancy_mean_param );
        stats_write_data_occupancy_mean = stats_write_data_occupancy_mean_param;
    endfunction

    function void axi4_set_stats_write_data_idle_mean_from_CY( int stats_write_data_idle_mean_param );
        stats_write_data_idle_mean = stats_write_data_idle_mean_param;
    endfunction

    function void axi4_set_config_stats_read_bandwidth_step_from_CY( int config_stats_read_bandwidth_step_param );
        config_stats_read_bandwidth_step = config_stats_read_bandwidth_step_param;
    endfunction

    function void axi4_set_config_stats_read_bandwidth_multiple_from_CY( int config_stats_read_bandwidth_multiple_param );
        config_stats_read_bandwidth_multiple = config_stats_read_bandwidth_multiple_param;
    endfunction

    function void axi4_set_stats_read_bandwidth_sw_from_CY( int stats_read_bandwidth_sw_param );
        stats_read_bandwidth_sw = stats_read_bandwidth_sw_param;
    endfunction

    function void axi4_set_stats_read_bandwidth_min_from_CY( int stats_read_bandwidth_min_param );
        stats_read_bandwidth_min = stats_read_bandwidth_min_param;
    endfunction

    function void axi4_set_stats_read_bandwidth_max_from_CY( int stats_read_bandwidth_max_param );
        stats_read_bandwidth_max = stats_read_bandwidth_max_param;
    endfunction

    function void axi4_set_stats_read_bandwidth_mean_from_CY( int stats_read_bandwidth_mean_param );
        stats_read_bandwidth_mean = stats_read_bandwidth_mean_param;
    endfunction

    function void axi4_set_config_stats_write_bandwidth_step_from_CY( int config_stats_write_bandwidth_step_param );
        config_stats_write_bandwidth_step = config_stats_write_bandwidth_step_param;
    endfunction

    function void axi4_set_config_stats_write_bandwidth_multiple_from_CY( int config_stats_write_bandwidth_multiple_param );
        config_stats_write_bandwidth_multiple = config_stats_write_bandwidth_multiple_param;
    endfunction

    function void axi4_set_stats_write_bandwidth_sw_from_CY( int stats_write_bandwidth_sw_param );
        stats_write_bandwidth_sw = stats_write_bandwidth_sw_param;
    endfunction

    function void axi4_set_stats_write_bandwidth_min_from_CY( int stats_write_bandwidth_min_param );
        stats_write_bandwidth_min = stats_write_bandwidth_min_param;
    endfunction

    function void axi4_set_stats_write_bandwidth_max_from_CY( int stats_write_bandwidth_max_param );
        stats_write_bandwidth_max = stats_write_bandwidth_max_param;
    endfunction

    function void axi4_set_stats_write_bandwidth_mean_from_CY( int stats_write_bandwidth_mean_param );
        stats_write_bandwidth_mean = stats_write_bandwidth_mean_param;
    endfunction

    function void axi4_set_config_stats_read_latency_step_from_CY( int config_stats_read_latency_step_param );
        config_stats_read_latency_step = config_stats_read_latency_step_param;
    endfunction

    function void axi4_set_config_stats_read_latency_multiple_from_CY( int config_stats_read_latency_multiple_param );
        config_stats_read_latency_multiple = config_stats_read_latency_multiple_param;
    endfunction

    function void axi4_set_stats_read_address_data_latency_inst_from_CY( int stats_read_address_data_latency_inst_param );
        stats_read_address_data_latency_inst = stats_read_address_data_latency_inst_param;
    endfunction

    function void axi4_set_stats_read_address_data_latency_sw_from_CY( int stats_read_address_data_latency_sw_param );
        stats_read_address_data_latency_sw = stats_read_address_data_latency_sw_param;
    endfunction

    function void axi4_set_stats_read_address_data_latency_min_from_CY( int stats_read_address_data_latency_min_param );
        stats_read_address_data_latency_min = stats_read_address_data_latency_min_param;
    endfunction

    function void axi4_set_stats_read_address_data_latency_max_from_CY( int stats_read_address_data_latency_max_param );
        stats_read_address_data_latency_max = stats_read_address_data_latency_max_param;
    endfunction

    function void axi4_set_stats_read_address_data_latency_mean_from_CY( int stats_read_address_data_latency_mean_param );
        stats_read_address_data_latency_mean = stats_read_address_data_latency_mean_param;
    endfunction

    function void axi4_set_stats_read_address_address_latency_inst_from_CY( int stats_read_address_address_latency_inst_param );
        stats_read_address_address_latency_inst = stats_read_address_address_latency_inst_param;
    endfunction

    function void axi4_set_stats_read_address_address_latency_sw_from_CY( int stats_read_address_address_latency_sw_param );
        stats_read_address_address_latency_sw = stats_read_address_address_latency_sw_param;
    endfunction

    function void axi4_set_stats_read_address_address_latency_min_from_CY( int stats_read_address_address_latency_min_param );
        stats_read_address_address_latency_min = stats_read_address_address_latency_min_param;
    endfunction

    function void axi4_set_stats_read_address_address_latency_max_from_CY( int stats_read_address_address_latency_max_param );
        stats_read_address_address_latency_max = stats_read_address_address_latency_max_param;
    endfunction

    function void axi4_set_stats_read_address_address_latency_mean_from_CY( int stats_read_address_address_latency_mean_param );
        stats_read_address_address_latency_mean = stats_read_address_address_latency_mean_param;
    endfunction

    function void axi4_set_config_stats_write_latency_step_from_CY( int config_stats_write_latency_step_param );
        config_stats_write_latency_step = config_stats_write_latency_step_param;
    endfunction

    function void axi4_set_config_stats_write_latency_multiple_from_CY( int config_stats_write_latency_multiple_param );
        config_stats_write_latency_multiple = config_stats_write_latency_multiple_param;
    endfunction

    function void axi4_set_stats_write_address_response_latency_inst_from_CY( int stats_write_address_response_latency_inst_param );
        stats_write_address_response_latency_inst = stats_write_address_response_latency_inst_param;
    endfunction

    function void axi4_set_stats_write_address_response_latency_sw_from_CY( int stats_write_address_response_latency_sw_param );
        stats_write_address_response_latency_sw = stats_write_address_response_latency_sw_param;
    endfunction

    function void axi4_set_stats_write_address_response_latency_min_from_CY( int stats_write_address_response_latency_min_param );
        stats_write_address_response_latency_min = stats_write_address_response_latency_min_param;
    endfunction

    function void axi4_set_stats_write_address_response_latency_max_from_CY( int stats_write_address_response_latency_max_param );
        stats_write_address_response_latency_max = stats_write_address_response_latency_max_param;
    endfunction

    function void axi4_set_stats_write_address_response_latency_mean_from_CY( int stats_write_address_response_latency_mean_param );
        stats_write_address_response_latency_mean = stats_write_address_response_latency_mean_param;
    endfunction

    function void axi4_set_stats_write_address_address_latency_inst_from_CY( int stats_write_address_address_latency_inst_param );
        stats_write_address_address_latency_inst = stats_write_address_address_latency_inst_param;
    endfunction

    function void axi4_set_stats_write_address_address_latency_sw_from_CY( int stats_write_address_address_latency_sw_param );
        stats_write_address_address_latency_sw = stats_write_address_address_latency_sw_param;
    endfunction

    function void axi4_set_stats_write_address_address_latency_min_from_CY( int stats_write_address_address_latency_min_param );
        stats_write_address_address_latency_min = stats_write_address_address_latency_min_param;
    endfunction

    function void axi4_set_stats_write_address_address_latency_max_from_CY( int stats_write_address_address_latency_max_param );
        stats_write_address_address_latency_max = stats_write_address_address_latency_max_param;
    endfunction

    function void axi4_set_stats_write_address_address_latency_mean_from_CY( int stats_write_address_address_latency_mean_param );
        stats_write_address_address_latency_mean = stats_write_address_address_latency_mean_param;
    endfunction

    function void axi4_set_config_stats_read_address_waits_step_from_CY( int config_stats_read_address_waits_step_param );
        config_stats_read_address_waits_step = config_stats_read_address_waits_step_param;
    endfunction

    function void axi4_set_config_stats_read_address_waits_multiple_from_CY( int config_stats_read_address_waits_multiple_param );
        config_stats_read_address_waits_multiple = config_stats_read_address_waits_multiple_param;
    endfunction

    function void axi4_set_stats_read_address_waits_inst_from_CY( int stats_read_address_waits_inst_param );
        stats_read_address_waits_inst = stats_read_address_waits_inst_param;
    endfunction

    function void axi4_set_stats_read_address_waits_sw_from_CY( int stats_read_address_waits_sw_param );
        stats_read_address_waits_sw = stats_read_address_waits_sw_param;
    endfunction

    function void axi4_set_stats_read_address_waits_min_from_CY( int stats_read_address_waits_min_param );
        stats_read_address_waits_min = stats_read_address_waits_min_param;
    endfunction

    function void axi4_set_stats_read_address_waits_max_from_CY( int stats_read_address_waits_max_param );
        stats_read_address_waits_max = stats_read_address_waits_max_param;
    endfunction

    function void axi4_set_stats_read_address_waits_mean_from_CY( int stats_read_address_waits_mean_param );
        stats_read_address_waits_mean = stats_read_address_waits_mean_param;
    endfunction

    function void axi4_set_config_stats_read_data_waits_step_from_CY( int config_stats_read_data_waits_step_param );
        config_stats_read_data_waits_step = config_stats_read_data_waits_step_param;
    endfunction

    function void axi4_set_config_stats_read_data_waits_multiple_from_CY( int config_stats_read_data_waits_multiple_param );
        config_stats_read_data_waits_multiple = config_stats_read_data_waits_multiple_param;
    endfunction

    function void axi4_set_stats_read_data_waits_inst_from_CY( int stats_read_data_waits_inst_param );
        stats_read_data_waits_inst = stats_read_data_waits_inst_param;
    endfunction

    function void axi4_set_stats_read_data_waits_sw_from_CY( int stats_read_data_waits_sw_param );
        stats_read_data_waits_sw = stats_read_data_waits_sw_param;
    endfunction

    function void axi4_set_stats_read_data_waits_min_from_CY( int stats_read_data_waits_min_param );
        stats_read_data_waits_min = stats_read_data_waits_min_param;
    endfunction

    function void axi4_set_stats_read_data_waits_max_from_CY( int stats_read_data_waits_max_param );
        stats_read_data_waits_max = stats_read_data_waits_max_param;
    endfunction

    function void axi4_set_stats_read_data_waits_mean_from_CY( int stats_read_data_waits_mean_param );
        stats_read_data_waits_mean = stats_read_data_waits_mean_param;
    endfunction

    function void axi4_set_config_stats_write_address_waits_step_from_CY( int config_stats_write_address_waits_step_param );
        config_stats_write_address_waits_step = config_stats_write_address_waits_step_param;
    endfunction

    function void axi4_set_config_stats_write_address_waits_multiple_from_CY( int config_stats_write_address_waits_multiple_param );
        config_stats_write_address_waits_multiple = config_stats_write_address_waits_multiple_param;
    endfunction

    function void axi4_set_stats_write_address_waits_inst_from_CY( int stats_write_address_waits_inst_param );
        stats_write_address_waits_inst = stats_write_address_waits_inst_param;
    endfunction

    function void axi4_set_stats_write_address_waits_sw_from_CY( int stats_write_address_waits_sw_param );
        stats_write_address_waits_sw = stats_write_address_waits_sw_param;
    endfunction

    function void axi4_set_stats_write_address_waits_min_from_CY( int stats_write_address_waits_min_param );
        stats_write_address_waits_min = stats_write_address_waits_min_param;
    endfunction

    function void axi4_set_stats_write_address_waits_max_from_CY( int stats_write_address_waits_max_param );
        stats_write_address_waits_max = stats_write_address_waits_max_param;
    endfunction

    function void axi4_set_stats_write_address_waits_mean_from_CY( int stats_write_address_waits_mean_param );
        stats_write_address_waits_mean = stats_write_address_waits_mean_param;
    endfunction

    function void axi4_set_config_stats_write_data_waits_step_from_CY( int config_stats_write_data_waits_step_param );
        config_stats_write_data_waits_step = config_stats_write_data_waits_step_param;
    endfunction

    function void axi4_set_config_stats_write_data_waits_multiple_from_CY( int config_stats_write_data_waits_multiple_param );
        config_stats_write_data_waits_multiple = config_stats_write_data_waits_multiple_param;
    endfunction

    function void axi4_set_stats_write_data_waits_inst_from_CY( int stats_write_data_waits_inst_param );
        stats_write_data_waits_inst = stats_write_data_waits_inst_param;
    endfunction

    function void axi4_set_stats_write_data_waits_sw_from_CY( int stats_write_data_waits_sw_param );
        stats_write_data_waits_sw = stats_write_data_waits_sw_param;
    endfunction

    function void axi4_set_stats_write_data_waits_min_from_CY( int stats_write_data_waits_min_param );
        stats_write_data_waits_min = stats_write_data_waits_min_param;
    endfunction

    function void axi4_set_stats_write_data_waits_max_from_CY( int stats_write_data_waits_max_param );
        stats_write_data_waits_max = stats_write_data_waits_max_param;
    endfunction

    function void axi4_set_stats_write_data_waits_mean_from_CY( int stats_write_data_waits_mean_param );
        stats_write_data_waits_mean = stats_write_data_waits_mean_param;
    endfunction

    function void axi4_set_config_stats_write_response_waits_step_from_CY( int config_stats_write_response_waits_step_param );
        config_stats_write_response_waits_step = config_stats_write_response_waits_step_param;
    endfunction

    function void axi4_set_config_stats_write_response_waits_multiple_from_CY( int config_stats_write_response_waits_multiple_param );
        config_stats_write_response_waits_multiple = config_stats_write_response_waits_multiple_param;
    endfunction

    function void axi4_set_stats_write_response_waits_inst_from_CY( int stats_write_response_waits_inst_param );
        stats_write_response_waits_inst = stats_write_response_waits_inst_param;
    endfunction

    function void axi4_set_stats_write_response_waits_sw_from_CY( int stats_write_response_waits_sw_param );
        stats_write_response_waits_sw = stats_write_response_waits_sw_param;
    endfunction

    function void axi4_set_stats_write_response_waits_min_from_CY( int stats_write_response_waits_min_param );
        stats_write_response_waits_min = stats_write_response_waits_min_param;
    endfunction

    function void axi4_set_stats_write_response_waits_max_from_CY( int stats_write_response_waits_max_param );
        stats_write_response_waits_max = stats_write_response_waits_max_param;
    endfunction

    function void axi4_set_stats_write_response_waits_mean_from_CY( int stats_write_response_waits_mean_param );
        stats_write_response_waits_mean = stats_write_response_waits_mean_param;
    endfunction

    function void axi4_set_reordering_depth_of_last_read_transaction_from_CY( int reordering_depth_of_last_read_transaction_param );
        reordering_depth_of_last_read_transaction = reordering_depth_of_last_read_transaction_param;
    endfunction

    //------------------------------------------------------------------------------
    // TLM Interface Support
    //------------------------------------------------------------------------------

    export "DPI-C" axi4_get_temp_static_rw_transaction_addr = function axi4_get_temp_static_rw_transaction_addr;
    export "DPI-C" axi4_set_temp_static_rw_transaction_addr = function axi4_set_temp_static_rw_transaction_addr;
    export "DPI-C" axi4_get_temp_static_rw_transaction_id = function axi4_get_temp_static_rw_transaction_id;
    export "DPI-C" axi4_set_temp_static_rw_transaction_id = function axi4_set_temp_static_rw_transaction_id;
    export "DPI-C" axi4_get_temp_static_rw_transaction_addr_user_data = function axi4_get_temp_static_rw_transaction_addr_user_data;
    export "DPI-C" axi4_set_temp_static_rw_transaction_addr_user_data = function axi4_set_temp_static_rw_transaction_addr_user_data;
    export "DPI-C" axi4_get_temp_static_rw_transaction_data_words = function axi4_get_temp_static_rw_transaction_data_words;
    export "DPI-C" axi4_set_temp_static_rw_transaction_data_words = function axi4_set_temp_static_rw_transaction_data_words;
    export "DPI-C" axi4_get_temp_static_rw_transaction_write_strobes = function axi4_get_temp_static_rw_transaction_write_strobes;
    export "DPI-C" axi4_set_temp_static_rw_transaction_write_strobes = function axi4_set_temp_static_rw_transaction_write_strobes;
    export "DPI-C" axi4_get_temp_static_rw_transaction_wdata_user_data = function axi4_get_temp_static_rw_transaction_wdata_user_data;
    export "DPI-C" axi4_set_temp_static_rw_transaction_wdata_user_data = function axi4_set_temp_static_rw_transaction_wdata_user_data;
    export "DPI-C" axi4_get_temp_static_rw_transaction_resp = function axi4_get_temp_static_rw_transaction_resp;
    export "DPI-C" axi4_set_temp_static_rw_transaction_resp = function axi4_set_temp_static_rw_transaction_resp;
    export "DPI-C" axi4_get_temp_static_rw_transaction_resp_user_data = function axi4_get_temp_static_rw_transaction_resp_user_data;
    export "DPI-C" axi4_set_temp_static_rw_transaction_resp_user_data = function axi4_set_temp_static_rw_transaction_resp_user_data;
    export "DPI-C" axi4_get_temp_static_rw_transaction_data_valid_delay = function axi4_get_temp_static_rw_transaction_data_valid_delay;
    export "DPI-C" axi4_set_temp_static_rw_transaction_data_valid_delay = function axi4_set_temp_static_rw_transaction_data_valid_delay;
    export "DPI-C" axi4_get_temp_static_rw_transaction_data_ready_delay = function axi4_get_temp_static_rw_transaction_data_ready_delay;
    export "DPI-C" axi4_set_temp_static_rw_transaction_data_ready_delay = function axi4_set_temp_static_rw_transaction_data_ready_delay;
    export "DPI-C" axi4_get_temp_static_rw_transaction_write_data_beats_delay = function axi4_get_temp_static_rw_transaction_write_data_beats_delay;
    export "DPI-C" axi4_set_temp_static_rw_transaction_write_data_beats_delay = function axi4_set_temp_static_rw_transaction_write_data_beats_delay;
    import "DPI-C" context axi4_rw_transaction_ActivatesActivatingActivate_SystemVerilog =
    task axi4_rw_transaction_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int read_or_write,
        inout int prot,
        inout bit [3:0] region,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout bit [3:0] qos,
        inout bit [7:0] burst_length,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int wdata_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int address_valid_delay,
        inout int data_valid_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_response_valid_delay,
        inout int address_ready_delay,
        inout int data_ready_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_response_ready_delay,
        inout bit write_data_with_address,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi4_rw_transaction_ActivatesActivatingActivate_open_SystemVerilog =
    task axi4_rw_transaction_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int read_or_write,
        inout int prot,
        inout bit [((4) - 1):0] region,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout bit [((4) - 1):0] qos,
        inout bit [((8) - 1):0] burst_length,
        inout int address_valid_delay,
        inout int write_response_valid_delay,
        inout int address_ready_delay,
        inout int write_response_ready_delay,
        inout bit write_data_with_address,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_rw_transaction_ReceivedReceivingReceive_SystemVerilog =
    task axi4_rw_transaction_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int wdata_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_valid_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_ready_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_rw_transaction_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_rw_transaction_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int read_or_write,
        output int prot,
        output bit [((4) - 1):0] region,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output bit [((4) - 1):0] qos,
        output bit [((8) - 1):0] burst_length,
        output int address_valid_delay,
        output int write_response_valid_delay,
        output int address_ready_delay,
        output int write_response_ready_delay,
        output bit write_data_with_address,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_read_addr = function axi4_get_temp_static_read_addr;
    export "DPI-C" axi4_set_temp_static_read_addr = function axi4_set_temp_static_read_addr;
    export "DPI-C" axi4_get_temp_static_read_rresp_delays = function axi4_get_temp_static_read_rresp_delays;
    export "DPI-C" axi4_set_temp_static_read_rresp_delays = function axi4_set_temp_static_read_rresp_delays;
    export "DPI-C" axi4_get_temp_static_read_id = function axi4_get_temp_static_read_id;
    export "DPI-C" axi4_set_temp_static_read_id = function axi4_set_temp_static_read_id;
    export "DPI-C" axi4_get_temp_static_read_addr_user_data = function axi4_get_temp_static_read_addr_user_data;
    export "DPI-C" axi4_set_temp_static_read_addr_user_data = function axi4_set_temp_static_read_addr_user_data;
    export "DPI-C" axi4_get_temp_static_read_data_words = function axi4_get_temp_static_read_data_words;
    export "DPI-C" axi4_set_temp_static_read_data_words = function axi4_set_temp_static_read_data_words;
    export "DPI-C" axi4_get_temp_static_read_resp = function axi4_get_temp_static_read_resp;
    export "DPI-C" axi4_set_temp_static_read_resp = function axi4_set_temp_static_read_resp;
    export "DPI-C" axi4_get_temp_static_read_resp_user_data = function axi4_get_temp_static_read_resp_user_data;
    export "DPI-C" axi4_set_temp_static_read_resp_user_data = function axi4_set_temp_static_read_resp_user_data;
    export "DPI-C" axi4_get_temp_static_read_data_start_time = function axi4_get_temp_static_read_data_start_time;
    export "DPI-C" axi4_set_temp_static_read_data_start_time = function axi4_set_temp_static_read_data_start_time;
    export "DPI-C" axi4_get_temp_static_read_data_end_time = function axi4_get_temp_static_read_data_end_time;
    export "DPI-C" axi4_set_temp_static_read_data_end_time = function axi4_set_temp_static_read_data_end_time;
    import "DPI-C" context axi4_read_ActivatesActivatingActivate_SystemVerilog =
    task axi4_read_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int prot,
        inout bit [3:0] region,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout bit [3:0] qos,
        inout bit [7:0] burst_length,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_ActivatesActivatingActivate_open_SystemVerilog =
    task axi4_read_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int prot,
        inout bit [((4) - 1):0] region,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout bit [((4) - 1):0] qos,
        inout bit [((8) - 1):0] burst_length,
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout int address_valid_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_read_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int prot,
        output bit [((4) - 1):0] region,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output bit [((4) - 1):0] qos,
        output bit [((8) - 1):0] burst_length,
        output longint addr_start_time,
        output longint addr_end_time,
        output int address_valid_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_write_addr = function axi4_get_temp_static_write_addr;
    export "DPI-C" axi4_set_temp_static_write_addr = function axi4_set_temp_static_write_addr;
    export "DPI-C" axi4_get_temp_static_write_id = function axi4_get_temp_static_write_id;
    export "DPI-C" axi4_set_temp_static_write_id = function axi4_set_temp_static_write_id;
    export "DPI-C" axi4_get_temp_static_write_addr_user_data = function axi4_get_temp_static_write_addr_user_data;
    export "DPI-C" axi4_set_temp_static_write_addr_user_data = function axi4_set_temp_static_write_addr_user_data;
    export "DPI-C" axi4_get_temp_static_write_data_words = function axi4_get_temp_static_write_data_words;
    export "DPI-C" axi4_set_temp_static_write_data_words = function axi4_set_temp_static_write_data_words;
    export "DPI-C" axi4_get_temp_static_write_write_strobes = function axi4_get_temp_static_write_write_strobes;
    export "DPI-C" axi4_set_temp_static_write_write_strobes = function axi4_set_temp_static_write_write_strobes;
    export "DPI-C" axi4_get_temp_static_write_wdata_user_data = function axi4_get_temp_static_write_wdata_user_data;
    export "DPI-C" axi4_set_temp_static_write_wdata_user_data = function axi4_set_temp_static_write_wdata_user_data;
    export "DPI-C" axi4_get_temp_static_write_resp_user_data = function axi4_get_temp_static_write_resp_user_data;
    export "DPI-C" axi4_set_temp_static_write_resp_user_data = function axi4_set_temp_static_write_resp_user_data;
    export "DPI-C" axi4_get_temp_static_write_data_start_time = function axi4_get_temp_static_write_data_start_time;
    export "DPI-C" axi4_set_temp_static_write_data_start_time = function axi4_set_temp_static_write_data_start_time;
    export "DPI-C" axi4_get_temp_static_write_data_end_time = function axi4_get_temp_static_write_data_end_time;
    export "DPI-C" axi4_set_temp_static_write_data_end_time = function axi4_set_temp_static_write_data_end_time;
    export "DPI-C" axi4_get_temp_static_write_write_data_beats_delay = function axi4_get_temp_static_write_write_data_beats_delay;
    export "DPI-C" axi4_set_temp_static_write_write_data_beats_delay = function axi4_set_temp_static_write_write_data_beats_delay;
    import "DPI-C" context axi4_write_ActivatesActivatingActivate_SystemVerilog =
    task axi4_write_ActivatesActivatingActivate_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int prot,
        inout int bresp_delay,
        inout bit [3:0] region,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout bit [3:0] qos,
        inout bit [7:0] burst_length,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int wdata_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int resp,
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout longint wr_resp_start_time,
        inout longint wr_resp_end_time,
        inout int address_valid_delay,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi4_write_ActivatesActivatingActivate_open_SystemVerilog =
    task axi4_write_ActivatesActivatingActivate_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        inout int prot,
        inout int bresp_delay,
        inout bit [((4) - 1):0] region,
        inout int size,
        inout int burst,
        inout int lock,
        inout int cache,
        inout bit [((4) - 1):0] qos,
        inout bit [((8) - 1):0] burst_length,
        inout int resp,
        inout longint addr_start_time,
        inout longint addr_end_time,
        inout longint wr_resp_start_time,
        inout longint wr_resp_end_time,
        inout int address_valid_delay,
        inout int write_address_to_data_delay,
        inout int write_data_to_address_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int wdata_user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_write_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int prot,
        output int bresp_delay,
        output bit [((4) - 1):0] region,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output bit [((4) - 1):0] qos,
        output bit [((8) - 1):0] burst_length,
        output int resp,
        output longint addr_start_time,
        output longint addr_end_time,
        output longint wr_resp_start_time,
        output longint wr_resp_end_time,
        output int address_valid_delay,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_write_data_burst_data_words = function axi4_get_temp_static_write_data_burst_data_words;
    export "DPI-C" axi4_set_temp_static_write_data_burst_data_words = function axi4_set_temp_static_write_data_burst_data_words;
    export "DPI-C" axi4_get_temp_static_write_data_burst_write_strobes = function axi4_get_temp_static_write_data_burst_write_strobes;
    export "DPI-C" axi4_set_temp_static_write_data_burst_write_strobes = function axi4_set_temp_static_write_data_burst_write_strobes;
    export "DPI-C" axi4_get_temp_static_write_data_burst_user_data = function axi4_get_temp_static_write_data_burst_user_data;
    export "DPI-C" axi4_set_temp_static_write_data_burst_user_data = function axi4_set_temp_static_write_data_burst_user_data;
    export "DPI-C" axi4_get_temp_static_write_data_burst_data_start_time = function axi4_get_temp_static_write_data_burst_data_start_time;
    export "DPI-C" axi4_set_temp_static_write_data_burst_data_start_time = function axi4_set_temp_static_write_data_burst_data_start_time;
    export "DPI-C" axi4_get_temp_static_write_data_burst_data_end_time = function axi4_get_temp_static_write_data_burst_data_end_time;
    export "DPI-C" axi4_set_temp_static_write_data_burst_data_end_time = function axi4_set_temp_static_write_data_burst_data_end_time;
    export "DPI-C" axi4_get_temp_static_write_data_burst_write_data_beats_delay = function axi4_get_temp_static_write_data_burst_write_data_beats_delay;
    export "DPI-C" axi4_set_temp_static_write_data_burst_write_data_beats_delay = function axi4_set_temp_static_write_data_burst_write_data_beats_delay;
    import "DPI-C" context axi4_write_data_burst_SendSendingSent_SystemVerilog =
    task axi4_write_data_burst_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int burst_length,
        input int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id
    );
    import "DPI-C" context axi4_write_data_burst_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_data_burst_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        inout int data_words_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_strobes_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int user_data_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_start_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int data_end_time_DIMS0, // Array to pass in and/or out the unsized dims of param
        inout int write_data_beats_delay_DIMS0, // Array to pass in and/or out the unsized dims of param
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_data_burst_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_write_data_burst_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int burst_length,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_read_addr_channel_phase_addr = function axi4_get_temp_static_read_addr_channel_phase_addr;
    export "DPI-C" axi4_set_temp_static_read_addr_channel_phase_addr = function axi4_set_temp_static_read_addr_channel_phase_addr;
    export "DPI-C" axi4_get_temp_static_read_addr_channel_phase_id = function axi4_get_temp_static_read_addr_channel_phase_id;
    export "DPI-C" axi4_set_temp_static_read_addr_channel_phase_id = function axi4_set_temp_static_read_addr_channel_phase_id;
    export "DPI-C" axi4_get_temp_static_read_addr_channel_phase_addr_user = function axi4_get_temp_static_read_addr_channel_phase_addr_user;
    export "DPI-C" axi4_set_temp_static_read_addr_channel_phase_addr_user = function axi4_set_temp_static_read_addr_channel_phase_addr_user;
    import "DPI-C" context axi4_read_addr_channel_phase_SendSendingSent_SystemVerilog =
    task axi4_read_addr_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int prot,
        input bit [3:0] region,
        input bit [7:0] burst_length,
        input int size,
        input int burst,
        input int lock,
        input int cache,
        input bit [3:0] qos,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_read_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int prot,
        output bit [((4) - 1):0] region,
        output bit [((8) - 1):0] burst_length,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output bit [((4) - 1):0] qos,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_data_burst_SendSendingSent_SystemVerilog =
    task axi4_read_data_burst_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_data_burst_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_data_burst_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_read_channel_phase_data = function axi4_get_temp_static_read_channel_phase_data;
    export "DPI-C" axi4_set_temp_static_read_channel_phase_data = function axi4_set_temp_static_read_channel_phase_data;
    export "DPI-C" axi4_get_temp_static_read_channel_phase_id = function axi4_get_temp_static_read_channel_phase_id;
    export "DPI-C" axi4_set_temp_static_read_channel_phase_id = function axi4_set_temp_static_read_channel_phase_id;
    export "DPI-C" axi4_get_temp_static_read_channel_phase_user_data = function axi4_get_temp_static_read_channel_phase_user_data;
    export "DPI-C" axi4_set_temp_static_read_channel_phase_user_data = function axi4_set_temp_static_read_channel_phase_user_data;
    import "DPI-C" context axi4_read_channel_phase_SendSendingSent_SystemVerilog =
    task axi4_read_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int resp,
        input bit last,
        input int data_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_channel_phase_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_read_channel_phase_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int resp,
        output bit last,
        output int data_ready_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_write_addr_channel_phase_addr = function axi4_get_temp_static_write_addr_channel_phase_addr;
    export "DPI-C" axi4_set_temp_static_write_addr_channel_phase_addr = function axi4_set_temp_static_write_addr_channel_phase_addr;
    export "DPI-C" axi4_get_temp_static_write_addr_channel_phase_id = function axi4_get_temp_static_write_addr_channel_phase_id;
    export "DPI-C" axi4_set_temp_static_write_addr_channel_phase_id = function axi4_set_temp_static_write_addr_channel_phase_id;
    export "DPI-C" axi4_get_temp_static_write_addr_channel_phase_addr_user = function axi4_get_temp_static_write_addr_channel_phase_addr_user;
    export "DPI-C" axi4_set_temp_static_write_addr_channel_phase_addr_user = function axi4_set_temp_static_write_addr_channel_phase_addr_user;
    import "DPI-C" context axi4_write_addr_channel_phase_SendSendingSent_SystemVerilog =
    task axi4_write_addr_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int prot,
        input bit [3:0] region,
        input bit [7:0] burst_length,
        input int size,
        input int burst,
        input int lock,
        input int cache,
        input bit [3:0] qos,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_write_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int prot,
        output bit [((4) - 1):0] region,
        output bit [((8) - 1):0] burst_length,
        output int size,
        output int burst,
        output int lock,
        output int cache,
        output bit [((4) - 1):0] qos,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_write_channel_phase_data = function axi4_get_temp_static_write_channel_phase_data;
    export "DPI-C" axi4_set_temp_static_write_channel_phase_data = function axi4_set_temp_static_write_channel_phase_data;
    export "DPI-C" axi4_get_temp_static_write_channel_phase_write_strobes = function axi4_get_temp_static_write_channel_phase_write_strobes;
    export "DPI-C" axi4_set_temp_static_write_channel_phase_write_strobes = function axi4_set_temp_static_write_channel_phase_write_strobes;
    export "DPI-C" axi4_get_temp_static_write_channel_phase_user_data = function axi4_get_temp_static_write_channel_phase_user_data;
    export "DPI-C" axi4_set_temp_static_write_channel_phase_user_data = function axi4_set_temp_static_write_channel_phase_user_data;
    import "DPI-C" context axi4_write_channel_phase_SendSendingSent_SystemVerilog =
    task axi4_write_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit last,
        input int data_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_channel_phase_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_write_channel_phase_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit last,
        output int data_ready_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_write_resp_channel_phase_id = function axi4_get_temp_static_write_resp_channel_phase_id;
    export "DPI-C" axi4_set_temp_static_write_resp_channel_phase_id = function axi4_set_temp_static_write_resp_channel_phase_id;
    export "DPI-C" axi4_get_temp_static_write_resp_channel_phase_user_data = function axi4_get_temp_static_write_resp_channel_phase_user_data;
    export "DPI-C" axi4_set_temp_static_write_resp_channel_phase_user_data = function axi4_set_temp_static_write_resp_channel_phase_user_data;
    import "DPI-C" context axi4_write_resp_channel_phase_SendSendingSent_SystemVerilog =
    task axi4_write_resp_channel_phase_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int resp,
        input int write_response_ready_delay,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_resp_channel_phase_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_resp_channel_phase_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_resp_channel_phase_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_write_resp_channel_phase_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int resp,
        output int write_response_ready_delay,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_read_addr_channel_cycle_addr = function axi4_get_temp_static_read_addr_channel_cycle_addr;
    export "DPI-C" axi4_set_temp_static_read_addr_channel_cycle_addr = function axi4_set_temp_static_read_addr_channel_cycle_addr;
    export "DPI-C" axi4_get_temp_static_read_addr_channel_cycle_id = function axi4_get_temp_static_read_addr_channel_cycle_id;
    export "DPI-C" axi4_set_temp_static_read_addr_channel_cycle_id = function axi4_set_temp_static_read_addr_channel_cycle_id;
    export "DPI-C" axi4_get_temp_static_read_addr_channel_cycle_user_data = function axi4_get_temp_static_read_addr_channel_cycle_user_data;
    export "DPI-C" axi4_set_temp_static_read_addr_channel_cycle_user_data = function axi4_set_temp_static_read_addr_channel_cycle_user_data;
    import "DPI-C" context axi4_read_addr_channel_cycle_SendSendingSent_SystemVerilog =
    task axi4_read_addr_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [3:0] region,
        input int cache,
        input bit [7:0] burst_length,
        input int size,
        input int burst,
        input int lock,
        input bit [3:0] qos,
        input int prot,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_read_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((4) - 1):0] region,
        output int cache,
        output bit [((8) - 1):0] burst_length,
        output int size,
        output int burst,
        output int lock,
        output bit [((4) - 1):0] qos,
        output int prot,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_addr_channel_ready_SendSendingSent_SystemVerilog =
    task axi4_read_addr_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_read_channel_cycle_data = function axi4_get_temp_static_read_channel_cycle_data;
    export "DPI-C" axi4_set_temp_static_read_channel_cycle_data = function axi4_set_temp_static_read_channel_cycle_data;
    export "DPI-C" axi4_get_temp_static_read_channel_cycle_id = function axi4_get_temp_static_read_channel_cycle_id;
    export "DPI-C" axi4_set_temp_static_read_channel_cycle_id = function axi4_set_temp_static_read_channel_cycle_id;
    export "DPI-C" axi4_get_temp_static_read_channel_cycle_user_data = function axi4_get_temp_static_read_channel_cycle_user_data;
    export "DPI-C" axi4_set_temp_static_read_channel_cycle_user_data = function axi4_set_temp_static_read_channel_cycle_user_data;
    import "DPI-C" context axi4_read_channel_cycle_SendSendingSent_SystemVerilog =
    task axi4_read_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int resp,
        input bit last,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_read_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int resp,
        output bit last,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_read_channel_ready_SendSendingSent_SystemVerilog =
    task axi4_read_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_read_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi4_read_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_write_addr_channel_cycle_addr = function axi4_get_temp_static_write_addr_channel_cycle_addr;
    export "DPI-C" axi4_set_temp_static_write_addr_channel_cycle_addr = function axi4_set_temp_static_write_addr_channel_cycle_addr;
    export "DPI-C" axi4_get_temp_static_write_addr_channel_cycle_id = function axi4_get_temp_static_write_addr_channel_cycle_id;
    export "DPI-C" axi4_set_temp_static_write_addr_channel_cycle_id = function axi4_set_temp_static_write_addr_channel_cycle_id;
    export "DPI-C" axi4_get_temp_static_write_addr_channel_cycle_user_data = function axi4_get_temp_static_write_addr_channel_cycle_user_data;
    export "DPI-C" axi4_set_temp_static_write_addr_channel_cycle_user_data = function axi4_set_temp_static_write_addr_channel_cycle_user_data;
    import "DPI-C" context axi4_write_addr_channel_cycle_SendSendingSent_SystemVerilog =
    task axi4_write_addr_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit [3:0] region,
        input int cache,
        input bit [7:0] burst_length,
        input int size,
        input int burst,
        input int lock,
        input bit [3:0] qos,
        input int prot,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_write_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit [((4) - 1):0] region,
        output int cache,
        output bit [((8) - 1):0] burst_length,
        output int size,
        output int burst,
        output int lock,
        output bit [((4) - 1):0] qos,
        output int prot,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_addr_channel_ready_SendSendingSent_SystemVerilog =
    task axi4_write_addr_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_write_channel_cycle_data = function axi4_get_temp_static_write_channel_cycle_data;
    export "DPI-C" axi4_set_temp_static_write_channel_cycle_data = function axi4_set_temp_static_write_channel_cycle_data;
    export "DPI-C" axi4_get_temp_static_write_channel_cycle_strb = function axi4_get_temp_static_write_channel_cycle_strb;
    export "DPI-C" axi4_set_temp_static_write_channel_cycle_strb = function axi4_set_temp_static_write_channel_cycle_strb;
    export "DPI-C" axi4_get_temp_static_write_channel_cycle_user_data = function axi4_get_temp_static_write_channel_cycle_user_data;
    export "DPI-C" axi4_set_temp_static_write_channel_cycle_user_data = function axi4_set_temp_static_write_channel_cycle_user_data;
    import "DPI-C" context axi4_write_channel_cycle_SendSendingSent_SystemVerilog =
    task axi4_write_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit last,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_write_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output bit last,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_channel_ready_SendSendingSent_SystemVerilog =
    task axi4_write_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_write_resp_channel_cycle_id = function axi4_get_temp_static_write_resp_channel_cycle_id;
    export "DPI-C" axi4_set_temp_static_write_resp_channel_cycle_id = function axi4_set_temp_static_write_resp_channel_cycle_id;
    export "DPI-C" axi4_get_temp_static_write_resp_channel_cycle_user_data = function axi4_get_temp_static_write_resp_channel_cycle_user_data;
    export "DPI-C" axi4_set_temp_static_write_resp_channel_cycle_user_data = function axi4_set_temp_static_write_resp_channel_cycle_user_data;
    import "DPI-C" context axi4_write_resp_channel_cycle_SendSendingSent_SystemVerilog =
    task axi4_write_resp_channel_cycle_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int resp,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_resp_channel_cycle_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_resp_channel_cycle_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_resp_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_write_resp_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int resp,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_write_resp_channel_ready_SendSendingSent_SystemVerilog =
    task axi4_write_resp_channel_ready_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id
    );
    import "DPI-C" context axi4_write_resp_channel_ready_ReceivedReceivingReceive_SystemVerilog =
    task axi4_write_resp_channel_ready_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_unexpected_write_response_id = function axi4_get_temp_static_unexpected_write_response_id;
    export "DPI-C" axi4_set_temp_static_unexpected_write_response_id = function axi4_set_temp_static_unexpected_write_response_id;
    export "DPI-C" axi4_get_temp_static_unexpected_write_response_resp_user_data = function axi4_get_temp_static_unexpected_write_response_resp_user_data;
    export "DPI-C" axi4_set_temp_static_unexpected_write_response_resp_user_data = function axi4_set_temp_static_unexpected_write_response_resp_user_data;
    import "DPI-C" context axi4_unexpected_write_response_SendSendingSent_SystemVerilog =
    task axi4_unexpected_write_response_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int resp,
        input int _unit_id
    );
    import "DPI-C" context axi4_unexpected_write_response_ReceivedReceivingReceive_SystemVerilog =
    task axi4_unexpected_write_response_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_unexpected_write_response_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_unexpected_write_response_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int resp,
        input int _unit_id,
        input bit _using
    );
    export "DPI-C" axi4_get_temp_static_unexpected_read_response_data = function axi4_get_temp_static_unexpected_read_response_data;
    export "DPI-C" axi4_set_temp_static_unexpected_read_response_data = function axi4_set_temp_static_unexpected_read_response_data;
    export "DPI-C" axi4_get_temp_static_unexpected_read_response_id = function axi4_get_temp_static_unexpected_read_response_id;
    export "DPI-C" axi4_set_temp_static_unexpected_read_response_id = function axi4_set_temp_static_unexpected_read_response_id;
    export "DPI-C" axi4_get_temp_static_unexpected_read_response_user_data = function axi4_get_temp_static_unexpected_read_response_user_data;
    export "DPI-C" axi4_set_temp_static_unexpected_read_response_user_data = function axi4_set_temp_static_unexpected_read_response_user_data;
    import "DPI-C" context axi4_unexpected_read_response_SendSendingSent_SystemVerilog =
    task axi4_unexpected_read_response_SendSendingSent_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int resp,
        input bit last,
        input int _unit_id
    );
    import "DPI-C" context axi4_unexpected_read_response_ReceivedReceivingReceive_SystemVerilog =
    task axi4_unexpected_read_response_ReceivedReceivingReceive_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        output int _trans_id,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_unexpected_read_response_ReceivedReceivingReceive_open_SystemVerilog =
    task axi4_unexpected_read_response_ReceivedReceivingReceive_open_SystemVerilog
    (
        input int _comms_semantic,
        input longint _as_end,
        input int _trans_id,
        output int resp,
        output bit last,
        input int _unit_id,
        input bit _using
    );
    import "DPI-C" context axi4_end_of_timestep_VPI_SystemVerilog =
    task axi4_end_of_timestep_VPI_SystemVerilog();
    import "DPI-C" context function longint axi4_get_interface_handle();

    // Waiter task and control
    reg wait_for_control = 0;

    always @(posedge wait_for_control)
    begin
        disable wait_for;
        wait_for_control = 0;
    end

    export "DPI-C" axi4_wait_for = task wait_for;

    task wait_for();
        begin
            wait(0 == 1);
        end
    endtask

    // handle control
    longint last_handle = 0;

    longint last_start_time = 0;

    longint last_end_time = 0;

    export "DPI-C" axi4_set_last_handle_and_times = function set_last_handle_and_times;

    function void set_last_handle_and_times(longint _handle, longint _start, longint _end);
        last_handle = _handle;
        last_start_time = _start;
        last_end_time = _end;
    endfunction

    // Drive wires (from Cohesive) 
    assign ACLK = internal_ACLK;
    assign ARESETn = internal_ARESETn;
    assign AWVALID = internal_AWVALID;
    assign AWADDR = internal_AWADDR;
    assign AWPROT = internal_AWPROT;
    assign AWREGION = internal_AWREGION;
    assign AWLEN = internal_AWLEN;
    assign AWSIZE = internal_AWSIZE;
    assign AWBURST = internal_AWBURST;
    assign AWLOCK = internal_AWLOCK;
    assign AWCACHE = internal_AWCACHE;
    assign AWQOS = internal_AWQOS;
    assign AWID = internal_AWID;
    assign AWUSER = internal_AWUSER;
    assign AWREADY = internal_AWREADY;
    assign ARVALID = internal_ARVALID;
    assign ARADDR = internal_ARADDR;
    assign ARPROT = internal_ARPROT;
    assign ARREGION = internal_ARREGION;
    assign ARLEN = internal_ARLEN;
    assign ARSIZE = internal_ARSIZE;
    assign ARBURST = internal_ARBURST;
    assign ARLOCK = internal_ARLOCK;
    assign ARCACHE = internal_ARCACHE;
    assign ARQOS = internal_ARQOS;
    assign ARID = internal_ARID;
    assign ARUSER = internal_ARUSER;
    assign ARREADY = internal_ARREADY;
    assign RVALID = internal_RVALID;
    assign RDATA = internal_RDATA;
    assign RRESP = internal_RRESP;
    assign RLAST = internal_RLAST;
    assign RID = internal_RID;
    assign RUSER = internal_RUSER;
    assign RREADY = internal_RREADY;
    assign WVALID = internal_WVALID;
    assign WDATA = internal_WDATA;
    assign WSTRB = internal_WSTRB;
    assign WLAST = internal_WLAST;
    assign WUSER = internal_WUSER;
    assign WREADY = internal_WREADY;
    assign BVALID = internal_BVALID;
    assign BRESP = internal_BRESP;
    assign BID = internal_BID;
    assign BUSER = internal_BUSER;
    assign BREADY = internal_BREADY;
    // Drive wires (from User) 
    assign ACLK = m_ACLK;
    assign ARESETn = m_ARESETn;
    assign AWVALID = m_AWVALID;
    assign AWADDR = m_AWADDR;
    assign AWPROT = m_AWPROT;
    assign AWREGION = m_AWREGION;
    assign AWLEN = m_AWLEN;
    assign AWSIZE = m_AWSIZE;
    assign AWBURST = m_AWBURST;
    assign AWLOCK = m_AWLOCK;
    assign AWCACHE = m_AWCACHE;
    assign AWQOS = m_AWQOS;
    assign AWID = m_AWID;
    assign AWUSER = m_AWUSER;
    assign AWREADY = m_AWREADY;
    assign ARVALID = m_ARVALID;
    assign ARADDR = m_ARADDR;
    assign ARPROT = m_ARPROT;
    assign ARREGION = m_ARREGION;
    assign ARLEN = m_ARLEN;
    assign ARSIZE = m_ARSIZE;
    assign ARBURST = m_ARBURST;
    assign ARLOCK = m_ARLOCK;
    assign ARCACHE = m_ARCACHE;
    assign ARQOS = m_ARQOS;
    assign ARID = m_ARID;
    assign ARUSER = m_ARUSER;
    assign ARREADY = m_ARREADY;
    assign RVALID = m_RVALID;
    assign RDATA = m_RDATA;
    assign RRESP = m_RRESP;
    assign RLAST = m_RLAST;
    assign RID = m_RID;
    assign RUSER = m_RUSER;
    assign RREADY = m_RREADY;
    assign WVALID = m_WVALID;
    assign WDATA = m_WDATA;
    assign WSTRB = m_WSTRB;
    assign WLAST = m_WLAST;
    assign WUSER = m_WUSER;
    assign WREADY = m_WREADY;
    assign BVALID = m_BVALID;
    assign BRESP = m_BRESP;
    assign BID = m_BID;
    assign BUSER = m_BUSER;
    assign BREADY = m_BREADY;

    reg ACLK_changed = 0;
    reg ARESETn_changed = 0;
    reg AWVALID_changed = 0;
    reg AWADDR_changed = 0;
    reg AWPROT_changed = 0;
    reg AWREGION_changed = 0;
    reg AWLEN_changed = 0;
    reg AWSIZE_changed = 0;
    reg AWBURST_changed = 0;
    reg AWLOCK_changed = 0;
    reg AWCACHE_changed = 0;
    reg AWQOS_changed = 0;
    reg AWID_changed = 0;
    reg AWUSER_changed = 0;
    reg AWREADY_changed = 0;
    reg ARVALID_changed = 0;
    reg ARADDR_changed = 0;
    reg ARPROT_changed = 0;
    reg ARREGION_changed = 0;
    reg ARLEN_changed = 0;
    reg ARSIZE_changed = 0;
    reg ARBURST_changed = 0;
    reg ARLOCK_changed = 0;
    reg ARCACHE_changed = 0;
    reg ARQOS_changed = 0;
    reg ARID_changed = 0;
    reg ARUSER_changed = 0;
    reg ARREADY_changed = 0;
    reg RVALID_changed = 0;
    reg RDATA_changed = 0;
    reg RRESP_changed = 0;
    reg RLAST_changed = 0;
    reg RID_changed = 0;
    reg RUSER_changed = 0;
    reg RREADY_changed = 0;
    reg WVALID_changed = 0;
    reg WDATA_changed = 0;
    reg WSTRB_changed = 0;
    reg WLAST_changed = 0;
    reg WUSER_changed = 0;
    reg WREADY_changed = 0;
    reg BVALID_changed = 0;
    reg BRESP_changed = 0;
    reg BID_changed = 0;
    reg BUSER_changed = 0;
    reg BREADY_changed = 0;
    reg config_interface_type_changed = 0;
    reg config_clk_init_value_changed = 0;
    reg config_clk_phase_shift_changed = 0;
    reg config_clk_1st_time_changed = 0;
    reg config_clk_2nd_time_changed = 0;
    reg config_setup_time_changed = 0;
    reg config_hold_time_changed = 0;
    reg config_burst_timeout_factor_changed = 0;
    reg config_max_transaction_time_factor_changed = 0;
    reg config_write_ctrl_first_ratio_changed = 0;
    reg config_write_data_first_ratio_changed = 0;
    reg config_reset_low_clocks_changed = 0;
    reg config_reset_hold_time_changed = 0;
    reg config_enable_rlast_changed = 0;
    reg config_enable_slave_exclusive_changed = 0;
    reg config_enable_burst_reserved_value_changed = 0;
    reg config_enable_cache_value_changed = 0;
    reg internal_dummy_variable_changed = 0;
    reg config_axi4lite_interface_changed = 0;
    reg config_axi4lite_tr_id_changed = 0;
    reg config_enable_all_assertions_changed = 0;
    reg config_enable_assertion_changed = 0;
    reg config_enable_error_changed = 0;
    reg config_max_latency_AWVALID_assertion_to_AWREADY_changed = 0;
    reg config_max_latency_ARVALID_assertion_to_ARREADY_changed = 0;
    reg config_max_latency_RVALID_assertion_to_RREADY_changed = 0;
    reg config_max_latency_BVALID_assertion_to_BREADY_changed = 0;
    reg config_max_latency_WVALID_assertion_to_WREADY_changed = 0;
    reg config_enable_qos_changed = 0;
    reg config_enable_region_support_changed = 0;
    reg config_slave_regions_changed = 0;
    reg config_region_changed = 0;
    reg region_error_state_changed = 0;
    reg region_map_lb_changed = 0;
    reg region_map_ub_changed = 0;
    reg region_map_region_changed = 0;
    reg cacheable_changed = 0;
    reg config_read_data_reordering_depth_changed = 0;
    reg config_slave_start_addr_changed = 0;
    reg config_slave_end_addr_changed = 0;
    reg config_slave_enabled_non_contiguous_address_spaces_changed = 0;
    reg config_slave_possess_multiple_non_contiguous_address_spaces_changed = 0;
    reg config_slave_multiple_non_contiguous_start_address_range_changed = 0;
    reg config_slave_multiple_non_contiguous_end_address_range_changed = 0;
    reg config_protect_ready_changed = 0;
    reg master_end_tlm_status_changed = 0;
    reg master_end_wlm_status_changed = 0;
    reg slave_end_tlm_status_changed = 0;
    reg slave_end_wlm_status_changed = 0;
    reg clock_source_end_tlm_status_changed = 0;
    reg clock_source_end_wlm_status_changed = 0;
    reg reset_source_end_tlm_status_changed = 0;
    reg reset_source_end_wlm_status_changed = 0;
    reg config_max_outstanding_wr_changed = 0;
    reg config_max_outstanding_rd_changed = 0;
    reg config_num_outstanding_wr_phase_changed = 0;
    reg config_num_outstanding_rd_phase_changed = 0;
    reg config_enable_warnings_changed = 0;
    reg config_enable_errors_changed = 0;
    reg config_enable_exclusive_checks_changed = 0;
    reg config_warn_on_slave_errors_changed = 0;
    reg config_error_on_deleted_valid_cycles_changed = 0;
    reg config_stats_enable_changed = 0;
    reg config_stats_enable_read_occupancy_changed = 0;
    reg config_stats_enable_write_occupancy_changed = 0;
    reg config_stats_enable_read_data_occupancy_changed = 0;
    reg config_stats_enable_write_data_occupancy_changed = 0;
    reg config_stats_enable_read_latency_changed = 0;
    reg config_stats_enable_write_latency_changed = 0;
    reg config_stats_enable_read_address_waits_changed = 0;
    reg config_stats_enable_read_data_waits_changed = 0;
    reg config_stats_enable_write_address_waits_changed = 0;
    reg config_stats_enable_write_data_waits_changed = 0;
    reg config_stats_enable_write_response_waits_changed = 0;
    reg config_stats_enable_read_bandwidth_changed = 0;
    reg config_stats_enable_write_bandwidth_changed = 0;
    reg stats_rw_transaction_last_duration_changed = 0;
    reg config_stats_read_occupancy_step_changed = 0;
    reg config_stats_read_occupancy_multiple_changed = 0;
    reg stats_read_active_changed = 0;
    reg stats_read_occupancy_sw_changed = 0;
    reg stats_read_idle_sw_changed = 0;
    reg stats_read_occupancy_min_changed = 0;
    reg stats_read_idle_min_changed = 0;
    reg stats_read_occupancy_max_changed = 0;
    reg stats_read_idle_max_changed = 0;
    reg stats_read_occupancy_mean_changed = 0;
    reg stats_read_idle_mean_changed = 0;
    reg stats_read_last_duration_changed = 0;
    reg config_stats_write_occupancy_step_changed = 0;
    reg config_stats_write_occupancy_multiple_changed = 0;
    reg stats_write_active_changed = 0;
    reg stats_write_occupancy_sw_changed = 0;
    reg stats_write_idle_sw_changed = 0;
    reg stats_write_occupancy_min_changed = 0;
    reg stats_write_idle_min_changed = 0;
    reg stats_write_occupancy_max_changed = 0;
    reg stats_write_idle_max_changed = 0;
    reg stats_write_occupancy_mean_changed = 0;
    reg stats_write_idle_mean_changed = 0;
    reg stats_write_last_duration_changed = 0;
    reg config_stats_read_data_occupancy_step_changed = 0;
    reg config_stats_read_data_occupancy_multiple_changed = 0;
    reg stats_read_data_occupancy_sw_changed = 0;
    reg stats_read_data_idle_sw_changed = 0;
    reg stats_read_data_occupancy_min_changed = 0;
    reg stats_read_data_idle_min_changed = 0;
    reg stats_read_data_occupancy_max_changed = 0;
    reg stats_read_data_idle_max_changed = 0;
    reg stats_read_data_occupancy_mean_changed = 0;
    reg stats_read_data_idle_mean_changed = 0;
    reg config_stats_write_data_occupancy_step_changed = 0;
    reg config_stats_write_data_occupancy_multiple_changed = 0;
    reg stats_write_data_occupancy_sw_changed = 0;
    reg stats_write_data_idle_sw_changed = 0;
    reg stats_write_data_occupancy_min_changed = 0;
    reg stats_write_data_idle_min_changed = 0;
    reg stats_write_data_occupancy_max_changed = 0;
    reg stats_write_data_idle_max_changed = 0;
    reg stats_write_data_occupancy_mean_changed = 0;
    reg stats_write_data_idle_mean_changed = 0;
    reg config_stats_read_bandwidth_step_changed = 0;
    reg config_stats_read_bandwidth_multiple_changed = 0;
    reg stats_read_bandwidth_sw_changed = 0;
    reg stats_read_bandwidth_min_changed = 0;
    reg stats_read_bandwidth_max_changed = 0;
    reg stats_read_bandwidth_mean_changed = 0;
    reg config_stats_write_bandwidth_step_changed = 0;
    reg config_stats_write_bandwidth_multiple_changed = 0;
    reg stats_write_bandwidth_sw_changed = 0;
    reg stats_write_bandwidth_min_changed = 0;
    reg stats_write_bandwidth_max_changed = 0;
    reg stats_write_bandwidth_mean_changed = 0;
    reg config_stats_read_latency_step_changed = 0;
    reg config_stats_read_latency_multiple_changed = 0;
    reg stats_read_address_data_latency_inst_changed = 0;
    reg stats_read_address_data_latency_sw_changed = 0;
    reg stats_read_address_data_latency_min_changed = 0;
    reg stats_read_address_data_latency_max_changed = 0;
    reg stats_read_address_data_latency_mean_changed = 0;
    reg stats_read_address_address_latency_inst_changed = 0;
    reg stats_read_address_address_latency_sw_changed = 0;
    reg stats_read_address_address_latency_min_changed = 0;
    reg stats_read_address_address_latency_max_changed = 0;
    reg stats_read_address_address_latency_mean_changed = 0;
    reg config_stats_write_latency_step_changed = 0;
    reg config_stats_write_latency_multiple_changed = 0;
    reg stats_write_address_response_latency_inst_changed = 0;
    reg stats_write_address_response_latency_sw_changed = 0;
    reg stats_write_address_response_latency_min_changed = 0;
    reg stats_write_address_response_latency_max_changed = 0;
    reg stats_write_address_response_latency_mean_changed = 0;
    reg stats_write_address_address_latency_inst_changed = 0;
    reg stats_write_address_address_latency_sw_changed = 0;
    reg stats_write_address_address_latency_min_changed = 0;
    reg stats_write_address_address_latency_max_changed = 0;
    reg stats_write_address_address_latency_mean_changed = 0;
    reg config_stats_read_address_waits_step_changed = 0;
    reg config_stats_read_address_waits_multiple_changed = 0;
    reg stats_read_address_waits_inst_changed = 0;
    reg stats_read_address_waits_sw_changed = 0;
    reg stats_read_address_waits_min_changed = 0;
    reg stats_read_address_waits_max_changed = 0;
    reg stats_read_address_waits_mean_changed = 0;
    reg config_stats_read_data_waits_step_changed = 0;
    reg config_stats_read_data_waits_multiple_changed = 0;
    reg stats_read_data_waits_inst_changed = 0;
    reg stats_read_data_waits_sw_changed = 0;
    reg stats_read_data_waits_min_changed = 0;
    reg stats_read_data_waits_max_changed = 0;
    reg stats_read_data_waits_mean_changed = 0;
    reg config_stats_write_address_waits_step_changed = 0;
    reg config_stats_write_address_waits_multiple_changed = 0;
    reg stats_write_address_waits_inst_changed = 0;
    reg stats_write_address_waits_sw_changed = 0;
    reg stats_write_address_waits_min_changed = 0;
    reg stats_write_address_waits_max_changed = 0;
    reg stats_write_address_waits_mean_changed = 0;
    reg config_stats_write_data_waits_step_changed = 0;
    reg config_stats_write_data_waits_multiple_changed = 0;
    reg stats_write_data_waits_inst_changed = 0;
    reg stats_write_data_waits_sw_changed = 0;
    reg stats_write_data_waits_min_changed = 0;
    reg stats_write_data_waits_max_changed = 0;
    reg stats_write_data_waits_mean_changed = 0;
    reg config_stats_write_response_waits_step_changed = 0;
    reg config_stats_write_response_waits_multiple_changed = 0;
    reg stats_write_response_waits_inst_changed = 0;
    reg stats_write_response_waits_sw_changed = 0;
    reg stats_write_response_waits_min_changed = 0;
    reg stats_write_response_waits_max_changed = 0;
    reg stats_write_response_waits_mean_changed = 0;
    reg reordering_depth_of_last_read_transaction_changed = 0;

    reg end_of_timestep_control = 0;


    // SV wire change monitors

    function automatic void axi4_local_set_ACLK_from_SystemVerilog(  );
            axi4_set_ACLK_from_SystemVerilog(ACLK); // DPI call to imported task
        
        axi4_propagate_ACLK_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ACLK or posedge _check_t0_values )
    begin
        axi4_local_set_ACLK_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARESETn_from_SystemVerilog(  );
            axi4_set_ARESETn_from_SystemVerilog(ARESETn); // DPI call to imported task
        
        axi4_propagate_ARESETn_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARESETn or posedge _check_t0_values )
    begin
        axi4_local_set_ARESETn_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWVALID_from_SystemVerilog(  );
            axi4_set_AWVALID_from_SystemVerilog(AWVALID); // DPI call to imported task
        
        axi4_propagate_AWVALID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWVALID or posedge _check_t0_values )
    begin
        axi4_local_set_AWVALID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWADDR_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_ADDRESS_WIDTH ); _this_dot_1++)
        begin
            axi4_set_AWADDR_from_SystemVerilog_index1(_this_dot_1,AWADDR[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_AWADDR_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWADDR or posedge _check_t0_values )
    begin
        axi4_local_set_AWADDR_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWPROT_from_SystemVerilog(  );
            axi4_set_AWPROT_from_SystemVerilog(AWPROT); // DPI call to imported task
        
        axi4_propagate_AWPROT_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWPROT or posedge _check_t0_values )
    begin
        axi4_local_set_AWPROT_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWREGION_from_SystemVerilog(  );
            axi4_set_AWREGION_from_SystemVerilog(AWREGION); // DPI call to imported task
        
        axi4_propagate_AWREGION_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWREGION or posedge _check_t0_values )
    begin
        axi4_local_set_AWREGION_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWLEN_from_SystemVerilog(  );
            axi4_set_AWLEN_from_SystemVerilog(AWLEN); // DPI call to imported task
        
        axi4_propagate_AWLEN_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWLEN or posedge _check_t0_values )
    begin
        axi4_local_set_AWLEN_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWSIZE_from_SystemVerilog(  );
            axi4_set_AWSIZE_from_SystemVerilog(AWSIZE); // DPI call to imported task
        
        axi4_propagate_AWSIZE_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWSIZE or posedge _check_t0_values )
    begin
        axi4_local_set_AWSIZE_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWBURST_from_SystemVerilog(  );
            axi4_set_AWBURST_from_SystemVerilog(AWBURST); // DPI call to imported task
        
        axi4_propagate_AWBURST_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWBURST or posedge _check_t0_values )
    begin
        axi4_local_set_AWBURST_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWLOCK_from_SystemVerilog(  );
            axi4_set_AWLOCK_from_SystemVerilog(AWLOCK); // DPI call to imported task
        
        axi4_propagate_AWLOCK_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWLOCK or posedge _check_t0_values )
    begin
        axi4_local_set_AWLOCK_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWCACHE_from_SystemVerilog(  );
            axi4_set_AWCACHE_from_SystemVerilog(AWCACHE); // DPI call to imported task
        
        axi4_propagate_AWCACHE_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWCACHE or posedge _check_t0_values )
    begin
        axi4_local_set_AWCACHE_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWQOS_from_SystemVerilog(  );
            axi4_set_AWQOS_from_SystemVerilog(AWQOS); // DPI call to imported task
        
        axi4_propagate_AWQOS_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWQOS or posedge _check_t0_values )
    begin
        axi4_local_set_AWQOS_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWID_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_ID_WIDTH ); _this_dot_1++)
        begin
            axi4_set_AWID_from_SystemVerilog_index1(_this_dot_1,AWID[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_AWID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWID or posedge _check_t0_values )
    begin
        axi4_local_set_AWID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWUSER_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_USER_WIDTH ); _this_dot_1++)
        begin
            axi4_set_AWUSER_from_SystemVerilog_index1(_this_dot_1,AWUSER[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_AWUSER_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWUSER or posedge _check_t0_values )
    begin
        axi4_local_set_AWUSER_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_AWREADY_from_SystemVerilog(  );
            axi4_set_AWREADY_from_SystemVerilog(AWREADY); // DPI call to imported task
        
        axi4_propagate_AWREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( AWREADY or posedge _check_t0_values )
    begin
        axi4_local_set_AWREADY_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARVALID_from_SystemVerilog(  );
            axi4_set_ARVALID_from_SystemVerilog(ARVALID); // DPI call to imported task
        
        axi4_propagate_ARVALID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARVALID or posedge _check_t0_values )
    begin
        axi4_local_set_ARVALID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARADDR_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_ADDRESS_WIDTH ); _this_dot_1++)
        begin
            axi4_set_ARADDR_from_SystemVerilog_index1(_this_dot_1,ARADDR[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_ARADDR_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARADDR or posedge _check_t0_values )
    begin
        axi4_local_set_ARADDR_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARPROT_from_SystemVerilog(  );
            axi4_set_ARPROT_from_SystemVerilog(ARPROT); // DPI call to imported task
        
        axi4_propagate_ARPROT_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARPROT or posedge _check_t0_values )
    begin
        axi4_local_set_ARPROT_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARREGION_from_SystemVerilog(  );
            axi4_set_ARREGION_from_SystemVerilog(ARREGION); // DPI call to imported task
        
        axi4_propagate_ARREGION_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARREGION or posedge _check_t0_values )
    begin
        axi4_local_set_ARREGION_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARLEN_from_SystemVerilog(  );
            axi4_set_ARLEN_from_SystemVerilog(ARLEN); // DPI call to imported task
        
        axi4_propagate_ARLEN_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARLEN or posedge _check_t0_values )
    begin
        axi4_local_set_ARLEN_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARSIZE_from_SystemVerilog(  );
            axi4_set_ARSIZE_from_SystemVerilog(ARSIZE); // DPI call to imported task
        
        axi4_propagate_ARSIZE_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARSIZE or posedge _check_t0_values )
    begin
        axi4_local_set_ARSIZE_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARBURST_from_SystemVerilog(  );
            axi4_set_ARBURST_from_SystemVerilog(ARBURST); // DPI call to imported task
        
        axi4_propagate_ARBURST_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARBURST or posedge _check_t0_values )
    begin
        axi4_local_set_ARBURST_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARLOCK_from_SystemVerilog(  );
            axi4_set_ARLOCK_from_SystemVerilog(ARLOCK); // DPI call to imported task
        
        axi4_propagate_ARLOCK_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARLOCK or posedge _check_t0_values )
    begin
        axi4_local_set_ARLOCK_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARCACHE_from_SystemVerilog(  );
            axi4_set_ARCACHE_from_SystemVerilog(ARCACHE); // DPI call to imported task
        
        axi4_propagate_ARCACHE_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARCACHE or posedge _check_t0_values )
    begin
        axi4_local_set_ARCACHE_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARQOS_from_SystemVerilog(  );
            axi4_set_ARQOS_from_SystemVerilog(ARQOS); // DPI call to imported task
        
        axi4_propagate_ARQOS_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARQOS or posedge _check_t0_values )
    begin
        axi4_local_set_ARQOS_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARID_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_ID_WIDTH ); _this_dot_1++)
        begin
            axi4_set_ARID_from_SystemVerilog_index1(_this_dot_1,ARID[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_ARID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARID or posedge _check_t0_values )
    begin
        axi4_local_set_ARID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARUSER_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_USER_WIDTH ); _this_dot_1++)
        begin
            axi4_set_ARUSER_from_SystemVerilog_index1(_this_dot_1,ARUSER[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_ARUSER_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARUSER or posedge _check_t0_values )
    begin
        axi4_local_set_ARUSER_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_ARREADY_from_SystemVerilog(  );
            axi4_set_ARREADY_from_SystemVerilog(ARREADY); // DPI call to imported task
        
        axi4_propagate_ARREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( ARREADY or posedge _check_t0_values )
    begin
        axi4_local_set_ARREADY_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_RVALID_from_SystemVerilog(  );
            axi4_set_RVALID_from_SystemVerilog(RVALID); // DPI call to imported task
        
        axi4_propagate_RVALID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RVALID or posedge _check_t0_values )
    begin
        axi4_local_set_RVALID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_RDATA_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_RDATA_WIDTH ); _this_dot_1++)
        begin
            axi4_set_RDATA_from_SystemVerilog_index1(_this_dot_1,RDATA[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_RDATA_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RDATA or posedge _check_t0_values )
    begin
        axi4_local_set_RDATA_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_RRESP_from_SystemVerilog(  );
            axi4_set_RRESP_from_SystemVerilog(RRESP); // DPI call to imported task
        
        axi4_propagate_RRESP_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RRESP or posedge _check_t0_values )
    begin
        axi4_local_set_RRESP_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_RLAST_from_SystemVerilog(  );
            axi4_set_RLAST_from_SystemVerilog(RLAST); // DPI call to imported task
        
        axi4_propagate_RLAST_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RLAST or posedge _check_t0_values )
    begin
        axi4_local_set_RLAST_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_RID_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_ID_WIDTH ); _this_dot_1++)
        begin
            axi4_set_RID_from_SystemVerilog_index1(_this_dot_1,RID[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_RID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RID or posedge _check_t0_values )
    begin
        axi4_local_set_RID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_RUSER_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_USER_WIDTH ); _this_dot_1++)
        begin
            axi4_set_RUSER_from_SystemVerilog_index1(_this_dot_1,RUSER[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_RUSER_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RUSER or posedge _check_t0_values )
    begin
        axi4_local_set_RUSER_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_RREADY_from_SystemVerilog(  );
            axi4_set_RREADY_from_SystemVerilog(RREADY); // DPI call to imported task
        
        axi4_propagate_RREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( RREADY or posedge _check_t0_values )
    begin
        axi4_local_set_RREADY_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_WVALID_from_SystemVerilog(  );
            axi4_set_WVALID_from_SystemVerilog(WVALID); // DPI call to imported task
        
        axi4_propagate_WVALID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WVALID or posedge _check_t0_values )
    begin
        axi4_local_set_WVALID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_WDATA_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_WDATA_WIDTH ); _this_dot_1++)
        begin
            axi4_set_WDATA_from_SystemVerilog_index1(_this_dot_1,WDATA[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_WDATA_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WDATA or posedge _check_t0_values )
    begin
        axi4_local_set_WDATA_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_WSTRB_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( (AXI4_WDATA_WIDTH / 8) ); _this_dot_1++)
        begin
            axi4_set_WSTRB_from_SystemVerilog_index1(_this_dot_1,WSTRB[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_WSTRB_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WSTRB or posedge _check_t0_values )
    begin
        axi4_local_set_WSTRB_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_WLAST_from_SystemVerilog(  );
            axi4_set_WLAST_from_SystemVerilog(WLAST); // DPI call to imported task
        
        axi4_propagate_WLAST_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WLAST or posedge _check_t0_values )
    begin
        axi4_local_set_WLAST_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_WUSER_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_USER_WIDTH ); _this_dot_1++)
        begin
            axi4_set_WUSER_from_SystemVerilog_index1(_this_dot_1,WUSER[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_WUSER_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WUSER or posedge _check_t0_values )
    begin
        axi4_local_set_WUSER_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_WREADY_from_SystemVerilog(  );
            axi4_set_WREADY_from_SystemVerilog(WREADY); // DPI call to imported task
        
        axi4_propagate_WREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( WREADY or posedge _check_t0_values )
    begin
        axi4_local_set_WREADY_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_BVALID_from_SystemVerilog(  );
            axi4_set_BVALID_from_SystemVerilog(BVALID); // DPI call to imported task
        
        axi4_propagate_BVALID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( BVALID or posedge _check_t0_values )
    begin
        axi4_local_set_BVALID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_BRESP_from_SystemVerilog(  );
            axi4_set_BRESP_from_SystemVerilog(BRESP); // DPI call to imported task
        
        axi4_propagate_BRESP_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( BRESP or posedge _check_t0_values )
    begin
        axi4_local_set_BRESP_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_BID_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_ID_WIDTH ); _this_dot_1++)
        begin
            axi4_set_BID_from_SystemVerilog_index1(_this_dot_1,BID[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_BID_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( BID or posedge _check_t0_values )
    begin
        axi4_local_set_BID_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_BUSER_from_SystemVerilog(  );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_USER_WIDTH ); _this_dot_1++)
        begin
            axi4_set_BUSER_from_SystemVerilog_index1(_this_dot_1,BUSER[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
        axi4_propagate_BUSER_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( BUSER or posedge _check_t0_values )
    begin
        axi4_local_set_BUSER_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end

    function automatic void axi4_local_set_BREADY_from_SystemVerilog(  );
            axi4_set_BREADY_from_SystemVerilog(BREADY); // DPI call to imported task
        
        axi4_propagate_BREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    always @( BREADY or posedge _check_t0_values )
    begin
        axi4_local_set_BREADY_from_SystemVerilog(); // Call to local task which flattens data as necessary
    end


    // CY wire and variable changed flag monitors

    always @(posedge ACLK_changed or posedge _check_t0_values )
    begin
        while (ACLK_changed == 1'b1)
        begin
            axi4_get_ACLK_into_SystemVerilog(  ); // DPI call to imported task
            ACLK_changed = 1'b0;
            #0  #0 if ( ACLK !== internal_ACLK )
            begin
                axi4_local_set_ACLK_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARESETn_changed or posedge _check_t0_values )
    begin
        while (ARESETn_changed == 1'b1)
        begin
            axi4_get_ARESETn_into_SystemVerilog(  ); // DPI call to imported task
            ARESETn_changed = 1'b0;
            #0  #0 if ( ARESETn !== internal_ARESETn )
            begin
                axi4_local_set_ARESETn_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWVALID_changed or posedge _check_t0_values )
    begin
        while (AWVALID_changed == 1'b1)
        begin
            axi4_get_AWVALID_into_SystemVerilog(  ); // DPI call to imported task
            AWVALID_changed = 1'b0;
            #0  #0 if ( AWVALID !== internal_AWVALID )
            begin
                axi4_local_set_AWVALID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWADDR_changed or posedge _check_t0_values )
    begin
        while (AWADDR_changed == 1'b1)
        begin
            axi4_get_AWADDR_into_SystemVerilog(  ); // DPI call to imported task
            AWADDR_changed = 1'b0;
            #0  #0 if ( AWADDR !== internal_AWADDR )
            begin
                axi4_local_set_AWADDR_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWPROT_changed or posedge _check_t0_values )
    begin
        while (AWPROT_changed == 1'b1)
        begin
            axi4_get_AWPROT_into_SystemVerilog(  ); // DPI call to imported task
            AWPROT_changed = 1'b0;
            #0  #0 if ( AWPROT !== internal_AWPROT )
            begin
                axi4_local_set_AWPROT_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWREGION_changed or posedge _check_t0_values )
    begin
        while (AWREGION_changed == 1'b1)
        begin
            axi4_get_AWREGION_into_SystemVerilog(  ); // DPI call to imported task
            AWREGION_changed = 1'b0;
            #0  #0 if ( AWREGION !== internal_AWREGION )
            begin
                axi4_local_set_AWREGION_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWLEN_changed or posedge _check_t0_values )
    begin
        while (AWLEN_changed == 1'b1)
        begin
            axi4_get_AWLEN_into_SystemVerilog(  ); // DPI call to imported task
            AWLEN_changed = 1'b0;
            #0  #0 if ( AWLEN !== internal_AWLEN )
            begin
                axi4_local_set_AWLEN_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWSIZE_changed or posedge _check_t0_values )
    begin
        while (AWSIZE_changed == 1'b1)
        begin
            axi4_get_AWSIZE_into_SystemVerilog(  ); // DPI call to imported task
            AWSIZE_changed = 1'b0;
            #0  #0 if ( AWSIZE !== internal_AWSIZE )
            begin
                axi4_local_set_AWSIZE_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWBURST_changed or posedge _check_t0_values )
    begin
        while (AWBURST_changed == 1'b1)
        begin
            axi4_get_AWBURST_into_SystemVerilog(  ); // DPI call to imported task
            AWBURST_changed = 1'b0;
            #0  #0 if ( AWBURST !== internal_AWBURST )
            begin
                axi4_local_set_AWBURST_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWLOCK_changed or posedge _check_t0_values )
    begin
        while (AWLOCK_changed == 1'b1)
        begin
            axi4_get_AWLOCK_into_SystemVerilog(  ); // DPI call to imported task
            AWLOCK_changed = 1'b0;
            #0  #0 if ( AWLOCK !== internal_AWLOCK )
            begin
                axi4_local_set_AWLOCK_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWCACHE_changed or posedge _check_t0_values )
    begin
        while (AWCACHE_changed == 1'b1)
        begin
            axi4_get_AWCACHE_into_SystemVerilog(  ); // DPI call to imported task
            AWCACHE_changed = 1'b0;
            #0  #0 if ( AWCACHE !== internal_AWCACHE )
            begin
                axi4_local_set_AWCACHE_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWQOS_changed or posedge _check_t0_values )
    begin
        while (AWQOS_changed == 1'b1)
        begin
            axi4_get_AWQOS_into_SystemVerilog(  ); // DPI call to imported task
            AWQOS_changed = 1'b0;
            #0  #0 if ( AWQOS !== internal_AWQOS )
            begin
                axi4_local_set_AWQOS_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWID_changed or posedge _check_t0_values )
    begin
        while (AWID_changed == 1'b1)
        begin
            axi4_get_AWID_into_SystemVerilog(  ); // DPI call to imported task
            AWID_changed = 1'b0;
            #0  #0 if ( AWID !== internal_AWID )
            begin
                axi4_local_set_AWID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWUSER_changed or posedge _check_t0_values )
    begin
        while (AWUSER_changed == 1'b1)
        begin
            axi4_get_AWUSER_into_SystemVerilog(  ); // DPI call to imported task
            AWUSER_changed = 1'b0;
            #0  #0 if ( AWUSER !== internal_AWUSER )
            begin
                axi4_local_set_AWUSER_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge AWREADY_changed or posedge _check_t0_values )
    begin
        while (AWREADY_changed == 1'b1)
        begin
            axi4_get_AWREADY_into_SystemVerilog(  ); // DPI call to imported task
            AWREADY_changed = 1'b0;
            #0  #0 if ( AWREADY !== internal_AWREADY )
            begin
                axi4_local_set_AWREADY_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARVALID_changed or posedge _check_t0_values )
    begin
        while (ARVALID_changed == 1'b1)
        begin
            axi4_get_ARVALID_into_SystemVerilog(  ); // DPI call to imported task
            ARVALID_changed = 1'b0;
            #0  #0 if ( ARVALID !== internal_ARVALID )
            begin
                axi4_local_set_ARVALID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARADDR_changed or posedge _check_t0_values )
    begin
        while (ARADDR_changed == 1'b1)
        begin
            axi4_get_ARADDR_into_SystemVerilog(  ); // DPI call to imported task
            ARADDR_changed = 1'b0;
            #0  #0 if ( ARADDR !== internal_ARADDR )
            begin
                axi4_local_set_ARADDR_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARPROT_changed or posedge _check_t0_values )
    begin
        while (ARPROT_changed == 1'b1)
        begin
            axi4_get_ARPROT_into_SystemVerilog(  ); // DPI call to imported task
            ARPROT_changed = 1'b0;
            #0  #0 if ( ARPROT !== internal_ARPROT )
            begin
                axi4_local_set_ARPROT_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARREGION_changed or posedge _check_t0_values )
    begin
        while (ARREGION_changed == 1'b1)
        begin
            axi4_get_ARREGION_into_SystemVerilog(  ); // DPI call to imported task
            ARREGION_changed = 1'b0;
            #0  #0 if ( ARREGION !== internal_ARREGION )
            begin
                axi4_local_set_ARREGION_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARLEN_changed or posedge _check_t0_values )
    begin
        while (ARLEN_changed == 1'b1)
        begin
            axi4_get_ARLEN_into_SystemVerilog(  ); // DPI call to imported task
            ARLEN_changed = 1'b0;
            #0  #0 if ( ARLEN !== internal_ARLEN )
            begin
                axi4_local_set_ARLEN_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARSIZE_changed or posedge _check_t0_values )
    begin
        while (ARSIZE_changed == 1'b1)
        begin
            axi4_get_ARSIZE_into_SystemVerilog(  ); // DPI call to imported task
            ARSIZE_changed = 1'b0;
            #0  #0 if ( ARSIZE !== internal_ARSIZE )
            begin
                axi4_local_set_ARSIZE_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARBURST_changed or posedge _check_t0_values )
    begin
        while (ARBURST_changed == 1'b1)
        begin
            axi4_get_ARBURST_into_SystemVerilog(  ); // DPI call to imported task
            ARBURST_changed = 1'b0;
            #0  #0 if ( ARBURST !== internal_ARBURST )
            begin
                axi4_local_set_ARBURST_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARLOCK_changed or posedge _check_t0_values )
    begin
        while (ARLOCK_changed == 1'b1)
        begin
            axi4_get_ARLOCK_into_SystemVerilog(  ); // DPI call to imported task
            ARLOCK_changed = 1'b0;
            #0  #0 if ( ARLOCK !== internal_ARLOCK )
            begin
                axi4_local_set_ARLOCK_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARCACHE_changed or posedge _check_t0_values )
    begin
        while (ARCACHE_changed == 1'b1)
        begin
            axi4_get_ARCACHE_into_SystemVerilog(  ); // DPI call to imported task
            ARCACHE_changed = 1'b0;
            #0  #0 if ( ARCACHE !== internal_ARCACHE )
            begin
                axi4_local_set_ARCACHE_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARQOS_changed or posedge _check_t0_values )
    begin
        while (ARQOS_changed == 1'b1)
        begin
            axi4_get_ARQOS_into_SystemVerilog(  ); // DPI call to imported task
            ARQOS_changed = 1'b0;
            #0  #0 if ( ARQOS !== internal_ARQOS )
            begin
                axi4_local_set_ARQOS_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARID_changed or posedge _check_t0_values )
    begin
        while (ARID_changed == 1'b1)
        begin
            axi4_get_ARID_into_SystemVerilog(  ); // DPI call to imported task
            ARID_changed = 1'b0;
            #0  #0 if ( ARID !== internal_ARID )
            begin
                axi4_local_set_ARID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARUSER_changed or posedge _check_t0_values )
    begin
        while (ARUSER_changed == 1'b1)
        begin
            axi4_get_ARUSER_into_SystemVerilog(  ); // DPI call to imported task
            ARUSER_changed = 1'b0;
            #0  #0 if ( ARUSER !== internal_ARUSER )
            begin
                axi4_local_set_ARUSER_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge ARREADY_changed or posedge _check_t0_values )
    begin
        while (ARREADY_changed == 1'b1)
        begin
            axi4_get_ARREADY_into_SystemVerilog(  ); // DPI call to imported task
            ARREADY_changed = 1'b0;
            #0  #0 if ( ARREADY !== internal_ARREADY )
            begin
                axi4_local_set_ARREADY_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RVALID_changed or posedge _check_t0_values )
    begin
        while (RVALID_changed == 1'b1)
        begin
            axi4_get_RVALID_into_SystemVerilog(  ); // DPI call to imported task
            RVALID_changed = 1'b0;
            #0  #0 if ( RVALID !== internal_RVALID )
            begin
                axi4_local_set_RVALID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RDATA_changed or posedge _check_t0_values )
    begin
        while (RDATA_changed == 1'b1)
        begin
            axi4_get_RDATA_into_SystemVerilog(  ); // DPI call to imported task
            RDATA_changed = 1'b0;
            #0  #0 if ( RDATA !== internal_RDATA )
            begin
                axi4_local_set_RDATA_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RRESP_changed or posedge _check_t0_values )
    begin
        while (RRESP_changed == 1'b1)
        begin
            axi4_get_RRESP_into_SystemVerilog(  ); // DPI call to imported task
            RRESP_changed = 1'b0;
            #0  #0 if ( RRESP !== internal_RRESP )
            begin
                axi4_local_set_RRESP_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RLAST_changed or posedge _check_t0_values )
    begin
        while (RLAST_changed == 1'b1)
        begin
            axi4_get_RLAST_into_SystemVerilog(  ); // DPI call to imported task
            RLAST_changed = 1'b0;
            #0  #0 if ( RLAST !== internal_RLAST )
            begin
                axi4_local_set_RLAST_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RID_changed or posedge _check_t0_values )
    begin
        while (RID_changed == 1'b1)
        begin
            axi4_get_RID_into_SystemVerilog(  ); // DPI call to imported task
            RID_changed = 1'b0;
            #0  #0 if ( RID !== internal_RID )
            begin
                axi4_local_set_RID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RUSER_changed or posedge _check_t0_values )
    begin
        while (RUSER_changed == 1'b1)
        begin
            axi4_get_RUSER_into_SystemVerilog(  ); // DPI call to imported task
            RUSER_changed = 1'b0;
            #0  #0 if ( RUSER !== internal_RUSER )
            begin
                axi4_local_set_RUSER_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge RREADY_changed or posedge _check_t0_values )
    begin
        while (RREADY_changed == 1'b1)
        begin
            axi4_get_RREADY_into_SystemVerilog(  ); // DPI call to imported task
            RREADY_changed = 1'b0;
            #0  #0 if ( RREADY !== internal_RREADY )
            begin
                axi4_local_set_RREADY_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WVALID_changed or posedge _check_t0_values )
    begin
        while (WVALID_changed == 1'b1)
        begin
            axi4_get_WVALID_into_SystemVerilog(  ); // DPI call to imported task
            WVALID_changed = 1'b0;
            #0  #0 if ( WVALID !== internal_WVALID )
            begin
                axi4_local_set_WVALID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WDATA_changed or posedge _check_t0_values )
    begin
        while (WDATA_changed == 1'b1)
        begin
            axi4_get_WDATA_into_SystemVerilog(  ); // DPI call to imported task
            WDATA_changed = 1'b0;
            #0  #0 if ( WDATA !== internal_WDATA )
            begin
                axi4_local_set_WDATA_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WSTRB_changed or posedge _check_t0_values )
    begin
        while (WSTRB_changed == 1'b1)
        begin
            axi4_get_WSTRB_into_SystemVerilog(  ); // DPI call to imported task
            WSTRB_changed = 1'b0;
            #0  #0 if ( WSTRB !== internal_WSTRB )
            begin
                axi4_local_set_WSTRB_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WLAST_changed or posedge _check_t0_values )
    begin
        while (WLAST_changed == 1'b1)
        begin
            axi4_get_WLAST_into_SystemVerilog(  ); // DPI call to imported task
            WLAST_changed = 1'b0;
            #0  #0 if ( WLAST !== internal_WLAST )
            begin
                axi4_local_set_WLAST_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WUSER_changed or posedge _check_t0_values )
    begin
        while (WUSER_changed == 1'b1)
        begin
            axi4_get_WUSER_into_SystemVerilog(  ); // DPI call to imported task
            WUSER_changed = 1'b0;
            #0  #0 if ( WUSER !== internal_WUSER )
            begin
                axi4_local_set_WUSER_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge WREADY_changed or posedge _check_t0_values )
    begin
        while (WREADY_changed == 1'b1)
        begin
            axi4_get_WREADY_into_SystemVerilog(  ); // DPI call to imported task
            WREADY_changed = 1'b0;
            #0  #0 if ( WREADY !== internal_WREADY )
            begin
                axi4_local_set_WREADY_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge BVALID_changed or posedge _check_t0_values )
    begin
        while (BVALID_changed == 1'b1)
        begin
            axi4_get_BVALID_into_SystemVerilog(  ); // DPI call to imported task
            BVALID_changed = 1'b0;
            #0  #0 if ( BVALID !== internal_BVALID )
            begin
                axi4_local_set_BVALID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge BRESP_changed or posedge _check_t0_values )
    begin
        while (BRESP_changed == 1'b1)
        begin
            axi4_get_BRESP_into_SystemVerilog(  ); // DPI call to imported task
            BRESP_changed = 1'b0;
            #0  #0 if ( BRESP !== internal_BRESP )
            begin
                axi4_local_set_BRESP_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge BID_changed or posedge _check_t0_values )
    begin
        while (BID_changed == 1'b1)
        begin
            axi4_get_BID_into_SystemVerilog(  ); // DPI call to imported task
            BID_changed = 1'b0;
            #0  #0 if ( BID !== internal_BID )
            begin
                axi4_local_set_BID_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge BUSER_changed or posedge _check_t0_values )
    begin
        while (BUSER_changed == 1'b1)
        begin
            axi4_get_BUSER_into_SystemVerilog(  ); // DPI call to imported task
            BUSER_changed = 1'b0;
            #0  #0 if ( BUSER !== internal_BUSER )
            begin
                axi4_local_set_BUSER_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge BREADY_changed or posedge _check_t0_values )
    begin
        while (BREADY_changed == 1'b1)
        begin
            axi4_get_BREADY_into_SystemVerilog(  ); // DPI call to imported task
            BREADY_changed = 1'b0;
            #0  #0 if ( BREADY !== internal_BREADY )
            begin
                axi4_local_set_BREADY_from_SystemVerilog(  );
            end
        end
    end

    always @(posedge config_interface_type_changed or posedge _check_t0_values )
    begin
        if (config_interface_type_changed == 1'b1)
        begin
            axi4_get_config_interface_type_into_SystemVerilog(  ); // DPI call to imported task
            config_interface_type_changed = 1'b0;
        end
    end

    always @(posedge config_clk_init_value_changed or posedge _check_t0_values )
    begin
        if (config_clk_init_value_changed == 1'b1)
        begin
            axi4_get_config_clk_init_value_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_init_value_changed = 1'b0;
        end
    end

    always @(posedge config_clk_phase_shift_changed or posedge _check_t0_values )
    begin
        if (config_clk_phase_shift_changed == 1'b1)
        begin
            axi4_get_config_clk_phase_shift_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_phase_shift_changed = 1'b0;
        end
    end

    always @(posedge config_clk_1st_time_changed or posedge _check_t0_values )
    begin
        if (config_clk_1st_time_changed == 1'b1)
        begin
            axi4_get_config_clk_1st_time_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_1st_time_changed = 1'b0;
        end
    end

    always @(posedge config_clk_2nd_time_changed or posedge _check_t0_values )
    begin
        if (config_clk_2nd_time_changed == 1'b1)
        begin
            axi4_get_config_clk_2nd_time_into_SystemVerilog(  ); // DPI call to imported task
            config_clk_2nd_time_changed = 1'b0;
        end
    end

    always @(posedge config_setup_time_changed or posedge _check_t0_values )
    begin
        if (config_setup_time_changed == 1'b1)
        begin
            axi4_get_config_setup_time_into_SystemVerilog(  ); // DPI call to imported task
            config_setup_time_changed = 1'b0;
        end
    end

    always @(posedge config_hold_time_changed or posedge _check_t0_values )
    begin
        if (config_hold_time_changed == 1'b1)
        begin
            axi4_get_config_hold_time_into_SystemVerilog(  ); // DPI call to imported task
            config_hold_time_changed = 1'b0;
        end
    end

    always @(posedge config_burst_timeout_factor_changed or posedge _check_t0_values )
    begin
        if (config_burst_timeout_factor_changed == 1'b1)
        begin
            axi4_get_config_burst_timeout_factor_into_SystemVerilog(  ); // DPI call to imported task
            config_burst_timeout_factor_changed = 1'b0;
        end
    end

    always @(posedge config_max_transaction_time_factor_changed or posedge _check_t0_values )
    begin
        if (config_max_transaction_time_factor_changed == 1'b1)
        begin
            axi4_get_config_max_transaction_time_factor_into_SystemVerilog(  ); // DPI call to imported task
            config_max_transaction_time_factor_changed = 1'b0;
        end
    end

    always @(posedge config_write_ctrl_first_ratio_changed or posedge _check_t0_values )
    begin
        if (config_write_ctrl_first_ratio_changed == 1'b1)
        begin
            axi4_get_config_write_ctrl_first_ratio_into_SystemVerilog(  ); // DPI call to imported task
            config_write_ctrl_first_ratio_changed = 1'b0;
        end
    end

    always @(posedge config_write_data_first_ratio_changed or posedge _check_t0_values )
    begin
        if (config_write_data_first_ratio_changed == 1'b1)
        begin
            axi4_get_config_write_data_first_ratio_into_SystemVerilog(  ); // DPI call to imported task
            config_write_data_first_ratio_changed = 1'b0;
        end
    end

    always @(posedge config_reset_low_clocks_changed or posedge _check_t0_values )
    begin
        if (config_reset_low_clocks_changed == 1'b1)
        begin
            axi4_get_config_reset_low_clocks_into_SystemVerilog(  ); // DPI call to imported task
            config_reset_low_clocks_changed = 1'b0;
        end
    end

    always @(posedge config_reset_hold_time_changed or posedge _check_t0_values )
    begin
        if (config_reset_hold_time_changed == 1'b1)
        begin
            axi4_get_config_reset_hold_time_into_SystemVerilog(  ); // DPI call to imported task
            config_reset_hold_time_changed = 1'b0;
        end
    end

    always @(posedge config_enable_rlast_changed or posedge _check_t0_values )
    begin
        if (config_enable_rlast_changed == 1'b1)
        begin
            axi4_get_config_enable_rlast_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_rlast_changed = 1'b0;
        end
    end

    always @(posedge config_enable_slave_exclusive_changed or posedge _check_t0_values )
    begin
        if (config_enable_slave_exclusive_changed == 1'b1)
        begin
            axi4_get_config_enable_slave_exclusive_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_slave_exclusive_changed = 1'b0;
        end
    end

    always @(posedge config_enable_burst_reserved_value_changed or posedge _check_t0_values )
    begin
        if (config_enable_burst_reserved_value_changed == 1'b1)
        begin
            axi4_get_config_enable_burst_reserved_value_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_burst_reserved_value_changed = 1'b0;
        end
    end

    always @(posedge config_enable_cache_value_changed or posedge _check_t0_values )
    begin
        if (config_enable_cache_value_changed == 1'b1)
        begin
            axi4_get_config_enable_cache_value_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_cache_value_changed = 1'b0;
        end
    end

    always @(posedge internal_dummy_variable_changed or posedge _check_t0_values )
    begin
        if (internal_dummy_variable_changed == 1'b1)
        begin
            axi4_get_internal_dummy_variable_into_SystemVerilog(  ); // DPI call to imported task
            internal_dummy_variable_changed = 1'b0;
        end
    end

    always @(posedge config_axi4lite_interface_changed or posedge _check_t0_values )
    begin
        if (config_axi4lite_interface_changed == 1'b1)
        begin
            axi4_get_config_axi4lite_interface_into_SystemVerilog(  ); // DPI call to imported task
            config_axi4lite_interface_changed = 1'b0;
        end
    end

    always @(posedge config_axi4lite_tr_id_changed or posedge _check_t0_values )
    begin
        if (config_axi4lite_tr_id_changed == 1'b1)
        begin
            axi4_get_config_axi4lite_tr_id_into_SystemVerilog(  ); // DPI call to imported task
            config_axi4lite_tr_id_changed = 1'b0;
        end
    end

    always @(posedge config_enable_all_assertions_changed or posedge _check_t0_values )
    begin
        if (config_enable_all_assertions_changed == 1'b1)
        begin
            axi4_get_config_enable_all_assertions_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_all_assertions_changed = 1'b0;
        end
    end

    always @(posedge config_enable_assertion_changed or posedge _check_t0_values )
    begin
        if (config_enable_assertion_changed == 1'b1)
        begin
            axi4_get_config_enable_assertion_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_assertion_changed = 1'b0;
        end
    end

    always @(posedge config_enable_error_changed or posedge _check_t0_values )
    begin
        if (config_enable_error_changed == 1'b1)
        begin
            axi4_get_config_enable_error_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_error_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_AWVALID_assertion_to_AWREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_AWVALID_assertion_to_AWREADY_changed == 1'b1)
        begin
            axi4_get_config_max_latency_AWVALID_assertion_to_AWREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_AWVALID_assertion_to_AWREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_ARVALID_assertion_to_ARREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_ARVALID_assertion_to_ARREADY_changed == 1'b1)
        begin
            axi4_get_config_max_latency_ARVALID_assertion_to_ARREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_ARVALID_assertion_to_ARREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_RVALID_assertion_to_RREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_RVALID_assertion_to_RREADY_changed == 1'b1)
        begin
            axi4_get_config_max_latency_RVALID_assertion_to_RREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_RVALID_assertion_to_RREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_BVALID_assertion_to_BREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_BVALID_assertion_to_BREADY_changed == 1'b1)
        begin
            axi4_get_config_max_latency_BVALID_assertion_to_BREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_BVALID_assertion_to_BREADY_changed = 1'b0;
        end
    end

    always @(posedge config_max_latency_WVALID_assertion_to_WREADY_changed or posedge _check_t0_values )
    begin
        if (config_max_latency_WVALID_assertion_to_WREADY_changed == 1'b1)
        begin
            axi4_get_config_max_latency_WVALID_assertion_to_WREADY_into_SystemVerilog(  ); // DPI call to imported task
            config_max_latency_WVALID_assertion_to_WREADY_changed = 1'b0;
        end
    end

    always @(posedge config_enable_qos_changed or posedge _check_t0_values )
    begin
        if (config_enable_qos_changed == 1'b1)
        begin
            axi4_get_config_enable_qos_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_qos_changed = 1'b0;
        end
    end

    always @(posedge config_enable_region_support_changed or posedge _check_t0_values )
    begin
        if (config_enable_region_support_changed == 1'b1)
        begin
            axi4_get_config_enable_region_support_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_region_support_changed = 1'b0;
        end
    end

    always @(posedge config_slave_regions_changed or posedge _check_t0_values )
    begin
        if (config_slave_regions_changed == 1'b1)
        begin
            axi4_get_config_slave_regions_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_regions_changed = 1'b0;
        end
    end

    always @(posedge config_region_changed or posedge _check_t0_values )
    begin
        if (config_region_changed == 1'b1)
        begin
            axi4_get_config_region_into_SystemVerilog(  ); // DPI call to imported task
            config_region_changed = 1'b0;
        end
    end

    always @(posedge region_error_state_changed or posedge _check_t0_values )
    begin
        if (region_error_state_changed == 1'b1)
        begin
            axi4_get_region_error_state_into_SystemVerilog(  ); // DPI call to imported task
            region_error_state_changed = 1'b0;
        end
    end

    always @(posedge region_map_lb_changed or posedge _check_t0_values )
    begin
        if (region_map_lb_changed == 1'b1)
        begin
            axi4_get_region_map_lb_into_SystemVerilog(  ); // DPI call to imported task
            region_map_lb_changed = 1'b0;
        end
    end

    always @(posedge region_map_ub_changed or posedge _check_t0_values )
    begin
        if (region_map_ub_changed == 1'b1)
        begin
            axi4_get_region_map_ub_into_SystemVerilog(  ); // DPI call to imported task
            region_map_ub_changed = 1'b0;
        end
    end

    always @(posedge region_map_region_changed or posedge _check_t0_values )
    begin
        if (region_map_region_changed == 1'b1)
        begin
            axi4_get_region_map_region_into_SystemVerilog(  ); // DPI call to imported task
            region_map_region_changed = 1'b0;
        end
    end

    always @(posedge cacheable_changed or posedge _check_t0_values )
    begin
        if (cacheable_changed == 1'b1)
        begin
            axi4_get_cacheable_into_SystemVerilog(  ); // DPI call to imported task
            cacheable_changed = 1'b0;
        end
    end

    always @(posedge config_read_data_reordering_depth_changed or posedge _check_t0_values )
    begin
        if (config_read_data_reordering_depth_changed == 1'b1)
        begin
            axi4_get_config_read_data_reordering_depth_into_SystemVerilog(  ); // DPI call to imported task
            config_read_data_reordering_depth_changed = 1'b0;
        end
    end

    always @(posedge config_slave_start_addr_changed or posedge _check_t0_values )
    begin
        if (config_slave_start_addr_changed == 1'b1)
        begin
            axi4_get_config_slave_start_addr_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_start_addr_changed = 1'b0;
        end
    end

    always @(posedge config_slave_end_addr_changed or posedge _check_t0_values )
    begin
        if (config_slave_end_addr_changed == 1'b1)
        begin
            axi4_get_config_slave_end_addr_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_end_addr_changed = 1'b0;
        end
    end

    always @(posedge config_slave_enabled_non_contiguous_address_spaces_changed or posedge _check_t0_values )
    begin
        if (config_slave_enabled_non_contiguous_address_spaces_changed == 1'b1)
        begin
            axi4_get_config_slave_enabled_non_contiguous_address_spaces_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_enabled_non_contiguous_address_spaces_changed = 1'b0;
        end
    end

    always @(posedge config_slave_possess_multiple_non_contiguous_address_spaces_changed or posedge _check_t0_values )
    begin
        if (config_slave_possess_multiple_non_contiguous_address_spaces_changed == 1'b1)
        begin
            axi4_get_config_slave_possess_multiple_non_contiguous_address_spaces_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_possess_multiple_non_contiguous_address_spaces_changed = 1'b0;
        end
    end

    always @(posedge config_slave_multiple_non_contiguous_start_address_range_changed or posedge _check_t0_values )
    begin
        if (config_slave_multiple_non_contiguous_start_address_range_changed == 1'b1)
        begin
            axi4_get_config_slave_multiple_non_contiguous_start_address_range_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_multiple_non_contiguous_start_address_range_changed = 1'b0;
        end
    end

    always @(posedge config_slave_multiple_non_contiguous_end_address_range_changed or posedge _check_t0_values )
    begin
        if (config_slave_multiple_non_contiguous_end_address_range_changed == 1'b1)
        begin
            axi4_get_config_slave_multiple_non_contiguous_end_address_range_into_SystemVerilog(  ); // DPI call to imported task
            config_slave_multiple_non_contiguous_end_address_range_changed = 1'b0;
        end
    end

    always @(posedge config_protect_ready_changed or posedge _check_t0_values )
    begin
        if (config_protect_ready_changed == 1'b1)
        begin
            axi4_get_config_protect_ready_into_SystemVerilog(  ); // DPI call to imported task
            config_protect_ready_changed = 1'b0;
        end
    end

    always @(posedge master_end_tlm_status_changed or posedge _check_t0_values )
    begin
        if (master_end_tlm_status_changed == 1'b1)
        begin
            axi4_get_master_end_tlm_status_into_SystemVerilog(  ); // DPI call to imported task
            master_end_tlm_status_changed = 1'b0;
        end
    end

    always @(posedge master_end_wlm_status_changed or posedge _check_t0_values )
    begin
        if (master_end_wlm_status_changed == 1'b1)
        begin
            axi4_get_master_end_wlm_status_into_SystemVerilog(  ); // DPI call to imported task
            master_end_wlm_status_changed = 1'b0;
        end
    end

    always @(posedge slave_end_tlm_status_changed or posedge _check_t0_values )
    begin
        if (slave_end_tlm_status_changed == 1'b1)
        begin
            axi4_get_slave_end_tlm_status_into_SystemVerilog(  ); // DPI call to imported task
            slave_end_tlm_status_changed = 1'b0;
        end
    end

    always @(posedge slave_end_wlm_status_changed or posedge _check_t0_values )
    begin
        if (slave_end_wlm_status_changed == 1'b1)
        begin
            axi4_get_slave_end_wlm_status_into_SystemVerilog(  ); // DPI call to imported task
            slave_end_wlm_status_changed = 1'b0;
        end
    end

    always @(posedge clock_source_end_tlm_status_changed or posedge _check_t0_values )
    begin
        if (clock_source_end_tlm_status_changed == 1'b1)
        begin
            axi4_get_clock_source_end_tlm_status_into_SystemVerilog(  ); // DPI call to imported task
            clock_source_end_tlm_status_changed = 1'b0;
        end
    end

    always @(posedge clock_source_end_wlm_status_changed or posedge _check_t0_values )
    begin
        if (clock_source_end_wlm_status_changed == 1'b1)
        begin
            axi4_get_clock_source_end_wlm_status_into_SystemVerilog(  ); // DPI call to imported task
            clock_source_end_wlm_status_changed = 1'b0;
        end
    end

    always @(posedge reset_source_end_tlm_status_changed or posedge _check_t0_values )
    begin
        if (reset_source_end_tlm_status_changed == 1'b1)
        begin
            axi4_get_reset_source_end_tlm_status_into_SystemVerilog(  ); // DPI call to imported task
            reset_source_end_tlm_status_changed = 1'b0;
        end
    end

    always @(posedge reset_source_end_wlm_status_changed or posedge _check_t0_values )
    begin
        if (reset_source_end_wlm_status_changed == 1'b1)
        begin
            axi4_get_reset_source_end_wlm_status_into_SystemVerilog(  ); // DPI call to imported task
            reset_source_end_wlm_status_changed = 1'b0;
        end
    end

    always @(posedge config_max_outstanding_wr_changed or posedge _check_t0_values )
    begin
        if (config_max_outstanding_wr_changed == 1'b1)
        begin
            axi4_get_config_max_outstanding_wr_into_SystemVerilog(  ); // DPI call to imported task
            config_max_outstanding_wr_changed = 1'b0;
        end
    end

    always @(posedge config_max_outstanding_rd_changed or posedge _check_t0_values )
    begin
        if (config_max_outstanding_rd_changed == 1'b1)
        begin
            axi4_get_config_max_outstanding_rd_into_SystemVerilog(  ); // DPI call to imported task
            config_max_outstanding_rd_changed = 1'b0;
        end
    end

    always @(posedge config_num_outstanding_wr_phase_changed or posedge _check_t0_values )
    begin
        if (config_num_outstanding_wr_phase_changed == 1'b1)
        begin
            axi4_get_config_num_outstanding_wr_phase_into_SystemVerilog(  ); // DPI call to imported task
            config_num_outstanding_wr_phase_changed = 1'b0;
        end
    end

    always @(posedge config_num_outstanding_rd_phase_changed or posedge _check_t0_values )
    begin
        if (config_num_outstanding_rd_phase_changed == 1'b1)
        begin
            axi4_get_config_num_outstanding_rd_phase_into_SystemVerilog(  ); // DPI call to imported task
            config_num_outstanding_rd_phase_changed = 1'b0;
        end
    end

    always @(posedge config_enable_warnings_changed or posedge _check_t0_values )
    begin
        if (config_enable_warnings_changed == 1'b1)
        begin
            axi4_get_config_enable_warnings_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_warnings_changed = 1'b0;
        end
    end

    always @(posedge config_enable_errors_changed or posedge _check_t0_values )
    begin
        if (config_enable_errors_changed == 1'b1)
        begin
            axi4_get_config_enable_errors_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_errors_changed = 1'b0;
        end
    end

    always @(posedge config_enable_exclusive_checks_changed or posedge _check_t0_values )
    begin
        if (config_enable_exclusive_checks_changed == 1'b1)
        begin
            axi4_get_config_enable_exclusive_checks_into_SystemVerilog(  ); // DPI call to imported task
            config_enable_exclusive_checks_changed = 1'b0;
        end
    end

    always @(posedge config_warn_on_slave_errors_changed or posedge _check_t0_values )
    begin
        if (config_warn_on_slave_errors_changed == 1'b1)
        begin
            axi4_get_config_warn_on_slave_errors_into_SystemVerilog(  ); // DPI call to imported task
            config_warn_on_slave_errors_changed = 1'b0;
        end
    end

    always @(posedge config_error_on_deleted_valid_cycles_changed or posedge _check_t0_values )
    begin
        if (config_error_on_deleted_valid_cycles_changed == 1'b1)
        begin
            axi4_get_config_error_on_deleted_valid_cycles_into_SystemVerilog(  ); // DPI call to imported task
            config_error_on_deleted_valid_cycles_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_occupancy_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_read_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_occupancy_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_write_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_data_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_data_occupancy_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_read_data_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_data_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_data_occupancy_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_data_occupancy_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_write_data_occupancy_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_data_occupancy_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_latency_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_latency_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_read_latency_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_latency_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_latency_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_latency_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_write_latency_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_latency_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_address_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_address_waits_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_read_address_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_address_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_data_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_data_waits_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_read_data_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_data_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_address_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_address_waits_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_write_address_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_address_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_data_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_data_waits_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_write_data_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_data_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_response_waits_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_response_waits_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_write_response_waits_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_response_waits_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_read_bandwidth_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_read_bandwidth_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_read_bandwidth_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_read_bandwidth_changed = 1'b0;
        end
    end

    always @(posedge config_stats_enable_write_bandwidth_changed or posedge _check_t0_values )
    begin
        if (config_stats_enable_write_bandwidth_changed == 1'b1)
        begin
            axi4_get_config_stats_enable_write_bandwidth_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_enable_write_bandwidth_changed = 1'b0;
        end
    end

    always @(posedge stats_rw_transaction_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_rw_transaction_last_duration_changed == 1'b1)
        begin
            axi4_get_stats_rw_transaction_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_rw_transaction_last_duration_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_occupancy_step_changed == 1'b1)
        begin
            axi4_get_config_stats_read_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_occupancy_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_read_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_active_changed or posedge _check_t0_values )
    begin
        if (stats_read_active_changed == 1'b1)
        begin
            axi4_get_stats_read_active_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_active_changed = 1'b0;
        end
    end

    always @(posedge stats_read_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_occupancy_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_idle_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_occupancy_min_changed == 1'b1)
        begin
            axi4_get_stats_read_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_idle_min_changed == 1'b1)
        begin
            axi4_get_stats_read_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_occupancy_max_changed == 1'b1)
        begin
            axi4_get_stats_read_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_idle_max_changed == 1'b1)
        begin
            axi4_get_stats_read_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_occupancy_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_read_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_idle_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_read_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_read_last_duration_changed == 1'b1)
        begin
            axi4_get_stats_read_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_last_duration_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_occupancy_step_changed == 1'b1)
        begin
            axi4_get_config_stats_write_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_occupancy_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_write_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_active_changed or posedge _check_t0_values )
    begin
        if (stats_write_active_changed == 1'b1)
        begin
            axi4_get_stats_write_active_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_active_changed = 1'b0;
        end
    end

    always @(posedge stats_write_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_occupancy_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_idle_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_occupancy_min_changed == 1'b1)
        begin
            axi4_get_stats_write_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_idle_min_changed == 1'b1)
        begin
            axi4_get_stats_write_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_occupancy_max_changed == 1'b1)
        begin
            axi4_get_stats_write_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_idle_max_changed == 1'b1)
        begin
            axi4_get_stats_write_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_occupancy_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_write_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_idle_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_write_last_duration_changed or posedge _check_t0_values )
    begin
        if (stats_write_last_duration_changed == 1'b1)
        begin
            axi4_get_stats_write_last_duration_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_last_duration_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_occupancy_step_changed == 1'b1)
        begin
            axi4_get_config_stats_read_data_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_occupancy_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_read_data_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_data_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_data_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_min_changed == 1'b1)
        begin
            axi4_get_stats_read_data_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_min_changed == 1'b1)
        begin
            axi4_get_stats_read_data_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_max_changed == 1'b1)
        begin
            axi4_get_stats_read_data_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_max_changed == 1'b1)
        begin
            axi4_get_stats_read_data_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_occupancy_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_data_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_idle_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_data_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_occupancy_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_occupancy_step_changed == 1'b1)
        begin
            axi4_get_config_stats_write_data_occupancy_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_occupancy_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_occupancy_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_occupancy_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_write_data_occupancy_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_occupancy_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_data_occupancy_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_data_idle_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_min_changed == 1'b1)
        begin
            axi4_get_stats_write_data_occupancy_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_min_changed == 1'b1)
        begin
            axi4_get_stats_write_data_idle_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_max_changed == 1'b1)
        begin
            axi4_get_stats_write_data_occupancy_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_max_changed == 1'b1)
        begin
            axi4_get_stats_write_data_idle_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_occupancy_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_occupancy_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_data_occupancy_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_occupancy_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_idle_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_idle_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_data_idle_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_idle_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_bandwidth_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_bandwidth_step_changed == 1'b1)
        begin
            axi4_get_config_stats_read_bandwidth_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_bandwidth_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_bandwidth_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_bandwidth_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_read_bandwidth_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_bandwidth_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_bandwidth_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_min_changed == 1'b1)
        begin
            axi4_get_stats_read_bandwidth_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_max_changed == 1'b1)
        begin
            axi4_get_stats_read_bandwidth_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_bandwidth_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_bandwidth_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_bandwidth_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_bandwidth_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_bandwidth_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_bandwidth_step_changed == 1'b1)
        begin
            axi4_get_config_stats_write_bandwidth_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_bandwidth_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_bandwidth_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_bandwidth_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_write_bandwidth_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_bandwidth_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_bandwidth_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_min_changed == 1'b1)
        begin
            axi4_get_stats_write_bandwidth_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_max_changed == 1'b1)
        begin
            axi4_get_stats_write_bandwidth_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_bandwidth_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_bandwidth_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_bandwidth_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_bandwidth_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_latency_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_latency_step_changed == 1'b1)
        begin
            axi4_get_config_stats_read_latency_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_latency_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_latency_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_latency_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_read_latency_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_latency_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_inst_changed == 1'b1)
        begin
            axi4_get_stats_read_address_data_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_address_data_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_min_changed == 1'b1)
        begin
            axi4_get_stats_read_address_data_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_max_changed == 1'b1)
        begin
            axi4_get_stats_read_address_data_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_data_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_data_latency_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_address_data_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_data_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_inst_changed == 1'b1)
        begin
            axi4_get_stats_read_address_address_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_address_address_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_min_changed == 1'b1)
        begin
            axi4_get_stats_read_address_address_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_max_changed == 1'b1)
        begin
            axi4_get_stats_read_address_address_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_address_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_address_latency_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_address_address_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_address_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_latency_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_latency_step_changed == 1'b1)
        begin
            axi4_get_config_stats_write_latency_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_latency_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_latency_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_latency_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_write_latency_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_latency_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_response_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_response_latency_inst_changed == 1'b1)
        begin
            axi4_get_stats_write_address_response_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_response_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_response_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_response_latency_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_address_response_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_response_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_response_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_response_latency_min_changed == 1'b1)
        begin
            axi4_get_stats_write_address_response_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_response_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_response_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_response_latency_max_changed == 1'b1)
        begin
            axi4_get_stats_write_address_response_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_response_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_response_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_response_latency_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_address_response_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_response_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_inst_changed == 1'b1)
        begin
            axi4_get_stats_write_address_address_latency_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_address_address_latency_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_min_changed == 1'b1)
        begin
            axi4_get_stats_write_address_address_latency_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_max_changed == 1'b1)
        begin
            axi4_get_stats_write_address_address_latency_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_address_latency_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_address_latency_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_address_address_latency_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_address_latency_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_address_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_address_waits_step_changed == 1'b1)
        begin
            axi4_get_config_stats_read_address_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_address_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_address_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_address_waits_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_read_address_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_address_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_inst_changed == 1'b1)
        begin
            axi4_get_stats_read_address_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_address_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_min_changed == 1'b1)
        begin
            axi4_get_stats_read_address_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_max_changed == 1'b1)
        begin
            axi4_get_stats_read_address_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_address_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_address_waits_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_address_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_address_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_waits_step_changed == 1'b1)
        begin
            axi4_get_config_stats_read_data_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_read_data_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_read_data_waits_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_read_data_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_read_data_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_inst_changed == 1'b1)
        begin
            axi4_get_stats_read_data_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_sw_changed == 1'b1)
        begin
            axi4_get_stats_read_data_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_min_changed == 1'b1)
        begin
            axi4_get_stats_read_data_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_max_changed == 1'b1)
        begin
            axi4_get_stats_read_data_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_read_data_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_read_data_waits_mean_changed == 1'b1)
        begin
            axi4_get_stats_read_data_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_read_data_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_address_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_address_waits_step_changed == 1'b1)
        begin
            axi4_get_config_stats_write_address_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_address_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_address_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_address_waits_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_write_address_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_address_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_inst_changed == 1'b1)
        begin
            axi4_get_stats_write_address_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_address_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_min_changed == 1'b1)
        begin
            axi4_get_stats_write_address_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_max_changed == 1'b1)
        begin
            axi4_get_stats_write_address_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_address_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_address_waits_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_address_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_address_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_waits_step_changed == 1'b1)
        begin
            axi4_get_config_stats_write_data_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_data_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_data_waits_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_write_data_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_data_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_inst_changed == 1'b1)
        begin
            axi4_get_stats_write_data_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_data_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_min_changed == 1'b1)
        begin
            axi4_get_stats_write_data_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_max_changed == 1'b1)
        begin
            axi4_get_stats_write_data_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_data_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_data_waits_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_data_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_data_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_response_waits_step_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_response_waits_step_changed == 1'b1)
        begin
            axi4_get_config_stats_write_response_waits_step_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_response_waits_step_changed = 1'b0;
        end
    end

    always @(posedge config_stats_write_response_waits_multiple_changed or posedge _check_t0_values )
    begin
        if (config_stats_write_response_waits_multiple_changed == 1'b1)
        begin
            axi4_get_config_stats_write_response_waits_multiple_into_SystemVerilog(  ); // DPI call to imported task
            config_stats_write_response_waits_multiple_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_inst_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_inst_changed == 1'b1)
        begin
            axi4_get_stats_write_response_waits_inst_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_inst_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_sw_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_sw_changed == 1'b1)
        begin
            axi4_get_stats_write_response_waits_sw_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_sw_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_min_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_min_changed == 1'b1)
        begin
            axi4_get_stats_write_response_waits_min_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_min_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_max_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_max_changed == 1'b1)
        begin
            axi4_get_stats_write_response_waits_max_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_max_changed = 1'b0;
        end
    end

    always @(posedge stats_write_response_waits_mean_changed or posedge _check_t0_values )
    begin
        if (stats_write_response_waits_mean_changed == 1'b1)
        begin
            axi4_get_stats_write_response_waits_mean_into_SystemVerilog(  ); // DPI call to imported task
            stats_write_response_waits_mean_changed = 1'b0;
        end
    end

    always @(posedge reordering_depth_of_last_read_transaction_changed or posedge _check_t0_values )
    begin
        if (reordering_depth_of_last_read_transaction_changed == 1'b1)
        begin
            axi4_get_reordering_depth_of_last_read_transaction_into_SystemVerilog(  ); // DPI call to imported task
            reordering_depth_of_last_read_transaction_changed = 1'b0;
        end
    end


    function longint do_get_last_handle();
        return last_handle;
    endfunction


    function longint do_get_last_start_time();
        return last_start_time;
    endfunction


    function longint do_get_last_end_time();
        return last_end_time;
    endfunction


        bit report_available;

        // Function for getting a message from QUESTA_MVC. Returns 1 if a message was returned, 0 otherwise.
        import "DPI-C" questa_mvc_sv_get_report =  function bit get_report( input longint recipient,
                                     output string category,     output string objectName,
                                     output string instanceName, output string error_no,
                                     output string typ,          output string mess );
        questa_mvc_reporter endPoint[longint];
        initial report_available = 0;

        always @report_available
        begin
            longint recipient;
            string category;
            string objectName;
            string instanceName;
            string severity;
            string mess;
            string error_no;

            if ( endPoint.first( recipient ) )
              begin
                do
                  begin
                      while ( get_report( recipient, category, objectName, instanceName, error_no, severity, mess ) )
                        begin
                          endPoint[recipient].report_message( category, "axi4", 0, objectName, instanceName, error_no, severity, mess );
                        end
                  end
                while (endPoint.next(recipient));
              end
            report_available = 0;
        end

        import "DPI-C" context questa_mvc_register_end_point = function void questa_mvc_register_end_point( input longint as_end, input string name );

        // A function for registering a reporter to capture any reports coming from as_end
        function automatic void register_end_point( input longint as_end, input questa_mvc_reporter rep = null );
            if ( rep != null )
              begin
                if ( ( rep.name == "" ) || ( rep.name == "NULL" ) )
                  begin
                    $display("Error: %m: Reporter passed to register_end_point has a reserved name. Neither an empty string nor the string 'NULL' can be used.");
                  end
                else
                  begin
                    questa_mvc_register_end_point( as_end, rep.name );
                    endPoint[as_end] = rep;
                  end
              end
            else
              begin
                questa_mvc_register_end_point( as_end, "NULL" );
                endPoint.delete( as_end );
              end
        endfunction

    //------------------------------------------------------------------------------
    // Tasks for registering reports
    //------------------------------------------------------------------------------
    function void do_register_interface_reporter( input questa_mvc_reporter _rep = null );
        register_end_point( _interface_ref, _rep );
    endfunction

    function void do_register_master_reporter
    (
        input questa_mvc_reporter rep = null
    );
        register_end_point( axi4_get_axi4_master_end(), rep );
    endfunction

    function void do_register_slave_reporter
    (
        input questa_mvc_reporter rep = null
    );
        register_end_point( axi4_get_axi4_slave_end(), rep );
    endfunction

    function void do_register_clock_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
        register_end_point( axi4_get_axi4_clock_source_end(), rep );
    endfunction

    function void do_register_reset_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
        register_end_point( axi4_get_axi4_reset_source_end(), rep );
    endfunction


    // Start end_of_timestep timer
    initial
    forever
    begin
        wait_end_of_timestep();
    end


    bit non_blocking_end_of_timestep_control = 0;

    export "DPI-C" axi4_wait_end_of_timestep = task wait_end_of_timestep;

    task wait_end_of_timestep();
        begin
            wait(non_blocking_end_of_timestep_control == 1);
            axi4_end_of_timestep_VPI_SystemVerilog();
            non_blocking_end_of_timestep_control = 0;
        end
    endtask

    always @( posedge end_of_timestep_control or posedge _check_t0_values )
    begin
        if ( end_of_timestep_control == 1 )
        begin
            non_blocking_end_of_timestep_control <= 1;
            end_of_timestep_control = 0;
        end
    end

    //------------------------------------------------------------------------------
    // Tasks to wait for a number of specified edges on a wire
    //------------------------------------------------------------------------------

    task automatic do_wait_for_ACLK( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ACLK);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ACLK);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ACLK);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ACLK === 0 );
                    @( ACLK );
                end
                while ( ACLK !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ACLK === 1 );
                    @( ACLK );
                end
                while ( ACLK !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARESETn( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARESETn);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARESETn);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARESETn);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARESETn === 0 );
                    @( ARESETn );
                end
                while ( ARESETn !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARESETn === 1 );
                    @( ARESETn );
                end
                while ( ARESETn !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWVALID === 0 );
                    @( AWVALID );
                end
                while ( AWVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWVALID === 1 );
                    @( AWVALID );
                end
                while ( AWVALID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWADDR( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWADDR);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWADDR);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWADDR);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWADDR === 0 );
                    @( AWADDR );
                end
                while ( AWADDR !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWADDR === 1 );
                    @( AWADDR );
                end
                while ( AWADDR !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWADDR[_this_dot_1] === 0 );
                    @( AWADDR[_this_dot_1] );
                end
                while ( AWADDR[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWADDR[_this_dot_1] === 1 );
                    @( AWADDR[_this_dot_1] );
                end
                while ( AWADDR[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWPROT( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWPROT);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWPROT);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWPROT);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWPROT === 0 );
                    @( AWPROT );
                end
                while ( AWPROT !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWPROT === 1 );
                    @( AWPROT );
                end
                while ( AWPROT !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWPROT[_this_dot_1] === 0 );
                    @( AWPROT[_this_dot_1] );
                end
                while ( AWPROT[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWPROT[_this_dot_1] === 1 );
                    @( AWPROT[_this_dot_1] );
                end
                while ( AWPROT[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWREGION( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWREGION);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWREGION);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWREGION);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWREGION === 0 );
                    @( AWREGION );
                end
                while ( AWREGION !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWREGION === 1 );
                    @( AWREGION );
                end
                while ( AWREGION !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWREGION_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWREGION[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWREGION[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWREGION[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWREGION[_this_dot_1] === 0 );
                    @( AWREGION[_this_dot_1] );
                end
                while ( AWREGION[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWREGION[_this_dot_1] === 1 );
                    @( AWREGION[_this_dot_1] );
                end
                while ( AWREGION[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWLEN( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWLEN);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWLEN);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWLEN);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWLEN === 0 );
                    @( AWLEN );
                end
                while ( AWLEN !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWLEN === 1 );
                    @( AWLEN );
                end
                while ( AWLEN !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWLEN[_this_dot_1] === 0 );
                    @( AWLEN[_this_dot_1] );
                end
                while ( AWLEN[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWLEN[_this_dot_1] === 1 );
                    @( AWLEN[_this_dot_1] );
                end
                while ( AWLEN[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWSIZE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWSIZE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWSIZE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWSIZE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWSIZE === 0 );
                    @( AWSIZE );
                end
                while ( AWSIZE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWSIZE === 1 );
                    @( AWSIZE );
                end
                while ( AWSIZE !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWSIZE[_this_dot_1] === 0 );
                    @( AWSIZE[_this_dot_1] );
                end
                while ( AWSIZE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWSIZE[_this_dot_1] === 1 );
                    @( AWSIZE[_this_dot_1] );
                end
                while ( AWSIZE[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWBURST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWBURST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWBURST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWBURST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWBURST === 0 );
                    @( AWBURST );
                end
                while ( AWBURST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWBURST === 1 );
                    @( AWBURST );
                end
                while ( AWBURST !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWBURST[_this_dot_1] === 0 );
                    @( AWBURST[_this_dot_1] );
                end
                while ( AWBURST[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWBURST[_this_dot_1] === 1 );
                    @( AWBURST[_this_dot_1] );
                end
                while ( AWBURST[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWLOCK( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWLOCK);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWLOCK);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWLOCK);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWLOCK === 0 );
                    @( AWLOCK );
                end
                while ( AWLOCK !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWLOCK === 1 );
                    @( AWLOCK );
                end
                while ( AWLOCK !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWCACHE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWCACHE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWCACHE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWCACHE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWCACHE === 0 );
                    @( AWCACHE );
                end
                while ( AWCACHE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWCACHE === 1 );
                    @( AWCACHE );
                end
                while ( AWCACHE !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWCACHE[_this_dot_1] === 0 );
                    @( AWCACHE[_this_dot_1] );
                end
                while ( AWCACHE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWCACHE[_this_dot_1] === 1 );
                    @( AWCACHE[_this_dot_1] );
                end
                while ( AWCACHE[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWQOS( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWQOS);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWQOS);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWQOS);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWQOS === 0 );
                    @( AWQOS );
                end
                while ( AWQOS !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWQOS === 1 );
                    @( AWQOS );
                end
                while ( AWQOS !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWQOS_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWQOS[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWQOS[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWQOS[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWQOS[_this_dot_1] === 0 );
                    @( AWQOS[_this_dot_1] );
                end
                while ( AWQOS[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWQOS[_this_dot_1] === 1 );
                    @( AWQOS[_this_dot_1] );
                end
                while ( AWQOS[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWID === 0 );
                    @( AWID );
                end
                while ( AWID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWID === 1 );
                    @( AWID );
                end
                while ( AWID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWID[_this_dot_1] === 0 );
                    @( AWID[_this_dot_1] );
                end
                while ( AWID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWID[_this_dot_1] === 1 );
                    @( AWID[_this_dot_1] );
                end
                while ( AWID[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWUSER === 0 );
                    @( AWUSER );
                end
                while ( AWUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWUSER === 1 );
                    @( AWUSER );
                end
                while ( AWUSER !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWUSER[_this_dot_1] === 0 );
                    @( AWUSER[_this_dot_1] );
                end
                while ( AWUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWUSER[_this_dot_1] === 1 );
                    @( AWUSER[_this_dot_1] );
                end
                while ( AWUSER[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_AWREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge AWREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge AWREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        AWREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( AWREADY === 0 );
                    @( AWREADY );
                end
                while ( AWREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( AWREADY === 1 );
                    @( AWREADY );
                end
                while ( AWREADY !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARVALID === 0 );
                    @( ARVALID );
                end
                while ( ARVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARVALID === 1 );
                    @( ARVALID );
                end
                while ( ARVALID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARADDR( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARADDR);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARADDR);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARADDR);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARADDR === 0 );
                    @( ARADDR );
                end
                while ( ARADDR !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARADDR === 1 );
                    @( ARADDR );
                end
                while ( ARADDR !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARADDR[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARADDR[_this_dot_1] === 0 );
                    @( ARADDR[_this_dot_1] );
                end
                while ( ARADDR[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARADDR[_this_dot_1] === 1 );
                    @( ARADDR[_this_dot_1] );
                end
                while ( ARADDR[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARPROT( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARPROT);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARPROT);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARPROT);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARPROT === 0 );
                    @( ARPROT );
                end
                while ( ARPROT !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARPROT === 1 );
                    @( ARPROT );
                end
                while ( ARPROT !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARPROT[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARPROT[_this_dot_1] === 0 );
                    @( ARPROT[_this_dot_1] );
                end
                while ( ARPROT[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARPROT[_this_dot_1] === 1 );
                    @( ARPROT[_this_dot_1] );
                end
                while ( ARPROT[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARREGION( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARREGION);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARREGION);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARREGION);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARREGION === 0 );
                    @( ARREGION );
                end
                while ( ARREGION !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARREGION === 1 );
                    @( ARREGION );
                end
                while ( ARREGION !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARREGION_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARREGION[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARREGION[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARREGION[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARREGION[_this_dot_1] === 0 );
                    @( ARREGION[_this_dot_1] );
                end
                while ( ARREGION[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARREGION[_this_dot_1] === 1 );
                    @( ARREGION[_this_dot_1] );
                end
                while ( ARREGION[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARLEN( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARLEN);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARLEN);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARLEN);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARLEN === 0 );
                    @( ARLEN );
                end
                while ( ARLEN !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARLEN === 1 );
                    @( ARLEN );
                end
                while ( ARLEN !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARLEN[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARLEN[_this_dot_1] === 0 );
                    @( ARLEN[_this_dot_1] );
                end
                while ( ARLEN[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARLEN[_this_dot_1] === 1 );
                    @( ARLEN[_this_dot_1] );
                end
                while ( ARLEN[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARSIZE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARSIZE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARSIZE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARSIZE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARSIZE === 0 );
                    @( ARSIZE );
                end
                while ( ARSIZE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARSIZE === 1 );
                    @( ARSIZE );
                end
                while ( ARSIZE !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARSIZE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARSIZE[_this_dot_1] === 0 );
                    @( ARSIZE[_this_dot_1] );
                end
                while ( ARSIZE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARSIZE[_this_dot_1] === 1 );
                    @( ARSIZE[_this_dot_1] );
                end
                while ( ARSIZE[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARBURST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARBURST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARBURST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARBURST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARBURST === 0 );
                    @( ARBURST );
                end
                while ( ARBURST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARBURST === 1 );
                    @( ARBURST );
                end
                while ( ARBURST !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARBURST[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARBURST[_this_dot_1] === 0 );
                    @( ARBURST[_this_dot_1] );
                end
                while ( ARBURST[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARBURST[_this_dot_1] === 1 );
                    @( ARBURST[_this_dot_1] );
                end
                while ( ARBURST[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARLOCK( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARLOCK);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARLOCK);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARLOCK);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARLOCK === 0 );
                    @( ARLOCK );
                end
                while ( ARLOCK !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARLOCK === 1 );
                    @( ARLOCK );
                end
                while ( ARLOCK !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARCACHE( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARCACHE);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARCACHE);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARCACHE);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARCACHE === 0 );
                    @( ARCACHE );
                end
                while ( ARCACHE !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARCACHE === 1 );
                    @( ARCACHE );
                end
                while ( ARCACHE !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARCACHE[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARCACHE[_this_dot_1] === 0 );
                    @( ARCACHE[_this_dot_1] );
                end
                while ( ARCACHE[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARCACHE[_this_dot_1] === 1 );
                    @( ARCACHE[_this_dot_1] );
                end
                while ( ARCACHE[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARQOS( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARQOS);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARQOS);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARQOS);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARQOS === 0 );
                    @( ARQOS );
                end
                while ( ARQOS !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARQOS === 1 );
                    @( ARQOS );
                end
                while ( ARQOS !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARQOS_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARQOS[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARQOS[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARQOS[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARQOS[_this_dot_1] === 0 );
                    @( ARQOS[_this_dot_1] );
                end
                while ( ARQOS[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARQOS[_this_dot_1] === 1 );
                    @( ARQOS[_this_dot_1] );
                end
                while ( ARQOS[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARID === 0 );
                    @( ARID );
                end
                while ( ARID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARID === 1 );
                    @( ARID );
                end
                while ( ARID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARID[_this_dot_1] === 0 );
                    @( ARID[_this_dot_1] );
                end
                while ( ARID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARID[_this_dot_1] === 1 );
                    @( ARID[_this_dot_1] );
                end
                while ( ARID[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARUSER === 0 );
                    @( ARUSER );
                end
                while ( ARUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARUSER === 1 );
                    @( ARUSER );
                end
                while ( ARUSER !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARUSER[_this_dot_1] === 0 );
                    @( ARUSER[_this_dot_1] );
                end
                while ( ARUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARUSER[_this_dot_1] === 1 );
                    @( ARUSER[_this_dot_1] );
                end
                while ( ARUSER[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_ARREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge ARREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge ARREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        ARREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( ARREADY === 0 );
                    @( ARREADY );
                end
                while ( ARREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( ARREADY === 1 );
                    @( ARREADY );
                end
                while ( ARREADY !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RVALID === 0 );
                    @( RVALID );
                end
                while ( RVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RVALID === 1 );
                    @( RVALID );
                end
                while ( RVALID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RDATA( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RDATA);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RDATA);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RDATA);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RDATA === 0 );
                    @( RDATA );
                end
                while ( RDATA !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RDATA === 1 );
                    @( RDATA );
                end
                while ( RDATA !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RDATA[_this_dot_1] === 0 );
                    @( RDATA[_this_dot_1] );
                end
                while ( RDATA[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RDATA[_this_dot_1] === 1 );
                    @( RDATA[_this_dot_1] );
                end
                while ( RDATA[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RRESP( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RRESP);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RRESP);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RRESP);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RRESP === 0 );
                    @( RRESP );
                end
                while ( RRESP !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RRESP === 1 );
                    @( RRESP );
                end
                while ( RRESP !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RRESP[_this_dot_1] === 0 );
                    @( RRESP[_this_dot_1] );
                end
                while ( RRESP[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RRESP[_this_dot_1] === 1 );
                    @( RRESP[_this_dot_1] );
                end
                while ( RRESP[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RLAST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RLAST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RLAST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RLAST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RLAST === 0 );
                    @( RLAST );
                end
                while ( RLAST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RLAST === 1 );
                    @( RLAST );
                end
                while ( RLAST !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RID === 0 );
                    @( RID );
                end
                while ( RID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RID === 1 );
                    @( RID );
                end
                while ( RID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RID[_this_dot_1] === 0 );
                    @( RID[_this_dot_1] );
                end
                while ( RID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RID[_this_dot_1] === 1 );
                    @( RID[_this_dot_1] );
                end
                while ( RID[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RUSER === 0 );
                    @( RUSER );
                end
                while ( RUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RUSER === 1 );
                    @( RUSER );
                end
                while ( RUSER !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RUSER[_this_dot_1] === 0 );
                    @( RUSER[_this_dot_1] );
                end
                while ( RUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RUSER[_this_dot_1] === 1 );
                    @( RUSER[_this_dot_1] );
                end
                while ( RUSER[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_RREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge RREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge RREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        RREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( RREADY === 0 );
                    @( RREADY );
                end
                while ( RREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( RREADY === 1 );
                    @( RREADY );
                end
                while ( RREADY !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WVALID === 0 );
                    @( WVALID );
                end
                while ( WVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WVALID === 1 );
                    @( WVALID );
                end
                while ( WVALID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WDATA( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WDATA);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WDATA);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WDATA);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WDATA === 0 );
                    @( WDATA );
                end
                while ( WDATA !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WDATA === 1 );
                    @( WDATA );
                end
                while ( WDATA !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WDATA[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WDATA[_this_dot_1] === 0 );
                    @( WDATA[_this_dot_1] );
                end
                while ( WDATA[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WDATA[_this_dot_1] === 1 );
                    @( WDATA[_this_dot_1] );
                end
                while ( WDATA[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WSTRB( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WSTRB);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WSTRB);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WSTRB);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WSTRB === 0 );
                    @( WSTRB );
                end
                while ( WSTRB !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WSTRB === 1 );
                    @( WSTRB );
                end
                while ( WSTRB !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WSTRB_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WSTRB[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WSTRB[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WSTRB[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WSTRB[_this_dot_1] === 0 );
                    @( WSTRB[_this_dot_1] );
                end
                while ( WSTRB[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WSTRB[_this_dot_1] === 1 );
                    @( WSTRB[_this_dot_1] );
                end
                while ( WSTRB[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WLAST( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WLAST);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WLAST);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WLAST);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WLAST === 0 );
                    @( WLAST );
                end
                while ( WLAST !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WLAST === 1 );
                    @( WLAST );
                end
                while ( WLAST !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WUSER === 0 );
                    @( WUSER );
                end
                while ( WUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WUSER === 1 );
                    @( WUSER );
                end
                while ( WUSER !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WUSER[_this_dot_1] === 0 );
                    @( WUSER[_this_dot_1] );
                end
                while ( WUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WUSER[_this_dot_1] === 1 );
                    @( WUSER[_this_dot_1] );
                end
                while ( WUSER[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_WREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge WREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge WREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        WREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( WREADY === 0 );
                    @( WREADY );
                end
                while ( WREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( WREADY === 1 );
                    @( WREADY );
                end
                while ( WREADY !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BVALID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BVALID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BVALID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BVALID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BVALID === 0 );
                    @( BVALID );
                end
                while ( BVALID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BVALID === 1 );
                    @( BVALID );
                end
                while ( BVALID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BRESP( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BRESP);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BRESP);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BRESP);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BRESP === 0 );
                    @( BRESP );
                end
                while ( BRESP !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BRESP === 1 );
                    @( BRESP );
                end
                while ( BRESP !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BRESP[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BRESP[_this_dot_1] === 0 );
                    @( BRESP[_this_dot_1] );
                end
                while ( BRESP[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BRESP[_this_dot_1] === 1 );
                    @( BRESP[_this_dot_1] );
                end
                while ( BRESP[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BID( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BID);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BID);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BID);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BID === 0 );
                    @( BID );
                end
                while ( BID !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BID === 1 );
                    @( BID );
                end
                while ( BID !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BID[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BID[_this_dot_1] === 0 );
                    @( BID[_this_dot_1] );
                end
                while ( BID[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BID[_this_dot_1] === 1 );
                    @( BID[_this_dot_1] );
                end
                while ( BID[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BUSER( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BUSER);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BUSER);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BUSER);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BUSER === 0 );
                    @( BUSER );
                end
                while ( BUSER !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BUSER === 1 );
                    @( BUSER );
                end
                while ( BUSER !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BUSER[_this_dot_1]);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BUSER[_this_dot_1] === 0 );
                    @( BUSER[_this_dot_1] );
                end
                while ( BUSER[_this_dot_1] !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BUSER[_this_dot_1] === 1 );
                    @( BUSER[_this_dot_1] );
                end
                while ( BUSER[_this_dot_1] !== 0 );
            end
        end
    endtask

    task automatic do_wait_for_BREADY( input questa_mvc_edge which_edge, input int count = 1 );
        int i;
        for ( i=0; i<count; i++ )
        begin
            if      ( which_edge == QUESTA_MVC_POSEDGE     ) @(posedge BREADY);
            else if ( which_edge == QUESTA_MVC_NEGEDGE     ) @(negedge BREADY);
            else if ( which_edge == QUESTA_MVC_ANYEDGE     ) @(        BREADY);
            else if ( which_edge == QUESTA_MVC_0_TO_1_EDGE )
            begin
                do
                begin
                    wait( BREADY === 0 );
                    @( BREADY );
                end
                while ( BREADY !== 1 );
            end
            else if ( which_edge == QUESTA_MVC_1_TO_0_EDGE )
            begin
                do
                begin
                    wait( BREADY === 1 );
                    @( BREADY );
                end
                while ( BREADY !== 0 );
            end
        end
    endtask

    //------------------------------------------------------------------------------
    // Tasks/functions to set/get wires
    //------------------------------------------------------------------------------

    task automatic do_set_ACLK( logic ACLK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ACLK = ACLK_param;
        else
            m_ACLK <= ACLK_param;
    endtask

    function automatic logic do_get_ACLK(  );
        return ACLK;
    endfunction

    task automatic do_set_ARESETn( logic ARESETn_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARESETn = ARESETn_param;
        else
            m_ARESETn <= ARESETn_param;
    endtask

    function automatic logic do_get_ARESETn(  );
        return ARESETn;
    endfunction

    task automatic do_set_AWVALID( logic AWVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWVALID = AWVALID_param;
        else
            m_AWVALID <= AWVALID_param;
    endtask

    function automatic logic do_get_AWVALID(  );
        return AWVALID;
    endfunction

    task automatic do_set_AWADDR( logic [((AXI4_ADDRESS_WIDTH) - 1):0]  AWADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWADDR = AWADDR_param;
        else
            m_AWADDR <= AWADDR_param;
    endtask

    task automatic do_set_AWADDR_index1( int _this_dot_1, logic  AWADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWADDR[_this_dot_1] = AWADDR_param;
        else
            m_AWADDR[_this_dot_1] <= AWADDR_param;
    endtask

    function automatic logic [((AXI4_ADDRESS_WIDTH) - 1):0]   do_get_AWADDR(  );
        return AWADDR;
    endfunction

    function automatic logic   do_get_AWADDR_index1( int _this_dot_1 );
        return AWADDR[_this_dot_1];
    endfunction

    task automatic do_set_AWPROT( logic [2:0] AWPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWPROT = AWPROT_param;
        else
            m_AWPROT <= AWPROT_param;
    endtask

    task automatic do_set_AWPROT_index1( int _this_dot_1, logic  AWPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWPROT[_this_dot_1] = AWPROT_param;
        else
            m_AWPROT[_this_dot_1] <= AWPROT_param;
    endtask

    function automatic logic [2:0]  do_get_AWPROT(  );
        return AWPROT;
    endfunction

    function automatic logic   do_get_AWPROT_index1( int _this_dot_1 );
        return AWPROT[_this_dot_1];
    endfunction

    task automatic do_set_AWREGION( logic [3:0] AWREGION_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWREGION = AWREGION_param;
        else
            m_AWREGION <= AWREGION_param;
    endtask

    task automatic do_set_AWREGION_index1( int _this_dot_1, logic  AWREGION_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWREGION[_this_dot_1] = AWREGION_param;
        else
            m_AWREGION[_this_dot_1] <= AWREGION_param;
    endtask

    function automatic logic [3:0]  do_get_AWREGION(  );
        return AWREGION;
    endfunction

    function automatic logic   do_get_AWREGION_index1( int _this_dot_1 );
        return AWREGION[_this_dot_1];
    endfunction

    task automatic do_set_AWLEN( logic [7:0] AWLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWLEN = AWLEN_param;
        else
            m_AWLEN <= AWLEN_param;
    endtask

    task automatic do_set_AWLEN_index1( int _this_dot_1, logic  AWLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWLEN[_this_dot_1] = AWLEN_param;
        else
            m_AWLEN[_this_dot_1] <= AWLEN_param;
    endtask

    function automatic logic [7:0]  do_get_AWLEN(  );
        return AWLEN;
    endfunction

    function automatic logic   do_get_AWLEN_index1( int _this_dot_1 );
        return AWLEN[_this_dot_1];
    endfunction

    task automatic do_set_AWSIZE( logic [2:0] AWSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWSIZE = AWSIZE_param;
        else
            m_AWSIZE <= AWSIZE_param;
    endtask

    task automatic do_set_AWSIZE_index1( int _this_dot_1, logic  AWSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWSIZE[_this_dot_1] = AWSIZE_param;
        else
            m_AWSIZE[_this_dot_1] <= AWSIZE_param;
    endtask

    function automatic logic [2:0]  do_get_AWSIZE(  );
        return AWSIZE;
    endfunction

    function automatic logic   do_get_AWSIZE_index1( int _this_dot_1 );
        return AWSIZE[_this_dot_1];
    endfunction

    task automatic do_set_AWBURST( logic [1:0] AWBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWBURST = AWBURST_param;
        else
            m_AWBURST <= AWBURST_param;
    endtask

    task automatic do_set_AWBURST_index1( int _this_dot_1, logic  AWBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWBURST[_this_dot_1] = AWBURST_param;
        else
            m_AWBURST[_this_dot_1] <= AWBURST_param;
    endtask

    function automatic logic [1:0]  do_get_AWBURST(  );
        return AWBURST;
    endfunction

    function automatic logic   do_get_AWBURST_index1( int _this_dot_1 );
        return AWBURST[_this_dot_1];
    endfunction

    task automatic do_set_AWLOCK( logic AWLOCK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWLOCK = AWLOCK_param;
        else
            m_AWLOCK <= AWLOCK_param;
    endtask

    function automatic logic do_get_AWLOCK(  );
        return AWLOCK;
    endfunction

    task automatic do_set_AWCACHE( logic [3:0] AWCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWCACHE = AWCACHE_param;
        else
            m_AWCACHE <= AWCACHE_param;
    endtask

    task automatic do_set_AWCACHE_index1( int _this_dot_1, logic  AWCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWCACHE[_this_dot_1] = AWCACHE_param;
        else
            m_AWCACHE[_this_dot_1] <= AWCACHE_param;
    endtask

    function automatic logic [3:0]  do_get_AWCACHE(  );
        return AWCACHE;
    endfunction

    function automatic logic   do_get_AWCACHE_index1( int _this_dot_1 );
        return AWCACHE[_this_dot_1];
    endfunction

    task automatic do_set_AWQOS( logic [3:0] AWQOS_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWQOS = AWQOS_param;
        else
            m_AWQOS <= AWQOS_param;
    endtask

    task automatic do_set_AWQOS_index1( int _this_dot_1, logic  AWQOS_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWQOS[_this_dot_1] = AWQOS_param;
        else
            m_AWQOS[_this_dot_1] <= AWQOS_param;
    endtask

    function automatic logic [3:0]  do_get_AWQOS(  );
        return AWQOS;
    endfunction

    function automatic logic   do_get_AWQOS_index1( int _this_dot_1 );
        return AWQOS[_this_dot_1];
    endfunction

    task automatic do_set_AWID( logic [((AXI4_ID_WIDTH) - 1):0]  AWID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWID = AWID_param;
        else
            m_AWID <= AWID_param;
    endtask

    task automatic do_set_AWID_index1( int _this_dot_1, logic  AWID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWID[_this_dot_1] = AWID_param;
        else
            m_AWID[_this_dot_1] <= AWID_param;
    endtask

    function automatic logic [((AXI4_ID_WIDTH) - 1):0]   do_get_AWID(  );
        return AWID;
    endfunction

    function automatic logic   do_get_AWID_index1( int _this_dot_1 );
        return AWID[_this_dot_1];
    endfunction

    task automatic do_set_AWUSER( logic [((AXI4_USER_WIDTH) - 1):0]  AWUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWUSER = AWUSER_param;
        else
            m_AWUSER <= AWUSER_param;
    endtask

    task automatic do_set_AWUSER_index1( int _this_dot_1, logic  AWUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWUSER[_this_dot_1] = AWUSER_param;
        else
            m_AWUSER[_this_dot_1] <= AWUSER_param;
    endtask

    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   do_get_AWUSER(  );
        return AWUSER;
    endfunction

    function automatic logic   do_get_AWUSER_index1( int _this_dot_1 );
        return AWUSER[_this_dot_1];
    endfunction

    task automatic do_set_AWREADY( logic AWREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_AWREADY = AWREADY_param;
        else
            m_AWREADY <= AWREADY_param;
    endtask

    function automatic logic do_get_AWREADY(  );
        return AWREADY;
    endfunction

    task automatic do_set_ARVALID( logic ARVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARVALID = ARVALID_param;
        else
            m_ARVALID <= ARVALID_param;
    endtask

    function automatic logic do_get_ARVALID(  );
        return ARVALID;
    endfunction

    task automatic do_set_ARADDR( logic [((AXI4_ADDRESS_WIDTH) - 1):0]  ARADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARADDR = ARADDR_param;
        else
            m_ARADDR <= ARADDR_param;
    endtask

    task automatic do_set_ARADDR_index1( int _this_dot_1, logic  ARADDR_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARADDR[_this_dot_1] = ARADDR_param;
        else
            m_ARADDR[_this_dot_1] <= ARADDR_param;
    endtask

    function automatic logic [((AXI4_ADDRESS_WIDTH) - 1):0]   do_get_ARADDR(  );
        return ARADDR;
    endfunction

    function automatic logic   do_get_ARADDR_index1( int _this_dot_1 );
        return ARADDR[_this_dot_1];
    endfunction

    task automatic do_set_ARPROT( logic [2:0] ARPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARPROT = ARPROT_param;
        else
            m_ARPROT <= ARPROT_param;
    endtask

    task automatic do_set_ARPROT_index1( int _this_dot_1, logic  ARPROT_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARPROT[_this_dot_1] = ARPROT_param;
        else
            m_ARPROT[_this_dot_1] <= ARPROT_param;
    endtask

    function automatic logic [2:0]  do_get_ARPROT(  );
        return ARPROT;
    endfunction

    function automatic logic   do_get_ARPROT_index1( int _this_dot_1 );
        return ARPROT[_this_dot_1];
    endfunction

    task automatic do_set_ARREGION( logic [3:0] ARREGION_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARREGION = ARREGION_param;
        else
            m_ARREGION <= ARREGION_param;
    endtask

    task automatic do_set_ARREGION_index1( int _this_dot_1, logic  ARREGION_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARREGION[_this_dot_1] = ARREGION_param;
        else
            m_ARREGION[_this_dot_1] <= ARREGION_param;
    endtask

    function automatic logic [3:0]  do_get_ARREGION(  );
        return ARREGION;
    endfunction

    function automatic logic   do_get_ARREGION_index1( int _this_dot_1 );
        return ARREGION[_this_dot_1];
    endfunction

    task automatic do_set_ARLEN( logic [7:0] ARLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARLEN = ARLEN_param;
        else
            m_ARLEN <= ARLEN_param;
    endtask

    task automatic do_set_ARLEN_index1( int _this_dot_1, logic  ARLEN_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARLEN[_this_dot_1] = ARLEN_param;
        else
            m_ARLEN[_this_dot_1] <= ARLEN_param;
    endtask

    function automatic logic [7:0]  do_get_ARLEN(  );
        return ARLEN;
    endfunction

    function automatic logic   do_get_ARLEN_index1( int _this_dot_1 );
        return ARLEN[_this_dot_1];
    endfunction

    task automatic do_set_ARSIZE( logic [2:0] ARSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARSIZE = ARSIZE_param;
        else
            m_ARSIZE <= ARSIZE_param;
    endtask

    task automatic do_set_ARSIZE_index1( int _this_dot_1, logic  ARSIZE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARSIZE[_this_dot_1] = ARSIZE_param;
        else
            m_ARSIZE[_this_dot_1] <= ARSIZE_param;
    endtask

    function automatic logic [2:0]  do_get_ARSIZE(  );
        return ARSIZE;
    endfunction

    function automatic logic   do_get_ARSIZE_index1( int _this_dot_1 );
        return ARSIZE[_this_dot_1];
    endfunction

    task automatic do_set_ARBURST( logic [1:0] ARBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARBURST = ARBURST_param;
        else
            m_ARBURST <= ARBURST_param;
    endtask

    task automatic do_set_ARBURST_index1( int _this_dot_1, logic  ARBURST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARBURST[_this_dot_1] = ARBURST_param;
        else
            m_ARBURST[_this_dot_1] <= ARBURST_param;
    endtask

    function automatic logic [1:0]  do_get_ARBURST(  );
        return ARBURST;
    endfunction

    function automatic logic   do_get_ARBURST_index1( int _this_dot_1 );
        return ARBURST[_this_dot_1];
    endfunction

    task automatic do_set_ARLOCK( logic ARLOCK_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARLOCK = ARLOCK_param;
        else
            m_ARLOCK <= ARLOCK_param;
    endtask

    function automatic logic do_get_ARLOCK(  );
        return ARLOCK;
    endfunction

    task automatic do_set_ARCACHE( logic [3:0] ARCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARCACHE = ARCACHE_param;
        else
            m_ARCACHE <= ARCACHE_param;
    endtask

    task automatic do_set_ARCACHE_index1( int _this_dot_1, logic  ARCACHE_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARCACHE[_this_dot_1] = ARCACHE_param;
        else
            m_ARCACHE[_this_dot_1] <= ARCACHE_param;
    endtask

    function automatic logic [3:0]  do_get_ARCACHE(  );
        return ARCACHE;
    endfunction

    function automatic logic   do_get_ARCACHE_index1( int _this_dot_1 );
        return ARCACHE[_this_dot_1];
    endfunction

    task automatic do_set_ARQOS( logic [3:0] ARQOS_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARQOS = ARQOS_param;
        else
            m_ARQOS <= ARQOS_param;
    endtask

    task automatic do_set_ARQOS_index1( int _this_dot_1, logic  ARQOS_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARQOS[_this_dot_1] = ARQOS_param;
        else
            m_ARQOS[_this_dot_1] <= ARQOS_param;
    endtask

    function automatic logic [3:0]  do_get_ARQOS(  );
        return ARQOS;
    endfunction

    function automatic logic   do_get_ARQOS_index1( int _this_dot_1 );
        return ARQOS[_this_dot_1];
    endfunction

    task automatic do_set_ARID( logic [((AXI4_ID_WIDTH) - 1):0]  ARID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARID = ARID_param;
        else
            m_ARID <= ARID_param;
    endtask

    task automatic do_set_ARID_index1( int _this_dot_1, logic  ARID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARID[_this_dot_1] = ARID_param;
        else
            m_ARID[_this_dot_1] <= ARID_param;
    endtask

    function automatic logic [((AXI4_ID_WIDTH) - 1):0]   do_get_ARID(  );
        return ARID;
    endfunction

    function automatic logic   do_get_ARID_index1( int _this_dot_1 );
        return ARID[_this_dot_1];
    endfunction

    task automatic do_set_ARUSER( logic [((AXI4_USER_WIDTH) - 1):0]  ARUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARUSER = ARUSER_param;
        else
            m_ARUSER <= ARUSER_param;
    endtask

    task automatic do_set_ARUSER_index1( int _this_dot_1, logic  ARUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARUSER[_this_dot_1] = ARUSER_param;
        else
            m_ARUSER[_this_dot_1] <= ARUSER_param;
    endtask

    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   do_get_ARUSER(  );
        return ARUSER;
    endfunction

    function automatic logic   do_get_ARUSER_index1( int _this_dot_1 );
        return ARUSER[_this_dot_1];
    endfunction

    task automatic do_set_ARREADY( logic ARREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_ARREADY = ARREADY_param;
        else
            m_ARREADY <= ARREADY_param;
    endtask

    function automatic logic do_get_ARREADY(  );
        return ARREADY;
    endfunction

    task automatic do_set_RVALID( logic RVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RVALID = RVALID_param;
        else
            m_RVALID <= RVALID_param;
    endtask

    function automatic logic do_get_RVALID(  );
        return RVALID;
    endfunction

    task automatic do_set_RDATA( logic [((AXI4_RDATA_WIDTH) - 1):0]  RDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RDATA = RDATA_param;
        else
            m_RDATA <= RDATA_param;
    endtask

    task automatic do_set_RDATA_index1( int _this_dot_1, logic  RDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RDATA[_this_dot_1] = RDATA_param;
        else
            m_RDATA[_this_dot_1] <= RDATA_param;
    endtask

    function automatic logic [((AXI4_RDATA_WIDTH) - 1):0]   do_get_RDATA(  );
        return RDATA;
    endfunction

    function automatic logic   do_get_RDATA_index1( int _this_dot_1 );
        return RDATA[_this_dot_1];
    endfunction

    task automatic do_set_RRESP( logic [1:0] RRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RRESP = RRESP_param;
        else
            m_RRESP <= RRESP_param;
    endtask

    task automatic do_set_RRESP_index1( int _this_dot_1, logic  RRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RRESP[_this_dot_1] = RRESP_param;
        else
            m_RRESP[_this_dot_1] <= RRESP_param;
    endtask

    function automatic logic [1:0]  do_get_RRESP(  );
        return RRESP;
    endfunction

    function automatic logic   do_get_RRESP_index1( int _this_dot_1 );
        return RRESP[_this_dot_1];
    endfunction

    task automatic do_set_RLAST( logic RLAST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RLAST = RLAST_param;
        else
            m_RLAST <= RLAST_param;
    endtask

    function automatic logic do_get_RLAST(  );
        return RLAST;
    endfunction

    task automatic do_set_RID( logic [((AXI4_ID_WIDTH) - 1):0]  RID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RID = RID_param;
        else
            m_RID <= RID_param;
    endtask

    task automatic do_set_RID_index1( int _this_dot_1, logic  RID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RID[_this_dot_1] = RID_param;
        else
            m_RID[_this_dot_1] <= RID_param;
    endtask

    function automatic logic [((AXI4_ID_WIDTH) - 1):0]   do_get_RID(  );
        return RID;
    endfunction

    function automatic logic   do_get_RID_index1( int _this_dot_1 );
        return RID[_this_dot_1];
    endfunction

    task automatic do_set_RUSER( logic [((AXI4_USER_WIDTH) - 1):0]  RUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RUSER = RUSER_param;
        else
            m_RUSER <= RUSER_param;
    endtask

    task automatic do_set_RUSER_index1( int _this_dot_1, logic  RUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RUSER[_this_dot_1] = RUSER_param;
        else
            m_RUSER[_this_dot_1] <= RUSER_param;
    endtask

    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   do_get_RUSER(  );
        return RUSER;
    endfunction

    function automatic logic   do_get_RUSER_index1( int _this_dot_1 );
        return RUSER[_this_dot_1];
    endfunction

    task automatic do_set_RREADY( logic RREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_RREADY = RREADY_param;
        else
            m_RREADY <= RREADY_param;
    endtask

    function automatic logic do_get_RREADY(  );
        return RREADY;
    endfunction

    task automatic do_set_WVALID( logic WVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WVALID = WVALID_param;
        else
            m_WVALID <= WVALID_param;
    endtask

    function automatic logic do_get_WVALID(  );
        return WVALID;
    endfunction

    task automatic do_set_WDATA( logic [((AXI4_WDATA_WIDTH) - 1):0]  WDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WDATA = WDATA_param;
        else
            m_WDATA <= WDATA_param;
    endtask

    task automatic do_set_WDATA_index1( int _this_dot_1, logic  WDATA_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WDATA[_this_dot_1] = WDATA_param;
        else
            m_WDATA[_this_dot_1] <= WDATA_param;
    endtask

    function automatic logic [((AXI4_WDATA_WIDTH) - 1):0]   do_get_WDATA(  );
        return WDATA;
    endfunction

    function automatic logic   do_get_WDATA_index1( int _this_dot_1 );
        return WDATA[_this_dot_1];
    endfunction

    task automatic do_set_WSTRB( logic [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  WSTRB_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WSTRB = WSTRB_param;
        else
            m_WSTRB <= WSTRB_param;
    endtask

    task automatic do_set_WSTRB_index1( int _this_dot_1, logic  WSTRB_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WSTRB[_this_dot_1] = WSTRB_param;
        else
            m_WSTRB[_this_dot_1] <= WSTRB_param;
    endtask

    function automatic logic [(((AXI4_WDATA_WIDTH / 8)) - 1):0]   do_get_WSTRB(  );
        return WSTRB;
    endfunction

    function automatic logic   do_get_WSTRB_index1( int _this_dot_1 );
        return WSTRB[_this_dot_1];
    endfunction

    task automatic do_set_WLAST( logic WLAST_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WLAST = WLAST_param;
        else
            m_WLAST <= WLAST_param;
    endtask

    function automatic logic do_get_WLAST(  );
        return WLAST;
    endfunction

    task automatic do_set_WUSER( logic [((AXI4_USER_WIDTH) - 1):0]  WUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WUSER = WUSER_param;
        else
            m_WUSER <= WUSER_param;
    endtask

    task automatic do_set_WUSER_index1( int _this_dot_1, logic  WUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WUSER[_this_dot_1] = WUSER_param;
        else
            m_WUSER[_this_dot_1] <= WUSER_param;
    endtask

    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   do_get_WUSER(  );
        return WUSER;
    endfunction

    function automatic logic   do_get_WUSER_index1( int _this_dot_1 );
        return WUSER[_this_dot_1];
    endfunction

    task automatic do_set_WREADY( logic WREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_WREADY = WREADY_param;
        else
            m_WREADY <= WREADY_param;
    endtask

    function automatic logic do_get_WREADY(  );
        return WREADY;
    endfunction

    task automatic do_set_BVALID( logic BVALID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BVALID = BVALID_param;
        else
            m_BVALID <= BVALID_param;
    endtask

    function automatic logic do_get_BVALID(  );
        return BVALID;
    endfunction

    task automatic do_set_BRESP( logic [1:0] BRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BRESP = BRESP_param;
        else
            m_BRESP <= BRESP_param;
    endtask

    task automatic do_set_BRESP_index1( int _this_dot_1, logic  BRESP_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BRESP[_this_dot_1] = BRESP_param;
        else
            m_BRESP[_this_dot_1] <= BRESP_param;
    endtask

    function automatic logic [1:0]  do_get_BRESP(  );
        return BRESP;
    endfunction

    function automatic logic   do_get_BRESP_index1( int _this_dot_1 );
        return BRESP[_this_dot_1];
    endfunction

    task automatic do_set_BID( logic [((AXI4_ID_WIDTH) - 1):0]  BID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BID = BID_param;
        else
            m_BID <= BID_param;
    endtask

    task automatic do_set_BID_index1( int _this_dot_1, logic  BID_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BID[_this_dot_1] = BID_param;
        else
            m_BID[_this_dot_1] <= BID_param;
    endtask

    function automatic logic [((AXI4_ID_WIDTH) - 1):0]   do_get_BID(  );
        return BID;
    endfunction

    function automatic logic   do_get_BID_index1( int _this_dot_1 );
        return BID[_this_dot_1];
    endfunction

    task automatic do_set_BUSER( logic [((AXI4_USER_WIDTH) - 1):0]  BUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BUSER = BUSER_param;
        else
            m_BUSER <= BUSER_param;
    endtask

    task automatic do_set_BUSER_index1( int _this_dot_1, logic  BUSER_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BUSER[_this_dot_1] = BUSER_param;
        else
            m_BUSER[_this_dot_1] <= BUSER_param;
    endtask

    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   do_get_BUSER(  );
        return BUSER;
    endfunction

    function automatic logic   do_get_BUSER_index1( int _this_dot_1 );
        return BUSER[_this_dot_1];
    endfunction

    task automatic do_set_BREADY( logic BREADY_param = 'z, bit non_blocking = 1'b0 );
        if ( non_blocking == 1'b0 )
            m_BREADY = BREADY_param;
        else
            m_BREADY <= BREADY_param;
    endtask

    function automatic logic do_get_BREADY(  );
        return BREADY;
    endfunction

    //------------------------------------------------------------------------------
    // Tasks to wait for a change to a global variable with read access
    //------------------------------------------------------------------------------

    task automatic do_wait_for_config_interface_type(  );
        begin
            axi4_interface_type_e _temp_config_interface_type;
            _temp_config_interface_type = config_interface_type;
            wait( _temp_config_interface_type != config_interface_type );
        end
    endtask

    task automatic do_wait_for_config_clk_init_value(  );
        begin
            bit _temp_config_clk_init_value;
            _temp_config_clk_init_value = config_clk_init_value;
            wait( _temp_config_clk_init_value != config_clk_init_value );
        end
    endtask

    task automatic do_wait_for_config_clk_phase_shift(  );
        begin
            longint unsigned _temp_config_clk_phase_shift;
            _temp_config_clk_phase_shift = config_clk_phase_shift;
            wait( _temp_config_clk_phase_shift != config_clk_phase_shift );
        end
    endtask

    task automatic do_wait_for_config_clk_1st_time(  );
        begin
            longint unsigned _temp_config_clk_1st_time;
            _temp_config_clk_1st_time = config_clk_1st_time;
            wait( _temp_config_clk_1st_time != config_clk_1st_time );
        end
    endtask

    task automatic do_wait_for_config_clk_2nd_time(  );
        begin
            longint unsigned _temp_config_clk_2nd_time;
            _temp_config_clk_2nd_time = config_clk_2nd_time;
            wait( _temp_config_clk_2nd_time != config_clk_2nd_time );
        end
    endtask

    task automatic do_wait_for_config_setup_time(  );
        begin
            longint unsigned _temp_config_setup_time;
            _temp_config_setup_time = config_setup_time;
            wait( _temp_config_setup_time != config_setup_time );
        end
    endtask

    task automatic do_wait_for_config_hold_time(  );
        begin
            longint unsigned _temp_config_hold_time;
            _temp_config_hold_time = config_hold_time;
            wait( _temp_config_hold_time != config_hold_time );
        end
    endtask

    task automatic do_wait_for_config_burst_timeout_factor(  );
        begin
            int unsigned _temp_config_burst_timeout_factor;
            _temp_config_burst_timeout_factor = config_burst_timeout_factor;
            wait( _temp_config_burst_timeout_factor != config_burst_timeout_factor );
        end
    endtask

    task automatic do_wait_for_config_max_transaction_time_factor(  );
        begin
            int unsigned _temp_config_max_transaction_time_factor;
            _temp_config_max_transaction_time_factor = config_max_transaction_time_factor;
            wait( _temp_config_max_transaction_time_factor != config_max_transaction_time_factor );
        end
    endtask

    task automatic do_wait_for_config_write_ctrl_first_ratio(  );
        begin
            int _temp_config_write_ctrl_first_ratio;
            _temp_config_write_ctrl_first_ratio = config_write_ctrl_first_ratio;
            wait( _temp_config_write_ctrl_first_ratio != config_write_ctrl_first_ratio );
        end
    endtask

    task automatic do_wait_for_config_write_data_first_ratio(  );
        begin
            int _temp_config_write_data_first_ratio;
            _temp_config_write_data_first_ratio = config_write_data_first_ratio;
            wait( _temp_config_write_data_first_ratio != config_write_data_first_ratio );
        end
    endtask

    task automatic do_wait_for_config_reset_low_clocks(  );
        begin
            int _temp_config_reset_low_clocks;
            _temp_config_reset_low_clocks = config_reset_low_clocks;
            wait( _temp_config_reset_low_clocks != config_reset_low_clocks );
        end
    endtask

    task automatic do_wait_for_config_reset_hold_time(  );
        begin
            int _temp_config_reset_hold_time;
            _temp_config_reset_hold_time = config_reset_hold_time;
            wait( _temp_config_reset_hold_time != config_reset_hold_time );
        end
    endtask

    task automatic do_wait_for_config_enable_rlast(  );
        begin
            bit _temp_config_enable_rlast;
            _temp_config_enable_rlast = config_enable_rlast;
            wait( _temp_config_enable_rlast != config_enable_rlast );
        end
    endtask

    task automatic do_wait_for_config_enable_slave_exclusive(  );
        begin
            bit _temp_config_enable_slave_exclusive;
            _temp_config_enable_slave_exclusive = config_enable_slave_exclusive;
            wait( _temp_config_enable_slave_exclusive != config_enable_slave_exclusive );
        end
    endtask

    task automatic do_wait_for_config_enable_burst_reserved_value(  );
        begin
            bit _temp_config_enable_burst_reserved_value;
            _temp_config_enable_burst_reserved_value = config_enable_burst_reserved_value;
            wait( _temp_config_enable_burst_reserved_value != config_enable_burst_reserved_value );
        end
    endtask

    task automatic do_wait_for_config_enable_cache_value(  );
        begin
            bit [15:0] _temp_config_enable_cache_value;
            _temp_config_enable_cache_value = config_enable_cache_value;
            wait( _temp_config_enable_cache_value != config_enable_cache_value );
        end
    endtask

    task automatic do_wait_for_config_enable_cache_value_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_enable_cache_value;
            _temp_config_enable_cache_value = config_enable_cache_value[_this_dot_1];
            wait( _temp_config_enable_cache_value != config_enable_cache_value[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_internal_dummy_variable(  );
        begin
            axi4_error_e _temp_internal_dummy_variable;
            _temp_internal_dummy_variable = internal_dummy_variable;
            wait( _temp_internal_dummy_variable != internal_dummy_variable );
        end
    endtask

    task automatic do_wait_for_config_axi4lite_interface(  );
        begin
            bit _temp_config_axi4lite_interface;
            _temp_config_axi4lite_interface = config_axi4lite_interface;
            wait( _temp_config_axi4lite_interface != config_axi4lite_interface );
        end
    endtask

    task automatic do_wait_for_config_axi4lite_tr_id(  );
        begin
            bit [((AXI4_ID_WIDTH) - 1):0]  _temp_config_axi4lite_tr_id;
            _temp_config_axi4lite_tr_id = config_axi4lite_tr_id;
            wait( _temp_config_axi4lite_tr_id != config_axi4lite_tr_id );
        end
    endtask

    task automatic do_wait_for_config_axi4lite_tr_id_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_axi4lite_tr_id;
            _temp_config_axi4lite_tr_id = config_axi4lite_tr_id[_this_dot_1];
            wait( _temp_config_axi4lite_tr_id != config_axi4lite_tr_id[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_enable_all_assertions(  );
        begin
            bit _temp_config_enable_all_assertions;
            _temp_config_enable_all_assertions = config_enable_all_assertions;
            wait( _temp_config_enable_all_assertions != config_enable_all_assertions );
        end
    endtask

    task automatic do_wait_for_config_enable_assertion(  );
        begin
            bit [255:0] _temp_config_enable_assertion;
            _temp_config_enable_assertion = config_enable_assertion;
            wait( _temp_config_enable_assertion != config_enable_assertion );
        end
    endtask

    task automatic do_wait_for_config_enable_assertion_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_enable_assertion;
            _temp_config_enable_assertion = config_enable_assertion[_this_dot_1];
            wait( _temp_config_enable_assertion != config_enable_assertion[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_enable_error(  );
        begin
            bit [255:0] _temp_config_enable_error;
            _temp_config_enable_error = config_enable_error;
            wait( _temp_config_enable_error != config_enable_error );
        end
    endtask

    task automatic do_wait_for_config_enable_error_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_enable_error;
            _temp_config_enable_error = config_enable_error[_this_dot_1];
            wait( _temp_config_enable_error != config_enable_error[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_max_latency_AWVALID_assertion_to_AWREADY(  );
        begin
            int unsigned _temp_config_max_latency_AWVALID_assertion_to_AWREADY;
            _temp_config_max_latency_AWVALID_assertion_to_AWREADY = config_max_latency_AWVALID_assertion_to_AWREADY;
            wait( _temp_config_max_latency_AWVALID_assertion_to_AWREADY != config_max_latency_AWVALID_assertion_to_AWREADY );
        end
    endtask

    task automatic do_wait_for_config_max_latency_ARVALID_assertion_to_ARREADY(  );
        begin
            int unsigned _temp_config_max_latency_ARVALID_assertion_to_ARREADY;
            _temp_config_max_latency_ARVALID_assertion_to_ARREADY = config_max_latency_ARVALID_assertion_to_ARREADY;
            wait( _temp_config_max_latency_ARVALID_assertion_to_ARREADY != config_max_latency_ARVALID_assertion_to_ARREADY );
        end
    endtask

    task automatic do_wait_for_config_max_latency_RVALID_assertion_to_RREADY(  );
        begin
            int unsigned _temp_config_max_latency_RVALID_assertion_to_RREADY;
            _temp_config_max_latency_RVALID_assertion_to_RREADY = config_max_latency_RVALID_assertion_to_RREADY;
            wait( _temp_config_max_latency_RVALID_assertion_to_RREADY != config_max_latency_RVALID_assertion_to_RREADY );
        end
    endtask

    task automatic do_wait_for_config_max_latency_BVALID_assertion_to_BREADY(  );
        begin
            int unsigned _temp_config_max_latency_BVALID_assertion_to_BREADY;
            _temp_config_max_latency_BVALID_assertion_to_BREADY = config_max_latency_BVALID_assertion_to_BREADY;
            wait( _temp_config_max_latency_BVALID_assertion_to_BREADY != config_max_latency_BVALID_assertion_to_BREADY );
        end
    endtask

    task automatic do_wait_for_config_max_latency_WVALID_assertion_to_WREADY(  );
        begin
            int unsigned _temp_config_max_latency_WVALID_assertion_to_WREADY;
            _temp_config_max_latency_WVALID_assertion_to_WREADY = config_max_latency_WVALID_assertion_to_WREADY;
            wait( _temp_config_max_latency_WVALID_assertion_to_WREADY != config_max_latency_WVALID_assertion_to_WREADY );
        end
    endtask

    task automatic do_wait_for_config_enable_qos(  );
        begin
            bit _temp_config_enable_qos;
            _temp_config_enable_qos = config_enable_qos;
            wait( _temp_config_enable_qos != config_enable_qos );
        end
    endtask

    task automatic do_wait_for_config_enable_region_support(  );
        begin
            bit _temp_config_enable_region_support;
            _temp_config_enable_region_support = config_enable_region_support;
            wait( _temp_config_enable_region_support != config_enable_region_support );
        end
    endtask

    task automatic do_wait_for_config_slave_regions(  );
        begin
            int _temp_config_slave_regions;
            _temp_config_slave_regions = config_slave_regions;
            wait( _temp_config_slave_regions != config_slave_regions );
        end
    endtask

    task automatic do_wait_for_config_region(  );
        begin
            bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  _temp_config_region;
            _temp_config_region = config_region;
            wait( _temp_config_region != config_region );
        end
    endtask

    task automatic do_wait_for_config_region_index1( input int _this_dot_1 );
        begin
            bit [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  _temp_config_region;
            _temp_config_region = config_region[_this_dot_1];
            wait( _temp_config_region != config_region[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_region_index2( input int _this_dot_1, input int _this_dot_2 );
        begin
            bit  _temp_config_region;
            _temp_config_region = config_region[_this_dot_1][_this_dot_2];
            wait( _temp_config_region != config_region[_this_dot_1][_this_dot_2] );
        end
    endtask

    task automatic do_wait_for_region_error_state(  );
        begin
            bit _temp_region_error_state;
            _temp_region_error_state = region_error_state;
            wait( _temp_region_error_state != region_error_state );
        end
    endtask

    task automatic do_wait_for_region_map_lb(  );
        begin
            longint unsigned _temp_region_map_lb [((AXI4_REGION_MAP_SIZE) - 1):0];
            _temp_region_map_lb = region_map_lb;
            wait( _temp_region_map_lb != region_map_lb );
        end
    endtask

    task automatic do_wait_for_region_map_lb_index1( input int _this_dot_1 );
        begin
            longint unsigned _temp_region_map_lb;
            _temp_region_map_lb = region_map_lb[_this_dot_1];
            wait( _temp_region_map_lb != region_map_lb[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_region_map_ub(  );
        begin
            longint unsigned _temp_region_map_ub [((AXI4_REGION_MAP_SIZE) - 1):0];
            _temp_region_map_ub = region_map_ub;
            wait( _temp_region_map_ub != region_map_ub );
        end
    endtask

    task automatic do_wait_for_region_map_ub_index1( input int _this_dot_1 );
        begin
            longint unsigned _temp_region_map_ub;
            _temp_region_map_ub = region_map_ub[_this_dot_1];
            wait( _temp_region_map_ub != region_map_ub[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_region_map_region(  );
        begin
            byte unsigned _temp_region_map_region [((AXI4_REGION_MAP_SIZE) - 1):0];
            _temp_region_map_region = region_map_region;
            wait( _temp_region_map_region != region_map_region );
        end
    endtask

    task automatic do_wait_for_region_map_region_index1( input int _this_dot_1 );
        begin
            byte unsigned _temp_region_map_region;
            _temp_region_map_region = region_map_region[_this_dot_1];
            wait( _temp_region_map_region != region_map_region[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_cacheable(  );
        begin
            byte unsigned _temp_cacheable [((AXI4_REGION_MAP_SIZE) - 1):0];
            _temp_cacheable = cacheable;
            wait( _temp_cacheable != cacheable );
        end
    endtask

    task automatic do_wait_for_cacheable_index1( input int _this_dot_1 );
        begin
            byte unsigned _temp_cacheable;
            _temp_cacheable = cacheable[_this_dot_1];
            wait( _temp_cacheable != cacheable[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_read_data_reordering_depth(  );
        begin
            int unsigned _temp_config_read_data_reordering_depth;
            _temp_config_read_data_reordering_depth = config_read_data_reordering_depth;
            wait( _temp_config_read_data_reordering_depth != config_read_data_reordering_depth );
        end
    endtask

    task automatic do_wait_for_config_slave_start_addr(  );
        begin
            bit [((AXI4_ADDRESS_WIDTH) - 1):0]  _temp_config_slave_start_addr;
            _temp_config_slave_start_addr = config_slave_start_addr;
            wait( _temp_config_slave_start_addr != config_slave_start_addr );
        end
    endtask

    task automatic do_wait_for_config_slave_start_addr_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_slave_start_addr;
            _temp_config_slave_start_addr = config_slave_start_addr[_this_dot_1];
            wait( _temp_config_slave_start_addr != config_slave_start_addr[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_slave_end_addr(  );
        begin
            bit [((AXI4_ADDRESS_WIDTH) - 1):0]  _temp_config_slave_end_addr;
            _temp_config_slave_end_addr = config_slave_end_addr;
            wait( _temp_config_slave_end_addr != config_slave_end_addr );
        end
    endtask

    task automatic do_wait_for_config_slave_end_addr_index1( input int _this_dot_1 );
        begin
            bit  _temp_config_slave_end_addr;
            _temp_config_slave_end_addr = config_slave_end_addr[_this_dot_1];
            wait( _temp_config_slave_end_addr != config_slave_end_addr[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_slave_enabled_non_contiguous_address_spaces(  );
        begin
            int _temp_config_slave_enabled_non_contiguous_address_spaces;
            _temp_config_slave_enabled_non_contiguous_address_spaces = config_slave_enabled_non_contiguous_address_spaces;
            wait( _temp_config_slave_enabled_non_contiguous_address_spaces != config_slave_enabled_non_contiguous_address_spaces );
        end
    endtask

    task automatic do_wait_for_config_slave_possess_multiple_non_contiguous_address_spaces(  );
        begin
            bit _temp_config_slave_possess_multiple_non_contiguous_address_spaces;
            _temp_config_slave_possess_multiple_non_contiguous_address_spaces = config_slave_possess_multiple_non_contiguous_address_spaces;
            wait( _temp_config_slave_possess_multiple_non_contiguous_address_spaces != config_slave_possess_multiple_non_contiguous_address_spaces );
        end
    endtask

    task automatic do_wait_for_config_slave_multiple_non_contiguous_start_address_range(  );
        begin
            bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  _temp_config_slave_multiple_non_contiguous_start_address_range;
            _temp_config_slave_multiple_non_contiguous_start_address_range = config_slave_multiple_non_contiguous_start_address_range;
            wait( _temp_config_slave_multiple_non_contiguous_start_address_range != config_slave_multiple_non_contiguous_start_address_range );
        end
    endtask

    task automatic do_wait_for_config_slave_multiple_non_contiguous_start_address_range_index1( input int _this_dot_1 );
        begin
            bit [((AXI4_ADDRESS_WIDTH) - 1):0]  _temp_config_slave_multiple_non_contiguous_start_address_range;
            _temp_config_slave_multiple_non_contiguous_start_address_range = config_slave_multiple_non_contiguous_start_address_range[_this_dot_1];
            wait( _temp_config_slave_multiple_non_contiguous_start_address_range != config_slave_multiple_non_contiguous_start_address_range[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_slave_multiple_non_contiguous_start_address_range_index2( input int _this_dot_1, input int _this_dot_2 );
        begin
            bit  _temp_config_slave_multiple_non_contiguous_start_address_range;
            _temp_config_slave_multiple_non_contiguous_start_address_range = config_slave_multiple_non_contiguous_start_address_range[_this_dot_1][_this_dot_2];
            wait( _temp_config_slave_multiple_non_contiguous_start_address_range != config_slave_multiple_non_contiguous_start_address_range[_this_dot_1][_this_dot_2] );
        end
    endtask

    task automatic do_wait_for_config_slave_multiple_non_contiguous_end_address_range(  );
        begin
            bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  _temp_config_slave_multiple_non_contiguous_end_address_range;
            _temp_config_slave_multiple_non_contiguous_end_address_range = config_slave_multiple_non_contiguous_end_address_range;
            wait( _temp_config_slave_multiple_non_contiguous_end_address_range != config_slave_multiple_non_contiguous_end_address_range );
        end
    endtask

    task automatic do_wait_for_config_slave_multiple_non_contiguous_end_address_range_index1( input int _this_dot_1 );
        begin
            bit [((AXI4_ADDRESS_WIDTH) - 1):0]  _temp_config_slave_multiple_non_contiguous_end_address_range;
            _temp_config_slave_multiple_non_contiguous_end_address_range = config_slave_multiple_non_contiguous_end_address_range[_this_dot_1];
            wait( _temp_config_slave_multiple_non_contiguous_end_address_range != config_slave_multiple_non_contiguous_end_address_range[_this_dot_1] );
        end
    endtask

    task automatic do_wait_for_config_slave_multiple_non_contiguous_end_address_range_index2( input int _this_dot_1, input int _this_dot_2 );
        begin
            bit  _temp_config_slave_multiple_non_contiguous_end_address_range;
            _temp_config_slave_multiple_non_contiguous_end_address_range = config_slave_multiple_non_contiguous_end_address_range[_this_dot_1][_this_dot_2];
            wait( _temp_config_slave_multiple_non_contiguous_end_address_range != config_slave_multiple_non_contiguous_end_address_range[_this_dot_1][_this_dot_2] );
        end
    endtask

    task automatic do_wait_for_config_protect_ready(  );
        begin
            bit _temp_config_protect_ready;
            _temp_config_protect_ready = config_protect_ready;
            wait( _temp_config_protect_ready != config_protect_ready );
        end
    endtask

    task automatic do_wait_for_master_end_tlm_status(  );
        begin
            bit _temp_master_end_tlm_status;
            _temp_master_end_tlm_status = master_end_tlm_status;
            wait( _temp_master_end_tlm_status != master_end_tlm_status );
        end
    endtask

    task automatic do_wait_for_master_end_wlm_status(  );
        begin
            bit _temp_master_end_wlm_status;
            _temp_master_end_wlm_status = master_end_wlm_status;
            wait( _temp_master_end_wlm_status != master_end_wlm_status );
        end
    endtask

    task automatic do_wait_for_slave_end_tlm_status(  );
        begin
            bit _temp_slave_end_tlm_status;
            _temp_slave_end_tlm_status = slave_end_tlm_status;
            wait( _temp_slave_end_tlm_status != slave_end_tlm_status );
        end
    endtask

    task automatic do_wait_for_slave_end_wlm_status(  );
        begin
            bit _temp_slave_end_wlm_status;
            _temp_slave_end_wlm_status = slave_end_wlm_status;
            wait( _temp_slave_end_wlm_status != slave_end_wlm_status );
        end
    endtask

    task automatic do_wait_for_clock_source_end_tlm_status(  );
        begin
            bit _temp_clock_source_end_tlm_status;
            _temp_clock_source_end_tlm_status = clock_source_end_tlm_status;
            wait( _temp_clock_source_end_tlm_status != clock_source_end_tlm_status );
        end
    endtask

    task automatic do_wait_for_clock_source_end_wlm_status(  );
        begin
            bit _temp_clock_source_end_wlm_status;
            _temp_clock_source_end_wlm_status = clock_source_end_wlm_status;
            wait( _temp_clock_source_end_wlm_status != clock_source_end_wlm_status );
        end
    endtask

    task automatic do_wait_for_reset_source_end_tlm_status(  );
        begin
            bit _temp_reset_source_end_tlm_status;
            _temp_reset_source_end_tlm_status = reset_source_end_tlm_status;
            wait( _temp_reset_source_end_tlm_status != reset_source_end_tlm_status );
        end
    endtask

    task automatic do_wait_for_reset_source_end_wlm_status(  );
        begin
            bit _temp_reset_source_end_wlm_status;
            _temp_reset_source_end_wlm_status = reset_source_end_wlm_status;
            wait( _temp_reset_source_end_wlm_status != reset_source_end_wlm_status );
        end
    endtask

    task automatic do_wait_for_config_max_outstanding_wr(  );
        begin
            int _temp_config_max_outstanding_wr;
            _temp_config_max_outstanding_wr = config_max_outstanding_wr;
            wait( _temp_config_max_outstanding_wr != config_max_outstanding_wr );
        end
    endtask

    task automatic do_wait_for_config_max_outstanding_rd(  );
        begin
            int _temp_config_max_outstanding_rd;
            _temp_config_max_outstanding_rd = config_max_outstanding_rd;
            wait( _temp_config_max_outstanding_rd != config_max_outstanding_rd );
        end
    endtask

    task automatic do_wait_for_config_num_outstanding_wr_phase(  );
        begin
            int _temp_config_num_outstanding_wr_phase;
            _temp_config_num_outstanding_wr_phase = config_num_outstanding_wr_phase;
            wait( _temp_config_num_outstanding_wr_phase != config_num_outstanding_wr_phase );
        end
    endtask

    task automatic do_wait_for_config_num_outstanding_rd_phase(  );
        begin
            int _temp_config_num_outstanding_rd_phase;
            _temp_config_num_outstanding_rd_phase = config_num_outstanding_rd_phase;
            wait( _temp_config_num_outstanding_rd_phase != config_num_outstanding_rd_phase );
        end
    endtask

    task automatic do_wait_for_config_enable_warnings(  );
        begin
            bit _temp_config_enable_warnings;
            _temp_config_enable_warnings = config_enable_warnings;
            wait( _temp_config_enable_warnings != config_enable_warnings );
        end
    endtask

    task automatic do_wait_for_config_enable_errors(  );
        begin
            bit _temp_config_enable_errors;
            _temp_config_enable_errors = config_enable_errors;
            wait( _temp_config_enable_errors != config_enable_errors );
        end
    endtask

    task automatic do_wait_for_config_enable_exclusive_checks(  );
        begin
            bit _temp_config_enable_exclusive_checks;
            _temp_config_enable_exclusive_checks = config_enable_exclusive_checks;
            wait( _temp_config_enable_exclusive_checks != config_enable_exclusive_checks );
        end
    endtask

    task automatic do_wait_for_config_warn_on_slave_errors(  );
        begin
            bit _temp_config_warn_on_slave_errors;
            _temp_config_warn_on_slave_errors = config_warn_on_slave_errors;
            wait( _temp_config_warn_on_slave_errors != config_warn_on_slave_errors );
        end
    endtask

    task automatic do_wait_for_config_error_on_deleted_valid_cycles(  );
        begin
            bit _temp_config_error_on_deleted_valid_cycles;
            _temp_config_error_on_deleted_valid_cycles = config_error_on_deleted_valid_cycles;
            wait( _temp_config_error_on_deleted_valid_cycles != config_error_on_deleted_valid_cycles );
        end
    endtask

    task automatic do_wait_for_config_stats_enable(  );
        begin
            bit _temp_config_stats_enable;
            _temp_config_stats_enable = config_stats_enable;
            wait( _temp_config_stats_enable != config_stats_enable );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_occupancy(  );
        begin
            bit _temp_config_stats_enable_read_occupancy;
            _temp_config_stats_enable_read_occupancy = config_stats_enable_read_occupancy;
            wait( _temp_config_stats_enable_read_occupancy != config_stats_enable_read_occupancy );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_occupancy(  );
        begin
            bit _temp_config_stats_enable_write_occupancy;
            _temp_config_stats_enable_write_occupancy = config_stats_enable_write_occupancy;
            wait( _temp_config_stats_enable_write_occupancy != config_stats_enable_write_occupancy );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_data_occupancy(  );
        begin
            bit _temp_config_stats_enable_read_data_occupancy;
            _temp_config_stats_enable_read_data_occupancy = config_stats_enable_read_data_occupancy;
            wait( _temp_config_stats_enable_read_data_occupancy != config_stats_enable_read_data_occupancy );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_data_occupancy(  );
        begin
            bit _temp_config_stats_enable_write_data_occupancy;
            _temp_config_stats_enable_write_data_occupancy = config_stats_enable_write_data_occupancy;
            wait( _temp_config_stats_enable_write_data_occupancy != config_stats_enable_write_data_occupancy );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_latency(  );
        begin
            bit _temp_config_stats_enable_read_latency;
            _temp_config_stats_enable_read_latency = config_stats_enable_read_latency;
            wait( _temp_config_stats_enable_read_latency != config_stats_enable_read_latency );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_latency(  );
        begin
            bit _temp_config_stats_enable_write_latency;
            _temp_config_stats_enable_write_latency = config_stats_enable_write_latency;
            wait( _temp_config_stats_enable_write_latency != config_stats_enable_write_latency );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_address_waits(  );
        begin
            bit _temp_config_stats_enable_read_address_waits;
            _temp_config_stats_enable_read_address_waits = config_stats_enable_read_address_waits;
            wait( _temp_config_stats_enable_read_address_waits != config_stats_enable_read_address_waits );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_data_waits(  );
        begin
            bit _temp_config_stats_enable_read_data_waits;
            _temp_config_stats_enable_read_data_waits = config_stats_enable_read_data_waits;
            wait( _temp_config_stats_enable_read_data_waits != config_stats_enable_read_data_waits );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_address_waits(  );
        begin
            bit _temp_config_stats_enable_write_address_waits;
            _temp_config_stats_enable_write_address_waits = config_stats_enable_write_address_waits;
            wait( _temp_config_stats_enable_write_address_waits != config_stats_enable_write_address_waits );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_data_waits(  );
        begin
            bit _temp_config_stats_enable_write_data_waits;
            _temp_config_stats_enable_write_data_waits = config_stats_enable_write_data_waits;
            wait( _temp_config_stats_enable_write_data_waits != config_stats_enable_write_data_waits );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_response_waits(  );
        begin
            bit _temp_config_stats_enable_write_response_waits;
            _temp_config_stats_enable_write_response_waits = config_stats_enable_write_response_waits;
            wait( _temp_config_stats_enable_write_response_waits != config_stats_enable_write_response_waits );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_read_bandwidth(  );
        begin
            bit _temp_config_stats_enable_read_bandwidth;
            _temp_config_stats_enable_read_bandwidth = config_stats_enable_read_bandwidth;
            wait( _temp_config_stats_enable_read_bandwidth != config_stats_enable_read_bandwidth );
        end
    endtask

    task automatic do_wait_for_config_stats_enable_write_bandwidth(  );
        begin
            bit _temp_config_stats_enable_write_bandwidth;
            _temp_config_stats_enable_write_bandwidth = config_stats_enable_write_bandwidth;
            wait( _temp_config_stats_enable_write_bandwidth != config_stats_enable_write_bandwidth );
        end
    endtask

    task automatic do_wait_for_stats_rw_transaction_last_duration(  );
        begin
            int _temp_stats_rw_transaction_last_duration;
            _temp_stats_rw_transaction_last_duration = stats_rw_transaction_last_duration;
            wait( _temp_stats_rw_transaction_last_duration != stats_rw_transaction_last_duration );
        end
    endtask

    task automatic do_wait_for_config_stats_read_occupancy_step(  );
        begin
            int _temp_config_stats_read_occupancy_step;
            _temp_config_stats_read_occupancy_step = config_stats_read_occupancy_step;
            wait( _temp_config_stats_read_occupancy_step != config_stats_read_occupancy_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_occupancy_multiple(  );
        begin
            int _temp_config_stats_read_occupancy_multiple;
            _temp_config_stats_read_occupancy_multiple = config_stats_read_occupancy_multiple;
            wait( _temp_config_stats_read_occupancy_multiple != config_stats_read_occupancy_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_active(  );
        begin
            bit _temp_stats_read_active;
            _temp_stats_read_active = stats_read_active;
            wait( _temp_stats_read_active != stats_read_active );
        end
    endtask

    task automatic do_wait_for_stats_read_occupancy_sw(  );
        begin
            int _temp_stats_read_occupancy_sw;
            _temp_stats_read_occupancy_sw = stats_read_occupancy_sw;
            wait( _temp_stats_read_occupancy_sw != stats_read_occupancy_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_idle_sw(  );
        begin
            int _temp_stats_read_idle_sw;
            _temp_stats_read_idle_sw = stats_read_idle_sw;
            wait( _temp_stats_read_idle_sw != stats_read_idle_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_occupancy_min(  );
        begin
            int _temp_stats_read_occupancy_min;
            _temp_stats_read_occupancy_min = stats_read_occupancy_min;
            wait( _temp_stats_read_occupancy_min != stats_read_occupancy_min );
        end
    endtask

    task automatic do_wait_for_stats_read_idle_min(  );
        begin
            int _temp_stats_read_idle_min;
            _temp_stats_read_idle_min = stats_read_idle_min;
            wait( _temp_stats_read_idle_min != stats_read_idle_min );
        end
    endtask

    task automatic do_wait_for_stats_read_occupancy_max(  );
        begin
            int _temp_stats_read_occupancy_max;
            _temp_stats_read_occupancy_max = stats_read_occupancy_max;
            wait( _temp_stats_read_occupancy_max != stats_read_occupancy_max );
        end
    endtask

    task automatic do_wait_for_stats_read_idle_max(  );
        begin
            int _temp_stats_read_idle_max;
            _temp_stats_read_idle_max = stats_read_idle_max;
            wait( _temp_stats_read_idle_max != stats_read_idle_max );
        end
    endtask

    task automatic do_wait_for_stats_read_occupancy_mean(  );
        begin
            int _temp_stats_read_occupancy_mean;
            _temp_stats_read_occupancy_mean = stats_read_occupancy_mean;
            wait( _temp_stats_read_occupancy_mean != stats_read_occupancy_mean );
        end
    endtask

    task automatic do_wait_for_stats_read_idle_mean(  );
        begin
            int _temp_stats_read_idle_mean;
            _temp_stats_read_idle_mean = stats_read_idle_mean;
            wait( _temp_stats_read_idle_mean != stats_read_idle_mean );
        end
    endtask

    task automatic do_wait_for_stats_read_last_duration(  );
        begin
            int _temp_stats_read_last_duration;
            _temp_stats_read_last_duration = stats_read_last_duration;
            wait( _temp_stats_read_last_duration != stats_read_last_duration );
        end
    endtask

    task automatic do_wait_for_config_stats_write_occupancy_step(  );
        begin
            int _temp_config_stats_write_occupancy_step;
            _temp_config_stats_write_occupancy_step = config_stats_write_occupancy_step;
            wait( _temp_config_stats_write_occupancy_step != config_stats_write_occupancy_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_occupancy_multiple(  );
        begin
            int _temp_config_stats_write_occupancy_multiple;
            _temp_config_stats_write_occupancy_multiple = config_stats_write_occupancy_multiple;
            wait( _temp_config_stats_write_occupancy_multiple != config_stats_write_occupancy_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_active(  );
        begin
            bit _temp_stats_write_active;
            _temp_stats_write_active = stats_write_active;
            wait( _temp_stats_write_active != stats_write_active );
        end
    endtask

    task automatic do_wait_for_stats_write_occupancy_sw(  );
        begin
            int _temp_stats_write_occupancy_sw;
            _temp_stats_write_occupancy_sw = stats_write_occupancy_sw;
            wait( _temp_stats_write_occupancy_sw != stats_write_occupancy_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_idle_sw(  );
        begin
            int _temp_stats_write_idle_sw;
            _temp_stats_write_idle_sw = stats_write_idle_sw;
            wait( _temp_stats_write_idle_sw != stats_write_idle_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_occupancy_min(  );
        begin
            int _temp_stats_write_occupancy_min;
            _temp_stats_write_occupancy_min = stats_write_occupancy_min;
            wait( _temp_stats_write_occupancy_min != stats_write_occupancy_min );
        end
    endtask

    task automatic do_wait_for_stats_write_idle_min(  );
        begin
            int _temp_stats_write_idle_min;
            _temp_stats_write_idle_min = stats_write_idle_min;
            wait( _temp_stats_write_idle_min != stats_write_idle_min );
        end
    endtask

    task automatic do_wait_for_stats_write_occupancy_max(  );
        begin
            int _temp_stats_write_occupancy_max;
            _temp_stats_write_occupancy_max = stats_write_occupancy_max;
            wait( _temp_stats_write_occupancy_max != stats_write_occupancy_max );
        end
    endtask

    task automatic do_wait_for_stats_write_idle_max(  );
        begin
            int _temp_stats_write_idle_max;
            _temp_stats_write_idle_max = stats_write_idle_max;
            wait( _temp_stats_write_idle_max != stats_write_idle_max );
        end
    endtask

    task automatic do_wait_for_stats_write_occupancy_mean(  );
        begin
            int _temp_stats_write_occupancy_mean;
            _temp_stats_write_occupancy_mean = stats_write_occupancy_mean;
            wait( _temp_stats_write_occupancy_mean != stats_write_occupancy_mean );
        end
    endtask

    task automatic do_wait_for_stats_write_idle_mean(  );
        begin
            int _temp_stats_write_idle_mean;
            _temp_stats_write_idle_mean = stats_write_idle_mean;
            wait( _temp_stats_write_idle_mean != stats_write_idle_mean );
        end
    endtask

    task automatic do_wait_for_stats_write_last_duration(  );
        begin
            int _temp_stats_write_last_duration;
            _temp_stats_write_last_duration = stats_write_last_duration;
            wait( _temp_stats_write_last_duration != stats_write_last_duration );
        end
    endtask

    task automatic do_wait_for_config_stats_read_data_occupancy_step(  );
        begin
            int _temp_config_stats_read_data_occupancy_step;
            _temp_config_stats_read_data_occupancy_step = config_stats_read_data_occupancy_step;
            wait( _temp_config_stats_read_data_occupancy_step != config_stats_read_data_occupancy_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_data_occupancy_multiple(  );
        begin
            int _temp_config_stats_read_data_occupancy_multiple;
            _temp_config_stats_read_data_occupancy_multiple = config_stats_read_data_occupancy_multiple;
            wait( _temp_config_stats_read_data_occupancy_multiple != config_stats_read_data_occupancy_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_data_occupancy_sw(  );
        begin
            int _temp_stats_read_data_occupancy_sw;
            _temp_stats_read_data_occupancy_sw = stats_read_data_occupancy_sw;
            wait( _temp_stats_read_data_occupancy_sw != stats_read_data_occupancy_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_data_idle_sw(  );
        begin
            int _temp_stats_read_data_idle_sw;
            _temp_stats_read_data_idle_sw = stats_read_data_idle_sw;
            wait( _temp_stats_read_data_idle_sw != stats_read_data_idle_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_data_occupancy_min(  );
        begin
            int _temp_stats_read_data_occupancy_min;
            _temp_stats_read_data_occupancy_min = stats_read_data_occupancy_min;
            wait( _temp_stats_read_data_occupancy_min != stats_read_data_occupancy_min );
        end
    endtask

    task automatic do_wait_for_stats_read_data_idle_min(  );
        begin
            int _temp_stats_read_data_idle_min;
            _temp_stats_read_data_idle_min = stats_read_data_idle_min;
            wait( _temp_stats_read_data_idle_min != stats_read_data_idle_min );
        end
    endtask

    task automatic do_wait_for_stats_read_data_occupancy_max(  );
        begin
            int _temp_stats_read_data_occupancy_max;
            _temp_stats_read_data_occupancy_max = stats_read_data_occupancy_max;
            wait( _temp_stats_read_data_occupancy_max != stats_read_data_occupancy_max );
        end
    endtask

    task automatic do_wait_for_stats_read_data_idle_max(  );
        begin
            int _temp_stats_read_data_idle_max;
            _temp_stats_read_data_idle_max = stats_read_data_idle_max;
            wait( _temp_stats_read_data_idle_max != stats_read_data_idle_max );
        end
    endtask

    task automatic do_wait_for_stats_read_data_occupancy_mean(  );
        begin
            int _temp_stats_read_data_occupancy_mean;
            _temp_stats_read_data_occupancy_mean = stats_read_data_occupancy_mean;
            wait( _temp_stats_read_data_occupancy_mean != stats_read_data_occupancy_mean );
        end
    endtask

    task automatic do_wait_for_stats_read_data_idle_mean(  );
        begin
            int _temp_stats_read_data_idle_mean;
            _temp_stats_read_data_idle_mean = stats_read_data_idle_mean;
            wait( _temp_stats_read_data_idle_mean != stats_read_data_idle_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_data_occupancy_step(  );
        begin
            int _temp_config_stats_write_data_occupancy_step;
            _temp_config_stats_write_data_occupancy_step = config_stats_write_data_occupancy_step;
            wait( _temp_config_stats_write_data_occupancy_step != config_stats_write_data_occupancy_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_data_occupancy_multiple(  );
        begin
            int _temp_config_stats_write_data_occupancy_multiple;
            _temp_config_stats_write_data_occupancy_multiple = config_stats_write_data_occupancy_multiple;
            wait( _temp_config_stats_write_data_occupancy_multiple != config_stats_write_data_occupancy_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_data_occupancy_sw(  );
        begin
            int _temp_stats_write_data_occupancy_sw;
            _temp_stats_write_data_occupancy_sw = stats_write_data_occupancy_sw;
            wait( _temp_stats_write_data_occupancy_sw != stats_write_data_occupancy_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_data_idle_sw(  );
        begin
            int _temp_stats_write_data_idle_sw;
            _temp_stats_write_data_idle_sw = stats_write_data_idle_sw;
            wait( _temp_stats_write_data_idle_sw != stats_write_data_idle_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_data_occupancy_min(  );
        begin
            int _temp_stats_write_data_occupancy_min;
            _temp_stats_write_data_occupancy_min = stats_write_data_occupancy_min;
            wait( _temp_stats_write_data_occupancy_min != stats_write_data_occupancy_min );
        end
    endtask

    task automatic do_wait_for_stats_write_data_idle_min(  );
        begin
            int _temp_stats_write_data_idle_min;
            _temp_stats_write_data_idle_min = stats_write_data_idle_min;
            wait( _temp_stats_write_data_idle_min != stats_write_data_idle_min );
        end
    endtask

    task automatic do_wait_for_stats_write_data_occupancy_max(  );
        begin
            int _temp_stats_write_data_occupancy_max;
            _temp_stats_write_data_occupancy_max = stats_write_data_occupancy_max;
            wait( _temp_stats_write_data_occupancy_max != stats_write_data_occupancy_max );
        end
    endtask

    task automatic do_wait_for_stats_write_data_idle_max(  );
        begin
            int _temp_stats_write_data_idle_max;
            _temp_stats_write_data_idle_max = stats_write_data_idle_max;
            wait( _temp_stats_write_data_idle_max != stats_write_data_idle_max );
        end
    endtask

    task automatic do_wait_for_stats_write_data_occupancy_mean(  );
        begin
            int _temp_stats_write_data_occupancy_mean;
            _temp_stats_write_data_occupancy_mean = stats_write_data_occupancy_mean;
            wait( _temp_stats_write_data_occupancy_mean != stats_write_data_occupancy_mean );
        end
    endtask

    task automatic do_wait_for_stats_write_data_idle_mean(  );
        begin
            int _temp_stats_write_data_idle_mean;
            _temp_stats_write_data_idle_mean = stats_write_data_idle_mean;
            wait( _temp_stats_write_data_idle_mean != stats_write_data_idle_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_read_bandwidth_step(  );
        begin
            int _temp_config_stats_read_bandwidth_step;
            _temp_config_stats_read_bandwidth_step = config_stats_read_bandwidth_step;
            wait( _temp_config_stats_read_bandwidth_step != config_stats_read_bandwidth_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_bandwidth_multiple(  );
        begin
            int _temp_config_stats_read_bandwidth_multiple;
            _temp_config_stats_read_bandwidth_multiple = config_stats_read_bandwidth_multiple;
            wait( _temp_config_stats_read_bandwidth_multiple != config_stats_read_bandwidth_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_bandwidth_sw(  );
        begin
            int _temp_stats_read_bandwidth_sw;
            _temp_stats_read_bandwidth_sw = stats_read_bandwidth_sw;
            wait( _temp_stats_read_bandwidth_sw != stats_read_bandwidth_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_bandwidth_min(  );
        begin
            int _temp_stats_read_bandwidth_min;
            _temp_stats_read_bandwidth_min = stats_read_bandwidth_min;
            wait( _temp_stats_read_bandwidth_min != stats_read_bandwidth_min );
        end
    endtask

    task automatic do_wait_for_stats_read_bandwidth_max(  );
        begin
            int _temp_stats_read_bandwidth_max;
            _temp_stats_read_bandwidth_max = stats_read_bandwidth_max;
            wait( _temp_stats_read_bandwidth_max != stats_read_bandwidth_max );
        end
    endtask

    task automatic do_wait_for_stats_read_bandwidth_mean(  );
        begin
            int _temp_stats_read_bandwidth_mean;
            _temp_stats_read_bandwidth_mean = stats_read_bandwidth_mean;
            wait( _temp_stats_read_bandwidth_mean != stats_read_bandwidth_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_bandwidth_step(  );
        begin
            int _temp_config_stats_write_bandwidth_step;
            _temp_config_stats_write_bandwidth_step = config_stats_write_bandwidth_step;
            wait( _temp_config_stats_write_bandwidth_step != config_stats_write_bandwidth_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_bandwidth_multiple(  );
        begin
            int _temp_config_stats_write_bandwidth_multiple;
            _temp_config_stats_write_bandwidth_multiple = config_stats_write_bandwidth_multiple;
            wait( _temp_config_stats_write_bandwidth_multiple != config_stats_write_bandwidth_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_bandwidth_sw(  );
        begin
            int _temp_stats_write_bandwidth_sw;
            _temp_stats_write_bandwidth_sw = stats_write_bandwidth_sw;
            wait( _temp_stats_write_bandwidth_sw != stats_write_bandwidth_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_bandwidth_min(  );
        begin
            int _temp_stats_write_bandwidth_min;
            _temp_stats_write_bandwidth_min = stats_write_bandwidth_min;
            wait( _temp_stats_write_bandwidth_min != stats_write_bandwidth_min );
        end
    endtask

    task automatic do_wait_for_stats_write_bandwidth_max(  );
        begin
            int _temp_stats_write_bandwidth_max;
            _temp_stats_write_bandwidth_max = stats_write_bandwidth_max;
            wait( _temp_stats_write_bandwidth_max != stats_write_bandwidth_max );
        end
    endtask

    task automatic do_wait_for_stats_write_bandwidth_mean(  );
        begin
            int _temp_stats_write_bandwidth_mean;
            _temp_stats_write_bandwidth_mean = stats_write_bandwidth_mean;
            wait( _temp_stats_write_bandwidth_mean != stats_write_bandwidth_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_read_latency_step(  );
        begin
            int _temp_config_stats_read_latency_step;
            _temp_config_stats_read_latency_step = config_stats_read_latency_step;
            wait( _temp_config_stats_read_latency_step != config_stats_read_latency_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_latency_multiple(  );
        begin
            int _temp_config_stats_read_latency_multiple;
            _temp_config_stats_read_latency_multiple = config_stats_read_latency_multiple;
            wait( _temp_config_stats_read_latency_multiple != config_stats_read_latency_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_address_data_latency_inst(  );
        begin
            int _temp_stats_read_address_data_latency_inst;
            _temp_stats_read_address_data_latency_inst = stats_read_address_data_latency_inst;
            wait( _temp_stats_read_address_data_latency_inst != stats_read_address_data_latency_inst );
        end
    endtask

    task automatic do_wait_for_stats_read_address_data_latency_sw(  );
        begin
            int _temp_stats_read_address_data_latency_sw;
            _temp_stats_read_address_data_latency_sw = stats_read_address_data_latency_sw;
            wait( _temp_stats_read_address_data_latency_sw != stats_read_address_data_latency_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_address_data_latency_min(  );
        begin
            int _temp_stats_read_address_data_latency_min;
            _temp_stats_read_address_data_latency_min = stats_read_address_data_latency_min;
            wait( _temp_stats_read_address_data_latency_min != stats_read_address_data_latency_min );
        end
    endtask

    task automatic do_wait_for_stats_read_address_data_latency_max(  );
        begin
            int _temp_stats_read_address_data_latency_max;
            _temp_stats_read_address_data_latency_max = stats_read_address_data_latency_max;
            wait( _temp_stats_read_address_data_latency_max != stats_read_address_data_latency_max );
        end
    endtask

    task automatic do_wait_for_stats_read_address_data_latency_mean(  );
        begin
            int _temp_stats_read_address_data_latency_mean;
            _temp_stats_read_address_data_latency_mean = stats_read_address_data_latency_mean;
            wait( _temp_stats_read_address_data_latency_mean != stats_read_address_data_latency_mean );
        end
    endtask

    task automatic do_wait_for_stats_read_address_address_latency_inst(  );
        begin
            int _temp_stats_read_address_address_latency_inst;
            _temp_stats_read_address_address_latency_inst = stats_read_address_address_latency_inst;
            wait( _temp_stats_read_address_address_latency_inst != stats_read_address_address_latency_inst );
        end
    endtask

    task automatic do_wait_for_stats_read_address_address_latency_sw(  );
        begin
            int _temp_stats_read_address_address_latency_sw;
            _temp_stats_read_address_address_latency_sw = stats_read_address_address_latency_sw;
            wait( _temp_stats_read_address_address_latency_sw != stats_read_address_address_latency_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_address_address_latency_min(  );
        begin
            int _temp_stats_read_address_address_latency_min;
            _temp_stats_read_address_address_latency_min = stats_read_address_address_latency_min;
            wait( _temp_stats_read_address_address_latency_min != stats_read_address_address_latency_min );
        end
    endtask

    task automatic do_wait_for_stats_read_address_address_latency_max(  );
        begin
            int _temp_stats_read_address_address_latency_max;
            _temp_stats_read_address_address_latency_max = stats_read_address_address_latency_max;
            wait( _temp_stats_read_address_address_latency_max != stats_read_address_address_latency_max );
        end
    endtask

    task automatic do_wait_for_stats_read_address_address_latency_mean(  );
        begin
            int _temp_stats_read_address_address_latency_mean;
            _temp_stats_read_address_address_latency_mean = stats_read_address_address_latency_mean;
            wait( _temp_stats_read_address_address_latency_mean != stats_read_address_address_latency_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_latency_step(  );
        begin
            int _temp_config_stats_write_latency_step;
            _temp_config_stats_write_latency_step = config_stats_write_latency_step;
            wait( _temp_config_stats_write_latency_step != config_stats_write_latency_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_latency_multiple(  );
        begin
            int _temp_config_stats_write_latency_multiple;
            _temp_config_stats_write_latency_multiple = config_stats_write_latency_multiple;
            wait( _temp_config_stats_write_latency_multiple != config_stats_write_latency_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_address_response_latency_inst(  );
        begin
            int _temp_stats_write_address_response_latency_inst;
            _temp_stats_write_address_response_latency_inst = stats_write_address_response_latency_inst;
            wait( _temp_stats_write_address_response_latency_inst != stats_write_address_response_latency_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_address_response_latency_sw(  );
        begin
            int _temp_stats_write_address_response_latency_sw;
            _temp_stats_write_address_response_latency_sw = stats_write_address_response_latency_sw;
            wait( _temp_stats_write_address_response_latency_sw != stats_write_address_response_latency_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_address_response_latency_min(  );
        begin
            int _temp_stats_write_address_response_latency_min;
            _temp_stats_write_address_response_latency_min = stats_write_address_response_latency_min;
            wait( _temp_stats_write_address_response_latency_min != stats_write_address_response_latency_min );
        end
    endtask

    task automatic do_wait_for_stats_write_address_response_latency_max(  );
        begin
            int _temp_stats_write_address_response_latency_max;
            _temp_stats_write_address_response_latency_max = stats_write_address_response_latency_max;
            wait( _temp_stats_write_address_response_latency_max != stats_write_address_response_latency_max );
        end
    endtask

    task automatic do_wait_for_stats_write_address_response_latency_mean(  );
        begin
            int _temp_stats_write_address_response_latency_mean;
            _temp_stats_write_address_response_latency_mean = stats_write_address_response_latency_mean;
            wait( _temp_stats_write_address_response_latency_mean != stats_write_address_response_latency_mean );
        end
    endtask

    task automatic do_wait_for_stats_write_address_address_latency_inst(  );
        begin
            int _temp_stats_write_address_address_latency_inst;
            _temp_stats_write_address_address_latency_inst = stats_write_address_address_latency_inst;
            wait( _temp_stats_write_address_address_latency_inst != stats_write_address_address_latency_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_address_address_latency_sw(  );
        begin
            int _temp_stats_write_address_address_latency_sw;
            _temp_stats_write_address_address_latency_sw = stats_write_address_address_latency_sw;
            wait( _temp_stats_write_address_address_latency_sw != stats_write_address_address_latency_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_address_address_latency_min(  );
        begin
            int _temp_stats_write_address_address_latency_min;
            _temp_stats_write_address_address_latency_min = stats_write_address_address_latency_min;
            wait( _temp_stats_write_address_address_latency_min != stats_write_address_address_latency_min );
        end
    endtask

    task automatic do_wait_for_stats_write_address_address_latency_max(  );
        begin
            int _temp_stats_write_address_address_latency_max;
            _temp_stats_write_address_address_latency_max = stats_write_address_address_latency_max;
            wait( _temp_stats_write_address_address_latency_max != stats_write_address_address_latency_max );
        end
    endtask

    task automatic do_wait_for_stats_write_address_address_latency_mean(  );
        begin
            int _temp_stats_write_address_address_latency_mean;
            _temp_stats_write_address_address_latency_mean = stats_write_address_address_latency_mean;
            wait( _temp_stats_write_address_address_latency_mean != stats_write_address_address_latency_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_read_address_waits_step(  );
        begin
            int _temp_config_stats_read_address_waits_step;
            _temp_config_stats_read_address_waits_step = config_stats_read_address_waits_step;
            wait( _temp_config_stats_read_address_waits_step != config_stats_read_address_waits_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_address_waits_multiple(  );
        begin
            int _temp_config_stats_read_address_waits_multiple;
            _temp_config_stats_read_address_waits_multiple = config_stats_read_address_waits_multiple;
            wait( _temp_config_stats_read_address_waits_multiple != config_stats_read_address_waits_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_inst(  );
        begin
            int _temp_stats_read_address_waits_inst;
            _temp_stats_read_address_waits_inst = stats_read_address_waits_inst;
            wait( _temp_stats_read_address_waits_inst != stats_read_address_waits_inst );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_sw(  );
        begin
            int _temp_stats_read_address_waits_sw;
            _temp_stats_read_address_waits_sw = stats_read_address_waits_sw;
            wait( _temp_stats_read_address_waits_sw != stats_read_address_waits_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_min(  );
        begin
            int _temp_stats_read_address_waits_min;
            _temp_stats_read_address_waits_min = stats_read_address_waits_min;
            wait( _temp_stats_read_address_waits_min != stats_read_address_waits_min );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_max(  );
        begin
            int _temp_stats_read_address_waits_max;
            _temp_stats_read_address_waits_max = stats_read_address_waits_max;
            wait( _temp_stats_read_address_waits_max != stats_read_address_waits_max );
        end
    endtask

    task automatic do_wait_for_stats_read_address_waits_mean(  );
        begin
            int _temp_stats_read_address_waits_mean;
            _temp_stats_read_address_waits_mean = stats_read_address_waits_mean;
            wait( _temp_stats_read_address_waits_mean != stats_read_address_waits_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_read_data_waits_step(  );
        begin
            int _temp_config_stats_read_data_waits_step;
            _temp_config_stats_read_data_waits_step = config_stats_read_data_waits_step;
            wait( _temp_config_stats_read_data_waits_step != config_stats_read_data_waits_step );
        end
    endtask

    task automatic do_wait_for_config_stats_read_data_waits_multiple(  );
        begin
            int _temp_config_stats_read_data_waits_multiple;
            _temp_config_stats_read_data_waits_multiple = config_stats_read_data_waits_multiple;
            wait( _temp_config_stats_read_data_waits_multiple != config_stats_read_data_waits_multiple );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_inst(  );
        begin
            int _temp_stats_read_data_waits_inst;
            _temp_stats_read_data_waits_inst = stats_read_data_waits_inst;
            wait( _temp_stats_read_data_waits_inst != stats_read_data_waits_inst );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_sw(  );
        begin
            int _temp_stats_read_data_waits_sw;
            _temp_stats_read_data_waits_sw = stats_read_data_waits_sw;
            wait( _temp_stats_read_data_waits_sw != stats_read_data_waits_sw );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_min(  );
        begin
            int _temp_stats_read_data_waits_min;
            _temp_stats_read_data_waits_min = stats_read_data_waits_min;
            wait( _temp_stats_read_data_waits_min != stats_read_data_waits_min );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_max(  );
        begin
            int _temp_stats_read_data_waits_max;
            _temp_stats_read_data_waits_max = stats_read_data_waits_max;
            wait( _temp_stats_read_data_waits_max != stats_read_data_waits_max );
        end
    endtask

    task automatic do_wait_for_stats_read_data_waits_mean(  );
        begin
            int _temp_stats_read_data_waits_mean;
            _temp_stats_read_data_waits_mean = stats_read_data_waits_mean;
            wait( _temp_stats_read_data_waits_mean != stats_read_data_waits_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_address_waits_step(  );
        begin
            int _temp_config_stats_write_address_waits_step;
            _temp_config_stats_write_address_waits_step = config_stats_write_address_waits_step;
            wait( _temp_config_stats_write_address_waits_step != config_stats_write_address_waits_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_address_waits_multiple(  );
        begin
            int _temp_config_stats_write_address_waits_multiple;
            _temp_config_stats_write_address_waits_multiple = config_stats_write_address_waits_multiple;
            wait( _temp_config_stats_write_address_waits_multiple != config_stats_write_address_waits_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_inst(  );
        begin
            int _temp_stats_write_address_waits_inst;
            _temp_stats_write_address_waits_inst = stats_write_address_waits_inst;
            wait( _temp_stats_write_address_waits_inst != stats_write_address_waits_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_sw(  );
        begin
            int _temp_stats_write_address_waits_sw;
            _temp_stats_write_address_waits_sw = stats_write_address_waits_sw;
            wait( _temp_stats_write_address_waits_sw != stats_write_address_waits_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_min(  );
        begin
            int _temp_stats_write_address_waits_min;
            _temp_stats_write_address_waits_min = stats_write_address_waits_min;
            wait( _temp_stats_write_address_waits_min != stats_write_address_waits_min );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_max(  );
        begin
            int _temp_stats_write_address_waits_max;
            _temp_stats_write_address_waits_max = stats_write_address_waits_max;
            wait( _temp_stats_write_address_waits_max != stats_write_address_waits_max );
        end
    endtask

    task automatic do_wait_for_stats_write_address_waits_mean(  );
        begin
            int _temp_stats_write_address_waits_mean;
            _temp_stats_write_address_waits_mean = stats_write_address_waits_mean;
            wait( _temp_stats_write_address_waits_mean != stats_write_address_waits_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_data_waits_step(  );
        begin
            int _temp_config_stats_write_data_waits_step;
            _temp_config_stats_write_data_waits_step = config_stats_write_data_waits_step;
            wait( _temp_config_stats_write_data_waits_step != config_stats_write_data_waits_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_data_waits_multiple(  );
        begin
            int _temp_config_stats_write_data_waits_multiple;
            _temp_config_stats_write_data_waits_multiple = config_stats_write_data_waits_multiple;
            wait( _temp_config_stats_write_data_waits_multiple != config_stats_write_data_waits_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_inst(  );
        begin
            int _temp_stats_write_data_waits_inst;
            _temp_stats_write_data_waits_inst = stats_write_data_waits_inst;
            wait( _temp_stats_write_data_waits_inst != stats_write_data_waits_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_sw(  );
        begin
            int _temp_stats_write_data_waits_sw;
            _temp_stats_write_data_waits_sw = stats_write_data_waits_sw;
            wait( _temp_stats_write_data_waits_sw != stats_write_data_waits_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_min(  );
        begin
            int _temp_stats_write_data_waits_min;
            _temp_stats_write_data_waits_min = stats_write_data_waits_min;
            wait( _temp_stats_write_data_waits_min != stats_write_data_waits_min );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_max(  );
        begin
            int _temp_stats_write_data_waits_max;
            _temp_stats_write_data_waits_max = stats_write_data_waits_max;
            wait( _temp_stats_write_data_waits_max != stats_write_data_waits_max );
        end
    endtask

    task automatic do_wait_for_stats_write_data_waits_mean(  );
        begin
            int _temp_stats_write_data_waits_mean;
            _temp_stats_write_data_waits_mean = stats_write_data_waits_mean;
            wait( _temp_stats_write_data_waits_mean != stats_write_data_waits_mean );
        end
    endtask

    task automatic do_wait_for_config_stats_write_response_waits_step(  );
        begin
            int _temp_config_stats_write_response_waits_step;
            _temp_config_stats_write_response_waits_step = config_stats_write_response_waits_step;
            wait( _temp_config_stats_write_response_waits_step != config_stats_write_response_waits_step );
        end
    endtask

    task automatic do_wait_for_config_stats_write_response_waits_multiple(  );
        begin
            int _temp_config_stats_write_response_waits_multiple;
            _temp_config_stats_write_response_waits_multiple = config_stats_write_response_waits_multiple;
            wait( _temp_config_stats_write_response_waits_multiple != config_stats_write_response_waits_multiple );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_inst(  );
        begin
            int _temp_stats_write_response_waits_inst;
            _temp_stats_write_response_waits_inst = stats_write_response_waits_inst;
            wait( _temp_stats_write_response_waits_inst != stats_write_response_waits_inst );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_sw(  );
        begin
            int _temp_stats_write_response_waits_sw;
            _temp_stats_write_response_waits_sw = stats_write_response_waits_sw;
            wait( _temp_stats_write_response_waits_sw != stats_write_response_waits_sw );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_min(  );
        begin
            int _temp_stats_write_response_waits_min;
            _temp_stats_write_response_waits_min = stats_write_response_waits_min;
            wait( _temp_stats_write_response_waits_min != stats_write_response_waits_min );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_max(  );
        begin
            int _temp_stats_write_response_waits_max;
            _temp_stats_write_response_waits_max = stats_write_response_waits_max;
            wait( _temp_stats_write_response_waits_max != stats_write_response_waits_max );
        end
    endtask

    task automatic do_wait_for_stats_write_response_waits_mean(  );
        begin
            int _temp_stats_write_response_waits_mean;
            _temp_stats_write_response_waits_mean = stats_write_response_waits_mean;
            wait( _temp_stats_write_response_waits_mean != stats_write_response_waits_mean );
        end
    endtask

    task automatic do_wait_for_reordering_depth_of_last_read_transaction(  );
        begin
            int _temp_reordering_depth_of_last_read_transaction;
            _temp_reordering_depth_of_last_read_transaction = reordering_depth_of_last_read_transaction;
            wait( _temp_reordering_depth_of_last_read_transaction != reordering_depth_of_last_read_transaction );
        end
    endtask


    //------------------------------------------------------------------------------
    // Functions to set global variables with write access
    //------------------------------------------------------------------------------

    function automatic void do_set_config_interface_type( axi4_interface_type_e config_interface_type_param );
        config_interface_type = config_interface_type_param;
    endfunction

    function automatic void do_set_config_clk_init_value( bit config_clk_init_value_param );
        config_clk_init_value = config_clk_init_value_param;
    endfunction

    function automatic void do_set_config_clk_phase_shift( longint unsigned config_clk_phase_shift_param );
        config_clk_phase_shift = config_clk_phase_shift_param;
    endfunction

    function automatic void do_set_config_clk_1st_time( longint unsigned config_clk_1st_time_param );
        config_clk_1st_time = config_clk_1st_time_param;
    endfunction

    function automatic void do_set_config_clk_2nd_time( longint unsigned config_clk_2nd_time_param );
        config_clk_2nd_time = config_clk_2nd_time_param;
    endfunction

    function automatic void do_set_config_setup_time( longint unsigned config_setup_time_param );
        config_setup_time = config_setup_time_param;
    endfunction

    function automatic void do_set_config_hold_time( longint unsigned config_hold_time_param );
        config_hold_time = config_hold_time_param;
    endfunction

    function automatic void do_set_config_burst_timeout_factor( int unsigned config_burst_timeout_factor_param );
        config_burst_timeout_factor = config_burst_timeout_factor_param;
    endfunction

    function automatic void do_set_config_max_transaction_time_factor( int unsigned config_max_transaction_time_factor_param );
        config_max_transaction_time_factor = config_max_transaction_time_factor_param;
    endfunction

    function automatic void do_set_config_write_ctrl_first_ratio( int config_write_ctrl_first_ratio_param );
        config_write_ctrl_first_ratio = config_write_ctrl_first_ratio_param;
    endfunction

    function automatic void do_set_config_write_data_first_ratio( int config_write_data_first_ratio_param );
        config_write_data_first_ratio = config_write_data_first_ratio_param;
    endfunction

    function automatic void do_set_config_reset_low_clocks( int config_reset_low_clocks_param );
        config_reset_low_clocks = config_reset_low_clocks_param;
    endfunction

    function automatic void do_set_config_reset_hold_time( int config_reset_hold_time_param );
        config_reset_hold_time = config_reset_hold_time_param;
    endfunction

    function automatic void do_set_config_enable_rlast( bit config_enable_rlast_param );
        config_enable_rlast = config_enable_rlast_param;
    endfunction

    function automatic void do_set_config_enable_slave_exclusive( bit config_enable_slave_exclusive_param );
        config_enable_slave_exclusive = config_enable_slave_exclusive_param;
    endfunction

    function automatic void do_set_config_enable_burst_reserved_value( bit config_enable_burst_reserved_value_param );
        config_enable_burst_reserved_value = config_enable_burst_reserved_value_param;
    endfunction

    function automatic void do_set_config_enable_cache_value( bit [15:0] config_enable_cache_value_param );
        config_enable_cache_value = config_enable_cache_value_param;
    endfunction

    function automatic void do_set_config_enable_cache_value_index1( int _this_dot_1, bit  config_enable_cache_value_param );
        config_enable_cache_value[_this_dot_1] = config_enable_cache_value_param;
    endfunction

    function automatic void do_set_internal_dummy_variable( axi4_error_e internal_dummy_variable_param );
        internal_dummy_variable = internal_dummy_variable_param;
    endfunction

    function automatic void do_set_config_axi4lite_interface( bit config_axi4lite_interface_param );
        config_axi4lite_interface = config_axi4lite_interface_param;
    endfunction

    function automatic void do_set_config_axi4lite_tr_id( bit [((AXI4_ID_WIDTH) - 1):0]  config_axi4lite_tr_id_param );
        config_axi4lite_tr_id = config_axi4lite_tr_id_param;
    endfunction

    function automatic void do_set_config_axi4lite_tr_id_index1( int _this_dot_1, bit  config_axi4lite_tr_id_param );
        config_axi4lite_tr_id[_this_dot_1] = config_axi4lite_tr_id_param;
    endfunction

    function automatic void do_set_config_enable_all_assertions( bit config_enable_all_assertions_param );
        config_enable_all_assertions = config_enable_all_assertions_param;
    endfunction

    function automatic void do_set_config_enable_assertion( bit [255:0] config_enable_assertion_param );
        config_enable_assertion = config_enable_assertion_param;
    endfunction

    function automatic void do_set_config_enable_assertion_index1( int _this_dot_1, bit  config_enable_assertion_param );
        config_enable_assertion[_this_dot_1] = config_enable_assertion_param;
    endfunction

    function automatic void do_set_config_enable_error( bit [255:0] config_enable_error_param );
        config_enable_error = config_enable_error_param;
    endfunction

    function automatic void do_set_config_enable_error_index1( int _this_dot_1, bit  config_enable_error_param );
        config_enable_error[_this_dot_1] = config_enable_error_param;
    endfunction

    function automatic void do_set_config_max_latency_AWVALID_assertion_to_AWREADY( int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
        config_max_latency_AWVALID_assertion_to_AWREADY = config_max_latency_AWVALID_assertion_to_AWREADY_param;
    endfunction

    function automatic void do_set_config_max_latency_ARVALID_assertion_to_ARREADY( int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
        config_max_latency_ARVALID_assertion_to_ARREADY = config_max_latency_ARVALID_assertion_to_ARREADY_param;
    endfunction

    function automatic void do_set_config_max_latency_RVALID_assertion_to_RREADY( int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
        config_max_latency_RVALID_assertion_to_RREADY = config_max_latency_RVALID_assertion_to_RREADY_param;
    endfunction

    function automatic void do_set_config_max_latency_BVALID_assertion_to_BREADY( int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
        config_max_latency_BVALID_assertion_to_BREADY = config_max_latency_BVALID_assertion_to_BREADY_param;
    endfunction

    function automatic void do_set_config_max_latency_WVALID_assertion_to_WREADY( int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
        config_max_latency_WVALID_assertion_to_WREADY = config_max_latency_WVALID_assertion_to_WREADY_param;
    endfunction

    function automatic void do_set_config_enable_qos( bit config_enable_qos_param );
        config_enable_qos = config_enable_qos_param;
    endfunction

    function automatic void do_set_config_enable_region_support( bit config_enable_region_support_param );
        config_enable_region_support = config_enable_region_support_param;
    endfunction

    function automatic void do_set_config_slave_regions( int config_slave_regions_param );
        config_slave_regions = config_slave_regions_param;
    endfunction

    function automatic void do_set_config_region( bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  config_region_param );
        config_region = config_region_param;
    endfunction

    function automatic void do_set_config_region_index1( int _this_dot_1, bit [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  config_region_param );
        config_region[_this_dot_1] = config_region_param;
    endfunction

    function automatic void do_set_config_region_index2( int _this_dot_1, int _this_dot_2, bit  config_region_param );
        config_region[_this_dot_1][_this_dot_2] = config_region_param;
    endfunction

    function automatic void do_set_config_read_data_reordering_depth( int unsigned config_read_data_reordering_depth_param );
        config_read_data_reordering_depth = config_read_data_reordering_depth_param;
    endfunction

    function automatic void do_set_config_slave_start_addr( bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param );
        config_slave_start_addr = config_slave_start_addr_param;
    endfunction

    function automatic void do_set_config_slave_start_addr_index1( int _this_dot_1, bit  config_slave_start_addr_param );
        config_slave_start_addr[_this_dot_1] = config_slave_start_addr_param;
    endfunction

    function automatic void do_set_config_slave_end_addr( bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param );
        config_slave_end_addr = config_slave_end_addr_param;
    endfunction

    function automatic void do_set_config_slave_end_addr_index1( int _this_dot_1, bit  config_slave_end_addr_param );
        config_slave_end_addr[_this_dot_1] = config_slave_end_addr_param;
    endfunction

    function automatic void do_set_config_slave_enabled_non_contiguous_address_spaces( int config_slave_enabled_non_contiguous_address_spaces_param );
        config_slave_enabled_non_contiguous_address_spaces = config_slave_enabled_non_contiguous_address_spaces_param;
    endfunction

    function automatic void do_set_config_slave_possess_multiple_non_contiguous_address_spaces( bit config_slave_possess_multiple_non_contiguous_address_spaces_param );
        config_slave_possess_multiple_non_contiguous_address_spaces = config_slave_possess_multiple_non_contiguous_address_spaces_param;
    endfunction

    function automatic void do_set_config_slave_multiple_non_contiguous_start_address_range( bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_start_address_range_param );
        config_slave_multiple_non_contiguous_start_address_range = config_slave_multiple_non_contiguous_start_address_range_param;
    endfunction

    function automatic void do_set_config_slave_multiple_non_contiguous_start_address_range_index1( int _this_dot_1, bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_start_address_range_param );
        config_slave_multiple_non_contiguous_start_address_range[_this_dot_1] = config_slave_multiple_non_contiguous_start_address_range_param;
    endfunction

    function automatic void do_set_config_slave_multiple_non_contiguous_start_address_range_index2( int _this_dot_1, int _this_dot_2, bit  config_slave_multiple_non_contiguous_start_address_range_param );
        config_slave_multiple_non_contiguous_start_address_range[_this_dot_1][_this_dot_2] = config_slave_multiple_non_contiguous_start_address_range_param;
    endfunction

    function automatic void do_set_config_slave_multiple_non_contiguous_end_address_range( bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_end_address_range_param );
        config_slave_multiple_non_contiguous_end_address_range = config_slave_multiple_non_contiguous_end_address_range_param;
    endfunction

    function automatic void do_set_config_slave_multiple_non_contiguous_end_address_range_index1( int _this_dot_1, bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_end_address_range_param );
        config_slave_multiple_non_contiguous_end_address_range[_this_dot_1] = config_slave_multiple_non_contiguous_end_address_range_param;
    endfunction

    function automatic void do_set_config_slave_multiple_non_contiguous_end_address_range_index2( int _this_dot_1, int _this_dot_2, bit  config_slave_multiple_non_contiguous_end_address_range_param );
        config_slave_multiple_non_contiguous_end_address_range[_this_dot_1][_this_dot_2] = config_slave_multiple_non_contiguous_end_address_range_param;
    endfunction

    function automatic void do_set_config_protect_ready( bit config_protect_ready_param );
        config_protect_ready = config_protect_ready_param;
    endfunction

    function automatic void do_set_config_max_outstanding_wr( int config_max_outstanding_wr_param );
        config_max_outstanding_wr = config_max_outstanding_wr_param;
    endfunction

    function automatic void do_set_config_max_outstanding_rd( int config_max_outstanding_rd_param );
        config_max_outstanding_rd = config_max_outstanding_rd_param;
    endfunction

    function automatic void do_set_config_num_outstanding_wr_phase( int config_num_outstanding_wr_phase_param );
        config_num_outstanding_wr_phase = config_num_outstanding_wr_phase_param;
    endfunction

    function automatic void do_set_config_num_outstanding_rd_phase( int config_num_outstanding_rd_phase_param );
        config_num_outstanding_rd_phase = config_num_outstanding_rd_phase_param;
    endfunction

    function automatic void do_set_config_enable_warnings( bit config_enable_warnings_param );
        config_enable_warnings = config_enable_warnings_param;
    endfunction

    function automatic void do_set_config_enable_errors( bit config_enable_errors_param );
        config_enable_errors = config_enable_errors_param;
    endfunction

    function automatic void do_set_config_enable_exclusive_checks( bit config_enable_exclusive_checks_param );
        config_enable_exclusive_checks = config_enable_exclusive_checks_param;
    endfunction

    function automatic void do_set_config_warn_on_slave_errors( bit config_warn_on_slave_errors_param );
        config_warn_on_slave_errors = config_warn_on_slave_errors_param;
    endfunction

    function automatic void do_set_config_error_on_deleted_valid_cycles( bit config_error_on_deleted_valid_cycles_param );
        config_error_on_deleted_valid_cycles = config_error_on_deleted_valid_cycles_param;
    endfunction

    function automatic void do_set_config_stats_enable( bit config_stats_enable_param );
        config_stats_enable = config_stats_enable_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_occupancy( bit config_stats_enable_read_occupancy_param );
        config_stats_enable_read_occupancy = config_stats_enable_read_occupancy_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_occupancy( bit config_stats_enable_write_occupancy_param );
        config_stats_enable_write_occupancy = config_stats_enable_write_occupancy_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_data_occupancy( bit config_stats_enable_read_data_occupancy_param );
        config_stats_enable_read_data_occupancy = config_stats_enable_read_data_occupancy_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_data_occupancy( bit config_stats_enable_write_data_occupancy_param );
        config_stats_enable_write_data_occupancy = config_stats_enable_write_data_occupancy_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_latency( bit config_stats_enable_read_latency_param );
        config_stats_enable_read_latency = config_stats_enable_read_latency_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_latency( bit config_stats_enable_write_latency_param );
        config_stats_enable_write_latency = config_stats_enable_write_latency_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_address_waits( bit config_stats_enable_read_address_waits_param );
        config_stats_enable_read_address_waits = config_stats_enable_read_address_waits_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_data_waits( bit config_stats_enable_read_data_waits_param );
        config_stats_enable_read_data_waits = config_stats_enable_read_data_waits_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_address_waits( bit config_stats_enable_write_address_waits_param );
        config_stats_enable_write_address_waits = config_stats_enable_write_address_waits_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_data_waits( bit config_stats_enable_write_data_waits_param );
        config_stats_enable_write_data_waits = config_stats_enable_write_data_waits_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_response_waits( bit config_stats_enable_write_response_waits_param );
        config_stats_enable_write_response_waits = config_stats_enable_write_response_waits_param;
    endfunction

    function automatic void do_set_config_stats_enable_read_bandwidth( bit config_stats_enable_read_bandwidth_param );
        config_stats_enable_read_bandwidth = config_stats_enable_read_bandwidth_param;
    endfunction

    function automatic void do_set_config_stats_enable_write_bandwidth( bit config_stats_enable_write_bandwidth_param );
        config_stats_enable_write_bandwidth = config_stats_enable_write_bandwidth_param;
    endfunction

    function automatic void do_set_config_stats_read_occupancy_step( int config_stats_read_occupancy_step_param );
        config_stats_read_occupancy_step = config_stats_read_occupancy_step_param;
    endfunction

    function automatic void do_set_config_stats_read_occupancy_multiple( int config_stats_read_occupancy_multiple_param );
        config_stats_read_occupancy_multiple = config_stats_read_occupancy_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_occupancy_step( int config_stats_write_occupancy_step_param );
        config_stats_write_occupancy_step = config_stats_write_occupancy_step_param;
    endfunction

    function automatic void do_set_config_stats_write_occupancy_multiple( int config_stats_write_occupancy_multiple_param );
        config_stats_write_occupancy_multiple = config_stats_write_occupancy_multiple_param;
    endfunction

    function automatic void do_set_config_stats_read_data_occupancy_step( int config_stats_read_data_occupancy_step_param );
        config_stats_read_data_occupancy_step = config_stats_read_data_occupancy_step_param;
    endfunction

    function automatic void do_set_config_stats_read_data_occupancy_multiple( int config_stats_read_data_occupancy_multiple_param );
        config_stats_read_data_occupancy_multiple = config_stats_read_data_occupancy_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_data_occupancy_step( int config_stats_write_data_occupancy_step_param );
        config_stats_write_data_occupancy_step = config_stats_write_data_occupancy_step_param;
    endfunction

    function automatic void do_set_config_stats_write_data_occupancy_multiple( int config_stats_write_data_occupancy_multiple_param );
        config_stats_write_data_occupancy_multiple = config_stats_write_data_occupancy_multiple_param;
    endfunction

    function automatic void do_set_config_stats_read_bandwidth_step( int config_stats_read_bandwidth_step_param );
        config_stats_read_bandwidth_step = config_stats_read_bandwidth_step_param;
    endfunction

    function automatic void do_set_config_stats_read_bandwidth_multiple( int config_stats_read_bandwidth_multiple_param );
        config_stats_read_bandwidth_multiple = config_stats_read_bandwidth_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_bandwidth_step( int config_stats_write_bandwidth_step_param );
        config_stats_write_bandwidth_step = config_stats_write_bandwidth_step_param;
    endfunction

    function automatic void do_set_config_stats_write_bandwidth_multiple( int config_stats_write_bandwidth_multiple_param );
        config_stats_write_bandwidth_multiple = config_stats_write_bandwidth_multiple_param;
    endfunction

    function automatic void do_set_config_stats_read_latency_step( int config_stats_read_latency_step_param );
        config_stats_read_latency_step = config_stats_read_latency_step_param;
    endfunction

    function automatic void do_set_config_stats_read_latency_multiple( int config_stats_read_latency_multiple_param );
        config_stats_read_latency_multiple = config_stats_read_latency_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_latency_step( int config_stats_write_latency_step_param );
        config_stats_write_latency_step = config_stats_write_latency_step_param;
    endfunction

    function automatic void do_set_config_stats_write_latency_multiple( int config_stats_write_latency_multiple_param );
        config_stats_write_latency_multiple = config_stats_write_latency_multiple_param;
    endfunction

    function automatic void do_set_config_stats_read_address_waits_step( int config_stats_read_address_waits_step_param );
        config_stats_read_address_waits_step = config_stats_read_address_waits_step_param;
    endfunction

    function automatic void do_set_config_stats_read_address_waits_multiple( int config_stats_read_address_waits_multiple_param );
        config_stats_read_address_waits_multiple = config_stats_read_address_waits_multiple_param;
    endfunction

    function automatic void do_set_config_stats_read_data_waits_step( int config_stats_read_data_waits_step_param );
        config_stats_read_data_waits_step = config_stats_read_data_waits_step_param;
    endfunction

    function automatic void do_set_config_stats_read_data_waits_multiple( int config_stats_read_data_waits_multiple_param );
        config_stats_read_data_waits_multiple = config_stats_read_data_waits_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_address_waits_step( int config_stats_write_address_waits_step_param );
        config_stats_write_address_waits_step = config_stats_write_address_waits_step_param;
    endfunction

    function automatic void do_set_config_stats_write_address_waits_multiple( int config_stats_write_address_waits_multiple_param );
        config_stats_write_address_waits_multiple = config_stats_write_address_waits_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_data_waits_step( int config_stats_write_data_waits_step_param );
        config_stats_write_data_waits_step = config_stats_write_data_waits_step_param;
    endfunction

    function automatic void do_set_config_stats_write_data_waits_multiple( int config_stats_write_data_waits_multiple_param );
        config_stats_write_data_waits_multiple = config_stats_write_data_waits_multiple_param;
    endfunction

    function automatic void do_set_config_stats_write_response_waits_step( int config_stats_write_response_waits_step_param );
        config_stats_write_response_waits_step = config_stats_write_response_waits_step_param;
    endfunction

    function automatic void do_set_config_stats_write_response_waits_multiple( int config_stats_write_response_waits_multiple_param );
        config_stats_write_response_waits_multiple = config_stats_write_response_waits_multiple_param;
    endfunction


    //------------------------------------------------------------------------------
    // Functions to get global variables with read access
    //------------------------------------------------------------------------------

    function automatic axi4_interface_type_e do_get_config_interface_type(  );
        return config_interface_type;
    endfunction

    function automatic bit do_get_config_clk_init_value(  );
        return config_clk_init_value;
    endfunction

    function automatic longint unsigned do_get_config_clk_phase_shift(  );
        return config_clk_phase_shift;
    endfunction

    function automatic longint unsigned do_get_config_clk_1st_time(  );
        return config_clk_1st_time;
    endfunction

    function automatic longint unsigned do_get_config_clk_2nd_time(  );
        return config_clk_2nd_time;
    endfunction

    function automatic longint unsigned do_get_config_setup_time(  );
        return config_setup_time;
    endfunction

    function automatic longint unsigned do_get_config_hold_time(  );
        return config_hold_time;
    endfunction

    function automatic int unsigned do_get_config_burst_timeout_factor(  );
        return config_burst_timeout_factor;
    endfunction

    function automatic int unsigned do_get_config_max_transaction_time_factor(  );
        return config_max_transaction_time_factor;
    endfunction

    function automatic int do_get_config_write_ctrl_first_ratio(  );
        return config_write_ctrl_first_ratio;
    endfunction

    function automatic int do_get_config_write_data_first_ratio(  );
        return config_write_data_first_ratio;
    endfunction

    function automatic int do_get_config_reset_low_clocks(  );
        return config_reset_low_clocks;
    endfunction

    function automatic int do_get_config_reset_hold_time(  );
        return config_reset_hold_time;
    endfunction

    function automatic bit do_get_config_enable_rlast(  );
        return config_enable_rlast;
    endfunction

    function automatic bit do_get_config_enable_slave_exclusive(  );
        return config_enable_slave_exclusive;
    endfunction

    function automatic bit do_get_config_enable_burst_reserved_value(  );
        return config_enable_burst_reserved_value;
    endfunction

    function automatic bit [15:0]  do_get_config_enable_cache_value(  );
        return config_enable_cache_value;
    endfunction

    function automatic bit   do_get_config_enable_cache_value_index1( int _this_dot_1 );
        return config_enable_cache_value[_this_dot_1];
    endfunction

    function automatic axi4_error_e do_get_internal_dummy_variable(  );
        return internal_dummy_variable;
    endfunction

    function automatic bit do_get_config_axi4lite_interface(  );
        return config_axi4lite_interface;
    endfunction

    function automatic bit [((AXI4_ID_WIDTH) - 1):0]   do_get_config_axi4lite_tr_id(  );
        return config_axi4lite_tr_id;
    endfunction

    function automatic bit   do_get_config_axi4lite_tr_id_index1( int _this_dot_1 );
        return config_axi4lite_tr_id[_this_dot_1];
    endfunction

    function automatic bit do_get_config_enable_all_assertions(  );
        return config_enable_all_assertions;
    endfunction

    function automatic bit [255:0]  do_get_config_enable_assertion(  );
        return config_enable_assertion;
    endfunction

    function automatic bit   do_get_config_enable_assertion_index1( int _this_dot_1 );
        return config_enable_assertion[_this_dot_1];
    endfunction

    function automatic bit [255:0]  do_get_config_enable_error(  );
        return config_enable_error;
    endfunction

    function automatic bit   do_get_config_enable_error_index1( int _this_dot_1 );
        return config_enable_error[_this_dot_1];
    endfunction

    function automatic int unsigned do_get_config_max_latency_AWVALID_assertion_to_AWREADY(  );
        return config_max_latency_AWVALID_assertion_to_AWREADY;
    endfunction

    function automatic int unsigned do_get_config_max_latency_ARVALID_assertion_to_ARREADY(  );
        return config_max_latency_ARVALID_assertion_to_ARREADY;
    endfunction

    function automatic int unsigned do_get_config_max_latency_RVALID_assertion_to_RREADY(  );
        return config_max_latency_RVALID_assertion_to_RREADY;
    endfunction

    function automatic int unsigned do_get_config_max_latency_BVALID_assertion_to_BREADY(  );
        return config_max_latency_BVALID_assertion_to_BREADY;
    endfunction

    function automatic int unsigned do_get_config_max_latency_WVALID_assertion_to_WREADY(  );
        return config_max_latency_WVALID_assertion_to_WREADY;
    endfunction

    function automatic bit do_get_config_enable_qos(  );
        return config_enable_qos;
    endfunction

    function automatic bit do_get_config_enable_region_support(  );
        return config_enable_region_support;
    endfunction

    function automatic int do_get_config_slave_regions(  );
        return config_slave_regions;
    endfunction

    function automatic bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]   do_get_config_region(  );
        return config_region;
    endfunction

    function automatic bit [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]   do_get_config_region_index1( int _this_dot_1 );
        return config_region[_this_dot_1];
    endfunction

    function automatic bit   do_get_config_region_index2( int _this_dot_1, int _this_dot_2 );
        return config_region[_this_dot_1][_this_dot_2];
    endfunction

    function automatic bit do_get_region_error_state(  );
        return region_error_state;
    endfunction

    typedef longint unsigned _region_map_lb_t [((AXI4_REGION_MAP_SIZE) - 1):0];
    function automatic _region_map_lb_t do_get_region_map_lb(  );
        return region_map_lb;
    endfunction

    function automatic longint unsigned do_get_region_map_lb_index1( int _this_dot_1 );
        return region_map_lb[_this_dot_1];
    endfunction

    typedef longint unsigned _region_map_ub_t [((AXI4_REGION_MAP_SIZE) - 1):0];
    function automatic _region_map_ub_t do_get_region_map_ub(  );
        return region_map_ub;
    endfunction

    function automatic longint unsigned do_get_region_map_ub_index1( int _this_dot_1 );
        return region_map_ub[_this_dot_1];
    endfunction

    typedef byte unsigned _region_map_region_t [((AXI4_REGION_MAP_SIZE) - 1):0];
    function automatic _region_map_region_t do_get_region_map_region(  );
        return region_map_region;
    endfunction

    function automatic byte unsigned do_get_region_map_region_index1( int _this_dot_1 );
        return region_map_region[_this_dot_1];
    endfunction

    typedef byte unsigned _cacheable_t [((AXI4_REGION_MAP_SIZE) - 1):0];
    function automatic _cacheable_t do_get_cacheable(  );
        return cacheable;
    endfunction

    function automatic byte unsigned do_get_cacheable_index1( int _this_dot_1 );
        return cacheable[_this_dot_1];
    endfunction

    function automatic int unsigned do_get_config_read_data_reordering_depth(  );
        return config_read_data_reordering_depth;
    endfunction

    function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   do_get_config_slave_start_addr(  );
        return config_slave_start_addr;
    endfunction

    function automatic bit   do_get_config_slave_start_addr_index1( int _this_dot_1 );
        return config_slave_start_addr[_this_dot_1];
    endfunction

    function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   do_get_config_slave_end_addr(  );
        return config_slave_end_addr;
    endfunction

    function automatic bit   do_get_config_slave_end_addr_index1( int _this_dot_1 );
        return config_slave_end_addr[_this_dot_1];
    endfunction

    function automatic int do_get_config_slave_enabled_non_contiguous_address_spaces(  );
        return config_slave_enabled_non_contiguous_address_spaces;
    endfunction

    function automatic bit do_get_config_slave_possess_multiple_non_contiguous_address_spaces(  );
        return config_slave_possess_multiple_non_contiguous_address_spaces;
    endfunction

    function automatic bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]   do_get_config_slave_multiple_non_contiguous_start_address_range(  );
        return config_slave_multiple_non_contiguous_start_address_range;
    endfunction

    function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   do_get_config_slave_multiple_non_contiguous_start_address_range_index1( int _this_dot_1 );
        return config_slave_multiple_non_contiguous_start_address_range[_this_dot_1];
    endfunction

    function automatic bit   do_get_config_slave_multiple_non_contiguous_start_address_range_index2( int _this_dot_1, int _this_dot_2 );
        return config_slave_multiple_non_contiguous_start_address_range[_this_dot_1][_this_dot_2];
    endfunction

    function automatic bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]   do_get_config_slave_multiple_non_contiguous_end_address_range(  );
        return config_slave_multiple_non_contiguous_end_address_range;
    endfunction

    function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   do_get_config_slave_multiple_non_contiguous_end_address_range_index1( int _this_dot_1 );
        return config_slave_multiple_non_contiguous_end_address_range[_this_dot_1];
    endfunction

    function automatic bit   do_get_config_slave_multiple_non_contiguous_end_address_range_index2( int _this_dot_1, int _this_dot_2 );
        return config_slave_multiple_non_contiguous_end_address_range[_this_dot_1][_this_dot_2];
    endfunction

    function automatic bit do_get_config_protect_ready(  );
        return config_protect_ready;
    endfunction

    function automatic bit do_get_master_end_tlm_status(  );
        return master_end_tlm_status;
    endfunction

    function automatic bit do_get_master_end_wlm_status(  );
        return master_end_wlm_status;
    endfunction

    function automatic bit do_get_slave_end_tlm_status(  );
        return slave_end_tlm_status;
    endfunction

    function automatic bit do_get_slave_end_wlm_status(  );
        return slave_end_wlm_status;
    endfunction

    function automatic bit do_get_clock_source_end_tlm_status(  );
        return clock_source_end_tlm_status;
    endfunction

    function automatic bit do_get_clock_source_end_wlm_status(  );
        return clock_source_end_wlm_status;
    endfunction

    function automatic bit do_get_reset_source_end_tlm_status(  );
        return reset_source_end_tlm_status;
    endfunction

    function automatic bit do_get_reset_source_end_wlm_status(  );
        return reset_source_end_wlm_status;
    endfunction

    function automatic int do_get_config_max_outstanding_wr(  );
        return config_max_outstanding_wr;
    endfunction

    function automatic int do_get_config_max_outstanding_rd(  );
        return config_max_outstanding_rd;
    endfunction

    function automatic int do_get_config_num_outstanding_wr_phase(  );
        return config_num_outstanding_wr_phase;
    endfunction

    function automatic int do_get_config_num_outstanding_rd_phase(  );
        return config_num_outstanding_rd_phase;
    endfunction

    function automatic bit do_get_config_enable_warnings(  );
        return config_enable_warnings;
    endfunction

    function automatic bit do_get_config_enable_errors(  );
        return config_enable_errors;
    endfunction

    function automatic bit do_get_config_enable_exclusive_checks(  );
        return config_enable_exclusive_checks;
    endfunction

    function automatic bit do_get_config_warn_on_slave_errors(  );
        return config_warn_on_slave_errors;
    endfunction

    function automatic bit do_get_config_error_on_deleted_valid_cycles(  );
        return config_error_on_deleted_valid_cycles;
    endfunction

    function automatic bit do_get_config_stats_enable(  );
        return config_stats_enable;
    endfunction

    function automatic bit do_get_config_stats_enable_read_occupancy(  );
        return config_stats_enable_read_occupancy;
    endfunction

    function automatic bit do_get_config_stats_enable_write_occupancy(  );
        return config_stats_enable_write_occupancy;
    endfunction

    function automatic bit do_get_config_stats_enable_read_data_occupancy(  );
        return config_stats_enable_read_data_occupancy;
    endfunction

    function automatic bit do_get_config_stats_enable_write_data_occupancy(  );
        return config_stats_enable_write_data_occupancy;
    endfunction

    function automatic bit do_get_config_stats_enable_read_latency(  );
        return config_stats_enable_read_latency;
    endfunction

    function automatic bit do_get_config_stats_enable_write_latency(  );
        return config_stats_enable_write_latency;
    endfunction

    function automatic bit do_get_config_stats_enable_read_address_waits(  );
        return config_stats_enable_read_address_waits;
    endfunction

    function automatic bit do_get_config_stats_enable_read_data_waits(  );
        return config_stats_enable_read_data_waits;
    endfunction

    function automatic bit do_get_config_stats_enable_write_address_waits(  );
        return config_stats_enable_write_address_waits;
    endfunction

    function automatic bit do_get_config_stats_enable_write_data_waits(  );
        return config_stats_enable_write_data_waits;
    endfunction

    function automatic bit do_get_config_stats_enable_write_response_waits(  );
        return config_stats_enable_write_response_waits;
    endfunction

    function automatic bit do_get_config_stats_enable_read_bandwidth(  );
        return config_stats_enable_read_bandwidth;
    endfunction

    function automatic bit do_get_config_stats_enable_write_bandwidth(  );
        return config_stats_enable_write_bandwidth;
    endfunction

    function automatic int do_get_stats_rw_transaction_last_duration(  );
        return stats_rw_transaction_last_duration;
    endfunction

    function automatic int do_get_config_stats_read_occupancy_step(  );
        return config_stats_read_occupancy_step;
    endfunction

    function automatic int do_get_config_stats_read_occupancy_multiple(  );
        return config_stats_read_occupancy_multiple;
    endfunction

    function automatic bit do_get_stats_read_active(  );
        return stats_read_active;
    endfunction

    function automatic int do_get_stats_read_occupancy_sw(  );
        return stats_read_occupancy_sw;
    endfunction

    function automatic int do_get_stats_read_idle_sw(  );
        return stats_read_idle_sw;
    endfunction

    function automatic int do_get_stats_read_occupancy_min(  );
        return stats_read_occupancy_min;
    endfunction

    function automatic int do_get_stats_read_idle_min(  );
        return stats_read_idle_min;
    endfunction

    function automatic int do_get_stats_read_occupancy_max(  );
        return stats_read_occupancy_max;
    endfunction

    function automatic int do_get_stats_read_idle_max(  );
        return stats_read_idle_max;
    endfunction

    function automatic int do_get_stats_read_occupancy_mean(  );
        return stats_read_occupancy_mean;
    endfunction

    function automatic int do_get_stats_read_idle_mean(  );
        return stats_read_idle_mean;
    endfunction

    function automatic int do_get_stats_read_last_duration(  );
        return stats_read_last_duration;
    endfunction

    function automatic int do_get_config_stats_write_occupancy_step(  );
        return config_stats_write_occupancy_step;
    endfunction

    function automatic int do_get_config_stats_write_occupancy_multiple(  );
        return config_stats_write_occupancy_multiple;
    endfunction

    function automatic bit do_get_stats_write_active(  );
        return stats_write_active;
    endfunction

    function automatic int do_get_stats_write_occupancy_sw(  );
        return stats_write_occupancy_sw;
    endfunction

    function automatic int do_get_stats_write_idle_sw(  );
        return stats_write_idle_sw;
    endfunction

    function automatic int do_get_stats_write_occupancy_min(  );
        return stats_write_occupancy_min;
    endfunction

    function automatic int do_get_stats_write_idle_min(  );
        return stats_write_idle_min;
    endfunction

    function automatic int do_get_stats_write_occupancy_max(  );
        return stats_write_occupancy_max;
    endfunction

    function automatic int do_get_stats_write_idle_max(  );
        return stats_write_idle_max;
    endfunction

    function automatic int do_get_stats_write_occupancy_mean(  );
        return stats_write_occupancy_mean;
    endfunction

    function automatic int do_get_stats_write_idle_mean(  );
        return stats_write_idle_mean;
    endfunction

    function automatic int do_get_stats_write_last_duration(  );
        return stats_write_last_duration;
    endfunction

    function automatic int do_get_config_stats_read_data_occupancy_step(  );
        return config_stats_read_data_occupancy_step;
    endfunction

    function automatic int do_get_config_stats_read_data_occupancy_multiple(  );
        return config_stats_read_data_occupancy_multiple;
    endfunction

    function automatic int do_get_stats_read_data_occupancy_sw(  );
        return stats_read_data_occupancy_sw;
    endfunction

    function automatic int do_get_stats_read_data_idle_sw(  );
        return stats_read_data_idle_sw;
    endfunction

    function automatic int do_get_stats_read_data_occupancy_min(  );
        return stats_read_data_occupancy_min;
    endfunction

    function automatic int do_get_stats_read_data_idle_min(  );
        return stats_read_data_idle_min;
    endfunction

    function automatic int do_get_stats_read_data_occupancy_max(  );
        return stats_read_data_occupancy_max;
    endfunction

    function automatic int do_get_stats_read_data_idle_max(  );
        return stats_read_data_idle_max;
    endfunction

    function automatic int do_get_stats_read_data_occupancy_mean(  );
        return stats_read_data_occupancy_mean;
    endfunction

    function automatic int do_get_stats_read_data_idle_mean(  );
        return stats_read_data_idle_mean;
    endfunction

    function automatic int do_get_config_stats_write_data_occupancy_step(  );
        return config_stats_write_data_occupancy_step;
    endfunction

    function automatic int do_get_config_stats_write_data_occupancy_multiple(  );
        return config_stats_write_data_occupancy_multiple;
    endfunction

    function automatic int do_get_stats_write_data_occupancy_sw(  );
        return stats_write_data_occupancy_sw;
    endfunction

    function automatic int do_get_stats_write_data_idle_sw(  );
        return stats_write_data_idle_sw;
    endfunction

    function automatic int do_get_stats_write_data_occupancy_min(  );
        return stats_write_data_occupancy_min;
    endfunction

    function automatic int do_get_stats_write_data_idle_min(  );
        return stats_write_data_idle_min;
    endfunction

    function automatic int do_get_stats_write_data_occupancy_max(  );
        return stats_write_data_occupancy_max;
    endfunction

    function automatic int do_get_stats_write_data_idle_max(  );
        return stats_write_data_idle_max;
    endfunction

    function automatic int do_get_stats_write_data_occupancy_mean(  );
        return stats_write_data_occupancy_mean;
    endfunction

    function automatic int do_get_stats_write_data_idle_mean(  );
        return stats_write_data_idle_mean;
    endfunction

    function automatic int do_get_config_stats_read_bandwidth_step(  );
        return config_stats_read_bandwidth_step;
    endfunction

    function automatic int do_get_config_stats_read_bandwidth_multiple(  );
        return config_stats_read_bandwidth_multiple;
    endfunction

    function automatic int do_get_stats_read_bandwidth_sw(  );
        return stats_read_bandwidth_sw;
    endfunction

    function automatic int do_get_stats_read_bandwidth_min(  );
        return stats_read_bandwidth_min;
    endfunction

    function automatic int do_get_stats_read_bandwidth_max(  );
        return stats_read_bandwidth_max;
    endfunction

    function automatic int do_get_stats_read_bandwidth_mean(  );
        return stats_read_bandwidth_mean;
    endfunction

    function automatic int do_get_config_stats_write_bandwidth_step(  );
        return config_stats_write_bandwidth_step;
    endfunction

    function automatic int do_get_config_stats_write_bandwidth_multiple(  );
        return config_stats_write_bandwidth_multiple;
    endfunction

    function automatic int do_get_stats_write_bandwidth_sw(  );
        return stats_write_bandwidth_sw;
    endfunction

    function automatic int do_get_stats_write_bandwidth_min(  );
        return stats_write_bandwidth_min;
    endfunction

    function automatic int do_get_stats_write_bandwidth_max(  );
        return stats_write_bandwidth_max;
    endfunction

    function automatic int do_get_stats_write_bandwidth_mean(  );
        return stats_write_bandwidth_mean;
    endfunction

    function automatic int do_get_config_stats_read_latency_step(  );
        return config_stats_read_latency_step;
    endfunction

    function automatic int do_get_config_stats_read_latency_multiple(  );
        return config_stats_read_latency_multiple;
    endfunction

    function automatic int do_get_stats_read_address_data_latency_inst(  );
        return stats_read_address_data_latency_inst;
    endfunction

    function automatic int do_get_stats_read_address_data_latency_sw(  );
        return stats_read_address_data_latency_sw;
    endfunction

    function automatic int do_get_stats_read_address_data_latency_min(  );
        return stats_read_address_data_latency_min;
    endfunction

    function automatic int do_get_stats_read_address_data_latency_max(  );
        return stats_read_address_data_latency_max;
    endfunction

    function automatic int do_get_stats_read_address_data_latency_mean(  );
        return stats_read_address_data_latency_mean;
    endfunction

    function automatic int do_get_stats_read_address_address_latency_inst(  );
        return stats_read_address_address_latency_inst;
    endfunction

    function automatic int do_get_stats_read_address_address_latency_sw(  );
        return stats_read_address_address_latency_sw;
    endfunction

    function automatic int do_get_stats_read_address_address_latency_min(  );
        return stats_read_address_address_latency_min;
    endfunction

    function automatic int do_get_stats_read_address_address_latency_max(  );
        return stats_read_address_address_latency_max;
    endfunction

    function automatic int do_get_stats_read_address_address_latency_mean(  );
        return stats_read_address_address_latency_mean;
    endfunction

    function automatic int do_get_config_stats_write_latency_step(  );
        return config_stats_write_latency_step;
    endfunction

    function automatic int do_get_config_stats_write_latency_multiple(  );
        return config_stats_write_latency_multiple;
    endfunction

    function automatic int do_get_stats_write_address_response_latency_inst(  );
        return stats_write_address_response_latency_inst;
    endfunction

    function automatic int do_get_stats_write_address_response_latency_sw(  );
        return stats_write_address_response_latency_sw;
    endfunction

    function automatic int do_get_stats_write_address_response_latency_min(  );
        return stats_write_address_response_latency_min;
    endfunction

    function automatic int do_get_stats_write_address_response_latency_max(  );
        return stats_write_address_response_latency_max;
    endfunction

    function automatic int do_get_stats_write_address_response_latency_mean(  );
        return stats_write_address_response_latency_mean;
    endfunction

    function automatic int do_get_stats_write_address_address_latency_inst(  );
        return stats_write_address_address_latency_inst;
    endfunction

    function automatic int do_get_stats_write_address_address_latency_sw(  );
        return stats_write_address_address_latency_sw;
    endfunction

    function automatic int do_get_stats_write_address_address_latency_min(  );
        return stats_write_address_address_latency_min;
    endfunction

    function automatic int do_get_stats_write_address_address_latency_max(  );
        return stats_write_address_address_latency_max;
    endfunction

    function automatic int do_get_stats_write_address_address_latency_mean(  );
        return stats_write_address_address_latency_mean;
    endfunction

    function automatic int do_get_config_stats_read_address_waits_step(  );
        return config_stats_read_address_waits_step;
    endfunction

    function automatic int do_get_config_stats_read_address_waits_multiple(  );
        return config_stats_read_address_waits_multiple;
    endfunction

    function automatic int do_get_stats_read_address_waits_inst(  );
        return stats_read_address_waits_inst;
    endfunction

    function automatic int do_get_stats_read_address_waits_sw(  );
        return stats_read_address_waits_sw;
    endfunction

    function automatic int do_get_stats_read_address_waits_min(  );
        return stats_read_address_waits_min;
    endfunction

    function automatic int do_get_stats_read_address_waits_max(  );
        return stats_read_address_waits_max;
    endfunction

    function automatic int do_get_stats_read_address_waits_mean(  );
        return stats_read_address_waits_mean;
    endfunction

    function automatic int do_get_config_stats_read_data_waits_step(  );
        return config_stats_read_data_waits_step;
    endfunction

    function automatic int do_get_config_stats_read_data_waits_multiple(  );
        return config_stats_read_data_waits_multiple;
    endfunction

    function automatic int do_get_stats_read_data_waits_inst(  );
        return stats_read_data_waits_inst;
    endfunction

    function automatic int do_get_stats_read_data_waits_sw(  );
        return stats_read_data_waits_sw;
    endfunction

    function automatic int do_get_stats_read_data_waits_min(  );
        return stats_read_data_waits_min;
    endfunction

    function automatic int do_get_stats_read_data_waits_max(  );
        return stats_read_data_waits_max;
    endfunction

    function automatic int do_get_stats_read_data_waits_mean(  );
        return stats_read_data_waits_mean;
    endfunction

    function automatic int do_get_config_stats_write_address_waits_step(  );
        return config_stats_write_address_waits_step;
    endfunction

    function automatic int do_get_config_stats_write_address_waits_multiple(  );
        return config_stats_write_address_waits_multiple;
    endfunction

    function automatic int do_get_stats_write_address_waits_inst(  );
        return stats_write_address_waits_inst;
    endfunction

    function automatic int do_get_stats_write_address_waits_sw(  );
        return stats_write_address_waits_sw;
    endfunction

    function automatic int do_get_stats_write_address_waits_min(  );
        return stats_write_address_waits_min;
    endfunction

    function automatic int do_get_stats_write_address_waits_max(  );
        return stats_write_address_waits_max;
    endfunction

    function automatic int do_get_stats_write_address_waits_mean(  );
        return stats_write_address_waits_mean;
    endfunction

    function automatic int do_get_config_stats_write_data_waits_step(  );
        return config_stats_write_data_waits_step;
    endfunction

    function automatic int do_get_config_stats_write_data_waits_multiple(  );
        return config_stats_write_data_waits_multiple;
    endfunction

    function automatic int do_get_stats_write_data_waits_inst(  );
        return stats_write_data_waits_inst;
    endfunction

    function automatic int do_get_stats_write_data_waits_sw(  );
        return stats_write_data_waits_sw;
    endfunction

    function automatic int do_get_stats_write_data_waits_min(  );
        return stats_write_data_waits_min;
    endfunction

    function automatic int do_get_stats_write_data_waits_max(  );
        return stats_write_data_waits_max;
    endfunction

    function automatic int do_get_stats_write_data_waits_mean(  );
        return stats_write_data_waits_mean;
    endfunction

    function automatic int do_get_config_stats_write_response_waits_step(  );
        return config_stats_write_response_waits_step;
    endfunction

    function automatic int do_get_config_stats_write_response_waits_multiple(  );
        return config_stats_write_response_waits_multiple;
    endfunction

    function automatic int do_get_stats_write_response_waits_inst(  );
        return stats_write_response_waits_inst;
    endfunction

    function automatic int do_get_stats_write_response_waits_sw(  );
        return stats_write_response_waits_sw;
    endfunction

    function automatic int do_get_stats_write_response_waits_min(  );
        return stats_write_response_waits_min;
    endfunction

    function automatic int do_get_stats_write_response_waits_max(  );
        return stats_write_response_waits_max;
    endfunction

    function automatic int do_get_stats_write_response_waits_mean(  );
        return stats_write_response_waits_mean;
    endfunction

    function automatic int do_get_reordering_depth_of_last_read_transaction(  );
        return reordering_depth_of_last_read_transaction;
    endfunction


    //------------------------------------------------------------------------------
    // Interface end access functions
    //------------------------------------------------------------------------------

    function longint do_get_axi4_master_end();
        return axi4_get_axi4_master_end();
    endfunction

    function longint do_get_axi4_slave_end();
        return axi4_get_axi4_slave_end();
    endfunction

    function longint do_get_axi4_clock_source_end();
        return axi4_get_axi4_clock_source_end();
    endfunction

    function longint do_get_axi4_reset_source_end();
        return axi4_get_axi4_reset_source_end();
    endfunction

    function longint do_get_axi4__monitor_end();
        return axi4_get_axi4__monitor_end();
    endfunction

    //------------------------------------------------------------------------------
    // Functions to set/get generic interface configuration
    //------------------------------------------------------------------------------

    function void do_set_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0,
        input int arg10 = 0
    );
        axi4_set_interface( what, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10 );
    endfunction

    function int do_get_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0
    );
        return axi4_get_interface( what, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 );
    endfunction

    //------------------------------------------------------------------------------
    // Functions to get the hierarchic name of this interface
    //------------------------------------------------------------------------------
    function string do_get_full_name();
        return axi4_get_full_name();
    endfunction

    //------------------------------------------------------------------------------
    // Functions to set/get the abstraction levels of interface ends
    //------------------------------------------------------------------------------

    function void do_axi4_set_master_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi4_set_master_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi4_get_master_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi4_get_master_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi4_set_slave_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi4_set_slave_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi4_get_slave_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi4_get_slave_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi4_set_clock_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi4_set_clock_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi4_get_clock_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi4_get_clock_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi4_set_reset_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        axi4_set_reset_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

    function void do_axi4_get_reset_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        axi4_get_reset_source_end_abstraction_level( wire_level, TLM_level );
    endfunction

// Variable monitors

    function automatic void axi4_local_set_config_interface_type_from_SystemVerilog( ref axi4_interface_type_e config_interface_type_param );
        int tmp_config_interface_type;
        tmp_config_interface_type = int'( config_interface_type );
            axi4_set_config_interface_type_from_SystemVerilog(
            tmp_config_interface_type
            ); // DPI call to imported task
        
            axi4_propagate_config_interface_type_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_interface_type_from_SystemVerilog( config_interface_type );
            end
        end
    end

    function automatic void axi4_local_set_config_clk_init_value_from_SystemVerilog( ref bit config_clk_init_value_param );
            axi4_set_config_clk_init_value_from_SystemVerilog(config_clk_init_value); // DPI call to imported task
        
            axi4_propagate_config_clk_init_value_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_clk_init_value_from_SystemVerilog( config_clk_init_value );
            end
        end
    end

    function automatic void axi4_local_set_config_clk_phase_shift_from_SystemVerilog( ref longint unsigned config_clk_phase_shift_param );
            axi4_set_config_clk_phase_shift_from_SystemVerilog(config_clk_phase_shift); // DPI call to imported task
        
            axi4_propagate_config_clk_phase_shift_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_clk_phase_shift_from_SystemVerilog( config_clk_phase_shift );
            end
        end
    end

    function automatic void axi4_local_set_config_clk_1st_time_from_SystemVerilog( ref longint unsigned config_clk_1st_time_param );
            axi4_set_config_clk_1st_time_from_SystemVerilog(config_clk_1st_time); // DPI call to imported task
        
            axi4_propagate_config_clk_1st_time_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_clk_1st_time_from_SystemVerilog( config_clk_1st_time );
            end
        end
    end

    function automatic void axi4_local_set_config_clk_2nd_time_from_SystemVerilog( ref longint unsigned config_clk_2nd_time_param );
            axi4_set_config_clk_2nd_time_from_SystemVerilog(config_clk_2nd_time); // DPI call to imported task
        
            axi4_propagate_config_clk_2nd_time_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_clk_2nd_time_from_SystemVerilog( config_clk_2nd_time );
            end
        end
    end

    function automatic void axi4_local_set_config_setup_time_from_SystemVerilog( ref longint unsigned config_setup_time_param );
            axi4_set_config_setup_time_from_SystemVerilog(config_setup_time); // DPI call to imported task
        
            axi4_propagate_config_setup_time_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_setup_time_from_SystemVerilog( config_setup_time );
            end
        end
    end

    function automatic void axi4_local_set_config_hold_time_from_SystemVerilog( ref longint unsigned config_hold_time_param );
            axi4_set_config_hold_time_from_SystemVerilog(config_hold_time); // DPI call to imported task
        
            axi4_propagate_config_hold_time_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_hold_time_from_SystemVerilog( config_hold_time );
            end
        end
    end

    function automatic void axi4_local_set_config_burst_timeout_factor_from_SystemVerilog( ref int unsigned config_burst_timeout_factor_param );
            axi4_set_config_burst_timeout_factor_from_SystemVerilog(config_burst_timeout_factor); // DPI call to imported task
        
            axi4_propagate_config_burst_timeout_factor_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_burst_timeout_factor_from_SystemVerilog( config_burst_timeout_factor );
            end
        end
    end

    function automatic void axi4_local_set_config_max_transaction_time_factor_from_SystemVerilog( ref int unsigned config_max_transaction_time_factor_param );
            axi4_set_config_max_transaction_time_factor_from_SystemVerilog(config_max_transaction_time_factor); // DPI call to imported task
        
            axi4_propagate_config_max_transaction_time_factor_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_transaction_time_factor_from_SystemVerilog( config_max_transaction_time_factor );
            end
        end
    end

    function automatic void axi4_local_set_config_write_ctrl_first_ratio_from_SystemVerilog( ref int config_write_ctrl_first_ratio_param );
            axi4_set_config_write_ctrl_first_ratio_from_SystemVerilog(config_write_ctrl_first_ratio); // DPI call to imported task
        
            axi4_propagate_config_write_ctrl_first_ratio_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_write_ctrl_first_ratio_from_SystemVerilog( config_write_ctrl_first_ratio );
            end
        end
    end

    function automatic void axi4_local_set_config_write_data_first_ratio_from_SystemVerilog( ref int config_write_data_first_ratio_param );
            axi4_set_config_write_data_first_ratio_from_SystemVerilog(config_write_data_first_ratio); // DPI call to imported task
        
            axi4_propagate_config_write_data_first_ratio_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_write_data_first_ratio_from_SystemVerilog( config_write_data_first_ratio );
            end
        end
    end

    function automatic void axi4_local_set_config_reset_low_clocks_from_SystemVerilog( ref int config_reset_low_clocks_param );
            axi4_set_config_reset_low_clocks_from_SystemVerilog(config_reset_low_clocks); // DPI call to imported task
        
            axi4_propagate_config_reset_low_clocks_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_reset_low_clocks_from_SystemVerilog( config_reset_low_clocks );
            end
        end
    end

    function automatic void axi4_local_set_config_reset_hold_time_from_SystemVerilog( ref int config_reset_hold_time_param );
            axi4_set_config_reset_hold_time_from_SystemVerilog(config_reset_hold_time); // DPI call to imported task
        
            axi4_propagate_config_reset_hold_time_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_reset_hold_time_from_SystemVerilog( config_reset_hold_time );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_rlast_from_SystemVerilog( ref bit config_enable_rlast_param );
            axi4_set_config_enable_rlast_from_SystemVerilog(config_enable_rlast); // DPI call to imported task
        
            axi4_propagate_config_enable_rlast_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_rlast_from_SystemVerilog( config_enable_rlast );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_slave_exclusive_from_SystemVerilog( ref bit config_enable_slave_exclusive_param );
            axi4_set_config_enable_slave_exclusive_from_SystemVerilog(config_enable_slave_exclusive); // DPI call to imported task
        
            axi4_propagate_config_enable_slave_exclusive_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_slave_exclusive_from_SystemVerilog( config_enable_slave_exclusive );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_burst_reserved_value_from_SystemVerilog( ref bit config_enable_burst_reserved_value_param );
            axi4_set_config_enable_burst_reserved_value_from_SystemVerilog(config_enable_burst_reserved_value); // DPI call to imported task
        
            axi4_propagate_config_enable_burst_reserved_value_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_burst_reserved_value_from_SystemVerilog( config_enable_burst_reserved_value );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_cache_value_from_SystemVerilog( ref bit [15:0] config_enable_cache_value_param );
            axi4_set_config_enable_cache_value_from_SystemVerilog(config_enable_cache_value); // DPI call to imported task
        
            axi4_propagate_config_enable_cache_value_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_cache_value_from_SystemVerilog( config_enable_cache_value );
            end
        end
    end

    function automatic void axi4_local_set_internal_dummy_variable_from_SystemVerilog( ref axi4_error_e internal_dummy_variable_param );
        int tmp_internal_dummy_variable;
        tmp_internal_dummy_variable = int'( internal_dummy_variable );
            axi4_set_internal_dummy_variable_from_SystemVerilog(
            tmp_internal_dummy_variable
            ); // DPI call to imported task
        
            axi4_propagate_internal_dummy_variable_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_internal_dummy_variable_from_SystemVerilog( internal_dummy_variable );
            end
        end
    end

    function automatic void axi4_local_set_config_axi4lite_interface_from_SystemVerilog( ref bit config_axi4lite_interface_param );
            axi4_set_config_axi4lite_interface_from_SystemVerilog(config_axi4lite_interface); // DPI call to imported task
        
            axi4_propagate_config_axi4lite_interface_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_axi4lite_interface_from_SystemVerilog( config_axi4lite_interface );
            end
        end
    end

    function automatic void axi4_local_set_config_axi4lite_tr_id_from_SystemVerilog( ref bit [((AXI4_ID_WIDTH) - 1):0]  config_axi4lite_tr_id_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_ID_WIDTH ); _this_dot_1++)
        begin
            axi4_set_config_axi4lite_tr_id_from_SystemVerilog_index1(_this_dot_1,config_axi4lite_tr_id[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
            axi4_propagate_config_axi4lite_tr_id_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_axi4lite_tr_id_from_SystemVerilog( config_axi4lite_tr_id );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_all_assertions_from_SystemVerilog( ref bit config_enable_all_assertions_param );
            axi4_set_config_enable_all_assertions_from_SystemVerilog(config_enable_all_assertions); // DPI call to imported task
        
            axi4_propagate_config_enable_all_assertions_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_all_assertions_from_SystemVerilog( config_enable_all_assertions );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_assertion_from_SystemVerilog( ref bit [255:0] config_enable_assertion_param );
            axi4_set_config_enable_assertion_from_SystemVerilog(config_enable_assertion); // DPI call to imported task
        
            axi4_propagate_config_enable_assertion_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_assertion_from_SystemVerilog( config_enable_assertion );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_error_from_SystemVerilog( ref bit [255:0] config_enable_error_param );
            axi4_set_config_enable_error_from_SystemVerilog(config_enable_error); // DPI call to imported task
        
            axi4_propagate_config_enable_error_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_error_from_SystemVerilog( config_enable_error );
            end
        end
    end

    function automatic void axi4_local_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog( ref int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
            axi4_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog(config_max_latency_AWVALID_assertion_to_AWREADY); // DPI call to imported task
        
            axi4_propagate_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_latency_AWVALID_assertion_to_AWREADY_from_SystemVerilog( config_max_latency_AWVALID_assertion_to_AWREADY );
            end
        end
    end

    function automatic void axi4_local_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog( ref int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
            axi4_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog(config_max_latency_ARVALID_assertion_to_ARREADY); // DPI call to imported task
        
            axi4_propagate_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_latency_ARVALID_assertion_to_ARREADY_from_SystemVerilog( config_max_latency_ARVALID_assertion_to_ARREADY );
            end
        end
    end

    function automatic void axi4_local_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog( ref int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
            axi4_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog(config_max_latency_RVALID_assertion_to_RREADY); // DPI call to imported task
        
            axi4_propagate_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_latency_RVALID_assertion_to_RREADY_from_SystemVerilog( config_max_latency_RVALID_assertion_to_RREADY );
            end
        end
    end

    function automatic void axi4_local_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog( ref int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
            axi4_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog(config_max_latency_BVALID_assertion_to_BREADY); // DPI call to imported task
        
            axi4_propagate_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_latency_BVALID_assertion_to_BREADY_from_SystemVerilog( config_max_latency_BVALID_assertion_to_BREADY );
            end
        end
    end

    function automatic void axi4_local_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog( ref int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
            axi4_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog(config_max_latency_WVALID_assertion_to_WREADY); // DPI call to imported task
        
            axi4_propagate_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_latency_WVALID_assertion_to_WREADY_from_SystemVerilog( config_max_latency_WVALID_assertion_to_WREADY );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_qos_from_SystemVerilog( ref bit config_enable_qos_param );
            axi4_set_config_enable_qos_from_SystemVerilog(config_enable_qos); // DPI call to imported task
        
            axi4_propagate_config_enable_qos_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_qos_from_SystemVerilog( config_enable_qos );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_region_support_from_SystemVerilog( ref bit config_enable_region_support_param );
            axi4_set_config_enable_region_support_from_SystemVerilog(config_enable_region_support); // DPI call to imported task
        
            axi4_propagate_config_enable_region_support_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_region_support_from_SystemVerilog( config_enable_region_support );
            end
        end
    end

    function automatic void axi4_local_set_config_slave_regions_from_SystemVerilog( ref int config_slave_regions_param );
            axi4_set_config_slave_regions_from_SystemVerilog(config_slave_regions); // DPI call to imported task
        
            axi4_propagate_config_slave_regions_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_slave_regions_from_SystemVerilog( config_slave_regions );
            end
        end
    end

    function automatic void axi4_local_set_config_region_from_SystemVerilog( ref bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  config_region_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_REGION_MAP_SIZE ); _this_dot_1++)
        begin
        begin
        for (int _this_dot_2= 0; _this_dot_2 < ( 2 * AXI4_ADDRESS_WIDTH + 4 + 1 ); _this_dot_2++)
        begin
            axi4_set_config_region_from_SystemVerilog_index2(_this_dot_1,_this_dot_2,config_region[_this_dot_1][_this_dot_2]); // DPI call to imported task
        
        end
        end/* 1 */ 
        end
        end/* 2 */ 
            axi4_propagate_config_region_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_region_from_SystemVerilog( config_region );
            end
        end
    end

    function automatic void axi4_local_set_config_read_data_reordering_depth_from_SystemVerilog( ref int unsigned config_read_data_reordering_depth_param );
            axi4_set_config_read_data_reordering_depth_from_SystemVerilog(config_read_data_reordering_depth); // DPI call to imported task
        
            axi4_propagate_config_read_data_reordering_depth_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_read_data_reordering_depth_from_SystemVerilog( config_read_data_reordering_depth );
            end
        end
    end

    function automatic void axi4_local_set_config_slave_start_addr_from_SystemVerilog( ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_ADDRESS_WIDTH ); _this_dot_1++)
        begin
            axi4_set_config_slave_start_addr_from_SystemVerilog_index1(_this_dot_1,config_slave_start_addr[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
            axi4_propagate_config_slave_start_addr_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_slave_start_addr_from_SystemVerilog( config_slave_start_addr );
            end
        end
    end

    function automatic void axi4_local_set_config_slave_end_addr_from_SystemVerilog( ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( AXI4_ADDRESS_WIDTH ); _this_dot_1++)
        begin
            axi4_set_config_slave_end_addr_from_SystemVerilog_index1(_this_dot_1,config_slave_end_addr[_this_dot_1]); // DPI call to imported task
        
        end
        end/* 1 */ 
            axi4_propagate_config_slave_end_addr_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_slave_end_addr_from_SystemVerilog( config_slave_end_addr );
            end
        end
    end

    function automatic void axi4_local_set_config_slave_enabled_non_contiguous_address_spaces_from_SystemVerilog( ref int config_slave_enabled_non_contiguous_address_spaces_param );
            axi4_set_config_slave_enabled_non_contiguous_address_spaces_from_SystemVerilog(config_slave_enabled_non_contiguous_address_spaces); // DPI call to imported task
        
            axi4_propagate_config_slave_enabled_non_contiguous_address_spaces_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_slave_enabled_non_contiguous_address_spaces_from_SystemVerilog( config_slave_enabled_non_contiguous_address_spaces );
            end
        end
    end

    function automatic void axi4_local_set_config_slave_possess_multiple_non_contiguous_address_spaces_from_SystemVerilog( ref bit config_slave_possess_multiple_non_contiguous_address_spaces_param );
            axi4_set_config_slave_possess_multiple_non_contiguous_address_spaces_from_SystemVerilog(config_slave_possess_multiple_non_contiguous_address_spaces); // DPI call to imported task
        
            axi4_propagate_config_slave_possess_multiple_non_contiguous_address_spaces_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_slave_possess_multiple_non_contiguous_address_spaces_from_SystemVerilog( config_slave_possess_multiple_non_contiguous_address_spaces );
            end
        end
    end

    function automatic void axi4_local_set_config_slave_multiple_non_contiguous_start_address_range_from_SystemVerilog( ref bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_start_address_range_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( 256 ); _this_dot_1++)
        begin
        begin
        for (int _this_dot_2= 0; _this_dot_2 < ( AXI4_ADDRESS_WIDTH ); _this_dot_2++)
        begin
            axi4_set_config_slave_multiple_non_contiguous_start_address_range_from_SystemVerilog_index2(_this_dot_1,_this_dot_2,config_slave_multiple_non_contiguous_start_address_range[_this_dot_1][_this_dot_2]); // DPI call to imported task
        
        end
        end/* 1 */ 
        end
        end/* 2 */ 
            axi4_propagate_config_slave_multiple_non_contiguous_start_address_range_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_slave_multiple_non_contiguous_start_address_range_from_SystemVerilog( config_slave_multiple_non_contiguous_start_address_range );
            end
        end
    end

    function automatic void axi4_local_set_config_slave_multiple_non_contiguous_end_address_range_from_SystemVerilog( ref bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_end_address_range_param );
        begin
        for (int _this_dot_1= 0; _this_dot_1 < ( 256 ); _this_dot_1++)
        begin
        begin
        for (int _this_dot_2= 0; _this_dot_2 < ( AXI4_ADDRESS_WIDTH ); _this_dot_2++)
        begin
            axi4_set_config_slave_multiple_non_contiguous_end_address_range_from_SystemVerilog_index2(_this_dot_1,_this_dot_2,config_slave_multiple_non_contiguous_end_address_range[_this_dot_1][_this_dot_2]); // DPI call to imported task
        
        end
        end/* 1 */ 
        end
        end/* 2 */ 
            axi4_propagate_config_slave_multiple_non_contiguous_end_address_range_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_slave_multiple_non_contiguous_end_address_range_from_SystemVerilog( config_slave_multiple_non_contiguous_end_address_range );
            end
        end
    end

    function automatic void axi4_local_set_config_protect_ready_from_SystemVerilog( ref bit config_protect_ready_param );
            axi4_set_config_protect_ready_from_SystemVerilog(config_protect_ready); // DPI call to imported task
        
            axi4_propagate_config_protect_ready_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_protect_ready_from_SystemVerilog( config_protect_ready );
            end
        end
    end

    function automatic void axi4_local_set_config_max_outstanding_wr_from_SystemVerilog( ref int config_max_outstanding_wr_param );
            axi4_set_config_max_outstanding_wr_from_SystemVerilog(config_max_outstanding_wr); // DPI call to imported task
        
            axi4_propagate_config_max_outstanding_wr_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_outstanding_wr_from_SystemVerilog( config_max_outstanding_wr );
            end
        end
    end

    function automatic void axi4_local_set_config_max_outstanding_rd_from_SystemVerilog( ref int config_max_outstanding_rd_param );
            axi4_set_config_max_outstanding_rd_from_SystemVerilog(config_max_outstanding_rd); // DPI call to imported task
        
            axi4_propagate_config_max_outstanding_rd_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_max_outstanding_rd_from_SystemVerilog( config_max_outstanding_rd );
            end
        end
    end

    function automatic void axi4_local_set_config_num_outstanding_wr_phase_from_SystemVerilog( ref int config_num_outstanding_wr_phase_param );
            axi4_set_config_num_outstanding_wr_phase_from_SystemVerilog(config_num_outstanding_wr_phase); // DPI call to imported task
        
            axi4_propagate_config_num_outstanding_wr_phase_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_num_outstanding_wr_phase_from_SystemVerilog( config_num_outstanding_wr_phase );
            end
        end
    end

    function automatic void axi4_local_set_config_num_outstanding_rd_phase_from_SystemVerilog( ref int config_num_outstanding_rd_phase_param );
            axi4_set_config_num_outstanding_rd_phase_from_SystemVerilog(config_num_outstanding_rd_phase); // DPI call to imported task
        
            axi4_propagate_config_num_outstanding_rd_phase_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_num_outstanding_rd_phase_from_SystemVerilog( config_num_outstanding_rd_phase );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_warnings_from_SystemVerilog( ref bit config_enable_warnings_param );
            axi4_set_config_enable_warnings_from_SystemVerilog(config_enable_warnings); // DPI call to imported task
        
            axi4_propagate_config_enable_warnings_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_warnings_from_SystemVerilog( config_enable_warnings );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_errors_from_SystemVerilog( ref bit config_enable_errors_param );
            axi4_set_config_enable_errors_from_SystemVerilog(config_enable_errors); // DPI call to imported task
        
            axi4_propagate_config_enable_errors_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_errors_from_SystemVerilog( config_enable_errors );
            end
        end
    end

    function automatic void axi4_local_set_config_enable_exclusive_checks_from_SystemVerilog( ref bit config_enable_exclusive_checks_param );
            axi4_set_config_enable_exclusive_checks_from_SystemVerilog(config_enable_exclusive_checks); // DPI call to imported task
        
            axi4_propagate_config_enable_exclusive_checks_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_enable_exclusive_checks_from_SystemVerilog( config_enable_exclusive_checks );
            end
        end
    end

    function automatic void axi4_local_set_config_warn_on_slave_errors_from_SystemVerilog( ref bit config_warn_on_slave_errors_param );
            axi4_set_config_warn_on_slave_errors_from_SystemVerilog(config_warn_on_slave_errors); // DPI call to imported task
        
            axi4_propagate_config_warn_on_slave_errors_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_warn_on_slave_errors_from_SystemVerilog( config_warn_on_slave_errors );
            end
        end
    end

    function automatic void axi4_local_set_config_error_on_deleted_valid_cycles_from_SystemVerilog( ref bit config_error_on_deleted_valid_cycles_param );
            axi4_set_config_error_on_deleted_valid_cycles_from_SystemVerilog(config_error_on_deleted_valid_cycles); // DPI call to imported task
        
            axi4_propagate_config_error_on_deleted_valid_cycles_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_error_on_deleted_valid_cycles_from_SystemVerilog( config_error_on_deleted_valid_cycles );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_from_SystemVerilog( ref bit config_stats_enable_param );
            axi4_set_config_stats_enable_from_SystemVerilog(config_stats_enable); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_from_SystemVerilog( config_stats_enable );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_read_occupancy_from_SystemVerilog( ref bit config_stats_enable_read_occupancy_param );
            axi4_set_config_stats_enable_read_occupancy_from_SystemVerilog(config_stats_enable_read_occupancy); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_read_occupancy_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_read_occupancy_from_SystemVerilog( config_stats_enable_read_occupancy );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_write_occupancy_from_SystemVerilog( ref bit config_stats_enable_write_occupancy_param );
            axi4_set_config_stats_enable_write_occupancy_from_SystemVerilog(config_stats_enable_write_occupancy); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_write_occupancy_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_write_occupancy_from_SystemVerilog( config_stats_enable_write_occupancy );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_read_data_occupancy_from_SystemVerilog( ref bit config_stats_enable_read_data_occupancy_param );
            axi4_set_config_stats_enable_read_data_occupancy_from_SystemVerilog(config_stats_enable_read_data_occupancy); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_read_data_occupancy_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_read_data_occupancy_from_SystemVerilog( config_stats_enable_read_data_occupancy );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_write_data_occupancy_from_SystemVerilog( ref bit config_stats_enable_write_data_occupancy_param );
            axi4_set_config_stats_enable_write_data_occupancy_from_SystemVerilog(config_stats_enable_write_data_occupancy); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_write_data_occupancy_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_write_data_occupancy_from_SystemVerilog( config_stats_enable_write_data_occupancy );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_read_latency_from_SystemVerilog( ref bit config_stats_enable_read_latency_param );
            axi4_set_config_stats_enable_read_latency_from_SystemVerilog(config_stats_enable_read_latency); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_read_latency_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_read_latency_from_SystemVerilog( config_stats_enable_read_latency );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_write_latency_from_SystemVerilog( ref bit config_stats_enable_write_latency_param );
            axi4_set_config_stats_enable_write_latency_from_SystemVerilog(config_stats_enable_write_latency); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_write_latency_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_write_latency_from_SystemVerilog( config_stats_enable_write_latency );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_read_address_waits_from_SystemVerilog( ref bit config_stats_enable_read_address_waits_param );
            axi4_set_config_stats_enable_read_address_waits_from_SystemVerilog(config_stats_enable_read_address_waits); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_read_address_waits_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_read_address_waits_from_SystemVerilog( config_stats_enable_read_address_waits );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_read_data_waits_from_SystemVerilog( ref bit config_stats_enable_read_data_waits_param );
            axi4_set_config_stats_enable_read_data_waits_from_SystemVerilog(config_stats_enable_read_data_waits); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_read_data_waits_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_read_data_waits_from_SystemVerilog( config_stats_enable_read_data_waits );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_write_address_waits_from_SystemVerilog( ref bit config_stats_enable_write_address_waits_param );
            axi4_set_config_stats_enable_write_address_waits_from_SystemVerilog(config_stats_enable_write_address_waits); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_write_address_waits_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_write_address_waits_from_SystemVerilog( config_stats_enable_write_address_waits );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_write_data_waits_from_SystemVerilog( ref bit config_stats_enable_write_data_waits_param );
            axi4_set_config_stats_enable_write_data_waits_from_SystemVerilog(config_stats_enable_write_data_waits); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_write_data_waits_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_write_data_waits_from_SystemVerilog( config_stats_enable_write_data_waits );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_write_response_waits_from_SystemVerilog( ref bit config_stats_enable_write_response_waits_param );
            axi4_set_config_stats_enable_write_response_waits_from_SystemVerilog(config_stats_enable_write_response_waits); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_write_response_waits_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_write_response_waits_from_SystemVerilog( config_stats_enable_write_response_waits );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_read_bandwidth_from_SystemVerilog( ref bit config_stats_enable_read_bandwidth_param );
            axi4_set_config_stats_enable_read_bandwidth_from_SystemVerilog(config_stats_enable_read_bandwidth); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_read_bandwidth_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_read_bandwidth_from_SystemVerilog( config_stats_enable_read_bandwidth );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_enable_write_bandwidth_from_SystemVerilog( ref bit config_stats_enable_write_bandwidth_param );
            axi4_set_config_stats_enable_write_bandwidth_from_SystemVerilog(config_stats_enable_write_bandwidth); // DPI call to imported task
        
            axi4_propagate_config_stats_enable_write_bandwidth_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_enable_write_bandwidth_from_SystemVerilog( config_stats_enable_write_bandwidth );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_occupancy_step_from_SystemVerilog( ref int config_stats_read_occupancy_step_param );
            axi4_set_config_stats_read_occupancy_step_from_SystemVerilog(config_stats_read_occupancy_step); // DPI call to imported task
        
            axi4_propagate_config_stats_read_occupancy_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_occupancy_step_from_SystemVerilog( config_stats_read_occupancy_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_occupancy_multiple_from_SystemVerilog( ref int config_stats_read_occupancy_multiple_param );
            axi4_set_config_stats_read_occupancy_multiple_from_SystemVerilog(config_stats_read_occupancy_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_read_occupancy_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_occupancy_multiple_from_SystemVerilog( config_stats_read_occupancy_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_occupancy_step_from_SystemVerilog( ref int config_stats_write_occupancy_step_param );
            axi4_set_config_stats_write_occupancy_step_from_SystemVerilog(config_stats_write_occupancy_step); // DPI call to imported task
        
            axi4_propagate_config_stats_write_occupancy_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_occupancy_step_from_SystemVerilog( config_stats_write_occupancy_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_occupancy_multiple_from_SystemVerilog( ref int config_stats_write_occupancy_multiple_param );
            axi4_set_config_stats_write_occupancy_multiple_from_SystemVerilog(config_stats_write_occupancy_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_write_occupancy_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_occupancy_multiple_from_SystemVerilog( config_stats_write_occupancy_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_data_occupancy_step_from_SystemVerilog( ref int config_stats_read_data_occupancy_step_param );
            axi4_set_config_stats_read_data_occupancy_step_from_SystemVerilog(config_stats_read_data_occupancy_step); // DPI call to imported task
        
            axi4_propagate_config_stats_read_data_occupancy_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_data_occupancy_step_from_SystemVerilog( config_stats_read_data_occupancy_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog( ref int config_stats_read_data_occupancy_multiple_param );
            axi4_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog(config_stats_read_data_occupancy_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_read_data_occupancy_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_data_occupancy_multiple_from_SystemVerilog( config_stats_read_data_occupancy_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_data_occupancy_step_from_SystemVerilog( ref int config_stats_write_data_occupancy_step_param );
            axi4_set_config_stats_write_data_occupancy_step_from_SystemVerilog(config_stats_write_data_occupancy_step); // DPI call to imported task
        
            axi4_propagate_config_stats_write_data_occupancy_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_data_occupancy_step_from_SystemVerilog( config_stats_write_data_occupancy_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog( ref int config_stats_write_data_occupancy_multiple_param );
            axi4_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog(config_stats_write_data_occupancy_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_write_data_occupancy_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_data_occupancy_multiple_from_SystemVerilog( config_stats_write_data_occupancy_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_bandwidth_step_from_SystemVerilog( ref int config_stats_read_bandwidth_step_param );
            axi4_set_config_stats_read_bandwidth_step_from_SystemVerilog(config_stats_read_bandwidth_step); // DPI call to imported task
        
            axi4_propagate_config_stats_read_bandwidth_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_bandwidth_step_from_SystemVerilog( config_stats_read_bandwidth_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_bandwidth_multiple_from_SystemVerilog( ref int config_stats_read_bandwidth_multiple_param );
            axi4_set_config_stats_read_bandwidth_multiple_from_SystemVerilog(config_stats_read_bandwidth_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_read_bandwidth_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_bandwidth_multiple_from_SystemVerilog( config_stats_read_bandwidth_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_bandwidth_step_from_SystemVerilog( ref int config_stats_write_bandwidth_step_param );
            axi4_set_config_stats_write_bandwidth_step_from_SystemVerilog(config_stats_write_bandwidth_step); // DPI call to imported task
        
            axi4_propagate_config_stats_write_bandwidth_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_bandwidth_step_from_SystemVerilog( config_stats_write_bandwidth_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_bandwidth_multiple_from_SystemVerilog( ref int config_stats_write_bandwidth_multiple_param );
            axi4_set_config_stats_write_bandwidth_multiple_from_SystemVerilog(config_stats_write_bandwidth_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_write_bandwidth_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_bandwidth_multiple_from_SystemVerilog( config_stats_write_bandwidth_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_latency_step_from_SystemVerilog( ref int config_stats_read_latency_step_param );
            axi4_set_config_stats_read_latency_step_from_SystemVerilog(config_stats_read_latency_step); // DPI call to imported task
        
            axi4_propagate_config_stats_read_latency_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_latency_step_from_SystemVerilog( config_stats_read_latency_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_latency_multiple_from_SystemVerilog( ref int config_stats_read_latency_multiple_param );
            axi4_set_config_stats_read_latency_multiple_from_SystemVerilog(config_stats_read_latency_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_read_latency_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_latency_multiple_from_SystemVerilog( config_stats_read_latency_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_latency_step_from_SystemVerilog( ref int config_stats_write_latency_step_param );
            axi4_set_config_stats_write_latency_step_from_SystemVerilog(config_stats_write_latency_step); // DPI call to imported task
        
            axi4_propagate_config_stats_write_latency_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_latency_step_from_SystemVerilog( config_stats_write_latency_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_latency_multiple_from_SystemVerilog( ref int config_stats_write_latency_multiple_param );
            axi4_set_config_stats_write_latency_multiple_from_SystemVerilog(config_stats_write_latency_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_write_latency_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_latency_multiple_from_SystemVerilog( config_stats_write_latency_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_address_waits_step_from_SystemVerilog( ref int config_stats_read_address_waits_step_param );
            axi4_set_config_stats_read_address_waits_step_from_SystemVerilog(config_stats_read_address_waits_step); // DPI call to imported task
        
            axi4_propagate_config_stats_read_address_waits_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_address_waits_step_from_SystemVerilog( config_stats_read_address_waits_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_address_waits_multiple_from_SystemVerilog( ref int config_stats_read_address_waits_multiple_param );
            axi4_set_config_stats_read_address_waits_multiple_from_SystemVerilog(config_stats_read_address_waits_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_read_address_waits_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_address_waits_multiple_from_SystemVerilog( config_stats_read_address_waits_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_data_waits_step_from_SystemVerilog( ref int config_stats_read_data_waits_step_param );
            axi4_set_config_stats_read_data_waits_step_from_SystemVerilog(config_stats_read_data_waits_step); // DPI call to imported task
        
            axi4_propagate_config_stats_read_data_waits_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_data_waits_step_from_SystemVerilog( config_stats_read_data_waits_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_read_data_waits_multiple_from_SystemVerilog( ref int config_stats_read_data_waits_multiple_param );
            axi4_set_config_stats_read_data_waits_multiple_from_SystemVerilog(config_stats_read_data_waits_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_read_data_waits_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_read_data_waits_multiple_from_SystemVerilog( config_stats_read_data_waits_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_address_waits_step_from_SystemVerilog( ref int config_stats_write_address_waits_step_param );
            axi4_set_config_stats_write_address_waits_step_from_SystemVerilog(config_stats_write_address_waits_step); // DPI call to imported task
        
            axi4_propagate_config_stats_write_address_waits_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_address_waits_step_from_SystemVerilog( config_stats_write_address_waits_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_address_waits_multiple_from_SystemVerilog( ref int config_stats_write_address_waits_multiple_param );
            axi4_set_config_stats_write_address_waits_multiple_from_SystemVerilog(config_stats_write_address_waits_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_write_address_waits_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_address_waits_multiple_from_SystemVerilog( config_stats_write_address_waits_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_data_waits_step_from_SystemVerilog( ref int config_stats_write_data_waits_step_param );
            axi4_set_config_stats_write_data_waits_step_from_SystemVerilog(config_stats_write_data_waits_step); // DPI call to imported task
        
            axi4_propagate_config_stats_write_data_waits_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_data_waits_step_from_SystemVerilog( config_stats_write_data_waits_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_data_waits_multiple_from_SystemVerilog( ref int config_stats_write_data_waits_multiple_param );
            axi4_set_config_stats_write_data_waits_multiple_from_SystemVerilog(config_stats_write_data_waits_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_write_data_waits_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_data_waits_multiple_from_SystemVerilog( config_stats_write_data_waits_multiple );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_response_waits_step_from_SystemVerilog( ref int config_stats_write_response_waits_step_param );
            axi4_set_config_stats_write_response_waits_step_from_SystemVerilog(config_stats_write_response_waits_step); // DPI call to imported task
        
            axi4_propagate_config_stats_write_response_waits_step_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_response_waits_step_from_SystemVerilog( config_stats_write_response_waits_step );
            end
        end
    end

    function automatic void axi4_local_set_config_stats_write_response_waits_multiple_from_SystemVerilog( ref int config_stats_write_response_waits_multiple_param );
            axi4_set_config_stats_write_response_waits_multiple_from_SystemVerilog(config_stats_write_response_waits_multiple); // DPI call to imported task
        
            axi4_propagate_config_stats_write_response_waits_multiple_from_SystemVerilog(); // DPI call to imported task
    endfunction

    initial
    begin
        begin
            wait(_interface_ref != 0);
            forever
            begin
                @( * ) axi4_local_set_config_stats_write_response_waits_multiple_from_SystemVerilog( config_stats_write_response_waits_multiple );
            end
        end
    end

    //------------------------------------------------------------------------------
    // Transaction interface
    //------------------------------------------------------------------------------

    bit [((AXI4_ADDRESS_WIDTH) - 1):0]  temp_static_rw_transaction_addr;
    function void axi4_get_temp_static_rw_transaction_addr( input int _d1, output bit  _value );
        _value = temp_static_rw_transaction_addr[_d1];
    endfunction
    function void axi4_set_temp_static_rw_transaction_addr( input int _d1, input bit  _value );
        temp_static_rw_transaction_addr[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_rw_transaction_id;
    function void axi4_get_temp_static_rw_transaction_id( input int _d1, output bit  _value );
        _value = temp_static_rw_transaction_id[_d1];
    endfunction
    function void axi4_set_temp_static_rw_transaction_id( input int _d1, input bit  _value );
        temp_static_rw_transaction_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_rw_transaction_addr_user_data;
    function void axi4_get_temp_static_rw_transaction_addr_user_data( input int _d1, output bit  _value );
        _value = temp_static_rw_transaction_addr_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_rw_transaction_addr_user_data( input int _d1, input bit  _value );
        temp_static_rw_transaction_addr_user_data[_d1] = _value;
    endfunction
    bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] temp_static_rw_transaction_data_words [];
    function void axi4_get_temp_static_rw_transaction_data_words( input int _d1, input int _d2, output bit _value );
        _value = temp_static_rw_transaction_data_words[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_rw_transaction_data_words( input int _d1, input int _d2, input bit _value );
        temp_static_rw_transaction_data_words[_d1][_d2] = _value;
    endfunction
    bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] temp_static_rw_transaction_write_strobes [];
    function void axi4_get_temp_static_rw_transaction_write_strobes( input int _d1, input int _d2, output bit _value );
        _value = temp_static_rw_transaction_write_strobes[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_rw_transaction_write_strobes( input int _d1, input int _d2, input bit _value );
        temp_static_rw_transaction_write_strobes[_d1][_d2] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0] temp_static_rw_transaction_wdata_user_data [];
    function void axi4_get_temp_static_rw_transaction_wdata_user_data( input int _d1, input int _d2, output bit _value );
        _value = temp_static_rw_transaction_wdata_user_data[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_rw_transaction_wdata_user_data( input int _d1, input int _d2, input bit _value );
        temp_static_rw_transaction_wdata_user_data[_d1][_d2] = _value;
    endfunction
    int temp_static_rw_transaction_resp[];
    function void axi4_get_temp_static_rw_transaction_resp( input int _d1, output int _value );
        _value = temp_static_rw_transaction_resp[_d1];
    endfunction
    function void axi4_set_temp_static_rw_transaction_resp( input int _d1, input int _value );
        temp_static_rw_transaction_resp[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0] temp_static_rw_transaction_resp_user_data [];
    function void axi4_get_temp_static_rw_transaction_resp_user_data( input int _d1, input int _d2, output bit _value );
        _value = temp_static_rw_transaction_resp_user_data[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_rw_transaction_resp_user_data( input int _d1, input int _d2, input bit _value );
        temp_static_rw_transaction_resp_user_data[_d1][_d2] = _value;
    endfunction
    int temp_static_rw_transaction_data_valid_delay[];
    function void axi4_get_temp_static_rw_transaction_data_valid_delay( input int _d1, output int _value );
        _value = temp_static_rw_transaction_data_valid_delay[_d1];
    endfunction
    function void axi4_set_temp_static_rw_transaction_data_valid_delay( input int _d1, input int _value );
        temp_static_rw_transaction_data_valid_delay[_d1] = _value;
    endfunction
    int temp_static_rw_transaction_data_ready_delay[];
    function void axi4_get_temp_static_rw_transaction_data_ready_delay( input int _d1, output int _value );
        _value = temp_static_rw_transaction_data_ready_delay[_d1];
    endfunction
    function void axi4_set_temp_static_rw_transaction_data_ready_delay( input int _d1, input int _value );
        temp_static_rw_transaction_data_ready_delay[_d1] = _value;
    endfunction
    int temp_static_rw_transaction_write_data_beats_delay[];
    function void axi4_get_temp_static_rw_transaction_write_data_beats_delay( input int _d1, output int _value );
        _value = temp_static_rw_transaction_write_data_beats_delay[_d1];
    endfunction
    function void axi4_set_temp_static_rw_transaction_write_data_beats_delay( input int _d1, input int _value );
        temp_static_rw_transaction_write_data_beats_delay[_d1] = _value;
    endfunction
    bit [((AXI4_ADDRESS_WIDTH) - 1):0]  temp_static_read_addr;
    function void axi4_get_temp_static_read_addr( input int _d1, output bit  _value );
        _value = temp_static_read_addr[_d1];
    endfunction
    function void axi4_set_temp_static_read_addr( input int _d1, input bit  _value );
        temp_static_read_addr[_d1] = _value;
    endfunction
    int temp_static_read_rresp_delays[255:0];
    function void axi4_get_temp_static_read_rresp_delays( input int _d1, output int _value );
        _value = temp_static_read_rresp_delays[_d1];
    endfunction
    function void axi4_set_temp_static_read_rresp_delays( input int _d1, input int _value );
        temp_static_read_rresp_delays[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_read_id;
    function void axi4_get_temp_static_read_id( input int _d1, output bit  _value );
        _value = temp_static_read_id[_d1];
    endfunction
    function void axi4_set_temp_static_read_id( input int _d1, input bit  _value );
        temp_static_read_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_read_addr_user_data;
    function void axi4_get_temp_static_read_addr_user_data( input int _d1, output bit  _value );
        _value = temp_static_read_addr_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_read_addr_user_data( input int _d1, input bit  _value );
        temp_static_read_addr_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_RDATA_WIDTH) - 1):0] temp_static_read_data_words [];
    function void axi4_get_temp_static_read_data_words( input int _d1, input int _d2, output bit _value );
        _value = temp_static_read_data_words[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_read_data_words( input int _d1, input int _d2, input bit _value );
        temp_static_read_data_words[_d1][_d2] = _value;
    endfunction
    int temp_static_read_resp[];
    function void axi4_get_temp_static_read_resp( input int _d1, output int _value );
        _value = temp_static_read_resp[_d1];
    endfunction
    function void axi4_set_temp_static_read_resp( input int _d1, input int _value );
        temp_static_read_resp[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0] temp_static_read_resp_user_data [];
    function void axi4_get_temp_static_read_resp_user_data( input int _d1, input int _d2, output bit _value );
        _value = temp_static_read_resp_user_data[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_read_resp_user_data( input int _d1, input int _d2, input bit _value );
        temp_static_read_resp_user_data[_d1][_d2] = _value;
    endfunction
    longint temp_static_read_data_start_time[];
    function void axi4_get_temp_static_read_data_start_time( input int _d1, output longint _value );
        _value = temp_static_read_data_start_time[_d1];
    endfunction
    function void axi4_set_temp_static_read_data_start_time( input int _d1, input longint _value );
        temp_static_read_data_start_time[_d1] = _value;
    endfunction
    longint temp_static_read_data_end_time[];
    function void axi4_get_temp_static_read_data_end_time( input int _d1, output longint _value );
        _value = temp_static_read_data_end_time[_d1];
    endfunction
    function void axi4_set_temp_static_read_data_end_time( input int _d1, input longint _value );
        temp_static_read_data_end_time[_d1] = _value;
    endfunction
    bit [((AXI4_ADDRESS_WIDTH) - 1):0]  temp_static_write_addr;
    function void axi4_get_temp_static_write_addr( input int _d1, output bit  _value );
        _value = temp_static_write_addr[_d1];
    endfunction
    function void axi4_set_temp_static_write_addr( input int _d1, input bit  _value );
        temp_static_write_addr[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_write_id;
    function void axi4_get_temp_static_write_id( input int _d1, output bit  _value );
        _value = temp_static_write_id[_d1];
    endfunction
    function void axi4_set_temp_static_write_id( input int _d1, input bit  _value );
        temp_static_write_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_write_addr_user_data;
    function void axi4_get_temp_static_write_addr_user_data( input int _d1, output bit  _value );
        _value = temp_static_write_addr_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_write_addr_user_data( input int _d1, input bit  _value );
        temp_static_write_addr_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_WDATA_WIDTH) - 1):0] temp_static_write_data_words [];
    function void axi4_get_temp_static_write_data_words( input int _d1, input int _d2, output bit _value );
        _value = temp_static_write_data_words[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_write_data_words( input int _d1, input int _d2, input bit _value );
        temp_static_write_data_words[_d1][_d2] = _value;
    endfunction
    bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] temp_static_write_write_strobes [];
    function void axi4_get_temp_static_write_write_strobes( input int _d1, input int _d2, output bit _value );
        _value = temp_static_write_write_strobes[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_write_write_strobes( input int _d1, input int _d2, input bit _value );
        temp_static_write_write_strobes[_d1][_d2] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0] temp_static_write_wdata_user_data [];
    function void axi4_get_temp_static_write_wdata_user_data( input int _d1, input int _d2, output bit _value );
        _value = temp_static_write_wdata_user_data[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_write_wdata_user_data( input int _d1, input int _d2, input bit _value );
        temp_static_write_wdata_user_data[_d1][_d2] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_write_resp_user_data;
    function void axi4_get_temp_static_write_resp_user_data( input int _d1, output bit  _value );
        _value = temp_static_write_resp_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_write_resp_user_data( input int _d1, input bit  _value );
        temp_static_write_resp_user_data[_d1] = _value;
    endfunction
    longint temp_static_write_data_start_time[];
    function void axi4_get_temp_static_write_data_start_time( input int _d1, output longint _value );
        _value = temp_static_write_data_start_time[_d1];
    endfunction
    function void axi4_set_temp_static_write_data_start_time( input int _d1, input longint _value );
        temp_static_write_data_start_time[_d1] = _value;
    endfunction
    longint temp_static_write_data_end_time[];
    function void axi4_get_temp_static_write_data_end_time( input int _d1, output longint _value );
        _value = temp_static_write_data_end_time[_d1];
    endfunction
    function void axi4_set_temp_static_write_data_end_time( input int _d1, input longint _value );
        temp_static_write_data_end_time[_d1] = _value;
    endfunction
    int temp_static_write_write_data_beats_delay[];
    function void axi4_get_temp_static_write_write_data_beats_delay( input int _d1, output int _value );
        _value = temp_static_write_write_data_beats_delay[_d1];
    endfunction
    function void axi4_set_temp_static_write_write_data_beats_delay( input int _d1, input int _value );
        temp_static_write_write_data_beats_delay[_d1] = _value;
    endfunction
    bit [((AXI4_WDATA_WIDTH) - 1):0] temp_static_write_data_burst_data_words [];
    function void axi4_get_temp_static_write_data_burst_data_words( input int _d1, input int _d2, output bit _value );
        _value = temp_static_write_data_burst_data_words[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_write_data_burst_data_words( input int _d1, input int _d2, input bit _value );
        temp_static_write_data_burst_data_words[_d1][_d2] = _value;
    endfunction
    bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] temp_static_write_data_burst_write_strobes [];
    function void axi4_get_temp_static_write_data_burst_write_strobes( input int _d1, input int _d2, output bit _value );
        _value = temp_static_write_data_burst_write_strobes[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_write_data_burst_write_strobes( input int _d1, input int _d2, input bit _value );
        temp_static_write_data_burst_write_strobes[_d1][_d2] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0] temp_static_write_data_burst_user_data [];
    function void axi4_get_temp_static_write_data_burst_user_data( input int _d1, input int _d2, output bit _value );
        _value = temp_static_write_data_burst_user_data[_d1][_d2];
    endfunction
    function void axi4_set_temp_static_write_data_burst_user_data( input int _d1, input int _d2, input bit _value );
        temp_static_write_data_burst_user_data[_d1][_d2] = _value;
    endfunction
    longint temp_static_write_data_burst_data_start_time[];
    function void axi4_get_temp_static_write_data_burst_data_start_time( input int _d1, output longint _value );
        _value = temp_static_write_data_burst_data_start_time[_d1];
    endfunction
    function void axi4_set_temp_static_write_data_burst_data_start_time( input int _d1, input longint _value );
        temp_static_write_data_burst_data_start_time[_d1] = _value;
    endfunction
    longint temp_static_write_data_burst_data_end_time[];
    function void axi4_get_temp_static_write_data_burst_data_end_time( input int _d1, output longint _value );
        _value = temp_static_write_data_burst_data_end_time[_d1];
    endfunction
    function void axi4_set_temp_static_write_data_burst_data_end_time( input int _d1, input longint _value );
        temp_static_write_data_burst_data_end_time[_d1] = _value;
    endfunction
    int temp_static_write_data_burst_write_data_beats_delay[];
    function void axi4_get_temp_static_write_data_burst_write_data_beats_delay( input int _d1, output int _value );
        _value = temp_static_write_data_burst_write_data_beats_delay[_d1];
    endfunction
    function void axi4_set_temp_static_write_data_burst_write_data_beats_delay( input int _d1, input int _value );
        temp_static_write_data_burst_write_data_beats_delay[_d1] = _value;
    endfunction
    bit [((AXI4_ADDRESS_WIDTH) - 1):0]  temp_static_read_addr_channel_phase_addr;
    function void axi4_get_temp_static_read_addr_channel_phase_addr( input int _d1, output bit  _value );
        _value = temp_static_read_addr_channel_phase_addr[_d1];
    endfunction
    function void axi4_set_temp_static_read_addr_channel_phase_addr( input int _d1, input bit  _value );
        temp_static_read_addr_channel_phase_addr[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_read_addr_channel_phase_id;
    function void axi4_get_temp_static_read_addr_channel_phase_id( input int _d1, output bit  _value );
        _value = temp_static_read_addr_channel_phase_id[_d1];
    endfunction
    function void axi4_set_temp_static_read_addr_channel_phase_id( input int _d1, input bit  _value );
        temp_static_read_addr_channel_phase_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_read_addr_channel_phase_addr_user;
    function void axi4_get_temp_static_read_addr_channel_phase_addr_user( input int _d1, output bit  _value );
        _value = temp_static_read_addr_channel_phase_addr_user[_d1];
    endfunction
    function void axi4_set_temp_static_read_addr_channel_phase_addr_user( input int _d1, input bit  _value );
        temp_static_read_addr_channel_phase_addr_user[_d1] = _value;
    endfunction
    bit [((AXI4_RDATA_WIDTH) - 1):0]  temp_static_read_channel_phase_data;
    function void axi4_get_temp_static_read_channel_phase_data( input int _d1, output bit  _value );
        _value = temp_static_read_channel_phase_data[_d1];
    endfunction
    function void axi4_set_temp_static_read_channel_phase_data( input int _d1, input bit  _value );
        temp_static_read_channel_phase_data[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_read_channel_phase_id;
    function void axi4_get_temp_static_read_channel_phase_id( input int _d1, output bit  _value );
        _value = temp_static_read_channel_phase_id[_d1];
    endfunction
    function void axi4_set_temp_static_read_channel_phase_id( input int _d1, input bit  _value );
        temp_static_read_channel_phase_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_read_channel_phase_user_data;
    function void axi4_get_temp_static_read_channel_phase_user_data( input int _d1, output bit  _value );
        _value = temp_static_read_channel_phase_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_read_channel_phase_user_data( input int _d1, input bit  _value );
        temp_static_read_channel_phase_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_ADDRESS_WIDTH) - 1):0]  temp_static_write_addr_channel_phase_addr;
    function void axi4_get_temp_static_write_addr_channel_phase_addr( input int _d1, output bit  _value );
        _value = temp_static_write_addr_channel_phase_addr[_d1];
    endfunction
    function void axi4_set_temp_static_write_addr_channel_phase_addr( input int _d1, input bit  _value );
        temp_static_write_addr_channel_phase_addr[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_write_addr_channel_phase_id;
    function void axi4_get_temp_static_write_addr_channel_phase_id( input int _d1, output bit  _value );
        _value = temp_static_write_addr_channel_phase_id[_d1];
    endfunction
    function void axi4_set_temp_static_write_addr_channel_phase_id( input int _d1, input bit  _value );
        temp_static_write_addr_channel_phase_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_write_addr_channel_phase_addr_user;
    function void axi4_get_temp_static_write_addr_channel_phase_addr_user( input int _d1, output bit  _value );
        _value = temp_static_write_addr_channel_phase_addr_user[_d1];
    endfunction
    function void axi4_set_temp_static_write_addr_channel_phase_addr_user( input int _d1, input bit  _value );
        temp_static_write_addr_channel_phase_addr_user[_d1] = _value;
    endfunction
    bit [((AXI4_WDATA_WIDTH) - 1):0]  temp_static_write_channel_phase_data;
    function void axi4_get_temp_static_write_channel_phase_data( input int _d1, output bit  _value );
        _value = temp_static_write_channel_phase_data[_d1];
    endfunction
    function void axi4_set_temp_static_write_channel_phase_data( input int _d1, input bit  _value );
        temp_static_write_channel_phase_data[_d1] = _value;
    endfunction
    bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  temp_static_write_channel_phase_write_strobes;
    function void axi4_get_temp_static_write_channel_phase_write_strobes( input int _d1, output bit  _value );
        _value = temp_static_write_channel_phase_write_strobes[_d1];
    endfunction
    function void axi4_set_temp_static_write_channel_phase_write_strobes( input int _d1, input bit  _value );
        temp_static_write_channel_phase_write_strobes[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_write_channel_phase_user_data;
    function void axi4_get_temp_static_write_channel_phase_user_data( input int _d1, output bit  _value );
        _value = temp_static_write_channel_phase_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_write_channel_phase_user_data( input int _d1, input bit  _value );
        temp_static_write_channel_phase_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_write_resp_channel_phase_id;
    function void axi4_get_temp_static_write_resp_channel_phase_id( input int _d1, output bit  _value );
        _value = temp_static_write_resp_channel_phase_id[_d1];
    endfunction
    function void axi4_set_temp_static_write_resp_channel_phase_id( input int _d1, input bit  _value );
        temp_static_write_resp_channel_phase_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_write_resp_channel_phase_user_data;
    function void axi4_get_temp_static_write_resp_channel_phase_user_data( input int _d1, output bit  _value );
        _value = temp_static_write_resp_channel_phase_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_write_resp_channel_phase_user_data( input int _d1, input bit  _value );
        temp_static_write_resp_channel_phase_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_ADDRESS_WIDTH) - 1):0]  temp_static_read_addr_channel_cycle_addr;
    function void axi4_get_temp_static_read_addr_channel_cycle_addr( input int _d1, output bit  _value );
        _value = temp_static_read_addr_channel_cycle_addr[_d1];
    endfunction
    function void axi4_set_temp_static_read_addr_channel_cycle_addr( input int _d1, input bit  _value );
        temp_static_read_addr_channel_cycle_addr[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_read_addr_channel_cycle_id;
    function void axi4_get_temp_static_read_addr_channel_cycle_id( input int _d1, output bit  _value );
        _value = temp_static_read_addr_channel_cycle_id[_d1];
    endfunction
    function void axi4_set_temp_static_read_addr_channel_cycle_id( input int _d1, input bit  _value );
        temp_static_read_addr_channel_cycle_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_read_addr_channel_cycle_user_data;
    function void axi4_get_temp_static_read_addr_channel_cycle_user_data( input int _d1, output bit  _value );
        _value = temp_static_read_addr_channel_cycle_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_read_addr_channel_cycle_user_data( input int _d1, input bit  _value );
        temp_static_read_addr_channel_cycle_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_RDATA_WIDTH) - 1):0]  temp_static_read_channel_cycle_data;
    function void axi4_get_temp_static_read_channel_cycle_data( input int _d1, output bit  _value );
        _value = temp_static_read_channel_cycle_data[_d1];
    endfunction
    function void axi4_set_temp_static_read_channel_cycle_data( input int _d1, input bit  _value );
        temp_static_read_channel_cycle_data[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_read_channel_cycle_id;
    function void axi4_get_temp_static_read_channel_cycle_id( input int _d1, output bit  _value );
        _value = temp_static_read_channel_cycle_id[_d1];
    endfunction
    function void axi4_set_temp_static_read_channel_cycle_id( input int _d1, input bit  _value );
        temp_static_read_channel_cycle_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_read_channel_cycle_user_data;
    function void axi4_get_temp_static_read_channel_cycle_user_data( input int _d1, output bit  _value );
        _value = temp_static_read_channel_cycle_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_read_channel_cycle_user_data( input int _d1, input bit  _value );
        temp_static_read_channel_cycle_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_ADDRESS_WIDTH) - 1):0]  temp_static_write_addr_channel_cycle_addr;
    function void axi4_get_temp_static_write_addr_channel_cycle_addr( input int _d1, output bit  _value );
        _value = temp_static_write_addr_channel_cycle_addr[_d1];
    endfunction
    function void axi4_set_temp_static_write_addr_channel_cycle_addr( input int _d1, input bit  _value );
        temp_static_write_addr_channel_cycle_addr[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_write_addr_channel_cycle_id;
    function void axi4_get_temp_static_write_addr_channel_cycle_id( input int _d1, output bit  _value );
        _value = temp_static_write_addr_channel_cycle_id[_d1];
    endfunction
    function void axi4_set_temp_static_write_addr_channel_cycle_id( input int _d1, input bit  _value );
        temp_static_write_addr_channel_cycle_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_write_addr_channel_cycle_user_data;
    function void axi4_get_temp_static_write_addr_channel_cycle_user_data( input int _d1, output bit  _value );
        _value = temp_static_write_addr_channel_cycle_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_write_addr_channel_cycle_user_data( input int _d1, input bit  _value );
        temp_static_write_addr_channel_cycle_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_WDATA_WIDTH) - 1):0]  temp_static_write_channel_cycle_data;
    function void axi4_get_temp_static_write_channel_cycle_data( input int _d1, output bit  _value );
        _value = temp_static_write_channel_cycle_data[_d1];
    endfunction
    function void axi4_set_temp_static_write_channel_cycle_data( input int _d1, input bit  _value );
        temp_static_write_channel_cycle_data[_d1] = _value;
    endfunction
    bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  temp_static_write_channel_cycle_strb;
    function void axi4_get_temp_static_write_channel_cycle_strb( input int _d1, output bit  _value );
        _value = temp_static_write_channel_cycle_strb[_d1];
    endfunction
    function void axi4_set_temp_static_write_channel_cycle_strb( input int _d1, input bit  _value );
        temp_static_write_channel_cycle_strb[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_write_channel_cycle_user_data;
    function void axi4_get_temp_static_write_channel_cycle_user_data( input int _d1, output bit  _value );
        _value = temp_static_write_channel_cycle_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_write_channel_cycle_user_data( input int _d1, input bit  _value );
        temp_static_write_channel_cycle_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_write_resp_channel_cycle_id;
    function void axi4_get_temp_static_write_resp_channel_cycle_id( input int _d1, output bit  _value );
        _value = temp_static_write_resp_channel_cycle_id[_d1];
    endfunction
    function void axi4_set_temp_static_write_resp_channel_cycle_id( input int _d1, input bit  _value );
        temp_static_write_resp_channel_cycle_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_write_resp_channel_cycle_user_data;
    function void axi4_get_temp_static_write_resp_channel_cycle_user_data( input int _d1, output bit  _value );
        _value = temp_static_write_resp_channel_cycle_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_write_resp_channel_cycle_user_data( input int _d1, input bit  _value );
        temp_static_write_resp_channel_cycle_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_unexpected_write_response_id;
    function void axi4_get_temp_static_unexpected_write_response_id( input int _d1, output bit  _value );
        _value = temp_static_unexpected_write_response_id[_d1];
    endfunction
    function void axi4_set_temp_static_unexpected_write_response_id( input int _d1, input bit  _value );
        temp_static_unexpected_write_response_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_unexpected_write_response_resp_user_data;
    function void axi4_get_temp_static_unexpected_write_response_resp_user_data( input int _d1, output bit  _value );
        _value = temp_static_unexpected_write_response_resp_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_unexpected_write_response_resp_user_data( input int _d1, input bit  _value );
        temp_static_unexpected_write_response_resp_user_data[_d1] = _value;
    endfunction
    bit [((AXI4_RDATA_WIDTH) - 1):0]  temp_static_unexpected_read_response_data;
    function void axi4_get_temp_static_unexpected_read_response_data( input int _d1, output bit  _value );
        _value = temp_static_unexpected_read_response_data[_d1];
    endfunction
    function void axi4_set_temp_static_unexpected_read_response_data( input int _d1, input bit  _value );
        temp_static_unexpected_read_response_data[_d1] = _value;
    endfunction
    bit [((AXI4_ID_WIDTH) - 1):0]  temp_static_unexpected_read_response_id;
    function void axi4_get_temp_static_unexpected_read_response_id( input int _d1, output bit  _value );
        _value = temp_static_unexpected_read_response_id[_d1];
    endfunction
    function void axi4_set_temp_static_unexpected_read_response_id( input int _d1, input bit  _value );
        temp_static_unexpected_read_response_id[_d1] = _value;
    endfunction
    bit [((AXI4_USER_WIDTH) - 1):0]  temp_static_unexpected_read_response_user_data;
    function void axi4_get_temp_static_unexpected_read_response_user_data( input int _d1, output bit  _value );
        _value = temp_static_unexpected_read_response_user_data[_d1];
    endfunction
    function void axi4_set_temp_static_unexpected_read_response_user_data( input int _d1, input bit  _value );
        temp_static_unexpected_read_response_user_data[_d1] = _value;
    endfunction
    task automatic do_dvc_activate_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref axi4_rw_e read_or_write,
        ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi4_prot_e prot,
        ref bit [3:0] region,
        ref axi4_size_e size,
        ref axi4_burst_e burst,
        ref axi4_lock_e lock,
        ref axi4_cache_e cache,
        ref bit [3:0] qos,
        ref bit [((AXI4_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] burst_length,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        ref int address_valid_delay,
        ref int data_valid_delay[],
        ref int write_response_valid_delay,
        ref int address_ready_delay,
        ref int data_ready_delay[],
        ref int write_response_ready_delay,
        ref bit write_data_with_address,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0
    );
        begin
            int _trans_id;
            int tmp_read_or_write;
            int tmp_prot;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_resp[];
            tmp_read_or_write = int'( read_or_write );
            tmp_prot = int'( prot );
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );
            begin
            tmp_resp = new [resp.size()];
            for (int _i_1= 0; _i_1 < ( resp.size() ); _i_1++)
            begin
            tmp_resp[_i_1] = int'( resp[_i_1] );
            
            end
            end/* 1 */ 

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int wdata_user_data_DIMS0;
                automatic int resp_DIMS0;
                automatic int resp_user_data_DIMS0;
                automatic int data_valid_delay_DIMS0;
                automatic int data_ready_delay_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_rw_transaction_addr = addr;
                temp_static_rw_transaction_id = id;
                temp_static_rw_transaction_addr_user_data = addr_user_data;
                data_words_DIMS0 = data_words.size();
                temp_static_rw_transaction_data_words = data_words;
                write_strobes_DIMS0 = write_strobes.size();
                temp_static_rw_transaction_write_strobes = write_strobes;
                wdata_user_data_DIMS0 = wdata_user_data.size();
                temp_static_rw_transaction_wdata_user_data = wdata_user_data;
                resp_DIMS0 = resp.size();
                temp_static_rw_transaction_resp = tmp_resp;
                resp_user_data_DIMS0 = resp_user_data.size();
                temp_static_rw_transaction_resp_user_data = resp_user_data;
                data_valid_delay_DIMS0 = data_valid_delay.size();
                temp_static_rw_transaction_data_valid_delay = data_valid_delay;
                data_ready_delay_DIMS0 = data_ready_delay.size();
                temp_static_rw_transaction_data_ready_delay = data_ready_delay;
                write_data_beats_delay_DIMS0 = write_data_beats_delay.size();
                temp_static_rw_transaction_write_data_beats_delay = write_data_beats_delay;
                // Call function to provide sized params and ingoing unsized params sizes.
                // In addition gets back updated sizes of unsized params.
                axi4_rw_transaction_ActivatesActivatingActivate_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_read_or_write, tmp_prot, region, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, burst_length, data_words_DIMS0, write_strobes_DIMS0, wdata_user_data_DIMS0, resp_DIMS0, resp_user_data_DIMS0, address_valid_delay, data_valid_delay_DIMS0, write_response_valid_delay, address_ready_delay, data_ready_delay_DIMS0, write_response_ready_delay, write_data_with_address, write_address_to_data_delay, write_data_to_address_delay, write_data_beats_delay_DIMS0, _unit_id); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_write_strobes.delete();
                end
                if (wdata_user_data_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_wdata_user_data = new [wdata_user_data_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_wdata_user_data.delete();
                end
                if (resp_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_resp = new [resp_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_resp.delete();
                end
                if (resp_user_data_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_resp_user_data = new [resp_user_data_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_resp_user_data.delete();
                end
                if (data_valid_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_valid_delay = new [data_valid_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_valid_delay.delete();
                end
                if (data_ready_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_ready_delay = new [data_ready_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_ready_delay.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_write_data_beats_delay.delete();
                end
                // Call function to get the sized params
                axi4_rw_transaction_ActivatesActivatingActivate_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_read_or_write, tmp_prot, region, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, burst_length, address_valid_delay, write_response_valid_delay, address_ready_delay, write_response_ready_delay, write_data_with_address, write_address_to_data_delay, write_data_to_address_delay, _unit_id); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_rw_transaction_addr;
                id = temp_static_rw_transaction_id;
                addr_user_data = temp_static_rw_transaction_addr_user_data;
                data_words = temp_static_rw_transaction_data_words;
                temp_static_rw_transaction_data_words.delete();
                write_strobes = temp_static_rw_transaction_write_strobes;
                temp_static_rw_transaction_write_strobes.delete();
                wdata_user_data = temp_static_rw_transaction_wdata_user_data;
                temp_static_rw_transaction_wdata_user_data.delete();
                tmp_resp = temp_static_rw_transaction_resp;
                temp_static_rw_transaction_resp.delete();
                resp_user_data = temp_static_rw_transaction_resp_user_data;
                temp_static_rw_transaction_resp_user_data.delete();
                data_valid_delay = temp_static_rw_transaction_data_valid_delay;
                temp_static_rw_transaction_data_valid_delay.delete();
                data_ready_delay = temp_static_rw_transaction_data_ready_delay;
                temp_static_rw_transaction_data_ready_delay.delete();
                write_data_beats_delay = temp_static_rw_transaction_write_data_beats_delay;
                temp_static_rw_transaction_write_data_beats_delay.delete();
            end // Block to create unsized data arrays
            read_or_write = axi4_rw_e'( tmp_read_or_write );
            prot = axi4_prot_e'( tmp_prot );
            size = axi4_size_e'( tmp_size );
            burst = axi4_burst_e'( tmp_burst );
            lock = axi4_lock_e'( tmp_lock );
            cache = axi4_cache_e'( tmp_cache );
            begin
            resp = new [tmp_resp.size()];
            for (int _i_1= 0; _i_1 < ( tmp_resp.size() ); _i_1++)
            begin
            resp[_i_1] = axi4_response_e'( tmp_resp[_i_1] );
            
            end
            end/* 1 */ 
        end
    endtask

    task automatic do_dvc_get_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi4_rw_e read_or_write,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        output int address_valid_delay,
        ref int data_valid_delay[],
        output int write_response_valid_delay,
        output int address_ready_delay,
        ref int data_ready_delay[],
        output int write_response_ready_delay,
        output bit write_data_with_address,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_read_or_write;
            int tmp_prot;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_resp[];

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int wdata_user_data_DIMS0;
                automatic int resp_DIMS0;
                automatic int resp_user_data_DIMS0;
                automatic int data_valid_delay_DIMS0;
                automatic int data_ready_delay_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                // Call function to get unsized params sizes.
                axi4_rw_transaction_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, write_strobes_DIMS0, wdata_user_data_DIMS0, resp_DIMS0, resp_user_data_DIMS0, data_valid_delay_DIMS0, data_ready_delay_DIMS0, write_data_beats_delay_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_write_strobes.delete();
                end
                if (wdata_user_data_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_wdata_user_data = new [wdata_user_data_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_wdata_user_data.delete();
                end
                if (resp_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_resp = new [resp_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_resp.delete();
                end
                if (resp_user_data_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_resp_user_data = new [resp_user_data_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_resp_user_data.delete();
                end
                if (data_valid_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_valid_delay = new [data_valid_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_valid_delay.delete();
                end
                if (data_ready_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_data_ready_delay = new [data_ready_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_data_ready_delay.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_rw_transaction_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_rw_transaction_write_data_beats_delay.delete();
                end
                // Call function to get the sized params
                axi4_rw_transaction_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_read_or_write, tmp_prot, region, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, burst_length, address_valid_delay, write_response_valid_delay, address_ready_delay, write_response_ready_delay, write_data_with_address, write_address_to_data_delay, write_data_to_address_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_rw_transaction_addr;
                id = temp_static_rw_transaction_id;
                addr_user_data = temp_static_rw_transaction_addr_user_data;
                data_words = temp_static_rw_transaction_data_words;
                temp_static_rw_transaction_data_words.delete();
                write_strobes = temp_static_rw_transaction_write_strobes;
                temp_static_rw_transaction_write_strobes.delete();
                wdata_user_data = temp_static_rw_transaction_wdata_user_data;
                temp_static_rw_transaction_wdata_user_data.delete();
                tmp_resp = temp_static_rw_transaction_resp;
                temp_static_rw_transaction_resp.delete();
                resp_user_data = temp_static_rw_transaction_resp_user_data;
                temp_static_rw_transaction_resp_user_data.delete();
                data_valid_delay = temp_static_rw_transaction_data_valid_delay;
                temp_static_rw_transaction_data_valid_delay.delete();
                data_ready_delay = temp_static_rw_transaction_data_ready_delay;
                temp_static_rw_transaction_data_ready_delay.delete();
                write_data_beats_delay = temp_static_rw_transaction_write_data_beats_delay;
                temp_static_rw_transaction_write_data_beats_delay.delete();
            end // Block to create unsized data arrays
            read_or_write = axi4_rw_e'( tmp_read_or_write );
            prot = axi4_prot_e'( tmp_prot );
            size = axi4_size_e'( tmp_size );
            burst = axi4_burst_e'( tmp_burst );
            lock = axi4_lock_e'( tmp_lock );
            cache = axi4_cache_e'( tmp_cache );
            begin
            resp = new [tmp_resp.size()];
            for (int _i_1= 0; _i_1 < ( tmp_resp.size() ); _i_1++)
            begin
            resp[_i_1] = axi4_response_e'( tmp_resp[_i_1] );
            
            end
            end/* 1 */ 
        end
    endtask

    task automatic do_dvc_activate_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi4_prot_e prot,
        ref int rresp_delays[255:0],
        ref bit [3:0] region,
        ref axi4_size_e size,
        ref axi4_burst_e burst,
        ref axi4_lock_e lock,
        ref axi4_cache_e cache,
        ref bit [3:0] qos,
        ref bit [((AXI4_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] burst_length,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_RDATA_WIDTH) - 1):0] data_words [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int address_valid_delay,
        input int _unit_id = 0
    );
        begin
            int _trans_id;
            int tmp_prot;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_resp[];
            tmp_prot = int'( prot );
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );
            begin
            tmp_resp = new [resp.size()];
            for (int _i_1= 0; _i_1 < ( resp.size() ); _i_1++)
            begin
            tmp_resp[_i_1] = int'( resp[_i_1] );
            
            end
            end/* 1 */ 

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int resp_DIMS0;
                automatic int resp_user_data_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_read_addr = addr;
                temp_static_read_rresp_delays = rresp_delays;
                temp_static_read_id = id;
                temp_static_read_addr_user_data = addr_user_data;
                data_words_DIMS0 = data_words.size();
                temp_static_read_data_words = data_words;
                resp_DIMS0 = resp.size();
                temp_static_read_resp = tmp_resp;
                resp_user_data_DIMS0 = resp_user_data.size();
                temp_static_read_resp_user_data = resp_user_data;
                data_start_time_DIMS0 = data_start_time.size();
                temp_static_read_data_start_time = data_start_time;
                data_end_time_DIMS0 = data_end_time.size();
                temp_static_read_data_end_time = data_end_time;
                // Call function to provide sized params and ingoing unsized params sizes.
                // In addition gets back updated sizes of unsized params.
                axi4_read_ActivatesActivatingActivate_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_prot, region, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, burst_length, data_words_DIMS0, resp_DIMS0, resp_user_data_DIMS0, addr_start_time, addr_end_time, data_start_time_DIMS0, data_end_time_DIMS0, address_valid_delay, _unit_id); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_read_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_read_data_words.delete();
                end
                if (resp_DIMS0 != 0)
                begin
                    temp_static_read_resp = new [resp_DIMS0];
                end
                else
                begin
                    temp_static_read_resp.delete();
                end
                if (resp_user_data_DIMS0 != 0)
                begin
                    temp_static_read_resp_user_data = new [resp_user_data_DIMS0];
                end
                else
                begin
                    temp_static_read_resp_user_data.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_read_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_read_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_read_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_read_data_end_time.delete();
                end
                // Call function to get the sized params
                axi4_read_ActivatesActivatingActivate_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_prot, region, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, burst_length, addr_start_time, addr_end_time, address_valid_delay, _unit_id); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_read_addr;
                rresp_delays = temp_static_read_rresp_delays;
                id = temp_static_read_id;
                addr_user_data = temp_static_read_addr_user_data;
                data_words = temp_static_read_data_words;
                temp_static_read_data_words.delete();
                tmp_resp = temp_static_read_resp;
                temp_static_read_resp.delete();
                resp_user_data = temp_static_read_resp_user_data;
                temp_static_read_resp_user_data.delete();
                data_start_time = temp_static_read_data_start_time;
                temp_static_read_data_start_time.delete();
                data_end_time = temp_static_read_data_end_time;
                temp_static_read_data_end_time.delete();
            end // Block to create unsized data arrays
            prot = axi4_prot_e'( tmp_prot );
            size = axi4_size_e'( tmp_size );
            burst = axi4_burst_e'( tmp_burst );
            lock = axi4_lock_e'( tmp_lock );
            cache = axi4_cache_e'( tmp_cache );
            begin
            resp = new [tmp_resp.size()];
            for (int _i_1= 0; _i_1 < ( tmp_resp.size() ); _i_1++)
            begin
            resp[_i_1] = axi4_response_e'( tmp_resp[_i_1] );
            
            end
            end/* 1 */ 
        end
    endtask

    task automatic do_dvc_get_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        ref int rresp_delays[255:0],
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_RDATA_WIDTH) - 1):0] data_words [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output int address_valid_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_prot;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_resp[];

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int resp_DIMS0;
                automatic int resp_user_data_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                // Call function to get unsized params sizes.
                axi4_read_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, resp_DIMS0, resp_user_data_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_read_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_read_data_words.delete();
                end
                if (resp_DIMS0 != 0)
                begin
                    temp_static_read_resp = new [resp_DIMS0];
                end
                else
                begin
                    temp_static_read_resp.delete();
                end
                if (resp_user_data_DIMS0 != 0)
                begin
                    temp_static_read_resp_user_data = new [resp_user_data_DIMS0];
                end
                else
                begin
                    temp_static_read_resp_user_data.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_read_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_read_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_read_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_read_data_end_time.delete();
                end
                // Call function to get the sized params
                axi4_read_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_prot, region, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, burst_length, addr_start_time, addr_end_time, address_valid_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_read_addr;
                rresp_delays = temp_static_read_rresp_delays;
                id = temp_static_read_id;
                addr_user_data = temp_static_read_addr_user_data;
                data_words = temp_static_read_data_words;
                temp_static_read_data_words.delete();
                tmp_resp = temp_static_read_resp;
                temp_static_read_resp.delete();
                resp_user_data = temp_static_read_resp_user_data;
                temp_static_read_resp_user_data.delete();
                data_start_time = temp_static_read_data_start_time;
                temp_static_read_data_start_time.delete();
                data_end_time = temp_static_read_data_end_time;
                temp_static_read_data_end_time.delete();
            end // Block to create unsized data arrays
            prot = axi4_prot_e'( tmp_prot );
            size = axi4_size_e'( tmp_size );
            burst = axi4_burst_e'( tmp_burst );
            lock = axi4_lock_e'( tmp_lock );
            cache = axi4_cache_e'( tmp_cache );
            begin
            resp = new [tmp_resp.size()];
            for (int _i_1= 0; _i_1 < ( tmp_resp.size() ); _i_1++)
            begin
            resp[_i_1] = axi4_response_e'( tmp_resp[_i_1] );
            
            end
            end/* 1 */ 
        end
    endtask

    task automatic do_dvc_activate_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi4_prot_e prot,
        ref int bresp_delay,
        ref bit [3:0] region,
        ref axi4_size_e size,
        ref axi4_burst_e burst,
        ref axi4_lock_e lock,
        ref axi4_cache_e cache,
        ref bit [3:0] qos,
        ref bit [((AXI4_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] burst_length,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        ref axi4_response_e resp,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref longint wr_resp_start_time,
        ref longint wr_resp_end_time,
        ref int address_valid_delay,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0
    );
        begin
            int _trans_id;
            int tmp_prot;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_resp;
            tmp_prot = int'( prot );
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int wdata_user_data_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_addr = addr;
                temp_static_write_id = id;
                temp_static_write_addr_user_data = addr_user_data;
                data_words_DIMS0 = data_words.size();
                temp_static_write_data_words = data_words;
                write_strobes_DIMS0 = write_strobes.size();
                temp_static_write_write_strobes = write_strobes;
                wdata_user_data_DIMS0 = wdata_user_data.size();
                temp_static_write_wdata_user_data = wdata_user_data;
                temp_static_write_resp_user_data = resp_user_data;
                data_start_time_DIMS0 = data_start_time.size();
                temp_static_write_data_start_time = data_start_time;
                data_end_time_DIMS0 = data_end_time.size();
                temp_static_write_data_end_time = data_end_time;
                write_data_beats_delay_DIMS0 = write_data_beats_delay.size();
                temp_static_write_write_data_beats_delay = write_data_beats_delay;
                // Call function to provide sized params and ingoing unsized params sizes.
                // In addition gets back updated sizes of unsized params.
                axi4_write_ActivatesActivatingActivate_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_prot, bresp_delay, region, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, burst_length, data_words_DIMS0, write_strobes_DIMS0, wdata_user_data_DIMS0, tmp_resp, addr_start_time, addr_end_time, data_start_time_DIMS0, data_end_time_DIMS0, wr_resp_start_time, wr_resp_end_time, address_valid_delay, write_address_to_data_delay, write_data_to_address_delay, write_data_beats_delay_DIMS0, _unit_id); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_write_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_write_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_write_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_write_write_strobes.delete();
                end
                if (wdata_user_data_DIMS0 != 0)
                begin
                    temp_static_write_wdata_user_data = new [wdata_user_data_DIMS0];
                end
                else
                begin
                    temp_static_write_wdata_user_data.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_write_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_write_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_write_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_write_data_end_time.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_write_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_write_write_data_beats_delay.delete();
                end
                // Call function to get the sized params
                axi4_write_ActivatesActivatingActivate_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_prot, bresp_delay, region, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, burst_length, tmp_resp, addr_start_time, addr_end_time, wr_resp_start_time, wr_resp_end_time, address_valid_delay, write_address_to_data_delay, write_data_to_address_delay, _unit_id); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_write_addr;
                id = temp_static_write_id;
                addr_user_data = temp_static_write_addr_user_data;
                data_words = temp_static_write_data_words;
                temp_static_write_data_words.delete();
                write_strobes = temp_static_write_write_strobes;
                temp_static_write_write_strobes.delete();
                wdata_user_data = temp_static_write_wdata_user_data;
                temp_static_write_wdata_user_data.delete();
                resp_user_data = temp_static_write_resp_user_data;
                data_start_time = temp_static_write_data_start_time;
                temp_static_write_data_start_time.delete();
                data_end_time = temp_static_write_data_end_time;
                temp_static_write_data_end_time.delete();
                write_data_beats_delay = temp_static_write_write_data_beats_delay;
                temp_static_write_write_data_beats_delay.delete();
            end // Block to create unsized data arrays
            prot = axi4_prot_e'( tmp_prot );
            size = axi4_size_e'( tmp_size );
            burst = axi4_burst_e'( tmp_burst );
            lock = axi4_lock_e'( tmp_lock );
            cache = axi4_cache_e'( tmp_cache );
            resp = axi4_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_get_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output int bresp_delay,
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        output axi4_response_e resp,
        output bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output longint wr_resp_start_time,
        output longint wr_resp_end_time,
        output int address_valid_delay,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_prot;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int wdata_user_data_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                // Call function to get unsized params sizes.
                axi4_write_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, write_strobes_DIMS0, wdata_user_data_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, write_data_beats_delay_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_write_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_write_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_write_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_write_write_strobes.delete();
                end
                if (wdata_user_data_DIMS0 != 0)
                begin
                    temp_static_write_wdata_user_data = new [wdata_user_data_DIMS0];
                end
                else
                begin
                    temp_static_write_wdata_user_data.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_write_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_write_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_write_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_write_data_end_time.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_write_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_write_write_data_beats_delay.delete();
                end
                // Call function to get the sized params
                axi4_write_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_prot, bresp_delay, region, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, burst_length, tmp_resp, addr_start_time, addr_end_time, wr_resp_start_time, wr_resp_end_time, address_valid_delay, write_address_to_data_delay, write_data_to_address_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_write_addr;
                id = temp_static_write_id;
                addr_user_data = temp_static_write_addr_user_data;
                data_words = temp_static_write_data_words;
                temp_static_write_data_words.delete();
                write_strobes = temp_static_write_write_strobes;
                temp_static_write_write_strobes.delete();
                wdata_user_data = temp_static_write_wdata_user_data;
                temp_static_write_wdata_user_data.delete();
                resp_user_data = temp_static_write_resp_user_data;
                data_start_time = temp_static_write_data_start_time;
                temp_static_write_data_start_time.delete();
                data_end_time = temp_static_write_data_end_time;
                temp_static_write_data_end_time.delete();
                write_data_beats_delay = temp_static_write_write_data_beats_delay;
                temp_static_write_write_data_beats_delay.delete();
            end // Block to create unsized data arrays
            prot = axi4_prot_e'( tmp_prot );
            size = axi4_size_e'( tmp_size );
            burst = axi4_burst_e'( tmp_burst );
            lock = axi4_lock_e'( tmp_lock );
            cache = axi4_cache_e'( tmp_cache );
            resp = axi4_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int burst_length,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] user_data [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int write_data_beats_delay[],
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int user_data_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                data_words_DIMS0 = data_words.size();
                temp_static_write_data_burst_data_words = data_words;
                write_strobes_DIMS0 = write_strobes.size();
                temp_static_write_data_burst_write_strobes = write_strobes;
                user_data_DIMS0 = user_data.size();
                temp_static_write_data_burst_user_data = user_data;
                data_start_time_DIMS0 = data_start_time.size();
                temp_static_write_data_burst_data_start_time = data_start_time;
                data_end_time_DIMS0 = data_end_time.size();
                temp_static_write_data_burst_data_end_time = data_end_time;
                write_data_beats_delay_DIMS0 = write_data_beats_delay.size();
                temp_static_write_data_burst_write_data_beats_delay = write_data_beats_delay;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_write_data_burst_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, burst_length, data_words_DIMS0, write_strobes_DIMS0, user_data_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, write_data_beats_delay_DIMS0, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
                temp_static_write_data_burst_data_words.delete();
                temp_static_write_data_burst_write_strobes.delete();
                temp_static_write_data_burst_user_data.delete();
                temp_static_write_data_burst_data_start_time.delete();
                temp_static_write_data_burst_data_end_time.delete();
                temp_static_write_data_burst_write_data_beats_delay.delete();
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output int burst_length,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] user_data [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int write_data_beats_delay[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                automatic int data_words_DIMS0;
                automatic int write_strobes_DIMS0;
                automatic int user_data_DIMS0;
                automatic int data_start_time_DIMS0;
                automatic int data_end_time_DIMS0;
                automatic int write_data_beats_delay_DIMS0;
                // Call function to get unsized params sizes.
                axi4_write_data_burst_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, data_words_DIMS0, write_strobes_DIMS0, user_data_DIMS0, data_start_time_DIMS0, data_end_time_DIMS0, write_data_beats_delay_DIMS0, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                if (data_words_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_data_words = new [data_words_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_data_words.delete();
                end
                if (write_strobes_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_write_strobes = new [write_strobes_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_write_strobes.delete();
                end
                if (user_data_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_user_data = new [user_data_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_user_data.delete();
                end
                if (data_start_time_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_data_start_time = new [data_start_time_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_data_start_time.delete();
                end
                if (data_end_time_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_data_end_time = new [data_end_time_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_data_end_time.delete();
                end
                if (write_data_beats_delay_DIMS0 != 0)
                begin
                    temp_static_write_data_burst_write_data_beats_delay = new [write_data_beats_delay_DIMS0];
                end
                else
                begin
                    temp_static_write_data_burst_write_data_beats_delay.delete();
                end
                // Call function to get the sized params
                axi4_write_data_burst_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, burst_length, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data_words = temp_static_write_data_burst_data_words;
                temp_static_write_data_burst_data_words.delete();
                write_strobes = temp_static_write_data_burst_write_strobes;
                temp_static_write_data_burst_write_strobes.delete();
                user_data = temp_static_write_data_burst_user_data;
                temp_static_write_data_burst_user_data.delete();
                data_start_time = temp_static_write_data_burst_data_start_time;
                temp_static_write_data_burst_data_start_time.delete();
                data_end_time = temp_static_write_data_burst_data_end_time;
                temp_static_write_data_burst_data_end_time.delete();
                write_data_beats_delay = temp_static_write_data_burst_write_data_beats_delay;
                temp_static_write_data_burst_write_data_beats_delay.delete();
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_put_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input axi4_prot_e prot,
        input bit [3:0] region,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input axi4_cache_e cache,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
        begin
            int tmp_prot;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            tmp_prot = int'( prot );
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_read_addr_channel_phase_addr = addr;
                temp_static_read_addr_channel_phase_id = id;
                temp_static_read_addr_channel_phase_addr_user = addr_user;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_read_addr_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, tmp_prot, region, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, address_valid_delay, address_ready_delay, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_prot;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_read_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_read_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_prot, region, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, address_valid_delay, address_ready_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_read_addr_channel_phase_addr;
                id = temp_static_read_addr_channel_phase_id;
                addr_user = temp_static_read_addr_channel_phase_addr_user;
            end // Block to create unsized data arrays
            prot = axi4_prot_e'( tmp_prot );
            size = axi4_size_e'( tmp_size );
            burst = axi4_burst_e'( tmp_burst );
            lock = axi4_lock_e'( tmp_lock );
            cache = axi4_cache_e'( tmp_cache );
        end
    endtask

    task automatic do_dvc_put_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_data_burst_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_data_burst_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_put_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int data_ready_delay,
        input int _unit_id = 0
    );
        begin
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_read_channel_phase_data = data;
                temp_static_read_channel_phase_id = id;
                temp_static_read_channel_phase_user_data = user_data;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_read_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, tmp_resp, last, data_ready_delay, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_read_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_read_channel_phase_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_resp, last, data_ready_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data = temp_static_read_channel_phase_data;
                id = temp_static_read_channel_phase_id;
                user_data = temp_static_read_channel_phase_user_data;
            end // Block to create unsized data arrays
            resp = axi4_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input axi4_prot_e prot,
        input bit [3:0] region,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input axi4_cache_e cache,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
        begin
            int tmp_prot;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;
            tmp_prot = int'( prot );
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_cache = int'( cache );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_addr_channel_phase_addr = addr;
                temp_static_write_addr_channel_phase_id = id;
                temp_static_write_addr_channel_phase_addr_user = addr_user;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_write_addr_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, tmp_prot, region, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, address_valid_delay, address_ready_delay, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_prot;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_cache;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_write_addr_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_write_addr_channel_phase_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_prot, region, burst_length, tmp_size, tmp_burst, tmp_lock, tmp_cache, qos, address_valid_delay, address_ready_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_write_addr_channel_phase_addr;
                id = temp_static_write_addr_channel_phase_id;
                addr_user = temp_static_write_addr_channel_phase_addr_user;
            end // Block to create unsized data arrays
            prot = axi4_prot_e'( tmp_prot );
            size = axi4_size_e'( tmp_size );
            burst = axi4_burst_e'( tmp_burst );
            lock = axi4_lock_e'( tmp_lock );
            cache = axi4_cache_e'( tmp_cache );
        end
    endtask

    task automatic do_dvc_put_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        input bit last,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int data_ready_delay,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_channel_phase_data = data;
                temp_static_write_channel_phase_write_strobes = write_strobes;
                temp_static_write_channel_phase_user_data = user_data;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_write_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, last, data_ready_delay, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        output bit last,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_write_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_write_channel_phase_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, last, data_ready_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data = temp_static_write_channel_phase_data;
                write_strobes = temp_static_write_channel_phase_write_strobes;
                user_data = temp_static_write_channel_phase_user_data;
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_put_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi4_response_e resp,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int write_response_ready_delay,
        input int _unit_id = 0
    );
        begin
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_resp_channel_phase_id = id;
                temp_static_write_resp_channel_phase_user_data = user_data;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_write_resp_channel_phase_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, tmp_resp, write_response_ready_delay, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi4_response_e resp,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int write_response_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_write_resp_channel_phase_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_write_resp_channel_phase_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_resp, write_response_ready_delay, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                id = temp_static_write_resp_channel_phase_id;
                user_data = temp_static_write_resp_channel_phase_user_data;
            end // Block to create unsized data arrays
            resp = axi4_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] region,
        input axi4_cache_e cache,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input axi4_prot_e prot,
        input int _unit_id = 0
    );
        begin
            int tmp_cache;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_prot;
            tmp_cache = int'( cache );
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_prot = int'( prot );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_read_addr_channel_cycle_addr = addr;
                temp_static_read_addr_channel_cycle_id = id;
                temp_static_read_addr_channel_cycle_user_data = user_data;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_read_addr_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, region, tmp_cache, burst_length, tmp_size, tmp_burst, tmp_lock, qos, tmp_prot, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] region,
        output axi4_cache_e cache,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output axi4_prot_e prot,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_cache;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_prot;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_read_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_read_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, region, tmp_cache, burst_length, tmp_size, tmp_burst, tmp_lock, qos, tmp_prot, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_read_addr_channel_cycle_addr;
                id = temp_static_read_addr_channel_cycle_id;
                user_data = temp_static_read_addr_channel_cycle_user_data;
            end // Block to create unsized data arrays
            cache = axi4_cache_e'( tmp_cache );
            size = axi4_size_e'( tmp_size );
            burst = axi4_burst_e'( tmp_burst );
            lock = axi4_lock_e'( tmp_lock );
            prot = axi4_prot_e'( tmp_prot );
        end
    endtask

    task automatic do_dvc_put_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_addr_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_put_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
        begin
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_read_channel_cycle_data = data;
                temp_static_read_channel_cycle_id = id;
                temp_static_read_channel_cycle_user_data = user_data;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_read_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, tmp_resp, last, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_read_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_read_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_resp, last, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data = temp_static_read_channel_cycle_data;
                id = temp_static_read_channel_cycle_id;
                user_data = temp_static_read_channel_cycle_user_data;
            end // Block to create unsized data arrays
            resp = axi4_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_read_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_put_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] region,
        input axi4_cache_e cache,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input axi4_prot_e prot,
        input int _unit_id = 0
    );
        begin
            int tmp_cache;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_prot;
            tmp_cache = int'( cache );
            tmp_size = int'( size );
            tmp_burst = int'( burst );
            tmp_lock = int'( lock );
            tmp_prot = int'( prot );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_addr_channel_cycle_addr = addr;
                temp_static_write_addr_channel_cycle_id = id;
                temp_static_write_addr_channel_cycle_user_data = user_data;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_write_addr_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, region, tmp_cache, burst_length, tmp_size, tmp_burst, tmp_lock, qos, tmp_prot, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] region,
        output axi4_cache_e cache,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output axi4_prot_e prot,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_cache;
            int tmp_size;
            int tmp_burst;
            int tmp_lock;
            int tmp_prot;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_write_addr_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_write_addr_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, region, tmp_cache, burst_length, tmp_size, tmp_burst, tmp_lock, qos, tmp_prot, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                addr = temp_static_write_addr_channel_cycle_addr;
                id = temp_static_write_addr_channel_cycle_id;
                user_data = temp_static_write_addr_channel_cycle_user_data;
            end // Block to create unsized data arrays
            cache = axi4_cache_e'( tmp_cache );
            size = axi4_size_e'( tmp_size );
            burst = axi4_burst_e'( tmp_burst );
            lock = axi4_lock_e'( tmp_lock );
            prot = axi4_prot_e'( tmp_prot );
        end
    endtask

    task automatic do_dvc_put_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_addr_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_addr_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_put_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  strb,
        input bit last,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_channel_cycle_data = data;
                temp_static_write_channel_cycle_strb = strb;
                temp_static_write_channel_cycle_user_data = user_data;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_write_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, last, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  strb,
        output bit last,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_write_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_write_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, last, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data = temp_static_write_channel_cycle_data;
                strb = temp_static_write_channel_cycle_strb;
                user_data = temp_static_write_channel_cycle_user_data;
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_put_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_put_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi4_response_e resp,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
        begin
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_write_resp_channel_cycle_id = id;
                temp_static_write_resp_channel_cycle_user_data = user_data;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_write_resp_channel_cycle_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, tmp_resp, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi4_response_e resp,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_write_resp_channel_cycle_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_write_resp_channel_cycle_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_resp, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                id = temp_static_write_resp_channel_cycle_id;
                user_data = temp_static_write_resp_channel_cycle_user_data;
            end // Block to create unsized data arrays
            resp = axi4_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_resp_channel_ready_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_get_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin

            wait(_interface_ref != 0);

            // the real code .....
            // Call function to set/get the params, all are of known size
            axi4_write_resp_channel_ready_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, ready, _unit_id, _using); // DPI call to imported task
        end
    endtask

    task automatic do_dvc_put_unexpected_write_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input axi4_response_e resp,
        input bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        input int _unit_id = 0
    );
        begin
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_unexpected_write_response_id = id;
                temp_static_unexpected_write_response_resp_user_data = resp_user_data;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_unexpected_write_response_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, tmp_resp, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_unexpected_write_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output axi4_response_e resp,
        output bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_unexpected_write_response_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_unexpected_write_response_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_resp, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                id = temp_static_unexpected_write_response_id;
                resp_user_data = temp_static_unexpected_write_response_resp_user_data;
            end // Block to create unsized data arrays
            resp = axi4_response_e'( tmp_resp );
        end
    endtask

    task automatic do_dvc_put_unexpected_read_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
        begin
            int tmp_resp;
            tmp_resp = int'( resp );

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Pass to CY the size of each open dimension (assumes rectangular arrays)
                // In addition copy any unsized or flexibly sized parameters to a related static variable which will be accessed element by element from the C
                temp_static_unexpected_read_response_data = data;
                temp_static_unexpected_read_response_id = id;
                temp_static_unexpected_read_response_user_data = user_data;
                // Call function to provide sized params and ingoing unsized params sizes.
                axi4_unexpected_read_response_SendSendingSent_SystemVerilog(_comms_semantic,_as_end, tmp_resp, last, _unit_id); // DPI call to imported task
                // Delete the storage allocated for the static variable(s)
            end // Block to create unsized data arrays
        end
    endtask

    task automatic do_dvc_get_unexpected_read_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        begin
            int _trans_id;
            int tmp_resp;

            wait(_interface_ref != 0);

            // the real code .....
            // Create an array to hold the unsized dims for each param (..._DIMS)
            begin // Block to create unsized data arrays
                // Call function to get unsized params sizes.
                axi4_unexpected_read_response_ReceivedReceivingReceive_SystemVerilog(_comms_semantic,_as_end, _trans_id, _unit_id, _using); // DPI call to imported task
                // Create each unsized param
                // Call function to get the sized params
                axi4_unexpected_read_response_ReceivedReceivingReceive_open_SystemVerilog(_comms_semantic,_as_end, _trans_id, tmp_resp, last, _unit_id, _using); // DPI call to imported task
                // Copy unsized data from static variable(s) which has/have been set element by element from the C++
                // In addition delete the storage allocated for the static variable(s)
                data = temp_static_unexpected_read_response_data;
                id = temp_static_unexpected_read_response_id;
                user_data = temp_static_unexpected_read_response_user_data;
            end // Block to create unsized data arrays
            resp = axi4_response_e'( tmp_resp );
        end
    endtask

    //-------------------------------------------------------------------------------------
    // Task which blocks and outputs an error if the interface has not initialized properly
    //-------------------------------------------------------------------------------------

    task _initialized();
        if (_interface_ref == 0)
        begin
            $display("Error: %m - Questa Verification IP failed to initialise. Please check questa_mvc.log for details");
            wait(_interface_ref!=0);
        end
    endtask

    //-------------------------------------------------------------------------------------
    // Function to get interface handle (internal use only)
    //-------------------------------------------------------------------------------------

    function longint _get_interface_handle();
        _get_interface_handle = axi4_get_interface_handle();
    endfunction

//------------------------------------------------------------------------------
//
// Class which implements interface defined by axi4_interface_class
//
//------------------------------------------------------------------------------
class axi4_implementation_class #(int AXI4_ADDRESS_WIDTH = 64, int AXI4_RDATA_WIDTH = 1024, int AXI4_WDATA_WIDTH = 1024, int AXI4_ID_WIDTH = 18, int AXI4_USER_WIDTH = 8, int AXI4_REGION_MAP_SIZE = 16)
    extends axi4_interface_class #(AXI4_ADDRESS_WIDTH, AXI4_RDATA_WIDTH, AXI4_WDATA_WIDTH, AXI4_ID_WIDTH, AXI4_USER_WIDTH, AXI4_REGION_MAP_SIZE);

    //------------------------------------------------------------------------------
    // Tasks to wait for a number of specified edges on a wire
    //------------------------------------------------------------------------------
    task automatic wait_for_ACLK( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ACLK( which_edge, count );
    endtask

    task automatic wait_for_ARESETn( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARESETn( which_edge, count );
    endtask

    task automatic wait_for_AWVALID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWVALID( which_edge, count );
    endtask

    task automatic wait_for_AWADDR( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWADDR( which_edge, count );
    endtask

    task automatic wait_for_AWADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWADDR_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWPROT( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWPROT( which_edge, count );
    endtask

    task automatic wait_for_AWPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWPROT_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWREGION( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWREGION( which_edge, count );
    endtask

    task automatic wait_for_AWREGION_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWREGION_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWLEN( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWLEN( which_edge, count );
    endtask

    task automatic wait_for_AWLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWLEN_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWSIZE( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWSIZE( which_edge, count );
    endtask

    task automatic wait_for_AWSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWSIZE_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWBURST( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWBURST( which_edge, count );
    endtask

    task automatic wait_for_AWBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWBURST_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWLOCK( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWLOCK( which_edge, count );
    endtask

    task automatic wait_for_AWCACHE( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWCACHE( which_edge, count );
    endtask

    task automatic wait_for_AWCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWCACHE_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWQOS( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWQOS( which_edge, count );
    endtask

    task automatic wait_for_AWQOS_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWQOS_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWID( which_edge, count );
    endtask

    task automatic wait_for_AWID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWID_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWUSER( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWUSER( which_edge, count );
    endtask

    task automatic wait_for_AWUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWUSER_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_AWREADY( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_AWREADY( which_edge, count );
    endtask

    task automatic wait_for_ARVALID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARVALID( which_edge, count );
    endtask

    task automatic wait_for_ARADDR( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARADDR( which_edge, count );
    endtask

    task automatic wait_for_ARADDR_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARADDR_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARPROT( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARPROT( which_edge, count );
    endtask

    task automatic wait_for_ARPROT_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARPROT_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARREGION( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARREGION( which_edge, count );
    endtask

    task automatic wait_for_ARREGION_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARREGION_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARLEN( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARLEN( which_edge, count );
    endtask

    task automatic wait_for_ARLEN_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARLEN_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARSIZE( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARSIZE( which_edge, count );
    endtask

    task automatic wait_for_ARSIZE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARSIZE_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARBURST( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARBURST( which_edge, count );
    endtask

    task automatic wait_for_ARBURST_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARBURST_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARLOCK( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARLOCK( which_edge, count );
    endtask

    task automatic wait_for_ARCACHE( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARCACHE( which_edge, count );
    endtask

    task automatic wait_for_ARCACHE_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARCACHE_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARQOS( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARQOS( which_edge, count );
    endtask

    task automatic wait_for_ARQOS_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARQOS_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARID( which_edge, count );
    endtask

    task automatic wait_for_ARID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARID_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARUSER( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARUSER( which_edge, count );
    endtask

    task automatic wait_for_ARUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARUSER_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_ARREADY( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_ARREADY( which_edge, count );
    endtask

    task automatic wait_for_RVALID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RVALID( which_edge, count );
    endtask

    task automatic wait_for_RDATA( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RDATA( which_edge, count );
    endtask

    task automatic wait_for_RDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RDATA_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_RRESP( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RRESP( which_edge, count );
    endtask

    task automatic wait_for_RRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RRESP_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_RLAST( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RLAST( which_edge, count );
    endtask

    task automatic wait_for_RID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RID( which_edge, count );
    endtask

    task automatic wait_for_RID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RID_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_RUSER( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RUSER( which_edge, count );
    endtask

    task automatic wait_for_RUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RUSER_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_RREADY( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_RREADY( which_edge, count );
    endtask

    task automatic wait_for_WVALID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WVALID( which_edge, count );
    endtask

    task automatic wait_for_WDATA( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WDATA( which_edge, count );
    endtask

    task automatic wait_for_WDATA_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WDATA_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_WSTRB( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WSTRB( which_edge, count );
    endtask

    task automatic wait_for_WSTRB_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WSTRB_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_WLAST( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WLAST( which_edge, count );
    endtask

    task automatic wait_for_WUSER( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WUSER( which_edge, count );
    endtask

    task automatic wait_for_WUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WUSER_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_WREADY( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_WREADY( which_edge, count );
    endtask

    task automatic wait_for_BVALID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BVALID( which_edge, count );
    endtask

    task automatic wait_for_BRESP( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BRESP( which_edge, count );
    endtask

    task automatic wait_for_BRESP_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BRESP_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_BID( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BID( which_edge, count );
    endtask

    task automatic wait_for_BID_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BID_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_BUSER( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BUSER( which_edge, count );
    endtask

    task automatic wait_for_BUSER_index1( input int _this_dot_1, input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BUSER_index1( _this_dot_1, which_edge, count );
    endtask

    task automatic wait_for_BREADY( input questa_mvc_edge which_edge, input int count = 1 );
        do_wait_for_BREADY( which_edge, count );
    endtask


    //------------------------------------------------------------------------------
    // Tasks/functions to set/get wires
    //------------------------------------------------------------------------------
    task automatic set_ACLK( logic ACLK_param = 'z, bit non_blocking = 1'b0 );
        do_set_ACLK( ACLK_param, non_blocking );
    endtask

    function automatic logic get_ACLK(  );
        return do_get_ACLK(  );
    endfunction


    task automatic set_ARESETn( logic ARESETn_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARESETn( ARESETn_param, non_blocking );
    endtask

    function automatic logic get_ARESETn(  );
        return do_get_ARESETn(  );
    endfunction


    task automatic set_AWVALID( logic AWVALID_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWVALID( AWVALID_param, non_blocking );
    endtask

    function automatic logic get_AWVALID(  );
        return do_get_AWVALID(  );
    endfunction


    task automatic set_AWADDR( logic [((AXI4_ADDRESS_WIDTH) - 1):0]  AWADDR_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWADDR( AWADDR_param, non_blocking );
    endtask

    task automatic set_AWADDR_index1( int _this_dot_1, logic  AWADDR_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWADDR_index1( _this_dot_1, AWADDR_param, non_blocking );
    endtask

    function automatic logic [((AXI4_ADDRESS_WIDTH) - 1):0]   get_AWADDR(  );
        return do_get_AWADDR(  );
    endfunction

    function automatic logic   get_AWADDR_index1( int _this_dot_1 );
        return do_get_AWADDR_index1( _this_dot_1 );
    endfunction


    task automatic set_AWPROT( logic [2:0] AWPROT_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWPROT( AWPROT_param, non_blocking );
    endtask

    task automatic set_AWPROT_index1( int _this_dot_1, logic  AWPROT_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWPROT_index1( _this_dot_1, AWPROT_param, non_blocking );
    endtask

    function automatic logic [2:0]  get_AWPROT(  );
        return do_get_AWPROT(  );
    endfunction

    function automatic logic   get_AWPROT_index1( int _this_dot_1 );
        return do_get_AWPROT_index1( _this_dot_1 );
    endfunction


    task automatic set_AWREGION( logic [3:0] AWREGION_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWREGION( AWREGION_param, non_blocking );
    endtask

    task automatic set_AWREGION_index1( int _this_dot_1, logic  AWREGION_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWREGION_index1( _this_dot_1, AWREGION_param, non_blocking );
    endtask

    function automatic logic [3:0]  get_AWREGION(  );
        return do_get_AWREGION(  );
    endfunction

    function automatic logic   get_AWREGION_index1( int _this_dot_1 );
        return do_get_AWREGION_index1( _this_dot_1 );
    endfunction


    task automatic set_AWLEN( logic [7:0] AWLEN_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWLEN( AWLEN_param, non_blocking );
    endtask

    task automatic set_AWLEN_index1( int _this_dot_1, logic  AWLEN_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWLEN_index1( _this_dot_1, AWLEN_param, non_blocking );
    endtask

    function automatic logic [7:0]  get_AWLEN(  );
        return do_get_AWLEN(  );
    endfunction

    function automatic logic   get_AWLEN_index1( int _this_dot_1 );
        return do_get_AWLEN_index1( _this_dot_1 );
    endfunction


    task automatic set_AWSIZE( logic [2:0] AWSIZE_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWSIZE( AWSIZE_param, non_blocking );
    endtask

    task automatic set_AWSIZE_index1( int _this_dot_1, logic  AWSIZE_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWSIZE_index1( _this_dot_1, AWSIZE_param, non_blocking );
    endtask

    function automatic logic [2:0]  get_AWSIZE(  );
        return do_get_AWSIZE(  );
    endfunction

    function automatic logic   get_AWSIZE_index1( int _this_dot_1 );
        return do_get_AWSIZE_index1( _this_dot_1 );
    endfunction


    task automatic set_AWBURST( logic [1:0] AWBURST_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWBURST( AWBURST_param, non_blocking );
    endtask

    task automatic set_AWBURST_index1( int _this_dot_1, logic  AWBURST_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWBURST_index1( _this_dot_1, AWBURST_param, non_blocking );
    endtask

    function automatic logic [1:0]  get_AWBURST(  );
        return do_get_AWBURST(  );
    endfunction

    function automatic logic   get_AWBURST_index1( int _this_dot_1 );
        return do_get_AWBURST_index1( _this_dot_1 );
    endfunction


    task automatic set_AWLOCK( logic AWLOCK_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWLOCK( AWLOCK_param, non_blocking );
    endtask

    function automatic logic get_AWLOCK(  );
        return do_get_AWLOCK(  );
    endfunction


    task automatic set_AWCACHE( logic [3:0] AWCACHE_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWCACHE( AWCACHE_param, non_blocking );
    endtask

    task automatic set_AWCACHE_index1( int _this_dot_1, logic  AWCACHE_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWCACHE_index1( _this_dot_1, AWCACHE_param, non_blocking );
    endtask

    function automatic logic [3:0]  get_AWCACHE(  );
        return do_get_AWCACHE(  );
    endfunction

    function automatic logic   get_AWCACHE_index1( int _this_dot_1 );
        return do_get_AWCACHE_index1( _this_dot_1 );
    endfunction


    task automatic set_AWQOS( logic [3:0] AWQOS_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWQOS( AWQOS_param, non_blocking );
    endtask

    task automatic set_AWQOS_index1( int _this_dot_1, logic  AWQOS_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWQOS_index1( _this_dot_1, AWQOS_param, non_blocking );
    endtask

    function automatic logic [3:0]  get_AWQOS(  );
        return do_get_AWQOS(  );
    endfunction

    function automatic logic   get_AWQOS_index1( int _this_dot_1 );
        return do_get_AWQOS_index1( _this_dot_1 );
    endfunction


    task automatic set_AWID( logic [((AXI4_ID_WIDTH) - 1):0]  AWID_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWID( AWID_param, non_blocking );
    endtask

    task automatic set_AWID_index1( int _this_dot_1, logic  AWID_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWID_index1( _this_dot_1, AWID_param, non_blocking );
    endtask

    function automatic logic [((AXI4_ID_WIDTH) - 1):0]   get_AWID(  );
        return do_get_AWID(  );
    endfunction

    function automatic logic   get_AWID_index1( int _this_dot_1 );
        return do_get_AWID_index1( _this_dot_1 );
    endfunction


    task automatic set_AWUSER( logic [((AXI4_USER_WIDTH) - 1):0]  AWUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWUSER( AWUSER_param, non_blocking );
    endtask

    task automatic set_AWUSER_index1( int _this_dot_1, logic  AWUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWUSER_index1( _this_dot_1, AWUSER_param, non_blocking );
    endtask

    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   get_AWUSER(  );
        return do_get_AWUSER(  );
    endfunction

    function automatic logic   get_AWUSER_index1( int _this_dot_1 );
        return do_get_AWUSER_index1( _this_dot_1 );
    endfunction


    task automatic set_AWREADY( logic AWREADY_param = 'z, bit non_blocking = 1'b0 );
        do_set_AWREADY( AWREADY_param, non_blocking );
    endtask

    function automatic logic get_AWREADY(  );
        return do_get_AWREADY(  );
    endfunction


    task automatic set_ARVALID( logic ARVALID_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARVALID( ARVALID_param, non_blocking );
    endtask

    function automatic logic get_ARVALID(  );
        return do_get_ARVALID(  );
    endfunction


    task automatic set_ARADDR( logic [((AXI4_ADDRESS_WIDTH) - 1):0]  ARADDR_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARADDR( ARADDR_param, non_blocking );
    endtask

    task automatic set_ARADDR_index1( int _this_dot_1, logic  ARADDR_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARADDR_index1( _this_dot_1, ARADDR_param, non_blocking );
    endtask

    function automatic logic [((AXI4_ADDRESS_WIDTH) - 1):0]   get_ARADDR(  );
        return do_get_ARADDR(  );
    endfunction

    function automatic logic   get_ARADDR_index1( int _this_dot_1 );
        return do_get_ARADDR_index1( _this_dot_1 );
    endfunction


    task automatic set_ARPROT( logic [2:0] ARPROT_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARPROT( ARPROT_param, non_blocking );
    endtask

    task automatic set_ARPROT_index1( int _this_dot_1, logic  ARPROT_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARPROT_index1( _this_dot_1, ARPROT_param, non_blocking );
    endtask

    function automatic logic [2:0]  get_ARPROT(  );
        return do_get_ARPROT(  );
    endfunction

    function automatic logic   get_ARPROT_index1( int _this_dot_1 );
        return do_get_ARPROT_index1( _this_dot_1 );
    endfunction


    task automatic set_ARREGION( logic [3:0] ARREGION_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARREGION( ARREGION_param, non_blocking );
    endtask

    task automatic set_ARREGION_index1( int _this_dot_1, logic  ARREGION_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARREGION_index1( _this_dot_1, ARREGION_param, non_blocking );
    endtask

    function automatic logic [3:0]  get_ARREGION(  );
        return do_get_ARREGION(  );
    endfunction

    function automatic logic   get_ARREGION_index1( int _this_dot_1 );
        return do_get_ARREGION_index1( _this_dot_1 );
    endfunction


    task automatic set_ARLEN( logic [7:0] ARLEN_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARLEN( ARLEN_param, non_blocking );
    endtask

    task automatic set_ARLEN_index1( int _this_dot_1, logic  ARLEN_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARLEN_index1( _this_dot_1, ARLEN_param, non_blocking );
    endtask

    function automatic logic [7:0]  get_ARLEN(  );
        return do_get_ARLEN(  );
    endfunction

    function automatic logic   get_ARLEN_index1( int _this_dot_1 );
        return do_get_ARLEN_index1( _this_dot_1 );
    endfunction


    task automatic set_ARSIZE( logic [2:0] ARSIZE_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARSIZE( ARSIZE_param, non_blocking );
    endtask

    task automatic set_ARSIZE_index1( int _this_dot_1, logic  ARSIZE_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARSIZE_index1( _this_dot_1, ARSIZE_param, non_blocking );
    endtask

    function automatic logic [2:0]  get_ARSIZE(  );
        return do_get_ARSIZE(  );
    endfunction

    function automatic logic   get_ARSIZE_index1( int _this_dot_1 );
        return do_get_ARSIZE_index1( _this_dot_1 );
    endfunction


    task automatic set_ARBURST( logic [1:0] ARBURST_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARBURST( ARBURST_param, non_blocking );
    endtask

    task automatic set_ARBURST_index1( int _this_dot_1, logic  ARBURST_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARBURST_index1( _this_dot_1, ARBURST_param, non_blocking );
    endtask

    function automatic logic [1:0]  get_ARBURST(  );
        return do_get_ARBURST(  );
    endfunction

    function automatic logic   get_ARBURST_index1( int _this_dot_1 );
        return do_get_ARBURST_index1( _this_dot_1 );
    endfunction


    task automatic set_ARLOCK( logic ARLOCK_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARLOCK( ARLOCK_param, non_blocking );
    endtask

    function automatic logic get_ARLOCK(  );
        return do_get_ARLOCK(  );
    endfunction


    task automatic set_ARCACHE( logic [3:0] ARCACHE_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARCACHE( ARCACHE_param, non_blocking );
    endtask

    task automatic set_ARCACHE_index1( int _this_dot_1, logic  ARCACHE_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARCACHE_index1( _this_dot_1, ARCACHE_param, non_blocking );
    endtask

    function automatic logic [3:0]  get_ARCACHE(  );
        return do_get_ARCACHE(  );
    endfunction

    function automatic logic   get_ARCACHE_index1( int _this_dot_1 );
        return do_get_ARCACHE_index1( _this_dot_1 );
    endfunction


    task automatic set_ARQOS( logic [3:0] ARQOS_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARQOS( ARQOS_param, non_blocking );
    endtask

    task automatic set_ARQOS_index1( int _this_dot_1, logic  ARQOS_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARQOS_index1( _this_dot_1, ARQOS_param, non_blocking );
    endtask

    function automatic logic [3:0]  get_ARQOS(  );
        return do_get_ARQOS(  );
    endfunction

    function automatic logic   get_ARQOS_index1( int _this_dot_1 );
        return do_get_ARQOS_index1( _this_dot_1 );
    endfunction


    task automatic set_ARID( logic [((AXI4_ID_WIDTH) - 1):0]  ARID_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARID( ARID_param, non_blocking );
    endtask

    task automatic set_ARID_index1( int _this_dot_1, logic  ARID_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARID_index1( _this_dot_1, ARID_param, non_blocking );
    endtask

    function automatic logic [((AXI4_ID_WIDTH) - 1):0]   get_ARID(  );
        return do_get_ARID(  );
    endfunction

    function automatic logic   get_ARID_index1( int _this_dot_1 );
        return do_get_ARID_index1( _this_dot_1 );
    endfunction


    task automatic set_ARUSER( logic [((AXI4_USER_WIDTH) - 1):0]  ARUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARUSER( ARUSER_param, non_blocking );
    endtask

    task automatic set_ARUSER_index1( int _this_dot_1, logic  ARUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARUSER_index1( _this_dot_1, ARUSER_param, non_blocking );
    endtask

    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   get_ARUSER(  );
        return do_get_ARUSER(  );
    endfunction

    function automatic logic   get_ARUSER_index1( int _this_dot_1 );
        return do_get_ARUSER_index1( _this_dot_1 );
    endfunction


    task automatic set_ARREADY( logic ARREADY_param = 'z, bit non_blocking = 1'b0 );
        do_set_ARREADY( ARREADY_param, non_blocking );
    endtask

    function automatic logic get_ARREADY(  );
        return do_get_ARREADY(  );
    endfunction


    task automatic set_RVALID( logic RVALID_param = 'z, bit non_blocking = 1'b0 );
        do_set_RVALID( RVALID_param, non_blocking );
    endtask

    function automatic logic get_RVALID(  );
        return do_get_RVALID(  );
    endfunction


    task automatic set_RDATA( logic [((AXI4_RDATA_WIDTH) - 1):0]  RDATA_param = 'z, bit non_blocking = 1'b0 );
        do_set_RDATA( RDATA_param, non_blocking );
    endtask

    task automatic set_RDATA_index1( int _this_dot_1, logic  RDATA_param = 'z, bit non_blocking = 1'b0 );
        do_set_RDATA_index1( _this_dot_1, RDATA_param, non_blocking );
    endtask

    function automatic logic [((AXI4_RDATA_WIDTH) - 1):0]   get_RDATA(  );
        return do_get_RDATA(  );
    endfunction

    function automatic logic   get_RDATA_index1( int _this_dot_1 );
        return do_get_RDATA_index1( _this_dot_1 );
    endfunction


    task automatic set_RRESP( logic [1:0] RRESP_param = 'z, bit non_blocking = 1'b0 );
        do_set_RRESP( RRESP_param, non_blocking );
    endtask

    task automatic set_RRESP_index1( int _this_dot_1, logic  RRESP_param = 'z, bit non_blocking = 1'b0 );
        do_set_RRESP_index1( _this_dot_1, RRESP_param, non_blocking );
    endtask

    function automatic logic [1:0]  get_RRESP(  );
        return do_get_RRESP(  );
    endfunction

    function automatic logic   get_RRESP_index1( int _this_dot_1 );
        return do_get_RRESP_index1( _this_dot_1 );
    endfunction


    task automatic set_RLAST( logic RLAST_param = 'z, bit non_blocking = 1'b0 );
        do_set_RLAST( RLAST_param, non_blocking );
    endtask

    function automatic logic get_RLAST(  );
        return do_get_RLAST(  );
    endfunction


    task automatic set_RID( logic [((AXI4_ID_WIDTH) - 1):0]  RID_param = 'z, bit non_blocking = 1'b0 );
        do_set_RID( RID_param, non_blocking );
    endtask

    task automatic set_RID_index1( int _this_dot_1, logic  RID_param = 'z, bit non_blocking = 1'b0 );
        do_set_RID_index1( _this_dot_1, RID_param, non_blocking );
    endtask

    function automatic logic [((AXI4_ID_WIDTH) - 1):0]   get_RID(  );
        return do_get_RID(  );
    endfunction

    function automatic logic   get_RID_index1( int _this_dot_1 );
        return do_get_RID_index1( _this_dot_1 );
    endfunction


    task automatic set_RUSER( logic [((AXI4_USER_WIDTH) - 1):0]  RUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_RUSER( RUSER_param, non_blocking );
    endtask

    task automatic set_RUSER_index1( int _this_dot_1, logic  RUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_RUSER_index1( _this_dot_1, RUSER_param, non_blocking );
    endtask

    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   get_RUSER(  );
        return do_get_RUSER(  );
    endfunction

    function automatic logic   get_RUSER_index1( int _this_dot_1 );
        return do_get_RUSER_index1( _this_dot_1 );
    endfunction


    task automatic set_RREADY( logic RREADY_param = 'z, bit non_blocking = 1'b0 );
        do_set_RREADY( RREADY_param, non_blocking );
    endtask

    function automatic logic get_RREADY(  );
        return do_get_RREADY(  );
    endfunction


    task automatic set_WVALID( logic WVALID_param = 'z, bit non_blocking = 1'b0 );
        do_set_WVALID( WVALID_param, non_blocking );
    endtask

    function automatic logic get_WVALID(  );
        return do_get_WVALID(  );
    endfunction


    task automatic set_WDATA( logic [((AXI4_WDATA_WIDTH) - 1):0]  WDATA_param = 'z, bit non_blocking = 1'b0 );
        do_set_WDATA( WDATA_param, non_blocking );
    endtask

    task automatic set_WDATA_index1( int _this_dot_1, logic  WDATA_param = 'z, bit non_blocking = 1'b0 );
        do_set_WDATA_index1( _this_dot_1, WDATA_param, non_blocking );
    endtask

    function automatic logic [((AXI4_WDATA_WIDTH) - 1):0]   get_WDATA(  );
        return do_get_WDATA(  );
    endfunction

    function automatic logic   get_WDATA_index1( int _this_dot_1 );
        return do_get_WDATA_index1( _this_dot_1 );
    endfunction


    task automatic set_WSTRB( logic [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  WSTRB_param = 'z, bit non_blocking = 1'b0 );
        do_set_WSTRB( WSTRB_param, non_blocking );
    endtask

    task automatic set_WSTRB_index1( int _this_dot_1, logic  WSTRB_param = 'z, bit non_blocking = 1'b0 );
        do_set_WSTRB_index1( _this_dot_1, WSTRB_param, non_blocking );
    endtask

    function automatic logic [(((AXI4_WDATA_WIDTH / 8)) - 1):0]   get_WSTRB(  );
        return do_get_WSTRB(  );
    endfunction

    function automatic logic   get_WSTRB_index1( int _this_dot_1 );
        return do_get_WSTRB_index1( _this_dot_1 );
    endfunction


    task automatic set_WLAST( logic WLAST_param = 'z, bit non_blocking = 1'b0 );
        do_set_WLAST( WLAST_param, non_blocking );
    endtask

    function automatic logic get_WLAST(  );
        return do_get_WLAST(  );
    endfunction


    task automatic set_WUSER( logic [((AXI4_USER_WIDTH) - 1):0]  WUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_WUSER( WUSER_param, non_blocking );
    endtask

    task automatic set_WUSER_index1( int _this_dot_1, logic  WUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_WUSER_index1( _this_dot_1, WUSER_param, non_blocking );
    endtask

    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   get_WUSER(  );
        return do_get_WUSER(  );
    endfunction

    function automatic logic   get_WUSER_index1( int _this_dot_1 );
        return do_get_WUSER_index1( _this_dot_1 );
    endfunction


    task automatic set_WREADY( logic WREADY_param = 'z, bit non_blocking = 1'b0 );
        do_set_WREADY( WREADY_param, non_blocking );
    endtask

    function automatic logic get_WREADY(  );
        return do_get_WREADY(  );
    endfunction


    task automatic set_BVALID( logic BVALID_param = 'z, bit non_blocking = 1'b0 );
        do_set_BVALID( BVALID_param, non_blocking );
    endtask

    function automatic logic get_BVALID(  );
        return do_get_BVALID(  );
    endfunction


    task automatic set_BRESP( logic [1:0] BRESP_param = 'z, bit non_blocking = 1'b0 );
        do_set_BRESP( BRESP_param, non_blocking );
    endtask

    task automatic set_BRESP_index1( int _this_dot_1, logic  BRESP_param = 'z, bit non_blocking = 1'b0 );
        do_set_BRESP_index1( _this_dot_1, BRESP_param, non_blocking );
    endtask

    function automatic logic [1:0]  get_BRESP(  );
        return do_get_BRESP(  );
    endfunction

    function automatic logic   get_BRESP_index1( int _this_dot_1 );
        return do_get_BRESP_index1( _this_dot_1 );
    endfunction


    task automatic set_BID( logic [((AXI4_ID_WIDTH) - 1):0]  BID_param = 'z, bit non_blocking = 1'b0 );
        do_set_BID( BID_param, non_blocking );
    endtask

    task automatic set_BID_index1( int _this_dot_1, logic  BID_param = 'z, bit non_blocking = 1'b0 );
        do_set_BID_index1( _this_dot_1, BID_param, non_blocking );
    endtask

    function automatic logic [((AXI4_ID_WIDTH) - 1):0]   get_BID(  );
        return do_get_BID(  );
    endfunction

    function automatic logic   get_BID_index1( int _this_dot_1 );
        return do_get_BID_index1( _this_dot_1 );
    endfunction


    task automatic set_BUSER( logic [((AXI4_USER_WIDTH) - 1):0]  BUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_BUSER( BUSER_param, non_blocking );
    endtask

    task automatic set_BUSER_index1( int _this_dot_1, logic  BUSER_param = 'z, bit non_blocking = 1'b0 );
        do_set_BUSER_index1( _this_dot_1, BUSER_param, non_blocking );
    endtask

    function automatic logic [((AXI4_USER_WIDTH) - 1):0]   get_BUSER(  );
        return do_get_BUSER(  );
    endfunction

    function automatic logic   get_BUSER_index1( int _this_dot_1 );
        return do_get_BUSER_index1( _this_dot_1 );
    endfunction


    task automatic set_BREADY( logic BREADY_param = 'z, bit non_blocking = 1'b0 );
        do_set_BREADY( BREADY_param, non_blocking );
    endtask

    function automatic logic get_BREADY(  );
        return do_get_BREADY(  );
    endfunction



    //------------------------------------------------------------------------------
    // Tasks to wait for a change to a global variable with read access
    //------------------------------------------------------------------------------
    task automatic wait_for_config_interface_type(  );
        do_wait_for_config_interface_type(  );
    endtask

    task automatic wait_for_config_clk_init_value(  );
        do_wait_for_config_clk_init_value(  );
    endtask

    task automatic wait_for_config_clk_phase_shift(  );
        do_wait_for_config_clk_phase_shift(  );
    endtask

    task automatic wait_for_config_clk_1st_time(  );
        do_wait_for_config_clk_1st_time(  );
    endtask

    task automatic wait_for_config_clk_2nd_time(  );
        do_wait_for_config_clk_2nd_time(  );
    endtask

    task automatic wait_for_config_setup_time(  );
        do_wait_for_config_setup_time(  );
    endtask

    task automatic wait_for_config_hold_time(  );
        do_wait_for_config_hold_time(  );
    endtask

    task automatic wait_for_config_burst_timeout_factor(  );
        do_wait_for_config_burst_timeout_factor(  );
    endtask

    task automatic wait_for_config_max_transaction_time_factor(  );
        do_wait_for_config_max_transaction_time_factor(  );
    endtask

    task automatic wait_for_config_write_ctrl_first_ratio(  );
        do_wait_for_config_write_ctrl_first_ratio(  );
    endtask

    task automatic wait_for_config_write_data_first_ratio(  );
        do_wait_for_config_write_data_first_ratio(  );
    endtask

    task automatic wait_for_config_reset_low_clocks(  );
        do_wait_for_config_reset_low_clocks(  );
    endtask

    task automatic wait_for_config_reset_hold_time(  );
        do_wait_for_config_reset_hold_time(  );
    endtask

    task automatic wait_for_config_enable_rlast(  );
        do_wait_for_config_enable_rlast(  );
    endtask

    task automatic wait_for_config_enable_slave_exclusive(  );
        do_wait_for_config_enable_slave_exclusive(  );
    endtask

    task automatic wait_for_config_enable_burst_reserved_value(  );
        do_wait_for_config_enable_burst_reserved_value(  );
    endtask

    task automatic wait_for_config_enable_cache_value(  );
        do_wait_for_config_enable_cache_value(  );
    endtask

    task automatic wait_for_config_enable_cache_value_index1( input int _this_dot_1 );
        do_wait_for_config_enable_cache_value_index1( _this_dot_1 );
    endtask

    task automatic wait_for_internal_dummy_variable(  );
        do_wait_for_internal_dummy_variable(  );
    endtask

    task automatic wait_for_config_axi4lite_interface(  );
        do_wait_for_config_axi4lite_interface(  );
    endtask

    task automatic wait_for_config_axi4lite_tr_id(  );
        do_wait_for_config_axi4lite_tr_id(  );
    endtask

    task automatic wait_for_config_axi4lite_tr_id_index1( input int _this_dot_1 );
        do_wait_for_config_axi4lite_tr_id_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_enable_all_assertions(  );
        do_wait_for_config_enable_all_assertions(  );
    endtask

    task automatic wait_for_config_enable_assertion(  );
        do_wait_for_config_enable_assertion(  );
    endtask

    task automatic wait_for_config_enable_assertion_index1( input int _this_dot_1 );
        do_wait_for_config_enable_assertion_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_enable_error(  );
        do_wait_for_config_enable_error(  );
    endtask

    task automatic wait_for_config_enable_error_index1( input int _this_dot_1 );
        do_wait_for_config_enable_error_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_max_latency_AWVALID_assertion_to_AWREADY(  );
        do_wait_for_config_max_latency_AWVALID_assertion_to_AWREADY(  );
    endtask

    task automatic wait_for_config_max_latency_ARVALID_assertion_to_ARREADY(  );
        do_wait_for_config_max_latency_ARVALID_assertion_to_ARREADY(  );
    endtask

    task automatic wait_for_config_max_latency_RVALID_assertion_to_RREADY(  );
        do_wait_for_config_max_latency_RVALID_assertion_to_RREADY(  );
    endtask

    task automatic wait_for_config_max_latency_BVALID_assertion_to_BREADY(  );
        do_wait_for_config_max_latency_BVALID_assertion_to_BREADY(  );
    endtask

    task automatic wait_for_config_max_latency_WVALID_assertion_to_WREADY(  );
        do_wait_for_config_max_latency_WVALID_assertion_to_WREADY(  );
    endtask

    task automatic wait_for_config_enable_qos(  );
        do_wait_for_config_enable_qos(  );
    endtask

    task automatic wait_for_config_enable_region_support(  );
        do_wait_for_config_enable_region_support(  );
    endtask

    task automatic wait_for_config_slave_regions(  );
        do_wait_for_config_slave_regions(  );
    endtask

    task automatic wait_for_config_region(  );
        do_wait_for_config_region(  );
    endtask

    task automatic wait_for_config_region_index1( input int _this_dot_1 );
        do_wait_for_config_region_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_region_index2( input int _this_dot_1, input int _this_dot_2 );
        do_wait_for_config_region_index2( _this_dot_1, _this_dot_2 );
    endtask

    task automatic wait_for_region_error_state(  );
        do_wait_for_region_error_state(  );
    endtask

    task automatic wait_for_region_map_lb(  );
        do_wait_for_region_map_lb(  );
    endtask

    task automatic wait_for_region_map_lb_index1( input int _this_dot_1 );
        do_wait_for_region_map_lb_index1( _this_dot_1 );
    endtask

    task automatic wait_for_region_map_ub(  );
        do_wait_for_region_map_ub(  );
    endtask

    task automatic wait_for_region_map_ub_index1( input int _this_dot_1 );
        do_wait_for_region_map_ub_index1( _this_dot_1 );
    endtask

    task automatic wait_for_region_map_region(  );
        do_wait_for_region_map_region(  );
    endtask

    task automatic wait_for_region_map_region_index1( input int _this_dot_1 );
        do_wait_for_region_map_region_index1( _this_dot_1 );
    endtask

    task automatic wait_for_cacheable(  );
        do_wait_for_cacheable(  );
    endtask

    task automatic wait_for_cacheable_index1( input int _this_dot_1 );
        do_wait_for_cacheable_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_read_data_reordering_depth(  );
        do_wait_for_config_read_data_reordering_depth(  );
    endtask

    task automatic wait_for_config_slave_start_addr(  );
        do_wait_for_config_slave_start_addr(  );
    endtask

    task automatic wait_for_config_slave_start_addr_index1( input int _this_dot_1 );
        do_wait_for_config_slave_start_addr_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_slave_end_addr(  );
        do_wait_for_config_slave_end_addr(  );
    endtask

    task automatic wait_for_config_slave_end_addr_index1( input int _this_dot_1 );
        do_wait_for_config_slave_end_addr_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_slave_enabled_non_contiguous_address_spaces(  );
        do_wait_for_config_slave_enabled_non_contiguous_address_spaces(  );
    endtask

    task automatic wait_for_config_slave_possess_multiple_non_contiguous_address_spaces(  );
        do_wait_for_config_slave_possess_multiple_non_contiguous_address_spaces(  );
    endtask

    task automatic wait_for_config_slave_multiple_non_contiguous_start_address_range(  );
        do_wait_for_config_slave_multiple_non_contiguous_start_address_range(  );
    endtask

    task automatic wait_for_config_slave_multiple_non_contiguous_start_address_range_index1( input int _this_dot_1 );
        do_wait_for_config_slave_multiple_non_contiguous_start_address_range_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_slave_multiple_non_contiguous_start_address_range_index2( input int _this_dot_1, input int _this_dot_2 );
        do_wait_for_config_slave_multiple_non_contiguous_start_address_range_index2( _this_dot_1, _this_dot_2 );
    endtask

    task automatic wait_for_config_slave_multiple_non_contiguous_end_address_range(  );
        do_wait_for_config_slave_multiple_non_contiguous_end_address_range(  );
    endtask

    task automatic wait_for_config_slave_multiple_non_contiguous_end_address_range_index1( input int _this_dot_1 );
        do_wait_for_config_slave_multiple_non_contiguous_end_address_range_index1( _this_dot_1 );
    endtask

    task automatic wait_for_config_slave_multiple_non_contiguous_end_address_range_index2( input int _this_dot_1, input int _this_dot_2 );
        do_wait_for_config_slave_multiple_non_contiguous_end_address_range_index2( _this_dot_1, _this_dot_2 );
    endtask

    task automatic wait_for_config_protect_ready(  );
        do_wait_for_config_protect_ready(  );
    endtask

    task automatic wait_for_master_end_tlm_status(  );
        do_wait_for_master_end_tlm_status(  );
    endtask

    task automatic wait_for_master_end_wlm_status(  );
        do_wait_for_master_end_wlm_status(  );
    endtask

    task automatic wait_for_slave_end_tlm_status(  );
        do_wait_for_slave_end_tlm_status(  );
    endtask

    task automatic wait_for_slave_end_wlm_status(  );
        do_wait_for_slave_end_wlm_status(  );
    endtask

    task automatic wait_for_clock_source_end_tlm_status(  );
        do_wait_for_clock_source_end_tlm_status(  );
    endtask

    task automatic wait_for_clock_source_end_wlm_status(  );
        do_wait_for_clock_source_end_wlm_status(  );
    endtask

    task automatic wait_for_reset_source_end_tlm_status(  );
        do_wait_for_reset_source_end_tlm_status(  );
    endtask

    task automatic wait_for_reset_source_end_wlm_status(  );
        do_wait_for_reset_source_end_wlm_status(  );
    endtask

    task automatic wait_for_config_max_outstanding_wr(  );
        do_wait_for_config_max_outstanding_wr(  );
    endtask

    task automatic wait_for_config_max_outstanding_rd(  );
        do_wait_for_config_max_outstanding_rd(  );
    endtask

    task automatic wait_for_config_num_outstanding_wr_phase(  );
        do_wait_for_config_num_outstanding_wr_phase(  );
    endtask

    task automatic wait_for_config_num_outstanding_rd_phase(  );
        do_wait_for_config_num_outstanding_rd_phase(  );
    endtask

    task automatic wait_for_config_enable_warnings(  );
        do_wait_for_config_enable_warnings(  );
    endtask

    task automatic wait_for_config_enable_errors(  );
        do_wait_for_config_enable_errors(  );
    endtask

    task automatic wait_for_config_enable_exclusive_checks(  );
        do_wait_for_config_enable_exclusive_checks(  );
    endtask

    task automatic wait_for_config_warn_on_slave_errors(  );
        do_wait_for_config_warn_on_slave_errors(  );
    endtask

    task automatic wait_for_config_error_on_deleted_valid_cycles(  );
        do_wait_for_config_error_on_deleted_valid_cycles(  );
    endtask

    task automatic wait_for_config_stats_enable(  );
        do_wait_for_config_stats_enable(  );
    endtask

    task automatic wait_for_config_stats_enable_read_occupancy(  );
        do_wait_for_config_stats_enable_read_occupancy(  );
    endtask

    task automatic wait_for_config_stats_enable_write_occupancy(  );
        do_wait_for_config_stats_enable_write_occupancy(  );
    endtask

    task automatic wait_for_config_stats_enable_read_data_occupancy(  );
        do_wait_for_config_stats_enable_read_data_occupancy(  );
    endtask

    task automatic wait_for_config_stats_enable_write_data_occupancy(  );
        do_wait_for_config_stats_enable_write_data_occupancy(  );
    endtask

    task automatic wait_for_config_stats_enable_read_latency(  );
        do_wait_for_config_stats_enable_read_latency(  );
    endtask

    task automatic wait_for_config_stats_enable_write_latency(  );
        do_wait_for_config_stats_enable_write_latency(  );
    endtask

    task automatic wait_for_config_stats_enable_read_address_waits(  );
        do_wait_for_config_stats_enable_read_address_waits(  );
    endtask

    task automatic wait_for_config_stats_enable_read_data_waits(  );
        do_wait_for_config_stats_enable_read_data_waits(  );
    endtask

    task automatic wait_for_config_stats_enable_write_address_waits(  );
        do_wait_for_config_stats_enable_write_address_waits(  );
    endtask

    task automatic wait_for_config_stats_enable_write_data_waits(  );
        do_wait_for_config_stats_enable_write_data_waits(  );
    endtask

    task automatic wait_for_config_stats_enable_write_response_waits(  );
        do_wait_for_config_stats_enable_write_response_waits(  );
    endtask

    task automatic wait_for_config_stats_enable_read_bandwidth(  );
        do_wait_for_config_stats_enable_read_bandwidth(  );
    endtask

    task automatic wait_for_config_stats_enable_write_bandwidth(  );
        do_wait_for_config_stats_enable_write_bandwidth(  );
    endtask

    task automatic wait_for_stats_rw_transaction_last_duration(  );
        do_wait_for_stats_rw_transaction_last_duration(  );
    endtask

    task automatic wait_for_config_stats_read_occupancy_step(  );
        do_wait_for_config_stats_read_occupancy_step(  );
    endtask

    task automatic wait_for_config_stats_read_occupancy_multiple(  );
        do_wait_for_config_stats_read_occupancy_multiple(  );
    endtask

    task automatic wait_for_stats_read_active(  );
        do_wait_for_stats_read_active(  );
    endtask

    task automatic wait_for_stats_read_occupancy_sw(  );
        do_wait_for_stats_read_occupancy_sw(  );
    endtask

    task automatic wait_for_stats_read_idle_sw(  );
        do_wait_for_stats_read_idle_sw(  );
    endtask

    task automatic wait_for_stats_read_occupancy_min(  );
        do_wait_for_stats_read_occupancy_min(  );
    endtask

    task automatic wait_for_stats_read_idle_min(  );
        do_wait_for_stats_read_idle_min(  );
    endtask

    task automatic wait_for_stats_read_occupancy_max(  );
        do_wait_for_stats_read_occupancy_max(  );
    endtask

    task automatic wait_for_stats_read_idle_max(  );
        do_wait_for_stats_read_idle_max(  );
    endtask

    task automatic wait_for_stats_read_occupancy_mean(  );
        do_wait_for_stats_read_occupancy_mean(  );
    endtask

    task automatic wait_for_stats_read_idle_mean(  );
        do_wait_for_stats_read_idle_mean(  );
    endtask

    task automatic wait_for_stats_read_last_duration(  );
        do_wait_for_stats_read_last_duration(  );
    endtask

    task automatic wait_for_config_stats_write_occupancy_step(  );
        do_wait_for_config_stats_write_occupancy_step(  );
    endtask

    task automatic wait_for_config_stats_write_occupancy_multiple(  );
        do_wait_for_config_stats_write_occupancy_multiple(  );
    endtask

    task automatic wait_for_stats_write_active(  );
        do_wait_for_stats_write_active(  );
    endtask

    task automatic wait_for_stats_write_occupancy_sw(  );
        do_wait_for_stats_write_occupancy_sw(  );
    endtask

    task automatic wait_for_stats_write_idle_sw(  );
        do_wait_for_stats_write_idle_sw(  );
    endtask

    task automatic wait_for_stats_write_occupancy_min(  );
        do_wait_for_stats_write_occupancy_min(  );
    endtask

    task automatic wait_for_stats_write_idle_min(  );
        do_wait_for_stats_write_idle_min(  );
    endtask

    task automatic wait_for_stats_write_occupancy_max(  );
        do_wait_for_stats_write_occupancy_max(  );
    endtask

    task automatic wait_for_stats_write_idle_max(  );
        do_wait_for_stats_write_idle_max(  );
    endtask

    task automatic wait_for_stats_write_occupancy_mean(  );
        do_wait_for_stats_write_occupancy_mean(  );
    endtask

    task automatic wait_for_stats_write_idle_mean(  );
        do_wait_for_stats_write_idle_mean(  );
    endtask

    task automatic wait_for_stats_write_last_duration(  );
        do_wait_for_stats_write_last_duration(  );
    endtask

    task automatic wait_for_config_stats_read_data_occupancy_step(  );
        do_wait_for_config_stats_read_data_occupancy_step(  );
    endtask

    task automatic wait_for_config_stats_read_data_occupancy_multiple(  );
        do_wait_for_config_stats_read_data_occupancy_multiple(  );
    endtask

    task automatic wait_for_stats_read_data_occupancy_sw(  );
        do_wait_for_stats_read_data_occupancy_sw(  );
    endtask

    task automatic wait_for_stats_read_data_idle_sw(  );
        do_wait_for_stats_read_data_idle_sw(  );
    endtask

    task automatic wait_for_stats_read_data_occupancy_min(  );
        do_wait_for_stats_read_data_occupancy_min(  );
    endtask

    task automatic wait_for_stats_read_data_idle_min(  );
        do_wait_for_stats_read_data_idle_min(  );
    endtask

    task automatic wait_for_stats_read_data_occupancy_max(  );
        do_wait_for_stats_read_data_occupancy_max(  );
    endtask

    task automatic wait_for_stats_read_data_idle_max(  );
        do_wait_for_stats_read_data_idle_max(  );
    endtask

    task automatic wait_for_stats_read_data_occupancy_mean(  );
        do_wait_for_stats_read_data_occupancy_mean(  );
    endtask

    task automatic wait_for_stats_read_data_idle_mean(  );
        do_wait_for_stats_read_data_idle_mean(  );
    endtask

    task automatic wait_for_config_stats_write_data_occupancy_step(  );
        do_wait_for_config_stats_write_data_occupancy_step(  );
    endtask

    task automatic wait_for_config_stats_write_data_occupancy_multiple(  );
        do_wait_for_config_stats_write_data_occupancy_multiple(  );
    endtask

    task automatic wait_for_stats_write_data_occupancy_sw(  );
        do_wait_for_stats_write_data_occupancy_sw(  );
    endtask

    task automatic wait_for_stats_write_data_idle_sw(  );
        do_wait_for_stats_write_data_idle_sw(  );
    endtask

    task automatic wait_for_stats_write_data_occupancy_min(  );
        do_wait_for_stats_write_data_occupancy_min(  );
    endtask

    task automatic wait_for_stats_write_data_idle_min(  );
        do_wait_for_stats_write_data_idle_min(  );
    endtask

    task automatic wait_for_stats_write_data_occupancy_max(  );
        do_wait_for_stats_write_data_occupancy_max(  );
    endtask

    task automatic wait_for_stats_write_data_idle_max(  );
        do_wait_for_stats_write_data_idle_max(  );
    endtask

    task automatic wait_for_stats_write_data_occupancy_mean(  );
        do_wait_for_stats_write_data_occupancy_mean(  );
    endtask

    task automatic wait_for_stats_write_data_idle_mean(  );
        do_wait_for_stats_write_data_idle_mean(  );
    endtask

    task automatic wait_for_config_stats_read_bandwidth_step(  );
        do_wait_for_config_stats_read_bandwidth_step(  );
    endtask

    task automatic wait_for_config_stats_read_bandwidth_multiple(  );
        do_wait_for_config_stats_read_bandwidth_multiple(  );
    endtask

    task automatic wait_for_stats_read_bandwidth_sw(  );
        do_wait_for_stats_read_bandwidth_sw(  );
    endtask

    task automatic wait_for_stats_read_bandwidth_min(  );
        do_wait_for_stats_read_bandwidth_min(  );
    endtask

    task automatic wait_for_stats_read_bandwidth_max(  );
        do_wait_for_stats_read_bandwidth_max(  );
    endtask

    task automatic wait_for_stats_read_bandwidth_mean(  );
        do_wait_for_stats_read_bandwidth_mean(  );
    endtask

    task automatic wait_for_config_stats_write_bandwidth_step(  );
        do_wait_for_config_stats_write_bandwidth_step(  );
    endtask

    task automatic wait_for_config_stats_write_bandwidth_multiple(  );
        do_wait_for_config_stats_write_bandwidth_multiple(  );
    endtask

    task automatic wait_for_stats_write_bandwidth_sw(  );
        do_wait_for_stats_write_bandwidth_sw(  );
    endtask

    task automatic wait_for_stats_write_bandwidth_min(  );
        do_wait_for_stats_write_bandwidth_min(  );
    endtask

    task automatic wait_for_stats_write_bandwidth_max(  );
        do_wait_for_stats_write_bandwidth_max(  );
    endtask

    task automatic wait_for_stats_write_bandwidth_mean(  );
        do_wait_for_stats_write_bandwidth_mean(  );
    endtask

    task automatic wait_for_config_stats_read_latency_step(  );
        do_wait_for_config_stats_read_latency_step(  );
    endtask

    task automatic wait_for_config_stats_read_latency_multiple(  );
        do_wait_for_config_stats_read_latency_multiple(  );
    endtask

    task automatic wait_for_stats_read_address_data_latency_inst(  );
        do_wait_for_stats_read_address_data_latency_inst(  );
    endtask

    task automatic wait_for_stats_read_address_data_latency_sw(  );
        do_wait_for_stats_read_address_data_latency_sw(  );
    endtask

    task automatic wait_for_stats_read_address_data_latency_min(  );
        do_wait_for_stats_read_address_data_latency_min(  );
    endtask

    task automatic wait_for_stats_read_address_data_latency_max(  );
        do_wait_for_stats_read_address_data_latency_max(  );
    endtask

    task automatic wait_for_stats_read_address_data_latency_mean(  );
        do_wait_for_stats_read_address_data_latency_mean(  );
    endtask

    task automatic wait_for_stats_read_address_address_latency_inst(  );
        do_wait_for_stats_read_address_address_latency_inst(  );
    endtask

    task automatic wait_for_stats_read_address_address_latency_sw(  );
        do_wait_for_stats_read_address_address_latency_sw(  );
    endtask

    task automatic wait_for_stats_read_address_address_latency_min(  );
        do_wait_for_stats_read_address_address_latency_min(  );
    endtask

    task automatic wait_for_stats_read_address_address_latency_max(  );
        do_wait_for_stats_read_address_address_latency_max(  );
    endtask

    task automatic wait_for_stats_read_address_address_latency_mean(  );
        do_wait_for_stats_read_address_address_latency_mean(  );
    endtask

    task automatic wait_for_config_stats_write_latency_step(  );
        do_wait_for_config_stats_write_latency_step(  );
    endtask

    task automatic wait_for_config_stats_write_latency_multiple(  );
        do_wait_for_config_stats_write_latency_multiple(  );
    endtask

    task automatic wait_for_stats_write_address_response_latency_inst(  );
        do_wait_for_stats_write_address_response_latency_inst(  );
    endtask

    task automatic wait_for_stats_write_address_response_latency_sw(  );
        do_wait_for_stats_write_address_response_latency_sw(  );
    endtask

    task automatic wait_for_stats_write_address_response_latency_min(  );
        do_wait_for_stats_write_address_response_latency_min(  );
    endtask

    task automatic wait_for_stats_write_address_response_latency_max(  );
        do_wait_for_stats_write_address_response_latency_max(  );
    endtask

    task automatic wait_for_stats_write_address_response_latency_mean(  );
        do_wait_for_stats_write_address_response_latency_mean(  );
    endtask

    task automatic wait_for_stats_write_address_address_latency_inst(  );
        do_wait_for_stats_write_address_address_latency_inst(  );
    endtask

    task automatic wait_for_stats_write_address_address_latency_sw(  );
        do_wait_for_stats_write_address_address_latency_sw(  );
    endtask

    task automatic wait_for_stats_write_address_address_latency_min(  );
        do_wait_for_stats_write_address_address_latency_min(  );
    endtask

    task automatic wait_for_stats_write_address_address_latency_max(  );
        do_wait_for_stats_write_address_address_latency_max(  );
    endtask

    task automatic wait_for_stats_write_address_address_latency_mean(  );
        do_wait_for_stats_write_address_address_latency_mean(  );
    endtask

    task automatic wait_for_config_stats_read_address_waits_step(  );
        do_wait_for_config_stats_read_address_waits_step(  );
    endtask

    task automatic wait_for_config_stats_read_address_waits_multiple(  );
        do_wait_for_config_stats_read_address_waits_multiple(  );
    endtask

    task automatic wait_for_stats_read_address_waits_inst(  );
        do_wait_for_stats_read_address_waits_inst(  );
    endtask

    task automatic wait_for_stats_read_address_waits_sw(  );
        do_wait_for_stats_read_address_waits_sw(  );
    endtask

    task automatic wait_for_stats_read_address_waits_min(  );
        do_wait_for_stats_read_address_waits_min(  );
    endtask

    task automatic wait_for_stats_read_address_waits_max(  );
        do_wait_for_stats_read_address_waits_max(  );
    endtask

    task automatic wait_for_stats_read_address_waits_mean(  );
        do_wait_for_stats_read_address_waits_mean(  );
    endtask

    task automatic wait_for_config_stats_read_data_waits_step(  );
        do_wait_for_config_stats_read_data_waits_step(  );
    endtask

    task automatic wait_for_config_stats_read_data_waits_multiple(  );
        do_wait_for_config_stats_read_data_waits_multiple(  );
    endtask

    task automatic wait_for_stats_read_data_waits_inst(  );
        do_wait_for_stats_read_data_waits_inst(  );
    endtask

    task automatic wait_for_stats_read_data_waits_sw(  );
        do_wait_for_stats_read_data_waits_sw(  );
    endtask

    task automatic wait_for_stats_read_data_waits_min(  );
        do_wait_for_stats_read_data_waits_min(  );
    endtask

    task automatic wait_for_stats_read_data_waits_max(  );
        do_wait_for_stats_read_data_waits_max(  );
    endtask

    task automatic wait_for_stats_read_data_waits_mean(  );
        do_wait_for_stats_read_data_waits_mean(  );
    endtask

    task automatic wait_for_config_stats_write_address_waits_step(  );
        do_wait_for_config_stats_write_address_waits_step(  );
    endtask

    task automatic wait_for_config_stats_write_address_waits_multiple(  );
        do_wait_for_config_stats_write_address_waits_multiple(  );
    endtask

    task automatic wait_for_stats_write_address_waits_inst(  );
        do_wait_for_stats_write_address_waits_inst(  );
    endtask

    task automatic wait_for_stats_write_address_waits_sw(  );
        do_wait_for_stats_write_address_waits_sw(  );
    endtask

    task automatic wait_for_stats_write_address_waits_min(  );
        do_wait_for_stats_write_address_waits_min(  );
    endtask

    task automatic wait_for_stats_write_address_waits_max(  );
        do_wait_for_stats_write_address_waits_max(  );
    endtask

    task automatic wait_for_stats_write_address_waits_mean(  );
        do_wait_for_stats_write_address_waits_mean(  );
    endtask

    task automatic wait_for_config_stats_write_data_waits_step(  );
        do_wait_for_config_stats_write_data_waits_step(  );
    endtask

    task automatic wait_for_config_stats_write_data_waits_multiple(  );
        do_wait_for_config_stats_write_data_waits_multiple(  );
    endtask

    task automatic wait_for_stats_write_data_waits_inst(  );
        do_wait_for_stats_write_data_waits_inst(  );
    endtask

    task automatic wait_for_stats_write_data_waits_sw(  );
        do_wait_for_stats_write_data_waits_sw(  );
    endtask

    task automatic wait_for_stats_write_data_waits_min(  );
        do_wait_for_stats_write_data_waits_min(  );
    endtask

    task automatic wait_for_stats_write_data_waits_max(  );
        do_wait_for_stats_write_data_waits_max(  );
    endtask

    task automatic wait_for_stats_write_data_waits_mean(  );
        do_wait_for_stats_write_data_waits_mean(  );
    endtask

    task automatic wait_for_config_stats_write_response_waits_step(  );
        do_wait_for_config_stats_write_response_waits_step(  );
    endtask

    task automatic wait_for_config_stats_write_response_waits_multiple(  );
        do_wait_for_config_stats_write_response_waits_multiple(  );
    endtask

    task automatic wait_for_stats_write_response_waits_inst(  );
        do_wait_for_stats_write_response_waits_inst(  );
    endtask

    task automatic wait_for_stats_write_response_waits_sw(  );
        do_wait_for_stats_write_response_waits_sw(  );
    endtask

    task automatic wait_for_stats_write_response_waits_min(  );
        do_wait_for_stats_write_response_waits_min(  );
    endtask

    task automatic wait_for_stats_write_response_waits_max(  );
        do_wait_for_stats_write_response_waits_max(  );
    endtask

    task automatic wait_for_stats_write_response_waits_mean(  );
        do_wait_for_stats_write_response_waits_mean(  );
    endtask

    task automatic wait_for_reordering_depth_of_last_read_transaction(  );
        do_wait_for_reordering_depth_of_last_read_transaction(  );
    endtask


    //------------------------------------------------------------------------------
    // Functions to set global variables with write access
    //------------------------------------------------------------------------------
    function automatic void set_config_interface_type( axi4_interface_type_e config_interface_type_param );
        do_set_config_interface_type( config_interface_type_param );
    endfunction

    function automatic void set_config_clk_init_value( bit config_clk_init_value_param );
        do_set_config_clk_init_value( config_clk_init_value_param );
    endfunction

    function automatic void set_config_clk_phase_shift( longint unsigned config_clk_phase_shift_param );
        do_set_config_clk_phase_shift( config_clk_phase_shift_param );
    endfunction

    function automatic void set_config_clk_1st_time( longint unsigned config_clk_1st_time_param );
        do_set_config_clk_1st_time( config_clk_1st_time_param );
    endfunction

    function automatic void set_config_clk_2nd_time( longint unsigned config_clk_2nd_time_param );
        do_set_config_clk_2nd_time( config_clk_2nd_time_param );
    endfunction

    function automatic void set_config_setup_time( longint unsigned config_setup_time_param );
        do_set_config_setup_time( config_setup_time_param );
    endfunction

    function automatic void set_config_hold_time( longint unsigned config_hold_time_param );
        do_set_config_hold_time( config_hold_time_param );
    endfunction

    function automatic void set_config_burst_timeout_factor( int unsigned config_burst_timeout_factor_param );
        do_set_config_burst_timeout_factor( config_burst_timeout_factor_param );
    endfunction

    function automatic void set_config_max_transaction_time_factor( int unsigned config_max_transaction_time_factor_param );
        do_set_config_max_transaction_time_factor( config_max_transaction_time_factor_param );
    endfunction

    function automatic void set_config_write_ctrl_first_ratio( int config_write_ctrl_first_ratio_param );
        do_set_config_write_ctrl_first_ratio( config_write_ctrl_first_ratio_param );
    endfunction

    function automatic void set_config_write_data_first_ratio( int config_write_data_first_ratio_param );
        do_set_config_write_data_first_ratio( config_write_data_first_ratio_param );
    endfunction

    function automatic void set_config_reset_low_clocks( int config_reset_low_clocks_param );
        do_set_config_reset_low_clocks( config_reset_low_clocks_param );
    endfunction

    function automatic void set_config_reset_hold_time( int config_reset_hold_time_param );
        do_set_config_reset_hold_time( config_reset_hold_time_param );
    endfunction

    function automatic void set_config_enable_rlast( bit config_enable_rlast_param );
        do_set_config_enable_rlast( config_enable_rlast_param );
    endfunction

    function automatic void set_config_enable_slave_exclusive( bit config_enable_slave_exclusive_param );
        do_set_config_enable_slave_exclusive( config_enable_slave_exclusive_param );
    endfunction

    function automatic void set_config_enable_burst_reserved_value( bit config_enable_burst_reserved_value_param );
        do_set_config_enable_burst_reserved_value( config_enable_burst_reserved_value_param );
    endfunction

    function automatic void set_config_enable_cache_value( bit [15:0] config_enable_cache_value_param );
        do_set_config_enable_cache_value( config_enable_cache_value_param );
    endfunction

    function automatic void set_config_enable_cache_value_index1( int _this_dot_1, bit  config_enable_cache_value_param );
        do_set_config_enable_cache_value_index1( _this_dot_1, config_enable_cache_value_param );
    endfunction

    function automatic void set_internal_dummy_variable( axi4_error_e internal_dummy_variable_param );
        do_set_internal_dummy_variable( internal_dummy_variable_param );
    endfunction

    function automatic void set_config_axi4lite_interface( bit config_axi4lite_interface_param );
        do_set_config_axi4lite_interface( config_axi4lite_interface_param );
    endfunction

    function automatic void set_config_axi4lite_tr_id( bit [((AXI4_ID_WIDTH) - 1):0]  config_axi4lite_tr_id_param );
        do_set_config_axi4lite_tr_id( config_axi4lite_tr_id_param );
    endfunction

    function automatic void set_config_axi4lite_tr_id_index1( int _this_dot_1, bit  config_axi4lite_tr_id_param );
        do_set_config_axi4lite_tr_id_index1( _this_dot_1, config_axi4lite_tr_id_param );
    endfunction

    function automatic void set_config_enable_all_assertions( bit config_enable_all_assertions_param );
        do_set_config_enable_all_assertions( config_enable_all_assertions_param );
    endfunction

    function automatic void set_config_enable_assertion( bit [255:0] config_enable_assertion_param );
        do_set_config_enable_assertion( config_enable_assertion_param );
    endfunction

    function automatic void set_config_enable_assertion_index1( int _this_dot_1, bit  config_enable_assertion_param );
        do_set_config_enable_assertion_index1( _this_dot_1, config_enable_assertion_param );
    endfunction

    function automatic void set_config_enable_error( bit [255:0] config_enable_error_param );
        do_set_config_enable_error( config_enable_error_param );
    endfunction

    function automatic void set_config_enable_error_index1( int _this_dot_1, bit  config_enable_error_param );
        do_set_config_enable_error_index1( _this_dot_1, config_enable_error_param );
    endfunction

    function automatic void set_config_max_latency_AWVALID_assertion_to_AWREADY( int unsigned config_max_latency_AWVALID_assertion_to_AWREADY_param );
        do_set_config_max_latency_AWVALID_assertion_to_AWREADY( config_max_latency_AWVALID_assertion_to_AWREADY_param );
    endfunction

    function automatic void set_config_max_latency_ARVALID_assertion_to_ARREADY( int unsigned config_max_latency_ARVALID_assertion_to_ARREADY_param );
        do_set_config_max_latency_ARVALID_assertion_to_ARREADY( config_max_latency_ARVALID_assertion_to_ARREADY_param );
    endfunction

    function automatic void set_config_max_latency_RVALID_assertion_to_RREADY( int unsigned config_max_latency_RVALID_assertion_to_RREADY_param );
        do_set_config_max_latency_RVALID_assertion_to_RREADY( config_max_latency_RVALID_assertion_to_RREADY_param );
    endfunction

    function automatic void set_config_max_latency_BVALID_assertion_to_BREADY( int unsigned config_max_latency_BVALID_assertion_to_BREADY_param );
        do_set_config_max_latency_BVALID_assertion_to_BREADY( config_max_latency_BVALID_assertion_to_BREADY_param );
    endfunction

    function automatic void set_config_max_latency_WVALID_assertion_to_WREADY( int unsigned config_max_latency_WVALID_assertion_to_WREADY_param );
        do_set_config_max_latency_WVALID_assertion_to_WREADY( config_max_latency_WVALID_assertion_to_WREADY_param );
    endfunction

    function automatic void set_config_enable_qos( bit config_enable_qos_param );
        do_set_config_enable_qos( config_enable_qos_param );
    endfunction

    function automatic void set_config_enable_region_support( bit config_enable_region_support_param );
        do_set_config_enable_region_support( config_enable_region_support_param );
    endfunction

    function automatic void set_config_slave_regions( int config_slave_regions_param );
        do_set_config_slave_regions( config_slave_regions_param );
    endfunction

    function automatic void set_config_region( bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  config_region_param );
        do_set_config_region( config_region_param );
    endfunction

    function automatic void set_config_region_index1( int _this_dot_1, bit [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]  config_region_param );
        do_set_config_region_index1( _this_dot_1, config_region_param );
    endfunction

    function automatic void set_config_region_index2( int _this_dot_1, int _this_dot_2, bit  config_region_param );
        do_set_config_region_index2( _this_dot_1, _this_dot_2, config_region_param );
    endfunction

    function automatic void set_config_read_data_reordering_depth( int unsigned config_read_data_reordering_depth_param );
        do_set_config_read_data_reordering_depth( config_read_data_reordering_depth_param );
    endfunction

    function automatic void set_config_slave_start_addr( bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_start_addr_param );
        do_set_config_slave_start_addr( config_slave_start_addr_param );
    endfunction

    function automatic void set_config_slave_start_addr_index1( int _this_dot_1, bit  config_slave_start_addr_param );
        do_set_config_slave_start_addr_index1( _this_dot_1, config_slave_start_addr_param );
    endfunction

    function automatic void set_config_slave_end_addr( bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_end_addr_param );
        do_set_config_slave_end_addr( config_slave_end_addr_param );
    endfunction

    function automatic void set_config_slave_end_addr_index1( int _this_dot_1, bit  config_slave_end_addr_param );
        do_set_config_slave_end_addr_index1( _this_dot_1, config_slave_end_addr_param );
    endfunction

    function automatic void set_config_slave_enabled_non_contiguous_address_spaces( int config_slave_enabled_non_contiguous_address_spaces_param );
        do_set_config_slave_enabled_non_contiguous_address_spaces( config_slave_enabled_non_contiguous_address_spaces_param );
    endfunction

    function automatic void set_config_slave_possess_multiple_non_contiguous_address_spaces( bit config_slave_possess_multiple_non_contiguous_address_spaces_param );
        do_set_config_slave_possess_multiple_non_contiguous_address_spaces( config_slave_possess_multiple_non_contiguous_address_spaces_param );
    endfunction

    function automatic void set_config_slave_multiple_non_contiguous_start_address_range( bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_start_address_range_param );
        do_set_config_slave_multiple_non_contiguous_start_address_range( config_slave_multiple_non_contiguous_start_address_range_param );
    endfunction

    function automatic void set_config_slave_multiple_non_contiguous_start_address_range_index1( int _this_dot_1, bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_start_address_range_param );
        do_set_config_slave_multiple_non_contiguous_start_address_range_index1( _this_dot_1, config_slave_multiple_non_contiguous_start_address_range_param );
    endfunction

    function automatic void set_config_slave_multiple_non_contiguous_start_address_range_index2( int _this_dot_1, int _this_dot_2, bit  config_slave_multiple_non_contiguous_start_address_range_param );
        do_set_config_slave_multiple_non_contiguous_start_address_range_index2( _this_dot_1, _this_dot_2, config_slave_multiple_non_contiguous_start_address_range_param );
    endfunction

    function automatic void set_config_slave_multiple_non_contiguous_end_address_range( bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_end_address_range_param );
        do_set_config_slave_multiple_non_contiguous_end_address_range( config_slave_multiple_non_contiguous_end_address_range_param );
    endfunction

    function automatic void set_config_slave_multiple_non_contiguous_end_address_range_index1( int _this_dot_1, bit [((AXI4_ADDRESS_WIDTH) - 1):0]  config_slave_multiple_non_contiguous_end_address_range_param );
        do_set_config_slave_multiple_non_contiguous_end_address_range_index1( _this_dot_1, config_slave_multiple_non_contiguous_end_address_range_param );
    endfunction

    function automatic void set_config_slave_multiple_non_contiguous_end_address_range_index2( int _this_dot_1, int _this_dot_2, bit  config_slave_multiple_non_contiguous_end_address_range_param );
        do_set_config_slave_multiple_non_contiguous_end_address_range_index2( _this_dot_1, _this_dot_2, config_slave_multiple_non_contiguous_end_address_range_param );
    endfunction

    function automatic void set_config_protect_ready( bit config_protect_ready_param );
        do_set_config_protect_ready( config_protect_ready_param );
    endfunction

    function automatic void set_config_max_outstanding_wr( int config_max_outstanding_wr_param );
        do_set_config_max_outstanding_wr( config_max_outstanding_wr_param );
    endfunction

    function automatic void set_config_max_outstanding_rd( int config_max_outstanding_rd_param );
        do_set_config_max_outstanding_rd( config_max_outstanding_rd_param );
    endfunction

    function automatic void set_config_num_outstanding_wr_phase( int config_num_outstanding_wr_phase_param );
        do_set_config_num_outstanding_wr_phase( config_num_outstanding_wr_phase_param );
    endfunction

    function automatic void set_config_num_outstanding_rd_phase( int config_num_outstanding_rd_phase_param );
        do_set_config_num_outstanding_rd_phase( config_num_outstanding_rd_phase_param );
    endfunction

    function automatic void set_config_enable_warnings( bit config_enable_warnings_param );
        do_set_config_enable_warnings( config_enable_warnings_param );
    endfunction

    function automatic void set_config_enable_errors( bit config_enable_errors_param );
        do_set_config_enable_errors( config_enable_errors_param );
    endfunction

    function automatic void set_config_enable_exclusive_checks( bit config_enable_exclusive_checks_param );
        do_set_config_enable_exclusive_checks( config_enable_exclusive_checks_param );
    endfunction

    function automatic void set_config_warn_on_slave_errors( bit config_warn_on_slave_errors_param );
        do_set_config_warn_on_slave_errors( config_warn_on_slave_errors_param );
    endfunction

    function automatic void set_config_error_on_deleted_valid_cycles( bit config_error_on_deleted_valid_cycles_param );
        do_set_config_error_on_deleted_valid_cycles( config_error_on_deleted_valid_cycles_param );
    endfunction

    function automatic void set_config_stats_enable( bit config_stats_enable_param );
        do_set_config_stats_enable( config_stats_enable_param );
    endfunction

    function automatic void set_config_stats_enable_read_occupancy( bit config_stats_enable_read_occupancy_param );
        do_set_config_stats_enable_read_occupancy( config_stats_enable_read_occupancy_param );
    endfunction

    function automatic void set_config_stats_enable_write_occupancy( bit config_stats_enable_write_occupancy_param );
        do_set_config_stats_enable_write_occupancy( config_stats_enable_write_occupancy_param );
    endfunction

    function automatic void set_config_stats_enable_read_data_occupancy( bit config_stats_enable_read_data_occupancy_param );
        do_set_config_stats_enable_read_data_occupancy( config_stats_enable_read_data_occupancy_param );
    endfunction

    function automatic void set_config_stats_enable_write_data_occupancy( bit config_stats_enable_write_data_occupancy_param );
        do_set_config_stats_enable_write_data_occupancy( config_stats_enable_write_data_occupancy_param );
    endfunction

    function automatic void set_config_stats_enable_read_latency( bit config_stats_enable_read_latency_param );
        do_set_config_stats_enable_read_latency( config_stats_enable_read_latency_param );
    endfunction

    function automatic void set_config_stats_enable_write_latency( bit config_stats_enable_write_latency_param );
        do_set_config_stats_enable_write_latency( config_stats_enable_write_latency_param );
    endfunction

    function automatic void set_config_stats_enable_read_address_waits( bit config_stats_enable_read_address_waits_param );
        do_set_config_stats_enable_read_address_waits( config_stats_enable_read_address_waits_param );
    endfunction

    function automatic void set_config_stats_enable_read_data_waits( bit config_stats_enable_read_data_waits_param );
        do_set_config_stats_enable_read_data_waits( config_stats_enable_read_data_waits_param );
    endfunction

    function automatic void set_config_stats_enable_write_address_waits( bit config_stats_enable_write_address_waits_param );
        do_set_config_stats_enable_write_address_waits( config_stats_enable_write_address_waits_param );
    endfunction

    function automatic void set_config_stats_enable_write_data_waits( bit config_stats_enable_write_data_waits_param );
        do_set_config_stats_enable_write_data_waits( config_stats_enable_write_data_waits_param );
    endfunction

    function automatic void set_config_stats_enable_write_response_waits( bit config_stats_enable_write_response_waits_param );
        do_set_config_stats_enable_write_response_waits( config_stats_enable_write_response_waits_param );
    endfunction

    function automatic void set_config_stats_enable_read_bandwidth( bit config_stats_enable_read_bandwidth_param );
        do_set_config_stats_enable_read_bandwidth( config_stats_enable_read_bandwidth_param );
    endfunction

    function automatic void set_config_stats_enable_write_bandwidth( bit config_stats_enable_write_bandwidth_param );
        do_set_config_stats_enable_write_bandwidth( config_stats_enable_write_bandwidth_param );
    endfunction

    function automatic void set_config_stats_read_occupancy_step( int config_stats_read_occupancy_step_param );
        do_set_config_stats_read_occupancy_step( config_stats_read_occupancy_step_param );
    endfunction

    function automatic void set_config_stats_read_occupancy_multiple( int config_stats_read_occupancy_multiple_param );
        do_set_config_stats_read_occupancy_multiple( config_stats_read_occupancy_multiple_param );
    endfunction

    function automatic void set_config_stats_write_occupancy_step( int config_stats_write_occupancy_step_param );
        do_set_config_stats_write_occupancy_step( config_stats_write_occupancy_step_param );
    endfunction

    function automatic void set_config_stats_write_occupancy_multiple( int config_stats_write_occupancy_multiple_param );
        do_set_config_stats_write_occupancy_multiple( config_stats_write_occupancy_multiple_param );
    endfunction

    function automatic void set_config_stats_read_data_occupancy_step( int config_stats_read_data_occupancy_step_param );
        do_set_config_stats_read_data_occupancy_step( config_stats_read_data_occupancy_step_param );
    endfunction

    function automatic void set_config_stats_read_data_occupancy_multiple( int config_stats_read_data_occupancy_multiple_param );
        do_set_config_stats_read_data_occupancy_multiple( config_stats_read_data_occupancy_multiple_param );
    endfunction

    function automatic void set_config_stats_write_data_occupancy_step( int config_stats_write_data_occupancy_step_param );
        do_set_config_stats_write_data_occupancy_step( config_stats_write_data_occupancy_step_param );
    endfunction

    function automatic void set_config_stats_write_data_occupancy_multiple( int config_stats_write_data_occupancy_multiple_param );
        do_set_config_stats_write_data_occupancy_multiple( config_stats_write_data_occupancy_multiple_param );
    endfunction

    function automatic void set_config_stats_read_bandwidth_step( int config_stats_read_bandwidth_step_param );
        do_set_config_stats_read_bandwidth_step( config_stats_read_bandwidth_step_param );
    endfunction

    function automatic void set_config_stats_read_bandwidth_multiple( int config_stats_read_bandwidth_multiple_param );
        do_set_config_stats_read_bandwidth_multiple( config_stats_read_bandwidth_multiple_param );
    endfunction

    function automatic void set_config_stats_write_bandwidth_step( int config_stats_write_bandwidth_step_param );
        do_set_config_stats_write_bandwidth_step( config_stats_write_bandwidth_step_param );
    endfunction

    function automatic void set_config_stats_write_bandwidth_multiple( int config_stats_write_bandwidth_multiple_param );
        do_set_config_stats_write_bandwidth_multiple( config_stats_write_bandwidth_multiple_param );
    endfunction

    function automatic void set_config_stats_read_latency_step( int config_stats_read_latency_step_param );
        do_set_config_stats_read_latency_step( config_stats_read_latency_step_param );
    endfunction

    function automatic void set_config_stats_read_latency_multiple( int config_stats_read_latency_multiple_param );
        do_set_config_stats_read_latency_multiple( config_stats_read_latency_multiple_param );
    endfunction

    function automatic void set_config_stats_write_latency_step( int config_stats_write_latency_step_param );
        do_set_config_stats_write_latency_step( config_stats_write_latency_step_param );
    endfunction

    function automatic void set_config_stats_write_latency_multiple( int config_stats_write_latency_multiple_param );
        do_set_config_stats_write_latency_multiple( config_stats_write_latency_multiple_param );
    endfunction

    function automatic void set_config_stats_read_address_waits_step( int config_stats_read_address_waits_step_param );
        do_set_config_stats_read_address_waits_step( config_stats_read_address_waits_step_param );
    endfunction

    function automatic void set_config_stats_read_address_waits_multiple( int config_stats_read_address_waits_multiple_param );
        do_set_config_stats_read_address_waits_multiple( config_stats_read_address_waits_multiple_param );
    endfunction

    function automatic void set_config_stats_read_data_waits_step( int config_stats_read_data_waits_step_param );
        do_set_config_stats_read_data_waits_step( config_stats_read_data_waits_step_param );
    endfunction

    function automatic void set_config_stats_read_data_waits_multiple( int config_stats_read_data_waits_multiple_param );
        do_set_config_stats_read_data_waits_multiple( config_stats_read_data_waits_multiple_param );
    endfunction

    function automatic void set_config_stats_write_address_waits_step( int config_stats_write_address_waits_step_param );
        do_set_config_stats_write_address_waits_step( config_stats_write_address_waits_step_param );
    endfunction

    function automatic void set_config_stats_write_address_waits_multiple( int config_stats_write_address_waits_multiple_param );
        do_set_config_stats_write_address_waits_multiple( config_stats_write_address_waits_multiple_param );
    endfunction

    function automatic void set_config_stats_write_data_waits_step( int config_stats_write_data_waits_step_param );
        do_set_config_stats_write_data_waits_step( config_stats_write_data_waits_step_param );
    endfunction

    function automatic void set_config_stats_write_data_waits_multiple( int config_stats_write_data_waits_multiple_param );
        do_set_config_stats_write_data_waits_multiple( config_stats_write_data_waits_multiple_param );
    endfunction

    function automatic void set_config_stats_write_response_waits_step( int config_stats_write_response_waits_step_param );
        do_set_config_stats_write_response_waits_step( config_stats_write_response_waits_step_param );
    endfunction

    function automatic void set_config_stats_write_response_waits_multiple( int config_stats_write_response_waits_multiple_param );
        do_set_config_stats_write_response_waits_multiple( config_stats_write_response_waits_multiple_param );
    endfunction


    //------------------------------------------------------------------------------
    // Functions to get global variables with read access
    //------------------------------------------------------------------------------
    function automatic axi4_interface_type_e get_config_interface_type(  );
        return do_get_config_interface_type(  );
    endfunction

    function automatic bit get_config_clk_init_value(  );
        return do_get_config_clk_init_value(  );
    endfunction

    function automatic longint unsigned get_config_clk_phase_shift(  );
        return do_get_config_clk_phase_shift(  );
    endfunction

    function automatic longint unsigned get_config_clk_1st_time(  );
        return do_get_config_clk_1st_time(  );
    endfunction

    function automatic longint unsigned get_config_clk_2nd_time(  );
        return do_get_config_clk_2nd_time(  );
    endfunction

    function automatic longint unsigned get_config_setup_time(  );
        return do_get_config_setup_time(  );
    endfunction

    function automatic longint unsigned get_config_hold_time(  );
        return do_get_config_hold_time(  );
    endfunction

    function automatic int unsigned get_config_burst_timeout_factor(  );
        return do_get_config_burst_timeout_factor(  );
    endfunction

    function automatic int unsigned get_config_max_transaction_time_factor(  );
        return do_get_config_max_transaction_time_factor(  );
    endfunction

    function automatic int get_config_write_ctrl_first_ratio(  );
        return do_get_config_write_ctrl_first_ratio(  );
    endfunction

    function automatic int get_config_write_data_first_ratio(  );
        return do_get_config_write_data_first_ratio(  );
    endfunction

    function automatic int get_config_reset_low_clocks(  );
        return do_get_config_reset_low_clocks(  );
    endfunction

    function automatic int get_config_reset_hold_time(  );
        return do_get_config_reset_hold_time(  );
    endfunction

    function automatic bit get_config_enable_rlast(  );
        return do_get_config_enable_rlast(  );
    endfunction

    function automatic bit get_config_enable_slave_exclusive(  );
        return do_get_config_enable_slave_exclusive(  );
    endfunction

    function automatic bit get_config_enable_burst_reserved_value(  );
        return do_get_config_enable_burst_reserved_value(  );
    endfunction

    function automatic bit [15:0]  get_config_enable_cache_value(  );
        return do_get_config_enable_cache_value(  );
    endfunction

    function automatic bit   get_config_enable_cache_value_index1( int _this_dot_1 );
        return do_get_config_enable_cache_value_index1( _this_dot_1 );
    endfunction

    function automatic axi4_error_e get_internal_dummy_variable(  );
        return do_get_internal_dummy_variable(  );
    endfunction

    function automatic bit get_config_axi4lite_interface(  );
        return do_get_config_axi4lite_interface(  );
    endfunction

    function automatic bit [((AXI4_ID_WIDTH) - 1):0]   get_config_axi4lite_tr_id(  );
        return do_get_config_axi4lite_tr_id(  );
    endfunction

    function automatic bit   get_config_axi4lite_tr_id_index1( int _this_dot_1 );
        return do_get_config_axi4lite_tr_id_index1( _this_dot_1 );
    endfunction

    function automatic bit get_config_enable_all_assertions(  );
        return do_get_config_enable_all_assertions(  );
    endfunction

    function automatic bit [255:0]  get_config_enable_assertion(  );
        return do_get_config_enable_assertion(  );
    endfunction

    function automatic bit   get_config_enable_assertion_index1( int _this_dot_1 );
        return do_get_config_enable_assertion_index1( _this_dot_1 );
    endfunction

    function automatic bit [255:0]  get_config_enable_error(  );
        return do_get_config_enable_error(  );
    endfunction

    function automatic bit   get_config_enable_error_index1( int _this_dot_1 );
        return do_get_config_enable_error_index1( _this_dot_1 );
    endfunction

    function automatic int unsigned get_config_max_latency_AWVALID_assertion_to_AWREADY(  );
        return do_get_config_max_latency_AWVALID_assertion_to_AWREADY(  );
    endfunction

    function automatic int unsigned get_config_max_latency_ARVALID_assertion_to_ARREADY(  );
        return do_get_config_max_latency_ARVALID_assertion_to_ARREADY(  );
    endfunction

    function automatic int unsigned get_config_max_latency_RVALID_assertion_to_RREADY(  );
        return do_get_config_max_latency_RVALID_assertion_to_RREADY(  );
    endfunction

    function automatic int unsigned get_config_max_latency_BVALID_assertion_to_BREADY(  );
        return do_get_config_max_latency_BVALID_assertion_to_BREADY(  );
    endfunction

    function automatic int unsigned get_config_max_latency_WVALID_assertion_to_WREADY(  );
        return do_get_config_max_latency_WVALID_assertion_to_WREADY(  );
    endfunction

    function automatic bit get_config_enable_qos(  );
        return do_get_config_enable_qos(  );
    endfunction

    function automatic bit get_config_enable_region_support(  );
        return do_get_config_enable_region_support(  );
    endfunction

    function automatic int get_config_slave_regions(  );
        return do_get_config_slave_regions(  );
    endfunction

    function automatic bit [((AXI4_REGION_MAP_SIZE) - 1):0] [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]   get_config_region(  );
        return do_get_config_region(  );
    endfunction

    function automatic bit [((2 * AXI4_ADDRESS_WIDTH + 4 + 1) - 1):0]   get_config_region_index1( int _this_dot_1 );
        return do_get_config_region_index1( _this_dot_1 );
    endfunction

    function automatic bit   get_config_region_index2( int _this_dot_1, int _this_dot_2 );
        return do_get_config_region_index2( _this_dot_1, _this_dot_2 );
    endfunction

    function automatic bit get_region_error_state(  );
        return do_get_region_error_state(  );
    endfunction

    function automatic _region_map_lb_t get_region_map_lb(  );
        return do_get_region_map_lb(  );
    endfunction

    function automatic longint unsigned get_region_map_lb_index1( int _this_dot_1 );
        return do_get_region_map_lb_index1( _this_dot_1 );
    endfunction

    function automatic _region_map_ub_t get_region_map_ub(  );
        return do_get_region_map_ub(  );
    endfunction

    function automatic longint unsigned get_region_map_ub_index1( int _this_dot_1 );
        return do_get_region_map_ub_index1( _this_dot_1 );
    endfunction

    function automatic _region_map_region_t get_region_map_region(  );
        return do_get_region_map_region(  );
    endfunction

    function automatic byte unsigned get_region_map_region_index1( int _this_dot_1 );
        return do_get_region_map_region_index1( _this_dot_1 );
    endfunction

    function automatic _cacheable_t get_cacheable(  );
        return do_get_cacheable(  );
    endfunction

    function automatic byte unsigned get_cacheable_index1( int _this_dot_1 );
        return do_get_cacheable_index1( _this_dot_1 );
    endfunction

    function automatic int unsigned get_config_read_data_reordering_depth(  );
        return do_get_config_read_data_reordering_depth(  );
    endfunction

    function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_start_addr(  );
        return do_get_config_slave_start_addr(  );
    endfunction

    function automatic bit   get_config_slave_start_addr_index1( int _this_dot_1 );
        return do_get_config_slave_start_addr_index1( _this_dot_1 );
    endfunction

    function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_end_addr(  );
        return do_get_config_slave_end_addr(  );
    endfunction

    function automatic bit   get_config_slave_end_addr_index1( int _this_dot_1 );
        return do_get_config_slave_end_addr_index1( _this_dot_1 );
    endfunction

    function automatic int get_config_slave_enabled_non_contiguous_address_spaces(  );
        return do_get_config_slave_enabled_non_contiguous_address_spaces(  );
    endfunction

    function automatic bit get_config_slave_possess_multiple_non_contiguous_address_spaces(  );
        return do_get_config_slave_possess_multiple_non_contiguous_address_spaces(  );
    endfunction

    function automatic bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_multiple_non_contiguous_start_address_range(  );
        return do_get_config_slave_multiple_non_contiguous_start_address_range(  );
    endfunction

    function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_multiple_non_contiguous_start_address_range_index1( int _this_dot_1 );
        return do_get_config_slave_multiple_non_contiguous_start_address_range_index1( _this_dot_1 );
    endfunction

    function automatic bit   get_config_slave_multiple_non_contiguous_start_address_range_index2( int _this_dot_1, int _this_dot_2 );
        return do_get_config_slave_multiple_non_contiguous_start_address_range_index2( _this_dot_1, _this_dot_2 );
    endfunction

    function automatic bit [((256) - 1):0] [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_multiple_non_contiguous_end_address_range(  );
        return do_get_config_slave_multiple_non_contiguous_end_address_range(  );
    endfunction

    function automatic bit [((AXI4_ADDRESS_WIDTH) - 1):0]   get_config_slave_multiple_non_contiguous_end_address_range_index1( int _this_dot_1 );
        return do_get_config_slave_multiple_non_contiguous_end_address_range_index1( _this_dot_1 );
    endfunction

    function automatic bit   get_config_slave_multiple_non_contiguous_end_address_range_index2( int _this_dot_1, int _this_dot_2 );
        return do_get_config_slave_multiple_non_contiguous_end_address_range_index2( _this_dot_1, _this_dot_2 );
    endfunction

    function automatic bit get_config_protect_ready(  );
        return do_get_config_protect_ready(  );
    endfunction

    function automatic bit get_master_end_tlm_status(  );
        return do_get_master_end_tlm_status(  );
    endfunction

    function automatic bit get_master_end_wlm_status(  );
        return do_get_master_end_wlm_status(  );
    endfunction

    function automatic bit get_slave_end_tlm_status(  );
        return do_get_slave_end_tlm_status(  );
    endfunction

    function automatic bit get_slave_end_wlm_status(  );
        return do_get_slave_end_wlm_status(  );
    endfunction

    function automatic bit get_clock_source_end_tlm_status(  );
        return do_get_clock_source_end_tlm_status(  );
    endfunction

    function automatic bit get_clock_source_end_wlm_status(  );
        return do_get_clock_source_end_wlm_status(  );
    endfunction

    function automatic bit get_reset_source_end_tlm_status(  );
        return do_get_reset_source_end_tlm_status(  );
    endfunction

    function automatic bit get_reset_source_end_wlm_status(  );
        return do_get_reset_source_end_wlm_status(  );
    endfunction

    function automatic int get_config_max_outstanding_wr(  );
        return do_get_config_max_outstanding_wr(  );
    endfunction

    function automatic int get_config_max_outstanding_rd(  );
        return do_get_config_max_outstanding_rd(  );
    endfunction

    function automatic int get_config_num_outstanding_wr_phase(  );
        return do_get_config_num_outstanding_wr_phase(  );
    endfunction

    function automatic int get_config_num_outstanding_rd_phase(  );
        return do_get_config_num_outstanding_rd_phase(  );
    endfunction

    function automatic bit get_config_enable_warnings(  );
        return do_get_config_enable_warnings(  );
    endfunction

    function automatic bit get_config_enable_errors(  );
        return do_get_config_enable_errors(  );
    endfunction

    function automatic bit get_config_enable_exclusive_checks(  );
        return do_get_config_enable_exclusive_checks(  );
    endfunction

    function automatic bit get_config_warn_on_slave_errors(  );
        return do_get_config_warn_on_slave_errors(  );
    endfunction

    function automatic bit get_config_error_on_deleted_valid_cycles(  );
        return do_get_config_error_on_deleted_valid_cycles(  );
    endfunction

    function automatic bit get_config_stats_enable(  );
        return do_get_config_stats_enable(  );
    endfunction

    function automatic bit get_config_stats_enable_read_occupancy(  );
        return do_get_config_stats_enable_read_occupancy(  );
    endfunction

    function automatic bit get_config_stats_enable_write_occupancy(  );
        return do_get_config_stats_enable_write_occupancy(  );
    endfunction

    function automatic bit get_config_stats_enable_read_data_occupancy(  );
        return do_get_config_stats_enable_read_data_occupancy(  );
    endfunction

    function automatic bit get_config_stats_enable_write_data_occupancy(  );
        return do_get_config_stats_enable_write_data_occupancy(  );
    endfunction

    function automatic bit get_config_stats_enable_read_latency(  );
        return do_get_config_stats_enable_read_latency(  );
    endfunction

    function automatic bit get_config_stats_enable_write_latency(  );
        return do_get_config_stats_enable_write_latency(  );
    endfunction

    function automatic bit get_config_stats_enable_read_address_waits(  );
        return do_get_config_stats_enable_read_address_waits(  );
    endfunction

    function automatic bit get_config_stats_enable_read_data_waits(  );
        return do_get_config_stats_enable_read_data_waits(  );
    endfunction

    function automatic bit get_config_stats_enable_write_address_waits(  );
        return do_get_config_stats_enable_write_address_waits(  );
    endfunction

    function automatic bit get_config_stats_enable_write_data_waits(  );
        return do_get_config_stats_enable_write_data_waits(  );
    endfunction

    function automatic bit get_config_stats_enable_write_response_waits(  );
        return do_get_config_stats_enable_write_response_waits(  );
    endfunction

    function automatic bit get_config_stats_enable_read_bandwidth(  );
        return do_get_config_stats_enable_read_bandwidth(  );
    endfunction

    function automatic bit get_config_stats_enable_write_bandwidth(  );
        return do_get_config_stats_enable_write_bandwidth(  );
    endfunction

    function automatic int get_stats_rw_transaction_last_duration(  );
        return do_get_stats_rw_transaction_last_duration(  );
    endfunction

    function automatic int get_config_stats_read_occupancy_step(  );
        return do_get_config_stats_read_occupancy_step(  );
    endfunction

    function automatic int get_config_stats_read_occupancy_multiple(  );
        return do_get_config_stats_read_occupancy_multiple(  );
    endfunction

    function automatic bit get_stats_read_active(  );
        return do_get_stats_read_active(  );
    endfunction

    function automatic int get_stats_read_occupancy_sw(  );
        return do_get_stats_read_occupancy_sw(  );
    endfunction

    function automatic int get_stats_read_idle_sw(  );
        return do_get_stats_read_idle_sw(  );
    endfunction

    function automatic int get_stats_read_occupancy_min(  );
        return do_get_stats_read_occupancy_min(  );
    endfunction

    function automatic int get_stats_read_idle_min(  );
        return do_get_stats_read_idle_min(  );
    endfunction

    function automatic int get_stats_read_occupancy_max(  );
        return do_get_stats_read_occupancy_max(  );
    endfunction

    function automatic int get_stats_read_idle_max(  );
        return do_get_stats_read_idle_max(  );
    endfunction

    function automatic int get_stats_read_occupancy_mean(  );
        return do_get_stats_read_occupancy_mean(  );
    endfunction

    function automatic int get_stats_read_idle_mean(  );
        return do_get_stats_read_idle_mean(  );
    endfunction

    function automatic int get_stats_read_last_duration(  );
        return do_get_stats_read_last_duration(  );
    endfunction

    function automatic int get_config_stats_write_occupancy_step(  );
        return do_get_config_stats_write_occupancy_step(  );
    endfunction

    function automatic int get_config_stats_write_occupancy_multiple(  );
        return do_get_config_stats_write_occupancy_multiple(  );
    endfunction

    function automatic bit get_stats_write_active(  );
        return do_get_stats_write_active(  );
    endfunction

    function automatic int get_stats_write_occupancy_sw(  );
        return do_get_stats_write_occupancy_sw(  );
    endfunction

    function automatic int get_stats_write_idle_sw(  );
        return do_get_stats_write_idle_sw(  );
    endfunction

    function automatic int get_stats_write_occupancy_min(  );
        return do_get_stats_write_occupancy_min(  );
    endfunction

    function automatic int get_stats_write_idle_min(  );
        return do_get_stats_write_idle_min(  );
    endfunction

    function automatic int get_stats_write_occupancy_max(  );
        return do_get_stats_write_occupancy_max(  );
    endfunction

    function automatic int get_stats_write_idle_max(  );
        return do_get_stats_write_idle_max(  );
    endfunction

    function automatic int get_stats_write_occupancy_mean(  );
        return do_get_stats_write_occupancy_mean(  );
    endfunction

    function automatic int get_stats_write_idle_mean(  );
        return do_get_stats_write_idle_mean(  );
    endfunction

    function automatic int get_stats_write_last_duration(  );
        return do_get_stats_write_last_duration(  );
    endfunction

    function automatic int get_config_stats_read_data_occupancy_step(  );
        return do_get_config_stats_read_data_occupancy_step(  );
    endfunction

    function automatic int get_config_stats_read_data_occupancy_multiple(  );
        return do_get_config_stats_read_data_occupancy_multiple(  );
    endfunction

    function automatic int get_stats_read_data_occupancy_sw(  );
        return do_get_stats_read_data_occupancy_sw(  );
    endfunction

    function automatic int get_stats_read_data_idle_sw(  );
        return do_get_stats_read_data_idle_sw(  );
    endfunction

    function automatic int get_stats_read_data_occupancy_min(  );
        return do_get_stats_read_data_occupancy_min(  );
    endfunction

    function automatic int get_stats_read_data_idle_min(  );
        return do_get_stats_read_data_idle_min(  );
    endfunction

    function automatic int get_stats_read_data_occupancy_max(  );
        return do_get_stats_read_data_occupancy_max(  );
    endfunction

    function automatic int get_stats_read_data_idle_max(  );
        return do_get_stats_read_data_idle_max(  );
    endfunction

    function automatic int get_stats_read_data_occupancy_mean(  );
        return do_get_stats_read_data_occupancy_mean(  );
    endfunction

    function automatic int get_stats_read_data_idle_mean(  );
        return do_get_stats_read_data_idle_mean(  );
    endfunction

    function automatic int get_config_stats_write_data_occupancy_step(  );
        return do_get_config_stats_write_data_occupancy_step(  );
    endfunction

    function automatic int get_config_stats_write_data_occupancy_multiple(  );
        return do_get_config_stats_write_data_occupancy_multiple(  );
    endfunction

    function automatic int get_stats_write_data_occupancy_sw(  );
        return do_get_stats_write_data_occupancy_sw(  );
    endfunction

    function automatic int get_stats_write_data_idle_sw(  );
        return do_get_stats_write_data_idle_sw(  );
    endfunction

    function automatic int get_stats_write_data_occupancy_min(  );
        return do_get_stats_write_data_occupancy_min(  );
    endfunction

    function automatic int get_stats_write_data_idle_min(  );
        return do_get_stats_write_data_idle_min(  );
    endfunction

    function automatic int get_stats_write_data_occupancy_max(  );
        return do_get_stats_write_data_occupancy_max(  );
    endfunction

    function automatic int get_stats_write_data_idle_max(  );
        return do_get_stats_write_data_idle_max(  );
    endfunction

    function automatic int get_stats_write_data_occupancy_mean(  );
        return do_get_stats_write_data_occupancy_mean(  );
    endfunction

    function automatic int get_stats_write_data_idle_mean(  );
        return do_get_stats_write_data_idle_mean(  );
    endfunction

    function automatic int get_config_stats_read_bandwidth_step(  );
        return do_get_config_stats_read_bandwidth_step(  );
    endfunction

    function automatic int get_config_stats_read_bandwidth_multiple(  );
        return do_get_config_stats_read_bandwidth_multiple(  );
    endfunction

    function automatic int get_stats_read_bandwidth_sw(  );
        return do_get_stats_read_bandwidth_sw(  );
    endfunction

    function automatic int get_stats_read_bandwidth_min(  );
        return do_get_stats_read_bandwidth_min(  );
    endfunction

    function automatic int get_stats_read_bandwidth_max(  );
        return do_get_stats_read_bandwidth_max(  );
    endfunction

    function automatic int get_stats_read_bandwidth_mean(  );
        return do_get_stats_read_bandwidth_mean(  );
    endfunction

    function automatic int get_config_stats_write_bandwidth_step(  );
        return do_get_config_stats_write_bandwidth_step(  );
    endfunction

    function automatic int get_config_stats_write_bandwidth_multiple(  );
        return do_get_config_stats_write_bandwidth_multiple(  );
    endfunction

    function automatic int get_stats_write_bandwidth_sw(  );
        return do_get_stats_write_bandwidth_sw(  );
    endfunction

    function automatic int get_stats_write_bandwidth_min(  );
        return do_get_stats_write_bandwidth_min(  );
    endfunction

    function automatic int get_stats_write_bandwidth_max(  );
        return do_get_stats_write_bandwidth_max(  );
    endfunction

    function automatic int get_stats_write_bandwidth_mean(  );
        return do_get_stats_write_bandwidth_mean(  );
    endfunction

    function automatic int get_config_stats_read_latency_step(  );
        return do_get_config_stats_read_latency_step(  );
    endfunction

    function automatic int get_config_stats_read_latency_multiple(  );
        return do_get_config_stats_read_latency_multiple(  );
    endfunction

    function automatic int get_stats_read_address_data_latency_inst(  );
        return do_get_stats_read_address_data_latency_inst(  );
    endfunction

    function automatic int get_stats_read_address_data_latency_sw(  );
        return do_get_stats_read_address_data_latency_sw(  );
    endfunction

    function automatic int get_stats_read_address_data_latency_min(  );
        return do_get_stats_read_address_data_latency_min(  );
    endfunction

    function automatic int get_stats_read_address_data_latency_max(  );
        return do_get_stats_read_address_data_latency_max(  );
    endfunction

    function automatic int get_stats_read_address_data_latency_mean(  );
        return do_get_stats_read_address_data_latency_mean(  );
    endfunction

    function automatic int get_stats_read_address_address_latency_inst(  );
        return do_get_stats_read_address_address_latency_inst(  );
    endfunction

    function automatic int get_stats_read_address_address_latency_sw(  );
        return do_get_stats_read_address_address_latency_sw(  );
    endfunction

    function automatic int get_stats_read_address_address_latency_min(  );
        return do_get_stats_read_address_address_latency_min(  );
    endfunction

    function automatic int get_stats_read_address_address_latency_max(  );
        return do_get_stats_read_address_address_latency_max(  );
    endfunction

    function automatic int get_stats_read_address_address_latency_mean(  );
        return do_get_stats_read_address_address_latency_mean(  );
    endfunction

    function automatic int get_config_stats_write_latency_step(  );
        return do_get_config_stats_write_latency_step(  );
    endfunction

    function automatic int get_config_stats_write_latency_multiple(  );
        return do_get_config_stats_write_latency_multiple(  );
    endfunction

    function automatic int get_stats_write_address_response_latency_inst(  );
        return do_get_stats_write_address_response_latency_inst(  );
    endfunction

    function automatic int get_stats_write_address_response_latency_sw(  );
        return do_get_stats_write_address_response_latency_sw(  );
    endfunction

    function automatic int get_stats_write_address_response_latency_min(  );
        return do_get_stats_write_address_response_latency_min(  );
    endfunction

    function automatic int get_stats_write_address_response_latency_max(  );
        return do_get_stats_write_address_response_latency_max(  );
    endfunction

    function automatic int get_stats_write_address_response_latency_mean(  );
        return do_get_stats_write_address_response_latency_mean(  );
    endfunction

    function automatic int get_stats_write_address_address_latency_inst(  );
        return do_get_stats_write_address_address_latency_inst(  );
    endfunction

    function automatic int get_stats_write_address_address_latency_sw(  );
        return do_get_stats_write_address_address_latency_sw(  );
    endfunction

    function automatic int get_stats_write_address_address_latency_min(  );
        return do_get_stats_write_address_address_latency_min(  );
    endfunction

    function automatic int get_stats_write_address_address_latency_max(  );
        return do_get_stats_write_address_address_latency_max(  );
    endfunction

    function automatic int get_stats_write_address_address_latency_mean(  );
        return do_get_stats_write_address_address_latency_mean(  );
    endfunction

    function automatic int get_config_stats_read_address_waits_step(  );
        return do_get_config_stats_read_address_waits_step(  );
    endfunction

    function automatic int get_config_stats_read_address_waits_multiple(  );
        return do_get_config_stats_read_address_waits_multiple(  );
    endfunction

    function automatic int get_stats_read_address_waits_inst(  );
        return do_get_stats_read_address_waits_inst(  );
    endfunction

    function automatic int get_stats_read_address_waits_sw(  );
        return do_get_stats_read_address_waits_sw(  );
    endfunction

    function automatic int get_stats_read_address_waits_min(  );
        return do_get_stats_read_address_waits_min(  );
    endfunction

    function automatic int get_stats_read_address_waits_max(  );
        return do_get_stats_read_address_waits_max(  );
    endfunction

    function automatic int get_stats_read_address_waits_mean(  );
        return do_get_stats_read_address_waits_mean(  );
    endfunction

    function automatic int get_config_stats_read_data_waits_step(  );
        return do_get_config_stats_read_data_waits_step(  );
    endfunction

    function automatic int get_config_stats_read_data_waits_multiple(  );
        return do_get_config_stats_read_data_waits_multiple(  );
    endfunction

    function automatic int get_stats_read_data_waits_inst(  );
        return do_get_stats_read_data_waits_inst(  );
    endfunction

    function automatic int get_stats_read_data_waits_sw(  );
        return do_get_stats_read_data_waits_sw(  );
    endfunction

    function automatic int get_stats_read_data_waits_min(  );
        return do_get_stats_read_data_waits_min(  );
    endfunction

    function automatic int get_stats_read_data_waits_max(  );
        return do_get_stats_read_data_waits_max(  );
    endfunction

    function automatic int get_stats_read_data_waits_mean(  );
        return do_get_stats_read_data_waits_mean(  );
    endfunction

    function automatic int get_config_stats_write_address_waits_step(  );
        return do_get_config_stats_write_address_waits_step(  );
    endfunction

    function automatic int get_config_stats_write_address_waits_multiple(  );
        return do_get_config_stats_write_address_waits_multiple(  );
    endfunction

    function automatic int get_stats_write_address_waits_inst(  );
        return do_get_stats_write_address_waits_inst(  );
    endfunction

    function automatic int get_stats_write_address_waits_sw(  );
        return do_get_stats_write_address_waits_sw(  );
    endfunction

    function automatic int get_stats_write_address_waits_min(  );
        return do_get_stats_write_address_waits_min(  );
    endfunction

    function automatic int get_stats_write_address_waits_max(  );
        return do_get_stats_write_address_waits_max(  );
    endfunction

    function automatic int get_stats_write_address_waits_mean(  );
        return do_get_stats_write_address_waits_mean(  );
    endfunction

    function automatic int get_config_stats_write_data_waits_step(  );
        return do_get_config_stats_write_data_waits_step(  );
    endfunction

    function automatic int get_config_stats_write_data_waits_multiple(  );
        return do_get_config_stats_write_data_waits_multiple(  );
    endfunction

    function automatic int get_stats_write_data_waits_inst(  );
        return do_get_stats_write_data_waits_inst(  );
    endfunction

    function automatic int get_stats_write_data_waits_sw(  );
        return do_get_stats_write_data_waits_sw(  );
    endfunction

    function automatic int get_stats_write_data_waits_min(  );
        return do_get_stats_write_data_waits_min(  );
    endfunction

    function automatic int get_stats_write_data_waits_max(  );
        return do_get_stats_write_data_waits_max(  );
    endfunction

    function automatic int get_stats_write_data_waits_mean(  );
        return do_get_stats_write_data_waits_mean(  );
    endfunction

    function automatic int get_config_stats_write_response_waits_step(  );
        return do_get_config_stats_write_response_waits_step(  );
    endfunction

    function automatic int get_config_stats_write_response_waits_multiple(  );
        return do_get_config_stats_write_response_waits_multiple(  );
    endfunction

    function automatic int get_stats_write_response_waits_inst(  );
        return do_get_stats_write_response_waits_inst(  );
    endfunction

    function automatic int get_stats_write_response_waits_sw(  );
        return do_get_stats_write_response_waits_sw(  );
    endfunction

    function automatic int get_stats_write_response_waits_min(  );
        return do_get_stats_write_response_waits_min(  );
    endfunction

    function automatic int get_stats_write_response_waits_max(  );
        return do_get_stats_write_response_waits_max(  );
    endfunction

    function automatic int get_stats_write_response_waits_mean(  );
        return do_get_stats_write_response_waits_mean(  );
    endfunction

    function automatic int get_reordering_depth_of_last_read_transaction(  );
        return do_get_reordering_depth_of_last_read_transaction(  );
    endfunction


    //------------------------------------------------------------------------------
    // Function to get last database handle
    //------------------------------------------------------------------------------

    function longint get_last_handle();
        return do_get_last_handle();
    endfunction

    //------------------------------------------------------------------------------
    // Function to get last start time
    //------------------------------------------------------------------------------

    function longint get_last_start_time();
        return do_get_last_start_time();
    endfunction

    //------------------------------------------------------------------------------
    // Function to get last end time
    //------------------------------------------------------------------------------

    function longint get_last_end_time();
        return do_get_last_end_time();
    endfunction


    //------------------------------------------------------------------------------
    // Functions to set/get generic interface configuration
    //------------------------------------------------------------------------------

    function void set_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0,
        input int arg10 = 0
    );
        do_set_interface( what, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10 );
    endfunction

    function int get_interface
    (
        input int what = 0,
        input int arg1 = 0,
        input int arg2 = 0,
        input int arg3 = 0,
        input int arg4 = 0,
        input int arg5 = 0,
        input int arg6 = 0,
        input int arg7 = 0,
        input int arg8 = 0,
        input int arg9 = 0
    );
        return do_get_interface( what, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 );
    endfunction

    //------------------------------------------------------------------------------
    // Functions to get the hierarchic name of this interface
    //------------------------------------------------------------------------------
    function string get_full_name();
        return do_get_full_name();
    endfunction

    //------------------------------------------------------------------------------
    // Functions to set/get the abstraction levels of interface ends
    //------------------------------------------------------------------------------
    function void axi4_set_master_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        do_axi4_set_master_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi4_get_master_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        do_axi4_get_master_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi4_set_slave_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        do_axi4_set_slave_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi4_get_slave_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        do_axi4_get_slave_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi4_set_clock_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        do_axi4_set_clock_source_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi4_get_clock_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        do_axi4_get_clock_source_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi4_set_reset_source_abstraction_level
    (
        input bit          wire_level,
        input bit          TLM_level
    );
        do_axi4_set_reset_source_abstraction_level( wire_level, TLM_level );
    endfunction

    function void axi4_get_reset_source_abstraction_level
    (
        output bit         wire_level,
        output bit         TLM_level
    );
        do_axi4_get_reset_source_abstraction_level( wire_level, TLM_level );
    endfunction


    //------------------------------------------------------------------------------
    // Interface end access functions
    //------------------------------------------------------------------------------

    function longint get_axi4_master_end();
        return do_get_axi4_master_end();
    endfunction

    function longint get_axi4_slave_end();
        return do_get_axi4_slave_end();
    endfunction

    function longint get_axi4_clock_source_end();
        return do_get_axi4_clock_source_end();
    endfunction

    function longint get_axi4_reset_source_end();
        return do_get_axi4_reset_source_end();
    endfunction

    function longint get_axi4__monitor_end();
        return do_get_axi4__monitor_end();
    endfunction


    //------------------------------------------------------------------------------
    // Transaction interface
    //------------------------------------------------------------------------------
    task automatic dvc_activate_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref axi4_rw_e read_or_write,
        ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi4_prot_e prot,
        ref bit [3:0] region,
        ref axi4_size_e size,
        ref axi4_burst_e burst,
        ref axi4_lock_e lock,
        ref axi4_cache_e cache,
        ref bit [3:0] qos,
        ref bit [((AXI4_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] burst_length,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        ref int address_valid_delay,
        ref int data_valid_delay[],
        ref int write_response_valid_delay,
        ref int address_ready_delay,
        ref int data_ready_delay[],
        ref int write_response_ready_delay,
        ref bit write_data_with_address,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0
    );
        do_dvc_activate_rw_transaction(_comms_semantic, _as_end,read_or_write,addr,prot,region,size,burst,lock,cache,qos,id,burst_length,addr_user_data,data_words,write_strobes,wdata_user_data,resp,resp_user_data,address_valid_delay,data_valid_delay,write_response_valid_delay,address_ready_delay,data_ready_delay,write_response_ready_delay,write_data_with_address,write_address_to_data_delay,write_data_to_address_delay,write_data_beats_delay,_unit_id);
    endtask

    task automatic dvc_get_rw_transaction
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi4_rw_e read_or_write,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((((AXI4_RDATA_WIDTH > AXI4_WDATA_WIDTH) ? AXI4_RDATA_WIDTH : AXI4_WDATA_WIDTH)) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        output int address_valid_delay,
        ref int data_valid_delay[],
        output int write_response_valid_delay,
        output int address_ready_delay,
        ref int data_ready_delay[],
        output int write_response_ready_delay,
        output bit write_data_with_address,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_rw_transaction(_comms_semantic, _as_end,read_or_write,addr,prot,region,size,burst,lock,cache,qos,id,burst_length,addr_user_data,data_words,write_strobes,wdata_user_data,resp,resp_user_data,address_valid_delay,data_valid_delay,write_response_valid_delay,address_ready_delay,data_ready_delay,write_response_ready_delay,write_data_with_address,write_address_to_data_delay,write_data_to_address_delay,write_data_beats_delay,_unit_id,_using);
    endtask

    task automatic dvc_activate_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi4_prot_e prot,
        ref int rresp_delays[255:0],
        ref bit [3:0] region,
        ref axi4_size_e size,
        ref axi4_burst_e burst,
        ref axi4_lock_e lock,
        ref axi4_cache_e cache,
        ref bit [3:0] qos,
        ref bit [((AXI4_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] burst_length,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_RDATA_WIDTH) - 1):0] data_words [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int address_valid_delay,
        input int _unit_id = 0
    );
        do_dvc_activate_read(_comms_semantic, _as_end,addr,prot,rresp_delays,region,size,burst,lock,cache,qos,id,burst_length,addr_user_data,data_words,resp,resp_user_data,addr_start_time,addr_end_time,data_start_time,data_end_time,address_valid_delay,_unit_id);
    endtask

    task automatic dvc_get_read
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        ref int rresp_delays[255:0],
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_RDATA_WIDTH) - 1):0] data_words [],
        ref axi4_response_e resp[],
        ref bit [((AXI4_USER_WIDTH) - 1):0] resp_user_data [],
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output int address_valid_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read(_comms_semantic, _as_end,addr,prot,rresp_delays,region,size,burst,lock,cache,qos,id,burst_length,addr_user_data,data_words,resp,resp_user_data,addr_start_time,addr_end_time,data_start_time,data_end_time,address_valid_delay,_unit_id,_using);
    endtask

    task automatic dvc_activate_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        ref bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        ref axi4_prot_e prot,
        ref int bresp_delay,
        ref bit [3:0] region,
        ref axi4_size_e size,
        ref axi4_burst_e burst,
        ref axi4_lock_e lock,
        ref axi4_cache_e cache,
        ref bit [3:0] qos,
        ref bit [((AXI4_ID_WIDTH) - 1):0]  id,
        ref bit [7:0] burst_length,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        ref axi4_response_e resp,
        ref bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        ref longint addr_start_time,
        ref longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref longint wr_resp_start_time,
        ref longint wr_resp_end_time,
        ref int address_valid_delay,
        ref int write_address_to_data_delay,
        ref int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0
    );
        do_dvc_activate_write(_comms_semantic, _as_end,addr,prot,bresp_delay,region,size,burst,lock,cache,qos,id,burst_length,addr_user_data,data_words,write_strobes,wdata_user_data,resp,resp_user_data,addr_start_time,addr_end_time,data_start_time,data_end_time,wr_resp_start_time,wr_resp_end_time,address_valid_delay,write_address_to_data_delay,write_data_to_address_delay,write_data_beats_delay,_unit_id);
    endtask

    task automatic dvc_get_write
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output int bresp_delay,
        output bit [3:0] region,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [7:0] burst_length,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user_data,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] wdata_user_data [],
        output axi4_response_e resp,
        output bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        output longint addr_start_time,
        output longint addr_end_time,
        ref longint data_start_time[],
        ref longint data_end_time[],
        output longint wr_resp_start_time,
        output longint wr_resp_end_time,
        output int address_valid_delay,
        output int write_address_to_data_delay,
        output int write_data_to_address_delay,
        ref int write_data_beats_delay[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write(_comms_semantic, _as_end,addr,prot,bresp_delay,region,size,burst,lock,cache,qos,id,burst_length,addr_user_data,data_words,write_strobes,wdata_user_data,resp,resp_user_data,addr_start_time,addr_end_time,data_start_time,data_end_time,wr_resp_start_time,wr_resp_end_time,address_valid_delay,write_address_to_data_delay,write_data_to_address_delay,write_data_beats_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int burst_length,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] user_data [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int write_data_beats_delay[],
        input int _unit_id = 0
    );
        do_dvc_put_write_data_burst(_comms_semantic, _as_end,burst_length,data_words,write_strobes,user_data,data_start_time,data_end_time,write_data_beats_delay,_unit_id);
    endtask

    task automatic dvc_get_write_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output int burst_length,
        ref bit [((AXI4_WDATA_WIDTH) - 1):0] data_words [],
        ref bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0] write_strobes [],
        ref bit [((AXI4_USER_WIDTH) - 1):0] user_data [],
        ref longint data_start_time[],
        ref longint data_end_time[],
        ref int write_data_beats_delay[],
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_data_burst(_comms_semantic, _as_end,burst_length,data_words,write_strobes,user_data,data_start_time,data_end_time,write_data_beats_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input axi4_prot_e prot,
        input bit [3:0] region,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input axi4_cache_e cache,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
        do_dvc_put_read_addr_channel_phase(_comms_semantic, _as_end,addr,prot,region,burst_length,size,burst,lock,cache,qos,id,addr_user,address_valid_delay,address_ready_delay,_unit_id);
    endtask

    task automatic dvc_get_read_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_addr_channel_phase(_comms_semantic, _as_end,addr,prot,region,burst_length,size,burst,lock,cache,qos,id,addr_user,address_valid_delay,address_ready_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int _unit_id = 0
    );
        do_dvc_put_read_data_burst(_comms_semantic, _as_end,_unit_id);
    endtask

    task automatic dvc_get_read_data_burst
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_data_burst(_comms_semantic, _as_end,_unit_id,_using);
    endtask

    task automatic dvc_put_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int data_ready_delay,
        input int _unit_id = 0
    );
        do_dvc_put_read_channel_phase(_comms_semantic, _as_end,data,resp,last,id,user_data,data_ready_delay,_unit_id);
    endtask

    task automatic dvc_get_read_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_channel_phase(_comms_semantic, _as_end,data,resp,last,id,user_data,data_ready_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input axi4_prot_e prot,
        input bit [3:0] region,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input axi4_cache_e cache,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        input int address_valid_delay,
        input int address_ready_delay,
        input int _unit_id = 0
    );
        do_dvc_put_write_addr_channel_phase(_comms_semantic, _as_end,addr,prot,region,burst_length,size,burst,lock,cache,qos,id,addr_user,address_valid_delay,address_ready_delay,_unit_id);
    endtask

    task automatic dvc_get_write_addr_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output axi4_prot_e prot,
        output bit [3:0] region,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output axi4_cache_e cache,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  addr_user,
        output int address_valid_delay,
        output int address_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_addr_channel_phase(_comms_semantic, _as_end,addr,prot,region,burst_length,size,burst,lock,cache,qos,id,addr_user,address_valid_delay,address_ready_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        input bit last,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int data_ready_delay,
        input int _unit_id = 0
    );
        do_dvc_put_write_channel_phase(_comms_semantic, _as_end,data,write_strobes,last,user_data,data_ready_delay,_unit_id);
    endtask

    task automatic dvc_get_write_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  write_strobes,
        output bit last,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int data_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_channel_phase(_comms_semantic, _as_end,data,write_strobes,last,user_data,data_ready_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi4_response_e resp,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int write_response_ready_delay,
        input int _unit_id = 0
    );
        do_dvc_put_write_resp_channel_phase(_comms_semantic, _as_end,resp,id,user_data,write_response_ready_delay,_unit_id);
    endtask

    task automatic dvc_get_write_resp_channel_phase
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi4_response_e resp,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output int write_response_ready_delay,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_resp_channel_phase(_comms_semantic, _as_end,resp,id,user_data,write_response_ready_delay,_unit_id,_using);
    endtask

    task automatic dvc_put_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] region,
        input axi4_cache_e cache,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input axi4_prot_e prot,
        input int _unit_id = 0
    );
        do_dvc_put_read_addr_channel_cycle(_comms_semantic, _as_end,addr,region,cache,burst_length,size,burst,lock,qos,id,user_data,prot,_unit_id);
    endtask

    task automatic dvc_get_read_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] region,
        output axi4_cache_e cache,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output axi4_prot_e prot,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_addr_channel_cycle(_comms_semantic, _as_end,addr,region,cache,burst_length,size,burst,lock,qos,id,user_data,prot,_unit_id,_using);
    endtask

    task automatic dvc_put_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        do_dvc_put_read_addr_channel_ready(_comms_semantic, _as_end,ready,_unit_id);
    endtask

    task automatic dvc_get_read_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_addr_channel_ready(_comms_semantic, _as_end,ready,_unit_id,_using);
    endtask

    task automatic dvc_put_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
        do_dvc_put_read_channel_cycle(_comms_semantic, _as_end,data,resp,last,id,user_data,_unit_id);
    endtask

    task automatic dvc_get_read_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_channel_cycle(_comms_semantic, _as_end,data,resp,last,id,user_data,_unit_id,_using);
    endtask

    task automatic dvc_put_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        do_dvc_put_read_channel_ready(_comms_semantic, _as_end,ready,_unit_id);
    endtask

    task automatic dvc_get_read_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_read_channel_ready(_comms_semantic, _as_end,ready,_unit_id,_using);
    endtask

    task automatic dvc_put_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        input bit [3:0] region,
        input axi4_cache_e cache,
        input bit [7:0] burst_length,
        input axi4_size_e size,
        input axi4_burst_e burst,
        input axi4_lock_e lock,
        input bit [3:0] qos,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input axi4_prot_e prot,
        input int _unit_id = 0
    );
        do_dvc_put_write_addr_channel_cycle(_comms_semantic, _as_end,addr,region,cache,burst_length,size,burst,lock,qos,id,user_data,prot,_unit_id);
    endtask

    task automatic dvc_get_write_addr_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ADDRESS_WIDTH) - 1):0]  addr,
        output bit [3:0] region,
        output axi4_cache_e cache,
        output bit [7:0] burst_length,
        output axi4_size_e size,
        output axi4_burst_e burst,
        output axi4_lock_e lock,
        output bit [3:0] qos,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        output axi4_prot_e prot,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_addr_channel_cycle(_comms_semantic, _as_end,addr,region,cache,burst_length,size,burst,lock,qos,id,user_data,prot,_unit_id,_using);
    endtask

    task automatic dvc_put_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        do_dvc_put_write_addr_channel_ready(_comms_semantic, _as_end,ready,_unit_id);
    endtask

    task automatic dvc_get_write_addr_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_addr_channel_ready(_comms_semantic, _as_end,ready,_unit_id,_using);
    endtask

    task automatic dvc_put_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        input bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  strb,
        input bit last,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
        do_dvc_put_write_channel_cycle(_comms_semantic, _as_end,data,strb,last,user_data,_unit_id);
    endtask

    task automatic dvc_get_write_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_WDATA_WIDTH) - 1):0]  data,
        output bit [(((AXI4_WDATA_WIDTH / 8)) - 1):0]  strb,
        output bit last,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_channel_cycle(_comms_semantic, _as_end,data,strb,last,user_data,_unit_id,_using);
    endtask

    task automatic dvc_put_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        do_dvc_put_write_channel_ready(_comms_semantic, _as_end,ready,_unit_id);
    endtask

    task automatic dvc_get_write_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_channel_ready(_comms_semantic, _as_end,ready,_unit_id,_using);
    endtask

    task automatic dvc_put_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input axi4_response_e resp,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
        do_dvc_put_write_resp_channel_cycle(_comms_semantic, _as_end,resp,id,user_data,_unit_id);
    endtask

    task automatic dvc_get_write_resp_channel_cycle
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output axi4_response_e resp,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_resp_channel_cycle(_comms_semantic, _as_end,resp,id,user_data,_unit_id,_using);
    endtask

    task automatic dvc_put_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit ready,
        input int _unit_id = 0
    );
        do_dvc_put_write_resp_channel_ready(_comms_semantic, _as_end,ready,_unit_id);
    endtask

    task automatic dvc_get_write_resp_channel_ready
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit ready,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_write_resp_channel_ready(_comms_semantic, _as_end,ready,_unit_id,_using);
    endtask

    task automatic dvc_put_unexpected_write_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input axi4_response_e resp,
        input bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        input int _unit_id = 0
    );
        do_dvc_put_unexpected_write_response(_comms_semantic, _as_end,id,resp,resp_user_data,_unit_id);
    endtask

    task automatic dvc_get_unexpected_write_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output axi4_response_e resp,
        output bit [((AXI4_USER_WIDTH) - 1):0]  resp_user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_unexpected_write_response(_comms_semantic, _as_end,id,resp,resp_user_data,_unit_id,_using);
    endtask

    task automatic dvc_put_unexpected_read_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        input bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        input axi4_response_e resp,
        input bit last,
        input bit [((AXI4_ID_WIDTH) - 1):0]  id,
        input bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0
    );
        do_dvc_put_unexpected_read_response(_comms_semantic, _as_end,data,resp,last,id,user_data,_unit_id);
    endtask

    task automatic dvc_get_unexpected_read_response
    (
        input questa_mvc_item_comms_semantic _comms_semantic,
        input longint _as_end,
        output bit [((AXI4_RDATA_WIDTH) - 1):0]  data,
        output axi4_response_e resp,
        output bit last,
        output bit [((AXI4_ID_WIDTH) - 1):0]  id,
        output bit [((AXI4_USER_WIDTH) - 1):0]  user_data,
        input int _unit_id = 0,
        input bit _using = 0
    );
        do_dvc_get_unexpected_read_response(_comms_semantic, _as_end,data,resp,last,id,user_data,_unit_id,_using);
    endtask

    //------------------------------------------------------------------------------
    // Functions to register reports for the interface and interface-ends.
    //------------------------------------------------------------------------------
    //------------------------------------------------------------------------------
    // Tasks for registering reports
    //------------------------------------------------------------------------------
    function void register_interface_reporter( input questa_mvc_reporter _rep = null );
        register_end_point( _interface_ref, _rep );
    endfunction

    function void register_master_reporter
    (
        input questa_mvc_reporter rep = null
    );
        do_register_master_reporter( rep );
    endfunction

    function void register_slave_reporter
    (
        input questa_mvc_reporter rep = null
    );
        do_register_slave_reporter( rep );
    endfunction

    function void register_clock_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
        do_register_clock_source_reporter( rep );
    endfunction

    function void register_reset_source_reporter
    (
        input questa_mvc_reporter rep = null
    );
        do_register_reset_source_reporter( rep );
    endfunction

endclass

    (* elab_init *) axi4_implementation_class #(AXI4_ADDRESS_WIDTH, AXI4_RDATA_WIDTH, AXI4_WDATA_WIDTH, AXI4_ID_WIDTH, AXI4_USER_WIDTH, AXI4_REGION_MAP_SIZE) this_interface_class = new();

    //------------------------------------------------------------------------------
    //
    // FUNCTION: get_interface_class
    //     Return a handle to the <axi4_interface_class> API for this interface
    //
    //------------------------------------------------------------------------------
    function axi4_interface_class #(AXI4_ADDRESS_WIDTH, AXI4_RDATA_WIDTH, AXI4_WDATA_WIDTH, AXI4_ID_WIDTH, AXI4_USER_WIDTH, AXI4_REGION_MAP_SIZE) get_interface_class();
        return this_interface_class;
    endfunction

endinterface

`endif // VCS

