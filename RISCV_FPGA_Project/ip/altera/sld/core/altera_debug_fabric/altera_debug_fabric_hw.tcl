# (C) 2001-2013 Altera Corporation. All rights reserved.
# Your use of Altera Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Altera Program License Subscription 
# Agreement, Altera MegaCore Function License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Altera and sold by 
# Altera or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# TCL File Generated by Component Editor __VERSION__
# Fri Oct 09 14:05:33 BST 2009
# DO NOT MODIFY


# +-----------------------------------
# | 
# | altera_debug_fabric "altera_debug_fabric" v1.0
# | null 2009.10.09.14:05:29
# | 
# | 
# +-----------------------------------

# +-----------------------------------
# | request TCL package from ACDS 9.1
# | 
package require -exact sopc 9.1
# | 
# +-----------------------------------

# +-----------------------------------
# | module altera_debug_fabric
# | 
set_module_property NAME altera_debug_fabric
set_module_property VERSION 13.1
set_module_property AUTHOR "Altera Corporation"
set_module_property INTERNAL true
set_module_property GROUP "Verification/Debug & Performance"
set_module_property DISPLAY_NAME "Avalon ST Debug Fabric"
set_module_property INSTANTIATE_IN_SYSTEM_MODULE true
set_module_property EDITABLE false
set_module_property REPORT_TO_TALKBACK true
set_module_property compose_callback compose
# | 
# +-----------------------------------

# +-----------------------------------
# | parameters
# | 
add_parameter STREAMS INTEGER 0
set_parameter_property STREAMS DEFAULT_VALUE 2
set_parameter_property STREAMS DISPLAY_NAME "Number of streams"
set_parameter_property STREAMS UNITS None
set_parameter_property STREAMS ALLOWED_RANGES 0:255
set_parameter_property STREAMS DESCRIPTION "Number of streams to be connected"
set_parameter_property STREAMS DISPLAY_HINT ""
set_parameter_property STREAMS AFFECTS_GENERATION true
set_parameter_property STREAMS HDL_PARAMETER false

add_parameter MASTERS INTEGER 0
set_parameter_property MASTERS DISPLAY_NAME "Enable debug master"
set_parameter_property MASTERS UNITS None
set_parameter_property MASTERS ALLOWED_RANGES 0:1
set_parameter_property MASTERS DESCRIPTION "Enable this if you want to connect debug slaves to your phy"
set_parameter_property MASTERS DISPLAY_HINT "boolean"
set_parameter_property MASTERS AFFECTS_GENERATION true
set_parameter_property MASTERS HDL_PARAMETER false
set_parameter_property MASTERS STATUS experimental

add_parameter USE_ROM INTEGER 0
set_parameter_property USE_ROM DISPLAY_NAME "Enable config ROM"
set_parameter_property USE_ROM UNITS None
set_parameter_property USE_ROM ALLOWED_RANGES 0:1
set_parameter_property USE_ROM DESCRIPTION "Enable this to include the experimental config ROM"
set_parameter_property USE_ROM DISPLAY_HINT "boolean"
set_parameter_property USE_ROM AFFECTS_GENERATION true
set_parameter_property USE_ROM HDL_PARAMETER false
set_parameter_property USE_ROM STATUS experimental

add_parameter STREAM_CONFIG string ""
set_parameter_property STREAM_CONFIG DISPLAY_NAME "TCL encoding of which slaves are connected"
set_parameter_property STREAM_CONFIG UNITS None
set_parameter_property STREAM_CONFIG DESCRIPTION "The debug connection transform will set this up for you"
set_parameter_property STREAM_CONFIG DISPLAY_HINT "rows:5"
set_parameter_property STREAM_CONFIG AFFECTS_GENERATION true
set_parameter_property STREAM_CONFIG HDL_PARAMETER false
set_parameter_property STREAM_CONFIG STATUS experimental

# STREAM CONFIG entries are of the form:
# {data_width 8 channel_width 2 has_mgmt 0 ready_latency 3 mfr_code 8d3 type_code 04a prefer_host {} clock clk}

add_parameter CHANNEL_WIDTH INTEGER 0
set_parameter_property CHANNEL_WIDTH DEFAULT_VALUE 8
set_parameter_property CHANNEL_WIDTH DISPLAY_NAME "Width of channel to host"
set_parameter_property CHANNEL_WIDTH UNITS None
set_parameter_property CHANNEL_WIDTH ALLOWED_RANGES 1:255
set_parameter_property CHANNEL_WIDTH DESCRIPTION "Number of bits needed to connect to host"
set_parameter_property CHANNEL_WIDTH DISPLAY_HINT ""
set_parameter_property CHANNEL_WIDTH AFFECTS_GENERATION true
set_parameter_property CHANNEL_WIDTH HDL_PARAMETER false

add_parameter ADDRESS_MAP string ""
set_parameter_property ADDRESS_MAP DISPLAY_NAME "XML encoding of which slaves are connected"
set_parameter_property ADDRESS_MAP system_info { address_map master }
set_parameter_property ADDRESS_MAP enabled false

# | 
# +-----------------------------------

# +-----------------------------------
# | display items
# | 
# | 
# +-----------------------------------

# +-----------------------------------
# | connection point clock
# | 
add_interface clk clock end

add_interface reset reset end

add_interface h2t avalon_streaming end

add_interface mgmt avalon_streaming end

add_interface t2h avalon_streaming source
set_interface_assignment h2t debug.interfaceGroup {associatedT2h t2h associatedMgmt mgmt}
# | 
# +-----------------------------------

# +-----------------------------------
# | children
# | 
add_instance clock altera_clock_bridge
set_interface_property clk export_of clock.in_clk

add_instance reset altera_reset_bridge
set_interface_property reset export_of reset.in_reset
add_connection clock.out_clk reset.clk

add_instance demux demultiplexer
set_instance_parameter_value demux bitsPerSymbol 8
set_instance_parameter_value demux symbolsPerBeat 1
set_instance_parameter_value demux errorWidth 0
set_instance_parameter_value demux inChannelWidth 1
set_instance_parameter_value demux numOutputInterfaces 2
set_instance_parameter_value demux usePackets true
set_instance_parameter_value demux useHighBitsOfChannel true
add_connection clock.out_clk demux.clk
add_connection reset.out_reset demux.reset

add_instance mux multiplexer
set_instance_parameter_value mux bitsPerSymbol 8
set_instance_parameter_value mux symbolsPerBeat 1
set_instance_parameter_value mux errorWidth 0
set_instance_parameter_value mux outChannelWidth 1
set_instance_parameter_value mux numInputInterfaces 2
set_instance_parameter_value mux usePackets true
set_instance_parameter_value mux useHighBitsOfChannel true
set_instance_parameter_value mux packetScheduling true
add_connection clock.out_clk mux.clk
add_connection reset.out_reset mux.reset

# new mgmt_demux
# has 1-bit data, no packets, same channel structure as demux above
# demux component uses ready - no option to disable
add_instance mgmt_demux demultiplexer
set_instance_parameter_value mgmt_demux bitsPerSymbol 1
set_instance_parameter_value mgmt_demux symbolsPerBeat 1
set_instance_parameter_value mgmt_demux errorWidth 0
set_instance_parameter_value mgmt_demux inChannelWidth 1
set_instance_parameter_value mgmt_demux numOutputInterfaces 2
set_instance_parameter_value mgmt_demux usePackets false
set_instance_parameter_value mgmt_demux useHighBitsOfChannel true
add_connection clock.out_clk mgmt_demux.clk
add_connection reset.out_reset mgmt_demux.reset

# | 
# +-----------------------------------

proc compose {} {
   set streams [get_parameter_value STREAMS]
   set masters [get_parameter_value MASTERS]
   set use_rom [get_parameter_value USE_ROM]
   set config  [get_parameter_value STREAM_CONFIG]
   set phyChannelWidth [get_parameter_value CHANNEL_WIDTH]


   set agents [expr 1 + $masters + $streams]
   if {$agents < 2} {
      # Mux/Demux need at least two channels
      set agents 2
   }

   # Work out how many channels the widest agent uses
   set agentChannelSpan 1
   for { set i 0 } { $i < $streams } { incr i } {
      # Set defaults first, then override with provided values
      array set conf {ready 1 mfr_code 0 type_code 0 channel_width 0}
      catch {array set conf [lindex $config $i]} 

      #send_message {text info} "Stream $i: [array get conf]"

      set channelWidth $conf(channel_width)
      set channelSpan [expr {int(pow(2, $channelWidth))} ]

      if {$agentChannelSpan < $channelSpan} {
         set agentChannelSpan $channelSpan
      }
   }
   # $agentChannelSpan is widest agent channel: 5 implies 5 channels, i.e.  ch 0, 1, 2, 3, 4
   # $maxAgentChannelWidth is width of channel signal to support agentChannelSpan, i.e. 3 bits to support 5-8 channels
   # $channelBits adds to $maxAgentChannelWidth the number of bits needed to drive the selector logic of the demux, 
   # i.e. 3 streams adds 2 more bits

   set maxAgentChannelWidth [log2ceil $agentChannelSpan]
   set channelBits [expr "[log2ceil $agents] + $maxAgentChannelWidth"]
   #send_message {text info} "maxAgentChannelWidth: $maxAgentChannelWidth  channelBits: $channelBits"

   set_instance_parameter_value demux numOutputInterfaces $agents
   set_instance_parameter_value demux inChannelWidth $channelBits

   set_instance_parameter_value mux numInputInterfaces $agents
   set_instance_parameter_value mux outChannelWidth $channelBits

   # new mgmt_demux - similar to demux above
   set_instance_parameter_value mgmt_demux numOutputInterfaces $agents
   set_instance_parameter_value mgmt_demux inChannelWidth $channelBits
   
   # adapt mgmt_demux port0 output (strip off channel signal)
   set sinkInternal mgmt_demux.out0
   if {$agentChannelSpan > 1} {
      add_avalon_adapter mgmt_demux_port_adap channel_adapter $sinkInternal clk 0
      set_instance_parameter_value mgmt_demux_port_adap outMaxChannel 0
      set_instance_parameter_value mgmt_demux_port_adap outChannelWidth 0
      add_connection $sinkInternal mgmt_demux_port_adap.in
      set sinkInternal mgmt_demux_port_adap.out
   }
   #add the null sink itself; mgmt_demux_port0 ---[Chan Adap]---null_sink
   add_instance demux_p0_sink altera_avalon_st_null_sink 
   set_instance_parameter_value demux_p0_sink inBitsPerSymbol  1
   set_instance_parameter_value demux_p0_sink inSymbolsPerBeat 1
   set_instance_parameter_value demux_p0_sink inUsePackets false
   add_connection clock.out_clk    demux_p0_sink.clk
   add_connection reset.out_reset  demux_p0_sink.reset
   add_connection $sinkInternal    demux_p0_sink.in


   set h2tInternal  demux.in
   set t2hInternal  mux.out
   set mgmtInternal mgmt_demux.in
   # add channel adapters, if needed, between ports and demux inputs / mux output
   if {$channelBits < $phyChannelWidth} {
      add_avalon_adapter h2t_channel_adap channel_adapter $h2tInternal clk 0
      set_instance_parameter_value h2t_channel_adap outMaxChannel [expr (1 << $channelBits) - 1]
      set_instance_parameter_value h2t_channel_adap outChannelWidth $channelBits
      set_instance_parameter_value h2t_channel_adap inMaxChannel [expr (1 << $phyChannelWidth) - 1]
      set_instance_parameter_value h2t_channel_adap inChannelWidth $phyChannelWidth
      add_connection h2t_channel_adap.out $h2tInternal
      set h2tInternal h2t_channel_adap.in

      add_avalon_adapter t2h_channel_adap channel_adapter $t2hInternal clk 0
      set_instance_parameter_value t2h_channel_adap inMaxChannel [expr (1 << $channelBits) - 1]
      set_instance_parameter_value t2h_channel_adap inChannelWidth $channelBits
      set_instance_parameter_value t2h_channel_adap outMaxChannel [expr (1 << $phyChannelWidth) - 1]
      set_instance_parameter_value t2h_channel_adap outChannelWidth $phyChannelWidth
      add_connection $t2hInternal t2h_channel_adap.in
      set t2hInternal t2h_channel_adap.out

      #channel adapter for new mgmt_demux - no packets, rdy signal present (but always high)
      #                  name              type            follow        clock
      add_avalon_adapter mgmt_channel_adap channel_adapter $mgmtInternal clk 0
      set_instance_parameter_value mgmt_channel_adap inUseReady true 
      set_instance_parameter_value mgmt_channel_adap outMaxChannel [expr (1 << $channelBits) - 1]
      set_instance_parameter_value mgmt_channel_adap outChannelWidth $channelBits
      set_instance_parameter_value mgmt_channel_adap inMaxChannel [expr (1 << $phyChannelWidth) - 1]
      set_instance_parameter_value mgmt_channel_adap inChannelWidth $phyChannelWidth
      add_connection mgmt_channel_adap.out $mgmtInternal
      set mgmtInternal mgmt_channel_adap.in
   }

   # add timing adapter for new mgmt_demux - no ready on input, though ready present internally
   # demuxes use ready signal, so using timing adapter to strip off ready
   add_avalon_adapter mgmt_time_adap timing_adapter $mgmtInternal clk 0
   set_instance_parameter_value mgmt_time_adap inUseReady  false
   set_instance_parameter_value mgmt_time_adap outUseReady true
   set_instance_parameter_value mgmt_time_adap inReadyLatency   0
   set_instance_parameter_value mgmt_time_adap outReadyLatency  0
   add_connection mgmt_time_adap.out $mgmtInternal
   set mgmtInternal mgmt_time_adap.in

   # export the muxed IO streams, i.e the inputs signals that go to the demuxes
   # and the output signals that come from the mux
   set_interface_property h2t      export_of $h2tInternal
   set_interface_property mgmt     export_of $mgmtInternal
   set_interface_property t2h      export_of $t2hInternal

   if {$use_rom != 0} {
      add_instance rom altera_debug_config_rom
      add_connection clock.out_clk rom.clk

      set inner demux.out0
      set inner [adapt_channel_h2t h2t_rom_channel $inner $maxAgentChannelWidth 0]
      add_connection $inner rom.h2t
   
      set inner mux.in0
      set inner [adapt_channel_t2h t2h_rom_channel $inner $maxAgentChannelWidth]
      add_connection rom.t2h $inner
   } else {
      add_connection demux.out0 mux.in0
   }
   
    set debug "<debug>"

   set id 1
   set chan $agentChannelSpan
   if {$masters > 0} {
      add_instance master altera_avalon_packets_to_master
      set_instance_parameter_value master EXPORT_MASTER_SIGNALS 0
      add_connection clock.out_clk master.clk
      
      set inner demux.out$id
      set inner [adapt_channel_h2t h2t_p2m_channel $inner $maxAgentChannelWidth 0]
      add_connection $inner master.in_stream

      set inner mux.in$id
      set inner [adapt_channel_t2h t2h_p2m_channel $inner $maxAgentChannelWidth]
      add_connection master.out_stream $inner
      
      add_interface master avalon start
      set_interface_property master export_of master.avalon_master
      set_interface_assignment master debug.providesServices master
      set_interface_assignment master debug.controlledBy h2t
      set_interface_assignment master debug.channelOffset $chan
      
      set debug "$debug<agent channel='$chan' typeId='0x6E:257'>"
      
      set addr_map [get_parameter_value ADDRESS_MAP]
      if {[regexp "^<address-map>.*" $addr_map] && [regexp ".*</address-map>$" $addr_map]} {
         regsub -all "</?address-map>" $addr_map "" addr_map
         set debug "$debug$addr_map"
      }
       
      set debug "$debug</agent>"
      
      incr id
      incr chan $agentChannelSpan
   }
   # newclks will be a list of clocks other than clk, i.e. clk_0, clk_1 ...
   set newclks [list clk]
   for { set i 0 } { $i < $streams } { incr i } {
      # configure the individual agent connections, h2t_i, t2h_i, mgmt_i_reset_n
      # note: entering this loop with $id = 1, so id will always be $i + 1
      
      # Set defaults first, then override with provided values
      array set conf {data_width 8 channel_width 0 has_mgmt 0 ready_latency 0 mfr_code 0 type_code 0 prefer_host {} clock clk}
      catch {array set conf [lindex $config $i]} 

      #send_message {text info} "Stream $i: chan_w $conf(channel_width) clk $conf(clock)"
 
      set h2t "h2t_$i"
      set t2h "t2h_$i"
      set mgmt "reset_$i"
      set agent_ready_latency $conf(ready_latency)
      set agent_clk           $conf(clock)

      # if stream is on new clock, add clock i/f
      if {[lsearch $newclks $agent_clk] < 0} {
         lappend newclks $agent_clk
         #             name       type  dir
         add_interface $agent_clk clock end
         #                  name       type
         add_instance cbrdg_$agent_clk altera_clock_bridge 
         #                      i/f        prop      value
         set_interface_property $agent_clk export_of cbrdg_$agent_clk.in_clk
      }

      if {$agent_clk != "clk"} {
         set async true
      } else {
         set async false
      }

      # add the channel adapters and mgmt_reset blocks for each stream
      add_interface $mgmt reset start
      #                  name            inner             muxChannelWidth       strm# clock
      adapt_channel_mgmt rst_chan_adap$i mgmt_demux.out$id $maxAgentChannelWidth $i    $agent_clk

      # if async clk, add a reset controller (synchronizer) & bridge
      if {$async} {
         add_instance mgmt_rst_synch_$i altera_reset_controller
         set_instance_parameter_value mgmt_rst_synch_$i NUM_RESET_INPUTS 1
         add_connection cbrdg_$agent_clk.out_clk mgmt_rst_synch_$i.clk clock
         add_connection mgmt_reset_$i.reset_source  mgmt_rst_synch_$i.reset_in0

         #bridge won't appear in verilog, but gives error if not instantiated here
         add_instance mgmt_rst_brdg_$i altera_reset_bridge
         set_instance_parameter_value mgmt_rst_brdg_$i NUM_RESET_OUTPUTS 1
         add_connection cbrdg_$agent_clk.out_clk mgmt_rst_brdg_$i.clk
         add_connection mgmt_rst_synch_$i.reset_out  mgmt_rst_brdg_$i.in_reset

         set_interface_property $mgmt export_of mgmt_rst_brdg_$i.out_reset
         #  mgmt_rst_brdg_$i.out_reset_1 will reset fifo & timing adapter in debug fabric
      } else {
         set_interface_property $mgmt export_of mgmt_reset_$i.reset_source
      }
      #send_message {text info} "exported reset_out connection port $i"


      add_interface $h2t avalon_streaming start
      set inner demux.out$id
      
      set_interface_assignment $h2t debug.providesServices packet
      set_interface_assignment $h2t debug.controlledBy h2t
      set_interface_assignment $h2t debug.interfaceGroup [list associatedT2h $t2h associatedMgmt $mgmt]
      set_interface_assignment $h2t debug.channelOffset $chan

      set channelWidth $conf(channel_width)
      set channelSpan [expr {int(pow(2, $channelWidth))} ]


      # h2t_i stream adapter ------------------------------------------------------------------------
      # Narrow or remove the channel signal
      set inner [adapt_channel_h2t h2t${i}_channel $inner $maxAgentChannelWidth $channelWidth $i]

      # Add a dual clock fifo if clock != clk (the host clock)
      set inner [dc_fifo_h2t h2t${i}_fifo $inner $agent_clk $i]

      # Add a timing adapter if agent ready_latency != 0
      #                           adap            inner   agent_ready_latency  clock
      set inner [adapt_timing_h2t h2t${i}_timing  $inner  $agent_ready_latency $agent_clk $i]

      set_interface_property $h2t export_of $inner

      # t2h_i stream adapter -------------------------------------------------------------------------
      add_interface $t2h avalon_streaming end

      set inner mux.in$id
      # add channel adapter if needed
      set inner [adapt_channel_t2h t2h${i}_channel $inner $maxAgentChannelWidth $channelWidth ]

      # Add a dual clock fifo if clock != clk (the host clock)
      set inner [dc_fifo_t2h t2h${i}_fifo $inner $agent_clk $i]

      # add timing adapter if agent ready_latency != 0
      set inner [adapt_timing_t2h t2h${i}_timing  $inner  $agent_ready_latency $agent_clk $i]

      set_interface_property $t2h export_of $inner
      # ---------------------------------------------------------------------------------------------

      set mfr_code  $conf(mfr_code)
      set type_code $conf(type_code)

      set debug "$debug<agent channel='$chan' channelCount='$channelSpan' typeId='$mfr_code:$type_code'"
      set debug "$debug>"
      
      # TODO: If agent provided some XML then insert that here...
      
      set debug "$debug</agent>"
      
      incr id
      incr chan $agentChannelSpan
   }

   if {$id == 1} {
      # Loopback the spare connection if there aren't any agents
      add_connection demux.out$id mux.in$id
   }

    set debug "$debug</debug>"
   if {$use_rom != 0} {
      set_instance_parameter_value rom DEBUG_FUNCTIONS $debug
      send_message {text info} "Config ROM XML: $debug"
    }
}

proc adapt_channel_h2t {adap inner muxChannelWidth agentChannelWidth i} {
   if {$muxChannelWidth > $agentChannelWidth} {
      add_avalon_adapter $adap channel_adapter $inner clk $i
      #inMaxChannel, inChannelWidth set by add_avalon_adapter proc
      set_instance_parameter_value $adap outMaxChannel [expr (1 << $agentChannelWidth) - 1]
      set_instance_parameter_value $adap outChannelWidth $agentChannelWidth

      add_connection $inner $adap.in
      set inner $adap.out
   }
   return $inner
}

proc adapt_channel_t2h {adap inner muxChannelWidth agentChannelWidth} {
   if {$muxChannelWidth > $agentChannelWidth} {
      add_avalon_adapter $adap channel_adapter $inner clk 0

      set_instance_parameter_value $adap inMaxChannel [expr (1 << $agentChannelWidth) - 1]
      set_instance_parameter_value $adap inChannelWidth $agentChannelWidth
      set_instance_parameter_value $adap outMaxChannel [expr (1 << $muxChannelWidth) - 1]
      set_instance_parameter_value $adap outChannelWidth $muxChannelWidth

      add_connection $adap.out $inner
      set inner $adap.in
   }
   return $inner
}

proc adapt_timing_h2t {adap inner agent_Ready_Latency agent_clk i} {
   if {$agent_Ready_Latency > 0} {
      add_avalon_adapter $adap timing_adapter $inner $agent_clk $i
      set_instance_parameter_value $adap inUseReady  true
      set_instance_parameter_value $adap outUseReady true
      set_instance_parameter_value $adap inReadyLatency 0
      set_instance_parameter_value $adap outReadyLatency $agent_Ready_Latency
      add_connection $inner $adap.in
      set inner $adap.out
   }
   return $inner
}

proc adapt_timing_t2h {adap inner agent_Ready_Latency agent_clk i } {
   if {$agent_Ready_Latency > 0} {
      add_avalon_adapter $adap timing_adapter $inner $agent_clk $i
      set_instance_parameter_value $adap inUseReady  true
      set_instance_parameter_value $adap outUseReady true
      set_instance_parameter_value $adap inReadyLatency $agent_Ready_Latency
      set_instance_parameter_value $adap outReadyLatency 0
      add_connection $adap.out $inner
      set inner $adap.in
   }
   return $inner
}

proc dc_fifo_h2t {name inner agent_clk i} {
   if {$agent_clk != "clk"} {
# can't use add_instance - dc_fifo has non-standard parameter names
      add_instance $name altera_avalon_dc_fifo
      add_connection clock.out_clk                  $name.in_clk
      add_connection cbrdg_$agent_clk.out_clk       $name.out_clk
      add_connection reset.out_reset                $name.in_clk_reset
      add_connection mgmt_rst_synch_$i.reset_out    $name.out_clk_reset reset

      regsub "\\..*" $inner "" mod
      regsub ".*\\." $inner "" intf
      
      set_instance_parameter_value $name SYMBOLS_PER_BEAT [get_instance_interface_property $mod $intf symbolsPerBeat]
      set_instance_parameter_value $name BITS_PER_SYMBOL  [get_instance_interface_property $mod $intf dataBitsPerSymbol]

      set startChannel [get_instance_interface_property $mod $intf maxChannel]
      set_instance_parameter_value $name CHANNEL_WIDTH    [log2ceil [expr {$startChannel + 1} ]]      
      set_instance_parameter_value $name USE_PACKETS      [has_port_with_role $mod $intf endofpacket]
      add_connection $inner $name.in
      set inner $name.out
   }
   return $inner
}

proc dc_fifo_t2h {name inner agent_clk i} {
   if {$agent_clk != "clk"} {
# can't use add_instance - dc_fifo has non-standard parameter names
      add_instance $name altera_avalon_dc_fifo
      add_connection clock.out_clk                 $name.out_clk
      add_connection cbrdg_$agent_clk.out_clk      $name.in_clk
      add_connection reset.out_reset               $name.out_clk_reset
      add_connection mgmt_rst_synch_$i.reset_out   $name.in_clk_reset reset

      regsub "\\..*" $inner "" mod
      regsub ".*\\." $inner "" intf
      
      set_instance_parameter_value $name SYMBOLS_PER_BEAT [get_instance_interface_property $mod $intf symbolsPerBeat]
      set_instance_parameter_value $name BITS_PER_SYMBOL  [get_instance_interface_property $mod $intf dataBitsPerSymbol]

      set startChannel [get_instance_interface_property $mod $intf maxChannel]
      set_instance_parameter_value $name CHANNEL_WIDTH    [log2ceil [expr {$startChannel + 1} ]]      
      set_instance_parameter_value $name USE_PACKETS      [has_port_with_role $mod $intf endofpacket]
      add_connection $name.out $inner
      set inner $name.in
   }
   return $inner
}


# adap is name for adapter, inner is name of preceding connection point, mgmt_demux.out$id
# muxChannelWidth is width of the channel signal of mgmt_demux.out$id, i.e. maxChannelWidth
# i just controls naming of mgmt_reset_$i block
proc adapt_channel_mgmt {adap inner muxChannelWidth i agent_clk} {
   #send_message {text info} "Adapt channel mgmt:  adap $adap: inner $inner: muxChanW $muxChannelWidth: i $i"
   if {$muxChannelWidth > 0} {
      add_avalon_adapter $adap channel_adapter $inner clk $i
      #inMaxChannel, inChannelWidth set by add_avalon_adapter proc
      set_instance_parameter_value $adap outMaxChannel 0
      set_instance_parameter_value $adap outChannelWidth 0

      add_connection $inner $adap.in
      set inner $adap.out
   }
   add_instance  mgmt_reset_$i altera_mgmt_reset
   #altera_mgmt_has no parameters - just connect clk and reset
   add_connection clock.out_clk      mgmt_reset_$i.clk
   add_connection reset.out_reset    mgmt_reset_$i.reset
   add_connection $inner             mgmt_reset_$i.mgmt
}


proc add_avalon_adapter {name type follow adap_clk i} {
   add_instance $name $type
   #send_message {text info} "add_avalon_adapter: name $name: type $type: follow $follow"
   if {$adap_clk == "clk"} {
      add_connection clock.out_clk $name.clk
      add_connection reset.out_reset $name.reset
   } else {
      add_connection cbrdg_$adap_clk.out_clk $name.clk
      add_connection mgmt_rst_synch_$i.reset_out $name.reset 
   }

   regsub "\\..*" $follow "" mod
   regsub ".*\\." $follow "" intf

   set_instance_parameter_value $name inBitsPerSymbol [get_instance_interface_property $mod $intf dataBitsPerSymbol]
   set_instance_parameter_value $name inSymbolsPerBeat [get_instance_interface_property $mod $intf symbolsPerBeat]

   set startChannel [get_instance_interface_property $mod $intf maxChannel]
   set_instance_parameter_value $name inChannelWidth [log2ceil [expr {$startChannel + 1} ]]
   set_instance_parameter_value $name inMaxChannel $startChannel

   set_instance_parameter_value $name inUseReady   [has_port_with_role $mod $intf ready]
   set_instance_parameter_value $name inUsePackets [has_port_with_role $mod $intf endofpacket]

   set readyLatency [get_instance_interface_property $mod $intf readyLatency]
   set_instance_parameter_value $name inReadyLatency $readyLatency
}

proc has_port_with_role {mod intf expect} {
   foreach name [get_instance_interface_ports $mod $intf] {
      set role [get_instance_port_property $mod $name role]
      if {$role == $expect} {
         return true
      }
   }
   return false
}

proc log2ceil x "expr {int(ceil(log(\$x)/[expr log(2)]))}"
